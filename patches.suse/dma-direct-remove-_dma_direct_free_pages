From: Christoph Hellwig <hch@lst.de>
Date: Tue, 29 Oct 2019 09:57:09 +0100
Subject: dma-direct: remove __dma_direct_free_pages
Git-commit: acaade1af3587132e7ea585f470a95261e14f60c
Patch-mainline: v5.5-rc1
References: bsc#1175898, ECO-2743

We can just call dma_free_contiguous directly instead of wrapping it.

Signed-off-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Max Filippov <jcmvbkbc@gmail.com>
Acked-by: Joerg Roedel <jroedel@suse.de>
---
 include/linux/dma-direct.h |    1 -
 kernel/dma/direct.c        |   11 +++--------
 kernel/dma/remap.c         |    4 ++--
 3 files changed, 5 insertions(+), 11 deletions(-)

--- a/include/linux/dma-direct.h
+++ b/include/linux/dma-direct.h
@@ -70,6 +70,5 @@ void dma_direct_free_pages(struct device
 		dma_addr_t dma_addr, unsigned long attrs);
 struct page *__dma_direct_alloc_pages(struct device *dev, size_t size,
 		dma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs);
-void __dma_direct_free_pages(struct device *dev, size_t size, struct page *page);
 int dma_direct_supported(struct device *dev, u64 mask);
 #endif /* _LINUX_DMA_DIRECT_H */
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@ -152,7 +152,7 @@ void *dma_direct_alloc_pages(struct devi
 		 * so log an error and fail.
 		 */
 		dev_info(dev, "Rejecting highmem page from CMA.\n");
-		__dma_direct_free_pages(dev, size, page);
+		dma_free_contiguous(dev, page, size);
 		return NULL;
 	}
 
@@ -174,11 +174,6 @@ void *dma_direct_alloc_pages(struct devi
 	return ret;
 }
 
-void __dma_direct_free_pages(struct device *dev, size_t size, struct page *page)
-{
-	dma_free_contiguous(dev, page, size);
-}
-
 void dma_direct_free_pages(struct device *dev, size_t size, void *cpu_addr,
 		dma_addr_t dma_addr, unsigned long attrs)
 {
@@ -187,7 +182,7 @@ void dma_direct_free_pages(struct device
 	if ((attrs & DMA_ATTR_NO_KERNEL_MAPPING) &&
 	    !force_dma_unencrypted(dev)) {
 		/* cpu_addr is a struct page cookie, not a kernel address */
-		__dma_direct_free_pages(dev, size, cpu_addr);
+		dma_free_contiguous(dev, cpu_addr, size);
 		return;
 	}
 
@@ -197,7 +192,7 @@ void dma_direct_free_pages(struct device
 	if (IS_ENABLED(CONFIG_ARCH_HAS_UNCACHED_SEGMENT) &&
 	    dma_alloc_need_uncached(dev, attrs))
 		cpu_addr = cached_kernel_address(cpu_addr);
-	__dma_direct_free_pages(dev, size, virt_to_page(cpu_addr));
+	dma_free_contiguous(dev, virt_to_page(cpu_addr), size);
 }
 
 void *dma_direct_alloc(struct device *dev, size_t size,
--- a/kernel/dma/remap.c
+++ b/kernel/dma/remap.c
@@ -229,7 +229,7 @@ void *arch_dma_alloc(struct device *dev,
 			dma_pgprot(dev, PAGE_KERNEL, attrs),
 			__builtin_return_address(0));
 	if (!ret) {
-		__dma_direct_free_pages(dev, size, page);
+		dma_free_contiguous(dev, page, size);
 		return ret;
 	}
 
@@ -247,7 +247,7 @@ void arch_dma_free(struct device *dev, s
 		struct page *page = pfn_to_page(__phys_to_pfn(phys));
 
 		vunmap(vaddr);
-		__dma_direct_free_pages(dev, size, page);
+		dma_free_contiguous(dev, page, size);
 	}
 }
 
