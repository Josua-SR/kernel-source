From: Sven Schnelle <svens@linux.ibm.com>
Date: Mon, 21 Sep 2020 17:23:42 +0200
Subject: s390/stp: unify stp_work_mutex and clock_sync_mutex
Git-commit: ad5ceb33eee128346475f5efa672e6402ae15e51
Patch-mainline: v5.10-rc1
References: jsc#SLE-13821

No need to have two mutexes, and while at it rename it to
stp_mutex.

Signed-off-by: Sven Schnelle <svens@linux.ibm.com>
Reviewed-by: Alexander Egorenkov <egorenar@linux.ibm.com>
Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 arch/s390/kernel/time.c |   53 +++++++++++++++++++++++-------------------------
 1 file changed, 26 insertions(+), 27 deletions(-)

--- a/arch/s390/kernel/time.c
+++ b/arch/s390/kernel/time.c
@@ -350,7 +350,7 @@ void __init time_init(void)
 }
 
 static DEFINE_PER_CPU(atomic_t, clock_sync_word);
-static DEFINE_MUTEX(clock_sync_mutex);
+static DEFINE_MUTEX(stp_mutex);
 static unsigned long clock_sync_flags;
 
 #define CLOCK_SYNC_HAS_STP		0
@@ -501,7 +501,6 @@ static struct stp_sstpi stp_info;
 static void *stp_page;
 
 static void stp_work_fn(struct work_struct *work);
-static DEFINE_MUTEX(stp_work_mutex);
 static DECLARE_WORK(stp_work, stp_work_fn);
 static struct timer_list stp_timer;
 
@@ -737,7 +736,7 @@ static void stp_work_fn(struct work_stru
 	int rc;
 
 	/* prevent multiple execution. */
-	mutex_lock(&stp_work_mutex);
+	mutex_lock(&stp_mutex);
 
 	if (!stp_online) {
 		chsc_sstpc(stp_page, STP_OP_CTRL, 0x0000, NULL);
@@ -772,7 +771,7 @@ static void stp_work_fn(struct work_stru
 		stp_check_leap();
 
 out_unlock:
-	mutex_unlock(&stp_work_mutex);
+	mutex_unlock(&stp_mutex);
 }
 
 /*
@@ -789,11 +788,11 @@ static ssize_t stp_ctn_id_show(struct de
 {
 	ssize_t ret = -ENODATA;
 
-	mutex_lock(&stp_work_mutex);
+	mutex_lock(&stp_mutex);
 	if (stpinfo_valid())
 		ret = sprintf(buf, "%016llx\n",
 			      *(unsigned long long *) stp_info.ctnid);
-	mutex_unlock(&stp_work_mutex);
+	mutex_unlock(&stp_mutex);
 	return ret;
 }
 
@@ -805,10 +804,10 @@ static ssize_t stp_ctn_type_show(struct
 {
 	ssize_t ret = -ENODATA;
 
-	mutex_lock(&stp_work_mutex);
+	mutex_lock(&stp_mutex);
 	if (stpinfo_valid())
 		ret = sprintf(buf, "%i\n", stp_info.ctn);
-	mutex_unlock(&stp_work_mutex);
+	mutex_unlock(&stp_mutex);
 	return ret;
 }
 
@@ -820,10 +819,10 @@ static ssize_t stp_dst_offset_show(struc
 {
 	ssize_t ret = -ENODATA;
 
-	mutex_lock(&stp_work_mutex);
+	mutex_lock(&stp_mutex);
 	if (stpinfo_valid() && (stp_info.vbits & 0x2000))
 		ret = sprintf(buf, "%i\n", (int)(s16) stp_info.dsto);
-	mutex_unlock(&stp_work_mutex);
+	mutex_unlock(&stp_mutex);
 	return ret;
 }
 
@@ -835,10 +834,10 @@ static ssize_t stp_leap_seconds_show(str
 {
 	ssize_t ret = -ENODATA;
 
-	mutex_lock(&stp_work_mutex);
+	mutex_lock(&stp_mutex);
 	if (stpinfo_valid() && (stp_info.vbits & 0x8000))
 		ret = sprintf(buf, "%i\n", (int)(s16) stp_info.leaps);
-	mutex_unlock(&stp_work_mutex);
+	mutex_unlock(&stp_mutex);
 	return ret;
 }
 
@@ -851,14 +850,14 @@ static ssize_t leap_seconds_scheduled_sh
 	struct stp_stzi stzi;
 	ssize_t ret;
 
-	mutex_lock(&stp_work_mutex);
+	mutex_lock(&stp_mutex);
 	if (!stpinfo_valid() || !(stp_info.vbits & 0x8000) || !stp_info.lu) {
-		mutex_unlock(&stp_work_mutex);
+		mutex_unlock(&stp_mutex);
 		return -ENODATA;
 	}
 
 	ret = chsc_stzi(stp_page, &stzi, sizeof(stzi));
-	mutex_unlock(&stp_work_mutex);
+	mutex_unlock(&stp_mutex);
 	if (ret < 0)
 		return ret;
 
@@ -878,10 +877,10 @@ static ssize_t stp_stratum_show(struct d
 {
 	ssize_t ret = -ENODATA;
 
-	mutex_lock(&stp_work_mutex);
+	mutex_lock(&stp_mutex);
 	if (stpinfo_valid())
 		ret = sprintf(buf, "%i\n", (int)(s16) stp_info.stratum);
-	mutex_unlock(&stp_work_mutex);
+	mutex_unlock(&stp_mutex);
 	return ret;
 }
 
@@ -893,10 +892,10 @@ static ssize_t stp_time_offset_show(stru
 {
 	ssize_t ret = -ENODATA;
 
-	mutex_lock(&stp_work_mutex);
+	mutex_lock(&stp_mutex);
 	if (stpinfo_valid() && (stp_info.vbits & 0x0800))
 		ret = sprintf(buf, "%i\n", (int) stp_info.tto);
-	mutex_unlock(&stp_work_mutex);
+	mutex_unlock(&stp_mutex);
 	return ret;
 }
 
@@ -908,10 +907,10 @@ static ssize_t stp_time_zone_offset_show
 {
 	ssize_t ret = -ENODATA;
 
-	mutex_lock(&stp_work_mutex);
+	mutex_lock(&stp_mutex);
 	if (stpinfo_valid() && (stp_info.vbits & 0x4000))
 		ret = sprintf(buf, "%i\n", (int)(s16) stp_info.tzo);
-	mutex_unlock(&stp_work_mutex);
+	mutex_unlock(&stp_mutex);
 	return ret;
 }
 
@@ -924,10 +923,10 @@ static ssize_t stp_timing_mode_show(stru
 {
 	ssize_t ret = -ENODATA;
 
-	mutex_lock(&stp_work_mutex);
+	mutex_lock(&stp_mutex);
 	if (stpinfo_valid())
 		ret = sprintf(buf, "%i\n", stp_info.tmd);
-	mutex_unlock(&stp_work_mutex);
+	mutex_unlock(&stp_mutex);
 	return ret;
 }
 
@@ -939,10 +938,10 @@ static ssize_t stp_timing_state_show(str
 {
 	ssize_t ret = -ENODATA;
 
-	mutex_lock(&stp_work_mutex);
+	mutex_lock(&stp_mutex);
 	if (stpinfo_valid())
 		ret = sprintf(buf, "%i\n", stp_info.tst);
-	mutex_unlock(&stp_work_mutex);
+	mutex_unlock(&stp_mutex);
 	return ret;
 }
 
@@ -966,14 +965,14 @@ static ssize_t stp_online_store(struct d
 		return -EINVAL;
 	if (!test_bit(CLOCK_SYNC_HAS_STP, &clock_sync_flags))
 		return -EOPNOTSUPP;
-	mutex_lock(&clock_sync_mutex);
+	mutex_lock(&stp_mutex);
 	stp_online = value;
 	if (stp_online)
 		set_bit(CLOCK_SYNC_STP, &clock_sync_flags);
 	else
 		clear_bit(CLOCK_SYNC_STP, &clock_sync_flags);
 	queue_work(time_sync_wq, &stp_work);
-	mutex_unlock(&clock_sync_mutex);
+	mutex_unlock(&stp_mutex);
 	return count;
 }
 
