From: =?UTF-8?q?Christian=20K=C3=B6nig?= <christian.koenig@amd.com>
Date: Thu, 16 Feb 2017 14:25:30 +0100
Subject: drm/ttm: cleanup coding style in ttm_bo_api.h
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: ba87349ed31ee623f3380b5feedaf16a8dfa25bf
Patch-mainline: v4.16-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Extern is the default for function declerations anyway and this
solves a bunch of 80char per line issues.

Signed-off-by: Christian König <christian.koenig@amd.com>
Reviewed-by: Michel Dänzer <michel.daenzer@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 include/drm/ttm/ttm_bo_api.h |  131 +++++++++++++++++--------------------------
 1 file changed, 54 insertions(+), 77 deletions(-)

--- a/include/drm/ttm/ttm_bo_api.h
+++ b/include/drm/ttm/ttm_bo_api.h
@@ -288,8 +288,7 @@ ttm_bo_reference(struct ttm_buffer_objec
  * Returns -EBUSY if no_wait is true and the buffer is busy.
  * Returns -ERESTARTSYS if interrupted by a signal.
  */
-extern int ttm_bo_wait(struct ttm_buffer_object *bo,
-		       bool interruptible, bool no_wait);
+int ttm_bo_wait(struct ttm_buffer_object *bo, bool interruptible, bool no_wait);
 
 /**
  * ttm_bo_mem_compat - Check if proposed placement is compatible with a bo
@@ -300,9 +299,8 @@ extern int ttm_bo_wait(struct ttm_buffer
  *
  * Returns true if the placement is compatible
  */
-extern bool ttm_bo_mem_compat(struct ttm_placement *placement,
-			      struct ttm_mem_reg *mem,
-			      uint32_t *new_flags);
+bool ttm_bo_mem_compat(struct ttm_placement *placement, struct ttm_mem_reg *mem,
+		       uint32_t *new_flags);
 
 /**
  * ttm_bo_validate
@@ -320,10 +318,10 @@ extern bool ttm_bo_mem_compat(struct ttm
  * -EBUSY if no_wait is true and buffer busy.
  * -ERESTARTSYS if interrupted by a signal.
  */
-extern int ttm_bo_validate(struct ttm_buffer_object *bo,
-				struct ttm_placement *placement,
-				bool interruptible,
-				bool no_wait_gpu);
+int ttm_bo_validate(struct ttm_buffer_object *bo,
+		    struct ttm_placement *placement,
+		    bool interruptible,
+		    bool no_wait_gpu);
 
 /**
  * ttm_bo_unref
@@ -332,7 +330,7 @@ extern int ttm_bo_validate(struct ttm_bu
  *
  * Unreference and clear a pointer to a buffer object.
  */
-extern void ttm_bo_unref(struct ttm_buffer_object **bo);
+void ttm_bo_unref(struct ttm_buffer_object **bo);
 
 /**
  * ttm_bo_add_to_lru
@@ -344,7 +342,7 @@ extern void ttm_bo_unref(struct ttm_buff
  * This function must be called with struct ttm_bo_global::lru_lock held, and
  * is typically called immediately prior to unreserving a bo.
  */
-extern void ttm_bo_add_to_lru(struct ttm_buffer_object *bo);
+void ttm_bo_add_to_lru(struct ttm_buffer_object *bo);
 
 /**
  * ttm_bo_del_from_lru
@@ -356,7 +354,7 @@ extern void ttm_bo_add_to_lru(struct ttm
  * and is usually called just immediately after the bo has been reserved to
  * avoid recursive reservation from lru lists.
  */
-extern void ttm_bo_del_from_lru(struct ttm_buffer_object *bo);
+void ttm_bo_del_from_lru(struct ttm_buffer_object *bo);
 
 /**
  * ttm_bo_move_to_lru_tail
@@ -367,7 +365,7 @@ extern void ttm_bo_del_from_lru(struct t
  * object. This function must be called with struct ttm_bo_global::lru_lock
  * held, and is used to make a BO less likely to be considered for eviction.
  */
-extern void ttm_bo_move_to_lru_tail(struct ttm_buffer_object *bo);
+void ttm_bo_move_to_lru_tail(struct ttm_buffer_object *bo);
 
 /**
  * ttm_bo_lock_delayed_workqueue
@@ -376,15 +374,14 @@ extern void ttm_bo_move_to_lru_tail(stru
  * Returns
  * True if the workqueue was queued at the time
  */
-extern int ttm_bo_lock_delayed_workqueue(struct ttm_bo_device *bdev);
+int ttm_bo_lock_delayed_workqueue(struct ttm_bo_device *bdev);
 
 /**
  * ttm_bo_unlock_delayed_workqueue
  *
  * Allows the delayed workqueue to run.
  */
-extern void ttm_bo_unlock_delayed_workqueue(struct ttm_bo_device *bdev,
-					    int resched);
+void ttm_bo_unlock_delayed_workqueue(struct ttm_bo_device *bdev, int resched);
 
 /**
  * ttm_bo_eviction_valuable
@@ -411,8 +408,7 @@ bool ttm_bo_eviction_valuable(struct ttm
  * -EBUSY if the buffer is busy and no_wait is true.
  * -ERESTARTSYS if interrupted by a signal.
  */
-extern int
-ttm_bo_synccpu_write_grab(struct ttm_buffer_object *bo, bool no_wait);
+int ttm_bo_synccpu_write_grab(struct ttm_buffer_object *bo, bool no_wait);
 
 /**
  * ttm_bo_synccpu_write_release:
@@ -421,7 +417,7 @@ ttm_bo_synccpu_write_grab(struct ttm_buf
  *
  * Releases a synccpu lock.
  */
-extern void ttm_bo_synccpu_write_release(struct ttm_buffer_object *bo);
+void ttm_bo_synccpu_write_release(struct ttm_buffer_object *bo);
 
 /**
  * ttm_bo_acc_size
@@ -480,18 +476,18 @@ size_t ttm_bo_dma_acc_size(struct ttm_bo
  * -ERESTARTSYS: Interrupted by signal while sleeping waiting for resources.
  */
 
-extern int ttm_bo_init_reserved(struct ttm_bo_device *bdev,
-				struct ttm_buffer_object *bo,
-				unsigned long size,
-				enum ttm_bo_type type,
-				struct ttm_placement *placement,
-				uint32_t page_alignment,
-				bool interrubtible,
-				struct file *persistent_swap_storage,
-				size_t acc_size,
-				struct sg_table *sg,
-				struct reservation_object *resv,
-				void (*destroy) (struct ttm_buffer_object *));
+int ttm_bo_init_reserved(struct ttm_bo_device *bdev,
+			 struct ttm_buffer_object *bo,
+			 unsigned long size,
+			 enum ttm_bo_type type,
+			 struct ttm_placement *placement,
+			 uint32_t page_alignment,
+			 bool interrubtible,
+			 struct file *persistent_swap_storage,
+			 size_t acc_size,
+			 struct sg_table *sg,
+			 struct reservation_object *resv,
+			 void (*destroy) (struct ttm_buffer_object *));
 
 /**
  * ttm_bo_init
@@ -531,19 +527,13 @@ extern int ttm_bo_init_reserved(struct t
  * -EINVAL: Invalid placement flags.
  * -ERESTARTSYS: Interrupted by signal while sleeping waiting for resources.
  */
-
-extern int ttm_bo_init(struct ttm_bo_device *bdev,
-			struct ttm_buffer_object *bo,
-			unsigned long size,
-			enum ttm_bo_type type,
-			struct ttm_placement *placement,
-			uint32_t page_alignment,
-			bool interrubtible,
-			struct file *persistent_swap_storage,
-			size_t acc_size,
-			struct sg_table *sg,
-			struct reservation_object *resv,
-			void (*destroy) (struct ttm_buffer_object *));
+int ttm_bo_init(struct ttm_bo_device *bdev, struct ttm_buffer_object *bo,
+		unsigned long size, enum ttm_bo_type type,
+		struct ttm_placement *placement,
+		uint32_t page_alignment, bool interrubtible,
+		struct file *persistent_swap_storage, size_t acc_size,
+		struct sg_table *sg, struct reservation_object *resv,
+		void (*destroy) (struct ttm_buffer_object *));
 
 /**
  * ttm_bo_create
@@ -569,15 +559,11 @@ extern int ttm_bo_init(struct ttm_bo_dev
  * -EINVAL: Invalid placement flags.
  * -ERESTARTSYS: Interrupted by signal while waiting for resources.
  */
-
-extern int ttm_bo_create(struct ttm_bo_device *bdev,
-				unsigned long size,
-				enum ttm_bo_type type,
-				struct ttm_placement *placement,
-				uint32_t page_alignment,
-				bool interruptible,
-				struct file *persistent_swap_storage,
-				struct ttm_buffer_object **p_bo);
+int ttm_bo_create(struct ttm_bo_device *bdev, unsigned long size,
+		  enum ttm_bo_type type, struct ttm_placement *placement,
+		  uint32_t page_alignment, bool interruptible,
+		  struct file *persistent_swap_storage,
+		  struct ttm_buffer_object **p_bo);
 
 /**
  * ttm_bo_init_mm
@@ -594,9 +580,9 @@ extern int ttm_bo_create(struct ttm_bo_d
  * -ENOMEM: Not enough memory.
  * May also return driver-specified errors.
  */
+int ttm_bo_init_mm(struct ttm_bo_device *bdev, unsigned type,
+		   unsigned long p_size);
 
-extern int ttm_bo_init_mm(struct ttm_bo_device *bdev, unsigned type,
-				unsigned long p_size);
 /**
  * ttm_bo_clean_mm
  *
@@ -623,8 +609,7 @@ extern int ttm_bo_init_mm(struct ttm_bo_
  * -EINVAL: invalid or uninitialized memory type.
  * -EBUSY: There are still buffers left in this memory type.
  */
-
-extern int ttm_bo_clean_mm(struct ttm_bo_device *bdev, unsigned mem_type);
+int ttm_bo_clean_mm(struct ttm_bo_device *bdev, unsigned mem_type);
 
 /**
  * ttm_bo_evict_mm
@@ -644,8 +629,7 @@ extern int ttm_bo_clean_mm(struct ttm_bo
  * -ERESTARTSYS: The call was interrupted by a signal while waiting to
  * evict a buffer.
  */
-
-extern int ttm_bo_evict_mm(struct ttm_bo_device *bdev, unsigned mem_type);
+int ttm_bo_evict_mm(struct ttm_bo_device *bdev, unsigned mem_type);
 
 /**
  * ttm_kmap_obj_virtual
@@ -658,7 +642,6 @@ extern int ttm_bo_evict_mm(struct ttm_bo
  * If *is_iomem is 1 on return, the virtual address points to an io memory area,
  * that should strictly be accessed by the iowriteXX() and similar functions.
  */
-
 static inline void *ttm_kmap_obj_virtual(struct ttm_bo_kmap_obj *map,
 					 bool *is_iomem)
 {
@@ -682,9 +665,8 @@ static inline void *ttm_kmap_obj_virtual
  * -ENOMEM: Out of memory.
  * -EINVAL: Invalid range.
  */
-
-extern int ttm_bo_kmap(struct ttm_buffer_object *bo, unsigned long start_page,
-		       unsigned long num_pages, struct ttm_bo_kmap_obj *map);
+int ttm_bo_kmap(struct ttm_buffer_object *bo, unsigned long start_page,
+		unsigned long num_pages, struct ttm_bo_kmap_obj *map);
 
 /**
  * ttm_bo_kunmap
@@ -693,8 +675,7 @@ extern int ttm_bo_kmap(struct ttm_buffer
  *
  * Unmaps a kernel map set up by ttm_bo_kmap.
  */
-
-extern void ttm_bo_kunmap(struct ttm_bo_kmap_obj *map);
+void ttm_bo_kunmap(struct ttm_bo_kmap_obj *map);
 
 /**
  * ttm_fbdev_mmap - mmap fbdev memory backed by a ttm buffer object.
@@ -706,9 +687,7 @@ extern void ttm_bo_kunmap(struct ttm_bo_
  * This function is intended to be called by the fbdev mmap method
  * if the fbdev address space is to be backed by a bo.
  */
-
-extern int ttm_fbdev_mmap(struct vm_area_struct *vma,
-			  struct ttm_buffer_object *bo);
+int ttm_fbdev_mmap(struct vm_area_struct *vma, struct ttm_buffer_object *bo);
 
 /**
  * ttm_bo_default_iomem_pfn - get a pfn for a page offset
@@ -731,9 +710,8 @@ unsigned long ttm_bo_default_io_mem_pfn(
  * This function is intended to be called by the device mmap method.
  * if the device address space is to be backed by the bo manager.
  */
-
-extern int ttm_bo_mmap(struct file *filp, struct vm_area_struct *vma,
-		       struct ttm_bo_device *bdev);
+int ttm_bo_mmap(struct file *filp, struct vm_area_struct *vma,
+		struct ttm_bo_device *bdev);
 
 /**
  * ttm_bo_io
@@ -755,11 +733,10 @@ extern int ttm_bo_mmap(struct file *filp
  * the function may return -ERESTARTSYS if
  * interrupted by a signal.
  */
+ssize_t ttm_bo_io(struct ttm_bo_device *bdev, struct file *filp,
+		  const char __user *wbuf, char __user *rbuf,
+		  size_t count, loff_t *f_pos, bool write);
 
-extern ssize_t ttm_bo_io(struct ttm_bo_device *bdev, struct file *filp,
-			 const char __user *wbuf, char __user *rbuf,
-			 size_t count, loff_t *f_pos, bool write);
-
-extern void ttm_bo_swapout_all(struct ttm_bo_device *bdev);
-extern int ttm_bo_wait_unreserved(struct ttm_buffer_object *bo);
+void ttm_bo_swapout_all(struct ttm_bo_device *bdev);
+int ttm_bo_wait_unreserved(struct ttm_buffer_object *bo);
 #endif
