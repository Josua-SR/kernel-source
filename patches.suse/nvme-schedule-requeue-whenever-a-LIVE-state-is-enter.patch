From 10baeb16126ee8e1373968399d52e742a0699a54 Mon Sep 17 00:00:00 2001
From: Hannes Reinecke <hare@suse.de>
Date: Mon, 18 Mar 2019 11:11:46 +0100
Subject: [PATCH] nvme: schedule requeue whenever a LIVE state is entered
Patch-Mainline: submitted linux-nvme 2019/03/21
References: bsc#1123105

When undergoing state transitions I/O might be requeued, hence
we always have to schedule requeue_work whenever the nvme device
is live, independent on whether the old state was live or not.

Reported-by: Martin George <martin.george@netapp.com>
Signed-off-by: Hannes Reinecke <hare@suse.com>
---
 drivers/nvme/host/multipath.c |   10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

--- a/drivers/nvme/host/multipath.c
+++ b/drivers/nvme/host/multipath.c
@@ -385,8 +385,6 @@ static void nvme_mpath_set_live(struct n
 			__nvme_find_path(head, node);
 		srcu_read_unlock(&head->srcu, srcu_idx);
 	}
-
-	kblockd_schedule_work(&ns->head->requeue_work);
 }
 
 static int nvme_parse_ana_log(struct nvme_ctrl *ctrl, void *data,
@@ -445,8 +443,11 @@ static void nvme_update_ns_ana_state(str
 	ns->ana_state = desc->state;
 	clear_bit(NVME_NS_ANA_PENDING, &ns->flags);
 
-	if (nvme_state_is_live(ns->ana_state) && !nvme_state_is_live(old))
-		nvme_mpath_set_live(ns);
+	if (nvme_state_is_live(ns->ana_state)) {
+		if (!nvme_state_is_live(old))
+			nvme_mpath_set_live(ns);
+		kblockd_schedule_work(&ns->head->requeue_work);
+	}
 	mutex_unlock(&ns->head->lock);
 }
 
@@ -627,6 +628,7 @@ void nvme_mpath_add_disk(struct nvme_ns
 		mutex_lock(&ns->head->lock);
 		ns->ana_state = NVME_ANA_OPTIMIZED; 
 		nvme_mpath_set_live(ns);
+		kblockd_schedule_work(&ns->head->requeue_work);
 		mutex_unlock(&ns->head->lock);
 	}
 }
