From: Yunsheng Lin <linyunsheng@huawei.com>
Date: Sun, 18 Nov 2018 03:19:14 +0000
Subject: net: hns3: up/down netdev in hclge module when setting mtu
Patch-mainline: v5.0-rc1
Git-commit: cdca4c485d0c6467211f7181710122100552b4b9
References: bsc#1104353 FATE#326415

Currently netdev is down in enet module, and it is before
mtu range checking in hclge module, which may be cause
netdev being down unnecessarily.

Signed-off-by: Yunsheng Lin <linyunsheng@huawei.com>
Signed-off-by: Jian Shen <shenjian15@huawei.com>
Signed-off-by: Salil Mehta <salil.mehta@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/hisilicon/hns3/hns3_enet.c         |   11 -----------
 drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c |    3 +++
 2 files changed, 3 insertions(+), 11 deletions(-)

--- a/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
@@ -1573,18 +1573,11 @@ static int hns3_ndo_set_vf_vlan(struct n
 static int hns3_nic_change_mtu(struct net_device *netdev, int new_mtu)
 {
 	struct hnae3_handle *h = hns3_get_handle(netdev);
-	bool if_running = netif_running(netdev);
 	int ret;
 
 	if (!h->ae_algo->ops->set_mtu)
 		return -EOPNOTSUPP;
 
-	/* if this was called with netdev up then bring netdevice down */
-	if (if_running) {
-		(void)hns3_nic_net_stop(netdev);
-		msleep(100);
-	}
-
 	ret = h->ae_algo->ops->set_mtu(h, new_mtu);
 	if (ret)
 		netdev_err(netdev, "failed to change MTU in hardware %d\n",
@@ -1592,10 +1585,6 @@ static int hns3_nic_change_mtu(struct ne
 	else
 		netdev->mtu = new_mtu;
 
-	/* if the netdev was running earlier, bring it up again */
-	if (if_running && hns3_nic_net_open(netdev))
-		ret = -EINVAL;
-
 	return ret;
 }
 
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
@@ -6450,6 +6450,8 @@ int hclge_set_vport_mtu(struct hclge_vpo
 			return -EINVAL;
 		}
 
+	hclge_notify_client(hdev, HNAE3_DOWN_CLIENT);
+
 	ret = hclge_set_mac_mtu(hdev, max_frm_size);
 	if (ret) {
 		dev_err(&hdev->pdev->dev,
@@ -6466,6 +6468,7 @@ int hclge_set_vport_mtu(struct hclge_vpo
 			"Allocate buffer fail, ret =%d\n", ret);
 
 out:
+	hclge_notify_client(hdev, HNAE3_UP_CLIENT);
 	mutex_unlock(&hdev->vport_lock);
 	return ret;
 }
