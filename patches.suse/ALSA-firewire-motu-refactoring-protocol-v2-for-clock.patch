From 2b8f050e4ea97bd9851d023935e0ca5229e6905b Mon Sep 17 00:00:00 2001
From: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date: Tue, 19 May 2020 20:16:39 +0900
Subject: [PATCH] ALSA: firewire-motu: refactoring protocol v2 for clock source getter
Git-commit: 2b8f050e4ea97bd9851d023935e0ca5229e6905b
Patch-mainline: v5.8-rc1
References: jsc#SLE-16518

This commit splits the method to get clock source for protocol
version 2 so that model-dependent operations are explicitly defined.

Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Link: https://lore.kernel.org/r/20200519111641.123211-13-o-takashi@sakamocchi.jp
Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 sound/firewire/motu/motu-protocol-v2.c | 48 ++++++++++++++++++++++++++++------
 1 file changed, 40 insertions(+), 8 deletions(-)

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 1bdc905e8e22..2e6c3cc8a9e1 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -78,14 +78,10 @@ int snd_motu_protocol_v2_set_clock_rate(struct snd_motu *motu,
 					  sizeof(reg));
 }
 
-static int get_clock_source(struct snd_motu *motu, u32 data,
-			    enum snd_motu_clock_source *src)
+static int detect_clock_source_optical_model(struct snd_motu *motu, u32 data,
+					     enum snd_motu_clock_source *src)
 {
-	unsigned int index = data & V2_CLOCK_SRC_MASK;
-	if (index > 5)
-		return -EIO;
-
-	switch (index) {
+	switch (data) {
 	case 0:
 		*src = SND_MOTU_CLOCK_SOURCE_INTERNAL;
 		break;
@@ -118,12 +114,48 @@ static int get_clock_source(struct snd_motu *motu, u32 data,
 		*src = SND_MOTU_CLOCK_SOURCE_ADAT_ON_DSUB;
 		break;
 	default:
-		return -EIO;
+		*src = SND_MOTU_CLOCK_SOURCE_UNKNOWN;
+		break;
+	}
+
+	return 0;
+}
+
+static int v2_detect_clock_source(struct snd_motu *motu, u32 data,
+				  enum snd_motu_clock_source *src)
+{
+	switch (data) {
+	case 0:
+		*src = SND_MOTU_CLOCK_SOURCE_INTERNAL;
+		break;
+	case 2:
+		*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_COAX;
+		break;
+	case 3:
+		*src = SND_MOTU_CLOCK_SOURCE_SPH;
+		break;
+	case 4:
+		*src = SND_MOTU_CLOCK_SOURCE_WORD_ON_BNC;
+		break;
+	default:
+		*src = SND_MOTU_CLOCK_SOURCE_UNKNOWN;
+		break;
 	}
 
 	return 0;
 }
 
+static int get_clock_source(struct snd_motu *motu, u32 data,
+			    enum snd_motu_clock_source *src)
+{
+	data &= V2_CLOCK_SRC_MASK;
+	if (motu->spec == &snd_motu_spec_828mk2 ||
+	    motu->spec == &snd_motu_spec_traveler)
+		return detect_clock_source_optical_model(motu, data, src);
+	else
+		return v2_detect_clock_source(motu, data, src);
+}
+
 int snd_motu_protocol_v2_get_clock_source(struct snd_motu *motu,
 					  enum snd_motu_clock_source *src)
 {
-- 
2.16.4

