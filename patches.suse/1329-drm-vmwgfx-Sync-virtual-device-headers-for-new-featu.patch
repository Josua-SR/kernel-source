From ae61282d2ea79fac91dd73e006db4389591aa1ce Mon Sep 17 00:00:00 2001
From: Deepak Rawat <drawat.floss@gmail.com>
Date: Thu, 13 Dec 2018 13:39:11 -0800
Subject: drm/vmwgfx: Sync virtual device headers for new feature
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 0651dfabd96c35fddd1c2f455e5b638ba6c58993
Patch-mainline: v5.7-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

Get the latest device headers for SM5 and other features development.

v2: sync to newer bits (merge later commits)
v3: sync to even newer bits

Co-developed-by: Roland Scheidegger <sroland@vmware.com>
Signed-off-by: Deepak Rawat <drawat.floss@gmail.com>
Signed-off-by: Neha Bhende <bhenden@vmware.com>
Signed-off-by: Charmaine Lee <charmainel@vmware.com>
Signed-off-by: Roland Scheidegger <sroland@vmware.com>
Reviewed-by: Thomas Hellstr√∂m (VMware) <thomas_os@shipmail.org>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 .../drm/vmwgfx/device_include/svga3d_cmd.h    | 149 +++-
 .../vmwgfx/device_include/svga3d_devcaps.h    | 792 +++++++++---------
 .../gpu/drm/vmwgfx/device_include/svga3d_dx.h | 466 ++++++++++-
 .../drm/vmwgfx/device_include/svga3d_limits.h |  36 +-
 .../device_include/svga3d_surfacedefs.h       |  58 +-
 .../drm/vmwgfx/device_include/svga3d_types.h  | 347 +++++++-
 .../gpu/drm/vmwgfx/device_include/svga_reg.h  | 382 ++++++---
 .../drm/vmwgfx/device_include/svga_types.h    |   1 +
 8 files changed, 1646 insertions(+), 585 deletions(-)

diff --git a/drivers/gpu/drm/vmwgfx/device_include/svga3d_cmd.h b/drivers/gpu/drm/vmwgfx/device_include/svga3d_cmd.h
index 84ea8d385b0e..799bc0963f7a 100644
--- a/drivers/gpu/drm/vmwgfx/device_include/svga3d_cmd.h
+++ b/drivers/gpu/drm/vmwgfx/device_include/svga3d_cmd.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
 /**********************************************************
- * Copyright 1998-2015 VMware, Inc.
+ * Copyright 1998-2020 VMware, Inc.
  *
  * Permission is hereby granted, free of charge, to any person
  * obtaining a copy of this software and associated documentation
@@ -261,30 +261,23 @@ typedef enum {
    SVGA_3D_CMD_DX_SET_VS_CONSTANT_BUFFER_OFFSET           = 1220,
    SVGA_3D_CMD_DX_SET_PS_CONSTANT_BUFFER_OFFSET           = 1221,
    SVGA_3D_CMD_DX_SET_GS_CONSTANT_BUFFER_OFFSET           = 1222,
-
-   /*
-    * Reserve some IDs to be used for the SM5 shader types.
-    */
-   SVGA_3D_CMD_DX_RESERVED1                               = 1223,
-   SVGA_3D_CMD_DX_RESERVED2                               = 1224,
-   SVGA_3D_CMD_DX_RESERVED3                               = 1225,
+   SVGA_3D_CMD_DX_SET_HS_CONSTANT_BUFFER_OFFSET           = 1223,
+   SVGA_3D_CMD_DX_SET_DS_CONSTANT_BUFFER_OFFSET           = 1224,
+   SVGA_3D_CMD_DX_SET_CS_CONSTANT_BUFFER_OFFSET           = 1225,
 
    SVGA_3D_CMD_DX_COND_BIND_ALL_SHADER                    = 1226,
    SVGA_3D_CMD_DX_MAX                                     = 1227,
 
    SVGA_3D_CMD_SCREEN_COPY                                = 1227,
 
-   /*
-    * Reserve some IDs to be used for video.
-    */
-   SVGA_3D_CMD_VIDEO_RESERVED1                            = 1228,
-   SVGA_3D_CMD_VIDEO_RESERVED2                            = 1229,
-   SVGA_3D_CMD_VIDEO_RESERVED3                            = 1230,
-   SVGA_3D_CMD_VIDEO_RESERVED4                            = 1231,
-   SVGA_3D_CMD_VIDEO_RESERVED5                            = 1232,
-   SVGA_3D_CMD_VIDEO_RESERVED6                            = 1233,
-   SVGA_3D_CMD_VIDEO_RESERVED7                            = 1234,
-   SVGA_3D_CMD_VIDEO_RESERVED8                            = 1235,
+   SVGA_3D_CMD_RESERVED1                                  = 1228,
+   SVGA_3D_CMD_RESERVED2                                  = 1229,
+   SVGA_3D_CMD_RESERVED3                                  = 1230,
+   SVGA_3D_CMD_RESERVED4                                  = 1231,
+   SVGA_3D_CMD_RESERVED5                                  = 1232,
+   SVGA_3D_CMD_RESERVED6                                  = 1233,
+   SVGA_3D_CMD_RESERVED7                                  = 1234,
+   SVGA_3D_CMD_RESERVED8                                  = 1235,
 
    SVGA_3D_CMD_GROW_OTABLE                                = 1236,
    SVGA_3D_CMD_DX_GROW_COTABLE                            = 1237,
@@ -298,7 +291,46 @@ typedef enum {
    SVGA_3D_CMD_DX_PRED_CONVERT                            = 1243,
    SVGA_3D_CMD_WHOLE_SURFACE_COPY                         = 1244,
 
-   SVGA_3D_CMD_MAX                                        = 1245,
+   SVGA_3D_CMD_DX_DEFINE_UA_VIEW                          = 1245,
+   SVGA_3D_CMD_DX_DESTROY_UA_VIEW                         = 1246,
+   SVGA_3D_CMD_DX_CLEAR_UA_VIEW_UINT                      = 1247,
+   SVGA_3D_CMD_DX_CLEAR_UA_VIEW_FLOAT                     = 1248,
+   SVGA_3D_CMD_DX_COPY_STRUCTURE_COUNT                    = 1249,
+   SVGA_3D_CMD_DX_SET_UA_VIEWS                            = 1250,
+
+   SVGA_3D_CMD_DX_DRAW_INDEXED_INSTANCED_INDIRECT         = 1251,
+   SVGA_3D_CMD_DX_DRAW_INSTANCED_INDIRECT                 = 1252,
+   SVGA_3D_CMD_DX_DISPATCH                                = 1253,
+   SVGA_3D_CMD_DX_DISPATCH_INDIRECT                       = 1254,
+
+   SVGA_3D_CMD_WRITE_ZERO_SURFACE                         = 1255,
+   SVGA_3D_CMD_HINT_ZERO_SURFACE                          = 1256,
+   SVGA_3D_CMD_DX_TRANSFER_TO_BUFFER                      = 1257,
+   SVGA_3D_CMD_DX_SET_STRUCTURE_COUNT                     = 1258,
+
+   SVGA_3D_CMD_LOGICOPS_BITBLT                            = 1259,
+   SVGA_3D_CMD_LOGICOPS_TRANSBLT                          = 1260,
+   SVGA_3D_CMD_LOGICOPS_STRETCHBLT                        = 1261,
+   SVGA_3D_CMD_LOGICOPS_COLORFILL                         = 1262,
+   SVGA_3D_CMD_LOGICOPS_ALPHABLEND                        = 1263,
+   SVGA_3D_CMD_LOGICOPS_CLEARTYPEBLEND                    = 1264,
+
+   SVGA_3D_CMD_RESERVED2_1                                = 1265,
+
+   SVGA_3D_CMD_RESERVED2_2                                = 1266,
+   SVGA_3D_CMD_DEFINE_GB_SURFACE_V4                       = 1267,
+   SVGA_3D_CMD_DX_SET_CS_UA_VIEWS                         = 1268,
+   SVGA_3D_CMD_DX_SET_MIN_LOD                             = 1269,
+   SVGA_3D_CMD_RESERVED2_3                                = 1270,
+   SVGA_3D_CMD_RESERVED2_4                                = 1271,
+   SVGA_3D_CMD_DX_DEFINE_DEPTHSTENCIL_VIEW_V2             = 1272,
+   SVGA_3D_CMD_DX_DEFINE_STREAMOUTPUT_WITH_MOB            = 1273,
+   SVGA_3D_CMD_DX_SET_SHADER_IFACE                        = 1274,
+   SVGA_3D_CMD_DX_BIND_STREAMOUTPUT                       = 1275,
+   SVGA_3D_CMD_SURFACE_STRETCHBLT_NON_MS_TO_MS            = 1276,
+   SVGA_3D_CMD_DX_BIND_SHADER_IFACE                       = 1277,
+
+   SVGA_3D_CMD_MAX                                        = 1278,
    SVGA_3D_CMD_FUTURE_MAX                                 = 3000
 } SVGAFifo3dCmdId;
 
@@ -334,6 +366,7 @@ struct {
    uint32                      sid;
    SVGA3dSurface1Flags         surfaceFlags;
    SVGA3dSurfaceFormat         format;
+
    /*
     * If surfaceFlags has SVGA3D_SURFACE_CUBEMAP bit set, all SVGA3dSurfaceFace
     * structures must have the same value of numMipLevels field.
@@ -341,6 +374,7 @@ struct {
     * numMipLevels set to 0.
     */
    SVGA3dSurfaceFace           face[SVGA3D_MAX_SURFACE_FACES];
+
    /*
     * Followed by an SVGA3dSize structure for each mip level in each face.
     *
@@ -360,6 +394,7 @@ struct {
    uint32                      sid;
    SVGA3dSurface1Flags         surfaceFlags;
    SVGA3dSurfaceFormat         format;
+
    /*
     * If surfaceFlags has SVGA3D_SURFACE_CUBEMAP bit set, all SVGA3dSurfaceFace
     * structures must have the same value of numMipLevels field.
@@ -369,6 +404,7 @@ struct {
    SVGA3dSurfaceFace           face[SVGA3D_MAX_SURFACE_FACES];
    uint32                      multisampleCount;
    SVGA3dTextureFilter         autogenFilter;
+
    /*
     * Followed by an SVGA3dSize structure for each mip level in each face.
     *
@@ -512,6 +548,18 @@ struct {
 #include "vmware_pack_end.h"
 SVGA3dCmdWholeSurfaceCopy;               /* SVGA_3D_CMD_WHOLE_SURFACE_COPY */
 
+typedef
+#include "vmware_pack_begin.h"
+struct {
+   SVGA3dSurfaceImageId  src;
+   SVGA3dSurfaceImageId  dest;
+   SVGA3dBox boxSrc;
+   SVGA3dBox boxDest;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdSurfaceStretchBltNonMSToMS;
+/* SVGA_3D_CMD_SURFACE_STRETCHBLT_NON_MS_TO_MS */
+
 typedef
 #include "vmware_pack_begin.h"
 struct {
@@ -555,6 +603,7 @@ struct {
    SVGAGuestImage guest;
    SVGA3dSurfaceImageId host;
    SVGA3dTransferType transfer;
+
    /*
     * Followed by variable number of SVGA3dCopyBox structures. For consistency
     * in all clipping logic and coordinate translation, we define the
@@ -789,7 +838,7 @@ struct {
 
    uint32 indexBufferSid;     /* Valid index buffer sid. */
    uint32 indexBufferOffset;  /* Byte offset into the vertex buffer, almost */
-			      /* always 0 for DX9 guests, non-zero for OpenGL */
+                              /* always 0 for pre SM guests, non-zero for OpenGL */
                               /* guests.  We can't represent non-multiple of */
                               /* stride offsets in D3D9Renderer... */
    uint8 indexBufferStride;   /* Allowable values = 1, 2, or 4 */
@@ -1228,6 +1277,7 @@ struct SVGA3dCmdLogicOpsBitBlt {
    SVGA3dSurfaceImageId src;
    SVGA3dSurfaceImageId dst;
    SVGA3dLogicOp logicOp;
+   SVGA3dLogicOpRop3 logicOpRop3;
    /* Followed by variable number of SVGA3dCopyBox structures */
 }
 #include "vmware_pack_end.h"
@@ -1247,7 +1297,8 @@ struct SVGA3dCmdLogicOpsTransBlt {
    uint32 color;
    uint32 flags;
    SVGA3dBox srcBox;
-   SVGA3dBox dstBox;
+   SVGA3dSignedBox dstBox;
+   SVGA3dBox clipBox;
 }
 #include "vmware_pack_end.h"
 SVGA3dCmdLogicOpsTransBlt;   /* SVGA_3D_CMD_LOGICOPS_TRANSBLT */
@@ -1266,7 +1317,8 @@ struct SVGA3dCmdLogicOpsStretchBlt {
    uint16 mode;
    uint16 flags;
    SVGA3dBox srcBox;
-   SVGA3dBox dstBox;
+   SVGA3dSignedBox dstBox;
+   SVGA3dBox clipBox;
 }
 #include "vmware_pack_end.h"
 SVGA3dCmdLogicOpsStretchBlt;   /* SVGA_3D_CMD_LOGICOPS_STRETCHBLT */
@@ -1283,6 +1335,7 @@ struct SVGA3dCmdLogicOpsColorFill {
    SVGA3dSurfaceImageId dst;
    uint32 color;
    SVGA3dLogicOp logicOp;
+   SVGA3dLogicOpRop3 logicOpRop3;
    /* Followed by variable number of SVGA3dRect structures. */
 }
 #include "vmware_pack_end.h"
@@ -1302,7 +1355,8 @@ struct SVGA3dCmdLogicOpsAlphaBlend {
    uint32 alphaVal;
    uint32 flags;
    SVGA3dBox srcBox;
-   SVGA3dBox dstBox;
+   SVGA3dSignedBox dstBox;
+   SVGA3dBox clipBox;
 }
 #include "vmware_pack_end.h"
 SVGA3dCmdLogicOpsAlphaBlend;   /* SVGA_3D_CMD_LOGICOPS_ALPHABLEND */
@@ -1365,8 +1419,9 @@ struct {
    SVGA3dSurface2Flags surface2Flags;
    uint8 multisamplePattern;
    uint8 qualityLevel;
-   uint8  pad0[2];
-   uint32 pad1[3];
+   uint16 bufferByteStride;
+   float minLOD;
+   uint32 pad0[2];
 }
 #include "vmware_pack_end.h"
 SVGAOTableSurfaceEntry;
@@ -1543,7 +1598,7 @@ typedef
 #include "vmware_pack_begin.h"
 struct {
    SVGAOTableType type;
-   PPN baseAddress;
+   PPN32 baseAddress;
    uint32 sizeInBytes;
    uint32 validSizeInBytes;
    SVGAMobFormat ptDepth;
@@ -1599,7 +1654,7 @@ typedef
 struct SVGA3dCmdDefineGBMob {
    SVGAMobId mobid;
    SVGAMobFormat ptDepth;
-   PPN base;
+   PPN32 base;
    uint32 sizeInBytes;
 }
 #include "vmware_pack_end.h"
@@ -1618,7 +1673,6 @@ struct SVGA3dCmdDestroyGBMob {
 #include "vmware_pack_end.h"
 SVGA3dCmdDestroyGBMob;   /* SVGA_3D_CMD_DESTROY_GB_MOB */
 
-
 /*
  * Define a memory object (Mob) in the OTable with a PPN64 base.
  */
@@ -1718,6 +1772,27 @@ struct SVGA3dCmdDefineGBSurface_v3 {
 #include "vmware_pack_end.h"
 SVGA3dCmdDefineGBSurface_v3;   /* SVGA_3D_CMD_DEFINE_GB_SURFACE_V3 */
 
+/*
+ * Defines a guest-backed surface, adding buffer byte stride.
+ */
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDefineGBSurface_v4 {
+   uint32 sid;
+   SVGA3dSurfaceAllFlags surfaceFlags;
+   SVGA3dSurfaceFormat format;
+   uint32 numMipLevels;
+   uint32 multisampleCount;
+   SVGA3dMSPattern multisamplePattern;
+   SVGA3dMSQualityLevel qualityLevel;
+   SVGA3dTextureFilter autogenFilter;
+   SVGA3dSize size;
+   uint32 arraySize;
+   uint32 bufferByteStride;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDefineGBSurface_v4;   /* SVGA_3D_CMD_DEFINE_GB_SURFACE_V4 */
+
 /*
  * Destroy a guest-backed surface.
  */
@@ -2181,4 +2256,20 @@ SVGA3dCmdScreenCopy;  /* SVGA_3D_CMD_SCREEN_COPY */
 #define SVGA_SCREEN_COPY_STATUS_SUCCESS 0x01
 #define SVGA_SCREEN_COPY_STATUS_INVALID 0xFFFFFFFF
 
+typedef
+#include "vmware_pack_begin.h"
+struct {
+   uint32 sid;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdWriteZeroSurface;  /* SVGA_3D_CMD_WRITE_ZERO_SURFACE */
+
+typedef
+#include "vmware_pack_begin.h"
+struct {
+   uint32 sid;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdHintZeroSurface;  /* SVGA_3D_CMD_HINT_ZERO_SURFACE */
+
 #endif /* _SVGA3D_CMD_H_ */
diff --git a/drivers/gpu/drm/vmwgfx/device_include/svga3d_devcaps.h b/drivers/gpu/drm/vmwgfx/device_include/svga3d_devcaps.h
index 2de878b5ba16..617b468c626c 100644
--- a/drivers/gpu/drm/vmwgfx/device_include/svga3d_devcaps.h
+++ b/drivers/gpu/drm/vmwgfx/device_include/svga3d_devcaps.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
 /**********************************************************
- * Copyright 1998-2015 VMware, Inc.
+ * Copyright 1998-2019 VMware, Inc.
  *
  * Permission is hereby granted, free of charge, to any person
  * obtaining a copy of this software and associated documentation
@@ -39,6 +39,8 @@
 
 #include "includeCheck.h"
 
+#include "svga3d_types.h"
+
 /*
  * 3D Hardware Version
  *
@@ -69,386 +71,408 @@ typedef enum {
  * DevCap indexes.
  */
 
-typedef enum {
-   SVGA3D_DEVCAP_INVALID                           = ((uint32)-1),
-   SVGA3D_DEVCAP_3D                                = 0,
-   SVGA3D_DEVCAP_MAX_LIGHTS                        = 1,
-
-   /*
-    * SVGA3D_DEVCAP_MAX_TEXTURES reflects the maximum number of
-    * fixed-function texture units available. Each of these units
-    * work in both FFP and Shader modes, and they support texture
-    * transforms and texture coordinates. The host may have additional
-    * texture image units that are only usable with shaders.
-    */
-   SVGA3D_DEVCAP_MAX_TEXTURES                      = 2,
-   SVGA3D_DEVCAP_MAX_CLIP_PLANES                   = 3,
-   SVGA3D_DEVCAP_VERTEX_SHADER_VERSION             = 4,
-   SVGA3D_DEVCAP_VERTEX_SHADER                     = 5,
-   SVGA3D_DEVCAP_FRAGMENT_SHADER_VERSION           = 6,
-   SVGA3D_DEVCAP_FRAGMENT_SHADER                   = 7,
-   SVGA3D_DEVCAP_MAX_RENDER_TARGETS                = 8,
-   SVGA3D_DEVCAP_S23E8_TEXTURES                    = 9,
-   SVGA3D_DEVCAP_S10E5_TEXTURES                    = 10,
-   SVGA3D_DEVCAP_MAX_FIXED_VERTEXBLEND             = 11,
-   SVGA3D_DEVCAP_D16_BUFFER_FORMAT                 = 12,
-   SVGA3D_DEVCAP_D24S8_BUFFER_FORMAT               = 13,
-   SVGA3D_DEVCAP_D24X8_BUFFER_FORMAT               = 14,
-   SVGA3D_DEVCAP_QUERY_TYPES                       = 15,
-   SVGA3D_DEVCAP_TEXTURE_GRADIENT_SAMPLING         = 16,
-   SVGA3D_DEVCAP_MAX_POINT_SIZE                    = 17,
-   SVGA3D_DEVCAP_MAX_SHADER_TEXTURES               = 18,
-   SVGA3D_DEVCAP_MAX_TEXTURE_WIDTH                 = 19,
-   SVGA3D_DEVCAP_MAX_TEXTURE_HEIGHT                = 20,
-   SVGA3D_DEVCAP_MAX_VOLUME_EXTENT                 = 21,
-   SVGA3D_DEVCAP_MAX_TEXTURE_REPEAT                = 22,
-   SVGA3D_DEVCAP_MAX_TEXTURE_ASPECT_RATIO          = 23,
-   SVGA3D_DEVCAP_MAX_TEXTURE_ANISOTROPY            = 24,
-   SVGA3D_DEVCAP_MAX_PRIMITIVE_COUNT               = 25,
-   SVGA3D_DEVCAP_MAX_VERTEX_INDEX                  = 26,
-   SVGA3D_DEVCAP_MAX_VERTEX_SHADER_INSTRUCTIONS    = 27,
-   SVGA3D_DEVCAP_MAX_FRAGMENT_SHADER_INSTRUCTIONS  = 28,
-   SVGA3D_DEVCAP_MAX_VERTEX_SHADER_TEMPS           = 29,
-   SVGA3D_DEVCAP_MAX_FRAGMENT_SHADER_TEMPS         = 30,
-   SVGA3D_DEVCAP_TEXTURE_OPS                       = 31,
-   SVGA3D_DEVCAP_SURFACEFMT_X8R8G8B8               = 32,
-   SVGA3D_DEVCAP_SURFACEFMT_A8R8G8B8               = 33,
-   SVGA3D_DEVCAP_SURFACEFMT_A2R10G10B10            = 34,
-   SVGA3D_DEVCAP_SURFACEFMT_X1R5G5B5               = 35,
-   SVGA3D_DEVCAP_SURFACEFMT_A1R5G5B5               = 36,
-   SVGA3D_DEVCAP_SURFACEFMT_A4R4G4B4               = 37,
-   SVGA3D_DEVCAP_SURFACEFMT_R5G6B5                 = 38,
-   SVGA3D_DEVCAP_SURFACEFMT_LUMINANCE16            = 39,
-   SVGA3D_DEVCAP_SURFACEFMT_LUMINANCE8_ALPHA8      = 40,
-   SVGA3D_DEVCAP_SURFACEFMT_ALPHA8                 = 41,
-   SVGA3D_DEVCAP_SURFACEFMT_LUMINANCE8             = 42,
-   SVGA3D_DEVCAP_SURFACEFMT_Z_D16                  = 43,
-   SVGA3D_DEVCAP_SURFACEFMT_Z_D24S8                = 44,
-   SVGA3D_DEVCAP_SURFACEFMT_Z_D24X8                = 45,
-   SVGA3D_DEVCAP_SURFACEFMT_DXT1                   = 46,
-   SVGA3D_DEVCAP_SURFACEFMT_DXT2                   = 47,
-   SVGA3D_DEVCAP_SURFACEFMT_DXT3                   = 48,
-   SVGA3D_DEVCAP_SURFACEFMT_DXT4                   = 49,
-   SVGA3D_DEVCAP_SURFACEFMT_DXT5                   = 50,
-   SVGA3D_DEVCAP_SURFACEFMT_BUMPX8L8V8U8           = 51,
-   SVGA3D_DEVCAP_SURFACEFMT_A2W10V10U10            = 52,
-   SVGA3D_DEVCAP_SURFACEFMT_BUMPU8V8               = 53,
-   SVGA3D_DEVCAP_SURFACEFMT_Q8W8V8U8               = 54,
-   SVGA3D_DEVCAP_SURFACEFMT_CxV8U8                 = 55,
-   SVGA3D_DEVCAP_SURFACEFMT_R_S10E5                = 56,
-   SVGA3D_DEVCAP_SURFACEFMT_R_S23E8                = 57,
-   SVGA3D_DEVCAP_SURFACEFMT_RG_S10E5               = 58,
-   SVGA3D_DEVCAP_SURFACEFMT_RG_S23E8               = 59,
-   SVGA3D_DEVCAP_SURFACEFMT_ARGB_S10E5             = 60,
-   SVGA3D_DEVCAP_SURFACEFMT_ARGB_S23E8             = 61,
-
-   /*
-    * There is a hole in our devcap definitions for
-    * historical reasons.
-    *
-    * Define a constant just for completeness.
-    */
-   SVGA3D_DEVCAP_MISSING62                         = 62,
-
-   SVGA3D_DEVCAP_MAX_VERTEX_SHADER_TEXTURES        = 63,
-
-   /*
-    * Note that MAX_SIMULTANEOUS_RENDER_TARGETS is a maximum count of color
-    * render targets.  This does not include the depth or stencil targets.
-    */
-   SVGA3D_DEVCAP_MAX_SIMULTANEOUS_RENDER_TARGETS   = 64,
-
-   SVGA3D_DEVCAP_SURFACEFMT_V16U16                 = 65,
-   SVGA3D_DEVCAP_SURFACEFMT_G16R16                 = 66,
-   SVGA3D_DEVCAP_SURFACEFMT_A16B16G16R16           = 67,
-   SVGA3D_DEVCAP_SURFACEFMT_UYVY                   = 68,
-   SVGA3D_DEVCAP_SURFACEFMT_YUY2                   = 69,
-
-   /*
-    * Deprecated.
-    */
-   SVGA3D_DEVCAP_DEAD4                             = 70,
-   SVGA3D_DEVCAP_DEAD5                             = 71,
-   SVGA3D_DEVCAP_DEAD7                             = 72,
-   SVGA3D_DEVCAP_DEAD6                             = 73,
-
-   SVGA3D_DEVCAP_AUTOGENMIPMAPS                    = 74,
-   SVGA3D_DEVCAP_SURFACEFMT_NV12                   = 75,
-   SVGA3D_DEVCAP_SURFACEFMT_AYUV                   = 76,
-
-   /*
-    * This is the maximum number of SVGA context IDs that the guest
-    * can define using SVGA_3D_CMD_CONTEXT_DEFINE.
-    */
-   SVGA3D_DEVCAP_MAX_CONTEXT_IDS                   = 77,
-
-   /*
-    * This is the maximum number of SVGA surface IDs that the guest
-    * can define using SVGA_3D_CMD_SURFACE_DEFINE*.
-    */
-   SVGA3D_DEVCAP_MAX_SURFACE_IDS                   = 78,
-
-   SVGA3D_DEVCAP_SURFACEFMT_Z_DF16                 = 79,
-   SVGA3D_DEVCAP_SURFACEFMT_Z_DF24                 = 80,
-   SVGA3D_DEVCAP_SURFACEFMT_Z_D24S8_INT            = 81,
-
-   SVGA3D_DEVCAP_SURFACEFMT_ATI1                   = 82,
-   SVGA3D_DEVCAP_SURFACEFMT_ATI2                   = 83,
-
-   /*
-    * Deprecated.
-    */
-   SVGA3D_DEVCAP_DEAD1                             = 84,
-
-   /*
-    * This contains several SVGA_3D_CAPS_VIDEO_DECODE elements
-    * ored together, one for every type of video decoding supported.
-    */
-   SVGA3D_DEVCAP_VIDEO_DECODE                      = 85,
-
-   /*
-    * This contains several SVGA_3D_CAPS_VIDEO_PROCESS elements
-    * ored together, one for every type of video processing supported.
-    */
-   SVGA3D_DEVCAP_VIDEO_PROCESS                     = 86,
-
-   SVGA3D_DEVCAP_LINE_AA                           = 87,  /* boolean */
-   SVGA3D_DEVCAP_LINE_STIPPLE                      = 88,  /* boolean */
-   SVGA3D_DEVCAP_MAX_LINE_WIDTH                    = 89,  /* float */
-   SVGA3D_DEVCAP_MAX_AA_LINE_WIDTH                 = 90,  /* float */
-
-   SVGA3D_DEVCAP_SURFACEFMT_YV12                   = 91,
-
-   /*
-    * Does the host support the SVGA logic ops commands?
-    */
-   SVGA3D_DEVCAP_LOGICOPS                          = 92,
-
-   /*
-    * Are TS_CONSTANT, TS_COLOR_KEY, and TS_COLOR_KEY_ENABLE supported?
-    */
-   SVGA3D_DEVCAP_TS_COLOR_KEY                      = 93, /* boolean */
-
-   /*
-    * Deprecated.
-    */
-   SVGA3D_DEVCAP_DEAD2                             = 94,
-
-   /*
-    * Does the device support DXContexts?
-    */
-   SVGA3D_DEVCAP_DXCONTEXT                         = 95,
-
-   /*
-    * What is the maximum size of a texture array?
-    *
-    * (Even if this cap is zero, cubemaps are still allowed.)
-    */
-   SVGA3D_DEVCAP_MAX_TEXTURE_ARRAY_SIZE            = 96,
-
-   /*
-    * What is the maximum number of vertex buffers or vertex input registers
-    * that can be expected to work correctly with a DXContext?
-    *
-    * The guest is allowed to set up to SVGA3D_DX_MAX_VERTEXBUFFERS, but
-    * anything in excess of this cap is not guaranteed to render correctly.
-    *
-    * Similarly, the guest can set up to SVGA3D_DX_MAX_VERTEXINPUTREGISTERS
-    * input registers without the SVGA3D_DEVCAP_SM4_1 cap, or
-    * SVGA3D_DX_SM41_MAX_VERTEXINPUTREGISTERS with the SVGA3D_DEVCAP_SM4_1,
-    * but only the registers up to this cap value are guaranteed to render
-    * correctly.
-    *
-    * If guest-drivers are able to expose a lower-limit, it's recommended
-    * that they clamp to this value.  Otherwise, the host will make a
-    * best-effort on case-by-case basis if guests exceed this.
-    */
-   SVGA3D_DEVCAP_DX_MAX_VERTEXBUFFERS              = 97,
-
-   /*
-    * What is the maximum number of constant buffers that can be expected to
-    * work correctly with a DX context?
-    *
-    * The guest is allowed to set up to SVGA3D_DX_MAX_CONSTBUFFERS, but
-    * anything in excess of this cap is not guaranteed to render correctly.
-    *
-    * If guest-drivers are able to expose a lower-limit, it's recommended
-    * that they clamp to this value.  Otherwise, the host will make a
-    * best-effort on case-by-case basis if guests exceed this.
-    */
-   SVGA3D_DEVCAP_DX_MAX_CONSTANT_BUFFERS           = 98,
-
-   /*
-    * Does the device support provoking vertex control?
-    *
-    * If this cap is present, the provokingVertexLast field in the
-    * rasterizer state is enabled.  (Guests can then set it to FALSE,
-    * meaning that the first vertex is the provoking vertex, or TRUE,
-    * meaning that the last verteix is the provoking vertex.)
-    *
-    * If this cap is FALSE, then guests should set the provokingVertexLast
-    * to FALSE, otherwise rendering behavior is undefined.
-    */
-   SVGA3D_DEVCAP_DX_PROVOKING_VERTEX               = 99,
-
-   SVGA3D_DEVCAP_DXFMT_X8R8G8B8                    = 100,
-   SVGA3D_DEVCAP_DXFMT_A8R8G8B8                    = 101,
-   SVGA3D_DEVCAP_DXFMT_R5G6B5                      = 102,
-   SVGA3D_DEVCAP_DXFMT_X1R5G5B5                    = 103,
-   SVGA3D_DEVCAP_DXFMT_A1R5G5B5                    = 104,
-   SVGA3D_DEVCAP_DXFMT_A4R4G4B4                    = 105,
-   SVGA3D_DEVCAP_DXFMT_Z_D32                       = 106,
-   SVGA3D_DEVCAP_DXFMT_Z_D16                       = 107,
-   SVGA3D_DEVCAP_DXFMT_Z_D24S8                     = 108,
-   SVGA3D_DEVCAP_DXFMT_Z_D15S1                     = 109,
-   SVGA3D_DEVCAP_DXFMT_LUMINANCE8                  = 110,
-   SVGA3D_DEVCAP_DXFMT_LUMINANCE4_ALPHA4           = 111,
-   SVGA3D_DEVCAP_DXFMT_LUMINANCE16                 = 112,
-   SVGA3D_DEVCAP_DXFMT_LUMINANCE8_ALPHA8           = 113,
-   SVGA3D_DEVCAP_DXFMT_DXT1                        = 114,
-   SVGA3D_DEVCAP_DXFMT_DXT2                        = 115,
-   SVGA3D_DEVCAP_DXFMT_DXT3                        = 116,
-   SVGA3D_DEVCAP_DXFMT_DXT4                        = 117,
-   SVGA3D_DEVCAP_DXFMT_DXT5                        = 118,
-   SVGA3D_DEVCAP_DXFMT_BUMPU8V8                    = 119,
-   SVGA3D_DEVCAP_DXFMT_BUMPL6V5U5                  = 120,
-   SVGA3D_DEVCAP_DXFMT_BUMPX8L8V8U8                = 121,
-   SVGA3D_DEVCAP_DXFMT_FORMAT_DEAD1                = 122,
-   SVGA3D_DEVCAP_DXFMT_ARGB_S10E5                  = 123,
-   SVGA3D_DEVCAP_DXFMT_ARGB_S23E8                  = 124,
-   SVGA3D_DEVCAP_DXFMT_A2R10G10B10                 = 125,
-   SVGA3D_DEVCAP_DXFMT_V8U8                        = 126,
-   SVGA3D_DEVCAP_DXFMT_Q8W8V8U8                    = 127,
-   SVGA3D_DEVCAP_DXFMT_CxV8U8                      = 128,
-   SVGA3D_DEVCAP_DXFMT_X8L8V8U8                    = 129,
-   SVGA3D_DEVCAP_DXFMT_A2W10V10U10                 = 130,
-   SVGA3D_DEVCAP_DXFMT_ALPHA8                      = 131,
-   SVGA3D_DEVCAP_DXFMT_R_S10E5                     = 132,
-   SVGA3D_DEVCAP_DXFMT_R_S23E8                     = 133,
-   SVGA3D_DEVCAP_DXFMT_RG_S10E5                    = 134,
-   SVGA3D_DEVCAP_DXFMT_RG_S23E8                    = 135,
-   SVGA3D_DEVCAP_DXFMT_BUFFER                      = 136,
-   SVGA3D_DEVCAP_DXFMT_Z_D24X8                     = 137,
-   SVGA3D_DEVCAP_DXFMT_V16U16                      = 138,
-   SVGA3D_DEVCAP_DXFMT_G16R16                      = 139,
-   SVGA3D_DEVCAP_DXFMT_A16B16G16R16                = 140,
-   SVGA3D_DEVCAP_DXFMT_UYVY                        = 141,
-   SVGA3D_DEVCAP_DXFMT_YUY2                        = 142,
-   SVGA3D_DEVCAP_DXFMT_NV12                        = 143,
-   SVGA3D_DEVCAP_DXFMT_AYUV                        = 144,
-   SVGA3D_DEVCAP_DXFMT_R32G32B32A32_TYPELESS       = 145,
-   SVGA3D_DEVCAP_DXFMT_R32G32B32A32_UINT           = 146,
-   SVGA3D_DEVCAP_DXFMT_R32G32B32A32_SINT           = 147,
-   SVGA3D_DEVCAP_DXFMT_R32G32B32_TYPELESS          = 148,
-   SVGA3D_DEVCAP_DXFMT_R32G32B32_FLOAT             = 149,
-   SVGA3D_DEVCAP_DXFMT_R32G32B32_UINT              = 150,
-   SVGA3D_DEVCAP_DXFMT_R32G32B32_SINT              = 151,
-   SVGA3D_DEVCAP_DXFMT_R16G16B16A16_TYPELESS       = 152,
-   SVGA3D_DEVCAP_DXFMT_R16G16B16A16_UINT           = 153,
-   SVGA3D_DEVCAP_DXFMT_R16G16B16A16_SNORM          = 154,
-   SVGA3D_DEVCAP_DXFMT_R16G16B16A16_SINT           = 155,
-   SVGA3D_DEVCAP_DXFMT_R32G32_TYPELESS             = 156,
-   SVGA3D_DEVCAP_DXFMT_R32G32_UINT                 = 157,
-   SVGA3D_DEVCAP_DXFMT_R32G32_SINT                 = 158,
-   SVGA3D_DEVCAP_DXFMT_R32G8X24_TYPELESS           = 159,
-   SVGA3D_DEVCAP_DXFMT_D32_FLOAT_S8X24_UINT        = 160,
-   SVGA3D_DEVCAP_DXFMT_R32_FLOAT_X8X24             = 161,
-   SVGA3D_DEVCAP_DXFMT_X32_G8X24_UINT              = 162,
-   SVGA3D_DEVCAP_DXFMT_R10G10B10A2_TYPELESS        = 163,
-   SVGA3D_DEVCAP_DXFMT_R10G10B10A2_UINT            = 164,
-   SVGA3D_DEVCAP_DXFMT_R11G11B10_FLOAT             = 165,
-   SVGA3D_DEVCAP_DXFMT_R8G8B8A8_TYPELESS           = 166,
-   SVGA3D_DEVCAP_DXFMT_R8G8B8A8_UNORM              = 167,
-   SVGA3D_DEVCAP_DXFMT_R8G8B8A8_UNORM_SRGB         = 168,
-   SVGA3D_DEVCAP_DXFMT_R8G8B8A8_UINT               = 169,
-   SVGA3D_DEVCAP_DXFMT_R8G8B8A8_SINT               = 170,
-   SVGA3D_DEVCAP_DXFMT_R16G16_TYPELESS             = 171,
-   SVGA3D_DEVCAP_DXFMT_R16G16_UINT                 = 172,
-   SVGA3D_DEVCAP_DXFMT_R16G16_SINT                 = 173,
-   SVGA3D_DEVCAP_DXFMT_R32_TYPELESS                = 174,
-   SVGA3D_DEVCAP_DXFMT_D32_FLOAT                   = 175,
-   SVGA3D_DEVCAP_DXFMT_R32_UINT                    = 176,
-   SVGA3D_DEVCAP_DXFMT_R32_SINT                    = 177,
-   SVGA3D_DEVCAP_DXFMT_R24G8_TYPELESS              = 178,
-   SVGA3D_DEVCAP_DXFMT_D24_UNORM_S8_UINT           = 179,
-   SVGA3D_DEVCAP_DXFMT_R24_UNORM_X8                = 180,
-   SVGA3D_DEVCAP_DXFMT_X24_G8_UINT                 = 181,
-   SVGA3D_DEVCAP_DXFMT_R8G8_TYPELESS               = 182,
-   SVGA3D_DEVCAP_DXFMT_R8G8_UNORM                  = 183,
-   SVGA3D_DEVCAP_DXFMT_R8G8_UINT                   = 184,
-   SVGA3D_DEVCAP_DXFMT_R8G8_SINT                   = 185,
-   SVGA3D_DEVCAP_DXFMT_R16_TYPELESS                = 186,
-   SVGA3D_DEVCAP_DXFMT_R16_UNORM                   = 187,
-   SVGA3D_DEVCAP_DXFMT_R16_UINT                    = 188,
-   SVGA3D_DEVCAP_DXFMT_R16_SNORM                   = 189,
-   SVGA3D_DEVCAP_DXFMT_R16_SINT                    = 190,
-   SVGA3D_DEVCAP_DXFMT_R8_TYPELESS                 = 191,
-   SVGA3D_DEVCAP_DXFMT_R8_UNORM                    = 192,
-   SVGA3D_DEVCAP_DXFMT_R8_UINT                     = 193,
-   SVGA3D_DEVCAP_DXFMT_R8_SNORM                    = 194,
-   SVGA3D_DEVCAP_DXFMT_R8_SINT                     = 195,
-   SVGA3D_DEVCAP_DXFMT_P8                          = 196,
-   SVGA3D_DEVCAP_DXFMT_R9G9B9E5_SHAREDEXP          = 197,
-   SVGA3D_DEVCAP_DXFMT_R8G8_B8G8_UNORM             = 198,
-   SVGA3D_DEVCAP_DXFMT_G8R8_G8B8_UNORM             = 199,
-   SVGA3D_DEVCAP_DXFMT_BC1_TYPELESS                = 200,
-   SVGA3D_DEVCAP_DXFMT_BC1_UNORM_SRGB              = 201,
-   SVGA3D_DEVCAP_DXFMT_BC2_TYPELESS                = 202,
-   SVGA3D_DEVCAP_DXFMT_BC2_UNORM_SRGB              = 203,
-   SVGA3D_DEVCAP_DXFMT_BC3_TYPELESS                = 204,
-   SVGA3D_DEVCAP_DXFMT_BC3_UNORM_SRGB              = 205,
-   SVGA3D_DEVCAP_DXFMT_BC4_TYPELESS                = 206,
-   SVGA3D_DEVCAP_DXFMT_ATI1                        = 207,
-   SVGA3D_DEVCAP_DXFMT_BC4_SNORM                   = 208,
-   SVGA3D_DEVCAP_DXFMT_BC5_TYPELESS                = 209,
-   SVGA3D_DEVCAP_DXFMT_ATI2                        = 210,
-   SVGA3D_DEVCAP_DXFMT_BC5_SNORM                   = 211,
-   SVGA3D_DEVCAP_DXFMT_R10G10B10_XR_BIAS_A2_UNORM  = 212,
-   SVGA3D_DEVCAP_DXFMT_B8G8R8A8_TYPELESS           = 213,
-   SVGA3D_DEVCAP_DXFMT_B8G8R8A8_UNORM_SRGB         = 214,
-   SVGA3D_DEVCAP_DXFMT_B8G8R8X8_TYPELESS           = 215,
-   SVGA3D_DEVCAP_DXFMT_B8G8R8X8_UNORM_SRGB         = 216,
-   SVGA3D_DEVCAP_DXFMT_Z_DF16                      = 217,
-   SVGA3D_DEVCAP_DXFMT_Z_DF24                      = 218,
-   SVGA3D_DEVCAP_DXFMT_Z_D24S8_INT                 = 219,
-   SVGA3D_DEVCAP_DXFMT_YV12                        = 220,
-   SVGA3D_DEVCAP_DXFMT_R32G32B32A32_FLOAT          = 221,
-   SVGA3D_DEVCAP_DXFMT_R16G16B16A16_FLOAT          = 222,
-   SVGA3D_DEVCAP_DXFMT_R16G16B16A16_UNORM          = 223,
-   SVGA3D_DEVCAP_DXFMT_R32G32_FLOAT                = 224,
-   SVGA3D_DEVCAP_DXFMT_R10G10B10A2_UNORM           = 225,
-   SVGA3D_DEVCAP_DXFMT_R8G8B8A8_SNORM              = 226,
-   SVGA3D_DEVCAP_DXFMT_R16G16_FLOAT                = 227,
-   SVGA3D_DEVCAP_DXFMT_R16G16_UNORM                = 228,
-   SVGA3D_DEVCAP_DXFMT_R16G16_SNORM                = 229,
-   SVGA3D_DEVCAP_DXFMT_R32_FLOAT                   = 230,
-   SVGA3D_DEVCAP_DXFMT_R8G8_SNORM                  = 231,
-   SVGA3D_DEVCAP_DXFMT_R16_FLOAT                   = 232,
-   SVGA3D_DEVCAP_DXFMT_D16_UNORM                   = 233,
-   SVGA3D_DEVCAP_DXFMT_A8_UNORM                    = 234,
-   SVGA3D_DEVCAP_DXFMT_BC1_UNORM                   = 235,
-   SVGA3D_DEVCAP_DXFMT_BC2_UNORM                   = 236,
-   SVGA3D_DEVCAP_DXFMT_BC3_UNORM                   = 237,
-   SVGA3D_DEVCAP_DXFMT_B5G6R5_UNORM                = 238,
-   SVGA3D_DEVCAP_DXFMT_B5G5R5A1_UNORM              = 239,
-   SVGA3D_DEVCAP_DXFMT_B8G8R8A8_UNORM              = 240,
-   SVGA3D_DEVCAP_DXFMT_B8G8R8X8_UNORM              = 241,
-   SVGA3D_DEVCAP_DXFMT_BC4_UNORM                   = 242,
-   SVGA3D_DEVCAP_DXFMT_BC5_UNORM                   = 243,
-
-   /*
-    * Advertises shaderModel 4.1 support, independent blend-states,
-    * cube-map arrays, and a higher vertex input registers limit.
-    *
-    * (See documentation on SVGA3D_DEVCAP_DX_MAX_VERTEXBUFFERS.)
-    */
-   SVGA3D_DEVCAP_SM41                              = 244,
-
-   SVGA3D_DEVCAP_MULTISAMPLE_2X                    = 245,
-   SVGA3D_DEVCAP_MULTISAMPLE_4X                    = 246,
-
-   SVGA3D_DEVCAP_MAX                       /* This must be the last index. */
-} SVGA3dDevCapIndex;
+typedef uint32 SVGA3dDevCapIndex;
+
+#define SVGA3D_DEVCAP_INVALID                              ((uint32)-1)
+#define SVGA3D_DEVCAP_3D                                   0
+#define SVGA3D_DEVCAP_MAX_LIGHTS                           1
+
+/*
+ * SVGA3D_DEVCAP_MAX_TEXTURES reflects the maximum number of
+ * fixed-function texture units available. Each of these units
+ * work in both FFP and Shader modes, and they support texture
+ * transforms and texture coordinates. The host may have additional
+ * texture image units that are only usable with shaders.
+ */
+#define SVGA3D_DEVCAP_MAX_TEXTURES                         2
+#define SVGA3D_DEVCAP_MAX_CLIP_PLANES                      3
+#define SVGA3D_DEVCAP_VERTEX_SHADER_VERSION                4
+#define SVGA3D_DEVCAP_VERTEX_SHADER                        5
+#define SVGA3D_DEVCAP_FRAGMENT_SHADER_VERSION              6
+#define SVGA3D_DEVCAP_FRAGMENT_SHADER                      7
+#define SVGA3D_DEVCAP_MAX_RENDER_TARGETS                   8
+#define SVGA3D_DEVCAP_S23E8_TEXTURES                       9
+#define SVGA3D_DEVCAP_S10E5_TEXTURES                       10
+#define SVGA3D_DEVCAP_MAX_FIXED_VERTEXBLEND                11
+#define SVGA3D_DEVCAP_D16_BUFFER_FORMAT                    12
+#define SVGA3D_DEVCAP_D24S8_BUFFER_FORMAT                  13
+#define SVGA3D_DEVCAP_D24X8_BUFFER_FORMAT                  14
+#define SVGA3D_DEVCAP_QUERY_TYPES                          15
+#define SVGA3D_DEVCAP_TEXTURE_GRADIENT_SAMPLING            16
+#define SVGA3D_DEVCAP_MAX_POINT_SIZE                       17
+#define SVGA3D_DEVCAP_MAX_SHADER_TEXTURES                  18
+#define SVGA3D_DEVCAP_MAX_TEXTURE_WIDTH                    19
+#define SVGA3D_DEVCAP_MAX_TEXTURE_HEIGHT                   20
+#define SVGA3D_DEVCAP_MAX_VOLUME_EXTENT                    21
+#define SVGA3D_DEVCAP_MAX_TEXTURE_REPEAT                   22
+#define SVGA3D_DEVCAP_MAX_TEXTURE_ASPECT_RATIO             23
+#define SVGA3D_DEVCAP_MAX_TEXTURE_ANISOTROPY               24
+#define SVGA3D_DEVCAP_MAX_PRIMITIVE_COUNT                  25
+#define SVGA3D_DEVCAP_MAX_VERTEX_INDEX                     26
+#define SVGA3D_DEVCAP_MAX_VERTEX_SHADER_INSTRUCTIONS       27
+#define SVGA3D_DEVCAP_MAX_FRAGMENT_SHADER_INSTRUCTIONS     28
+#define SVGA3D_DEVCAP_MAX_VERTEX_SHADER_TEMPS              29
+#define SVGA3D_DEVCAP_MAX_FRAGMENT_SHADER_TEMPS            30
+#define SVGA3D_DEVCAP_TEXTURE_OPS                          31
+#define SVGA3D_DEVCAP_SURFACEFMT_X8R8G8B8                  32
+#define SVGA3D_DEVCAP_SURFACEFMT_A8R8G8B8                  33
+#define SVGA3D_DEVCAP_SURFACEFMT_A2R10G10B10               34
+#define SVGA3D_DEVCAP_SURFACEFMT_X1R5G5B5                  35
+#define SVGA3D_DEVCAP_SURFACEFMT_A1R5G5B5                  36
+#define SVGA3D_DEVCAP_SURFACEFMT_A4R4G4B4                  37
+#define SVGA3D_DEVCAP_SURFACEFMT_R5G6B5                    38
+#define SVGA3D_DEVCAP_SURFACEFMT_LUMINANCE16               39
+#define SVGA3D_DEVCAP_SURFACEFMT_LUMINANCE8_ALPHA8         40
+#define SVGA3D_DEVCAP_SURFACEFMT_ALPHA8                    41
+#define SVGA3D_DEVCAP_SURFACEFMT_LUMINANCE8                42
+#define SVGA3D_DEVCAP_SURFACEFMT_Z_D16                     43
+#define SVGA3D_DEVCAP_SURFACEFMT_Z_D24S8                   44
+#define SVGA3D_DEVCAP_SURFACEFMT_Z_D24X8                   45
+#define SVGA3D_DEVCAP_SURFACEFMT_DXT1                      46
+#define SVGA3D_DEVCAP_SURFACEFMT_DXT2                      47
+#define SVGA3D_DEVCAP_SURFACEFMT_DXT3                      48
+#define SVGA3D_DEVCAP_SURFACEFMT_DXT4                      49
+#define SVGA3D_DEVCAP_SURFACEFMT_DXT5                      50
+#define SVGA3D_DEVCAP_SURFACEFMT_BUMPX8L8V8U8              51
+#define SVGA3D_DEVCAP_SURFACEFMT_A2W10V10U10               52
+#define SVGA3D_DEVCAP_SURFACEFMT_BUMPU8V8                  53
+#define SVGA3D_DEVCAP_SURFACEFMT_Q8W8V8U8                  54
+#define SVGA3D_DEVCAP_SURFACEFMT_CxV8U8                    55
+#define SVGA3D_DEVCAP_SURFACEFMT_R_S10E5                   56
+#define SVGA3D_DEVCAP_SURFACEFMT_R_S23E8                   57
+#define SVGA3D_DEVCAP_SURFACEFMT_RG_S10E5                  58
+#define SVGA3D_DEVCAP_SURFACEFMT_RG_S23E8                  59
+#define SVGA3D_DEVCAP_SURFACEFMT_ARGB_S10E5                60
+#define SVGA3D_DEVCAP_SURFACEFMT_ARGB_S23E8                61
+
+/*
+ * There is a hole in our devcap definitions for
+ * historical reasons.
+ *
+ * Define a constant just for completeness.
+ */
+#define SVGA3D_DEVCAP_MISSING62                            62
+
+#define SVGA3D_DEVCAP_MAX_VERTEX_SHADER_TEXTURES           63
+
+/*
+ * Note that MAX_SIMULTANEOUS_RENDER_TARGETS is a maximum count of color
+ * render targets.  This does not include the depth or stencil targets.
+ */
+#define SVGA3D_DEVCAP_MAX_SIMULTANEOUS_RENDER_TARGETS      64
+
+#define SVGA3D_DEVCAP_SURFACEFMT_V16U16                    65
+#define SVGA3D_DEVCAP_SURFACEFMT_G16R16                    66
+#define SVGA3D_DEVCAP_SURFACEFMT_A16B16G16R16              67
+#define SVGA3D_DEVCAP_SURFACEFMT_UYVY                      68
+#define SVGA3D_DEVCAP_SURFACEFMT_YUY2                      69
+
+/*
+ * Deprecated.
+ */
+#define SVGA3D_DEVCAP_DEAD4                                70
+#define SVGA3D_DEVCAP_DEAD5                                71
+#define SVGA3D_DEVCAP_DEAD7                                72
+#define SVGA3D_DEVCAP_DEAD6                                73
+
+#define SVGA3D_DEVCAP_AUTOGENMIPMAPS                       74
+#define SVGA3D_DEVCAP_SURFACEFMT_NV12                      75
+#define SVGA3D_DEVCAP_DEAD10                               76
+
+/*
+ * This is the maximum number of SVGA context IDs that the guest
+ * can define using SVGA_3D_CMD_CONTEXT_DEFINE.
+ */
+#define SVGA3D_DEVCAP_MAX_CONTEXT_IDS                      77
+
+/*
+ * This is the maximum number of SVGA surface IDs that the guest
+ * can define using SVGA_3D_CMD_SURFACE_DEFINE*.
+ */
+#define SVGA3D_DEVCAP_MAX_SURFACE_IDS                      78
+
+#define SVGA3D_DEVCAP_SURFACEFMT_Z_DF16                    79
+#define SVGA3D_DEVCAP_SURFACEFMT_Z_DF24                    80
+#define SVGA3D_DEVCAP_SURFACEFMT_Z_D24S8_INT               81
+
+#define SVGA3D_DEVCAP_SURFACEFMT_ATI1                      82
+#define SVGA3D_DEVCAP_SURFACEFMT_ATI2                      83
+
+/*
+ * Deprecated.
+ */
+#define SVGA3D_DEVCAP_DEAD1                                84
+#define SVGA3D_DEVCAP_DEAD8                                85
+#define SVGA3D_DEVCAP_DEAD9                                86
+
+#define SVGA3D_DEVCAP_LINE_AA                              87  /* boolean */
+#define SVGA3D_DEVCAP_LINE_STIPPLE                         88  /* boolean */
+#define SVGA3D_DEVCAP_MAX_LINE_WIDTH                       89  /* float */
+#define SVGA3D_DEVCAP_MAX_AA_LINE_WIDTH                    90  /* float */
+
+#define SVGA3D_DEVCAP_SURFACEFMT_YV12                      91
+
+/*
+ * Deprecated.
+ */
+#define SVGA3D_DEVCAP_DEAD3                                92
+
+/*
+ * Are TS_CONSTANT, TS_COLOR_KEY, and TS_COLOR_KEY_ENABLE supported?
+ */
+#define SVGA3D_DEVCAP_TS_COLOR_KEY                         93 /* boolean */
+
+/*
+ * Deprecated.
+ */
+#define SVGA3D_DEVCAP_DEAD2                                94
+
+/*
+ * Does the device support DXContexts?
+ */
+#define SVGA3D_DEVCAP_DXCONTEXT                            95
+
+/*
+ * Deprecated.
+ */
+#define SVGA3D_DEVCAP_DEAD11                               96
+
+/*
+ * What is the maximum number of vertex buffers or vertex input registers
+ * that can be expected to work correctly with a DXContext?
+ *
+ * The guest is allowed to set up to SVGA3D_DX_MAX_VERTEXBUFFERS, but
+ * anything in excess of this cap is not guaranteed to render correctly.
+ *
+ * Similarly, the guest can set up to SVGA3D_DX_MAX_VERTEXINPUTREGISTERS
+ * input registers without the SVGA3D_DEVCAP_SM4_1 cap, or
+ * SVGA3D_DX_SM41_MAX_VERTEXINPUTREGISTERS with the SVGA3D_DEVCAP_SM4_1,
+ * but only the registers up to this cap value are guaranteed to render
+ * correctly.
+ *
+ * If guest-drivers are able to expose a lower-limit, it's recommended
+ * that they clamp to this value.  Otherwise, the host will make a
+ * best-effort on case-by-case basis if guests exceed this.
+ */
+#define SVGA3D_DEVCAP_DX_MAX_VERTEXBUFFERS                 97
+
+/*
+ * What is the maximum number of constant buffers that can be expected to
+ * work correctly with a DX context?
+ *
+ * The guest is allowed to set up to SVGA3D_DX_MAX_CONSTBUFFERS, but
+ * anything in excess of this cap is not guaranteed to render correctly.
+ *
+ * If guest-drivers are able to expose a lower-limit, it's recommended
+ * that they clamp to this value.  Otherwise, the host will make a
+ * best-effort on case-by-case basis if guests exceed this.
+ */
+#define SVGA3D_DEVCAP_DX_MAX_CONSTANT_BUFFERS              98
+
+/*
+ * Does the device support provoking vertex control?
+ *
+ * If this cap is present, the provokingVertexLast field in the
+ * rasterizer state is enabled.  (Guests can then set it to FALSE,
+ * meaning that the first vertex is the provoking vertex, or TRUE,
+ * meaning that the last verteix is the provoking vertex.)
+ *
+ * If this cap is FALSE, then guests should set the provokingVertexLast
+ * to FALSE, otherwise rendering behavior is undefined.
+ */
+#define SVGA3D_DEVCAP_DX_PROVOKING_VERTEX                  99
+
+#define SVGA3D_DEVCAP_DXFMT_X8R8G8B8                       100
+#define SVGA3D_DEVCAP_DXFMT_A8R8G8B8                       101
+#define SVGA3D_DEVCAP_DXFMT_R5G6B5                         102
+#define SVGA3D_DEVCAP_DXFMT_X1R5G5B5                       103
+#define SVGA3D_DEVCAP_DXFMT_A1R5G5B5                       104
+#define SVGA3D_DEVCAP_DXFMT_A4R4G4B4                       105
+#define SVGA3D_DEVCAP_DXFMT_Z_D32                          106
+#define SVGA3D_DEVCAP_DXFMT_Z_D16                          107
+#define SVGA3D_DEVCAP_DXFMT_Z_D24S8                        108
+#define SVGA3D_DEVCAP_DXFMT_Z_D15S1                        109
+#define SVGA3D_DEVCAP_DXFMT_LUMINANCE8                     110
+#define SVGA3D_DEVCAP_DXFMT_LUMINANCE4_ALPHA4              111
+#define SVGA3D_DEVCAP_DXFMT_LUMINANCE16                    112
+#define SVGA3D_DEVCAP_DXFMT_LUMINANCE8_ALPHA8              113
+#define SVGA3D_DEVCAP_DXFMT_DXT1                           114
+#define SVGA3D_DEVCAP_DXFMT_DXT2                           115
+#define SVGA3D_DEVCAP_DXFMT_DXT3                           116
+#define SVGA3D_DEVCAP_DXFMT_DXT4                           117
+#define SVGA3D_DEVCAP_DXFMT_DXT5                           118
+#define SVGA3D_DEVCAP_DXFMT_BUMPU8V8                       119
+#define SVGA3D_DEVCAP_DXFMT_BUMPL6V5U5                     120
+#define SVGA3D_DEVCAP_DXFMT_BUMPX8L8V8U8                   121
+#define SVGA3D_DEVCAP_DXFMT_FORMAT_DEAD1                   122
+#define SVGA3D_DEVCAP_DXFMT_ARGB_S10E5                     123
+#define SVGA3D_DEVCAP_DXFMT_ARGB_S23E8                     124
+#define SVGA3D_DEVCAP_DXFMT_A2R10G10B10                    125
+#define SVGA3D_DEVCAP_DXFMT_V8U8                           126
+#define SVGA3D_DEVCAP_DXFMT_Q8W8V8U8                       127
+#define SVGA3D_DEVCAP_DXFMT_CxV8U8                         128
+#define SVGA3D_DEVCAP_DXFMT_X8L8V8U8                       129
+#define SVGA3D_DEVCAP_DXFMT_A2W10V10U10                    130
+#define SVGA3D_DEVCAP_DXFMT_ALPHA8                         131
+#define SVGA3D_DEVCAP_DXFMT_R_S10E5                        132
+#define SVGA3D_DEVCAP_DXFMT_R_S23E8                        133
+#define SVGA3D_DEVCAP_DXFMT_RG_S10E5                       134
+#define SVGA3D_DEVCAP_DXFMT_RG_S23E8                       135
+#define SVGA3D_DEVCAP_DXFMT_BUFFER                         136
+#define SVGA3D_DEVCAP_DXFMT_Z_D24X8                        137
+#define SVGA3D_DEVCAP_DXFMT_V16U16                         138
+#define SVGA3D_DEVCAP_DXFMT_G16R16                         139
+#define SVGA3D_DEVCAP_DXFMT_A16B16G16R16                   140
+#define SVGA3D_DEVCAP_DXFMT_UYVY                           141
+#define SVGA3D_DEVCAP_DXFMT_YUY2                           142
+#define SVGA3D_DEVCAP_DXFMT_NV12                           143
+#define SVGA3D_DEVCAP_DXFMT_FORMAT_DEAD2                   144
+#define SVGA3D_DEVCAP_DXFMT_R32G32B32A32_TYPELESS          145
+#define SVGA3D_DEVCAP_DXFMT_R32G32B32A32_UINT              146
+#define SVGA3D_DEVCAP_DXFMT_R32G32B32A32_SINT              147
+#define SVGA3D_DEVCAP_DXFMT_R32G32B32_TYPELESS             148
+#define SVGA3D_DEVCAP_DXFMT_R32G32B32_FLOAT                149
+#define SVGA3D_DEVCAP_DXFMT_R32G32B32_UINT                 150
+#define SVGA3D_DEVCAP_DXFMT_R32G32B32_SINT                 151
+#define SVGA3D_DEVCAP_DXFMT_R16G16B16A16_TYPELESS          152
+#define SVGA3D_DEVCAP_DXFMT_R16G16B16A16_UINT              153
+#define SVGA3D_DEVCAP_DXFMT_R16G16B16A16_SNORM             154
+#define SVGA3D_DEVCAP_DXFMT_R16G16B16A16_SINT              155
+#define SVGA3D_DEVCAP_DXFMT_R32G32_TYPELESS                156
+#define SVGA3D_DEVCAP_DXFMT_R32G32_UINT                    157
+#define SVGA3D_DEVCAP_DXFMT_R32G32_SINT                    158
+#define SVGA3D_DEVCAP_DXFMT_R32G8X24_TYPELESS              159
+#define SVGA3D_DEVCAP_DXFMT_D32_FLOAT_S8X24_UINT           160
+#define SVGA3D_DEVCAP_DXFMT_R32_FLOAT_X8X24                161
+#define SVGA3D_DEVCAP_DXFMT_X32_G8X24_UINT                 162
+#define SVGA3D_DEVCAP_DXFMT_R10G10B10A2_TYPELESS           163
+#define SVGA3D_DEVCAP_DXFMT_R10G10B10A2_UINT               164
+#define SVGA3D_DEVCAP_DXFMT_R11G11B10_FLOAT                165
+#define SVGA3D_DEVCAP_DXFMT_R8G8B8A8_TYPELESS              166
+#define SVGA3D_DEVCAP_DXFMT_R8G8B8A8_UNORM                 167
+#define SVGA3D_DEVCAP_DXFMT_R8G8B8A8_UNORM_SRGB            168
+#define SVGA3D_DEVCAP_DXFMT_R8G8B8A8_UINT                  169
+#define SVGA3D_DEVCAP_DXFMT_R8G8B8A8_SINT                  170
+#define SVGA3D_DEVCAP_DXFMT_R16G16_TYPELESS                171
+#define SVGA3D_DEVCAP_DXFMT_R16G16_UINT                    172
+#define SVGA3D_DEVCAP_DXFMT_R16G16_SINT                    173
+#define SVGA3D_DEVCAP_DXFMT_R32_TYPELESS                   174
+#define SVGA3D_DEVCAP_DXFMT_D32_FLOAT                      175
+#define SVGA3D_DEVCAP_DXFMT_R32_UINT                       176
+#define SVGA3D_DEVCAP_DXFMT_R32_SINT                       177
+#define SVGA3D_DEVCAP_DXFMT_R24G8_TYPELESS                 178
+#define SVGA3D_DEVCAP_DXFMT_D24_UNORM_S8_UINT              179
+#define SVGA3D_DEVCAP_DXFMT_R24_UNORM_X8                   180
+#define SVGA3D_DEVCAP_DXFMT_X24_G8_UINT                    181
+#define SVGA3D_DEVCAP_DXFMT_R8G8_TYPELESS                  182
+#define SVGA3D_DEVCAP_DXFMT_R8G8_UNORM                     183
+#define SVGA3D_DEVCAP_DXFMT_R8G8_UINT                      184
+#define SVGA3D_DEVCAP_DXFMT_R8G8_SINT                      185
+#define SVGA3D_DEVCAP_DXFMT_R16_TYPELESS                   186
+#define SVGA3D_DEVCAP_DXFMT_R16_UNORM                      187
+#define SVGA3D_DEVCAP_DXFMT_R16_UINT                       188
+#define SVGA3D_DEVCAP_DXFMT_R16_SNORM                      189
+#define SVGA3D_DEVCAP_DXFMT_R16_SINT                       190
+#define SVGA3D_DEVCAP_DXFMT_R8_TYPELESS                    191
+#define SVGA3D_DEVCAP_DXFMT_R8_UNORM                       192
+#define SVGA3D_DEVCAP_DXFMT_R8_UINT                        193
+#define SVGA3D_DEVCAP_DXFMT_R8_SNORM                       194
+#define SVGA3D_DEVCAP_DXFMT_R8_SINT                        195
+#define SVGA3D_DEVCAP_DXFMT_P8                             196
+#define SVGA3D_DEVCAP_DXFMT_R9G9B9E5_SHAREDEXP             197
+#define SVGA3D_DEVCAP_DXFMT_R8G8_B8G8_UNORM                198
+#define SVGA3D_DEVCAP_DXFMT_G8R8_G8B8_UNORM                199
+#define SVGA3D_DEVCAP_DXFMT_BC1_TYPELESS                   200
+#define SVGA3D_DEVCAP_DXFMT_BC1_UNORM_SRGB                 201
+#define SVGA3D_DEVCAP_DXFMT_BC2_TYPELESS                   202
+#define SVGA3D_DEVCAP_DXFMT_BC2_UNORM_SRGB                 203
+#define SVGA3D_DEVCAP_DXFMT_BC3_TYPELESS                   204
+#define SVGA3D_DEVCAP_DXFMT_BC3_UNORM_SRGB                 205
+#define SVGA3D_DEVCAP_DXFMT_BC4_TYPELESS                   206
+#define SVGA3D_DEVCAP_DXFMT_ATI1                           207
+#define SVGA3D_DEVCAP_DXFMT_BC4_SNORM                      208
+#define SVGA3D_DEVCAP_DXFMT_BC5_TYPELESS                   209
+#define SVGA3D_DEVCAP_DXFMT_ATI2                           210
+#define SVGA3D_DEVCAP_DXFMT_BC5_SNORM                      211
+#define SVGA3D_DEVCAP_DXFMT_R10G10B10_XR_BIAS_A2_UNORM     212
+#define SVGA3D_DEVCAP_DXFMT_B8G8R8A8_TYPELESS              213
+#define SVGA3D_DEVCAP_DXFMT_B8G8R8A8_UNORM_SRGB            214
+#define SVGA3D_DEVCAP_DXFMT_B8G8R8X8_TYPELESS              215
+#define SVGA3D_DEVCAP_DXFMT_B8G8R8X8_UNORM_SRGB            216
+#define SVGA3D_DEVCAP_DXFMT_Z_DF16                         217
+#define SVGA3D_DEVCAP_DXFMT_Z_DF24                         218
+#define SVGA3D_DEVCAP_DXFMT_Z_D24S8_INT                    219
+#define SVGA3D_DEVCAP_DXFMT_YV12                           220
+#define SVGA3D_DEVCAP_DXFMT_R32G32B32A32_FLOAT             221
+#define SVGA3D_DEVCAP_DXFMT_R16G16B16A16_FLOAT             222
+#define SVGA3D_DEVCAP_DXFMT_R16G16B16A16_UNORM             223
+#define SVGA3D_DEVCAP_DXFMT_R32G32_FLOAT                   224
+#define SVGA3D_DEVCAP_DXFMT_R10G10B10A2_UNORM              225
+#define SVGA3D_DEVCAP_DXFMT_R8G8B8A8_SNORM                 226
+#define SVGA3D_DEVCAP_DXFMT_R16G16_FLOAT                   227
+#define SVGA3D_DEVCAP_DXFMT_R16G16_UNORM                   228
+#define SVGA3D_DEVCAP_DXFMT_R16G16_SNORM                   229
+#define SVGA3D_DEVCAP_DXFMT_R32_FLOAT                      230
+#define SVGA3D_DEVCAP_DXFMT_R8G8_SNORM                     231
+#define SVGA3D_DEVCAP_DXFMT_R16_FLOAT                      232
+#define SVGA3D_DEVCAP_DXFMT_D16_UNORM                      233
+#define SVGA3D_DEVCAP_DXFMT_A8_UNORM                       234
+#define SVGA3D_DEVCAP_DXFMT_BC1_UNORM                      235
+#define SVGA3D_DEVCAP_DXFMT_BC2_UNORM                      236
+#define SVGA3D_DEVCAP_DXFMT_BC3_UNORM                      237
+#define SVGA3D_DEVCAP_DXFMT_B5G6R5_UNORM                   238
+#define SVGA3D_DEVCAP_DXFMT_B5G5R5A1_UNORM                 239
+#define SVGA3D_DEVCAP_DXFMT_B8G8R8A8_UNORM                 240
+#define SVGA3D_DEVCAP_DXFMT_B8G8R8X8_UNORM                 241
+#define SVGA3D_DEVCAP_DXFMT_BC4_UNORM                      242
+#define SVGA3D_DEVCAP_DXFMT_BC5_UNORM                      243
+
+/*
+ * Advertises shaderModel 4.1 support, independent blend-states,
+ * cube-map arrays, and a higher vertex input registers limit.
+ *
+ * (See documentation on SVGA3D_DEVCAP_DX_MAX_VERTEXBUFFERS.)
+ */
+#define SVGA3D_DEVCAP_SM41                                 244
+#define SVGA3D_DEVCAP_MULTISAMPLE_2X                       245
+#define SVGA3D_DEVCAP_MULTISAMPLE_4X                       246
+
+/*
+ * Indicates that the device has rendering support for
+ * the full multisample quality.  If this cap is not present,
+ * the host may or may not support full quality rendering.
+ *
+ * See also SVGA_REG_MS_HINT_RESOLVED.
+ */
+#define SVGA3D_DEVCAP_MS_FULL_QUALITY                      247
+
+/*
+ * Advertises support for the SVGA3D LogicOps commands.
+ */
+#define SVGA3D_DEVCAP_LOGICOPS                             248
+
+/*
+ * Advertises support for using logicOps in the DXBlendStates.
+ */
+#define SVGA3D_DEVCAP_LOGIC_BLENDOPS                       249
+
+/*
+* Note DXFMT range is now non-contiguous.
+*/
+#define SVGA3D_DEVCAP_RESERVED_1                           250
+#define SVGA3D_DEVCAP_DXFMT_BC6H_TYPELESS                  251
+#define SVGA3D_DEVCAP_DXFMT_BC6H_UF16                      252
+#define SVGA3D_DEVCAP_DXFMT_BC6H_SF16                      253
+#define SVGA3D_DEVCAP_DXFMT_BC7_TYPELESS                   254
+#define SVGA3D_DEVCAP_DXFMT_BC7_UNORM                      255
+#define SVGA3D_DEVCAP_DXFMT_BC7_UNORM_SRGB                 256
+#define SVGA3D_DEVCAP_RESERVED_2                           257
+
+#define SVGA3D_DEVCAP_SM5                                  258
+#define SVGA3D_DEVCAP_MULTISAMPLE_8X                       259
+
+/* This must be the last index. */
+#define SVGA3D_DEVCAP_MAX                                  260
 
 /*
  * Bit definitions for DXFMT devcaps
@@ -477,10 +501,10 @@ typedef enum {
 #define SVGA3D_DXFMT_MAX                      (1 << 10)
 
 typedef union {
-   Bool   b;
+   SVGA3dBool b;
    uint32 u;
-   int32  i;
-   float  f;
+   int32 i;
+   float f;
 } SVGA3dDevCapResult;
 
 #endif /* _SVGA3D_DEVCAPS_H_ */
diff --git a/drivers/gpu/drm/vmwgfx/device_include/svga3d_dx.h b/drivers/gpu/drm/vmwgfx/device_include/svga3d_dx.h
index 7a49c94df221..f703ac2b1768 100644
--- a/drivers/gpu/drm/vmwgfx/device_include/svga3d_dx.h
+++ b/drivers/gpu/drm/vmwgfx/device_include/svga3d_dx.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
 /**********************************************************
- * Copyright 2012-2015 VMware, Inc.
+ * Copyright 2012-2019 VMware, Inc.
  *
  * Permission is hereby granted, free of charge, to any person
  * obtaining a copy of this software and associated documentation
@@ -118,12 +118,14 @@ typedef uint8 SVGA3dMultisampleRastEnable;
 #define SVGA3D_DX_MAX_SRVIEWS 128
 #define SVGA3D_DX_MAX_CONSTBUFFERS 16
 #define SVGA3D_DX_MAX_SAMPLERS 16
+#define SVGA3D_DX_MAX_CLASS_INSTANCES 253
 
 #define SVGA3D_DX_MAX_CONSTBUF_BINDING_SIZE (4096 * 4 * (uint32)sizeof(uint32))
 
 typedef uint32 SVGA3dShaderResourceViewId;
 typedef uint32 SVGA3dRenderTargetViewId;
 typedef uint32 SVGA3dDepthStencilViewId;
+typedef uint32 SVGA3dUAViewId;
 
 typedef uint32 SVGA3dShaderId;
 typedef uint32 SVGA3dElementLayoutId;
@@ -145,6 +147,17 @@ typedef union {
    float value[4];
 } SVGA3dRGBAFloat;
 
+typedef union {
+   struct {
+      uint32 r;
+      uint32 g;
+      uint32 b;
+      uint32 a;
+   };
+
+   uint32 value[4];
+} SVGA3dRGBAUint32;
+
 typedef
 #include "vmware_pack_begin.h"
 struct {
@@ -249,6 +262,39 @@ struct SVGA3dCmdDXSetShader {
 #include "vmware_pack_end.h"
 SVGA3dCmdDXSetShader; /* SVGA_3D_CMD_DX_SET_SHADER */
 
+typedef union {
+   struct {
+      uint32 cbOffset : 12;
+      uint32 cbId     : 4;
+      uint32 baseSamp : 4;
+      uint32 baseTex  : 7;
+      uint32 reserved : 5;
+   };
+   uint32 value;
+} SVGA3dIfaceData;
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXSetShaderIface {
+   SVGA3dShaderType type;
+   uint32 numClassInstances;
+   uint32 index;
+   uint32 iface;
+   SVGA3dIfaceData data;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXSetShaderIface; /* SVGA_3D_CMD_DX_SET_SHADER_IFACE */
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXBindShaderIface {
+   uint32 cid;
+   SVGAMobId mobid;
+   uint32 offsetInBytes;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXBindShaderIface; /* SVGA_3D_CMD_DX_BIND_SHADER_IFACE */
+
 typedef
 #include "vmware_pack_begin.h"
 struct SVGA3dCmdDXSetSamplers {
@@ -304,6 +350,26 @@ struct SVGA3dCmdDXDrawIndexedInstanced {
 #include "vmware_pack_end.h"
 SVGA3dCmdDXDrawIndexedInstanced; /* SVGA_3D_CMD_DX_DRAW_INDEXED_INSTANCED */
 
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXDrawIndexedInstancedIndirect {
+   SVGA3dSurfaceId argsBufferSid;
+   uint32 byteOffsetForArgs;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXDrawIndexedInstancedIndirect;
+/* SVGA_3D_CMD_DX_DRAW_INDEXED_INSTANCED_INDIRECT */
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXDrawInstancedIndirect {
+   SVGA3dSurfaceId argsBufferSid;
+   uint32 byteOffsetForArgs;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXDrawInstancedIndirect;
+/* SVGA_3D_CMD_DX_DRAW_INSTANCED_INDIRECT */
+
 typedef
 #include "vmware_pack_begin.h"
 struct SVGA3dCmdDXDrawAuto {
@@ -312,6 +378,27 @@ struct SVGA3dCmdDXDrawAuto {
 #include "vmware_pack_end.h"
 SVGA3dCmdDXDrawAuto; /* SVGA_3D_CMD_DX_DRAW_AUTO */
 
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXDispatch {
+   uint32 threadGroupCountX;
+   uint32 threadGroupCountY;
+   uint32 threadGroupCountZ;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXDispatch;
+/* SVGA_3D_CMD_DX_DISPATCH */
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXDispatchIndirect {
+   SVGA3dSurfaceId argsBufferSid;
+   uint32 byteOffsetForArgs;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXDispatchIndirect;
+/* SVGA_3D_CMD_DX_DISPATCH_INDIRECT */
+
 typedef
 #include "vmware_pack_begin.h"
 struct SVGA3dCmdDXSetInputLayout {
@@ -525,7 +612,7 @@ struct MKS3dDXSOState {
    uint32 offset;       /* Starting offset */
    uint32 intOffset;    /* Internal offset */
    uint32 vertexCount;  /* vertices written */
-   uint32 sizeInBytes;  /* max bytes to write */
+   uint32 dead;
 }
 #include "vmware_pack_end.h"
 SVGA3dDXSOState;
@@ -786,6 +873,31 @@ struct SVGA3dCmdDXTransferFromBuffer {
 SVGA3dCmdDXTransferFromBuffer;   /* SVGA_3D_CMD_DX_TRANSFER_FROM_BUFFER */
 
 
+#define SVGA3D_TRANSFER_TO_BUFFER_READBACK   (1 << 0)
+#define SVGA3D_TRANSFER_TO_BUFFER_FLAGS_MASK (1 << 0)
+typedef uint32 SVGA3dTransferToBufferFlags;
+
+/*
+ * Raw byte wise transfer to a buffer surface from another surface
+ * of the requested box.  Supported if SVGA_CAP_DX2 is set.  This
+ * command does not take a context.
+ */
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXTransferToBuffer {
+   SVGA3dSurfaceId srcSid;
+   uint32 srcSubResource;
+   SVGA3dBox srcBox;
+   SVGA3dSurfaceId destSid;
+   uint32 destOffset;
+   uint32 destPitch;
+   uint32 destSlicePitch;
+   SVGA3dTransferToBufferFlags flags;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXTransferToBuffer;   /* SVGA_3D_CMD_DX_TRANSFER_TO_BUFFER */
+
+
 /*
  * Raw byte wise transfer from a buffer surface into another surface
  * of the requested box.  Supported if SVGA3D_DEVCAP_DXCONTEXT is set.
@@ -905,6 +1017,20 @@ typedef SVGA3dCmdDXSetConstantBufferOffset SVGA3dCmdDXSetPSConstantBufferOffset;
 typedef SVGA3dCmdDXSetConstantBufferOffset SVGA3dCmdDXSetGSConstantBufferOffset;
 /* SVGA_3D_CMD_DX_SET_GS_CONSTANT_BUFFER_OFFSET */
 
+typedef SVGA3dCmdDXSetConstantBufferOffset SVGA3dCmdDXSetHSConstantBufferOffset;
+/* SVGA_3D_CMD_DX_SET_HS_CONSTANT_BUFFER_OFFSET */
+
+typedef SVGA3dCmdDXSetConstantBufferOffset SVGA3dCmdDXSetDSConstantBufferOffset;
+/* SVGA_3D_CMD_DX_SET_DS_CONSTANT_BUFFER_OFFSET */
+
+typedef SVGA3dCmdDXSetConstantBufferOffset SVGA3dCmdDXSetCSConstantBufferOffset;
+/* SVGA_3D_CMD_DX_SET_CS_CONSTANT_BUFFER_OFFSET */
+
+
+#define SVGA3D_BUFFEREX_SRV_RAW        (1 << 0)
+#define SVGA3D_BUFFEREX_SRV_FLAGS_MAX  (1 << 1)
+#define SVGA3D_BUFFEREX_SRV_FLAGS_MASK (SVGA3D_BUFFEREX_SRV_FLAGS_MAX - 1)
+typedef uint32 SVGA3dBufferExFlags;
 
 typedef
 #include "vmware_pack_begin.h"
@@ -925,7 +1051,7 @@ struct {
       struct {
          uint32 firstElement;
          uint32 numElements;
-         uint32 flags;
+         SVGA3dBufferExFlags flags;
          uint32 pad0;
       } bufferex;
    };
@@ -1072,6 +1198,32 @@ struct SVGA3dCmdDXDefineDepthStencilView {
 SVGA3dCmdDXDefineDepthStencilView;
 /* SVGA_3D_CMD_DX_DEFINE_DEPTHSTENCIL_VIEW */
 
+/*
+ * Version 2 needed in order to start validating and using the flags
+ * field.  Unfortunately the device wasn't validating or using the
+ * flags field and the driver wasn't initializing it in shipped code,
+ * so a new version of the command is needed to allow that code to
+ * continue to work.
+ */
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXDefineDepthStencilView_v2 {
+   SVGA3dDepthStencilViewId depthStencilViewId;
+
+   SVGA3dSurfaceId sid;
+   SVGA3dSurfaceFormat format;
+   SVGA3dResourceType resourceDimension;
+   uint32 mipSlice;
+   uint32 firstArraySlice;
+   uint32 arraySize;
+   SVGA3DCreateDSViewFlags flags;
+   uint8 pad0;
+   uint16 pad1;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXDefineDepthStencilView_v2;
+/* SVGA_3D_CMD_DX_DEFINE_DEPTHSTENCIL_VIEW_V2 */
+
 typedef
 #include "vmware_pack_begin.h"
 struct SVGA3dCmdDXDestroyDepthStencilView {
@@ -1081,6 +1233,138 @@ struct SVGA3dCmdDXDestroyDepthStencilView {
 SVGA3dCmdDXDestroyDepthStencilView;
 /* SVGA_3D_CMD_DX_DESTROY_DEPTHSTENCIL_VIEW */
 
+
+#define SVGA3D_UABUFFER_RAW     (1 << 0)
+#define SVGA3D_UABUFFER_APPEND  (1 << 1)
+#define SVGA3D_UABUFFER_COUNTER (1 << 2)
+typedef uint32 SVGA3dUABufferFlags;
+
+typedef
+#include "vmware_pack_begin.h"
+struct {
+   union {
+      struct {
+         uint32 firstElement;
+         uint32 numElements;
+         SVGA3dUABufferFlags flags;
+         uint32 padding0;
+         uint32 padding1;
+      } buffer;
+      struct {
+         uint32 mipSlice;
+         uint32 firstArraySlice;
+         uint32 arraySize;
+         uint32 padding0;
+         uint32 padding1;
+      } tex;  /* 1d, 2d */
+      struct {
+         uint32 mipSlice;
+         uint32 firstW;
+         uint32 wSize;
+         uint32 padding0;
+         uint32 padding1;
+      } tex3D;
+   };
+}
+#include "vmware_pack_end.h"
+SVGA3dUAViewDesc;
+
+typedef
+#include "vmware_pack_begin.h"
+struct {
+   SVGA3dSurfaceId sid;
+   SVGA3dSurfaceFormat format;
+   SVGA3dResourceType resourceDimension;
+   SVGA3dUAViewDesc desc;
+   uint32 structureCount;
+   uint32 pad[7];
+}
+#include "vmware_pack_end.h"
+SVGACOTableDXUAViewEntry;
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXDefineUAView {
+   SVGA3dUAViewId uaViewId;
+
+   SVGA3dSurfaceId sid;
+   SVGA3dSurfaceFormat format;
+   SVGA3dResourceType resourceDimension;
+
+   SVGA3dUAViewDesc desc;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXDefineUAView;
+/* SVGA_3D_CMD_DX_DEFINE_UA_VIEW */
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXDestroyUAView {
+   SVGA3dUAViewId uaViewId;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXDestroyUAView;
+/* SVGA_3D_CMD_DX_DESTROY_UA_VIEW */
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXClearUAViewUint {
+   SVGA3dUAViewId uaViewId;
+   SVGA3dRGBAUint32 value;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXClearUAViewUint;
+/* SVGA_3D_CMD_DX_CLEAR_UA_VIEW_UINT */
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXClearUAViewFloat {
+   SVGA3dUAViewId uaViewId;
+   SVGA3dRGBAFloat value;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXClearUAViewFloat;
+/* SVGA_3D_CMD_DX_CLEAR_UA_VIEW_FLOAT */
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXCopyStructureCount {
+   SVGA3dUAViewId srcUAViewId;
+   SVGA3dSurfaceId destSid;
+   uint32 destByteOffset;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXCopyStructureCount;
+/* SVGA_3D_CMD_DX_COPY_STRUCTURE_COUNT */
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXSetStructureCount {
+   SVGA3dUAViewId uaViewId;
+   uint32 structureCount;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXSetStructureCount;
+/* SVGA_3D_CMD_DX_SET_STRUCTURE_COUNT */
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXSetUAViews {
+   uint32 uavSpliceIndex;
+   /* Followed by a variable number of SVGA3dUAViewId's. */
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXSetUAViews; /* SVGA_3D_CMD_DX_SET_UA_VIEWS */
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXSetCSUAViews {
+   uint32 startIndex;
+   /* Followed by a variable number of SVGA3dUAViewId's. */
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXSetCSUAViews; /* SVGA_3D_CMD_DX_SET_CS_UA_VIEWS */
+
 typedef
 #include "vmware_pack_begin.h"
 struct SVGA3dInputElementDesc {
@@ -1099,7 +1383,7 @@ typedef
 struct {
    uint32 elid;
    uint32 numDescs;
-   SVGA3dInputElementDesc desc[32];
+   SVGA3dInputElementDesc descs[32];
    uint32 pad[62];
 }
 #include "vmware_pack_end.h"
@@ -1261,7 +1545,8 @@ struct {
    uint8 lineStippleEnable;
    uint8 lineStippleFactor;
    uint16 lineStipplePattern;
-   uint32 forcedSampleCount;
+   uint8 forcedSampleCount;
+   uint8 mustBeZero[3];
 }
 #include "vmware_pack_end.h"
 SVGACOTableDXRasterizerStateEntry;
@@ -1352,6 +1637,71 @@ struct SVGA3dCmdDXDestroySamplerState {
 #include "vmware_pack_end.h"
 SVGA3dCmdDXDestroySamplerState; /* SVGA_3D_CMD_DX_DESTROY_SAMPLER_STATE */
 
+
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_UNDEFINED                          0
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_POSITION                           1
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_CLIP_DISTANCE                      2
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_CULL_DISTANCE                      3
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_RENDER_TARGET_ARRAY_INDEX          4
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_VIEWPORT_ARRAY_INDEX               5
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_VERTEX_ID                          6
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_PRIMITIVE_ID                       7
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_INSTANCE_ID                        8
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_IS_FRONT_FACE                      9
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_SAMPLE_INDEX                       10
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_FINAL_QUAD_U_EQ_0_EDGE_TESSFACTOR  11
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_FINAL_QUAD_V_EQ_0_EDGE_TESSFACTOR  12
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_FINAL_QUAD_U_EQ_1_EDGE_TESSFACTOR  13
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_FINAL_QUAD_V_EQ_1_EDGE_TESSFACTOR  14
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_FINAL_QUAD_U_INSIDE_TESSFACTOR     15
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_FINAL_QUAD_V_INSIDE_TESSFACTOR     16
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_FINAL_TRI_U_EQ_0_EDGE_TESSFACTOR   17
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_FINAL_TRI_V_EQ_0_EDGE_TESSFACTOR   18
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_FINAL_TRI_W_EQ_0_EDGE_TESSFACTOR   19
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_FINAL_TRI_INSIDE_TESSFACTOR        20
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_FINAL_LINE_DETAIL_TESSFACTOR       21
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_FINAL_LINE_DENSITY_TESSFACTOR      22
+#define SVGADX_SIGNATURE_SEMANTIC_NAME_MAX                                23
+typedef uint32 SVGA3dDXSignatureSemanticName;
+
+#define SVGADX_SIGNATURE_REGISTER_COMPONENT_UNKNOWN 0
+typedef uint32 SVGA3dDXSignatureRegisterComponentType;
+
+#define SVGADX_SIGNATURE_MIN_PRECISION_DEFAULT 0
+typedef uint32 SVGA3dDXSignatureMinPrecision;
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dDXSignatureEntry {
+   uint32 registerIndex;
+   SVGA3dDXSignatureSemanticName semanticName;
+   uint32 mask; /* Lower 4 bits represent X, Y, Z, W channels */
+   SVGA3dDXSignatureRegisterComponentType componentType;
+   SVGA3dDXSignatureMinPrecision minPrecision;
+}
+#include "vmware_pack_end.h"
+SVGA3dDXShaderSignatureEntry;
+
+#define SVGADX_SIGNATURE_HEADER_VERSION_0 0x08a92d12
+
+/*
+ * The SVGA3dDXSignatureHeader structure is added after the shader
+ * body in the mob that is bound to the shader.  It is followed by the
+ * specified number of SVGA3dDXSignatureEntry structures for each of
+ * the three types of signatures in the order (input, output, patch
+ * constants).
+ */
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dDXSignatureHeader {
+   uint32 headerVersion;
+   uint32 numInputSignatures;
+   uint32 numOutputSignatures;
+   uint32 numPatchConstantSignatures;
+}
+#include "vmware_pack_end.h"
+SVGA3dDXShaderSignatureHeader;
+
 typedef
 #include "vmware_pack_begin.h"
 struct SVGA3dCmdDXDefineShader {
@@ -1415,7 +1765,8 @@ SVGA3dCmdDXCondBindAllShader;   /* SVGA_3D_CMD_DX_COND_BIND_ALL_SHADER */
 /*
  * The maximum number of streamout decl's in each streamout entry.
  */
-#define SVGA3D_MAX_STREAMOUT_DECLS 64
+#define SVGA3D_MAX_DX10_STREAMOUT_DECLS 64
+#define SVGA3D_MAX_STREAMOUT_DECLS 512
 
 typedef
 #include "vmware_pack_begin.h"
@@ -1434,10 +1785,16 @@ typedef
 #include "vmware_pack_begin.h"
 struct SVGAOTableStreamOutputEntry {
    uint32 numOutputStreamEntries;
-   SVGA3dStreamOutputDeclarationEntry decl[SVGA3D_MAX_STREAMOUT_DECLS];
+   SVGA3dStreamOutputDeclarationEntry decl[SVGA3D_MAX_DX10_STREAMOUT_DECLS];
    uint32 streamOutputStrideInBytes[SVGA3D_DX_MAX_SOTARGETS];
    uint32 rasterizedStream;
-   uint32 pad[250];
+   uint32 numOutputStreamStrides;
+   uint32 mobid;
+   uint32 offsetInBytes;
+   uint8 usesMob;
+   uint8 pad0;
+   uint16 pad1;
+   uint32 pad2[246];
 }
 #include "vmware_pack_end.h"
 SVGACOTableDXStreamOutputEntry;
@@ -1447,13 +1804,47 @@ typedef
 struct SVGA3dCmdDXDefineStreamOutput {
    SVGA3dStreamOutputId soid;
    uint32 numOutputStreamEntries;
-   SVGA3dStreamOutputDeclarationEntry decl[SVGA3D_MAX_STREAMOUT_DECLS];
+   SVGA3dStreamOutputDeclarationEntry decl[SVGA3D_MAX_DX10_STREAMOUT_DECLS];
    uint32 streamOutputStrideInBytes[SVGA3D_DX_MAX_SOTARGETS];
    uint32 rasterizedStream;
 }
 #include "vmware_pack_end.h"
 SVGA3dCmdDXDefineStreamOutput; /* SVGA_3D_CMD_DX_DEFINE_STREAMOUTPUT */
 
+/*
+ * Version 2 needed in order to start validating and using the
+ * rasterizedStream field.  Unfortunately the device wasn't validating
+ * or using this field and the driver wasn't initializing it in shipped
+ * code, so a new version of the command is needed to allow that code
+ * to continue to work.  Also added new numOutputStreamStrides field.
+ */
+
+#define SVGA3D_DX_SO_NO_RASTERIZED_STREAM 0xFFFFFFFF
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXDefineStreamOutputWithMob {
+   SVGA3dStreamOutputId soid;
+   uint32 numOutputStreamEntries;
+   uint32 numOutputStreamStrides;
+   uint32 streamOutputStrideInBytes[SVGA3D_DX_MAX_SOTARGETS];
+   uint32 rasterizedStream;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXDefineStreamOutputWithMob;
+/* SVGA_3D_CMD_DX_DEFINE_STREAMOUTPUT_WITH_MOB */
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXBindStreamOutput {
+   SVGA3dStreamOutputId soid;
+   uint32 mobid;
+   uint32 offsetInBytes;
+   uint32 sizeInBytes;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXBindStreamOutput; /* SVGA_3D_CMD_DX_BIND_STREAMOUTPUT */
+
 typedef
 #include "vmware_pack_begin.h"
 struct SVGA3dCmdDXDestroyStreamOutput {
@@ -1470,6 +1861,15 @@ struct SVGA3dCmdDXSetStreamOutput {
 #include "vmware_pack_end.h"
 SVGA3dCmdDXSetStreamOutput; /* SVGA_3D_CMD_DX_SET_STREAMOUTPUT */
 
+typedef
+#include "vmware_pack_begin.h"
+struct SVGA3dCmdDXSetMinLOD {
+   SVGA3dSurfaceId sid;
+   float minLOD;
+}
+#include "vmware_pack_end.h"
+SVGA3dCmdDXSetMinLOD; /* SVGA_3D_CMD_DX_SET_MIN_LOD */
+
 typedef
 #include "vmware_pack_begin.h"
 struct {
@@ -1581,33 +1981,38 @@ struct SVGADXContextMobFormat {
       uint32 rasterizerStateId;
       uint32 depthStencilViewId;
       uint32 renderTargetViewIds[SVGA3D_MAX_SIMULTANEOUS_RENDER_TARGETS];
-      uint32 unorderedAccessViewIds[SVGA3D_MAX_UAVIEWS];
    } renderState;
 
+   uint32 pad0[8];
+
    struct {
       uint32 targets[SVGA3D_DX_MAX_SOTARGETS];
       uint32 soid;
    } streamOut;
-   uint32 pad0[11];
+
+   uint32 pad1[10];
+
+   uint32 uavSpliceIndex;
 
    uint8 numViewports;
    uint8 numScissorRects;
-   uint16 pad1[1];
+   uint16 pad2[1];
 
-   uint32 pad2[3];
+   uint32 pad3[3];
 
    SVGA3dViewport viewports[SVGA3D_DX_MAX_VIEWPORTS];
-   uint32 pad3[32];
+   uint32 pad4[32];
 
    SVGASignedRect scissorRects[SVGA3D_DX_MAX_SCISSORRECTS];
-   uint32 pad4[64];
+   uint32 pad5[64];
 
    struct {
       uint32 queryID;
       uint32 value;
    } predication;
-   uint32 pad5[2];
 
+   SVGAMobId shaderIfaceMobid;
+   uint32 shaderIfaceOffset;
    struct {
       uint32 shaderId;
       SVGA3dConstantBufferBinding constantBuffers[SVGA3D_DX_MAX_CONSTBUFFERS];
@@ -1619,11 +2024,38 @@ struct SVGADXContextMobFormat {
    SVGA3dQueryId queryID[SVGA3D_MAX_QUERY];
 
    SVGA3dCOTableData cotables[SVGA_COTABLE_MAX];
-   uint32 pad7[380];
+
+   uint32 pad7[64];
+
+   uint32 uaViewIds[SVGA3D_DX11_1_MAX_UAVIEWS];
+   uint32 csuaViewIds[SVGA3D_DX11_1_MAX_UAVIEWS];
+
+   uint32 pad8[188];
 }
 #include "vmware_pack_end.h"
 SVGADXContextMobFormat;
 
+/*
+ * There is conflicting documentation on max class instances (253 vs 256).  The
+ * lower value is the one used throughout the device, but since mob format is
+ * more involved to increase if needed, conservatively use the higher one here.
+ */
+#define SVGA3D_DX_MAX_CLASS_INSTANCES_PADDED 256
+
+typedef
+#include "vmware_pack_begin.h"
+struct SVGADXShaderIfaceMobFormat {
+   struct {
+      uint32 numClassInstances;
+      uint32 iface[SVGA3D_DX_MAX_CLASS_INSTANCES_PADDED];
+      SVGA3dIfaceData data[SVGA3D_DX_MAX_CLASS_INSTANCES_PADDED];
+   } shaderIfaceState[SVGA3D_NUM_SHADERTYPE];
+
+   uint32 pad0[1018];
+}
+#include "vmware_pack_end.h"
+SVGADXShaderIfaceMobFormat;
+
 typedef
 #include "vmware_pack_begin.h"
 struct SVGA3dCmdDXTempSetContext {
diff --git a/drivers/gpu/drm/vmwgfx/device_include/svga3d_limits.h b/drivers/gpu/drm/vmwgfx/device_include/svga3d_limits.h
index b22a67f15660..f4375a41b3aa 100644
--- a/drivers/gpu/drm/vmwgfx/device_include/svga3d_limits.h
+++ b/drivers/gpu/drm/vmwgfx/device_include/svga3d_limits.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
 /**********************************************************
- * Copyright 2007-2015 VMware, Inc.
+ * Copyright 2007-2019 VMware, Inc.
  *
  * Permission is hereby granted, free of charge, to any person
  * obtaining a copy of this software and associated documentation
@@ -40,11 +40,25 @@
 #include "includeCheck.h"
 
 #define SVGA3D_NUM_CLIPPLANES                   6
+#define SVGA3D_MAX_CONTEXT_IDS                  256
+#define SVGA3D_MAX_SURFACE_IDS                  (32 * 1024)
+
+/*
+ * While there are separate bind-points for RenderTargetViews and
+ * UnorderedAccessViews in a DXContext, there is in fact one shared
+ * semantic space that the guest-driver can use on any given draw call.
+ * So there are really only 8 slots that can be spilt up between them, with the
+ * spliceIndex controlling where the UAV's sit in the collapsed array.
+ */
 #define SVGA3D_MAX_RENDER_TARGETS               8
 #define SVGA3D_MAX_SIMULTANEOUS_RENDER_TARGETS  (SVGA3D_MAX_RENDER_TARGETS)
 #define SVGA3D_MAX_UAVIEWS                      8
-#define SVGA3D_MAX_CONTEXT_IDS                  256
-#define SVGA3D_MAX_SURFACE_IDS                  (32 * 1024)
+#define SVGA3D_DX11_1_MAX_UAVIEWS               64
+
+/*
+ * Maximum canonical size of a surface in host-backed mode (pre-GBObjects).
+ */
+#define SVGA3D_HB_MAX_SURFACE_SIZE MBYTES_2_BYTES(128)
 
 /*
  * Maximum ID a shader can be assigned on a given context.
@@ -59,6 +73,8 @@
 #define SVGA3D_NUM_TEXTURE_UNITS                32
 #define SVGA3D_NUM_LIGHTS                       8
 
+#define SVGA3D_MAX_VIDEOPROCESSOR_SAMPLERS      32
+
 /*
  * Maximum size in dwords of shader text the SVGA device will allow.
  * Currently 8 MB.
@@ -67,6 +83,11 @@
 #define SVGA3D_MAX_SHADER_MEMORY  (SVGA3D_MAX_SHADER_MEMORY_BYTES / \
                                    sizeof(uint32))
 
+/*
+ * The maximum value of threadGroupCount in each dimension
+ */
+#define SVGA3D_MAX_SHADER_THREAD_GROUPS 65535
+
 #define SVGA3D_MAX_CLIP_PLANES    6
 
 /*
@@ -85,7 +106,9 @@
 /*
  * Maximum number of array indexes in a GB surface (with DX enabled).
  */
-#define SVGA3D_MAX_SURFACE_ARRAYSIZE 512
+#define SVGA3D_SM4_MAX_SURFACE_ARRAYSIZE 512
+#define SVGA3D_SM5_MAX_SURFACE_ARRAYSIZE 2048
+#define SVGA3D_MAX_SURFACE_ARRAYSIZE SVGA3D_SM5_MAX_SURFACE_ARRAYSIZE
 
 /*
  * The maximum number of vertex arrays we're guaranteed to support in
@@ -99,4 +122,9 @@
  */
 #define SVGA3D_MAX_DRAW_PRIMITIVE_RANGES 32
 
+/*
+ * The maximum number of samples that can be contained in a surface.
+ */
+#define SVGA3D_MAX_SAMPLES 8
+
 #endif /* _SVGA3D_LIMITS_H_ */
diff --git a/drivers/gpu/drm/vmwgfx/device_include/svga3d_surfacedefs.h b/drivers/gpu/drm/vmwgfx/device_include/svga3d_surfacedefs.h
index 61414f105c67..4db25bd9fa22 100644
--- a/drivers/gpu/drm/vmwgfx/device_include/svga3d_surfacedefs.h
+++ b/drivers/gpu/drm/vmwgfx/device_include/svga3d_surfacedefs.h
@@ -131,6 +131,8 @@ enum svga3d_block_desc {
 	SVGA3DBLOCKDESC_BC3         = 1 << 26,
 	SVGA3DBLOCKDESC_BC4         = 1 << 27,
 	SVGA3DBLOCKDESC_BC5         = 1 << 28,
+	SVGA3DBLOCKDESC_BC6H        = 1 << 29,
+	SVGA3DBLOCKDESC_BC7         = 1 << 30,
 
 	SVGA3DBLOCKDESC_A_UINT    = SVGA3DBLOCKDESC_ALPHA |
 				    SVGA3DBLOCKDESC_UINT |
@@ -290,6 +292,18 @@ enum svga3d_block_desc {
 					 SVGA3DBLOCKDESC_COMP_UNORM,
 	SVGA3DBLOCKDESC_BC5_COMP_SNORM = SVGA3DBLOCKDESC_BC5 |
 					 SVGA3DBLOCKDESC_COMP_SNORM,
+	SVGA3DBLOCKDESC_BC6H_COMP_TYPELESS = SVGA3DBLOCKDESC_BC6H |
+					     SVGA3DBLOCKDESC_COMP_TYPELESS,
+	SVGA3DBLOCKDESC_BC6H_COMP_UF16 = SVGA3DBLOCKDESC_BC6H |
+					 SVGA3DBLOCKDESC_COMPRESSED,
+	SVGA3DBLOCKDESC_BC6H_COMP_SF16 = SVGA3DBLOCKDESC_BC6H |
+					 SVGA3DBLOCKDESC_COMPRESSED,
+	SVGA3DBLOCKDESC_BC7_COMP_TYPELESS = SVGA3DBLOCKDESC_BC7 |
+					    SVGA3DBLOCKDESC_COMP_TYPELESS,
+	SVGA3DBLOCKDESC_BC7_COMP_UNORM = SVGA3DBLOCKDESC_BC7 |
+					 SVGA3DBLOCKDESC_COMP_UNORM,
+	SVGA3DBLOCKDESC_BC7_COMP_UNORM_SRGB = SVGA3DBLOCKDESC_BC7_COMP_UNORM |
+					      SVGA3DBLOCKDESC_SRGB,
 
 	SVGA3DBLOCKDESC_NV12       = SVGA3DBLOCKDESC_YUV_VIDEO |
 				     SVGA3DBLOCKDESC_PLANAR_YUV |
@@ -494,7 +508,7 @@ static const struct svga3d_surface_desc svga3d_surface_descs[] = {
       {{8}, {8}, {8}, {0}},
       {{16}, {8}, {0}, {0}}},
 
-   {SVGA3D_FORMAT_DEAD1, SVGA3DBLOCKDESC_UVL,
+   {SVGA3D_FORMAT_DEAD1, SVGA3DBLOCKDESC_NONE,
       {1, 1, 1},  3, 3,
       {{8}, {8}, {8}, {0}},
       {{16}, {8}, {0}, {0}}},
@@ -604,7 +618,7 @@ static const struct svga3d_surface_desc svga3d_surface_descs[] = {
       {{0}, {0}, {48}, {0}},
       {{0}, {0}, {0}, {0}}},
 
-   {SVGA3D_AYUV, SVGA3DBLOCKDESC_AYUV,
+   {SVGA3D_FORMAT_DEAD2, SVGA3DBLOCKDESC_NONE,
       {1, 1, 1},  4, 4,
       {{8}, {8}, {8}, {8}},
       {{0}, {8}, {16}, {24}}},
@@ -1103,6 +1117,46 @@ static const struct svga3d_surface_desc svga3d_surface_descs[] = {
       {4, 4, 1},  16, 16,
       {{0}, {0}, {128}, {0}},
       {{0}, {0}, {0}, {0}}},
+
+   {SVGA3D_B4G4R4A4_UNORM, SVGA3DBLOCKDESC_RGBA_UNORM,
+      {1, 1, 1},  2, 2,
+      {{4}, {4}, {4}, {4}},
+      {{0}, {4}, {8}, {12}}},
+
+   {SVGA3D_BC6H_TYPELESS, SVGA3DBLOCKDESC_BC6H_COMP_TYPELESS,
+      {4, 4, 1},  16, 16,
+      {{0}, {0}, {128}, {0}},
+      {{0}, {0}, {0}, {0}}},
+
+   {SVGA3D_BC6H_UF16, SVGA3DBLOCKDESC_BC6H_COMP_UF16,
+      {4, 4, 1},  16, 16,
+      {{0}, {0}, {128}, {0}},
+      {{0}, {0}, {0}, {0}}},
+
+   {SVGA3D_BC6H_SF16, SVGA3DBLOCKDESC_BC6H_COMP_SF16,
+      {4, 4, 1},  16, 16,
+      {{0}, {0}, {128}, {0}},
+      {{0}, {0}, {0}, {0}}},
+
+   {SVGA3D_BC7_TYPELESS, SVGA3DBLOCKDESC_BC7_COMP_TYPELESS,
+      {4, 4, 1},  16, 16,
+      {{0}, {0}, {128}, {0}},
+      {{0}, {0}, {0}, {0}}},
+
+   {SVGA3D_BC7_UNORM, SVGA3DBLOCKDESC_BC7_COMP_UNORM,
+      {4, 4, 1},  16, 16,
+      {{0}, {0}, {128}, {0}},
+      {{0}, {0}, {0}, {0}}},
+
+   {SVGA3D_BC7_UNORM_SRGB, SVGA3DBLOCKDESC_BC7_COMP_UNORM_SRGB,
+      {4, 4, 1},  16, 16,
+      {{0}, {0}, {128}, {0}},
+      {{0}, {0}, {0}, {0}}},
+
+   {SVGA3D_AYUV, SVGA3DBLOCKDESC_AYUV,
+      {1, 1, 1},  4, 4,
+      {{8}, {8}, {8}, {8}},
+      {{0}, {8}, {16}, {24}}},
 };
 
 static inline u32 clamped_umul32(u32 a, u32 b)
diff --git a/drivers/gpu/drm/vmwgfx/device_include/svga3d_types.h b/drivers/gpu/drm/vmwgfx/device_include/svga3d_types.h
index 308370665a8e..77e338a65791 100644
--- a/drivers/gpu/drm/vmwgfx/device_include/svga3d_types.h
+++ b/drivers/gpu/drm/vmwgfx/device_include/svga3d_types.h
@@ -113,6 +113,19 @@ struct {
 #include "vmware_pack_end.h"
 SVGA3dBox;
 
+typedef
+#include "vmware_pack_begin.h"
+struct {
+   int32                x;
+   int32                y;
+   int32                z;
+   int32                w;
+   int32                h;
+   int32                d;
+}
+#include "vmware_pack_end.h"
+SVGA3dSignedBox;
+
 typedef
 #include "vmware_pack_begin.h"
 struct {
@@ -198,8 +211,7 @@ typedef enum SVGA3dSurfaceFormat {
    /* Planar video formats */
    SVGA3D_NV12                         = 44,
 
-   /* Video format with alpha */
-   SVGA3D_AYUV                         = 45,
+   SVGA3D_FORMAT_DEAD2                 = 45,
 
    SVGA3D_R32G32B32A32_TYPELESS        = 46,
    SVGA3D_R32G32B32A32_UINT            = 47,
@@ -305,6 +317,18 @@ typedef enum SVGA3dSurfaceFormat {
    SVGA3D_B8G8R8X8_UNORM               = 142,
    SVGA3D_BC4_UNORM                    = 143,
    SVGA3D_BC5_UNORM                    = 144,
+   SVGA3D_B4G4R4A4_UNORM               = 145,
+   
+   /* DX11 compressed formats */
+   SVGA3D_BC6H_TYPELESS                = 146,
+   SVGA3D_BC6H_UF16                    = 147,
+   SVGA3D_BC6H_SF16                    = 148,
+   SVGA3D_BC7_TYPELESS                 = 149,
+   SVGA3D_BC7_UNORM                    = 150,
+   SVGA3D_BC7_UNORM_SRGB               = 151,
+
+   /* Video format with alpha */
+   SVGA3D_AYUV                         = 152,
 
    SVGA3D_FORMAT_MAX
 } SVGA3dSurfaceFormat;
@@ -326,10 +350,10 @@ typedef enum SVGA3dSurfaceFormat {
 #define SVGA3D_SURFACE_HINT_RENDERTARGET      (CONST64U(1) << 6)
 #define SVGA3D_SURFACE_HINT_DEPTHSTENCIL      (CONST64U(1) << 7)
 #define SVGA3D_SURFACE_HINT_WRITEONLY         (CONST64U(1) << 8)
-#define SVGA3D_SURFACE_MASKABLE_ANTIALIAS     (CONST64U(1) << 9)
+#define SVGA3D_SURFACE_DEAD2                  (CONST64U(1) << 9)
 #define SVGA3D_SURFACE_AUTOGENMIPMAPS         (CONST64U(1) << 10)
 
-#define SVGA3D_SURFACE_DECODE_RENDERTARGET    (CONST64U(1) << 11)
+#define SVGA3D_SURFACE_DEAD1                  (CONST64U(1) << 11)
 
 /*
  * Is this surface using a base-level pitch for it's mob backing?
@@ -387,7 +411,7 @@ typedef enum SVGA3dSurfaceFormat {
  * Setting this flag allow this surface to be used with the
  * SVGA_3D_CMD_DX_TRANSFER_FROM_BUFFER command.  It is only valid for
  * buffer surfaces, and no bind flags are allowed to be set on surfaces
- * with this flag.
+ * with this flag except SVGA3D_SURFACE_TRANSFER_TO_BUFFER.
  */
 #define SVGA3D_SURFACE_TRANSFER_FROM_BUFFER   (CONST64U(1) << 30)
 
@@ -402,7 +426,31 @@ typedef enum SVGA3dSurfaceFormat {
  */
 #define SVGA3D_SURFACE_MULTISAMPLE            (CONST64U(1) << 32)
 
-#define SVGA3D_SURFACE_FLAG_MAX               (CONST64U(1) << 33)
+/*
+ * Specified that the surface is allowed to be bound to a UAView.
+ */
+#define SVGA3D_SURFACE_BIND_UAVIEW            (CONST64U(1) << 33)
+
+/*
+ * Setting this flag allow this surface to be used with the
+ * SVGA_3D_CMD_DX_TRANSFER_TO_BUFFER command.  It is only valid for
+ * buffer surfaces, and no bind flags are allowed to be set on surfaces
+ * with this flag except SVGA3D_SURFACE_TRANSFER_FROM_BUFFER.
+ */
+#define SVGA3D_SURFACE_TRANSFER_TO_BUFFER     (CONST64U(1) << 34)
+
+#define SVGA3D_SURFACE_BIND_LOGICOPS          (CONST64U(1) << 35)
+
+/*
+ * Optional flags for use with SVGA3D_SURFACE_BIND_UAVIEW
+ */
+#define SVGA3D_SURFACE_BIND_RAW_VIEWS         (CONST64U(1) << 36)
+#define SVGA3D_SURFACE_BUFFER_STRUCTURED      (CONST64U(1) << 37)
+
+#define SVGA3D_SURFACE_DRAWINDIRECT_ARGS      (CONST64U(1) << 38)
+#define SVGA3D_SURFACE_RESOURCE_CLAMP         (CONST64U(1) << 39)
+
+#define SVGA3D_SURFACE_FLAG_MAX               (CONST64U(1) << 40)
 
 /*
  * Surface flags types:
@@ -428,17 +476,25 @@ typedef uint64 SVGA3dSurfaceAllFlags;
            SVGA3D_SURFACE_STAGING_DOWNLOAD |     \
            SVGA3D_SURFACE_HINT_INDIRECT_UPDATE | \
            SVGA3D_SURFACE_TRANSFER_FROM_BUFFER | \
-           SVGA3D_SURFACE_MULTISAMPLE            \
+           SVGA3D_SURFACE_RESERVED1 |             \
+           SVGA3D_SURFACE_MULTISAMPLE |          \
+           SVGA3D_SURFACE_BIND_UAVIEW |          \
+           SVGA3D_SURFACE_TRANSFER_TO_BUFFER |   \
+           SVGA3D_SURFACE_BIND_LOGICOPS |        \
+           SVGA3D_SURFACE_BIND_RAW_VIEWS |       \
+           SVGA3D_SURFACE_BUFFER_STRUCTURED |    \
+           SVGA3D_SURFACE_DRAWINDIRECT_ARGS |    \
+           SVGA3D_SURFACE_RESOURCE_CLAMP         \
         )
 
 #define SVGA3D_SURFACE_HB_PRESENT_DISALLOWED_MASK   \
        (   SVGA3D_SURFACE_1D |                      \
+           SVGA3D_SURFACE_RESERVED1 |                \
            SVGA3D_SURFACE_MULTISAMPLE               \
         )
 
 #define SVGA3D_SURFACE_2D_DISALLOWED_MASK           \
         (  SVGA3D_SURFACE_CUBEMAP |                 \
-           SVGA3D_SURFACE_MASKABLE_ANTIALIAS |      \
            SVGA3D_SURFACE_AUTOGENMIPMAPS |          \
            SVGA3D_SURFACE_VOLUME |                  \
            SVGA3D_SURFACE_1D |                      \
@@ -448,7 +504,14 @@ typedef uint64 SVGA3dSurfaceAllFlags;
            SVGA3D_SURFACE_BIND_DEPTH_STENCIL |      \
            SVGA3D_SURFACE_BIND_STREAM_OUTPUT |      \
            SVGA3D_SURFACE_TRANSFER_FROM_BUFFER |    \
-           SVGA3D_SURFACE_MULTISAMPLE               \
+           SVGA3D_SURFACE_RESERVED1 |                \
+           SVGA3D_SURFACE_MULTISAMPLE |             \
+           SVGA3D_SURFACE_BIND_UAVIEW |             \
+           SVGA3D_SURFACE_TRANSFER_TO_BUFFER |      \
+           SVGA3D_SURFACE_BIND_RAW_VIEWS |          \
+           SVGA3D_SURFACE_BUFFER_STRUCTURED |       \
+           SVGA3D_SURFACE_DRAWINDIRECT_ARGS |       \
+           SVGA3D_SURFACE_RESOURCE_CLAMP            \
         )
 
 #define SVGA3D_SURFACE_BASICOPS_DISALLOWED_MASK     \
@@ -456,6 +519,7 @@ typedef uint64 SVGA3dSurfaceAllFlags;
            SVGA3D_SURFACE_AUTOGENMIPMAPS |          \
            SVGA3D_SURFACE_VOLUME |                  \
            SVGA3D_SURFACE_1D |                      \
+           SVGA3D_SURFACE_RESERVED1 |                \
            SVGA3D_SURFACE_MULTISAMPLE               \
         )
 
@@ -474,7 +538,14 @@ typedef uint64 SVGA3dSurfaceAllFlags;
            SVGA3D_SURFACE_STAGING_DOWNLOAD |        \
            SVGA3D_SURFACE_HINT_INDIRECT_UPDATE |    \
            SVGA3D_SURFACE_TRANSFER_FROM_BUFFER |    \
-           SVGA3D_SURFACE_MULTISAMPLE               \
+           SVGA3D_SURFACE_RESERVED1 |                \
+           SVGA3D_SURFACE_MULTISAMPLE |             \
+           SVGA3D_SURFACE_BIND_UAVIEW |             \
+           SVGA3D_SURFACE_TRANSFER_TO_BUFFER |      \
+           SVGA3D_SURFACE_BIND_RAW_VIEWS |          \
+           SVGA3D_SURFACE_BUFFER_STRUCTURED |       \
+           SVGA3D_SURFACE_DRAWINDIRECT_ARGS |       \
+           SVGA3D_SURFACE_RESOURCE_CLAMP            \
         )
 
 #define SVGA3D_SURFACE_BUFFER_DISALLOWED_MASK       \
@@ -482,10 +553,11 @@ typedef uint64 SVGA3dSurfaceAllFlags;
            SVGA3D_SURFACE_AUTOGENMIPMAPS |          \
            SVGA3D_SURFACE_VOLUME |                  \
            SVGA3D_SURFACE_1D |                      \
-           SVGA3D_SURFACE_MASKABLE_ANTIALIAS |      \
+           SVGA3D_SURFACE_DEAD2 |                   \
            SVGA3D_SURFACE_ARRAY |                   \
            SVGA3D_SURFACE_MULTISAMPLE |             \
-           SVGA3D_SURFACE_MOB_PITCH                 \
+           SVGA3D_SURFACE_MOB_PITCH |               \
+           SVGA3D_SURFACE_RESOURCE_CLAMP            \
         )
 
 #define SVGA3D_SURFACE_MULTISAMPLE_DISALLOWED_MASK  \
@@ -494,14 +566,23 @@ typedef uint64 SVGA3dSurfaceAllFlags;
            SVGA3D_SURFACE_VOLUME |                  \
            SVGA3D_SURFACE_1D |                      \
            SVGA3D_SURFACE_SCREENTARGET |            \
-           SVGA3D_SURFACE_MOB_PITCH                 \
+           SVGA3D_SURFACE_MOB_PITCH |               \
+           SVGA3D_SURFACE_TRANSFER_FROM_BUFFER |    \
+           SVGA3D_SURFACE_RESERVED1 |                \
+           SVGA3D_SURFACE_BIND_UAVIEW |             \
+           SVGA3D_SURFACE_TRANSFER_TO_BUFFER |      \
+           SVGA3D_SURFACE_BIND_LOGICOPS |           \
+           SVGA3D_SURFACE_BIND_RAW_VIEWS |          \
+           SVGA3D_SURFACE_BUFFER_STRUCTURED |       \
+           SVGA3D_SURFACE_DRAWINDIRECT_ARGS         \
         )
 
-#define SVGA3D_SURFACE_DX_ONLY_MASK             \
-        (  SVGA3D_SURFACE_BIND_STREAM_OUTPUT |  \
-           SVGA3D_SURFACE_STAGING_UPLOAD |      \
-           SVGA3D_SURFACE_STAGING_DOWNLOAD |    \
-           SVGA3D_SURFACE_TRANSFER_FROM_BUFFER  \
+#define SVGA3D_SURFACE_DX_ONLY_MASK              \
+        (  SVGA3D_SURFACE_BIND_STREAM_OUTPUT |   \
+           SVGA3D_SURFACE_STAGING_UPLOAD |       \
+           SVGA3D_SURFACE_STAGING_DOWNLOAD |     \
+           SVGA3D_SURFACE_TRANSFER_FROM_BUFFER | \
+           SVGA3D_SURFACE_TRANSFER_TO_BUFFER     \
         )
 
 #define SVGA3D_SURFACE_STAGING_MASK             \
@@ -516,9 +597,135 @@ typedef uint64 SVGA3dSurfaceAllFlags;
            SVGA3D_SURFACE_BIND_SHADER_RESOURCE |  \
            SVGA3D_SURFACE_BIND_RENDER_TARGET   |  \
            SVGA3D_SURFACE_BIND_DEPTH_STENCIL   |  \
-           SVGA3D_SURFACE_BIND_STREAM_OUTPUT      \
+           SVGA3D_SURFACE_BIND_STREAM_OUTPUT   |  \
+           SVGA3D_SURFACE_BIND_UAVIEW          |  \
+           SVGA3D_SURFACE_BIND_LOGICOPS        |  \
+           SVGA3D_SURFACE_BIND_RAW_VIEWS          \
+        )
+
+#define SVGA3D_SURFACE_VADECODE_DISALLOWED_MASK     \
+        (  SVGA3D_SURFACE_CUBEMAP |                 \
+           SVGA3D_SURFACE_HINT_STATIC |             \
+           SVGA3D_SURFACE_HINT_DYNAMIC |            \
+           SVGA3D_SURFACE_HINT_INDEXBUFFER |        \
+           SVGA3D_SURFACE_HINT_VERTEXBUFFER |       \
+           SVGA3D_SURFACE_HINT_TEXTURE |            \
+           SVGA3D_SURFACE_HINT_RENDERTARGET |       \
+           SVGA3D_SURFACE_HINT_DEPTHSTENCIL |       \
+           SVGA3D_SURFACE_HINT_WRITEONLY |          \
+           SVGA3D_SURFACE_DEAD2 |                   \
+           SVGA3D_SURFACE_AUTOGENMIPMAPS |          \
+           SVGA3D_SURFACE_HINT_RT_LOCKABLE |        \
+           SVGA3D_SURFACE_VOLUME |                  \
+           SVGA3D_SURFACE_SCREENTARGET |            \
+           SVGA3D_SURFACE_1D |                      \
+           SVGA3D_SURFACE_BIND_VERTEX_BUFFER |      \
+           SVGA3D_SURFACE_BIND_INDEX_BUFFER |       \
+           SVGA3D_SURFACE_BIND_CONSTANT_BUFFER |    \
+           SVGA3D_SURFACE_BIND_RENDER_TARGET |      \
+           SVGA3D_SURFACE_BIND_SHADER_RESOURCE |    \
+           SVGA3D_SURFACE_BIND_DEPTH_STENCIL |      \
+           SVGA3D_SURFACE_BIND_STREAM_OUTPUT |      \
+           SVGA3D_SURFACE_INACTIVE |                \
+           SVGA3D_SURFACE_STAGING_UPLOAD |          \
+           SVGA3D_SURFACE_STAGING_DOWNLOAD |        \
+           SVGA3D_SURFACE_HINT_INDIRECT_UPDATE |    \
+           SVGA3D_SURFACE_TRANSFER_FROM_BUFFER  |   \
+           SVGA3D_SURFACE_MULTISAMPLE |             \
+           SVGA3D_SURFACE_BIND_UAVIEW |             \
+           SVGA3D_SURFACE_TRANSFER_TO_BUFFER |      \
+           SVGA3D_SURFACE_BIND_LOGICOPS |           \
+           SVGA3D_SURFACE_BIND_RAW_VIEWS |          \
+           SVGA3D_SURFACE_BUFFER_STRUCTURED |       \
+           SVGA3D_SURFACE_DRAWINDIRECT_ARGS |       \
+           SVGA3D_SURFACE_RESOURCE_CLAMP            \
+        )
+
+#define SVGA3D_SURFACE_VAPROCESSFRAME_OUTPUT_DISALLOWED_MASK     \
+        (  SVGA3D_SURFACE_HINT_INDEXBUFFER |                     \
+           SVGA3D_SURFACE_HINT_VERTEXBUFFER |                    \
+           SVGA3D_SURFACE_HINT_DEPTHSTENCIL |                    \
+           SVGA3D_SURFACE_DEAD2 |                                \
+           SVGA3D_SURFACE_VOLUME |                               \
+           SVGA3D_SURFACE_1D |                                   \
+           SVGA3D_SURFACE_BIND_VERTEX_BUFFER |                   \
+           SVGA3D_SURFACE_BIND_INDEX_BUFFER |                    \
+           SVGA3D_SURFACE_BIND_CONSTANT_BUFFER |                 \
+           SVGA3D_SURFACE_BIND_DEPTH_STENCIL |                   \
+           SVGA3D_SURFACE_BIND_STREAM_OUTPUT |                   \
+           SVGA3D_SURFACE_INACTIVE |                             \
+           SVGA3D_SURFACE_STAGING_UPLOAD |                       \
+           SVGA3D_SURFACE_STAGING_DOWNLOAD |                     \
+           SVGA3D_SURFACE_TRANSFER_FROM_BUFFER |                 \
+           SVGA3D_SURFACE_VADECODE |                             \
+           SVGA3D_SURFACE_MULTISAMPLE |                          \
+           SVGA3D_SURFACE_BIND_UAVIEW |                          \
+           SVGA3D_SURFACE_TRANSFER_TO_BUFFER |                   \
+           SVGA3D_SURFACE_BIND_LOGICOPS |                        \
+           SVGA3D_SURFACE_BIND_RAW_VIEWS |                       \
+           SVGA3D_SURFACE_BUFFER_STRUCTURED |                    \
+           SVGA3D_SURFACE_DRAWINDIRECT_ARGS |                    \
+           SVGA3D_SURFACE_RESOURCE_CLAMP         \
+        )
+
+#define SVGA3D_SURFACE_VAPROCESSFRAME_INPUT_DISALLOWED_MASK     \
+        ( SVGA3D_SURFACE_CUBEMAP |                              \
+          SVGA3D_SURFACE_HINT_INDEXBUFFER |                     \
+          SVGA3D_SURFACE_HINT_VERTEXBUFFER |                    \
+          SVGA3D_SURFACE_HINT_DEPTHSTENCIL |                    \
+          SVGA3D_SURFACE_DEAD2 |                                \
+          SVGA3D_SURFACE_VOLUME |                               \
+          SVGA3D_SURFACE_SCREENTARGET |                         \
+          SVGA3D_SURFACE_1D |                                   \
+          SVGA3D_SURFACE_BIND_VERTEX_BUFFER |                   \
+          SVGA3D_SURFACE_BIND_INDEX_BUFFER |                    \
+          SVGA3D_SURFACE_BIND_CONSTANT_BUFFER |                 \
+          SVGA3D_SURFACE_BIND_DEPTH_STENCIL |                   \
+          SVGA3D_SURFACE_BIND_STREAM_OUTPUT |                   \
+          SVGA3D_SURFACE_STAGING_UPLOAD |                       \
+          SVGA3D_SURFACE_STAGING_DOWNLOAD |                     \
+          SVGA3D_SURFACE_TRANSFER_FROM_BUFFER |                 \
+          SVGA3D_SURFACE_MULTISAMPLE |                          \
+          SVGA3D_SURFACE_BIND_UAVIEW |                          \
+          SVGA3D_SURFACE_TRANSFER_TO_BUFFER |                   \
+          SVGA3D_SURFACE_BIND_LOGICOPS |                        \
+          SVGA3D_SURFACE_BIND_RAW_VIEWS |                       \
+          SVGA3D_SURFACE_BUFFER_STRUCTURED |                    \
+          SVGA3D_SURFACE_DRAWINDIRECT_ARGS |                    \
+          SVGA3D_SURFACE_RESOURCE_CLAMP                         \
+        )
+
+#define SVGA3D_SURFACE_LOGICOPS_DISALLOWED_MASK     \
+        (  SVGA3D_SURFACE_CUBEMAP |                 \
+           SVGA3D_SURFACE_DEAD2 |                   \
+           SVGA3D_SURFACE_AUTOGENMIPMAPS |          \
+           SVGA3D_SURFACE_VOLUME |                  \
+           SVGA3D_SURFACE_1D |                      \
+           SVGA3D_SURFACE_BIND_VERTEX_BUFFER |      \
+           SVGA3D_SURFACE_BIND_INDEX_BUFFER |       \
+           SVGA3D_SURFACE_BIND_CONSTANT_BUFFER |    \
+           SVGA3D_SURFACE_BIND_DEPTH_STENCIL |      \
+           SVGA3D_SURFACE_BIND_STREAM_OUTPUT |      \
+           SVGA3D_SURFACE_TRANSFER_FROM_BUFFER |    \
+           SVGA3D_SURFACE_VADECODE |                \
+           SVGA3D_SURFACE_MULTISAMPLE |             \
+           SVGA3D_SURFACE_BIND_UAVIEW |             \
+           SVGA3D_SURFACE_TRANSFER_TO_BUFFER |      \
+           SVGA3D_SURFACE_BIND_RAW_VIEWS |          \
+           SVGA3D_SURFACE_BUFFER_STRUCTURED |       \
+           SVGA3D_SURFACE_DRAWINDIRECT_ARGS |       \
+           SVGA3D_SURFACE_RESOURCE_CLAMP            \
         )
 
+#define SVGA3D_BUFFER_STRUCTURED_STRIDE_MAX 2048
+
+
+/*
+ * These are really the D3DFORMAT_OP defines from the wdk. We need
+ * them so that we can query the host for what the supported surface
+ * operations are (when we're using the D3D backend, in particular),
+ * and so we can send those operations to the guest.
+ */
 typedef enum {
    SVGA3DFORMAT_OP_TEXTURE                               = 0x00000001,
    SVGA3DFORMAT_OP_VOLUMETEXTURE                         = 0x00000002,
@@ -1338,7 +1545,40 @@ typedef enum {
    SVGA3D_PRIMITIVE_LINESTRIP_ADJ               = 8,
    SVGA3D_PRIMITIVE_TRIANGLELIST_ADJ            = 9,
    SVGA3D_PRIMITIVE_TRIANGLESTRIP_ADJ           = 10,
-   SVGA3D_PRIMITIVE_MAX
+   SVGA3D_PRIMITIVE_DX10_MAX                    = 11,
+   SVGA3D_PRIMITIVE_1_CONTROL_POINT_PATCH       = 11,
+   SVGA3D_PRIMITIVE_2_CONTROL_POINT_PATCH       = 12,
+   SVGA3D_PRIMITIVE_3_CONTROL_POINT_PATCH       = 13,
+   SVGA3D_PRIMITIVE_4_CONTROL_POINT_PATCH       = 14,
+   SVGA3D_PRIMITIVE_5_CONTROL_POINT_PATCH       = 15,
+   SVGA3D_PRIMITIVE_6_CONTROL_POINT_PATCH       = 16,
+   SVGA3D_PRIMITIVE_7_CONTROL_POINT_PATCH       = 17,
+   SVGA3D_PRIMITIVE_8_CONTROL_POINT_PATCH       = 18,
+   SVGA3D_PRIMITIVE_9_CONTROL_POINT_PATCH       = 19,
+   SVGA3D_PRIMITIVE_10_CONTROL_POINT_PATCH      = 20,
+   SVGA3D_PRIMITIVE_11_CONTROL_POINT_PATCH      = 21,
+   SVGA3D_PRIMITIVE_12_CONTROL_POINT_PATCH      = 22,
+   SVGA3D_PRIMITIVE_13_CONTROL_POINT_PATCH      = 23,
+   SVGA3D_PRIMITIVE_14_CONTROL_POINT_PATCH      = 24,
+   SVGA3D_PRIMITIVE_15_CONTROL_POINT_PATCH      = 25,
+   SVGA3D_PRIMITIVE_16_CONTROL_POINT_PATCH      = 26,
+   SVGA3D_PRIMITIVE_17_CONTROL_POINT_PATCH      = 27,
+   SVGA3D_PRIMITIVE_18_CONTROL_POINT_PATCH      = 28,
+   SVGA3D_PRIMITIVE_19_CONTROL_POINT_PATCH      = 29,
+   SVGA3D_PRIMITIVE_20_CONTROL_POINT_PATCH      = 30,
+   SVGA3D_PRIMITIVE_21_CONTROL_POINT_PATCH      = 31,
+   SVGA3D_PRIMITIVE_22_CONTROL_POINT_PATCH      = 32,
+   SVGA3D_PRIMITIVE_23_CONTROL_POINT_PATCH      = 33,
+   SVGA3D_PRIMITIVE_24_CONTROL_POINT_PATCH      = 34,
+   SVGA3D_PRIMITIVE_25_CONTROL_POINT_PATCH      = 35,
+   SVGA3D_PRIMITIVE_26_CONTROL_POINT_PATCH      = 36,
+   SVGA3D_PRIMITIVE_27_CONTROL_POINT_PATCH      = 37,
+   SVGA3D_PRIMITIVE_28_CONTROL_POINT_PATCH      = 38,
+   SVGA3D_PRIMITIVE_29_CONTROL_POINT_PATCH      = 39,
+   SVGA3D_PRIMITIVE_30_CONTROL_POINT_PATCH      = 40,
+   SVGA3D_PRIMITIVE_31_CONTROL_POINT_PATCH      = 41,
+   SVGA3D_PRIMITIVE_32_CONTROL_POINT_PATCH      = 42,
+   SVGA3D_PRIMITIVE_MAX                         = 43
 } SVGA3dPrimitiveType;
 
 typedef enum {
@@ -1442,16 +1682,15 @@ typedef enum {
    SVGA3D_QUERYTYPE_STREAMOUTPUTSTATS           = 5,
    SVGA3D_QUERYTYPE_STREAMOVERFLOWPREDICATE     = 6,
    SVGA3D_QUERYTYPE_OCCLUSION64                 = 7,
-   SVGA3D_QUERYTYPE_EVENT                       = 8,
-   SVGA3D_QUERYTYPE_DX10_MAX                    = 9,
-   SVGA3D_QUERYTYPE_SOSTATS_STREAM0             = 9,
-   SVGA3D_QUERYTYPE_SOSTATS_STREAM1             = 10,
-   SVGA3D_QUERYTYPE_SOSTATS_STREAM2             = 11,
-   SVGA3D_QUERYTYPE_SOSTATS_STREAM3             = 12,
-   SVGA3D_QUERYTYPE_SOP_STREAM0                 = 13,
-   SVGA3D_QUERYTYPE_SOP_STREAM1                 = 14,
-   SVGA3D_QUERYTYPE_SOP_STREAM2                 = 15,
-   SVGA3D_QUERYTYPE_SOP_STREAM3                 = 16,
+   SVGA3D_QUERYTYPE_DX10_MAX                    = 8,
+   SVGA3D_QUERYTYPE_SOSTATS_STREAM0             = 8,
+   SVGA3D_QUERYTYPE_SOSTATS_STREAM1             = 9,
+   SVGA3D_QUERYTYPE_SOSTATS_STREAM2             = 10,
+   SVGA3D_QUERYTYPE_SOSTATS_STREAM3             = 11,
+   SVGA3D_QUERYTYPE_SOP_STREAM0                 = 12,
+   SVGA3D_QUERYTYPE_SOP_STREAM1                 = 13,
+   SVGA3D_QUERYTYPE_SOP_STREAM2                 = 14,
+   SVGA3D_QUERYTYPE_SOP_STREAM3                 = 15,
    SVGA3D_QUERYTYPE_MAX
 } SVGA3dQueryType;
 
@@ -1584,28 +1823,33 @@ typedef enum {
    SVGA3D_READ_HOST_VRAM         = 2,
 } SVGA3dTransferType;
 
-typedef enum {
-   SVGA3D_LOGICOP_INVALID   = 0,
-   SVGA3D_LOGICOP_MIN       = 1,
-   SVGA3D_LOGICOP_COPY      = 1,
-   SVGA3D_LOGICOP_NOT       = 2,
-   SVGA3D_LOGICOP_AND       = 3,
-   SVGA3D_LOGICOP_OR        = 4,
-   SVGA3D_LOGICOP_XOR       = 5,
-   SVGA3D_LOGICOP_NXOR      = 6,
-   SVGA3D_LOGICOP_ROP3MIN   = 30,   /* 7-29 are reserved for future logic ops. */
-   SVGA3D_LOGICOP_ROP3MAX   = (SVGA3D_LOGICOP_ROP3MIN + 255),
-   SVGA3D_LOGICOP_MAX       = (SVGA3D_LOGICOP_ROP3MAX + 1),
-} SVGA3dLogicOp;
+#define SVGA3D_LOGICOP_INVALID  0
+#define SVGA3D_LOGICOP_MIN      1
+#define SVGA3D_LOGICOP_COPY     1
+#define SVGA3D_LOGICOP_NOT      2
+#define SVGA3D_LOGICOP_AND      3
+#define SVGA3D_LOGICOP_OR       4
+#define SVGA3D_LOGICOP_XOR      5
+#define SVGA3D_LOGICOP_NXOR     6
+#define SVGA3D_LOGICOP_ROP3     7
+#define SVGA3D_LOGICOP_MAX      8
+
+typedef uint16 SVGA3dLogicOp;
+
+#define SVGA3D_LOGICOP_ROP3_INVALID ((uint16) -1)
+#define SVGA3D_LOGICOP_ROP3_MIN     0
+#define SVGA3D_LOGICOP_ROP3_MAX     256
+
+typedef uint16 SVGA3dLogicOpRop3;
 
 typedef
 #include "vmware_pack_begin.h"
 struct {
    union {
       struct {
-         uint16  function;       /* SVGA3dFogFunction */
-         uint8   type;           /* SVGA3dFogType */
-         uint8   base;           /* SVGA3dFogBase */
+         uint16  function;       // SVGA3dFogFunction
+         uint8   type;           // SVGA3dFogType
+         uint8   base;           // SVGA3dFogBase
       };
       uint32     uintValue;
    };
@@ -1742,4 +1986,15 @@ typedef enum SVGA3dMSQualityLevel {
    SVGA3D_MS_QUALITY_MAX  = 2,
 } SVGA3dMSQualityLevel;
 
+/*
+ * Screen Target Update Flags
+ */
+
+typedef enum SVGA3dFrameUpdateType {
+   SVGA3D_FRAME_END     = 0,
+   SVGA3D_FRAME_PARTIAL = 1,
+   SVGA3D_FRAME_UNKNOWN = 2,
+   SVGA3D_FRAME_MAX     = 3,
+} SVGA3dFrameUpdateType;
+
 #endif /* _SVGA3D_TYPES_H_ */
diff --git a/drivers/gpu/drm/vmwgfx/device_include/svga_reg.h b/drivers/gpu/drm/vmwgfx/device_include/svga_reg.h
index 056f54b35d73..19fb9e3299e7 100644
--- a/drivers/gpu/drm/vmwgfx/device_include/svga_reg.h
+++ b/drivers/gpu/drm/vmwgfx/device_include/svga_reg.h
@@ -70,8 +70,7 @@ typedef uint32 SVGAMobId;
 
 /*
  * Legal values for the SVGA_REG_CURSOR_ON register in old-fashioned
- * cursor bypass mode. This is still supported, but no new guest
- * drivers should use it.
+ * cursor bypass mode.
  */
 #define SVGA_CURSOR_ON_HIDE            0x0
 #define SVGA_CURSOR_ON_SHOW            0x1
@@ -136,6 +135,17 @@ typedef uint32 SVGAMobId;
 #define SVGA_IRQFLAG_COMMAND_BUFFER       0x8    /* Command buffer completed */
 #define SVGA_IRQFLAG_ERROR                0x10   /* Error while processing commands */
 
+/*
+ * The byte-size is the size of the actual cursor data,
+ * possibly after expanding it to the current bit depth.
+ *
+ * 40K is sufficient memory for two 32-bit planes for a 64 x 64 cursor.
+ *
+ * The dimension limit is a bound on the maximum width or height.
+ */
+#define SVGA_MAX_CURSOR_CMD_BYTES  (40 * 1024)
+#define SVGA_MAX_CURSOR_CMD_DIMENSION 1024
+
 /*
  * Registers
  */
@@ -169,7 +179,7 @@ enum {
    SVGA_REG_SYNC = 21,                /* See "FIFO Synchronization Registers" */
    SVGA_REG_BUSY = 22,                /* See "FIFO Synchronization Registers" */
    SVGA_REG_GUEST_ID = 23,            /* (Deprecated) */
-   SVGA_REG_CURSOR_ID = 24,           /* (Deprecated) */
+   SVGA_REG_DEAD = 24,                /* Drivers should never write this. */
    SVGA_REG_CURSOR_X = 25,            /* (Deprecated) */
    SVGA_REG_CURSOR_Y = 26,            /* (Deprecated) */
    SVGA_REG_CURSOR_ON = 27,           /* (Deprecated) */
@@ -208,7 +218,13 @@ enum {
    SVGA_REG_MAX_PRIMARY_MEM = 50,
    SVGA_REG_MAX_PRIMARY_BOUNDING_BOX_MEM = 50,
 
-   SVGA_REG_SUGGESTED_GBOBJECT_MEM_SIZE_KB = 51, /* Sugested limit on mob mem */
+   /*
+    * Legacy version of SVGA_REG_GBOBJECT_MEM_SIZE_KB for drivers that
+    * don't know how to convert to a 64-bit byte value without overflowing.
+    * (See SVGA_REG_GBOBJECT_MEM_SIZE_KB).
+    */
+   SVGA_REG_SUGGESTED_GBOBJECT_MEM_SIZE_KB = 51,
+
    SVGA_REG_DEV_CAP = 52,           /* Write dev cap index, read value */
    SVGA_REG_CMD_PREPEND_LOW = 53,
    SVGA_REG_CMD_PREPEND_HIGH = 54,
@@ -218,7 +234,59 @@ enum {
    SVGA_REG_BLANK_SCREEN_TARGETS = 58,
    SVGA_REG_CAP2 = 59,
    SVGA_REG_DEVEL_CAP = 60,
-   SVGA_REG_TOP = 61,               /* Must be 1 more than the last register */
+
+   /*
+    * Allow the guest to hint to the device which driver is running.
+    *
+    * This should not generally change device behavior, but might be
+    * convenient to work-around specific bugs in guest drivers.
+    *
+    * Drivers should first write their id value into SVGA_REG_GUEST_DRIVER_ID,
+    * and then fill out all of the version registers that they have defined.
+    *
+    * After the driver has written all of the registers, they should
+    * then write the value SVGA_REG_GUEST_DRIVER_ID_SUBMIT to the
+    * SVGA_REG_GUEST_DRIVER_ID register, to signal that they have finished.
+    *
+    * The SVGA_REG_GUEST_DRIVER_ID values are defined below by the
+    * SVGARegGuestDriverId enum.
+    *
+    * The SVGA_REG_GUEST_DRIVER_VERSION fields are driver-specific,
+    * but ideally should encode a monotonically increasing number that allows
+    * the device to perform inequality checks against ranges of driver versions.
+    */
+   SVGA_REG_GUEST_DRIVER_ID = 61,
+   SVGA_REG_GUEST_DRIVER_VERSION1 = 62,
+   SVGA_REG_GUEST_DRIVER_VERSION2 = 63,
+   SVGA_REG_GUEST_DRIVER_VERSION3 = 64,
+   SVGA_REG_CURSOR_MOBID = 65,
+   SVGA_REG_CURSOR_MAX_BYTE_SIZE = 66,
+   SVGA_REG_CURSOR_MAX_DIMENSION = 67,
+
+   SVGA_REG_FIFO_CAPS = 68,
+   SVGA_REG_FENCE = 69,
+
+   SVGA_REG_RESERVED1 = 70,
+   SVGA_REG_RESERVED2 = 71,
+   SVGA_REG_RESERVED3 = 72,
+   SVGA_REG_RESERVED4 = 73,
+   SVGA_REG_RESERVED5 = 74,
+   SVGA_REG_SCREENDMA = 75,
+
+   /*
+    * The maximum amount of guest-backed objects that the device can have
+    * resident at a time. Guest-drivers should keep their working set size
+    * below this limit for best performance.
+    *
+    * Note that this value is in kilobytes, and not bytes, because the actual
+    * number of bytes might be larger than can fit in a 32-bit register.
+    *
+    * PLEASE USE A 64-BIT VALUE WHEN CONVERTING THIS INTO BYTES.
+    * (See SVGA_REG_SUGGESTED_GBOBJECT_MEM_SIZE_KB).
+    */
+   SVGA_REG_GBOBJECT_MEM_SIZE_KB = 76,
+
+   SVGA_REG_TOP = 77,               /* Must be 1 more than the last register */
 
    SVGA_PALETTE_BASE = 1024,        /* Base of SVGA color map */
    /* Next 768 (== 256*3) registers exist for colormap */
@@ -229,6 +297,20 @@ enum {
       the use of the current SVGA driver. */
 };
 
+
+/*
+ * Values for SVGA_REG_GUEST_DRIVER_ID.
+ */
+typedef enum SVGARegGuestDriverId {
+   SVGA_REG_GUEST_DRIVER_ID_UNKNOWN = 0,
+   SVGA_REG_GUEST_DRIVER_ID_WDDM    = 1,
+   SVGA_REG_GUEST_DRIVER_ID_LINUX   = 2,
+   SVGA_REG_GUEST_DRIVER_ID_MAX,
+
+   SVGA_REG_GUEST_DRIVER_ID_SUBMIT  = MAX_UINT32,
+} SVGARegGuestDriverId;
+
+
 /*
  * Guest memory regions (GMRs):
  *
@@ -416,7 +498,6 @@ typedef enum {
    SVGA_CB_CONTEXT_0      = 0x0,
    SVGA_CB_CONTEXT_1      = 0x1, /* Supported with SVGA_CAP_HP_CMD_QUEUE */
    SVGA_CB_CONTEXT_MAX    = 0x2,
-   SVGA_CB_CONTEXT_HP_MAX = 0x2,
 } SVGACBContext;
 
 
@@ -733,9 +814,6 @@ SVGASignedPoint;
  * and must not be reused. Those capabilities will never be reported
  * by new versions of the SVGA device.
  *
- * XXX: Add longer descriptions for each capability, including a list
- *      of the new features that each capability provides.
- *
  * SVGA_CAP_IRQMASK --
  *    Provides device interrupts.  Adds device register SVGA_REG_IRQMASK
  *    to set interrupt mask and direct I/O port SVGA_IRQSTATUS_PORT to
@@ -842,17 +920,51 @@ SVGASignedPoint;
  *      Allow the IntraSurfaceCopy command.
  *
  * SVGA_CAP2_DX2 --
- *      Allow the DefineGBSurface_v3, WholeSurfaceCopy.
+ *      Allow the DefineGBSurface_v3, WholeSurfaceCopy, WriteZeroSurface, and
+ *      HintZeroSurface commands, and the SVGA_REG_GUEST_DRIVER_ID register.
+ *
+ * SVGA_CAP2_GB_MEMSIZE_2 --
+ *      Allow the SVGA_REG_GBOBJECT_MEM_SIZE_KB register.
+ *
+ * SVGA_CAP2_SCREENDMA_REG --
+ *      Allow the SVGA_REG_SCREENDMA register.
+ *
+ * SVGA_CAP2_OTABLE_PTDEPTH_2 --
+ *      Allow 2 level page tables for OTable commands.
+ *
+ * SVGA_CAP2_NON_MS_TO_MS_STRETCHBLT --
+ *      Allow a stretch blt from a non-multisampled surface to a multisampled
+ *      surface.
+ *
+ * SVGA_CAP2_CURSOR_MOB --
+ *      Allow the SVGA_REG_CURSOR_MOBID register.
+ *
+ * SVGA_CAP2_MSHINT --
+ *      Allow the SVGA_REG_MSHINT register.
+ *
+ * SVGA_CAP2_DX3 --
+ *      Allows the DefineGBSurface_v4 command.
+ *      Allows the DXDefineDepthStencilView_v2, DXDefineStreamOutputWithMob,
+ *      and DXBindStreamOutput commands if 3D is also available.
+ *      Allows the DXPredStagingCopy and DXStagingCopy commands if SM41
+ *      is also available.
  *
  * SVGA_CAP2_RESERVED --
  *      Reserve the last bit for extending the SVGA capabilities to some
  *      future mechanisms.
  */
-#define SVGA_CAP2_NONE               0x00000000
-#define SVGA_CAP2_GROW_OTABLE        0x00000001
-#define SVGA_CAP2_INTRA_SURFACE_COPY 0x00000002
-#define SVGA_CAP2_DX2                0x00000004
-#define SVGA_CAP2_RESERVED           0x80000000
+#define SVGA_CAP2_NONE                    0x00000000
+#define SVGA_CAP2_GROW_OTABLE             0x00000001
+#define SVGA_CAP2_INTRA_SURFACE_COPY      0x00000002
+#define SVGA_CAP2_DX2                     0x00000004
+#define SVGA_CAP2_GB_MEMSIZE_2            0x00000008
+#define SVGA_CAP2_SCREENDMA_REG           0x00000010
+#define SVGA_CAP2_OTABLE_PTDEPTH_2        0x00000020
+#define SVGA_CAP2_NON_MS_TO_MS_STRETCHBLT 0x00000040
+#define SVGA_CAP2_CURSOR_MOB              0x00000080
+#define SVGA_CAP2_MSHINT                  0x00000100
+#define SVGA_CAP2_DX3                     0x00000400
+#define SVGA_CAP2_RESERVED                0x80000000
 
 
 /*
@@ -875,7 +987,9 @@ typedef enum {
    SVGABackdoorCapFifoCaps = 1,
    SVGABackdoorCap3dHWVersion = 2,
    SVGABackdoorCapDeviceCaps2 = 3,
-   SVGABackdoorCapMax = 4,
+   SVGABackdoorCapDevelCaps = 4,
+   SVGABackdoorDevelRenderer = 5,
+   SVGABackdoorCapMax = 6,
 } SVGABackdoorCapType;
 
 
@@ -1055,103 +1169,80 @@ enum {
 /*
  * FIFO Synchronization Registers
  *
- *  This explains the relationship between the various FIFO
- *  sync-related registers in IOSpace and in FIFO space.
- *
  *  SVGA_REG_SYNC --
  *
- *       The SYNC register can be used in two different ways by the guest:
- *
- *         1. If the guest wishes to fully sync (drain) the FIFO,
- *            it will write once to SYNC then poll on the BUSY
- *            register. The FIFO is sync'ed once BUSY is zero.
- *
- *         2. If the guest wants to asynchronously wake up the host,
- *            it will write once to SYNC without polling on BUSY.
- *            Ideally it will do this after some new commands have
- *            been placed in the FIFO, and after reading a zero
- *            from SVGA_FIFO_BUSY.
- *
- *       (1) is the original behaviour that SYNC was designed to
- *       support.  Originally, a write to SYNC would implicitly
- *       trigger a read from BUSY. This causes us to synchronously
- *       process the FIFO.
- *
- *       This behaviour has since been changed so that writing SYNC
- *       will *not* implicitly cause a read from BUSY. Instead, it
- *       makes a channel call which asynchronously wakes up the MKS
- *       thread.
- *
- *       New guests can use this new behaviour to implement (2)
- *       efficiently. This lets guests get the host's attention
- *       without waiting for the MKS to poll, which gives us much
- *       better CPU utilization on SMP hosts and on UP hosts while
- *       we're blocked on the host GPU.
- *
- *       Old guests shouldn't notice the behaviour change. SYNC was
- *       never guaranteed to process the entire FIFO, since it was
- *       bounded to a particular number of CPU cycles. Old guests will
- *       still loop on the BUSY register until the FIFO is empty.
- *
- *       Writing to SYNC currently has the following side-effects:
- *
- *         - Sets SVGA_REG_BUSY to TRUE (in the monitor)
- *         - Asynchronously wakes up the MKS thread for FIFO processing
- *         - The value written to SYNC is recorded as a "reason", for
- *           stats purposes.
- *
- *       If SVGA_FIFO_BUSY is available, drivers are advised to only
- *       write to SYNC if SVGA_FIFO_BUSY is FALSE. Drivers should set
- *       SVGA_FIFO_BUSY to TRUE after writing to SYNC. The MKS will
- *       eventually set SVGA_FIFO_BUSY on its own, but this approach
- *       lets the driver avoid sending multiple asynchronous wakeup
- *       messages to the MKS thread.
+ *       The SYNC register can be used by the guest driver to signal to the
+ *       device that the guest driver is waiting for previously submitted
+ *       commands to complete.
+ *
+ *       When the guest driver writes to the SYNC register, the device sets
+ *       the BUSY register to TRUE, and starts processing the submitted commands
+ *       (if it was not already doing so).  When all previously submitted
+ *       commands are finished and the device is idle again, it sets the BUSY
+ *       register back to FALSE.  (If the guest driver submits new commands
+ *       after writing the SYNC register, the new commands are not guaranteed
+ *       to have been procesesd.)
+ *
+ *       When guest drivers are submitting commands using the FIFO, the device
+ *       periodically polls to check for new FIFO commands when idle, which may
+ *       introduce a delay in command processing.  If the guest-driver wants
+ *       the commands to be processed quickly (which it typically does), it
+ *       should write SYNC after each batch of commands is committed to the
+ *       FIFO to immediately wake up the device.  For even better performance,
+ *       the guest can use the SVGA_FIFO_BUSY register to avoid these extra
+ *       SYNC writes if the device is already active, using the technique known
+ *       as "Ringing the Doorbell" (described below).  (Note that command
+ *       buffer submission implicitly wakes up the device, and so doesn't
+ *       suffer from this problem.)
+ *
+ *       The SYNC register can also be used in combination with BUSY to
+ *       synchronously ensure that all SVGA commands are processed (with both
+ *       the FIFO and command-buffers).  To do this, the guest driver should
+ *       write to SYNC, and then loop reading BUSY until BUSY returns FALSE.
+ *       This technique is known as a "Legacy Sync".
  *
  *  SVGA_REG_BUSY --
  *
  *       This register is set to TRUE when SVGA_REG_SYNC is written,
- *       and it reads as FALSE when the FIFO has been completely
- *       drained.
- *
- *       Every read from this register causes us to synchronously
- *       process FIFO commands. There is no guarantee as to how many
- *       commands each read will process.
+ *       and is set back to FALSE when the device has finished processing
+ *       all commands and is idle again.
  *
- *       CPU time spent processing FIFO commands will be billed to
- *       the guest.
+ *       Every read from the BUSY reigster will block for an undefined
+ *       amount of time (normally until the device finishes some interesting
+ *       work unit), or the device is idle.
  *
- *       New drivers should avoid using this register unless they
- *       need to guarantee that the FIFO is completely drained. It
- *       is overkill for performing a sync-to-fence. Older drivers
- *       will use this register for any type of synchronization.
+ *       Guest drivers can also do a partial Legacy Sync to check for some
+ *       particular condition, for instance by stopping early when a fence
+ *       passes before BUSY has been set back to FALSE.  This is particularly
+ *       useful if the guest-driver knows that it is blocked waiting on the
+ *       device, because it will yield CPU time back to the host.
  *
  *  SVGA_FIFO_BUSY --
  *
- *       This register is a fast way for the guest driver to check
- *       whether the FIFO is already being processed. It reads and
- *       writes at normal RAM speeds, with no monitor intervention.
- *
- *       If this register reads as TRUE, the host is guaranteeing that
- *       any new commands written into the FIFO will be noticed before
- *       the MKS goes back to sleep.
+ *       The SVGA_FIFO_BUSY register is a fast way for the guest driver to check
+ *       whether the device is actively processing FIFO commands before writing
+ *       the more expensive SYNC register.
  *
- *       If this register reads as FALSE, no such guarantee can be
- *       made.
+ *       If this register reads as TRUE, the device is actively processing
+ *       FIFO commands.
  *
- *       The guest should use this register to quickly determine
- *       whether or not it needs to wake up the host. If the guest
- *       just wrote a command or group of commands that it would like
- *       the host to begin processing, it should:
+ *       If this register reads as FALSE, the device may not be actively
+ *       processing commands, and the guest driver should try
+ *       "Ringing the Doorbell".
  *
- *         1. Read SVGA_FIFO_BUSY. If it reads as TRUE, no further
- *            action is necessary.
+ *       To Ring the Doorbell, the guest should:
  *
- *         2. Write TRUE to SVGA_FIFO_BUSY. This informs future guest
- *            code that we've already sent a SYNC to the host and we
- *            don't need to send a duplicate.
+ *       1. Have already written their batch of commands into the FIFO.
+ *       2. Check if the SVGA_FIFO_BUSY register is available by reading
+ *          SVGA_FIFO_MIN.
+ *       3. Read SVGA_FIFO_BUSY.  If it reads as TRUE, the device is actively
+ *          processing FIFO commands, and no further action is necessary.
+ *       4. If SVGA_FIFO_BUSY was FALSE, write TRUE to SVGA_REG_SYNC.
  *
- *         3. Write a reason to SVGA_REG_SYNC. This will send an
- *            asynchronous wakeup to the MKS thread.
+ *       For maximum performance, this procedure should be followed after
+ *       every meaningful batch of commands has been written into the FIFO.
+ *       (Normally when the underlying application signals it's finished a
+ *       meaningful work unit by calling Flush.)
  */
 
 
@@ -1164,9 +1255,6 @@ enum {
  *      Video -- SVGA Video overlay units are supported
  *      Escape -- Escape command is supported
  *
- * XXX: Add longer descriptions for each capability, including a list
- *      of the new features that each capability provides.
- *
  * SVGA_FIFO_CAP_SCREEN_OBJECT --
  *
  *    Provides dynamic multi-screen rendering, for improved Unity and
@@ -1278,6 +1366,15 @@ enum {
 #define SVGA_FIFO_RESERVED_UNKNOWN      0xffffffff
 
 
+/*
+ * ScreenDMA Register Values
+ */
+
+#define SVGA_SCREENDMA_REG_UNDEFINED    0
+#define SVGA_SCREENDMA_REG_NOT_PRESENT  1
+#define SVGA_SCREENDMA_REG_PRESENT      2
+#define SVGA_SCREENDMA_REG_MAX          3
+
 /*
  * Video overlay support
  */
@@ -1664,6 +1761,80 @@ struct {
 SVGAFifoCmdDefineAlphaCursor;
 
 
+/*
+ *    Provide a new large cursor image, as an AND/XOR mask.
+ *
+ *    Should only be used for CursorMob functionality
+ */
+
+typedef
+#include "vmware_pack_begin.h"
+struct {
+   uint32 hotspotX;
+   uint32 hotspotY;
+   uint32 width;
+   uint32 height;
+   uint32 andMaskDepth;
+   uint32 xorMaskDepth;
+   /*
+    * Followed by scanline data for AND mask, then XOR mask.
+    * Each scanline is padded to a 32-bit boundary.
+   */
+}
+#include "vmware_pack_end.h"
+SVGAGBColorCursorHeader;
+
+
+/*
+ *    Provide a new large cursor image, in 32-bit BGRA format.
+ *
+ *    Should only be used for CursorMob functionality
+ */
+
+typedef
+#include "vmware_pack_begin.h"
+struct {
+   uint32 hotspotX;
+   uint32 hotspotY;
+   uint32 width;
+   uint32 height;
+   /* Followed by scanline data */
+}
+#include "vmware_pack_end.h"
+SVGAGBAlphaCursorHeader;
+
+ /*
+  * Define the SVGA guest backed cursor types
+  */
+
+typedef enum {
+   SVGA_COLOR_CURSOR       = 0,
+   SVGA_ALPHA_CURSOR       = 1,
+} SVGAGBCursorType;
+
+/*
+ *    Provide a new large cursor image.
+ *
+ *    Should only be used for CursorMob functionality
+ */
+
+typedef
+#include "vmware_pack_begin.h"
+struct {
+   SVGAGBCursorType type;
+   union {
+      SVGAGBColorCursorHeader colorHeader;
+      SVGAGBAlphaCursorHeader alphaHeader;
+   } header;
+   uint32 sizeInBytes;
+   /*
+    * Followed by the cursor data
+    */
+}
+#include "vmware_pack_end.h"
+SVGAGBCursorHeader;
+
+
 /*
  * SVGA_CMD_UPDATE_VERBOSE --
  *
@@ -2061,9 +2232,12 @@ SVGAFifoCmdRemapGMR2;
 #define SVGA_VRAM_MAX_SIZE         (128 * 1024 * 1024)
 #define SVGA_MEMORY_SIZE_MAX      (1024 * 1024 * 1024)
 #define SVGA_FIFO_SIZE_MAX           (2 * 1024 * 1024)
-#define SVGA_GRAPHICS_MEMORY_KB_MIN       (32 * 1024)
-#define SVGA_GRAPHICS_MEMORY_KB_MAX       (2 * 1024 * 1024)
-#define SVGA_GRAPHICS_MEMORY_KB_DEFAULT   (256 * 1024)
+#define SVGA_GRAPHICS_MEMORY_KB_MIN     (32 * 1024)
+#define SVGA_GRAPHICS_MEMORY_KB_MAX_2GB (2 * 1024 * 1024)
+#define SVGA_GRAPHICS_MEMORY_KB_MAX_3GB (3 * 1024 * 1024)
+#define SVGA_GRAPHICS_MEMORY_KB_MAX_4GB (4 * 1024 * 1024)
+#define SVGA_GRAPHICS_MEMORY_KB_MAX_8GB (8 * 1024 * 1024)
+#define SVGA_GRAPHICS_MEMORY_KB_DEFAULT (256 * 1024)
 
 #define SVGA_VRAM_SIZE_W2K          (64 * 1024 * 1024) /* 64 MB */
 
@@ -2086,4 +2260,6 @@ SVGAFifoCmdRemapGMR2;
 #define SVGA_FIFO_SIZE_GBOBJECTS          (256 * 1024)
 #define SVGA_VRAM_SIZE_GBOBJECTS     (4 * 1024 * 1024)
 
+#define SVGA_PCI_REGS_PAGES                        (1)
+
 #endif
diff --git a/drivers/gpu/drm/vmwgfx/device_include/svga_types.h b/drivers/gpu/drm/vmwgfx/device_include/svga_types.h
index 350bbc6fab02..beddccee40f6 100644
--- a/drivers/gpu/drm/vmwgfx/device_include/svga_types.h
+++ b/drivers/gpu/drm/vmwgfx/device_include/svga_types.h
@@ -37,6 +37,7 @@ typedef s8  int8;
 
 typedef uint64 PA;
 typedef uint32 PPN;
+typedef uint32 PPN32;
 typedef uint64 PPN64;
 
 typedef bool Bool;
-- 
2.28.0

