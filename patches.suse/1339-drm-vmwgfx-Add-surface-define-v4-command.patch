From 0559987c064d309688e32bc403c14518abc5c36e Mon Sep 17 00:00:00 2001
From: Deepak Rawat <drawat.floss@gmail.com>
Date: Tue, 30 Apr 2019 13:04:55 -0700
Subject: drm/vmwgfx: Add surface define v4 command
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 2a50f06d639bc6d21e855296c2fa511b080f9a79
Patch-mainline: v5.7-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

Surface define v4 added new member buffer_byte_stride. With this patch
add buffer_byte_stride in surface metadata and create surface using new
command if support is available.

Also with this patch replace device specific data types with kernel
types.

Signed-off-by: Deepak Rawat <drawat.floss@gmail.com>
Reviewed-by: Thomas Hellstr√∂m (VMware) <thomas_os@shipmail.org>
Reviewed-by: Roland Scheidegger <sroland@vmware.com>
Signed-off-by: Roland Scheidegger <sroland@vmware.com>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/vmwgfx/vmwgfx_drv.h     |  2 ++
 drivers/gpu/drm/vmwgfx/vmwgfx_surface.c | 36 +++++++++++++++++++++++--
 include/uapi/drm/vmwgfx_drm.h           | 12 +++++----
 3 files changed, 43 insertions(+), 7 deletions(-)

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h
index 326d1dd58bc5..0447be87697e 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h
@@ -238,6 +238,7 @@ struct vmw_surface_offset;
  * @array_size: Number of array elements for a 1D/2D texture. For cubemap
                 texture number of faces * array_size. This should be 0 for pre
 		SM4 device.
+ * @buffer_byte_stride: Buffer byte stride.
  * @num_sizes: Size of @sizes. For GB surface this should always be 1.
  * @base_size: Surface dimension.
  * @sizes: Array representing mip sizes. Legacy only.
@@ -255,6 +256,7 @@ struct vmw_surface_metadata {
 	u32 autogen_filter;
 	u32 array_size;
 	u32 num_sizes;
+	u32 buffer_byte_stride;
 	struct drm_vmw_size base_size;
 	struct drm_vmw_size *sizes;
 	bool scanout;
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c b/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c
index 6c907b147e97..7ef51fa84b01 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c
@@ -1082,6 +1082,10 @@ static int vmw_gb_surface_create(struct vmw_resource *res)
 		SVGA3dCmdHeader header;
 		SVGA3dCmdDefineGBSurface_v3 body;
 	} *cmd3;
+	struct {
+		SVGA3dCmdHeader header;
+		SVGA3dCmdDefineGBSurface_v4 body;
+	} *cmd4;
 
 	if (likely(res->id != -1))
 		return 0;
@@ -1098,7 +1102,11 @@ static int vmw_gb_surface_create(struct vmw_resource *res)
 		goto out_no_fifo;
 	}
 
-	if (has_sm4_1_context(dev_priv) && metadata->array_size > 0) {
+	if (has_sm5_context(dev_priv) && metadata->array_size > 0) {
+		cmd_id = SVGA_3D_CMD_DEFINE_GB_SURFACE_V4;
+		cmd_len = sizeof(cmd4->body);
+		submit_len = sizeof(*cmd4);
+	} else if (has_sm4_1_context(dev_priv) && metadata->array_size > 0) {
 		cmd_id = SVGA_3D_CMD_DEFINE_GB_SURFACE_V3;
 		cmd_len = sizeof(cmd3->body);
 		submit_len = sizeof(*cmd3);
@@ -1116,12 +1124,29 @@ static int vmw_gb_surface_create(struct vmw_resource *res)
 	cmd = VMW_FIFO_RESERVE(dev_priv, submit_len);
 	cmd2 = (typeof(cmd2))cmd;
 	cmd3 = (typeof(cmd3))cmd;
+	cmd4 = (typeof(cmd4))cmd;
 	if (unlikely(!cmd)) {
 		ret = -ENOMEM;
 		goto out_no_fifo;
 	}
 
-	if (has_sm4_1_context(dev_priv) && metadata->array_size > 0) {
+	if (has_sm5_context(dev_priv) && metadata->array_size > 0) {
+		cmd4->header.id = cmd_id;
+		cmd4->header.size = cmd_len;
+		cmd4->body.sid = srf->res.id;
+		cmd4->body.surfaceFlags = metadata->flags;
+		cmd4->body.format = metadata->format;
+		cmd4->body.numMipLevels = metadata->mip_levels[0];
+		cmd4->body.multisampleCount = metadata->multisample_count;
+		cmd4->body.multisamplePattern = metadata->multisample_pattern;
+		cmd4->body.qualityLevel = metadata->quality_level;
+		cmd4->body.autogenFilter = metadata->autogen_filter;
+		cmd4->body.size.width = metadata->base_size.width;
+		cmd4->body.size.height = metadata->base_size.height;
+		cmd4->body.size.depth = metadata->base_size.depth;
+		cmd4->body.arraySize = metadata->array_size;
+		cmd4->body.bufferByteStride = metadata->buffer_byte_stride;
+	} else if (has_sm4_1_context(dev_priv) && metadata->array_size > 0) {
 		cmd3->header.id = cmd_id;
 		cmd3->header.size = cmd_len;
 		cmd3->body.sid = srf->res.id;
@@ -1341,6 +1366,7 @@ int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,
 	req_ext.svga3d_flags_upper_32_bits = 0;
 	req_ext.multisample_pattern = SVGA3D_MS_PATTERN_NONE;
 	req_ext.quality_level = SVGA3D_MS_QUALITY_NONE;
+	req_ext.buffer_byte_stride = 0;
 	req_ext.must_be_zero = 0;
 
 	return vmw_gb_surface_define_internal(dev, &req_ext, rep, file_priv);
@@ -1467,6 +1493,11 @@ vmw_gb_surface_define_internal(struct drm_device *dev,
 		}
 	}
 
+	if (req->buffer_byte_stride > 0 && !has_sm5_context(dev_priv)) {
+		VMW_DEBUG_USER("SM5 surface not supported.\n");
+		return -EINVAL;
+	}
+
 	if ((svga3d_flags_64 & SVGA3D_SURFACE_MULTISAMPLE) &&
 	    req->base.multisample_count == 0) {
 		VMW_DEBUG_USER("Invalid sample count.\n");
@@ -1491,6 +1522,7 @@ vmw_gb_surface_define_internal(struct drm_device *dev,
 	metadata.multisample_pattern = req->multisample_pattern;
 	metadata.quality_level = req->quality_level;
 	metadata.array_size = req->base.array_size;
+	metadata.buffer_byte_stride = req->buffer_byte_stride;
 	metadata.num_sizes = 1;
 	metadata.base_size = req->base.base_size;
 	metadata.scanout = req->base.drm_surface_flags &
diff --git a/include/uapi/drm/vmwgfx_drm.h b/include/uapi/drm/vmwgfx_drm.h
index fcb741e3068f..8cd4b321597c 100644
--- a/include/uapi/drm/vmwgfx_drm.h
+++ b/include/uapi/drm/vmwgfx_drm.h
@@ -1133,7 +1133,7 @@ struct drm_vmw_handle_close_arg {
  * svga3d surface flags split into 2, upper half and lower half.
  */
 enum drm_vmw_surface_version {
-	drm_vmw_gb_surface_v1
+	drm_vmw_gb_surface_v1,
 };
 
 /**
@@ -1144,6 +1144,7 @@ enum drm_vmw_surface_version {
  * @svga3d_flags_upper_32_bits: Upper 32 bits of svga3d flags.
  * @multisample_pattern: Multisampling pattern when msaa is supported.
  * @quality_level: Precision settings for each sample.
+ * @buffer_byte_stride: Buffer byte stride.
  * @must_be_zero: Reserved for future usage.
  *
  * Input argument to the  DRM_VMW_GB_SURFACE_CREATE_EXT Ioctl.
@@ -1152,10 +1153,11 @@ enum drm_vmw_surface_version {
 struct drm_vmw_gb_surface_create_ext_req {
 	struct drm_vmw_gb_surface_create_req base;
 	enum drm_vmw_surface_version version;
-	uint32_t svga3d_flags_upper_32_bits;
-	SVGA3dMSPattern multisample_pattern;
-	SVGA3dMSQualityLevel quality_level;
-	uint64_t must_be_zero;
+	__u32 svga3d_flags_upper_32_bits;
+	__u32 multisample_pattern;
+	__u32 quality_level;
+	__u32 buffer_byte_stride;
+	__u32 must_be_zero;
 };
 
 /**
-- 
2.28.0

