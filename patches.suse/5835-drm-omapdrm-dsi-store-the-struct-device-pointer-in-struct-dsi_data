From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Tue, 13 Feb 2018 14:00:36 +0200
Subject: drm: omapdrm: dsi: Store the struct device pointer in struct dsi_data
Git-commit: 4600ea9c49cc494fd7fb65d4f659e9f7b27b56e8
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

The dsi_data structure stores a pointer to a struct platform_device. The
driver only uses the dev member of the platform device structure. Store
the struct device pointer instead and use it directly.

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/omapdrm/dss/dsi.c |   26 +++++++++++++-------------
 1 file changed, 13 insertions(+), 13 deletions(-)

--- a/drivers/gpu/drm/omapdrm/dss/dsi.c
+++ b/drivers/gpu/drm/omapdrm/dss/dsi.c
@@ -330,7 +330,7 @@ struct dsi_of_data {
 };
 
 struct dsi_data {
-	struct platform_device *pdev;
+	struct device *dev;
 	void __iomem *proto_base;
 	void __iomem *phy_base;
 	void __iomem *pll_base;
@@ -1144,7 +1144,7 @@ static int dsi_runtime_get(struct dsi_da
 
 	DSSDBG("dsi_runtime_get\n");
 
-	r = pm_runtime_get_sync(&dsi->pdev->dev);
+	r = pm_runtime_get_sync(dsi->dev);
 	WARN_ON(r < 0);
 	return r < 0 ? r : 0;
 }
@@ -1155,7 +1155,7 @@ static void dsi_runtime_put(struct dsi_d
 
 	DSSDBG("dsi_runtime_put\n");
 
-	r = pm_runtime_put_sync(&dsi->pdev->dev);
+	r = pm_runtime_put_sync(dsi->dev);
 	WARN_ON(r < 0 && r != -ENOSYS);
 }
 
@@ -1166,7 +1166,7 @@ static int dsi_regulator_init(struct dsi
 	if (dsi->vdds_dsi_reg != NULL)
 		return 0;
 
-	vdds_dsi = devm_regulator_get(&dsi->pdev->dev, "vdd");
+	vdds_dsi = devm_regulator_get(dsi->dev, "vdd");
 
 	if (IS_ERR(vdds_dsi)) {
 		if (PTR_ERR(vdds_dsi) != -EPROBE_DEFER)
@@ -4951,7 +4951,7 @@ static int dsi_get_clocks(struct dsi_dat
 {
 	struct clk *clk;
 
-	clk = devm_clk_get(&dsi->pdev->dev, "fck");
+	clk = devm_clk_get(dsi->dev, "fck");
 	if (IS_ERR(clk)) {
 		DSSERR("can't get fck\n");
 		return PTR_ERR(clk);
@@ -5046,7 +5046,7 @@ static void dsi_init_output(struct dsi_d
 {
 	struct omap_dss_device *out = &dsi->output;
 
-	out->dev = &dsi->pdev->dev;
+	out->dev = dsi->dev;
 	out->id = dsi->module_id == 0 ?
 			OMAP_DSS_OUTPUT_DSI1 : OMAP_DSS_OUTPUT_DSI2;
 
@@ -5068,7 +5068,7 @@ static void dsi_uninit_output(struct dsi
 
 static int dsi_probe_of(struct dsi_data *dsi)
 {
-	struct device_node *node = dsi->pdev->dev.of_node;
+	struct device_node *node = dsi->dev->of_node;
 	struct property *prop;
 	u32 lane_arr[10];
 	int len, num_pins;
@@ -5082,7 +5082,7 @@ static int dsi_probe_of(struct dsi_data
 
 	prop = of_find_property(ep, "lanes", &len);
 	if (prop == NULL) {
-		dev_err(&dsi->pdev->dev, "failed to find lane data\n");
+		dev_err(dsi->dev, "failed to find lane data\n");
 		r = -EINVAL;
 		goto err;
 	}
@@ -5091,14 +5091,14 @@ static int dsi_probe_of(struct dsi_data
 
 	if (num_pins < 4 || num_pins % 2 != 0 ||
 		num_pins > dsi->num_lanes_supported * 2) {
-		dev_err(&dsi->pdev->dev, "bad number of lanes\n");
+		dev_err(dsi->dev, "bad number of lanes\n");
 		r = -EINVAL;
 		goto err;
 	}
 
 	r = of_property_read_u32_array(ep, "lanes", lane_arr, num_pins);
 	if (r) {
-		dev_err(&dsi->pdev->dev, "failed to read lane data\n");
+		dev_err(dsi->dev, "failed to read lane data\n");
 		goto err;
 	}
 
@@ -5108,7 +5108,7 @@ static int dsi_probe_of(struct dsi_data
 
 	r = dsi_configure_pins(&dsi->output, &pin_cfg);
 	if (r) {
-		dev_err(&dsi->pdev->dev, "failed to configure pins");
+		dev_err(dsi->dev, "failed to configure pins");
 		goto err;
 	}
 
@@ -5214,7 +5214,7 @@ static int dsi_init_pll_data(struct dss_
 	struct clk *clk;
 	int r;
 
-	clk = devm_clk_get(&dsi->pdev->dev, "sys_clk");
+	clk = devm_clk_get(dsi->dev, "sys_clk");
 	if (IS_ERR(clk)) {
 		DSSERR("can't get sys_clk\n");
 		return PTR_ERR(clk);
@@ -5317,7 +5317,7 @@ static int dsi_bind(struct device *dev,
 		return -ENOMEM;
 
 	dsi->dss = dss;
-	dsi->pdev = pdev;
+	dsi->dev = dev;
 	dev_set_drvdata(dev, dsi);
 
 	spin_lock_init(&dsi->irq_lock);
