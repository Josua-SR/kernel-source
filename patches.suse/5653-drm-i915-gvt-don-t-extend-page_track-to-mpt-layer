From: Changbin Du <changbin.du@intel.com>
Date: Tue, 30 Jan 2018 19:19:52 +0800
Subject: drm/i915/gvt: Don't extend page_track to mpt layer
Git-commit: 0947572849cb3ca7028d9daa3958158639ae4d69
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Don't extend page_track to mpt layer. Keep MPT simple and clean.
Meanwhile remove gtt.n_tracked_guest_page which doesn't make much
sense.

v2: clean up gtt.n_tracked_guest_page.

Signed-off-by: Changbin Du <changbin.du@intel.com>
Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/i915/gvt/gtt.c |   50 ++++++++++++++++++++++-------------------
 drivers/gpu/drm/i915/gvt/mpt.h |   34 ++++-----------------------
 2 files changed, 34 insertions(+), 50 deletions(-)

--- a/drivers/gpu/drm/i915/gvt/gtt.c
+++ b/drivers/gpu/drm/i915/gvt/gtt.c
@@ -678,7 +678,7 @@ static void ppgtt_free_spt(struct intel_
 
 	if (spt->guest_page.track.tracked)
 		intel_gvt_hypervisor_disable_page_track(spt->vgpu,
-				&spt->guest_page.track);
+				spt->guest_page.track.gfn);
 
 	list_del_init(&spt->post_shadow_list);
 	free_spt(spt);
@@ -926,10 +926,11 @@ static struct intel_vgpu_ppgtt_spt *ppgt
 			goto fail;
 		}
 
-		ret = intel_gvt_hypervisor_enable_page_track(vgpu, &spt->guest_page.track);
+		ret = intel_gvt_hypervisor_enable_page_track(vgpu, spt->guest_page.track.gfn);
 		if (ret)
 			goto fail;
 
+		spt->guest_page.track.tracked = true;
 		ret = ppgtt_populate_spt(spt);
 		if (ret)
 			goto fail;
@@ -1196,9 +1197,10 @@ static int ppgtt_set_guest_page_sync(str
 	struct intel_vgpu_oos_page *oos_page = spt->guest_page.oos_page;
 	int ret;
 
-	ret = intel_gvt_hypervisor_enable_page_track(spt->vgpu, &spt->guest_page.track);
+	ret = intel_gvt_hypervisor_enable_page_track(spt->vgpu, spt->guest_page.track.gfn);
 	if (ret)
 		return ret;
+	spt->guest_page.track.tracked = true;
 
 	trace_oos_change(spt->vgpu->id, "set page sync", oos_page->id,
 			 spt, spt->guest_page.type);
@@ -1234,6 +1236,7 @@ static int ppgtt_allocate_oos_page(struc
 static int ppgtt_set_guest_page_oos(struct intel_vgpu_ppgtt_spt *spt)
 {
 	struct intel_vgpu_oos_page *oos_page = spt->guest_page.oos_page;
+	int ret;
 
 	if (WARN(!oos_page, "shadow PPGTT page should have a oos page\n"))
 		return -EINVAL;
@@ -1242,7 +1245,11 @@ static int ppgtt_set_guest_page_oos(stru
 			 spt, spt->guest_page.type);
 
 	list_add_tail(&oos_page->vm_list, &spt->vgpu->gtt.oos_page_list_head);
-	return intel_gvt_hypervisor_disable_page_track(spt->vgpu, &spt->guest_page.track);
+	ret = intel_gvt_hypervisor_disable_page_track(spt->vgpu, spt->guest_page.track.gfn);
+	if (ret)
+		return ret;
+	spt->guest_page.track.tracked = false;
+	return 0;
 }
 
 /**
@@ -1917,29 +1924,28 @@ int intel_vgpu_write_protect_handler(str
 	struct intel_gvt *gvt = vgpu->gvt;
 	int ret = 0;
 
-	if (atomic_read(&vgpu->gtt.n_tracked_guest_page)) {
-		struct intel_vgpu_page_track *t;
+	struct intel_vgpu_page_track *t;
 
-		mutex_lock(&gvt->lock);
+	mutex_lock(&gvt->lock);
 
-		t = intel_vgpu_find_tracked_page(vgpu, pa >> PAGE_SHIFT);
-		if (t) {
-			if (unlikely(vgpu->failsafe)) {
-				/* remove write protection to prevent furture traps */
-				intel_gvt_hypervisor_disable_page_track(vgpu, t);
-			} else {
-				ret = t->handler(t, pa, p_data, bytes);
-				if (ret) {
-					gvt_err("guest page write error %d, "
-						"gfn 0x%lx, pa 0x%llx, "
-						"var 0x%x, len %d\n",
-						ret, t->gfn, pa,
-						*(u32 *)p_data, bytes);
-				}
+	t = intel_vgpu_find_tracked_page(vgpu, pa >> PAGE_SHIFT);
+	if (t) {
+		if (unlikely(vgpu->failsafe)) {
+			/* remove write protection to prevent furture traps */
+			intel_gvt_hypervisor_disable_page_track(vgpu, t->gfn);
+		} else {
+			ret = t->handler(t, pa, p_data, bytes);
+			if (ret) {
+				gvt_err("guest page write error %d, "
+					"gfn 0x%lx, pa 0x%llx, "
+					"var 0x%x, len %d\n",
+					ret, t->gfn, pa,
+					*(u32 *)p_data, bytes);
 			}
 		}
-		mutex_unlock(&gvt->lock);
 	}
+	mutex_unlock(&gvt->lock);
+
 	return ret;
 }
 
--- a/drivers/gpu/drm/i915/gvt/mpt.h
+++ b/drivers/gpu/drm/i915/gvt/mpt.h
@@ -156,51 +156,29 @@ static inline unsigned long intel_gvt_hy
 /**
  * intel_gvt_hypervisor_enable_page_track - track a guest page
  * @vgpu: a vGPU
- * @t: page track data structure
+ * @gfn: the gfn of guest
  *
  * Returns:
  * Zero on success, negative error code if failed.
  */
 static inline int intel_gvt_hypervisor_enable_page_track(
-		struct intel_vgpu *vgpu,
-		struct intel_vgpu_page_track *t)
+		struct intel_vgpu *vgpu, unsigned long gfn)
 {
-	int ret;
-
-	if (t->tracked)
-		return 0;
-
-	ret = intel_gvt_host.mpt->enable_page_track(vgpu->handle, t->gfn);
-	if (ret)
-		return ret;
-	t->tracked = true;
-	atomic_inc(&vgpu->gtt.n_tracked_guest_page);
-	return 0;
+	return intel_gvt_host.mpt->enable_page_track(vgpu->handle, gfn);
 }
 
 /**
  * intel_gvt_hypervisor_disable_page_track - untrack a guest page
  * @vgpu: a vGPU
- * @t: page track data structure
+ * @gfn: the gfn of guest
  *
  * Returns:
  * Zero on success, negative error code if failed.
  */
 static inline int intel_gvt_hypervisor_disable_page_track(
-		struct intel_vgpu *vgpu,
-		struct intel_vgpu_page_track *t)
+		struct intel_vgpu *vgpu, unsigned long gfn)
 {
-	int ret;
-
-	if (!t->tracked)
-		return 0;
-
-	ret = intel_gvt_host.mpt->disable_page_track(vgpu->handle, t->gfn);
-	if (ret)
-		return ret;
-	t->tracked = false;
-	atomic_dec(&vgpu->gtt.n_tracked_guest_page);
-	return 0;
+	return intel_gvt_host.mpt->disable_page_track(vgpu->handle, gfn);
 }
 
 /**
