From: Ramalingam C <ramalingam.c@intel.com>
Date: Sat, 3 Feb 2018 03:39:08 +0530
Subject: drm/i915: Detect panel's hdcp capability
Git-commit: 791a98dd9bcfd214d8ef51d248f377354a9ea683
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

DP HDCP1.4 spec mandates that An can be written to panel only after
detecting the panel's hdcp capability.

For DP 0th Bit of Bcaps register indicates the panel's hdcp capability
For HDMI valid BKSV indicates the panel's hdcp capability.

For HDMI it is optional to detect the panel's hdcp capability before
An Write.

v2:
  Added comments explaining the need for action [Seanpaul].
  Made panel's hdcp capability detection optional for hdmi [Seanpaul].
  Defined a func for reading bcaps for DP [Seanpaul].

v3:
  Removed the NULL initialization [Seanpaul].

Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
Reviewed-by: Sean Paul <seanpaul@chromium.org>
Signed-off-by: Sean Paul <seanpaul@chromium.org>
Link: https://patchwork.freedesktop.org/patch/msgid/1517609350-10698-7-git-send-email-ramalingam.c@intel.com

Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/i915/intel_dp.c   |   39 ++++++++++++++++++++++++++++++++++----
 drivers/gpu/drm/i915/intel_drv.h  |    4 +++
 drivers/gpu/drm/i915/intel_hdcp.c |   18 ++++++++++++++++-
 3 files changed, 56 insertions(+), 5 deletions(-)

--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@ -5120,17 +5120,32 @@ static int intel_dp_hdcp_read_bstatus(st
 }
 
 static
-int intel_dp_hdcp_repeater_present(struct intel_digital_port *intel_dig_port,
-				   bool *repeater_present)
+int intel_dp_hdcp_read_bcaps(struct intel_digital_port *intel_dig_port,
+			     u8 *bcaps)
 {
 	ssize_t ret;
-	u8 bcaps;
+
 	ret = drm_dp_dpcd_read(&intel_dig_port->dp.aux, DP_AUX_HDCP_BCAPS,
-			       &bcaps, 1);
+			       bcaps, 1);
 	if (ret != 1) {
 		DRM_ERROR("Read bcaps from DP/AUX failed (%zd)\n", ret);
 		return ret >= 0 ? -EIO : ret;
 	}
+
+	return 0;
+}
+
+static
+int intel_dp_hdcp_repeater_present(struct intel_digital_port *intel_dig_port,
+				   bool *repeater_present)
+{
+	ssize_t ret;
+	u8 bcaps;
+
+	ret = intel_dp_hdcp_read_bcaps(intel_dig_port, &bcaps);
+	if (ret)
+		return ret;
+
 	*repeater_present = bcaps & DP_BCAPS_REPEATER_PRESENT;
 	return 0;
 }
@@ -5231,6 +5246,21 @@ bool intel_dp_hdcp_check_link(struct int
 	return !(bstatus & (DP_BSTATUS_LINK_FAILURE | DP_BSTATUS_REAUTH_REQ));
 }
 
+static
+int intel_dp_hdcp_capable(struct intel_digital_port *intel_dig_port,
+			  bool *hdcp_capable)
+{
+	ssize_t ret;
+	u8 bcaps;
+
+	ret = intel_dp_hdcp_read_bcaps(intel_dig_port, &bcaps);
+	if (ret)
+		return ret;
+
+	*hdcp_capable = bcaps & DP_BCAPS_HDCP_CAPABLE;
+	return 0;
+}
+
 static const struct intel_hdcp_shim intel_dp_hdcp_shim = {
 	.write_an_aksv = intel_dp_hdcp_write_an_aksv,
 	.read_bksv = intel_dp_hdcp_read_bksv,
@@ -5242,6 +5272,7 @@ static const struct intel_hdcp_shim inte
 	.read_v_prime_part = intel_dp_hdcp_read_v_prime_part,
 	.toggle_signalling = intel_dp_hdcp_toggle_signalling,
 	.check_link = intel_dp_hdcp_check_link,
+	.hdcp_capable = intel_dp_hdcp_capable,
 };
 
 static void intel_edp_panel_vdd_sanitize(struct intel_dp *intel_dp)
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@ -369,6 +369,10 @@ struct intel_hdcp_shim {
 
 	/* Ensures the link is still protected */
 	bool (*check_link)(struct intel_digital_port *intel_dig_port);
+
+	/* Detects panel's hdcp capability. This is optional for HDMI. */
+	int (*hdcp_capable)(struct intel_digital_port *intel_dig_port,
+			    bool *hdcp_capable);
 };
 
 struct intel_connector {
--- a/drivers/gpu/drm/i915/intel_hdcp.c
+++ b/drivers/gpu/drm/i915/intel_hdcp.c
@@ -414,12 +414,28 @@ static int intel_hdcp_auth(struct intel_
 		u32 reg;
 		u8 shim[DRM_HDCP_RI_LEN];
 	} ri;
-	bool repeater_present;
+	bool repeater_present, hdcp_capable;
 
 	dev_priv = intel_dig_port->base.base.dev->dev_private;
 
 	port = intel_dig_port->base.port;
 
+	/*
+	 * Detects whether the display is HDCP capable. Although we check for
+	 * valid Bksv below, the HDCP over DP spec requires that we check
+	 * whether the display supports HDCP before we write An. For HDMI
+	 * displays, this is not necessary.
+	 */
+	if (shim->hdcp_capable) {
+		ret = shim->hdcp_capable(intel_dig_port, &hdcp_capable);
+		if (ret)
+			return ret;
+		if (!hdcp_capable) {
+			DRM_ERROR("Panel is not HDCP capable\n");
+			return -EINVAL;
+		}
+	}
+
 	/* Initialize An with 2 random values and acquire it */
 	for (i = 0; i < 2; i++)
 		I915_WRITE(PORT_HDCP_ANINIT(port), get_random_u32());
