From: Raghava Aditya Renukunta <RaghavaAditya.Renukunta@microsemi.com>
Date: Tue, 26 Dec 2017 20:34:38 -0800
Subject: scsi: aacraid: Add helper function to set queue depth
Patch-mainline: v4.16-rc1
Git-commit: 0bcb45fb20c2195fe0ae175d4775241e672a5fd3
References: FATE#325927

Add helper function to set queue depth from information retrieved from
the bmic phy structure.

Signed-off-by: Raghava Aditya Renukunta <RaghavaAditya.Renukunta@microsemi.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 drivers/scsi/aacraid/aachba.c |   37 ++++++++++++++++++++++++-------------
 1 file changed, 24 insertions(+), 13 deletions(-)

--- a/drivers/scsi/aacraid/aachba.c
+++ b/drivers/scsi/aacraid/aachba.c
@@ -1755,6 +1755,28 @@ fib_error:
 	return rcode;
 }
 
+static void aac_set_safw_target_qd(struct aac_dev *dev, int bus, int target)
+{
+
+	struct aac_ciss_identify_pd *identify_resp;
+
+	if (dev->hba_map[bus][target].devtype != AAC_DEVTYPE_NATIVE_RAW)
+		return;
+
+	identify_resp = dev->hba_map[bus][target].safw_identify_resp;
+	if (identify_resp == NULL) {
+		dev->hba_map[bus][target].qd_limit = 32;
+		return;
+	}
+
+	if (identify_resp->current_queue_depth_limit <= 0 ||
+		identify_resp->current_queue_depth_limit > 255)
+		dev->hba_map[bus][target].qd_limit = 32;
+	else
+		dev->hba_map[bus][target].qd_limit =
+			identify_resp->current_queue_depth_limit;
+}
+
 static int aac_issue_safw_bmic_identify(struct aac_dev *dev,
 	struct aac_ciss_identify_pd **identify_resp, u32 bus, u32 target)
 {
@@ -1781,13 +1803,6 @@ static int aac_issue_safw_bmic_identify(
 	if (unlikely(rcode < 0))
 		goto mem_free_all;
 
-	if (identify_reply->current_queue_depth_limit <= 0 ||
-		identify_reply->current_queue_depth_limit > 32)
-		dev->hba_map[bus][target].qd_limit = 32;
-	else
-		dev->hba_map[bus][target].qd_limit =
-			identify_reply->current_queue_depth_limit;
-
 	*identify_resp = identify_reply;
 
 out:
@@ -1936,17 +1951,14 @@ static int aac_get_safw_attr_all_targets
 		rcode = aac_issue_safw_bmic_identify(dev,
 						&identify_resp, bus, target);
 
-		if (unlikely(rcode < 0)) {
-			dev->hba_map[bus][target].qd_limit = 32;
+		if (unlikely(rcode < 0))
 			goto free_identify_resp;
-		}
 
 		dev->hba_map[bus][target].safw_identify_resp = identify_resp;
 	}
 
 out:
 	return rcode;
-
 free_identify_resp:
 	aac_free_safw_all_identify_resp(dev, i);
 	goto out;
@@ -1995,8 +2007,7 @@ static void aac_set_safw_attr_all_target
 		} else
 			devtype = AAC_DEVTYPE_ARC_RAW;
 
-		if (devtype != AAC_DEVTYPE_NATIVE_RAW)
-			goto update_devtype;
+		aac_set_safw_target_qd(dev, bus, target);
 
 update_devtype:
 		if (rescan == AAC_INIT)
