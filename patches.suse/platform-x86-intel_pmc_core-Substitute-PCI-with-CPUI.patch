From 21ae43570940f8393a80369f62a3880bd64daad8 Mon Sep 17 00:00:00 2001
From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date: Fri, 19 Jan 2018 14:28:21 +0530
Subject: [PATCH] platform/x86: intel_pmc_core: Substitute PCI with CPUID enumeration
Git-commit: 21ae43570940f8393a80369f62a3880bd64daad8
Patch-mainline: v4.16-rc1
References: FATE#326281

The Only use of PCI device enumeration here is to get the PMC base address
which is a fixed value i.e. 0xFE000000. On some platforms this can be read
through a non standard PCI BAR. But after Kabylake, PMC is not exposed as a
PCI device anymore. There are other non standard methods like ACPI LPIT
which can also be used for obtaining this value.

For simplicity, this value can be hardcoded as it won't change.

Since we don't have a PMC PCI device on any platform after Kabylake, this
creates a foundation for future SoC support.

Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/platform/x86/intel_pmc_core.c | 89 ++++++++++-----------------
 drivers/platform/x86/intel_pmc_core.h |  3 +-
 2 files changed, 32 insertions(+), 60 deletions(-)

diff --git a/drivers/platform/x86/intel_pmc_core.c b/drivers/platform/x86/intel_pmc_core.c
index da924d3bb3e5..e3b98fcceb57 100644
--- a/drivers/platform/x86/intel_pmc_core.c
+++ b/drivers/platform/x86/intel_pmc_core.c
@@ -18,12 +18,12 @@
  *
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/debugfs.h>
 #include <linux/delay.h>
-#include <linux/device.h>
 #include <linux/io.h>
 #include <linux/module.h>
-#include <linux/pci.h>
 #include <linux/uaccess.h>
 
 #include <asm/cpu_device_id.h>
@@ -119,13 +119,6 @@ static const struct pmc_reg_map spt_reg_map = {
 	.pm_read_disable_bit = SPT_PMC_READ_DISABLE_BIT,
 };
 
-static const struct pci_device_id pmc_pci_ids[] = {
-	{ PCI_VDEVICE(INTEL, SPT_PMC_PCI_DEVICE_ID),
-					(kernel_ulong_t)&spt_reg_map },
-	{ 0, },
-};
-MODULE_DEVICE_TABLE(pci, pmc_pci_ids);
-
 static inline u8 pmc_core_reg_read_byte(struct pmc_dev *pmcdev, int offset)
 {
 	return readb(pmcdev->regbase + offset);
@@ -448,79 +441,59 @@ static inline void pmc_core_dbgfs_unregister(struct pmc_dev *pmcdev)
 
 static const struct x86_cpu_id intel_pmc_core_ids[] = {
 	{ X86_VENDOR_INTEL, 6, INTEL_FAM6_SKYLAKE_MOBILE, X86_FEATURE_MWAIT,
-		(kernel_ulong_t)NULL},
+		(kernel_ulong_t)&spt_reg_map},
 	{ X86_VENDOR_INTEL, 6, INTEL_FAM6_SKYLAKE_DESKTOP, X86_FEATURE_MWAIT,
-		(kernel_ulong_t)NULL},
+		(kernel_ulong_t)&spt_reg_map},
 	{ X86_VENDOR_INTEL, 6, INTEL_FAM6_KABYLAKE_MOBILE, X86_FEATURE_MWAIT,
-		(kernel_ulong_t)NULL},
+		(kernel_ulong_t)&spt_reg_map},
 	{ X86_VENDOR_INTEL, 6, INTEL_FAM6_KABYLAKE_DESKTOP, X86_FEATURE_MWAIT,
-		(kernel_ulong_t)NULL},
+		(kernel_ulong_t)&spt_reg_map},
 	{}
 };
 
-static int pmc_core_probe(struct pci_dev *dev, const struct pci_device_id *id)
+MODULE_DEVICE_TABLE(x86cpu, intel_pmc_core_ids);
+
+static int __init pmc_core_probe(void)
 {
-	struct device *ptr_dev = &dev->dev;
 	struct pmc_dev *pmcdev = &pmc;
 	const struct x86_cpu_id *cpu_id;
-	const struct pmc_reg_map *map = (struct pmc_reg_map *)id->driver_data;
 	int err;
 
 	cpu_id = x86_match_cpu(intel_pmc_core_ids);
-	if (!cpu_id) {
-		dev_dbg(&dev->dev, "PMC Core: cpuid mismatch.\n");
-		return -EINVAL;
-	}
-
-	err = pcim_enable_device(dev);
-	if (err < 0) {
-		dev_dbg(&dev->dev, "PMC Core: failed to enable Power Management Controller.\n");
-		return err;
-	}
-
-	err = pci_read_config_dword(dev,
-				    SPT_PMC_BASE_ADDR_OFFSET,
-				    &pmcdev->base_addr);
-	if (err < 0) {
-		dev_dbg(&dev->dev, "PMC Core: failed to read PCI config space.\n");
-		return err;
-	}
-	pmcdev->base_addr &= PMC_BASE_ADDR_MASK;
-	dev_dbg(&dev->dev, "PMC Core: PWRMBASE is %#x\n", pmcdev->base_addr);
-
-	pmcdev->regbase = devm_ioremap_nocache(ptr_dev,
-					      pmcdev->base_addr,
-					      SPT_PMC_MMIO_REG_LEN);
-	if (!pmcdev->regbase) {
-		dev_dbg(&dev->dev, "PMC Core: ioremap failed.\n");
+	if (!cpu_id)
+		return -ENODEV;
+
+	pmcdev->map = (struct pmc_reg_map *)cpu_id->driver_data;
+	pmcdev->base_addr = PMC_BASE_ADDR_DEFAULT;
+	pmcdev->regbase = ioremap(pmcdev->base_addr,
+				  pmcdev->map->regmap_length);
+	if (!pmcdev->regbase)
 		return -ENOMEM;
-	}
 
 	mutex_init(&pmcdev->lock);
-	pmcdev->map = map;
 	pmcdev->pmc_xram_read_bit = pmc_core_check_read_lock_bit();
 
 	err = pmc_core_dbgfs_register(pmcdev);
-	if (err < 0)
-		dev_warn(&dev->dev, "PMC Core: debugfs register failed.\n");
+	if (err < 0) {
+		pr_warn(" debugfs register failed.\n");
+		iounmap(pmcdev->regbase);
+		return err;
+	}
 
+	pr_info(" initialized\n");
 	return 0;
 }
+module_init(pmc_core_probe)
 
-static void pmc_core_remove(struct pci_dev *dev)
+static void __exit pmc_core_remove(void)
 {
-	pmc_core_dbgfs_unregister(&pmc);
-	mutex_destroy(&pmc.lock);
-}
-
-static struct pci_driver intel_pmc_core_driver = {
-	.name = "intel_pmc_core",
-	.id_table = pmc_pci_ids,
-	.probe = pmc_core_probe,
-	.remove = pmc_core_remove,
-};
+	struct pmc_dev *pmcdev = &pmc;
 
-module_pci_driver(intel_pmc_core_driver);
+	pmc_core_dbgfs_unregister(pmcdev);
+	mutex_destroy(&pmcdev->lock);
+	iounmap(pmcdev->regbase);
+}
+module_exit(pmc_core_remove)
 
 MODULE_LICENSE("GPL v2");
 MODULE_DESCRIPTION("Intel PMC Core Driver");
diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index e3be1d2b08cd..9df4a60a179f 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -21,8 +21,7 @@
 #ifndef PMC_CORE_H
 #define PMC_CORE_H
 
-/* Sunrise Point Power Management Controller PCI Device ID */
-#define SPT_PMC_PCI_DEVICE_ID			0x9d21
+#define PMC_BASE_ADDR_DEFAULT			0xFE000000
 
 #define SPT_PMC_BASE_ADDR_OFFSET		0x48
 #define SPT_PMC_SLP_S0_RES_COUNTER_OFFSET	0x13c
-- 
2.18.0

