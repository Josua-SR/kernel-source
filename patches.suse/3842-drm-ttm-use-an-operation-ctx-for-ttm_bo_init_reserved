From: =?UTF-8?q?Christian=20K=C3=B6nig?= <christian.koenig@amd.com>
Date: Wed, 12 Apr 2017 14:41:43 +0200
Subject: drm/ttm: use an operation ctx for ttm_bo_init_reserved
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 6fead44a4c5897c1524005ed3228b86120ff3ada
Patch-mainline: v4.16-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Instead of specifying if sleeping should be interruptible.

Signed-off-by: Christian König <christian.koenig@amd.com>
Reviewed-by: Michel Dänzer <michel.daenzer@amd.com>
Reviewed-by: Chunming Zhou <david1.zhou@amd.com>
Tested-by: Dieter Nützel <Dieter@nuetzel-hh.de>
Tested-by: Michel Dänzer <michel.daenzer@amd.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_object.c |    3 ++-
 drivers/gpu/drm/ttm/ttm_bo.c               |   12 +++++-------
 include/drm/ttm/ttm_bo_api.h               |    5 ++---
 3 files changed, 9 insertions(+), 11 deletions(-)

--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
@@ -327,6 +327,7 @@ static int amdgpu_bo_do_create(struct am
 			       uint64_t init_value,
 			       struct amdgpu_bo **bo_ptr)
 {
+	struct ttm_operation_ctx ctx = { !kernel, false };
 	struct amdgpu_bo *bo;
 	enum ttm_bo_type type;
 	unsigned long page_align;
@@ -408,7 +409,7 @@ static int amdgpu_bo_do_create(struct am
 	initial_bytes_moved = atomic64_read(&adev->num_bytes_moved);
 	/* Kernel allocation are uninterruptible */
 	r = ttm_bo_init_reserved(&adev->mman.bdev, &bo->tbo, size, type,
-				 &bo->placement, page_align, !kernel, NULL,
+				 &bo->placement, page_align, &ctx, NULL,
 				 acc_size, sg, resv, &amdgpu_ttm_bo_destroy);
 	if (unlikely(r != 0))
 		return r;
--- a/drivers/gpu/drm/ttm/ttm_bo.c
+++ b/drivers/gpu/drm/ttm/ttm_bo.c
@@ -1132,7 +1132,7 @@ int ttm_bo_init_reserved(struct ttm_bo_d
 			 enum ttm_bo_type type,
 			 struct ttm_placement *placement,
 			 uint32_t page_alignment,
-			 bool interruptible,
+			 struct ttm_operation_ctx *ctx,
 			 struct file *persistent_swap_storage,
 			 size_t acc_size,
 			 struct sg_table *sg,
@@ -1218,11 +1218,8 @@ int ttm_bo_init_reserved(struct ttm_bo_d
 		WARN_ON(!locked);
 	}
 
-	if (likely(!ret)) {
-		struct ttm_operation_ctx ctx = { interruptible, false };
-
-		ret = ttm_bo_validate(bo, placement, &ctx);
-	}
+	if (likely(!ret))
+		ret = ttm_bo_validate(bo, placement, ctx);
 
 	if (unlikely(ret)) {
 		if (!resv)
@@ -1255,10 +1252,11 @@ int ttm_bo_init(struct ttm_bo_device *bd
 		struct reservation_object *resv,
 		void (*destroy) (struct ttm_buffer_object *))
 {
+	struct ttm_operation_ctx ctx = { interruptible, false };
 	int ret;
 
 	ret = ttm_bo_init_reserved(bdev, bo, size, type, placement,
-				   page_alignment, interruptible,
+				   page_alignment, &ctx,
 				   persistent_swap_storage, acc_size,
 				   sg, resv, destroy);
 	if (ret)
--- a/include/drm/ttm/ttm_bo_api.h
+++ b/include/drm/ttm/ttm_bo_api.h
@@ -455,8 +455,7 @@ size_t ttm_bo_dma_acc_size(struct ttm_bo
  * @type: Requested type of buffer object.
  * @flags: Initial placement flags.
  * @page_alignment: Data alignment in pages.
- * @interruptible: If needing to sleep to wait for GPU resources,
- * sleep interruptible.
+ * @ctx: TTM operation context for memory allocation.
  * @persistent_swap_storage: Usually the swap storage is deleted for buffers
  * pinned in physical memory. If this behaviour is not desired, this member
  * holds a pointer to a persistent shmem object. Typically, this would
@@ -493,7 +492,7 @@ int ttm_bo_init_reserved(struct ttm_bo_d
 			 enum ttm_bo_type type,
 			 struct ttm_placement *placement,
 			 uint32_t page_alignment,
-			 bool interrubtible,
+			 struct ttm_operation_ctx *ctx,
 			 struct file *persistent_swap_storage,
 			 size_t acc_size,
 			 struct sg_table *sg,
