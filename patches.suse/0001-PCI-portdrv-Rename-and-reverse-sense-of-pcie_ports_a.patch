From d850882b726f6db01b0792151e72e69b234aa461 Mon Sep 17 00:00:00 2001
From: Bjorn Helgaas <bhelgaas@google.com>
Date: Fri, 9 Mar 2018 11:21:30 -0600
Subject: [PATCH] PCI/portdrv: Rename and reverse sense of pcie_ports_auto
Git-commit: d850882b726f6db01b0792151e72e69b234aa461
Patch-mainline: v4.17
References: FATE#326302

The platform may restrict the OS's use of PCIe services, e.g., via the ACPI
_OSC method.  The user may use "pcie_ports=native" to force the port driver
to use PCIe services even if the platform asked us not to.

The "pcie_ports=native" parameter determines the setting of
pcie_ports_auto.  Rename this to pcie_ports_native and reverse the
sense to simplify the code.

Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
Signed-off-by: Oliver Neukum <oneukum@suse.com>
---
 drivers/pci/pcie/portdrv.h      |    2 ++
 drivers/pci/pcie/portdrv_core.c |   16 ++++------------
 drivers/pci/pcie/portdrv_pci.c  |   11 ++++-------
 3 files changed, 10 insertions(+), 19 deletions(-)

--- a/drivers/pci/pcie/portdrv.h
+++ b/drivers/pci/pcie/portdrv.h
@@ -11,6 +11,8 @@
 
 #include <linux/compiler.h>
 
+extern bool pcie_ports_native;
+
 /* Service Type */
 #define PCIE_PORT_SERVICE_PME_SHIFT	0	/* Power Management Event */
 #define PCIE_PORT_SERVICE_PME		(1 << PCIE_PORT_SERVICE_PME_SHIFT)
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -208,18 +208,10 @@ legacy_irq:
 static int get_port_device_capability(struct pci_dev *dev)
 {
 	struct pci_host_bridge *host = pci_find_host_bridge(dev->bus);
-	bool native;
 	int services = 0;
 
-	/*
-	 * If the user specified "pcie_ports=native", use the PCIe services
-	 * regardless of whether the platform has given us permission.  On
-	 * ACPI systems, this means we ignore _OSC.
-	 */
-	native = !pcie_ports_auto;
-
-	/* Hot-Plug Capable */
-	if (dev->is_hotplug_bridge && (native || host->native_hotplug)) {
+	if (dev->is_hotplug_bridge &&
+	    (pcie_ports_native || host->native_hotplug)) {
 		services |= PCIE_PORT_SERVICE_HP;
 
 		/*
@@ -231,7 +223,7 @@ static int get_port_device_capability(st
 	}
 
 	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR) &&
-	    pci_aer_available() && (native || host->native_aer)) {
+	    pci_aer_available() && (pcie_ports_native || host->native_aer)) {
 		services |= PCIE_PORT_SERVICE_AER;
 
 		/*
@@ -250,7 +242,7 @@ static int get_port_device_capability(st
 	 * those yet.
 	 */
 	if (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT &&
-	    (native || host->native_pme)) {
+	    (pcie_ports_native || host->native_pme)) {
 		services |= PCIE_PORT_SERVICE_PME;
 
 		/*
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -25,21 +25,18 @@
 bool pcie_ports_disabled;
 
 /*
- * If this switch is set, ACPI _OSC will be used to determine whether or not to
- * enable PCIe port native services.
+ * If the user specified "pcie_ports=native", use the PCIe services regardless
+ * of whether the platform has given us permission.  On ACPI systems, this
+ * means we ignore _OSC.
  */
-bool pcie_ports_auto = true;
+bool pcie_ports_native;
 
 static int __init pcie_port_setup(char *str)
 {
 	if (!strncmp(str, "compat", 6)) {
 		pcie_ports_disabled = true;
-	} else if (!strncmp(str, "native", 6)) {
-		pcie_ports_disabled = false;
-		pcie_ports_auto = false;
 	} else if (!strncmp(str, "auto", 4)) {
 		pcie_ports_disabled = false;
-		pcie_ports_auto = true;
 	}
 
 	return 1;
