From: Andrii Nakryiko <andriin@fb.com>
Date: Thu, 9 Jul 2020 18:10:23 -0700
Subject: libbpf: Fix memory leak and optimize BTF sanitization
Patch-mainline: v5.9-rc1
Git-commit: 5c3320d7fece4612d4a413aa3c8e82cdb5b49fcb
References: bsc#1177028

Coverity's static analysis helpfully reported a memory leak introduced by
0f0e55d8247c ("libbpf: Improve BTF sanitization handling"). While fixing it,
I realized that btf__new() already creates a memory copy, so there is no need
to do this. So this patch also fixes misleading btf__new() signature to make
data into a `const void *` input parameter. And it avoids unnecessary memory
allocation and copy in BTF sanitization code altogether.

Fixes: 0f0e55d8247c ("libbpf: Improve BTF sanitization handling")
Signed-off-by: Andrii Nakryiko <andriin@fb.com>
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Link: https://lore.kernel.org/bpf/20200710011023.1655008-1-andriin@fb.com
Acked-by: Gary Lin <glin@suse.com>
---
 tools/lib/bpf/btf.c    |    2 +-
 tools/lib/bpf/btf.h    |    2 +-
 tools/lib/bpf/libbpf.c |   11 +++--------
 3 files changed, 5 insertions(+), 10 deletions(-)

--- a/tools/lib/bpf/btf.c
+++ b/tools/lib/bpf/btf.c
@@ -397,7 +397,7 @@ void btf__free(struct btf *btf)
 	free(btf);
 }
 
-struct btf *btf__new(__u8 *data, __u32 size)
+struct btf *btf__new(const void *data, __u32 size)
 {
 	struct btf *btf;
 	int err;
--- a/tools/lib/bpf/btf.h
+++ b/tools/lib/bpf/btf.h
@@ -63,7 +63,7 @@ struct btf_ext_header {
 };
 
 LIBBPF_API void btf__free(struct btf *btf);
-LIBBPF_API struct btf *btf__new(__u8 *data, __u32 size);
+LIBBPF_API struct btf *btf__new(const void *data, __u32 size);
 LIBBPF_API struct btf *btf__parse_elf(const char *path,
 				      struct btf_ext **btf_ext);
 LIBBPF_API int btf__finalize_data(struct bpf_object *obj, struct btf *btf);
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@ -2533,17 +2533,12 @@ static int bpf_object__sanitize_and_load
 
 	sanitize = btf_needs_sanitization(obj);
 	if (sanitize) {
-		const void *orig_data;
-		void *san_data;
+		const void *raw_data;
 		__u32 sz;
 
 		/* clone BTF to sanitize a copy and leave the original intact */
-		orig_data = btf__get_raw_data(obj->btf, &sz);
-		san_data = malloc(sz);
-		if (!san_data)
-			return -ENOMEM;
-		memcpy(san_data, orig_data, sz);
-		kern_btf = btf__new(san_data, sz);
+		raw_data = btf__get_raw_data(obj->btf, &sz);
+		kern_btf = btf__new(raw_data, sz);
 		if (IS_ERR(kern_btf))
 			return PTR_ERR(kern_btf);
 
