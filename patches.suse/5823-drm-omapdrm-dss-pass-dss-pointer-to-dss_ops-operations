From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Tue, 13 Feb 2018 14:00:24 +0200
Subject: drm: omapdrm: dss: Pass DSS pointer to dss_ops operations
Git-commit: 8aea8e6a79e77f4c4af4edc45db744f28f6fe008
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

This removes the need to access the global DSS private data in those
functions (both for the current accesses and the future ones that will
be introduced when allocating the DSS device dynamically).

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/omapdrm/dss/dpi.c   |   12 +++---
 drivers/gpu/drm/omapdrm/dss/dsi.c   |   18 +++++----
 drivers/gpu/drm/omapdrm/dss/dss.c   |   68 +++++++++++++++++++++---------------
 drivers/gpu/drm/omapdrm/dss/dss.h   |   25 +++++++------
 drivers/gpu/drm/omapdrm/dss/hdmi.h  |    1 
 drivers/gpu/drm/omapdrm/dss/hdmi4.c |    3 +
 drivers/gpu/drm/omapdrm/dss/hdmi5.c |    3 +
 7 files changed, 77 insertions(+), 53 deletions(-)

--- a/drivers/gpu/drm/omapdrm/dss/dpi.c
+++ b/drivers/gpu/drm/omapdrm/dss/dpi.c
@@ -38,6 +38,7 @@
 struct dpi_data {
 	struct platform_device *pdev;
 	enum dss_model dss_model;
+	struct dss_device *dss;
 
 	struct regulator *vdds_dsi_reg;
 	enum dss_clk_source clk_src;
@@ -302,7 +303,7 @@ static int dpi_set_pll_clk(struct dpi_da
 	if (r)
 		return r;
 
-	dss_select_lcd_clk_source(channel, dpi->clk_src);
+	dss_select_lcd_clk_source(dpi->dss, channel, dpi->clk_src);
 
 	dpi->mgr_config.clock_info = ctx.dispc_cinfo;
 
@@ -412,7 +413,7 @@ static int dpi_display_enable(struct oma
 	if (r)
 		goto err_get_dispc;
 
-	r = dss_dpi_select_source(out->port_num, channel);
+	r = dss_dpi_select_source(dpi->dss, out->port_num, channel);
 	if (r)
 		goto err_src_sel;
 
@@ -464,7 +465,7 @@ static void dpi_display_disable(struct o
 	dss_mgr_disable(channel);
 
 	if (dpi->pll) {
-		dss_select_lcd_clk_source(channel, DSS_CLK_SRC_FCK);
+		dss_select_lcd_clk_source(dpi->dss, channel, DSS_CLK_SRC_FCK);
 		dss_pll_disable(dpi->pll);
 	}
 
@@ -748,8 +749,8 @@ static void dpi_uninit_output_port(struc
 	omapdss_unregister_output(out);
 }
 
-int dpi_init_port(struct platform_device *pdev, struct device_node *port,
-		  enum dss_model dss_model)
+int dpi_init_port(struct dss_device *dss, struct platform_device *pdev,
+		  struct device_node *port, enum dss_model dss_model)
 {
 	struct dpi_data *dpi;
 	struct device_node *ep;
@@ -776,6 +777,7 @@ int dpi_init_port(struct platform_device
 
 	dpi->pdev = pdev;
 	dpi->dss_model = dss_model;
+	dpi->dss = dss;
 	port->data = dpi;
 
 	mutex_init(&dpi->lock);
--- a/drivers/gpu/drm/omapdrm/dss/dsi.c
+++ b/drivers/gpu/drm/omapdrm/dss/dsi.c
@@ -343,6 +343,7 @@ struct dsi_data {
 
 	struct clk *dss_clk;
 	struct regmap *syscon;
+	struct dss_device *dss;
 
 	struct dispc_clock_info user_dispc_cinfo;
 	struct dss_pll_clock_info user_dsi_cinfo;
@@ -4206,7 +4207,7 @@ static int dsi_display_init_dispc(struct
 	struct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);
 	int r;
 
-	dss_select_lcd_clk_source(channel, dsi->module_id == 0 ?
+	dss_select_lcd_clk_source(dsi->dss, channel, dsi->module_id == 0 ?
 			DSS_CLK_SRC_PLL1_1 :
 			DSS_CLK_SRC_PLL2_1);
 
@@ -4260,7 +4261,7 @@ err1:
 		dss_mgr_unregister_framedone_handler(channel,
 				dsi_framedone_irq_callback, dsidev);
 err:
-	dss_select_lcd_clk_source(channel, DSS_CLK_SRC_FCK);
+	dss_select_lcd_clk_source(dsi->dss, channel, DSS_CLK_SRC_FCK);
 	return r;
 }
 
@@ -4273,7 +4274,7 @@ static void dsi_display_uninit_dispc(str
 		dss_mgr_unregister_framedone_handler(channel,
 				dsi_framedone_irq_callback, dsidev);
 
-	dss_select_lcd_clk_source(channel, DSS_CLK_SRC_FCK);
+	dss_select_lcd_clk_source(dsi->dss, channel, DSS_CLK_SRC_FCK);
 }
 
 static int dsi_configure_dsi_clocks(struct platform_device *dsidev)
@@ -4306,9 +4307,9 @@ static int dsi_display_init_dsi(struct p
 	if (r)
 		goto err1;
 
-	dss_select_dsi_clk_source(dsi->module_id, dsi->module_id == 0 ?
-			DSS_CLK_SRC_PLL1_2 :
-			DSS_CLK_SRC_PLL2_2);
+	dss_select_dsi_clk_source(dsi->dss, dsi->module_id,
+				  dsi->module_id == 0 ?
+				  DSS_CLK_SRC_PLL1_2 : DSS_CLK_SRC_PLL2_2);
 
 	DSSDBG("PLL OK\n");
 
@@ -4340,7 +4341,7 @@ static int dsi_display_init_dsi(struct p
 err3:
 	dsi_cio_uninit(dsidev);
 err2:
-	dss_select_dsi_clk_source(dsi->module_id, DSS_CLK_SRC_FCK);
+	dss_select_dsi_clk_source(dsi->dss, dsi->module_id, DSS_CLK_SRC_FCK);
 err1:
 	dss_pll_disable(&dsi->pll);
 err0:
@@ -4362,7 +4363,7 @@ static void dsi_display_uninit_dsi(struc
 	dsi_vc_enable(dsidev, 2, 0);
 	dsi_vc_enable(dsidev, 3, 0);
 
-	dss_select_dsi_clk_source(dsi->module_id, DSS_CLK_SRC_FCK);
+	dss_select_dsi_clk_source(dsi->dss, dsi->module_id, DSS_CLK_SRC_FCK);
 	dsi_cio_uninit(dsidev);
 	dsi_pll_uninit(dsidev, disconnect_lanes);
 }
@@ -5432,6 +5433,7 @@ static int dsi_bind(struct device *dev,
 	if (!dsi)
 		return -ENOMEM;
 
+	dsi->dss = dss;
 	dsi->pdev = dsidev;
 	dev_set_drvdata(&dsidev->dev, dsi);
 
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -69,9 +69,11 @@ struct dss_reg {
 	dss_write_reg(idx, FLD_MOD(dss_read_reg(idx), val, start, end))
 
 struct dss_ops {
-	int (*dpi_select_source)(int port, enum omap_channel channel);
-	int (*select_lcd_source)(enum omap_channel channel,
-		enum dss_clk_source clk_src);
+	int (*dpi_select_source)(struct dss_device *dss, int port,
+				 enum omap_channel channel);
+	int (*select_lcd_source)(struct dss_device *dss,
+				 enum omap_channel channel,
+				 enum dss_clk_source clk_src);
 };
 
 struct dss_features {
@@ -432,8 +434,8 @@ static void dss_select_dispc_clk_source(
 	dss.dispc_clk_source = clk_src;
 }
 
-void dss_select_dsi_clk_source(int dsi_module,
-		enum dss_clk_source clk_src)
+void dss_select_dsi_clk_source(struct dss_device *dss, int dsi_module,
+			       enum dss_clk_source clk_src)
 {
 	int b, pos;
 
@@ -457,11 +459,12 @@ void dss_select_dsi_clk_source(int dsi_m
 	pos = dsi_module == 0 ? 1 : 10;
 	REG_FLD_MOD(DSS_CONTROL, b, pos, pos);	/* DSIx_CLK_SWITCH */
 
-	dss.dsi_clk_source[dsi_module] = clk_src;
+	dss->dsi_clk_source[dsi_module] = clk_src;
 }
 
-static int dss_lcd_clk_mux_dra7(enum omap_channel channel,
-	enum dss_clk_source clk_src)
+static int dss_lcd_clk_mux_dra7(struct dss_device *dss,
+				enum omap_channel channel,
+				enum dss_clk_source clk_src)
 {
 	const u8 ctrl_bits[] = {
 		[OMAP_DSS_CHANNEL_LCD] = 0,
@@ -487,8 +490,9 @@ static int dss_lcd_clk_mux_dra7(enum oma
 	return 0;
 }
 
-static int dss_lcd_clk_mux_omap5(enum omap_channel channel,
-	enum dss_clk_source clk_src)
+static int dss_lcd_clk_mux_omap5(struct dss_device *dss,
+				 enum omap_channel channel,
+				 enum dss_clk_source clk_src)
 {
 	const u8 ctrl_bits[] = {
 		[OMAP_DSS_CHANNEL_LCD] = 0,
@@ -517,8 +521,9 @@ static int dss_lcd_clk_mux_omap5(enum om
 	return 0;
 }
 
-static int dss_lcd_clk_mux_omap4(enum omap_channel channel,
-	enum dss_clk_source clk_src)
+static int dss_lcd_clk_mux_omap4(struct dss_device *dss,
+				 enum omap_channel channel,
+				 enum dss_clk_source clk_src)
 {
 	const u8 ctrl_bits[] = {
 		[OMAP_DSS_CHANNEL_LCD] = 0,
@@ -545,23 +550,24 @@ static int dss_lcd_clk_mux_omap4(enum om
 	return 0;
 }
 
-void dss_select_lcd_clk_source(enum omap_channel channel,
-		enum dss_clk_source clk_src)
+void dss_select_lcd_clk_source(struct dss_device *dss,
+			       enum omap_channel channel,
+			       enum dss_clk_source clk_src)
 {
 	int idx = dss_get_channel_index(channel);
 	int r;
 
-	if (!dss.feat->has_lcd_clk_src) {
+	if (!dss->feat->has_lcd_clk_src) {
 		dss_select_dispc_clk_source(clk_src);
-		dss.lcd_clk_source[idx] = clk_src;
+		dss->lcd_clk_source[idx] = clk_src;
 		return;
 	}
 
-	r = dss.feat->ops->select_lcd_source(channel, clk_src);
+	r = dss->feat->ops->select_lcd_source(dss, channel, clk_src);
 	if (r)
 		return;
 
-	dss.lcd_clk_source[idx] = clk_src;
+	dss->lcd_clk_source[idx] = clk_src;
 }
 
 enum dss_clk_source dss_get_dispc_clk_source(void)
@@ -710,11 +716,12 @@ void dss_set_dac_pwrdn_bgz(bool enable)
 	REG_FLD_MOD(DSS_CONTROL, enable, 5, 5);	/* DAC Power-Down Control */
 }
 
-void dss_select_hdmi_venc_clk_source(enum dss_hdmi_venc_clk_source_select src)
+void dss_select_hdmi_venc_clk_source(struct dss_device *dss,
+				     enum dss_hdmi_venc_clk_source_select src)
 {
 	enum omap_dss_output_id outputs;
 
-	outputs = dss.feat->outputs[OMAP_DSS_CHANNEL_DIGIT];
+	outputs = dss->feat->outputs[OMAP_DSS_CHANNEL_DIGIT];
 
 	/* Complain about invalid selections */
 	WARN_ON((src == DSS_VENC_TV_CLK) && !(outputs & OMAP_DSS_OUTPUT_VENC));
@@ -726,7 +733,8 @@ void dss_select_hdmi_venc_clk_source(enu
 		REG_FLD_MOD(DSS_CONTROL, src, 15, 15);	/* VENC_HDMI_SWITCH */
 }
 
-static int dss_dpi_select_source_omap2_omap3(int port, enum omap_channel channel)
+static int dss_dpi_select_source_omap2_omap3(struct dss_device *dss, int port,
+					     enum omap_channel channel)
 {
 	if (channel != OMAP_DSS_CHANNEL_LCD)
 		return -EINVAL;
@@ -734,7 +742,8 @@ static int dss_dpi_select_source_omap2_o
 	return 0;
 }
 
-static int dss_dpi_select_source_omap4(int port, enum omap_channel channel)
+static int dss_dpi_select_source_omap4(struct dss_device *dss, int port,
+				       enum omap_channel channel)
 {
 	int val;
 
@@ -754,7 +763,8 @@ static int dss_dpi_select_source_omap4(i
 	return 0;
 }
 
-static int dss_dpi_select_source_omap5(int port, enum omap_channel channel)
+static int dss_dpi_select_source_omap5(struct dss_device *dss, int port,
+				       enum omap_channel channel)
 {
 	int val;
 
@@ -780,11 +790,12 @@ static int dss_dpi_select_source_omap5(i
 	return 0;
 }
 
-static int dss_dpi_select_source_dra7xx(int port, enum omap_channel channel)
+static int dss_dpi_select_source_dra7xx(struct dss_device *dss, int port,
+					enum omap_channel channel)
 {
 	switch (port) {
 	case 0:
-		return dss_dpi_select_source_omap5(port, channel);
+		return dss_dpi_select_source_omap5(dss, port, channel);
 	case 1:
 		if (channel != OMAP_DSS_CHANNEL_LCD2)
 			return -EINVAL;
@@ -800,9 +811,10 @@ static int dss_dpi_select_source_dra7xx(
 	return 0;
 }
 
-int dss_dpi_select_source(int port, enum omap_channel channel)
+int dss_dpi_select_source(struct dss_device *dss, int port,
+			  enum omap_channel channel)
 {
-	return dss.feat->ops->dpi_select_source(port, channel);
+	return dss->feat->ops->dpi_select_source(dss, port, channel);
 }
 
 static int dss_get_clocks(void)
@@ -1147,7 +1159,7 @@ static int dss_init_ports(struct platfor
 
 		switch (dss.feat->ports[i]) {
 		case OMAP_DISPLAY_TYPE_DPI:
-			dpi_init_port(pdev, port, dss.feat->model);
+			dpi_init_port(&dss, pdev, port, dss.feat->model);
 			break;
 		case OMAP_DISPLAY_TYPE_SDI:
 			sdi_init_port(&dss, pdev, port);
--- a/drivers/gpu/drm/omapdrm/dss/dss.h
+++ b/drivers/gpu/drm/omapdrm/dss/dss.h
@@ -300,8 +300,10 @@ void dss_runtime_put(struct dss_device *
 unsigned long dss_get_dispc_clk_rate(void);
 unsigned long dss_get_max_fck_rate(void);
 enum omap_dss_output_id dss_get_supported_outputs(enum omap_channel channel);
-int dss_dpi_select_source(int port, enum omap_channel channel);
-void dss_select_hdmi_venc_clk_source(enum dss_hdmi_venc_clk_source_select);
+int dss_dpi_select_source(struct dss_device *dss, int port,
+			  enum omap_channel channel);
+void dss_select_hdmi_venc_clk_source(struct dss_device *dss,
+				     enum dss_hdmi_venc_clk_source_select src);
 const char *dss_get_clk_source_name(enum dss_clk_source clk_src);
 
 /* DSS VIDEO PLL */
@@ -316,10 +318,11 @@ void dss_sdi_init(struct dss_device *dss
 int dss_sdi_enable(struct dss_device *dss);
 void dss_sdi_disable(struct dss_device *dss);
 
-void dss_select_dsi_clk_source(int dsi_module,
-		enum dss_clk_source clk_src);
-void dss_select_lcd_clk_source(enum omap_channel channel,
-		enum dss_clk_source clk_src);
+void dss_select_dsi_clk_source(struct dss_device *dss, int dsi_module,
+			       enum dss_clk_source clk_src);
+void dss_select_lcd_clk_source(struct dss_device *dss,
+			       enum omap_channel channel,
+			       enum dss_clk_source clk_src);
 enum dss_clk_source dss_get_dispc_clk_source(void);
 enum dss_clk_source dss_get_dsi_clk_source(int dsi_module);
 enum dss_clk_source dss_get_lcd_clk_source(enum omap_channel channel);
@@ -365,12 +368,14 @@ void dsi_irq_handler(void);
 
 /* DPI */
 #ifdef CONFIG_OMAP2_DSS_DPI
-int dpi_init_port(struct platform_device *pdev, struct device_node *port,
-		  enum dss_model dss_model);
+int dpi_init_port(struct dss_device *dss, struct platform_device *pdev,
+		  struct device_node *port, enum dss_model dss_model);
 void dpi_uninit_port(struct device_node *port);
 #else
-static inline int dpi_init_port(struct platform_device *pdev,
-		struct device_node *port, enum dss_model dss_model)
+static inline int dpi_init_port(struct dss_device *port,
+				struct platform_device *pdev,
+				struct device_node *port,
+				enum dss_model dss_model)
 {
 	return 0;
 }
--- a/drivers/gpu/drm/omapdrm/dss/hdmi.h
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi.h
@@ -359,6 +359,7 @@ static inline bool hdmi_mode_has_audio(s
 struct omap_hdmi {
 	struct mutex lock;
 	struct platform_device *pdev;
+	struct dss_device *dss;
 
 	struct hdmi_wp_data	wp;
 	struct hdmi_pll_data	pll;
--- a/drivers/gpu/drm/omapdrm/dss/hdmi4.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi4.c
@@ -148,7 +148,7 @@ static int hdmi_power_on_core(struct oma
 	hdmi4_core_powerdown_disable(&hdmi.core);
 
 	/* Make selection of HDMI in DSS */
-	dss_select_hdmi_venc_clk_source(DSS_HDMI_M_PCLK);
+	dss_select_hdmi_venc_clk_source(hdmi.dss, DSS_HDMI_M_PCLK);
 
 	hdmi.core_enabled = true;
 
@@ -722,6 +722,7 @@ static int hdmi4_bind(struct device *dev
 	int irq;
 
 	hdmi.pdev = pdev;
+	hdmi.dss = dss;
 	dev_set_drvdata(&pdev->dev, &hdmi);
 
 	mutex_init(&hdmi.lock);
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -149,7 +149,7 @@ static int hdmi_power_on_core(struct oma
 		goto err_runtime_get;
 
 	/* Make selection of HDMI in DSS */
-	dss_select_hdmi_venc_clk_source(DSS_HDMI_M_PCLK);
+	dss_select_hdmi_venc_clk_source(hdmi.dss, DSS_HDMI_M_PCLK);
 
 	hdmi.core_enabled = true;
 
@@ -723,6 +723,7 @@ static int hdmi5_bind(struct device *dev
 	int irq;
 
 	hdmi.pdev = pdev;
+	hdmi.dss = dss;
 	dev_set_drvdata(&pdev->dev, &hdmi);
 
 	mutex_init(&hdmi.lock);
