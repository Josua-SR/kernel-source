From: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date: Fri, 19 May 2017 18:09:21 +0200
Subject: gpio: mvebu: switch to regmap for register access

Git-commit: 2233bf7a92e784f20d1a4a1d39438dcf51e75161
Patch-mainline: v4.13-rc1
References: fate#326470

In order to be able to use this driver with the Armada 7K/8K SoCs, we
need to use the regmap to access the registers. Indeed for these new SoCs,
the gpio node will be part of a syscon.

[gregory.clement@free-electrons.com:
 - fixed merge conflcit from 4.10 to 4.12-rc1
 - added a commit log]

Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
Signed-off-by: Mian Yousaf Kaukab <yousaf.kaukab@suse.com>
---
 drivers/gpio/gpio-mvebu.c |  436 +++++++++++++++++++++++++---------------------
 1 file changed, 245 insertions(+), 191 deletions(-)

--- a/drivers/gpio/gpio-mvebu.c
+++ b/drivers/gpio/gpio-mvebu.c
@@ -47,6 +47,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/platform_device.h>
 #include <linux/pwm.h>
+#include <linux/regmap.h>
 #include <linux/slab.h>
 
 #include "gpiolib.h"
@@ -106,9 +107,8 @@ struct mvebu_pwm {
 
 struct mvebu_gpio_chip {
 	struct gpio_chip   chip;
-	spinlock_t	   lock;
-	void __iomem	  *membase;
-	void __iomem	  *percpu_membase;
+	struct regmap     *regs;
+	struct regmap     *percpu_regs;
 	int		   irqbase;
 	struct irq_domain *domain;
 	int		   soc_variant;
@@ -130,92 +130,149 @@ struct mvebu_gpio_chip {
  * Functions returning addresses of individual registers for a given
  * GPIO controller.
  */
-static void __iomem *mvebu_gpioreg_out(struct mvebu_gpio_chip *mvchip)
-{
-	return mvchip->membase + GPIO_OUT_OFF;
-}
 
-static void __iomem *mvebu_gpioreg_blink(struct mvebu_gpio_chip *mvchip)
+static void mvebu_gpioreg_edge_cause(struct mvebu_gpio_chip *mvchip,
+			 struct regmap **map, unsigned int *offset)
 {
-	return mvchip->membase + GPIO_BLINK_EN_OFF;
-}
+	int cpu;
 
-static void __iomem *mvebu_gpioreg_blink_counter_select(struct mvebu_gpio_chip
-							*mvchip)
-{
-	return mvchip->membase + GPIO_BLINK_CNT_SELECT_OFF;
+	switch (mvchip->soc_variant) {
+	case MVEBU_GPIO_SOC_VARIANT_ORION:
+	case MVEBU_GPIO_SOC_VARIANT_MV78200:
+		*map = mvchip->regs;
+		*offset = GPIO_EDGE_CAUSE_OFF;
+		break;
+	case MVEBU_GPIO_SOC_VARIANT_ARMADAXP:
+		cpu = smp_processor_id();
+		*map = mvchip->percpu_regs;
+		*offset = GPIO_EDGE_CAUSE_ARMADAXP_OFF(cpu);
+		break;
+	default:
+		BUG();
+	}
 }
 
-static void __iomem *mvebu_gpioreg_io_conf(struct mvebu_gpio_chip *mvchip)
+static u32
+mvebu_gpio_read_edge_cause(struct mvebu_gpio_chip *mvchip)
 {
-	return mvchip->membase + GPIO_IO_CONF_OFF;
-}
+	struct regmap *map;
+	unsigned int offset;
+	u32 val;
 
-static void __iomem *mvebu_gpioreg_in_pol(struct mvebu_gpio_chip *mvchip)
-{
-	return mvchip->membase + GPIO_IN_POL_OFF;
+	mvebu_gpioreg_edge_cause(mvchip, &map, &offset);
+	regmap_read(map, offset, &val);
+
+	return val;
 }
 
-static void __iomem *mvebu_gpioreg_data_in(struct mvebu_gpio_chip *mvchip)
+static void
+mvebu_gpio_write_edge_cause(struct mvebu_gpio_chip *mvchip, u32 val)
 {
-	return mvchip->membase + GPIO_DATA_IN_OFF;
+	struct regmap *map;
+	unsigned int offset;
+
+	mvebu_gpioreg_edge_cause(mvchip, &map, &offset);
+	regmap_write(map, offset, val);
 }
 
-static void __iomem *mvebu_gpioreg_edge_cause(struct mvebu_gpio_chip *mvchip)
+static inline void
+mvebu_gpioreg_edge_mask(struct mvebu_gpio_chip *mvchip,
+			struct regmap **map, unsigned int *offset)
 {
 	int cpu;
 
 	switch (mvchip->soc_variant) {
 	case MVEBU_GPIO_SOC_VARIANT_ORION:
+		*map = mvchip->regs;
+		*offset = GPIO_EDGE_MASK_OFF;
+		break;
 	case MVEBU_GPIO_SOC_VARIANT_MV78200:
-		return mvchip->membase + GPIO_EDGE_CAUSE_OFF;
+		cpu = smp_processor_id();
+		*map = mvchip->regs;
+		*offset = GPIO_EDGE_MASK_MV78200_OFF(cpu);
+		break;
 	case MVEBU_GPIO_SOC_VARIANT_ARMADAXP:
 		cpu = smp_processor_id();
-		return mvchip->percpu_membase +
-			GPIO_EDGE_CAUSE_ARMADAXP_OFF(cpu);
+		*map = mvchip->percpu_regs;
+		*offset = GPIO_EDGE_MASK_ARMADAXP_OFF(cpu);
+		break;
 	default:
 		BUG();
 	}
 }
 
-static void __iomem *mvebu_gpioreg_edge_mask(struct mvebu_gpio_chip *mvchip)
+static u32
+mvebu_gpio_read_edge_mask(struct mvebu_gpio_chip *mvchip)
 {
-	int cpu;
+	struct regmap *map;
+	unsigned int offset;
+	u32 val;
 
-	switch (mvchip->soc_variant) {
-	case MVEBU_GPIO_SOC_VARIANT_ORION:
-		return mvchip->membase + GPIO_EDGE_MASK_OFF;
-	case MVEBU_GPIO_SOC_VARIANT_MV78200:
-		cpu = smp_processor_id();
-		return mvchip->membase + GPIO_EDGE_MASK_MV78200_OFF(cpu);
-	case MVEBU_GPIO_SOC_VARIANT_ARMADAXP:
-		cpu = smp_processor_id();
-		return mvchip->percpu_membase +
-			GPIO_EDGE_MASK_ARMADAXP_OFF(cpu);
-	default:
-		BUG();
-	}
+	mvebu_gpioreg_edge_mask(mvchip, &map, &offset);
+	regmap_read(map, offset, &val);
+
+	return val;
 }
 
-static void __iomem *mvebu_gpioreg_level_mask(struct mvebu_gpio_chip *mvchip)
+static void
+mvebu_gpio_write_edge_mask(struct mvebu_gpio_chip *mvchip, u32 val)
+{
+	struct regmap *map;
+	unsigned int offset;
+
+	mvebu_gpioreg_edge_mask(mvchip, &map, &offset);
+	regmap_write(map, offset, val);
+}
+
+static void
+mvebu_gpioreg_level_mask(struct mvebu_gpio_chip *mvchip,
+			 struct regmap **map, unsigned int *offset)
 {
 	int cpu;
 
 	switch (mvchip->soc_variant) {
 	case MVEBU_GPIO_SOC_VARIANT_ORION:
-		return mvchip->membase + GPIO_LEVEL_MASK_OFF;
+		*map = mvchip->regs;
+		*offset = GPIO_LEVEL_MASK_OFF;
+		break;
 	case MVEBU_GPIO_SOC_VARIANT_MV78200:
 		cpu = smp_processor_id();
-		return mvchip->membase + GPIO_LEVEL_MASK_MV78200_OFF(cpu);
+		*map = mvchip->regs;
+		*offset = GPIO_LEVEL_MASK_MV78200_OFF(cpu);
+		break;
 	case MVEBU_GPIO_SOC_VARIANT_ARMADAXP:
 		cpu = smp_processor_id();
-		return mvchip->percpu_membase +
-			GPIO_LEVEL_MASK_ARMADAXP_OFF(cpu);
+		*map = mvchip->percpu_regs;
+		*offset = GPIO_LEVEL_MASK_ARMADAXP_OFF(cpu);
+		break;
 	default:
 		BUG();
 	}
 }
 
+static u32
+mvebu_gpio_read_level_mask(struct mvebu_gpio_chip *mvchip)
+{
+	struct regmap *map;
+	unsigned int offset;
+	u32 val;
+
+	mvebu_gpioreg_level_mask(mvchip, &map, &offset);
+	regmap_read(map, offset, &val);
+
+	return val;
+}
+
+static void
+mvebu_gpio_write_level_mask(struct mvebu_gpio_chip *mvchip, u32 val)
+{
+	struct regmap *map;
+	unsigned int offset;
+
+	mvebu_gpioreg_level_mask(mvchip, &map, &offset);
+	regmap_write(map, offset, val);
+}
+
 /*
  * Functions returning addresses of individual registers for a given
  * PWM controller.
@@ -236,17 +293,9 @@ static void __iomem *mvebu_pwmreg_blink_
 static void mvebu_gpio_set(struct gpio_chip *chip, unsigned int pin, int value)
 {
 	struct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);
-	unsigned long flags;
-	u32 u;
 
-	spin_lock_irqsave(&mvchip->lock, flags);
-	u = readl_relaxed(mvebu_gpioreg_out(mvchip));
-	if (value)
-		u |= BIT(pin);
-	else
-		u &= ~BIT(pin);
-	writel_relaxed(u, mvebu_gpioreg_out(mvchip));
-	spin_unlock_irqrestore(&mvchip->lock, flags);
+	regmap_update_bits(mvchip->regs, GPIO_OUT_OFF,
+			   BIT(pin), value ? BIT(pin) : 0);
 }
 
 static int mvebu_gpio_get(struct gpio_chip *chip, unsigned int pin)
@@ -254,11 +303,16 @@ static int mvebu_gpio_get(struct gpio_ch
 	struct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);
 	u32 u;
 
-	if (readl_relaxed(mvebu_gpioreg_io_conf(mvchip)) & BIT(pin)) {
-		u = readl_relaxed(mvebu_gpioreg_data_in(mvchip)) ^
-			readl_relaxed(mvebu_gpioreg_in_pol(mvchip));
+	regmap_read(mvchip->regs, GPIO_IO_CONF_OFF, &u);
+
+	if (u & BIT(pin)) {
+		u32 data_in, in_pol;
+
+		regmap_read(mvchip->regs, GPIO_DATA_IN_OFF, &data_in);
+		regmap_read(mvchip->regs, GPIO_IN_POL_OFF, &in_pol);
+		u = data_in ^ in_pol;
 	} else {
-		u = readl_relaxed(mvebu_gpioreg_out(mvchip));
+		regmap_read(mvchip->regs, GPIO_OUT_OFF, &u);
 	}
 
 	return (u >> pin) & 1;
@@ -268,25 +322,15 @@ static void mvebu_gpio_blink(struct gpio
 			     int value)
 {
 	struct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);
-	unsigned long flags;
-	u32 u;
 
-	spin_lock_irqsave(&mvchip->lock, flags);
-	u = readl_relaxed(mvebu_gpioreg_blink(mvchip));
-	if (value)
-		u |= BIT(pin);
-	else
-		u &= ~BIT(pin);
-	writel_relaxed(u, mvebu_gpioreg_blink(mvchip));
-	spin_unlock_irqrestore(&mvchip->lock, flags);
+	regmap_update_bits(mvchip->regs, GPIO_BLINK_EN_OFF,
+			   BIT(pin), value ? BIT(pin) : 0);
 }
 
 static int mvebu_gpio_direction_input(struct gpio_chip *chip, unsigned int pin)
 {
 	struct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);
-	unsigned long flags;
 	int ret;
-	u32 u;
 
 	/*
 	 * Check with the pinctrl driver whether this pin is usable as
@@ -296,11 +340,8 @@ static int mvebu_gpio_direction_input(st
 	if (ret)
 		return ret;
 
-	spin_lock_irqsave(&mvchip->lock, flags);
-	u = readl_relaxed(mvebu_gpioreg_io_conf(mvchip));
-	u |= BIT(pin);
-	writel_relaxed(u, mvebu_gpioreg_io_conf(mvchip));
-	spin_unlock_irqrestore(&mvchip->lock, flags);
+	regmap_update_bits(mvchip->regs, GPIO_IO_CONF_OFF,
+			   BIT(pin), 1);
 
 	return 0;
 }
@@ -309,9 +350,7 @@ static int mvebu_gpio_direction_output(s
 				       int value)
 {
 	struct mvebu_gpio_chip *mvchip = gpiochip_get_data(chip);
-	unsigned long flags;
 	int ret;
-	u32 u;
 
 	/*
 	 * Check with the pinctrl driver whether this pin is usable as
@@ -324,11 +363,8 @@ static int mvebu_gpio_direction_output(s
 	mvebu_gpio_blink(chip, pin, 0);
 	mvebu_gpio_set(chip, pin, value);
 
-	spin_lock_irqsave(&mvchip->lock, flags);
-	u = readl_relaxed(mvebu_gpioreg_io_conf(mvchip));
-	u &= ~BIT(pin);
-	writel_relaxed(u, mvebu_gpioreg_io_conf(mvchip));
-	spin_unlock_irqrestore(&mvchip->lock, flags);
+	regmap_update_bits(mvchip->regs, GPIO_IO_CONF_OFF,
+			   BIT(pin), 0);
 
 	return 0;
 }
@@ -350,7 +386,7 @@ static void mvebu_gpio_irq_ack(struct ir
 	u32 mask = d->mask;
 
 	irq_gc_lock(gc);
-	writel_relaxed(~mask, mvebu_gpioreg_edge_cause(mvchip));
+	mvebu_gpio_write_edge_cause(mvchip, ~mask);
 	irq_gc_unlock(gc);
 }
 
@@ -363,8 +399,7 @@ static void mvebu_gpio_edge_irq_mask(str
 
 	irq_gc_lock(gc);
 	ct->mask_cache_priv &= ~mask;
-
-	writel_relaxed(ct->mask_cache_priv, mvebu_gpioreg_edge_mask(mvchip));
+	mvebu_gpio_write_edge_mask(mvchip, ct->mask_cache_priv);
 	irq_gc_unlock(gc);
 }
 
@@ -377,7 +412,7 @@ static void mvebu_gpio_edge_irq_unmask(s
 
 	irq_gc_lock(gc);
 	ct->mask_cache_priv |= mask;
-	writel_relaxed(ct->mask_cache_priv, mvebu_gpioreg_edge_mask(mvchip));
+	mvebu_gpio_write_edge_mask(mvchip, ct->mask_cache_priv);
 	irq_gc_unlock(gc);
 }
 
@@ -390,7 +425,7 @@ static void mvebu_gpio_level_irq_mask(st
 
 	irq_gc_lock(gc);
 	ct->mask_cache_priv &= ~mask;
-	writel_relaxed(ct->mask_cache_priv, mvebu_gpioreg_level_mask(mvchip));
+	mvebu_gpio_write_level_mask(mvchip, ct->mask_cache_priv);
 	irq_gc_unlock(gc);
 }
 
@@ -403,7 +438,7 @@ static void mvebu_gpio_level_irq_unmask(
 
 	irq_gc_lock(gc);
 	ct->mask_cache_priv |= mask;
-	writel_relaxed(ct->mask_cache_priv, mvebu_gpioreg_level_mask(mvchip));
+	mvebu_gpio_write_level_mask(mvchip, ct->mask_cache_priv);
 	irq_gc_unlock(gc);
 }
 
@@ -443,8 +478,8 @@ static int mvebu_gpio_irq_set_type(struc
 
 	pin = d->hwirq;
 
-	u = readl_relaxed(mvebu_gpioreg_io_conf(mvchip)) & BIT(pin);
-	if (!u)
+	regmap_read(mvchip->regs, GPIO_IO_CONF_OFF, &u);
+	if ((u & BIT(pin)) == 0)
 		return -EINVAL;
 
 	type &= IRQ_TYPE_SENSE_MASK;
@@ -462,31 +497,30 @@ static int mvebu_gpio_irq_set_type(struc
 	switch (type) {
 	case IRQ_TYPE_EDGE_RISING:
 	case IRQ_TYPE_LEVEL_HIGH:
-		u = readl_relaxed(mvebu_gpioreg_in_pol(mvchip));
-		u &= ~BIT(pin);
-		writel_relaxed(u, mvebu_gpioreg_in_pol(mvchip));
+		regmap_update_bits(mvchip->regs, GPIO_IN_POL_OFF,
+				   BIT(pin), 0);
 		break;
 	case IRQ_TYPE_EDGE_FALLING:
 	case IRQ_TYPE_LEVEL_LOW:
-		u = readl_relaxed(mvebu_gpioreg_in_pol(mvchip));
-		u |= BIT(pin);
-		writel_relaxed(u, mvebu_gpioreg_in_pol(mvchip));
+		regmap_update_bits(mvchip->regs, GPIO_IN_POL_OFF,
+				   BIT(pin), 1);
 		break;
 	case IRQ_TYPE_EDGE_BOTH: {
-		u32 v;
+		u32 data_in, in_pol, val;
 
-		v = readl_relaxed(mvebu_gpioreg_in_pol(mvchip)) ^
-			readl_relaxed(mvebu_gpioreg_data_in(mvchip));
+		regmap_read(mvchip->regs, GPIO_IN_POL_OFF, &in_pol);
+		regmap_read(mvchip->regs, GPIO_DATA_IN_OFF, &data_in);
 
 		/*
 		 * set initial polarity based on current input level
 		 */
-		u = readl_relaxed(mvebu_gpioreg_in_pol(mvchip));
-		if (v & BIT(pin))
-			u |= BIT(pin);		/* falling */
+		if ((data_in ^ in_pol) & BIT(pin))
+			val = BIT(pin); /* falling */
 		else
-			u &= ~BIT(pin);		/* rising */
-		writel_relaxed(u, mvebu_gpioreg_in_pol(mvchip));
+			val = 0; /* raising */
+
+		regmap_update_bits(mvchip->regs, GPIO_IN_POL_OFF,
+				   BIT(pin), val);
 		break;
 	}
 	}
@@ -497,7 +531,7 @@ static void mvebu_gpio_irq_handler(struc
 {
 	struct mvebu_gpio_chip *mvchip = irq_desc_get_handler_data(desc);
 	struct irq_chip *chip = irq_desc_get_chip(desc);
-	u32 cause, type;
+	u32 cause, type, data_in, level_mask, edge_cause, edge_mask;
 	int i;
 
 	if (mvchip == NULL)
@@ -505,10 +539,12 @@ static void mvebu_gpio_irq_handler(struc
 
 	chained_irq_enter(chip, desc);
 
-	cause = readl_relaxed(mvebu_gpioreg_data_in(mvchip)) &
-		readl_relaxed(mvebu_gpioreg_level_mask(mvchip));
-	cause |= readl_relaxed(mvebu_gpioreg_edge_cause(mvchip)) &
-		readl_relaxed(mvebu_gpioreg_edge_mask(mvchip));
+	regmap_read(mvchip->regs, GPIO_DATA_IN_OFF, &data_in);
+	level_mask = mvebu_gpio_read_level_mask(mvchip);
+	edge_cause = mvebu_gpio_read_edge_cause(mvchip);
+	edge_mask  = mvebu_gpio_read_edge_mask(mvchip);
+
+	cause = (data_in ^ level_mask) | (edge_cause & edge_mask);
 
 	for (i = 0; i < mvchip->chip.ngpio; i++) {
 		int irq;
@@ -523,9 +559,9 @@ static void mvebu_gpio_irq_handler(struc
 			/* Swap polarity (race with GPIO line) */
 			u32 polarity;
 
-			polarity = readl_relaxed(mvebu_gpioreg_in_pol(mvchip));
+			regmap_read(mvchip->regs, GPIO_IN_POL_OFF, &polarity);
 			polarity ^= BIT(i);
-			writel_relaxed(polarity, mvebu_gpioreg_in_pol(mvchip));
+			regmap_write(mvchip->regs, GPIO_IN_POL_OFF, polarity);
 		}
 
 		generic_handle_irq(irq);
@@ -628,7 +664,7 @@ static void mvebu_pwm_get_state(struct p
 			state->period = 1;
 	}
 
-	u = readl_relaxed(mvebu_gpioreg_blink(mvchip));
+	regmap_read(mvchip->regs, GPIO_BLINK_EN_OFF, &u);
 	if (u)
 		state->enabled = true;
 	else
@@ -691,8 +727,8 @@ static void __maybe_unused mvebu_pwm_sus
 {
 	struct mvebu_pwm *mvpwm = mvchip->mvpwm;
 
-	mvpwm->blink_select =
-		readl_relaxed(mvebu_gpioreg_blink_counter_select(mvchip));
+	regmap_read(mvchip->regs, GPIO_BLINK_CNT_SELECT_OFF,
+		    &mvpwm->blink_select);
 	mvpwm->blink_on_duration =
 		readl_relaxed(mvebu_pwmreg_blink_on_duration(mvpwm));
 	mvpwm->blink_off_duration =
@@ -703,8 +739,8 @@ static void __maybe_unused mvebu_pwm_res
 {
 	struct mvebu_pwm *mvpwm = mvchip->mvpwm;
 
-	writel_relaxed(mvpwm->blink_select,
-		       mvebu_gpioreg_blink_counter_select(mvchip));
+	regmap_write(mvchip->regs, GPIO_BLINK_CNT_SELECT_OFF,
+		     mvpwm->blink_select);
 	writel_relaxed(mvpwm->blink_on_duration,
 		       mvebu_pwmreg_blink_on_duration(mvpwm));
 	writel_relaxed(mvpwm->blink_off_duration,
@@ -747,7 +783,7 @@ static int mvebu_pwm_probe(struct platfo
 		set = U32_MAX;
 	else
 		return -EINVAL;
-	writel_relaxed(set, mvebu_gpioreg_blink_counter_select(mvchip));
+	regmap_write(mvchip->regs, GPIO_BLINK_CNT_SELECT_OFF, set);
 
 	mvpwm = devm_kzalloc(dev, sizeof(struct mvebu_pwm), GFP_KERNEL);
 	if (!mvpwm)
@@ -790,14 +826,14 @@ static void mvebu_gpio_dbg_show(struct s
 	u32 out, io_conf, blink, in_pol, data_in, cause, edg_msk, lvl_msk;
 	int i;
 
-	out	= readl_relaxed(mvebu_gpioreg_out(mvchip));
-	io_conf	= readl_relaxed(mvebu_gpioreg_io_conf(mvchip));
-	blink	= readl_relaxed(mvebu_gpioreg_blink(mvchip));
-	in_pol	= readl_relaxed(mvebu_gpioreg_in_pol(mvchip));
-	data_in	= readl_relaxed(mvebu_gpioreg_data_in(mvchip));
-	cause	= readl_relaxed(mvebu_gpioreg_edge_cause(mvchip));
-	edg_msk	= readl_relaxed(mvebu_gpioreg_edge_mask(mvchip));
-	lvl_msk	= readl_relaxed(mvebu_gpioreg_level_mask(mvchip));
+	regmap_read(mvchip->regs, GPIO_OUT_OFF, &out);
+	regmap_read(mvchip->regs, GPIO_IO_CONF_OFF, &io_conf);
+	regmap_read(mvchip->regs, GPIO_BLINK_EN_OFF, &blink);
+	regmap_read(mvchip->regs, GPIO_IN_POL_OFF, &in_pol);
+	regmap_read(mvchip->regs, GPIO_DATA_IN_OFF, &data_in);
+	cause	= mvebu_gpio_read_edge_cause(mvchip);
+	edg_msk	= mvebu_gpio_read_edge_mask(mvchip);
+	lvl_msk	= mvebu_gpio_read_level_mask(mvchip);
 
 	for (i = 0; i < chip->ngpio; i++) {
 		const char *label;
@@ -865,36 +901,36 @@ static int mvebu_gpio_suspend(struct pla
 	struct mvebu_gpio_chip *mvchip = platform_get_drvdata(pdev);
 	int i;
 
-	mvchip->out_reg = readl(mvebu_gpioreg_out(mvchip));
-	mvchip->io_conf_reg = readl(mvebu_gpioreg_io_conf(mvchip));
-	mvchip->blink_en_reg = readl(mvebu_gpioreg_blink(mvchip));
-	mvchip->in_pol_reg = readl(mvebu_gpioreg_in_pol(mvchip));
+	regmap_read(mvchip->regs, GPIO_OUT_OFF, &mvchip->out_reg);
+	regmap_read(mvchip->regs, GPIO_IO_CONF_OFF, &mvchip->io_conf_reg);
+	regmap_read(mvchip->regs, GPIO_BLINK_EN_OFF, &mvchip->blink_en_reg);
+	regmap_read(mvchip->regs, GPIO_IN_POL_OFF, &mvchip->in_pol_reg);
 
 	switch (mvchip->soc_variant) {
 	case MVEBU_GPIO_SOC_VARIANT_ORION:
-		mvchip->edge_mask_regs[0] =
-			readl(mvchip->membase + GPIO_EDGE_MASK_OFF);
-		mvchip->level_mask_regs[0] =
-			readl(mvchip->membase + GPIO_LEVEL_MASK_OFF);
+		regmap_read(mvchip->regs, GPIO_EDGE_MASK_OFF,
+			    &mvchip->edge_mask_regs[0]);
+		regmap_read(mvchip->regs, GPIO_LEVEL_MASK_OFF,
+			    &mvchip->level_mask_regs[0]);
 		break;
 	case MVEBU_GPIO_SOC_VARIANT_MV78200:
 		for (i = 0; i < 2; i++) {
-			mvchip->edge_mask_regs[i] =
-				readl(mvchip->membase +
-				      GPIO_EDGE_MASK_MV78200_OFF(i));
-			mvchip->level_mask_regs[i] =
-				readl(mvchip->membase +
-				      GPIO_LEVEL_MASK_MV78200_OFF(i));
+			regmap_read(mvchip->regs,
+				    GPIO_EDGE_MASK_MV78200_OFF(i),
+				    &mvchip->edge_mask_regs[i]);
+			regmap_read(mvchip->regs,
+				    GPIO_LEVEL_MASK_MV78200_OFF(i),
+				    &mvchip->level_mask_regs[i]);
 		}
 		break;
 	case MVEBU_GPIO_SOC_VARIANT_ARMADAXP:
 		for (i = 0; i < 4; i++) {
-			mvchip->edge_mask_regs[i] =
-				readl(mvchip->membase +
-				      GPIO_EDGE_MASK_ARMADAXP_OFF(i));
-			mvchip->level_mask_regs[i] =
-				readl(mvchip->membase +
-				      GPIO_LEVEL_MASK_ARMADAXP_OFF(i));
+			regmap_read(mvchip->regs,
+				    GPIO_EDGE_MASK_ARMADAXP_OFF(i),
+				    &mvchip->edge_mask_regs[i]);
+			regmap_read(mvchip->regs,
+				    GPIO_LEVEL_MASK_ARMADAXP_OFF(i),
+				    &mvchip->level_mask_regs[i]);
 		}
 		break;
 	default:
@@ -912,35 +948,36 @@ static int mvebu_gpio_resume(struct plat
 	struct mvebu_gpio_chip *mvchip = platform_get_drvdata(pdev);
 	int i;
 
-	writel(mvchip->out_reg, mvebu_gpioreg_out(mvchip));
-	writel(mvchip->io_conf_reg, mvebu_gpioreg_io_conf(mvchip));
-	writel(mvchip->blink_en_reg, mvebu_gpioreg_blink(mvchip));
-	writel(mvchip->in_pol_reg, mvebu_gpioreg_in_pol(mvchip));
+	regmap_write(mvchip->regs, GPIO_OUT_OFF, mvchip->out_reg);
+	regmap_write(mvchip->regs, GPIO_IO_CONF_OFF, mvchip->io_conf_reg);
+	regmap_write(mvchip->regs, GPIO_BLINK_EN_OFF, mvchip->blink_en_reg);
+	regmap_write(mvchip->regs, GPIO_IN_POL_OFF, mvchip->in_pol_reg);
 
 	switch (mvchip->soc_variant) {
 	case MVEBU_GPIO_SOC_VARIANT_ORION:
-		writel(mvchip->edge_mask_regs[0],
-		       mvchip->membase + GPIO_EDGE_MASK_OFF);
-		writel(mvchip->level_mask_regs[0],
-		       mvchip->membase + GPIO_LEVEL_MASK_OFF);
+		regmap_write(mvchip->regs, GPIO_EDGE_MASK_OFF,
+			     mvchip->edge_mask_regs[0]);
+		regmap_write(mvchip->regs, GPIO_LEVEL_MASK_OFF,
+			     mvchip->level_mask_regs[0]);
 		break;
 	case MVEBU_GPIO_SOC_VARIANT_MV78200:
 		for (i = 0; i < 2; i++) {
-			writel(mvchip->edge_mask_regs[i],
-			       mvchip->membase + GPIO_EDGE_MASK_MV78200_OFF(i));
-			writel(mvchip->level_mask_regs[i],
-			       mvchip->membase +
-			       GPIO_LEVEL_MASK_MV78200_OFF(i));
+			regmap_write(mvchip->regs,
+				     GPIO_EDGE_MASK_MV78200_OFF(i),
+				     mvchip->edge_mask_regs[i]);
+			regmap_write(mvchip->regs,
+				     GPIO_LEVEL_MASK_MV78200_OFF(i),
+				     mvchip->level_mask_regs[i]);
 		}
 		break;
 	case MVEBU_GPIO_SOC_VARIANT_ARMADAXP:
 		for (i = 0; i < 4; i++) {
-			writel(mvchip->edge_mask_regs[i],
-			       mvchip->membase +
-			       GPIO_EDGE_MASK_ARMADAXP_OFF(i));
-			writel(mvchip->level_mask_regs[i],
-			       mvchip->membase +
-			       GPIO_LEVEL_MASK_ARMADAXP_OFF(i));
+			regmap_write(mvchip->regs,
+				     GPIO_EDGE_MASK_ARMADAXP_OFF(i),
+				     mvchip->edge_mask_regs[i]);
+			regmap_write(mvchip->regs,
+				     GPIO_LEVEL_MASK_ARMADAXP_OFF(i),
+				     mvchip->level_mask_regs[i]);
 		}
 		break;
 	default:
@@ -953,6 +990,13 @@ static int mvebu_gpio_resume(struct plat
 	return 0;
 }
 
+static const struct regmap_config mvebu_gpio_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.fast_io = true,
+};
+
 static int mvebu_gpio_probe(struct platform_device *pdev)
 {
 	struct mvebu_gpio_chip *mvchip;
@@ -961,6 +1005,7 @@ static int mvebu_gpio_probe(struct platf
 	struct resource *res;
 	struct irq_chip_generic *gc;
 	struct irq_chip_type *ct;
+	void __iomem *base;
 	unsigned int ngpios;
 	bool have_irqs;
 	int soc_variant;
@@ -1016,11 +1061,15 @@ static int mvebu_gpio_probe(struct platf
 	mvchip->chip.of_node = np;
 	mvchip->chip.dbg_show = mvebu_gpio_dbg_show;
 
-	spin_lock_init(&mvchip->lock);
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	mvchip->membase = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(mvchip->membase))
-		return PTR_ERR(mvchip->membase);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	mvchip->regs = devm_regmap_init_mmio(&pdev->dev, base,
+					     &mvebu_gpio_regmap_config);
+	if (IS_ERR(mvchip->regs))
+		return PTR_ERR(mvchip->regs);
 
 	/*
 	 * The Armada XP has a second range of registers for the
@@ -1028,10 +1077,15 @@ static int mvebu_gpio_probe(struct platf
 	 */
 	if (soc_variant == MVEBU_GPIO_SOC_VARIANT_ARMADAXP) {
 		res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-		mvchip->percpu_membase = devm_ioremap_resource(&pdev->dev,
-							       res);
-		if (IS_ERR(mvchip->percpu_membase))
-			return PTR_ERR(mvchip->percpu_membase);
+		base = devm_ioremap_resource(&pdev->dev, res);
+		if (IS_ERR(base))
+			return PTR_ERR(base);
+
+		mvchip->percpu_regs =
+			devm_regmap_init_mmio(&pdev->dev, base,
+					      &mvebu_gpio_regmap_config);
+		if (IS_ERR(mvchip->percpu_regs))
+			return PTR_ERR(mvchip->percpu_regs);
 	}
 
 	/*
@@ -1039,30 +1093,30 @@ static int mvebu_gpio_probe(struct platf
 	 */
 	switch (soc_variant) {
 	case MVEBU_GPIO_SOC_VARIANT_ORION:
-		writel_relaxed(0, mvchip->membase + GPIO_EDGE_CAUSE_OFF);
-		writel_relaxed(0, mvchip->membase + GPIO_EDGE_MASK_OFF);
-		writel_relaxed(0, mvchip->membase + GPIO_LEVEL_MASK_OFF);
+		regmap_write(mvchip->regs, GPIO_EDGE_CAUSE_OFF, 0);
+		regmap_write(mvchip->regs, GPIO_EDGE_MASK_OFF, 0);
+		regmap_write(mvchip->regs, GPIO_LEVEL_MASK_OFF, 0);
 		break;
 	case MVEBU_GPIO_SOC_VARIANT_MV78200:
-		writel_relaxed(0, mvchip->membase + GPIO_EDGE_CAUSE_OFF);
+		regmap_write(mvchip->regs, GPIO_EDGE_CAUSE_OFF, 0);
 		for (cpu = 0; cpu < 2; cpu++) {
-			writel_relaxed(0, mvchip->membase +
-				       GPIO_EDGE_MASK_MV78200_OFF(cpu));
-			writel_relaxed(0, mvchip->membase +
-				       GPIO_LEVEL_MASK_MV78200_OFF(cpu));
+			regmap_write(mvchip->regs,
+				     GPIO_EDGE_MASK_MV78200_OFF(cpu), 0);
+			regmap_write(mvchip->regs,
+				     GPIO_LEVEL_MASK_MV78200_OFF(cpu), 0);
 		}
 		break;
 	case MVEBU_GPIO_SOC_VARIANT_ARMADAXP:
-		writel_relaxed(0, mvchip->membase + GPIO_EDGE_CAUSE_OFF);
-		writel_relaxed(0, mvchip->membase + GPIO_EDGE_MASK_OFF);
-		writel_relaxed(0, mvchip->membase + GPIO_LEVEL_MASK_OFF);
+		regmap_write(mvchip->regs, GPIO_EDGE_CAUSE_OFF, 0);
+		regmap_write(mvchip->regs, GPIO_EDGE_MASK_OFF, 0);
+		regmap_write(mvchip->regs, GPIO_LEVEL_MASK_OFF, 0);
 		for (cpu = 0; cpu < 4; cpu++) {
-			writel_relaxed(0, mvchip->percpu_membase +
-				       GPIO_EDGE_CAUSE_ARMADAXP_OFF(cpu));
-			writel_relaxed(0, mvchip->percpu_membase +
-				       GPIO_EDGE_MASK_ARMADAXP_OFF(cpu));
-			writel_relaxed(0, mvchip->percpu_membase +
-				       GPIO_LEVEL_MASK_ARMADAXP_OFF(cpu));
+			regmap_write(mvchip->percpu_regs,
+				     GPIO_EDGE_CAUSE_ARMADAXP_OFF(cpu), 0);
+			regmap_write(mvchip->percpu_regs,
+				     GPIO_EDGE_MASK_ARMADAXP_OFF(cpu), 0);
+			regmap_write(mvchip->percpu_regs,
+				     GPIO_LEVEL_MASK_ARMADAXP_OFF(cpu), 0);
 		}
 		break;
 	default:
