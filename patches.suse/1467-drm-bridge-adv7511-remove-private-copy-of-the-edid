From: Lars-Peter Clausen <lars@metafoo.de>
Date: Tue, 5 Sep 2017 14:10:16 +0200
Subject: drm/bridge: adv7511: Remove private copy of the EDID
Git-commit: fcb4c5eee79ea17e1fbc5b3ebbd575d56714fabe
Patch-mainline: v4.15-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

The adv7511 driver keeps a private copy of the EDID in its driver state
struct. But this copy is only used in adv7511_get_modes() where it is also
retrieved, so there is no need to keep this extra copy around.

If a need to access the EDID elsewhere in the driver ever arises the copy
that is stored in the connector can be used. This copy is accessible
through drm_connector_get_edid().

Note, this patch removes the NULL check of the EDID before passing it to
drm_detect_hdmi_monitor(), but that is fine since the function correctly
handles the case where the EDID is NULL.

Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
Tested-by: John Stultz <john.stultz@linaro.org>
Signed-off-by: Archit Taneja <architt@codeaurora.org>
Link: https://patchwork.freedesktop.org/patch/msgid/20170905121018.11477-2-lars@metafoo.de

Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/bridge/adv7511/adv7511.h     |    2 --
 drivers/gpu/drm/bridge/adv7511/adv7511_drv.c |   16 ++++++----------
 2 files changed, 6 insertions(+), 12 deletions(-)

--- a/drivers/gpu/drm/bridge/adv7511/adv7511.h
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511.h
@@ -328,8 +328,6 @@ struct adv7511 {
 	enum adv7511_sync_polarity hsync_polarity;
 	bool rgb;
 
-	struct edid *edid;
-
 	struct gpio_desc *gpio_pd;
 
 	struct regulator_bulk_data *supplies;
--- a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
@@ -199,17 +199,14 @@ static const uint16_t adv7511_csc_ycbcr_
 
 static void adv7511_set_config_csc(struct adv7511 *adv7511,
 				   struct drm_connector *connector,
-				   bool rgb)
+				   bool rgb, bool hdmi_mode)
 {
 	struct adv7511_video_config config;
 	bool output_format_422, output_format_ycbcr;
 	unsigned int mode;
 	uint8_t infoframe[17];
 
-	if (adv7511->edid)
-		config.hdmi_mode = drm_detect_hdmi_monitor(adv7511->edid);
-	else
-		config.hdmi_mode = false;
+	config.hdmi_mode = hdmi_mode;
 
 	hdmi_avi_infoframe_init(&config.avi_infoframe);
 
@@ -589,13 +586,14 @@ static int adv7511_get_modes(struct adv7
 	if (!adv7511->powered)
 		__adv7511_power_off(adv7511);
 
-	kfree(adv7511->edid);
-	adv7511->edid = edid;
 
 	drm_mode_connector_update_edid_property(connector, edid);
 	count = drm_add_edid_modes(connector, edid);
 
-	adv7511_set_config_csc(adv7511, connector, adv7511->rgb);
+	adv7511_set_config_csc(adv7511, connector, adv7511->rgb,
+			       drm_detect_hdmi_monitor(edid));
+
+	kfree(edid);
 
 	return count;
 }
@@ -1156,8 +1154,6 @@ static int adv7511_remove(struct i2c_cli
 
 	i2c_unregister_device(adv7511->i2c_edid);
 
-	kfree(adv7511->edid);
-
 	return 0;
 }
 
