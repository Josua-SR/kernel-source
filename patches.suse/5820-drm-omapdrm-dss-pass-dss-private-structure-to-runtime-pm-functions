From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Tue, 13 Feb 2018 14:00:21 +0200
Subject: drm: omapdrm: dss: Pass DSS private structure to runtime PM functions
Git-commit: 7b295257a13d827dac8c71af70e633c7ba722cfe
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

To prepare for the removal of the global variable storing DSS private
data, pass its pointer to the dss_runtime_{get,put}() functions.

As this requires getting hold of the dss_device structure in the
callers, we add a new dss_get_device() function to retrieve it. The
function currently returns a pointer to the global data structure, and
will later be updated to get the pointer from device driver data when
the DSS private structure will be allocated dynamically.

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/omapdrm/dss/dsi.c       |    7 +++-
 drivers/gpu/drm/omapdrm/dss/dss.c       |   47 ++++++++++++++++++--------------
 drivers/gpu/drm/omapdrm/dss/dss.h       |   12 +++++---
 drivers/gpu/drm/omapdrm/dss/hdmi.h      |    6 ++--
 drivers/gpu/drm/omapdrm/dss/hdmi4.c     |    3 +-
 drivers/gpu/drm/omapdrm/dss/hdmi5.c     |    3 +-
 drivers/gpu/drm/omapdrm/dss/hdmi_pll.c  |   10 ++++--
 drivers/gpu/drm/omapdrm/dss/video-pll.c |   12 ++++----
 8 files changed, 61 insertions(+), 39 deletions(-)

--- a/drivers/gpu/drm/omapdrm/dss/dsi.c
+++ b/drivers/gpu/drm/omapdrm/dss/dsi.c
@@ -5322,7 +5322,8 @@ static const struct dss_pll_hw dss_omap5
 	.has_refsel = true,
 };
 
-static int dsi_init_pll_data(struct platform_device *dsidev)
+static int dsi_init_pll_data(struct dss_device *dss,
+			     struct platform_device *dsidev)
 {
 	struct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);
 	struct dss_pll *pll = &dsi->pll;
@@ -5341,6 +5342,7 @@ static int dsi_init_pll_data(struct plat
 	pll->base = dsi->pll_base;
 	pll->hw = dsi->data->pll_hw;
 	pll->ops = &dsi_pll_ops;
+	pll->dss = dss;
 
 	r = dss_pll_register(pll);
 	if (r)
@@ -5417,6 +5419,7 @@ static const struct soc_device_attribute
 static int dsi_bind(struct device *dev, struct device *master, void *data)
 {
 	struct platform_device *dsidev = to_platform_device(dev);
+	struct dss_device *dss = dss_get_device(master);
 	const struct soc_device_attribute *soc;
 	const struct dsi_module_id_data *d;
 	u32 rev;
@@ -5527,7 +5530,7 @@ static int dsi_bind(struct device *dev,
 	if (r)
 		return r;
 
-	dsi_init_pll_data(dsidev);
+	dsi_init_pll_data(dss, dsidev);
 
 	pm_runtime_enable(&dsidev->dev);
 
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -345,7 +345,7 @@ static void dss_dump_clocks(struct seq_f
 	const char *fclk_name;
 	unsigned long fclk_rate;
 
-	if (dss_runtime_get())
+	if (dss_runtime_get(&dss))
 		return;
 
 	seq_printf(s, "- DSS -\n");
@@ -357,7 +357,7 @@ static void dss_dump_clocks(struct seq_f
 			fclk_name,
 			fclk_rate);
 
-	dss_runtime_put();
+	dss_runtime_put(&dss);
 }
 #endif
 
@@ -365,7 +365,7 @@ static void dss_dump_regs(struct seq_fil
 {
 #define DUMPREG(r) seq_printf(s, "%-35s %08x\n", #r, dss_read_reg(r))
 
-	if (dss_runtime_get())
+	if (dss_runtime_get(&dss))
 		return;
 
 	DUMPREG(DSS_REVISION);
@@ -379,7 +379,7 @@ static void dss_dump_regs(struct seq_fil
 		DUMPREG(DSS_SDI_STATUS);
 	}
 
-	dss_runtime_put();
+	dss_runtime_put(&dss);
 #undef DUMPREG
 }
 
@@ -837,27 +837,32 @@ static void dss_put_clocks(void)
 		clk_put(dss.parent_clk);
 }
 
-int dss_runtime_get(void)
+int dss_runtime_get(struct dss_device *dss)
 {
 	int r;
 
 	DSSDBG("dss_runtime_get\n");
 
-	r = pm_runtime_get_sync(&dss.pdev->dev);
+	r = pm_runtime_get_sync(&dss->pdev->dev);
 	WARN_ON(r < 0);
 	return r < 0 ? r : 0;
 }
 
-void dss_runtime_put(void)
+void dss_runtime_put(struct dss_device *dss)
 {
 	int r;
 
 	DSSDBG("dss_runtime_put\n");
 
-	r = pm_runtime_put_sync(&dss.pdev->dev);
+	r = pm_runtime_put_sync(&dss->pdev->dev);
 	WARN_ON(r < 0 && r != -ENOSYS && r != -EBUSY);
 }
 
+struct dss_device *dss_get_device(struct device *dev)
+{
+	return &dss;
+}
+
 /* DEBUGFS */
 #if defined(CONFIG_OMAP2_DSS_DEBUGFS)
 static void dss_debug_dump_clocks(struct seq_file *s)
@@ -1223,13 +1228,15 @@ static int dss_video_pll_probe(struct pl
 	}
 
 	if (of_property_match_string(np, "reg-names", "pll1") >= 0) {
-		dss.video1_pll = dss_video_pll_init(pdev, 0, pll_regulator);
+		dss.video1_pll = dss_video_pll_init(&dss, pdev, 0,
+						    pll_regulator);
 		if (IS_ERR(dss.video1_pll))
 			return PTR_ERR(dss.video1_pll);
 	}
 
 	if (of_property_match_string(np, "reg-names", "pll2") >= 0) {
-		dss.video2_pll = dss_video_pll_init(pdev, 1, pll_regulator);
+		dss.video2_pll = dss_video_pll_init(&dss, pdev, 1,
+						    pll_regulator);
 		if (IS_ERR(dss.video2_pll)) {
 			dss_video_pll_uninit(dss.video1_pll);
 			return PTR_ERR(dss.video2_pll);
@@ -1311,16 +1318,16 @@ static int dss_add_child_component(struc
 	return 0;
 }
 
-static int dss_probe_hardware(void)
+static int dss_probe_hardware(struct dss_device *dss)
 {
 	u32 rev;
 	int r;
 
-	r = dss_runtime_get();
+	r = dss_runtime_get(dss);
 	if (r)
 		return r;
 
-	dss.dss_clk_rate = clk_get_rate(dss.dss_clk);
+	dss->dss_clk_rate = clk_get_rate(dss->dss_clk);
 
 	/* Select DPLL */
 	REG_FLD_MOD(DSS_CONTROL, 0, 0, 0);
@@ -1332,16 +1339,16 @@ static int dss_probe_hardware(void)
 	REG_FLD_MOD(DSS_CONTROL, 1, 3, 3);	/* venc clock 4x enable */
 	REG_FLD_MOD(DSS_CONTROL, 0, 2, 2);	/* venc clock mode = normal */
 #endif
-	dss.dsi_clk_source[0] = DSS_CLK_SRC_FCK;
-	dss.dsi_clk_source[1] = DSS_CLK_SRC_FCK;
-	dss.dispc_clk_source = DSS_CLK_SRC_FCK;
-	dss.lcd_clk_source[0] = DSS_CLK_SRC_FCK;
-	dss.lcd_clk_source[1] = DSS_CLK_SRC_FCK;
+	dss->dsi_clk_source[0] = DSS_CLK_SRC_FCK;
+	dss->dsi_clk_source[1] = DSS_CLK_SRC_FCK;
+	dss->dispc_clk_source = DSS_CLK_SRC_FCK;
+	dss->lcd_clk_source[0] = DSS_CLK_SRC_FCK;
+	dss->lcd_clk_source[1] = DSS_CLK_SRC_FCK;
 
 	rev = dss_read_reg(DSS_REVISION);
 	pr_info("OMAP DSS rev %d.%d\n", FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));
 
-	dss_runtime_put();
+	dss_runtime_put(dss);
 
 	return 0;
 }
@@ -1397,7 +1404,7 @@ static int dss_probe(struct platform_dev
 	/* Enable runtime PM and probe the hardware. */
 	pm_runtime_enable(&pdev->dev);
 
-	r = dss_probe_hardware();
+	r = dss_probe_hardware(&dss);
 	if (r)
 		goto err_pm_runtime_disable;
 
--- a/drivers/gpu/drm/omapdrm/dss/dss.h
+++ b/drivers/gpu/drm/omapdrm/dss/dss.h
@@ -191,6 +191,7 @@ struct dss_pll_hw {
 struct dss_pll {
 	const char *name;
 	enum dss_pll_id id;
+	struct dss_device *dss;
 
 	struct clk *clkin;
 	struct regulator *regulator;
@@ -291,8 +292,10 @@ static inline int dss_debugfs_create_fil
 }
 #endif /* CONFIG_OMAP2_DSS_DEBUGFS */
 
-int dss_runtime_get(void);
-void dss_runtime_put(void);
+struct dss_device *dss_get_device(struct device *dev);
+
+int dss_runtime_get(struct dss_device *dss);
+void dss_runtime_put(struct dss_device *dss);
 
 unsigned long dss_get_dispc_clk_rate(void);
 unsigned long dss_get_max_fck_rate(void);
@@ -302,8 +305,9 @@ void dss_select_hdmi_venc_clk_source(enu
 const char *dss_get_clk_source_name(enum dss_clk_source clk_src);
 
 /* DSS VIDEO PLL */
-struct dss_pll *dss_video_pll_init(struct platform_device *pdev, int id,
-	struct regulator *regulator);
+struct dss_pll *dss_video_pll_init(struct dss_device *dss,
+				   struct platform_device *pdev, int id,
+				   struct regulator *regulator);
 void dss_video_pll_uninit(struct dss_pll *pll);
 
 void dss_ctrl_pll_enable(enum dss_pll_id pll_id, bool enable);
--- a/drivers/gpu/drm/omapdrm/dss/hdmi.h
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi.h
@@ -29,6 +29,8 @@
 #include "omapdss.h"
 #include "dss.h"
 
+struct dss_device;
+
 /* HDMI Wrapper */
 
 #define HDMI_WP_REVISION			0x0
@@ -324,8 +326,8 @@ phys_addr_t hdmi_wp_get_audio_dma_addr(s
 
 /* HDMI PLL funcs */
 void hdmi_pll_dump(struct hdmi_pll_data *pll, struct seq_file *s);
-int hdmi_pll_init(struct platform_device *pdev, struct hdmi_pll_data *pll,
-	struct hdmi_wp_data *wp);
+int hdmi_pll_init(struct dss_device *dss, struct platform_device *pdev,
+		  struct hdmi_pll_data *pll, struct hdmi_wp_data *wp);
 void hdmi_pll_uninit(struct hdmi_pll_data *hpll);
 
 /* HDMI PHY funcs */
--- a/drivers/gpu/drm/omapdrm/dss/hdmi4.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi4.c
@@ -717,6 +717,7 @@ static int hdmi_audio_register(struct de
 static int hdmi4_bind(struct device *dev, struct device *master, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
+	struct dss_device *dss = dss_get_device(master);
 	int r;
 	int irq;
 
@@ -734,7 +735,7 @@ static int hdmi4_bind(struct device *dev
 	if (r)
 		return r;
 
-	r = hdmi_pll_init(pdev, &hdmi.pll, &hdmi.wp);
+	r = hdmi_pll_init(dss, pdev, &hdmi.pll, &hdmi.wp);
 	if (r)
 		return r;
 
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -718,6 +718,7 @@ static int hdmi_audio_register(struct de
 static int hdmi5_bind(struct device *dev, struct device *master, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
+	struct dss_device *dss = dss_get_device(master);
 	int r;
 	int irq;
 
@@ -735,7 +736,7 @@ static int hdmi5_bind(struct device *dev
 	if (r)
 		return r;
 
-	r = hdmi_pll_init(pdev, &hdmi.pll, &hdmi.wp);
+	r = hdmi_pll_init(dss, pdev, &hdmi.pll, &hdmi.wp);
 	if (r)
 		return r;
 
--- a/drivers/gpu/drm/omapdrm/dss/hdmi_pll.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi_pll.c
@@ -128,7 +128,8 @@ static const struct dss_pll_hw dss_omap5
 	.has_refsel = true,
 };
 
-static int hdmi_init_pll_data(struct platform_device *pdev,
+static int hdmi_init_pll_data(struct dss_device *dss,
+			      struct platform_device *pdev,
 			      struct hdmi_pll_data *hpll)
 {
 	struct dss_pll *pll = &hpll->pll;
@@ -145,6 +146,7 @@ static int hdmi_init_pll_data(struct pla
 	pll->id = DSS_PLL_HDMI;
 	pll->base = hpll->base;
 	pll->clkin = clk;
+	pll->dss = dss;
 
 	if (hpll->wp->version == 4)
 		pll->hw = &dss_omap4_hdmi_pll_hw;
@@ -160,8 +162,8 @@ static int hdmi_init_pll_data(struct pla
 	return 0;
 }
 
-int hdmi_pll_init(struct platform_device *pdev, struct hdmi_pll_data *pll,
-	struct hdmi_wp_data *wp)
+int hdmi_pll_init(struct dss_device *dss, struct platform_device *pdev,
+		  struct hdmi_pll_data *pll, struct hdmi_wp_data *wp)
 {
 	int r;
 	struct resource *res;
@@ -174,7 +176,7 @@ int hdmi_pll_init(struct platform_device
 	if (IS_ERR(pll->base))
 		return PTR_ERR(pll->base);
 
-	r = hdmi_init_pll_data(pdev, pll);
+	r = hdmi_init_pll_data(dss, pdev, pll);
 	if (r) {
 		DSSERR("failed to init HDMI PLL\n");
 		return r;
--- a/drivers/gpu/drm/omapdrm/dss/video-pll.c
+++ b/drivers/gpu/drm/omapdrm/dss/video-pll.c
@@ -64,7 +64,7 @@ static int dss_video_pll_enable(struct d
 	struct dss_video_pll *vpll = container_of(pll, struct dss_video_pll, pll);
 	int r;
 
-	r = dss_runtime_get();
+	r = dss_runtime_get(pll->dss);
 	if (r)
 		return r;
 
@@ -83,7 +83,7 @@ static int dss_video_pll_enable(struct d
 err_reset:
 	dss_dpll_disable_scp_clk(vpll);
 	dss_ctrl_pll_enable(pll->id, false);
-	dss_runtime_put();
+	dss_runtime_put(pll->dss);
 
 	return r;
 }
@@ -98,7 +98,7 @@ static void dss_video_pll_disable(struct
 
 	dss_ctrl_pll_enable(pll->id, false);
 
-	dss_runtime_put();
+	dss_runtime_put(pll->dss);
 }
 
 static const struct dss_pll_ops dss_pll_ops = {
@@ -136,8 +136,9 @@ static const struct dss_pll_hw dss_dra7_
 	.errata_i886 = true,
 };
 
-struct dss_pll *dss_video_pll_init(struct platform_device *pdev, int id,
-	struct regulator *regulator)
+struct dss_pll *dss_video_pll_init(struct dss_device *dss,
+				   struct platform_device *pdev, int id,
+				   struct regulator *regulator)
 {
 	const char * const reg_name[] = { "pll1", "pll2" };
 	const char * const clkctrl_name[] = { "pll1_clkctrl", "pll2_clkctrl" };
@@ -189,6 +190,7 @@ struct dss_pll *dss_video_pll_init(struc
 	pll->base = pll_base;
 	pll->hw = &dss_dra7_video_pll_hw;
 	pll->ops = &dss_pll_ops;
+	pll->dss = dss;
 
 	r = dss_pll_register(pll);
 	if (r)
