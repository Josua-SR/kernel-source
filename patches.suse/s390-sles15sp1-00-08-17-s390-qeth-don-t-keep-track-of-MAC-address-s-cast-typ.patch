From: Julian Wiedmann <jwi@linux.ibm.com>
Subject: s390/qeth: don't keep track of MAC address's cast type
Patch-mainline: v4.16-rc1
Git-commit: 4641b027f7c32ea51db3acd6dcf97435c2385970
References: FATE#326350, LTC#169511, bsc#1113509

Summary:     qeth: performance improvements
Description: This adds recent functional and performance improvements for the
             qeth network driver.
             Primarily this brings Scatter-Gather support for HiperSockets,
             reduced CPU consumption in the L3 IPv4 transmit path for OSA,
             improved Promiscuous Mode performance due to IFF_UNICAST_FLT,
             support for Scatter-Gather on z/VM virtual NICs, and
             support for delayed GRO flushing.

             For sanity & stability reasons, this effectively constitutes a
             backport of the qeth device driver from 4.19 mainline.
             

Upstream-Description:

             s390/qeth: don't keep track of MAC address's cast type

             Instead of tracking the uc/mc state in each MAC address object, just
             check the multicast bit in the address itself.

             Signed-off-by: Julian Wiedmann <jwi@linux.vnet.ibm.com>
             Signed-off-by: David S. Miller <davem@davemloft.net>

Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/s390/net/qeth_l2.h      |    1 -
 drivers/s390/net/qeth_l2_main.c |   27 ++++++++-------------------
 2 files changed, 8 insertions(+), 20 deletions(-)

--- a/drivers/s390/net/qeth_l2.h
+++ b/drivers/s390/net/qeth_l2.h
@@ -22,7 +22,6 @@ bool qeth_l2_vnicc_is_in_use(struct qeth
 
 struct qeth_mac {
 	u8 mac_addr[OSA_ADDR_LEN];
-	u8 is_uc:1;
 	u8 disp_flag:2;
 	struct hlist_node hnode;
 };
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@ -169,22 +169,16 @@ static int qeth_l2_send_delgroupmac(stru
 
 static int qeth_l2_write_mac(struct qeth_card *card, struct qeth_mac *mac)
 {
-	if (mac->is_uc) {
-		return qeth_l2_send_setdelmac(card, mac->mac_addr,
-						IPA_CMD_SETVMAC);
-	} else {
+	if (is_multicast_ether_addr_64bits(mac->mac_addr))
 		return qeth_l2_send_setgroupmac(card, mac->mac_addr);
-	}
+	return qeth_l2_send_setdelmac(card, mac->mac_addr, IPA_CMD_SETVMAC);
 }
 
 static int qeth_l2_remove_mac(struct qeth_card *card, struct qeth_mac *mac)
 {
-	if (mac->is_uc) {
-		return qeth_l2_send_setdelmac(card, mac->mac_addr,
-						IPA_CMD_DELVMAC);
-	} else {
+	if (is_multicast_ether_addr_64bits(mac->mac_addr))
 		return qeth_l2_send_delgroupmac(card, mac->mac_addr);
-	}
+	return qeth_l2_send_setdelmac(card, mac->mac_addr, IPA_CMD_DELVMAC);
 }
 
 static void qeth_l2_del_all_macs(struct qeth_card *card)
@@ -609,27 +603,23 @@ static void qeth_promisc_to_bridge(struc
  * only if there is not in the hash table storage already
  *
 */
-static void qeth_l2_add_mac(struct qeth_card *card, struct netdev_hw_addr *ha,
-			    u8 is_uc)
+static void qeth_l2_add_mac(struct qeth_card *card, struct netdev_hw_addr *ha)
 {
 	u32 mac_hash = get_unaligned((u32 *)(&ha->addr[2]));
 	struct qeth_mac *mac;
 
 	hash_for_each_possible(card->mac_htable, mac, hnode, mac_hash) {
-		if (is_uc == mac->is_uc &&
-		    !memcmp(ha->addr, mac->mac_addr, OSA_ADDR_LEN)) {
+		if (!memcmp(ha->addr, mac->mac_addr, OSA_ADDR_LEN)) {
 			mac->disp_flag = QETH_DISP_ADDR_DO_NOTHING;
 			return;
 		}
 	}
 
 	mac = kzalloc(sizeof(struct qeth_mac), GFP_ATOMIC);
-
 	if (!mac)
 		return;
 
 	memcpy(mac->mac_addr, ha->addr, OSA_ADDR_LEN);
-	mac->is_uc = is_uc;
 	mac->disp_flag = QETH_DISP_ADDR_ADD;
 
 	hash_add(card->mac_htable, &mac->hnode, mac_hash);
@@ -655,10 +645,9 @@ static void qeth_l2_set_rx_mode(struct n
 	spin_lock_bh(&card->mclock);
 
 	netdev_for_each_mc_addr(ha, dev)
-		qeth_l2_add_mac(card, ha, 0);
-
+		qeth_l2_add_mac(card, ha);
 	netdev_for_each_uc_addr(ha, dev)
-		qeth_l2_add_mac(card, ha, 1);
+		qeth_l2_add_mac(card, ha);
 
 	hash_for_each_safe(card->mac_htable, i, tmp, mac, hnode) {
 		if (mac->disp_flag == QETH_DISP_ADDR_DELETE) {
