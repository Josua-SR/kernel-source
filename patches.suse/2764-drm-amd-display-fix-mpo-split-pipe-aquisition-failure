From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Tue, 30 May 2017 13:38:10 -0400
Subject: drm/amd/display: fix mpo + split pipe aquisition failure
Git-commit: 0f9a536fe036eed82b563b0da5b2c57a9455b679
Patch-mainline: v4.15-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Acked-by: Harry Wentland <Harry.Wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/amd/display/dc/core/dc_resource.c |   80 ++++++++++++----------
 1 file changed, 44 insertions(+), 36 deletions(-)

--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -995,6 +995,43 @@ static void release_free_pipes_for_strea
 	}
 }
 
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+static int acquire_first_split_pipe(
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
+		struct core_stream *stream)
+{
+	int i;
+
+	for (i = 0; i < pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
+
+		if (pipe_ctx->top_pipe &&
+				pipe_ctx->top_pipe->surface == pipe_ctx->surface) {
+			int mpc_idx = pipe_ctx->mpc_idx;
+
+			pipe_ctx->top_pipe->bottom_pipe = pipe_ctx->bottom_pipe;
+			if (pipe_ctx->bottom_pipe)
+				pipe_ctx->bottom_pipe->top_pipe = pipe_ctx->top_pipe;
+
+			memset(pipe_ctx, 0, sizeof(*pipe_ctx));
+			pipe_ctx->tg = pool->timing_generators[i];
+			pipe_ctx->mi = pool->mis[i];
+			pipe_ctx->ipp = pool->ipps[i];
+			pipe_ctx->xfm = pool->transforms[i];
+			pipe_ctx->opp = pool->opps[i];
+			pipe_ctx->dis_clk = pool->display_clock;
+			pipe_ctx->pipe_idx = i;
+			pipe_ctx->mpc_idx = mpc_idx;
+
+			pipe_ctx->stream = stream;
+			return i;
+		}
+	}
+	return -1;
+}
+#endif
+
 bool resource_attach_surfaces_to_context(
 		const struct dc_surface * const *surfaces,
 		int surface_count,
@@ -1048,6 +1085,13 @@ bool resource_attach_surfaces_to_context
 		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
 				context, pool, dc_stream);
 
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+		if (!free_pipe) {
+			int pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
+			if (pipe_idx >= 0)
+				free_pipe = &context->res_ctx.pipe_ctx[pipe_idx];
+		}
+#endif
 		if (!free_pipe) {
 			stream_status->surfaces[i] = NULL;
 			return false;
@@ -1391,42 +1435,6 @@ static void calculate_phy_pix_clks(struc
 	}
 }
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-static int acquire_first_split_pipe(
-		struct resource_context *res_ctx,
-		const struct resource_pool *pool,
-		struct core_stream *stream)
-{
-	int i;
-
-	for (i = 0; i < pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
-
-		if (pipe_ctx->top_pipe &&
-				pipe_ctx->top_pipe->surface == pipe_ctx->surface) {
-			int mpc_idx = pipe_ctx->mpc_idx;
-
-			pipe_ctx->top_pipe->bottom_pipe = pipe_ctx->bottom_pipe;
-			pipe_ctx->bottom_pipe->top_pipe = pipe_ctx->top_pipe;
-
-			memset(pipe_ctx, 0, sizeof(*pipe_ctx));
-			pipe_ctx->tg = pool->timing_generators[i];
-			pipe_ctx->mi = pool->mis[i];
-			pipe_ctx->ipp = pool->ipps[i];
-			pipe_ctx->xfm = pool->transforms[i];
-			pipe_ctx->opp = pool->opps[i];
-			pipe_ctx->dis_clk = pool->display_clock;
-			pipe_ctx->pipe_idx = i;
-			pipe_ctx->mpc_idx = mpc_idx;
-
-			pipe_ctx->stream = stream;
-			return i;
-		}
-	}
-	return -1;
-}
-#endif
-
 enum dc_status resource_map_pool_resources(
 		const struct core_dc *dc,
 		struct validate_context *context,
