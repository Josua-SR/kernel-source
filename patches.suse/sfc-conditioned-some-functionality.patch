From: "Alex Maftei (amaftei)" <amaftei@solarflare.com>
Date: Thu, 9 Jan 2020 15:45:29 +0000
Subject: sfc: conditioned some functionality
Patch-mainline: v5.6-rc1
Git-commit: b5775b476ef7b28a3895335a2b8533e10ba36b16
References: jsc#SLE-8314

Before calling certain function pointers, check that they are non-NULL.

Signed-off-by: Alexandru-Mihai Maftei <amaftei@solarflare.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/sfc/efx_channels.c |    6 ++--
 drivers/net/ethernet/sfc/efx_common.c   |   47 +++++++++++++++++++-------------
 2 files changed, 32 insertions(+), 21 deletions(-)

--- a/drivers/net/ethernet/sfc/efx_channels.c
+++ b/drivers/net/ethernet/sfc/efx_channels.c
@@ -1039,7 +1039,7 @@ void efx_stop_channels(struct efx_nic *e
 	struct efx_tx_queue *tx_queue;
 	struct efx_rx_queue *rx_queue;
 	struct efx_channel *channel;
-	int rc;
+	int rc = 0;
 
 	/* Stop RX refill */
 	efx_for_each_channel(channel, efx) {
@@ -1060,7 +1060,9 @@ void efx_stop_channels(struct efx_nic *e
 		}
 	}
 
-	rc = efx->type->fini_dmaq(efx);
+	if (efx->type->fini_dmaq)
+		rc = efx->type->fini_dmaq(efx);
+
 	if (rc) {
 		netif_err(efx, drv, efx->net_dev, "failed to flush queues\n");
 	} else {
--- a/drivers/net/ethernet/sfc/efx_common.c
+++ b/drivers/net/ethernet/sfc/efx_common.c
@@ -141,9 +141,11 @@ void efx_destroy_reset_workqueue(void)
  */
 void efx_mac_reconfigure(struct efx_nic *efx)
 {
-	down_read(&efx->filter_sem);
-	efx->type->reconfigure_mac(efx);
-	up_read(&efx->filter_sem);
+	if (efx->type->reconfigure_mac) {
+		down_read(&efx->filter_sem);
+		efx->type->reconfigure_mac(efx);
+		up_read(&efx->filter_sem);
+	}
 }
 
 /* Asynchronous work item for changing MAC promiscuity and multicast
@@ -296,7 +298,8 @@ static void efx_start_datapath(struct ef
 		netdev_features_change(efx->net_dev);
 
 	/* RX filters may also have scatter-enabled flags */
-	if (efx->rx_scatter != old_rx_scatter)
+	if ((efx->rx_scatter != old_rx_scatter) &&
+	    efx->type->filter_update_rx_scatter)
 		efx->type->filter_update_rx_scatter(efx);
 
 	/* We must keep at least one descriptor in a TX ring empty.
@@ -405,11 +408,13 @@ void efx_start_all(struct efx_nic *efx)
 		efx_link_status_changed(efx);
 	mutex_unlock(&efx->mac_lock);
 
-	efx->type->start_stats(efx);
-	efx->type->pull_stats(efx);
-	spin_lock_bh(&efx->stats_lock);
-	efx->type->update_stats(efx, NULL, NULL);
-	spin_unlock_bh(&efx->stats_lock);
+	if (efx->type->start_stats) {
+		efx->type->start_stats(efx);
+		efx->type->pull_stats(efx);
+		spin_lock_bh(&efx->stats_lock);
+		efx->type->update_stats(efx, NULL, NULL);
+		spin_unlock_bh(&efx->stats_lock);
+	}
 }
 
 /* Quiesce the hardware and software data path, and regular activity
@@ -425,14 +430,17 @@ void efx_stop_all(struct efx_nic *efx)
 	if (!efx->port_enabled)
 		return;
 
-	/* update stats before we go down so we can accurately count
-	 * rx_nodesc_drops
-	 */
-	efx->type->pull_stats(efx);
-	spin_lock_bh(&efx->stats_lock);
-	efx->type->update_stats(efx, NULL, NULL);
-	spin_unlock_bh(&efx->stats_lock);
-	efx->type->stop_stats(efx);
+	if (efx->type->update_stats) {
+		/* update stats before we go down so we can accurately count
+		 * rx_nodesc_drops
+		 */
+		efx->type->pull_stats(efx);
+		spin_lock_bh(&efx->stats_lock);
+		efx->type->update_stats(efx, NULL, NULL);
+		spin_unlock_bh(&efx->stats_lock);
+		efx->type->stop_stats(efx);
+	}
+
 	efx_stop_port(efx);
 
 	/* Stop the kernel transmit interface.  This is only valid if
@@ -456,7 +464,7 @@ void efx_stop_all(struct efx_nic *efx)
 int __efx_reconfigure_port(struct efx_nic *efx)
 {
 	enum efx_phy_mode phy_mode;
-	int rc;
+	int rc = 0;
 
 	WARN_ON(!mutex_is_locked(&efx->mac_lock));
 
@@ -467,7 +475,8 @@ int __efx_reconfigure_port(struct efx_ni
 	else
 		efx->phy_mode &= ~PHY_MODE_TX_DISABLED;
 
-	rc = efx->type->reconfigure_port(efx);
+	if (efx->type->reconfigure_port)
+		rc = efx->type->reconfigure_port(efx);
 
 	if (rc)
 		efx->phy_mode = phy_mode;
