From 5a6fe2cf6f166cf3b019208c2e356d4b7bc00ee9 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Fri, 5 Jun 2020 17:52:58 +0100
Subject: drm/i915: Discard a misplaced GGTT vma
Git-commit: 9bdcaa5e3a2fb0a18d8c7a49bd64a52bce105bd2
Patch-mainline: v5.9-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

Across the many users of the GGTT vma (internal objects, mmapings,
display etc), we may end up with conflicting requirements for the
placement. Currently, we try to resolve the conflict by unbinding the
vma and rebinding it to match the new constraints; over time we will end
up with a GGTT that matches the most strict constraints over all
concurrent users. However, this causes a problem if the vma is currently
in use as we must wait until it is idle before moving it. But there is
no restriction on the number of views we may use (apart from the limited
size of the GGTT itself), and so if the active vma does not meet our
requirements, try and build a new one!

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Reviewed-by: Matthew Auld <matthew.auld@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200605165258.1483-1-chris@chris-wilson.co.uk
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/i915/i915_gem.c | 45 +++++++++++++++++++++++++++++++++
 1 file changed, 45 insertions(+)

diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index 0cbcb9f54e7d..f1acd1889d37 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -933,6 +933,45 @@ void i915_gem_runtime_suspend(struct drm_i915_private *i915)
 	}
 }
 
+static bool
+discard_ggtt_vma(struct i915_vma *vma, const struct i915_ggtt_view *view)
+{
+	const struct i915_ggtt_view discard = {
+		.type = I915_GGTT_VIEW_PARTIAL,
+	};
+	struct drm_i915_gem_object *obj = vma->obj;
+
+	spin_lock(&obj->vma.lock);
+	if (i915_vma_compare(vma, vma->vm, &discard)) {
+		struct rb_node *rb, **p;
+
+		rb_erase(&vma->obj_node, &obj->vma.tree);
+		vma->ggtt_view = discard;
+		GEM_BUG_ON(i915_vma_compare(vma, vma->vm, view));
+
+		rb = NULL;
+		p = &obj->vma.tree.rb_node;
+		while (*p) {
+			struct i915_vma *pos;
+			long cmp;
+
+			rb = *p;
+			pos = rb_entry(rb, struct i915_vma, obj_node);
+
+			cmp = i915_vma_compare(pos, vma->vm, &discard);
+			if (cmp < 0)
+				p = &rb->rb_right;
+			else
+				p = &rb->rb_left;
+		}
+		rb_link_node(&vma->obj_node, rb, p);
+		rb_insert_color(&vma->obj_node, &obj->vma.tree);
+	}
+	spin_unlock(&obj->vma.lock);
+
+	return i915_vma_compare(vma, vma->vm, view);
+}
+
 struct i915_vma *
 i915_gem_object_ggtt_pin(struct drm_i915_gem_object *obj,
 			 const struct i915_ggtt_view *view,
@@ -979,6 +1018,7 @@ i915_gem_object_ggtt_pin(struct drm_i915_gem_object *obj,
 			return ERR_PTR(-ENOSPC);
 	}
 
+new_vma:
 	vma = i915_vma_instance(obj, &ggtt->vm, view);
 	if (IS_ERR(vma))
 		return vma;
@@ -993,6 +1033,11 @@ i915_gem_object_ggtt_pin(struct drm_i915_gem_object *obj,
 				return ERR_PTR(-ENOSPC);
 		}
 
+		if (i915_vma_is_pinned(vma) || i915_vma_is_active(vma)) {
+			if (discard_ggtt_vma(vma, view))
+				goto new_vma;
+		}
+
 		ret = i915_vma_unbind(vma);
 		if (ret)
 			return ERR_PTR(ret);
-- 
2.29.2

