From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 8 May 2018 01:30:46 +0100
Subject: drm/i915/execlists: Cache the priolist when rescheduling
Git-commit: a02eb975be78171f66a47c103e57e7940d0860a7
Patch-mainline: v4.18-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

When rescheduling a change of dependencies, they all need to be added to
the same priolist (at least the ones on the same engine!). Since we
likely want to move a batch of requests, keep the priolist around.

v2: Throw in an assert to catch trivial errors quickly.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20180508003046.2633-2-chris@chris-wilson.co.uk

Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/i915/intel_lrc.c |   13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

--- a/drivers/gpu/drm/i915/intel_lrc.c
+++ b/drivers/gpu/drm/i915/intel_lrc.c
@@ -346,6 +346,7 @@ static void __unwind_incomplete_requests
 			p = lookup_priolist(engine, last_prio);
 		}
 
+		GEM_BUG_ON(p->priority != rq_prio(rq));
 		list_add(&rq->sched.link, &p->requests);
 	}
 }
@@ -1198,7 +1199,8 @@ sched_lock_engine(struct i915_sched_node
 static void execlists_schedule(struct i915_request *request,
 			       const struct i915_sched_attr *attr)
 {
-	struct intel_engine_cs *engine;
+	struct i915_priolist *uninitialized_var(pl);
+	struct intel_engine_cs *engine, *last;
 	struct i915_dependency *dep, *p;
 	struct i915_dependency stack;
 	const int prio = attr->priority;
@@ -1271,6 +1273,7 @@ static void execlists_schedule(struct i9
 		__list_del_entry(&stack.dfs_link);
 	}
 
+	last = NULL;
 	engine = request->engine;
 	spin_lock_irq(&engine->timeline.lock);
 
@@ -1287,8 +1290,12 @@ static void execlists_schedule(struct i9
 
 		node->attr.priority = prio;
 		if (!list_empty(&node->link)) {
-			__list_del_entry(&node->link);
-			queue_request(engine, node, prio);
+			if (last != engine) {
+				pl = lookup_priolist(engine, prio);
+				last = engine;
+			}
+			GEM_BUG_ON(pl->priority != prio);
+			list_move_tail(&node->link, &pl->requests);
 		}
 
 		if (prio > engine->execlists.queue_priority &&
