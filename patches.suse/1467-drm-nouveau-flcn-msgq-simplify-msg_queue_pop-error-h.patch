From 167bc8963b80c21595613313bbeeeefa9506f09b Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Wed, 15 Jan 2020 06:34:22 +1000
Subject: drm/nouveau/flcn/msgq: simplify msg_queue_pop() error handling
Git-commit: e9602a1bd7e996aca5c231bc07cad41fff9b290b
Patch-mainline: v5.6-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

We always want at least requested size, make anything less a more direct
error condition.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/nouveau/nvkm/falcon/msgq.c | 25 ++++++----------------
 1 file changed, 7 insertions(+), 18 deletions(-)

diff --git a/drivers/gpu/drm/nouveau/nvkm/falcon/msgq.c b/drivers/gpu/drm/nouveau/nvkm/falcon/msgq.c
index ea3e7c73e990..15299ff45685 100644
--- a/drivers/gpu/drm/nouveau/nvkm/falcon/msgq.c
+++ b/drivers/gpu/drm/nouveau/nvkm/falcon/msgq.c
@@ -67,20 +67,14 @@ msg_queue_pop(struct nvkm_msgqueue *priv, struct nvkm_msgqueue_queue *queue,
 	tail = queue->position;
 
 	available = head - tail;
-
-	if (available == 0) {
-		nvkm_warn(subdev, "no message data available\n");
-		return 0;
-	}
-
 	if (size > available) {
 		nvkm_warn(subdev, "message data smaller than read request\n");
-		size = available;
+		return -EINVAL;
 	}
 
 	nvkm_falcon_read_dmem(priv->falcon, tail, size, 0, data);
 	queue->position += ALIGN(size, QUEUE_ALIGNMENT);
-	return size;
+	return 0;
 }
 
 static int
@@ -88,19 +82,15 @@ msg_queue_read(struct nvkm_msgqueue *priv, struct nvkm_msgqueue_queue *queue,
 	       struct nv_falcon_msg *hdr)
 {
 	const struct nvkm_subdev *subdev = priv->falcon->owner;
-	int ret;
+	int ret = 0;
 
 	msg_queue_open(priv, queue);
 
-	if (msg_queue_empty(priv, queue)) {
-		ret = 0;
+	if (msg_queue_empty(priv, queue))
 		goto close;
-	}
 
 	ret = msg_queue_pop(priv, queue, hdr, HDR_SIZE);
-	if (ret >= 0 && ret != HDR_SIZE)
-		ret = -EINVAL;
-	if (ret < 0) {
+	if (ret) {
 		nvkm_error(subdev, "failed to read message header: %d\n", ret);
 		goto close;
 	}
@@ -115,14 +105,13 @@ msg_queue_read(struct nvkm_msgqueue *priv, struct nvkm_msgqueue_queue *queue,
 		u32 read_size = hdr->size - HDR_SIZE;
 
 		ret = msg_queue_pop(priv, queue, (hdr + 1), read_size);
-		if (ret >= 0 && ret != read_size)
-			ret = -EINVAL;
-		if (ret < 0) {
+		if (ret) {
 			nvkm_error(subdev, "failed to read message: %d\n", ret);
 			goto close;
 		}
 	}
 
+	ret = 1;
 close:
 	msg_queue_close(priv, queue, (ret >= 0));
 	return ret;
-- 
2.28.0

