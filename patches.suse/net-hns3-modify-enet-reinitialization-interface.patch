From: Huazhong Tan <tanhuazhong@huawei.com>
Date: Fri, 18 Jan 2019 16:13:03 +0800
Subject: net: hns3: modify enet reinitialization interface
Patch-mainline: v5.1-rc1
Git-commit: 2c9dd668914bb9813b83bc62c28ebfe53e205525
References: bsc#1126390

hns3_reset_notify_init_enet and hns3_reset_notify_uninit_enet are the
reinitialization interface that will be called when the device reset,
the number of TC changed, or the queue length changed. So these two
function should call hns3_get_ring_config() and hns3_put_ring_config()
to allocate and free memory for the ring with the correct number.

Also this patch fixes a double free problem when
hns3_reset_notify_uninit_enet calling hns3_nic_dealloc_vector_data

Signed-off-by: Huazhong Tan <tanhuazhong@huawei.com>
Signed-off-by: Yunsheng Lin <linyunsheng@huawei.com>
Signed-off-by: Peng Li <lipeng321@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/hisilicon/hns3/hns3_enet.c |   18 ++++++++++++++++--
 1 file changed, 16 insertions(+), 2 deletions(-)

--- a/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
@@ -3186,6 +3186,9 @@ static int hns3_nic_uninit_vector_data(s
 	for (i = 0; i < priv->vector_num; i++) {
 		tqp_vector = &priv->tqp_vector[i];
 
+		if (!tqp_vector->rx_group.ring && !tqp_vector->tx_group.ring)
+			continue;
+
 		ret = hns3_get_vector_ring_chain(tqp_vector,
 						 &vector_ring_chain);
 		if (ret)
@@ -3239,6 +3242,7 @@ static int hns3_ring_get_cfg(struct hnae
 {
 	struct hns3_nic_ring_data *ring_data = priv->ring_data;
 	int queue_num = priv->ae_handle->kinfo.num_tqps;
+	int desc_num = priv->ae_handle->kinfo.num_desc;
 	struct pci_dev *pdev = priv->ae_handle->pdev;
 	struct hns3_enet_ring *ring;
 
@@ -3264,7 +3268,7 @@ static int hns3_ring_get_cfg(struct hnae
 	ring->dev = priv->dev;
 	ring->desc_dma_addr = 0;
 	ring->buf_size = q->buf_size;
-	ring->desc_num = q->desc_num;
+	ring->desc_num = desc_num;
 	ring->next_to_use = 0;
 	ring->next_to_clean = 0;
 
@@ -4044,10 +4048,14 @@ static int hns3_reset_notify_init_enet(s
 	/* Carrier off reporting is important to ethtool even BEFORE open */
 	netif_carrier_off(netdev);
 
-	ret = hns3_nic_alloc_vector_data(priv);
+	ret = hns3_get_ring_config(priv);
 	if (ret)
 		return ret;
 
+	ret = hns3_nic_alloc_vector_data(priv);
+	if (ret)
+		goto err_put_ring;
+
 	hns3_restore_coal(priv);
 
 	ret = hns3_nic_init_vector_data(priv);
@@ -4067,6 +4075,9 @@ err_uninit_vector:
 	priv->ring_data = NULL;
 err_dealloc_vector:
 	hns3_nic_dealloc_vector_data(priv);
+err_put_ring:
+	hns3_put_ring_config(priv);
+	priv->ring_data = NULL;
 
 	return ret;
 }
@@ -4100,6 +4111,9 @@ static int hns3_reset_notify_uninit_enet
 	if (ret)
 		netdev_err(netdev, "uninit ring error\n");
 
+	hns3_put_ring_config(priv);
+	priv->ring_data = NULL;
+
 	clear_bit(HNS3_NIC_STATE_INITED, &priv->state);
 
 	return ret;
