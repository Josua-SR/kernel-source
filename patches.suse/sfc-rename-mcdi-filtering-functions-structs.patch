From: "Alex Maftei (amaftei)" <amaftei@solarflare.com>
Date: Mon, 27 Jan 2020 11:13:27 +0000
Subject: sfc: rename mcdi filtering functions/structs
Patch-mainline: v5.6-rc1
Git-commit: 90c914d2a39367b18b25b67b0a69335df8b92d56
References: jsc#SLE-8314

Minor style fixes included due to name lengths changing.

Signed-off-by: Alexandru-Mihai Maftei <amaftei@solarflare.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/sfc/ef10.c |  558 ++++++++++++++++++++--------------------
 1 file changed, 282 insertions(+), 276 deletions(-)

--- a/drivers/net/ethernet/sfc/ef10.c
+++ b/drivers/net/ethernet/sfc/ef10.c
@@ -44,7 +44,7 @@ enum {
  * Huntington has a single 8K filter table shared between all filter
  * types and both ports.
  */
-#define HUNT_FILTER_TBL_ROWS 8192
+#define EFX_MCDI_FILTER_TBL_ROWS 8192
 
 #define EFX_EF10_FILTER_ID_INVALID 0xffff
 
@@ -57,7 +57,7 @@ struct efx_ef10_vlan {
 	u16 vid;
 };
 
-enum efx_ef10_default_filters {
+enum efx_mcdi_filter_default_filters {
 	EFX_EF10_BCAST,
 	EFX_EF10_UCDEF,
 	EFX_EF10_MCDEF,
@@ -78,7 +78,7 @@ enum efx_ef10_default_filters {
 };
 
 /* Per-VLAN filters information */
-struct efx_ef10_filter_vlan {
+struct efx_mcdi_filter_vlan {
 	struct list_head list;
 	u16 vid;
 	u16 uc[EFX_EF10_FILTER_DEV_UC_MAX];
@@ -86,11 +86,11 @@ struct efx_ef10_filter_vlan {
 	u16 default_filters[EFX_EF10_NUM_DEFAULT_FILTERS];
 };
 
-struct efx_ef10_dev_addr {
+struct efx_mcdi_dev_addr {
 	u8 addr[ETH_ALEN];
 };
 
-struct efx_ef10_filter_table {
+struct efx_mcdi_filter_table {
 /* The MCDI match masks supported by this fw & hw, in order of priority */
 	u32 rx_match_mcdi_flags[
 		MC_CMD_GET_PARSER_DISP_INFO_OUT_SUPPORTED_MATCHES_MAXNUM * 2];
@@ -106,8 +106,8 @@ struct efx_ef10_filter_table {
 		u64 handle;		/* firmware handle */
 	} *entry;
 /* Shadow of net_device address lists, guarded by mac_lock */
-	struct efx_ef10_dev_addr dev_uc_list[EFX_EF10_FILTER_DEV_UC_MAX];
-	struct efx_ef10_dev_addr dev_mc_list[EFX_EF10_FILTER_DEV_MC_MAX];
+	struct efx_mcdi_dev_addr dev_uc_list[EFX_EF10_FILTER_DEV_UC_MAX];
+	struct efx_mcdi_dev_addr dev_mc_list[EFX_EF10_FILTER_DEV_MC_MAX];
 	int dev_uc_count;
 	int dev_mc_count;
 	bool uc_promisc;
@@ -122,28 +122,28 @@ struct efx_ef10_filter_table {
 /* An arbitrary search limit for the software hash table */
 #define EFX_EF10_FILTER_SEARCH_LIMIT 200
 
-static void efx_ef10_rx_free_indir_table(struct efx_nic *efx);
-static void efx_ef10_filter_table_remove(struct efx_nic *efx);
-static int efx_ef10_filter_add_vlan(struct efx_nic *efx, u16 vid);
-static void efx_ef10_filter_del_vlan_internal(struct efx_nic *efx,
-					      struct efx_ef10_filter_vlan *vlan);
-static void efx_ef10_filter_del_vlan(struct efx_nic *efx, u16 vid);
+static void efx_mcdi_rx_free_indir_table(struct efx_nic *efx);
+static void efx_mcdi_filter_table_remove(struct efx_nic *efx);
+static int efx_mcdi_filter_add_vlan(struct efx_nic *efx, u16 vid);
+static void efx_mcdi_filter_del_vlan_internal(struct efx_nic *efx,
+					      struct efx_mcdi_filter_vlan *vlan);
+static void efx_mcdi_filter_del_vlan(struct efx_nic *efx, u16 vid);
 static int efx_ef10_set_udp_tnl_ports(struct efx_nic *efx, bool unloading);
 
 static u32 efx_ef10_filter_get_unsafe_id(u32 filter_id)
 {
 	WARN_ON_ONCE(filter_id == EFX_EF10_FILTER_ID_INVALID);
-	return filter_id & (HUNT_FILTER_TBL_ROWS - 1);
+	return filter_id & (EFX_MCDI_FILTER_TBL_ROWS - 1);
 }
 
 static unsigned int efx_ef10_filter_get_unsafe_pri(u32 filter_id)
 {
-	return filter_id / (HUNT_FILTER_TBL_ROWS * 2);
+	return filter_id / (EFX_MCDI_FILTER_TBL_ROWS * 2);
 }
 
 static u32 efx_ef10_make_filter_id(unsigned int pri, u16 idx)
 {
-	return pri * HUNT_FILTER_TBL_ROWS * 2 + idx;
+	return pri * EFX_MCDI_FILTER_TBL_ROWS * 2 + idx;
 }
 
 static int efx_ef10_get_warm_boot_count(struct efx_nic *efx)
@@ -546,7 +546,7 @@ static int efx_ef10_add_vlan(struct efx_
 	if (efx->filter_state) {
 		mutex_lock(&efx->mac_lock);
 		down_write(&efx->filter_sem);
-		rc = efx_ef10_filter_add_vlan(efx, vlan->vid);
+		rc = efx_mcdi_filter_add_vlan(efx, vlan->vid);
 		up_write(&efx->filter_sem);
 		mutex_unlock(&efx->mac_lock);
 		if (rc)
@@ -575,7 +575,7 @@ static void efx_ef10_del_vlan_internal(s
 
 	if (efx->filter_state) {
 		down_write(&efx->filter_sem);
-		efx_ef10_filter_del_vlan(efx, vlan->vid);
+		efx_mcdi_filter_del_vlan(efx, vlan->vid);
 		up_write(&efx->filter_sem);
 	}
 
@@ -1038,7 +1038,7 @@ static void efx_ef10_remove(struct efx_n
 
 	efx_mcdi_mon_remove(efx);
 
-	efx_ef10_rx_free_indir_table(efx);
+	efx_mcdi_rx_free_indir_table(efx);
 
 	if (nic_data->wc_membase)
 		iounmap(nic_data->wc_membase);
@@ -1426,7 +1426,7 @@ static int efx_ef10_init_nic(struct efx_
 	return 0;
 }
 
-static void efx_ef10_reset_mc_allocations(struct efx_nic *efx)
+static void efx_ef10_table_reset_mc_allocations(struct efx_nic *efx)
 {
 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
 #ifdef CONFIG_SFC_SRIOV
@@ -1507,7 +1507,7 @@ static int efx_ef10_reset(struct efx_nic
 	 */
 	if ((reset_type == RESET_TYPE_ALL ||
 	     reset_type == RESET_TYPE_MCDI_TIMEOUT) && !rc)
-		efx_ef10_reset_mc_allocations(efx);
+		efx_ef10_table_reset_mc_allocations(efx);
 	return rc;
 }
 
@@ -2123,7 +2123,7 @@ static void efx_ef10_mcdi_reboot_detecte
 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
 
 	/* All our allocations have been reset */
-	efx_ef10_reset_mc_allocations(efx);
+	efx_ef10_table_reset_mc_allocations(efx);
 
 	/* The datapath firmware might have been changed */
 	nic_data->must_check_datapath_caps = true;
@@ -2512,7 +2512,8 @@ static void efx_ef10_tx_write(struct efx
 					 RSS_MODE_HASH_ADDRS << MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_UDP_IPV6_RSS_MODE_LBN |\
 					 RSS_MODE_HASH_ADDRS << MC_CMD_RSS_CONTEXT_GET_FLAGS_OUT_OTHER_IPV6_RSS_MODE_LBN)
 
-static int efx_ef10_get_rss_flags(struct efx_nic *efx, u32 context, u32 *flags)
+static int efx_mcdi_get_rss_context_flags(struct efx_nic *efx, u32 context,
+					  u32 *flags)
 {
 	/* Firmware had a bug (sfc bug 61952) where it would not actually
 	 * fill in the flags field in the response to MC_CMD_RSS_CONTEXT_GET_FLAGS.
@@ -2558,15 +2559,15 @@ static int efx_ef10_get_rss_flags(struct
  * Defaults are 4-tuple for TCP and 2-tuple for UDP and other-IP, so we
  * just need to set the UDP ports flags (for both IP versions).
  */
-static void efx_ef10_set_rss_flags(struct efx_nic *efx,
-				   struct efx_rss_context *ctx)
+static void efx_mcdi_set_rss_context_flags(struct efx_nic *efx,
+					   struct efx_rss_context *ctx)
 {
 	MCDI_DECLARE_BUF(inbuf, MC_CMD_RSS_CONTEXT_SET_FLAGS_IN_LEN);
 	u32 flags;
 
 	BUILD_BUG_ON(MC_CMD_RSS_CONTEXT_SET_FLAGS_OUT_LEN != 0);
 
-	if (efx_ef10_get_rss_flags(efx, ctx->context_id, &flags) != 0)
+	if (efx_mcdi_get_rss_context_flags(efx, ctx->context_id, &flags) != 0)
 		return;
 	MCDI_SET_DWORD(inbuf, RSS_CONTEXT_SET_FLAGS_IN_RSS_CONTEXT_ID,
 		       ctx->context_id);
@@ -2579,9 +2580,9 @@ static void efx_ef10_set_rss_flags(struc
 		ctx->rx_hash_udp_4tuple = true;
 }
 
-static int efx_ef10_alloc_rss_context(struct efx_nic *efx, bool exclusive,
-				      struct efx_rss_context *ctx,
-				      unsigned *context_size)
+static int efx_mcdi_filter_alloc_rss_context(struct efx_nic *efx, bool exclusive,
+					     struct efx_rss_context *ctx,
+					     unsigned *context_size)
 {
 	MCDI_DECLARE_BUF(inbuf, MC_CMD_RSS_CONTEXT_ALLOC_IN_LEN);
 	MCDI_DECLARE_BUF(outbuf, MC_CMD_RSS_CONTEXT_ALLOC_OUT_LEN);
@@ -2627,12 +2628,12 @@ static int efx_ef10_alloc_rss_context(st
 
 	if (nic_data->datapath_caps &
 	    1 << MC_CMD_GET_CAPABILITIES_OUT_ADDITIONAL_RSS_MODES_LBN)
-		efx_ef10_set_rss_flags(efx, ctx);
+		efx_mcdi_set_rss_context_flags(efx, ctx);
 
 	return 0;
 }
 
-static int efx_ef10_free_rss_context(struct efx_nic *efx, u32 context)
+static int efx_mcdi_filter_free_rss_context(struct efx_nic *efx, u32 context)
 {
 	MCDI_DECLARE_BUF(inbuf, MC_CMD_RSS_CONTEXT_FREE_IN_LEN);
 
@@ -2642,8 +2643,8 @@ static int efx_ef10_free_rss_context(str
 			    NULL, 0, NULL);
 }
 
-static int efx_ef10_populate_rss_table(struct efx_nic *efx, u32 context,
-				       const u32 *rx_indir_table, const u8 *key)
+static int efx_mcdi_filter_populate_rss_table(struct efx_nic *efx, u32 context,
+					      const u32 *rx_indir_table, const u8 *key)
 {
 	MCDI_DECLARE_BUF(tablebuf, MC_CMD_RSS_CONTEXT_SET_TABLE_IN_LEN);
 	MCDI_DECLARE_BUF(keybuf, MC_CMD_RSS_CONTEXT_SET_KEY_IN_LEN);
@@ -2680,23 +2681,25 @@ static int efx_ef10_populate_rss_table(s
 			    sizeof(keybuf), NULL, 0, NULL);
 }
 
-static void efx_ef10_rx_free_indir_table(struct efx_nic *efx)
+static void efx_mcdi_rx_free_indir_table(struct efx_nic *efx)
 {
 	int rc;
 
 	if (efx->rss_context.context_id != EFX_MCDI_RSS_CONTEXT_INVALID) {
-		rc = efx_ef10_free_rss_context(efx, efx->rss_context.context_id);
+		rc = efx_mcdi_filter_free_rss_context(efx,
+						   efx->rss_context.context_id);
 		WARN_ON(rc != 0);
 	}
 	efx->rss_context.context_id = EFX_MCDI_RSS_CONTEXT_INVALID;
 }
 
-static int efx_ef10_rx_push_shared_rss_config(struct efx_nic *efx,
-					      unsigned *context_size)
+static int efx_mcdi_filter_rx_push_shared_rss_config(struct efx_nic *efx,
+						     unsigned *context_size)
 {
 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
-	int rc = efx_ef10_alloc_rss_context(efx, false, &efx->rss_context,
-					    context_size);
+	int rc = efx_mcdi_filter_alloc_rss_context(efx, false,
+						   &efx->rss_context,
+						   context_size);
 
 	if (rc != 0)
 		return rc;
@@ -2706,9 +2709,9 @@ static int efx_ef10_rx_push_shared_rss_c
 	return 0;
 }
 
-static int efx_ef10_rx_push_exclusive_rss_config(struct efx_nic *efx,
-						 const u32 *rx_indir_table,
-						 const u8 *key)
+static int efx_mcdi_filter_rx_push_exclusive_rss_config(struct efx_nic *efx,
+						        const u32 *rx_indir_table,
+						        const u8 *key)
 {
 	u32 old_rx_rss_context = efx->rss_context.context_id;
 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
@@ -2716,22 +2719,24 @@ static int efx_ef10_rx_push_exclusive_rs
 
 	if (efx->rss_context.context_id == EFX_MCDI_RSS_CONTEXT_INVALID ||
 	    !nic_data->rx_rss_context_exclusive) {
-		rc = efx_ef10_alloc_rss_context(efx, true, &efx->rss_context,
-						NULL);
+		rc = efx_mcdi_filter_alloc_rss_context(efx, true,
+						       &efx->rss_context,
+						       NULL);
 		if (rc == -EOPNOTSUPP)
 			return rc;
 		else if (rc != 0)
 			goto fail1;
 	}
 
-	rc = efx_ef10_populate_rss_table(efx, efx->rss_context.context_id,
-					 rx_indir_table, key);
+	rc = efx_mcdi_filter_populate_rss_table(efx,
+						efx->rss_context.context_id,
+						rx_indir_table, key);
 	if (rc != 0)
 		goto fail2;
 
 	if (efx->rss_context.context_id != old_rx_rss_context &&
 	    old_rx_rss_context != EFX_MCDI_RSS_CONTEXT_INVALID)
-		WARN_ON(efx_ef10_free_rss_context(efx, old_rx_rss_context) != 0);
+		WARN_ON(efx_mcdi_filter_free_rss_context(efx, old_rx_rss_context) != 0);
 	nic_data->rx_rss_context_exclusive = true;
 	if (rx_indir_table != efx->rss_context.rx_indir_table)
 		memcpy(efx->rss_context.rx_indir_table, rx_indir_table,
@@ -2744,7 +2749,7 @@ static int efx_ef10_rx_push_exclusive_rs
 
 fail2:
 	if (old_rx_rss_context != efx->rss_context.context_id) {
-		WARN_ON(efx_ef10_free_rss_context(efx, efx->rss_context.context_id) != 0);
+		WARN_ON(efx_mcdi_filter_free_rss_context(efx, efx->rss_context.context_id) != 0);
 		efx->rss_context.context_id = old_rx_rss_context;
 	}
 fail1:
@@ -2752,7 +2757,7 @@ fail1:
 	return rc;
 }
 
-static int efx_ef10_rx_push_rss_context_config(struct efx_nic *efx,
+static int efx_mcdi_rx_push_rss_context_config(struct efx_nic *efx,
 					       struct efx_rss_context *ctx,
 					       const u32 *rx_indir_table,
 					       const u8 *key)
@@ -2762,16 +2767,16 @@ static int efx_ef10_rx_push_rss_context_
 	WARN_ON(!mutex_is_locked(&efx->rss_lock));
 
 	if (ctx->context_id == EFX_MCDI_RSS_CONTEXT_INVALID) {
-		rc = efx_ef10_alloc_rss_context(efx, true, ctx, NULL);
+		rc = efx_mcdi_filter_alloc_rss_context(efx, true, ctx, NULL);
 		if (rc)
 			return rc;
 	}
 
 	if (!rx_indir_table) /* Delete this context */
-		return efx_ef10_free_rss_context(efx, ctx->context_id);
+		return efx_mcdi_filter_free_rss_context(efx, ctx->context_id);
 
-	rc = efx_ef10_populate_rss_table(efx, ctx->context_id,
-					 rx_indir_table, key);
+	rc = efx_mcdi_filter_populate_rss_table(efx, ctx->context_id,
+						rx_indir_table, key);
 	if (rc)
 		return rc;
 
@@ -2782,7 +2787,7 @@ static int efx_ef10_rx_push_rss_context_
 	return 0;
 }
 
-static int efx_ef10_rx_pull_rss_context_config(struct efx_nic *efx,
+static int efx_mcdi_rx_pull_rss_context_config(struct efx_nic *efx,
 					       struct efx_rss_context *ctx)
 {
 	MCDI_DECLARE_BUF(inbuf, MC_CMD_RSS_CONTEXT_GET_TABLE_IN_LEN);
@@ -2834,17 +2839,17 @@ static int efx_ef10_rx_pull_rss_context_
 	return 0;
 }
 
-static int efx_ef10_rx_pull_rss_config(struct efx_nic *efx)
+static int efx_mcdi_rx_pull_rss_config(struct efx_nic *efx)
 {
 	int rc;
 
 	mutex_lock(&efx->rss_lock);
-	rc = efx_ef10_rx_pull_rss_context_config(efx, &efx->rss_context);
+	rc = efx_mcdi_rx_pull_rss_context_config(efx, &efx->rss_context);
 	mutex_unlock(&efx->rss_lock);
 	return rc;
 }
 
-static void efx_ef10_rx_restore_rss_contexts(struct efx_nic *efx)
+static void efx_mcdi_rx_restore_rss_contexts(struct efx_nic *efx)
 {
 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
 	struct efx_rss_context *ctx;
@@ -2859,7 +2864,7 @@ static void efx_ef10_rx_restore_rss_cont
 		/* previous NIC RSS context is gone */
 		ctx->context_id = EFX_MCDI_RSS_CONTEXT_INVALID;
 		/* so try to allocate a new one */
-		rc = efx_ef10_rx_push_rss_context_config(efx, ctx,
+		rc = efx_mcdi_rx_push_rss_context_config(efx, ctx,
 							 ctx->rx_indir_table,
 							 ctx->rx_hash_key);
 		if (rc)
@@ -2871,7 +2876,7 @@ static void efx_ef10_rx_restore_rss_cont
 	nic_data->must_restore_rss_contexts = false;
 }
 
-static int efx_ef10_pf_rx_push_rss_config(struct efx_nic *efx, bool user,
+static int efx_mcdi_pf_rx_push_rss_config(struct efx_nic *efx, bool user,
 					  const u32 *rx_indir_table,
 					  const u8 *key)
 {
@@ -2883,7 +2888,7 @@ static int efx_ef10_pf_rx_push_rss_confi
 	if (!key)
 		key = efx->rss_context.rx_hash_key;
 
-	rc = efx_ef10_rx_push_exclusive_rss_config(efx, rx_indir_table, key);
+	rc = efx_mcdi_filter_rx_push_exclusive_rss_config(efx, rx_indir_table, key);
 
 	if (rc == -ENOBUFS && !user) {
 		unsigned context_size;
@@ -2896,7 +2901,8 @@ static int efx_ef10_pf_rx_push_rss_confi
 			mismatch = rx_indir_table[i] !=
 				ethtool_rxfh_indir_default(i, efx->rss_spread);
 
-		rc = efx_ef10_rx_push_shared_rss_config(efx, &context_size);
+		rc = efx_mcdi_filter_rx_push_shared_rss_config(efx,
+							       &context_size);
 		if (rc == 0) {
 			if (context_size != efx->rss_spread)
 				netif_warn(efx, probe, efx->net_dev,
@@ -2920,7 +2926,7 @@ static int efx_ef10_pf_rx_push_rss_confi
 	return rc;
 }
 
-static int efx_ef10_vf_rx_push_rss_config(struct efx_nic *efx, bool user,
+static int efx_mcdi_vf_rx_push_rss_config(struct efx_nic *efx, bool user,
 					  const u32 *rx_indir_table
 					  __attribute__ ((unused)),
 					  const u8 *key
@@ -2930,7 +2936,7 @@ static int efx_ef10_vf_rx_push_rss_confi
 		return -EOPNOTSUPP;
 	if (efx->rss_context.context_id != EFX_MCDI_RSS_CONTEXT_INVALID)
 		return 0;
-	return efx_ef10_rx_push_shared_rss_config(efx, NULL);
+	return efx_mcdi_filter_rx_push_shared_rss_config(efx, NULL);
 }
 
 /* This creates an entry in the RX descriptor queue */
@@ -3710,7 +3716,7 @@ static bool efx_ef10_filter_is_exclusive
 }
 
 static struct efx_filter_spec *
-efx_ef10_filter_entry_spec(const struct efx_ef10_filter_table *table,
+efx_ef10_filter_entry_spec(const struct efx_mcdi_filter_table *table,
 			   unsigned int filter_idx)
 {
 	return (struct efx_filter_spec *)(table->entry[filter_idx].spec &
@@ -3718,14 +3724,14 @@ efx_ef10_filter_entry_spec(const struct
 }
 
 static unsigned int
-efx_ef10_filter_entry_flags(const struct efx_ef10_filter_table *table,
+efx_ef10_filter_entry_flags(const struct efx_mcdi_filter_table *table,
 			   unsigned int filter_idx)
 {
 	return table->entry[filter_idx].spec & EFX_EF10_FILTER_FLAGS;
 }
 
 static void
-efx_ef10_filter_set_entry(struct efx_ef10_filter_table *table,
+efx_ef10_filter_set_entry(struct efx_mcdi_filter_table *table,
 			  unsigned int filter_idx,
 			  const struct efx_filter_spec *spec,
 			  unsigned int flags)
@@ -3831,7 +3837,7 @@ efx_ef10_filter_push_prep_set_match_fiel
 		       match_fields);
 }
 
-static void efx_ef10_filter_push_prep(struct efx_nic *efx,
+static void efx_mcdi_filter_push_prep(struct efx_nic *efx,
 				      const struct efx_filter_spec *spec,
 				      efx_dword_t *inbuf, u64 handle,
 				      struct efx_rss_context *ctx,
@@ -3880,7 +3886,7 @@ static void efx_ef10_filter_push_prep(st
 		MCDI_SET_DWORD(inbuf, FILTER_OP_IN_RX_CONTEXT, ctx->context_id);
 }
 
-static int efx_ef10_filter_push(struct efx_nic *efx,
+static int efx_mcdi_filter_push(struct efx_nic *efx,
 				const struct efx_filter_spec *spec, u64 *handle,
 				struct efx_rss_context *ctx, bool replacing)
 {
@@ -3889,7 +3895,7 @@ static int efx_ef10_filter_push(struct e
 	size_t outlen;
 	int rc;
 
-	efx_ef10_filter_push_prep(efx, spec, inbuf, *handle, ctx, replacing);
+	efx_mcdi_filter_push_prep(efx, spec, inbuf, *handle, ctx, replacing);
 	rc = efx_mcdi_rpc_quiet(efx, MC_CMD_FILTER_OP, inbuf, sizeof(inbuf),
 				outbuf, sizeof(outbuf), &outlen);
 	if (rc && spec->priority != EFX_FILTER_PRI_HINT)
@@ -3902,7 +3908,7 @@ static int efx_ef10_filter_push(struct e
 	return rc;
 }
 
-static u32 efx_ef10_filter_mcdi_flags_from_spec(const struct efx_filter_spec *spec)
+static u32 efx_mcdi_filter_mcdi_flags_from_spec(const struct efx_filter_spec *spec)
 {
 	enum efx_encap_type encap_type = efx_filter_get_encap_type(spec);
 	unsigned int match_flags = spec->match_flags;
@@ -3962,10 +3968,10 @@ static u32 efx_ef10_filter_mcdi_flags_fr
 	return mcdi_flags;
 }
 
-static int efx_ef10_filter_pri(struct efx_ef10_filter_table *table,
+static int efx_mcdi_filter_pri(struct efx_mcdi_filter_table *table,
 			       const struct efx_filter_spec *spec)
 {
-	u32 mcdi_flags = efx_ef10_filter_mcdi_flags_from_spec(spec);
+	u32 mcdi_flags = efx_mcdi_filter_mcdi_flags_from_spec(spec);
 	unsigned int match_pri;
 
 	for (match_pri = 0;
@@ -3977,13 +3983,13 @@ static int efx_ef10_filter_pri(struct ef
 	return -EPROTONOSUPPORT;
 }
 
-static s32 efx_ef10_filter_insert_locked(struct efx_nic *efx,
+static s32 efx_mcdi_filter_insert_locked(struct efx_nic *efx,
 					 struct efx_filter_spec *spec,
 					 bool replace_equal)
 {
 	DECLARE_BITMAP(mc_rem_map, EFX_EF10_FILTER_SEARCH_LIMIT);
 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
-	struct efx_ef10_filter_table *table;
+	struct efx_mcdi_filter_table *table;
 	struct efx_filter_spec *saved_spec;
 	struct efx_rss_context *ctx = NULL;
 	unsigned int match_pri, hash;
@@ -4007,7 +4013,7 @@ static s32 efx_ef10_filter_insert_locked
 		goto out_unlock;
 	}
 
-	rc = efx_ef10_filter_pri(table, spec);
+	rc = efx_mcdi_filter_pri(table, spec);
 	if (rc < 0)
 		goto out_unlock;
 	match_pri = rc;
@@ -4038,7 +4044,7 @@ static s32 efx_ef10_filter_insert_locked
 	 * else a free slot to insert at.
 	 */
 	for (depth = 1; depth < EFX_EF10_FILTER_SEARCH_LIMIT; depth++) {
-		i = (hash + depth) & (HUNT_FILTER_TBL_ROWS - 1);
+		i = (hash + depth) & (EFX_MCDI_FILTER_TBL_ROWS - 1);
 		saved_spec = efx_ef10_filter_entry_spec(table, i);
 
 		if (!saved_spec) {
@@ -4108,7 +4114,7 @@ static s32 efx_ef10_filter_insert_locked
 	efx_ef10_filter_set_entry(table, ins_index, saved_spec, priv_flags);
 
 	/* Actually insert the filter on the HW */
-	rc = efx_ef10_filter_push(efx, spec, &table->entry[ins_index].handle,
+	rc = efx_mcdi_filter_push(efx, spec, &table->entry[ins_index].handle,
 				  ctx, replacing);
 
 	if (rc == -EINVAL && nic_data->must_realloc_vis)
@@ -4155,7 +4161,7 @@ static s32 efx_ef10_filter_insert_locked
 			if (!test_bit(depth, mc_rem_map))
 				continue;
 
-			i = (hash + depth) & (HUNT_FILTER_TBL_ROWS - 1);
+			i = (hash + depth) & (EFX_MCDI_FILTER_TBL_ROWS - 1);
 			saved_spec = efx_ef10_filter_entry_spec(table, i);
 			priv_flags = efx_ef10_filter_entry_flags(table, i);
 
@@ -4190,20 +4196,20 @@ out_unlock:
 	return rc;
 }
 
-static s32 efx_ef10_filter_insert(struct efx_nic *efx,
+static s32 efx_mcdi_filter_insert(struct efx_nic *efx,
 				  struct efx_filter_spec *spec,
 				  bool replace_equal)
 {
 	s32 ret;
 
 	down_read(&efx->filter_sem);
-	ret = efx_ef10_filter_insert_locked(efx, spec, replace_equal);
+	ret = efx_mcdi_filter_insert_locked(efx, spec, replace_equal);
 	up_read(&efx->filter_sem);
 
 	return ret;
 }
 
-static void efx_ef10_filter_update_rx_scatter(struct efx_nic *efx)
+static void efx_mcdi_update_rx_scatter(struct efx_nic *efx)
 {
 	/* no need to do anything here on EF10 */
 }
@@ -4215,12 +4221,12 @@ static void efx_ef10_filter_update_rx_sc
  * Caller must hold efx->filter_sem for read, and efx->filter_state->lock
  * for write.
  */
-static int efx_ef10_filter_remove_internal(struct efx_nic *efx,
+static int efx_mcdi_filter_remove_internal(struct efx_nic *efx,
 					   unsigned int priority_mask,
 					   u32 filter_id, bool by_index)
 {
 	unsigned int filter_idx = efx_ef10_filter_get_unsafe_id(filter_id);
-	struct efx_ef10_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
 	MCDI_DECLARE_BUF(inbuf,
 			 MC_CMD_FILTER_OP_IN_HANDLE_OFST +
 			 MC_CMD_FILTER_OP_IN_HANDLE_LEN);
@@ -4231,7 +4237,7 @@ static int efx_ef10_filter_remove_intern
 	spec = efx_ef10_filter_entry_spec(table, filter_idx);
 	if (!spec ||
 	    (!by_index &&
-	     efx_ef10_filter_pri(table, spec) !=
+	     efx_mcdi_filter_pri(table, spec) !=
 	     efx_ef10_filter_get_unsafe_pri(filter_id)))
 		return -ENOENT;
 
@@ -4257,7 +4263,7 @@ static int efx_ef10_filter_remove_intern
 				   EFX_FILTER_FLAG_RX_RSS : 0));
 		new_spec.dmaq_id = 0;
 		new_spec.rss_context = 0;
-		rc = efx_ef10_filter_push(efx, &new_spec,
+		rc = efx_mcdi_filter_push(efx, &new_spec,
 					  &table->entry[filter_idx].handle,
 					  &efx->rss_context,
 					  true);
@@ -4290,17 +4296,17 @@ static int efx_ef10_filter_remove_intern
 	return rc;
 }
 
-static int efx_ef10_filter_remove_safe(struct efx_nic *efx,
+static int efx_mcdi_filter_remove_safe(struct efx_nic *efx,
 				       enum efx_filter_priority priority,
 				       u32 filter_id)
 {
-	struct efx_ef10_filter_table *table;
+	struct efx_mcdi_filter_table *table;
 	int rc;
 
 	down_read(&efx->filter_sem);
 	table = efx->filter_state;
 	down_write(&table->lock);
-	rc = efx_ef10_filter_remove_internal(efx, 1U << priority, filter_id,
+	rc = efx_mcdi_filter_remove_internal(efx, 1U << priority, filter_id,
 					     false);
 	up_write(&table->lock);
 	up_read(&efx->filter_sem);
@@ -4308,28 +4314,28 @@ static int efx_ef10_filter_remove_safe(s
 }
 
 /* Caller must hold efx->filter_sem for read */
-static void efx_ef10_filter_remove_unsafe(struct efx_nic *efx,
+static void efx_mcdi_filter_remove_unsafe(struct efx_nic *efx,
 					  enum efx_filter_priority priority,
 					  u32 filter_id)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
 
 	if (filter_id == EFX_EF10_FILTER_ID_INVALID)
 		return;
 
 	down_write(&table->lock);
-	efx_ef10_filter_remove_internal(efx, 1U << priority, filter_id,
+	efx_mcdi_filter_remove_internal(efx, 1U << priority, filter_id,
 					true);
 	up_write(&table->lock);
 }
 
-static int efx_ef10_filter_get_safe(struct efx_nic *efx,
+static int efx_mcdi_filter_get_safe(struct efx_nic *efx,
 				    enum efx_filter_priority priority,
 				    u32 filter_id, struct efx_filter_spec *spec)
 {
 	unsigned int filter_idx = efx_ef10_filter_get_unsafe_id(filter_id);
 	const struct efx_filter_spec *saved_spec;
-	struct efx_ef10_filter_table *table;
+	struct efx_mcdi_filter_table *table;
 	int rc;
 
 	down_read(&efx->filter_sem);
@@ -4337,7 +4343,7 @@ static int efx_ef10_filter_get_safe(stru
 	down_read(&table->lock);
 	saved_spec = efx_ef10_filter_entry_spec(table, filter_idx);
 	if (saved_spec && saved_spec->priority == priority &&
-	    efx_ef10_filter_pri(table, saved_spec) ==
+	    efx_mcdi_filter_pri(table, saved_spec) ==
 	    efx_ef10_filter_get_unsafe_pri(filter_id)) {
 		*spec = *saved_spec;
 		rc = 0;
@@ -4349,10 +4355,10 @@ static int efx_ef10_filter_get_safe(stru
 	return rc;
 }
 
-static int efx_ef10_filter_clear_rx(struct efx_nic *efx,
+static int efx_mcdi_filter_clear_rx(struct efx_nic *efx,
 				    enum efx_filter_priority priority)
 {
-	struct efx_ef10_filter_table *table;
+	struct efx_mcdi_filter_table *table;
 	unsigned int priority_mask;
 	unsigned int i;
 	int rc;
@@ -4363,8 +4369,8 @@ static int efx_ef10_filter_clear_rx(stru
 	down_read(&efx->filter_sem);
 	table = efx->filter_state;
 	down_write(&table->lock);
-	for (i = 0; i < HUNT_FILTER_TBL_ROWS; i++) {
-		rc = efx_ef10_filter_remove_internal(efx, priority_mask,
+	for (i = 0; i < EFX_MCDI_FILTER_TBL_ROWS; i++) {
+		rc = efx_mcdi_filter_remove_internal(efx, priority_mask,
 						     i, true);
 		if (rc && rc != -ENOENT)
 			break;
@@ -4376,17 +4382,17 @@ static int efx_ef10_filter_clear_rx(stru
 	return rc;
 }
 
-static u32 efx_ef10_filter_count_rx_used(struct efx_nic *efx,
+static u32 efx_mcdi_filter_count_rx_used(struct efx_nic *efx,
 					 enum efx_filter_priority priority)
 {
-	struct efx_ef10_filter_table *table;
+	struct efx_mcdi_filter_table *table;
 	unsigned int filter_idx;
 	s32 count = 0;
 
 	down_read(&efx->filter_sem);
 	table = efx->filter_state;
 	down_read(&table->lock);
-	for (filter_idx = 0; filter_idx < HUNT_FILTER_TBL_ROWS; filter_idx++) {
+	for (filter_idx = 0; filter_idx < EFX_MCDI_FILTER_TBL_ROWS; filter_idx++) {
 		if (table->entry[filter_idx].spec &&
 		    efx_ef10_filter_entry_spec(table, filter_idx)->priority ==
 		    priority)
@@ -4397,18 +4403,18 @@ static u32 efx_ef10_filter_count_rx_used
 	return count;
 }
 
-static u32 efx_ef10_filter_get_rx_id_limit(struct efx_nic *efx)
+static u32 efx_mcdi_filter_get_rx_id_limit(struct efx_nic *efx)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
 
-	return table->rx_match_count * HUNT_FILTER_TBL_ROWS * 2;
+	return table->rx_match_count * EFX_MCDI_FILTER_TBL_ROWS * 2;
 }
 
-static s32 efx_ef10_filter_get_rx_ids(struct efx_nic *efx,
+static s32 efx_mcdi_filter_get_rx_ids(struct efx_nic *efx,
 				      enum efx_filter_priority priority,
 				      u32 *buf, u32 size)
 {
-	struct efx_ef10_filter_table *table;
+	struct efx_mcdi_filter_table *table;
 	struct efx_filter_spec *spec;
 	unsigned int filter_idx;
 	s32 count = 0;
@@ -4417,7 +4423,7 @@ static s32 efx_ef10_filter_get_rx_ids(st
 	table = efx->filter_state;
 	down_read(&table->lock);
 
-	for (filter_idx = 0; filter_idx < HUNT_FILTER_TBL_ROWS; filter_idx++) {
+	for (filter_idx = 0; filter_idx < EFX_MCDI_FILTER_TBL_ROWS; filter_idx++) {
 		spec = efx_ef10_filter_entry_spec(table, filter_idx);
 		if (spec && spec->priority == priority) {
 			if (count == size) {
@@ -4426,7 +4432,7 @@ static s32 efx_ef10_filter_get_rx_ids(st
 			}
 			buf[count++] =
 				efx_ef10_make_filter_id(
-					efx_ef10_filter_pri(table, spec),
+					efx_mcdi_filter_pri(table, spec),
 					filter_idx);
 		}
 	}
@@ -4437,11 +4443,11 @@ static s32 efx_ef10_filter_get_rx_ids(st
 
 #ifdef CONFIG_RFS_ACCEL
 
-static bool efx_ef10_filter_rfs_expire_one(struct efx_nic *efx, u32 flow_id,
+static bool efx_mcdi_filter_rfs_expire_one(struct efx_nic *efx, u32 flow_id,
 					   unsigned int filter_idx)
 {
 	struct efx_filter_spec *spec, saved_spec;
-	struct efx_ef10_filter_table *table;
+	struct efx_mcdi_filter_table *table;
 	struct efx_arfs_rule *rule = NULL;
 	bool ret = true, force = false;
 	u16 arfs_id;
@@ -4486,7 +4492,7 @@ expire:
 	 * the rule is not removed by efx_rps_hash_del() below.
 	 */
 	if (ret)
-		ret = efx_ef10_filter_remove_internal(efx, 1U << spec->priority,
+		ret = efx_mcdi_filter_remove_internal(efx, 1U << spec->priority,
 						      filter_idx, true) == 0;
 	/* While we can't safely dereference rule (we dropped the lock), we can
 	 * still test it for NULL.
@@ -4505,7 +4511,7 @@ out_unlock:
 
 #endif /* CONFIG_RFS_ACCEL */
 
-static int efx_ef10_filter_match_flags_from_mcdi(bool encap, u32 mcdi_flags)
+static int efx_mcdi_filter_match_flags_from_mcdi(bool encap, u32 mcdi_flags)
 {
 	int match_flags = 0;
 
@@ -4562,12 +4568,12 @@ static int efx_ef10_filter_match_flags_f
 	return match_flags;
 }
 
-static void efx_ef10_filter_cleanup_vlans(struct efx_nic *efx)
+static void efx_mcdi_filter_cleanup_vlans(struct efx_nic *efx)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
-	struct efx_ef10_filter_vlan *vlan, *next_vlan;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_vlan *vlan, *next_vlan;
 
-	/* See comment in efx_ef10_filter_table_remove() */
+	/* See comment in efx_mcdi_filter_table_remove() */
 	if (!efx_rwsem_assert_write_locked(&efx->filter_sem))
 		return;
 
@@ -4575,10 +4581,10 @@ static void efx_ef10_filter_cleanup_vlan
 		return;
 
 	list_for_each_entry_safe(vlan, next_vlan, &table->vlan_list, list)
-		efx_ef10_filter_del_vlan_internal(efx, vlan);
+		efx_mcdi_filter_del_vlan_internal(efx, vlan);
 }
 
-static bool efx_ef10_filter_match_supported(struct efx_ef10_filter_table *table,
+static bool efx_mcdi_filter_match_supported(struct efx_mcdi_filter_table *table,
 					    bool encap,
 					    enum efx_filter_match_flags match_flags)
 {
@@ -4588,7 +4594,7 @@ static bool efx_ef10_filter_match_suppor
 	for (match_pri = 0;
 	     match_pri < table->rx_match_count;
 	     match_pri++) {
-		mf = efx_ef10_filter_match_flags_from_mcdi(encap,
+		mf = efx_mcdi_filter_match_flags_from_mcdi(encap,
 				table->rx_match_mcdi_flags[match_pri]);
 		if (mf == match_flags)
 			return true;
@@ -4598,8 +4604,8 @@ static bool efx_ef10_filter_match_suppor
 }
 
 static int
-efx_ef10_filter_table_probe_matches(struct efx_nic *efx,
-				    struct efx_ef10_filter_table *table,
+efx_mcdi_filter_table_probe_matches(struct efx_nic *efx,
+				    struct efx_mcdi_filter_table *table,
 				    bool encap)
 {
 	MCDI_DECLARE_BUF(inbuf, MC_CMD_GET_PARSER_DISP_INFO_IN_LEN);
@@ -4628,7 +4634,7 @@ efx_ef10_filter_table_probe_matches(stru
 				outbuf,
 				GET_PARSER_DISP_INFO_OUT_SUPPORTED_MATCHES,
 				pd_match_pri);
-		rc = efx_ef10_filter_match_flags_from_mcdi(encap, mcdi_flags);
+		rc = efx_mcdi_filter_match_flags_from_mcdi(encap, mcdi_flags);
 		if (rc < 0) {
 			netif_dbg(efx, probe, efx->net_dev,
 				  "%s: fw flags %#x pri %u not supported in driver\n",
@@ -4646,11 +4652,11 @@ efx_ef10_filter_table_probe_matches(stru
 	return 0;
 }
 
-static int efx_ef10_filter_table_probe(struct efx_nic *efx)
+static int efx_mcdi_filter_table_probe(struct efx_nic *efx)
 {
 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
 	struct net_device *net_dev = efx->net_dev;
-	struct efx_ef10_filter_table *table;
+	struct efx_mcdi_filter_table *table;
 	struct efx_ef10_vlan *vlan;
 	int rc;
 
@@ -4665,18 +4671,18 @@ static int efx_ef10_filter_table_probe(s
 		return -ENOMEM;
 
 	table->rx_match_count = 0;
-	rc = efx_ef10_filter_table_probe_matches(efx, table, false);
+	rc = efx_mcdi_filter_table_probe_matches(efx, table, false);
 	if (rc)
 		goto fail;
 	if (nic_data->datapath_caps &
 		   (1 << MC_CMD_GET_CAPABILITIES_OUT_VXLAN_NVGRE_LBN))
-		rc = efx_ef10_filter_table_probe_matches(efx, table, true);
+		rc = efx_mcdi_filter_table_probe_matches(efx, table, true);
 	if (rc)
 		goto fail;
 	if ((efx_supported_features(efx) & NETIF_F_HW_VLAN_CTAG_FILTER) &&
-	    !(efx_ef10_filter_match_supported(table, false,
+	    !(efx_mcdi_filter_match_supported(table, false,
 		(EFX_FILTER_MATCH_OUTER_VID | EFX_FILTER_MATCH_LOC_MAC)) &&
-	      efx_ef10_filter_match_supported(table, false,
+	      efx_mcdi_filter_match_supported(table, false,
 		(EFX_FILTER_MATCH_OUTER_VID | EFX_FILTER_MATCH_LOC_MAC_IG)))) {
 		netif_info(efx, probe, net_dev,
 			   "VLAN filters are not supported in this firmware variant\n");
@@ -4685,7 +4691,7 @@ static int efx_ef10_filter_table_probe(s
 		net_dev->hw_features &= ~NETIF_F_HW_VLAN_CTAG_FILTER;
 	}
 
-	table->entry = vzalloc(array_size(HUNT_FILTER_TBL_ROWS,
+	table->entry = vzalloc(array_size(EFX_MCDI_FILTER_TBL_ROWS,
 					  sizeof(*table->entry)));
 	if (!table->entry) {
 		rc = -ENOMEM;
@@ -4701,7 +4707,7 @@ static int efx_ef10_filter_table_probe(s
 	efx->filter_state = table;
 
 	list_for_each_entry(vlan, &nic_data->vlan_list, list) {
-		rc = efx_ef10_filter_add_vlan(efx, vlan->vid);
+		rc = efx_mcdi_filter_add_vlan(efx, vlan->vid);
 		if (rc)
 			goto fail_add_vlan;
 	}
@@ -4709,7 +4715,7 @@ static int efx_ef10_filter_table_probe(s
 	return 0;
 
 fail_add_vlan:
-	efx_ef10_filter_cleanup_vlans(efx);
+	efx_mcdi_filter_cleanup_vlans(efx);
 	efx->filter_state = NULL;
 fail:
 	kfree(table);
@@ -4717,14 +4723,14 @@ fail:
 }
 
 /* Caller must hold efx->filter_sem for read if race against
- * efx_ef10_filter_table_remove() is possible
+ * efx_mcdi_filter_table_remove() is possible
  */
-static void efx_ef10_filter_table_restore(struct efx_nic *efx)
+static void efx_mcdi_filter_table_restore(struct efx_nic *efx)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
 	unsigned int invalid_filters = 0, failed = 0;
-	struct efx_ef10_filter_vlan *vlan;
+	struct efx_mcdi_filter_vlan *vlan;
 	struct efx_filter_spec *spec;
 	struct efx_rss_context *ctx;
 	unsigned int filter_idx;
@@ -4743,12 +4749,12 @@ static void efx_ef10_filter_table_restor
 	down_write(&table->lock);
 	mutex_lock(&efx->rss_lock);
 
-	for (filter_idx = 0; filter_idx < HUNT_FILTER_TBL_ROWS; filter_idx++) {
+	for (filter_idx = 0; filter_idx < EFX_MCDI_FILTER_TBL_ROWS; filter_idx++) {
 		spec = efx_ef10_filter_entry_spec(table, filter_idx);
 		if (!spec)
 			continue;
 
-		mcdi_flags = efx_ef10_filter_mcdi_flags_from_spec(spec);
+		mcdi_flags = efx_mcdi_filter_mcdi_flags_from_spec(spec);
 		match_pri = 0;
 		while (match_pri < table->rx_match_count &&
 		       table->rx_match_mcdi_flags[match_pri] != mcdi_flags)
@@ -4778,7 +4784,7 @@ static void efx_ef10_filter_table_restor
 			}
 		}
 
-		rc = efx_ef10_filter_push(efx, spec,
+		rc = efx_mcdi_filter_push(efx, spec,
 					  &table->entry[filter_idx].handle,
 					  ctx, false);
 		if (rc)
@@ -4815,15 +4821,15 @@ not_restored:
 		nic_data->must_restore_filters = false;
 }
 
-static void efx_ef10_filter_table_remove(struct efx_nic *efx)
+static void efx_mcdi_filter_table_remove(struct efx_nic *efx)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
 	MCDI_DECLARE_BUF(inbuf, MC_CMD_FILTER_OP_EXT_IN_LEN);
 	struct efx_filter_spec *spec;
 	unsigned int filter_idx;
 	int rc;
 
-	efx_ef10_filter_cleanup_vlans(efx);
+	efx_mcdi_filter_cleanup_vlans(efx);
 	efx->filter_state = NULL;
 	/* If we were called without locking, then it's not safe to free
 	 * the table as others might be using it.  So we just WARN, leak
@@ -4837,7 +4843,7 @@ static void efx_ef10_filter_table_remove
 	if (!table)
 		return;
 
-	for (filter_idx = 0; filter_idx < HUNT_FILTER_TBL_ROWS; filter_idx++) {
+	for (filter_idx = 0; filter_idx < EFX_MCDI_FILTER_TBL_ROWS; filter_idx++) {
 		spec = efx_ef10_filter_entry_spec(table, filter_idx);
 		if (!spec)
 			continue;
@@ -4861,9 +4867,9 @@ static void efx_ef10_filter_table_remove
 	kfree(table);
 }
 
-static void efx_ef10_filter_mark_one_old(struct efx_nic *efx, uint16_t *id)
+static void efx_mcdi_filter_mark_one_old(struct efx_nic *efx, uint16_t *id)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
 	unsigned int filter_idx;
 
 	efx_rwsem_assert_write_locked(&table->lock);
@@ -4880,38 +4886,38 @@ static void efx_ef10_filter_mark_one_old
 }
 
 /* Mark old per-VLAN filters that may need to be removed */
-static void _efx_ef10_filter_vlan_mark_old(struct efx_nic *efx,
-					   struct efx_ef10_filter_vlan *vlan)
+static void _efx_mcdi_filter_vlan_mark_old(struct efx_nic *efx,
+					   struct efx_mcdi_filter_vlan *vlan)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
 	unsigned int i;
 
 	for (i = 0; i < table->dev_uc_count; i++)
-		efx_ef10_filter_mark_one_old(efx, &vlan->uc[i]);
+		efx_mcdi_filter_mark_one_old(efx, &vlan->uc[i]);
 	for (i = 0; i < table->dev_mc_count; i++)
-		efx_ef10_filter_mark_one_old(efx, &vlan->mc[i]);
+		efx_mcdi_filter_mark_one_old(efx, &vlan->mc[i]);
 	for (i = 0; i < EFX_EF10_NUM_DEFAULT_FILTERS; i++)
-		efx_ef10_filter_mark_one_old(efx, &vlan->default_filters[i]);
+		efx_mcdi_filter_mark_one_old(efx, &vlan->default_filters[i]);
 }
 
 /* Mark old filters that may need to be removed.
  * Caller must hold efx->filter_sem for read if race against
- * efx_ef10_filter_table_remove() is possible
+ * efx_mcdi_filter_table_remove() is possible
  */
-static void efx_ef10_filter_mark_old(struct efx_nic *efx)
+static void efx_mcdi_filter_mark_old(struct efx_nic *efx)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
-	struct efx_ef10_filter_vlan *vlan;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_vlan *vlan;
 
 	down_write(&table->lock);
 	list_for_each_entry(vlan, &table->vlan_list, list)
-		_efx_ef10_filter_vlan_mark_old(efx, vlan);
+		_efx_mcdi_filter_vlan_mark_old(efx, vlan);
 	up_write(&table->lock);
 }
 
-static void efx_ef10_filter_uc_addr_list(struct efx_nic *efx)
+static void efx_mcdi_filter_uc_addr_list(struct efx_nic *efx)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
 	struct net_device *net_dev = efx->net_dev;
 	struct netdev_hw_addr *uc;
 	unsigned int i;
@@ -4931,9 +4937,9 @@ static void efx_ef10_filter_uc_addr_list
 	table->dev_uc_count = i;
 }
 
-static void efx_ef10_filter_mc_addr_list(struct efx_nic *efx)
+static void efx_mcdi_filter_mc_addr_list(struct efx_nic *efx)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
 	struct net_device *net_dev = efx->net_dev;
 	struct netdev_hw_addr *mc;
 	unsigned int i;
@@ -4955,12 +4961,12 @@ static void efx_ef10_filter_mc_addr_list
 	table->dev_mc_count = i;
 }
 
-static int efx_ef10_filter_insert_addr_list(struct efx_nic *efx,
-					    struct efx_ef10_filter_vlan *vlan,
+static int efx_mcdi_filter_insert_addr_list(struct efx_nic *efx,
+					    struct efx_mcdi_filter_vlan *vlan,
 					    bool multicast, bool rollback)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
-	struct efx_ef10_dev_addr *addr_list;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
+	struct efx_mcdi_dev_addr *addr_list;
 	enum efx_filter_flags filter_flags;
 	struct efx_filter_spec spec;
 	u8 baddr[ETH_ALEN];
@@ -4986,7 +4992,7 @@ static int efx_ef10_filter_insert_addr_l
 		EFX_WARN_ON_PARANOID(ids[i] != EFX_EF10_FILTER_ID_INVALID);
 		efx_filter_init_rx(&spec, EFX_FILTER_PRI_AUTO, filter_flags, 0);
 		efx_filter_set_eth_local(&spec, vlan->vid, addr_list[i].addr);
-		rc = efx_ef10_filter_insert_locked(efx, &spec, true);
+		rc = efx_mcdi_filter_insert_locked(efx, &spec, true);
 		if (rc < 0) {
 			if (rollback) {
 				netif_info(efx, drv, efx->net_dev,
@@ -4994,7 +5000,7 @@ static int efx_ef10_filter_insert_addr_l
 					   rc);
 				/* Fall back to promiscuous */
 				for (j = 0; j < i; j++) {
-					efx_ef10_filter_remove_unsafe(
+					efx_mcdi_filter_remove_unsafe(
 						efx, EFX_FILTER_PRI_AUTO,
 						ids[j]);
 					ids[j] = EFX_EF10_FILTER_ID_INVALID;
@@ -5015,13 +5021,13 @@ static int efx_ef10_filter_insert_addr_l
 		efx_filter_init_rx(&spec, EFX_FILTER_PRI_AUTO, filter_flags, 0);
 		eth_broadcast_addr(baddr);
 		efx_filter_set_eth_local(&spec, vlan->vid, baddr);
-		rc = efx_ef10_filter_insert_locked(efx, &spec, true);
+		rc = efx_mcdi_filter_insert_locked(efx, &spec, true);
 		if (rc < 0) {
 			netif_warn(efx, drv, efx->net_dev,
 				   "Broadcast filter insert failed rc=%d\n", rc);
 			/* Fall back to promiscuous */
 			for (j = 0; j < i; j++) {
-				efx_ef10_filter_remove_unsafe(
+				efx_mcdi_filter_remove_unsafe(
 					efx, EFX_FILTER_PRI_AUTO,
 					ids[j]);
 				ids[j] = EFX_EF10_FILTER_ID_INVALID;
@@ -5036,8 +5042,8 @@ static int efx_ef10_filter_insert_addr_l
 	return 0;
 }
 
-static int efx_ef10_filter_insert_def(struct efx_nic *efx,
-				      struct efx_ef10_filter_vlan *vlan,
+static int efx_mcdi_filter_insert_def(struct efx_nic *efx,
+				      struct efx_mcdi_filter_vlan *vlan,
 				      enum efx_encap_type encap_type,
 				      bool multicast, bool rollback)
 {
@@ -5071,7 +5077,7 @@ static int efx_ef10_filter_insert_def(st
 	if (vlan->vid != EFX_FILTER_VID_UNSPEC)
 		efx_filter_set_eth_local(&spec, vlan->vid, NULL);
 
-	rc = efx_ef10_filter_insert_locked(efx, &spec, true);
+	rc = efx_mcdi_filter_insert_locked(efx, &spec, true);
 	if (rc < 0) {
 		const char *um = multicast ? "Multicast" : "Unicast";
 		const char *encap_name = "";
@@ -5101,7 +5107,7 @@ static int efx_ef10_filter_insert_def(st
 			       encap_name, encap_ipv, um, rc);
 	} else if (multicast) {
 		/* mapping from encap types to default filter IDs (multicast) */
-		static enum efx_ef10_default_filters map[] = {
+		static enum efx_mcdi_filter_default_filters map[] = {
 			[EFX_ENCAP_TYPE_NONE] = EFX_EF10_MCDEF,
 			[EFX_ENCAP_TYPE_VXLAN] = EFX_EF10_VXLAN4_MCDEF,
 			[EFX_ENCAP_TYPE_NVGRE] = EFX_EF10_NVGRE4_MCDEF,
@@ -5131,14 +5137,14 @@ static int efx_ef10_filter_insert_def(st
 					   filter_flags, 0);
 			eth_broadcast_addr(baddr);
 			efx_filter_set_eth_local(&spec, vlan->vid, baddr);
-			rc = efx_ef10_filter_insert_locked(efx, &spec, true);
+			rc = efx_mcdi_filter_insert_locked(efx, &spec, true);
 			if (rc < 0) {
 				netif_warn(efx, drv, efx->net_dev,
 					   "Broadcast filter insert failed rc=%d\n",
 					   rc);
 				if (rollback) {
 					/* Roll back the mc_def filter */
-					efx_ef10_filter_remove_unsafe(
+					efx_mcdi_filter_remove_unsafe(
 							efx, EFX_FILTER_PRI_AUTO,
 							*id);
 					*id = EFX_EF10_FILTER_ID_INVALID;
@@ -5155,7 +5161,7 @@ static int efx_ef10_filter_insert_def(st
 		rc = 0;
 	} else {
 		/* mapping from encap types to default filter IDs (unicast) */
-		static enum efx_ef10_default_filters map[] = {
+		static enum efx_mcdi_filter_default_filters map[] = {
 			[EFX_ENCAP_TYPE_NONE] = EFX_EF10_UCDEF,
 			[EFX_ENCAP_TYPE_VXLAN] = EFX_EF10_VXLAN4_UCDEF,
 			[EFX_ENCAP_TYPE_NVGRE] = EFX_EF10_NVGRE4_UCDEF,
@@ -5184,19 +5190,19 @@ static int efx_ef10_filter_insert_def(st
 }
 
 /* Remove filters that weren't renewed. */
-static void efx_ef10_filter_remove_old(struct efx_nic *efx)
+static void efx_mcdi_filter_remove_old(struct efx_nic *efx)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
 	int remove_failed = 0;
 	int remove_noent = 0;
 	int rc;
 	int i;
 
 	down_write(&table->lock);
-	for (i = 0; i < HUNT_FILTER_TBL_ROWS; i++) {
+	for (i = 0; i < EFX_MCDI_FILTER_TBL_ROWS; i++) {
 		if (READ_ONCE(table->entry[i].spec) &
 		    EFX_EF10_FILTER_FLAG_AUTO_OLD) {
-			rc = efx_ef10_filter_remove_internal(efx,
+			rc = efx_mcdi_filter_remove_internal(efx,
 					1U << EFX_FILTER_PRI_AUTO, i, true);
 			if (rc == -ENOENT)
 				remove_noent++;
@@ -5229,7 +5235,7 @@ static int efx_ef10_vport_set_mac_addres
 	efx_device_detach_sync(efx);
 	efx_net_stop(efx->net_dev);
 	down_write(&efx->filter_sem);
-	efx_ef10_filter_table_remove(efx);
+	efx_mcdi_filter_table_remove(efx);
 	up_write(&efx->filter_sem);
 
 	rc = efx_ef10_vadaptor_free(efx, nic_data->vport_id);
@@ -5261,7 +5267,7 @@ restore_vadaptor:
 		goto reset_nic;
 restore_filters:
 	down_write(&efx->filter_sem);
-	rc2 = efx_ef10_filter_table_probe(efx);
+	rc2 = efx_mcdi_filter_table_probe(efx);
 	up_write(&efx->filter_sem);
 	if (rc2)
 		goto reset_nic;
@@ -5283,12 +5289,12 @@ reset_nic:
 }
 
 /* Caller must hold efx->filter_sem for read if race against
- * efx_ef10_filter_table_remove() is possible
+ * efx_mcdi_filter_table_remove() is possible
  */
-static void efx_ef10_filter_vlan_sync_rx_mode(struct efx_nic *efx,
-					      struct efx_ef10_filter_vlan *vlan)
+static void efx_mcdi_filter_vlan_sync_rx_mode(struct efx_nic *efx,
+					      struct efx_mcdi_filter_vlan *vlan)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
 
 	/* Do not install unspecified VID if VLAN filtering is enabled.
@@ -5299,32 +5305,32 @@ static void efx_ef10_filter_vlan_sync_rx
 
 	/* Insert/renew unicast filters */
 	if (table->uc_promisc) {
-		efx_ef10_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_NONE,
+		efx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_NONE,
 					   false, false);
-		efx_ef10_filter_insert_addr_list(efx, vlan, false, false);
+		efx_mcdi_filter_insert_addr_list(efx, vlan, false, false);
 	} else {
 		/* If any of the filters failed to insert, fall back to
 		 * promiscuous mode - add in the uc_def filter.  But keep
 		 * our individual unicast filters.
 		 */
-		if (efx_ef10_filter_insert_addr_list(efx, vlan, false, false))
-			efx_ef10_filter_insert_def(efx, vlan,
+		if (efx_mcdi_filter_insert_addr_list(efx, vlan, false, false))
+			efx_mcdi_filter_insert_def(efx, vlan,
 						   EFX_ENCAP_TYPE_NONE,
 						   false, false);
 	}
-	efx_ef10_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_VXLAN,
+	efx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_VXLAN,
 				   false, false);
-	efx_ef10_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_VXLAN |
+	efx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_VXLAN |
 					      EFX_ENCAP_FLAG_IPV6,
 				   false, false);
-	efx_ef10_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_NVGRE,
+	efx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_NVGRE,
 				   false, false);
-	efx_ef10_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_NVGRE |
+	efx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_NVGRE |
 					      EFX_ENCAP_FLAG_IPV6,
 				   false, false);
-	efx_ef10_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_GENEVE,
+	efx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_GENEVE,
 				   false, false);
-	efx_ef10_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_GENEVE |
+	efx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_GENEVE |
 					      EFX_ENCAP_FLAG_IPV6,
 				   false, false);
 
@@ -5334,18 +5340,18 @@ static void efx_ef10_filter_vlan_sync_rx
 	 */
 	if (nic_data->workaround_26807 &&
 	    table->mc_promisc_last != table->mc_promisc)
-		efx_ef10_filter_remove_old(efx);
+		efx_mcdi_filter_remove_old(efx);
 	if (table->mc_promisc) {
 		if (nic_data->workaround_26807) {
 			/* If we failed to insert promiscuous filters, rollback
 			 * and fall back to individual multicast filters
 			 */
-			if (efx_ef10_filter_insert_def(efx, vlan,
+			if (efx_mcdi_filter_insert_def(efx, vlan,
 						       EFX_ENCAP_TYPE_NONE,
 						       true, true)) {
 				/* Changing promisc state, so remove old filters */
-				efx_ef10_filter_remove_old(efx);
-				efx_ef10_filter_insert_addr_list(efx, vlan,
+				efx_mcdi_filter_remove_old(efx);
+				efx_mcdi_filter_insert_addr_list(efx, vlan,
 								 true, false);
 			}
 		} else {
@@ -5353,11 +5359,11 @@ static void efx_ef10_filter_vlan_sync_rx
 			 * rollback.  Regardless, also insert the mc_list,
 			 * unless it's incomplete due to overflow
 			 */
-			efx_ef10_filter_insert_def(efx, vlan,
+			efx_mcdi_filter_insert_def(efx, vlan,
 						   EFX_ENCAP_TYPE_NONE,
 						   true, false);
 			if (!table->mc_overflow)
-				efx_ef10_filter_insert_addr_list(efx, vlan,
+				efx_mcdi_filter_insert_addr_list(efx, vlan,
 								 true, false);
 		}
 	} else {
@@ -5366,42 +5372,42 @@ static void efx_ef10_filter_vlan_sync_rx
 		 * that fails, roll back again and insert as many of our
 		 * individual multicast filters as we can.
 		 */
-		if (efx_ef10_filter_insert_addr_list(efx, vlan, true, true)) {
+		if (efx_mcdi_filter_insert_addr_list(efx, vlan, true, true)) {
 			/* Changing promisc state, so remove old filters */
 			if (nic_data->workaround_26807)
-				efx_ef10_filter_remove_old(efx);
-			if (efx_ef10_filter_insert_def(efx, vlan,
+				efx_mcdi_filter_remove_old(efx);
+			if (efx_mcdi_filter_insert_def(efx, vlan,
 						       EFX_ENCAP_TYPE_NONE,
 						       true, true))
-				efx_ef10_filter_insert_addr_list(efx, vlan,
+				efx_mcdi_filter_insert_addr_list(efx, vlan,
 								 true, false);
 		}
 	}
-	efx_ef10_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_VXLAN,
+	efx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_VXLAN,
 				   true, false);
-	efx_ef10_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_VXLAN |
+	efx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_VXLAN |
 					      EFX_ENCAP_FLAG_IPV6,
 				   true, false);
-	efx_ef10_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_NVGRE,
+	efx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_NVGRE,
 				   true, false);
-	efx_ef10_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_NVGRE |
+	efx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_NVGRE |
 					      EFX_ENCAP_FLAG_IPV6,
 				   true, false);
-	efx_ef10_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_GENEVE,
+	efx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_GENEVE,
 				   true, false);
-	efx_ef10_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_GENEVE |
+	efx_mcdi_filter_insert_def(efx, vlan, EFX_ENCAP_TYPE_GENEVE |
 					      EFX_ENCAP_FLAG_IPV6,
 				   true, false);
 }
 
 /* Caller must hold efx->filter_sem for read if race against
- * efx_ef10_filter_table_remove() is possible
+ * efx_mcdi_filter_table_remove() is possible
  */
-static void efx_ef10_filter_sync_rx_mode(struct efx_nic *efx)
+static void efx_mcdi_filter_sync_rx_mode(struct efx_nic *efx)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
 	struct net_device *net_dev = efx->net_dev;
-	struct efx_ef10_filter_vlan *vlan;
+	struct efx_mcdi_filter_vlan *vlan;
 	bool vlan_filter;
 
 	if (!efx_dev_registered(efx))
@@ -5410,14 +5416,14 @@ static void efx_ef10_filter_sync_rx_mode
 	if (!table)
 		return;
 
-	efx_ef10_filter_mark_old(efx);
+	efx_mcdi_filter_mark_old(efx);
 
 	/* Copy/convert the address lists; add the primary station
 	 * address and broadcast address
 	 */
 	netif_addr_lock_bh(net_dev);
-	efx_ef10_filter_uc_addr_list(efx);
-	efx_ef10_filter_mc_addr_list(efx);
+	efx_mcdi_filter_uc_addr_list(efx);
+	efx_mcdi_filter_mc_addr_list(efx);
 	netif_addr_unlock_bh(net_dev);
 
 	/* If VLAN filtering changes, all old filters are finally removed.
@@ -5427,20 +5433,20 @@ static void efx_ef10_filter_sync_rx_mode
 	vlan_filter = !!(net_dev->features & NETIF_F_HW_VLAN_CTAG_FILTER);
 	if (table->vlan_filter != vlan_filter) {
 		table->vlan_filter = vlan_filter;
-		efx_ef10_filter_remove_old(efx);
+		efx_mcdi_filter_remove_old(efx);
 	}
 
 	list_for_each_entry(vlan, &table->vlan_list, list)
-		efx_ef10_filter_vlan_sync_rx_mode(efx, vlan);
+		efx_mcdi_filter_vlan_sync_rx_mode(efx, vlan);
 
-	efx_ef10_filter_remove_old(efx);
+	efx_mcdi_filter_remove_old(efx);
 	table->mc_promisc_last = table->mc_promisc;
 }
 
-static struct efx_ef10_filter_vlan *efx_ef10_filter_find_vlan(struct efx_nic *efx, u16 vid)
+static struct efx_mcdi_filter_vlan *efx_mcdi_filter_find_vlan(struct efx_nic *efx, u16 vid)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
-	struct efx_ef10_filter_vlan *vlan;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_vlan *vlan;
 
 	WARN_ON(!rwsem_is_locked(&efx->filter_sem));
 
@@ -5452,16 +5458,16 @@ static struct efx_ef10_filter_vlan *efx_
 	return NULL;
 }
 
-static int efx_ef10_filter_add_vlan(struct efx_nic *efx, u16 vid)
+static int efx_mcdi_filter_add_vlan(struct efx_nic *efx, u16 vid)
 {
-	struct efx_ef10_filter_table *table = efx->filter_state;
-	struct efx_ef10_filter_vlan *vlan;
+	struct efx_mcdi_filter_table *table = efx->filter_state;
+	struct efx_mcdi_filter_vlan *vlan;
 	unsigned int i;
 
 	if (!efx_rwsem_assert_write_locked(&efx->filter_sem))
 		return -EINVAL;
 
-	vlan = efx_ef10_filter_find_vlan(efx, vid);
+	vlan = efx_mcdi_filter_find_vlan(efx, vid);
 	if (WARN_ON(vlan)) {
 		netif_err(efx, drv, efx->net_dev,
 			  "VLAN %u already added\n", vid);
@@ -5484,52 +5490,52 @@ static int efx_ef10_filter_add_vlan(stru
 	list_add_tail(&vlan->list, &table->vlan_list);
 
 	if (efx_dev_registered(efx))
-		efx_ef10_filter_vlan_sync_rx_mode(efx, vlan);
+		efx_mcdi_filter_vlan_sync_rx_mode(efx, vlan);
 
 	return 0;
 }
 
-static void efx_ef10_filter_del_vlan_internal(struct efx_nic *efx,
-					      struct efx_ef10_filter_vlan *vlan)
+static void efx_mcdi_filter_del_vlan_internal(struct efx_nic *efx,
+					      struct efx_mcdi_filter_vlan *vlan)
 {
 	unsigned int i;
 
-	/* See comment in efx_ef10_filter_table_remove() */
+	/* See comment in efx_mcdi_filter_table_remove() */
 	if (!efx_rwsem_assert_write_locked(&efx->filter_sem))
 		return;
 
 	list_del(&vlan->list);
 
 	for (i = 0; i < ARRAY_SIZE(vlan->uc); i++)
-		efx_ef10_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO,
+		efx_mcdi_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO,
 					      vlan->uc[i]);
 	for (i = 0; i < ARRAY_SIZE(vlan->mc); i++)
-		efx_ef10_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO,
+		efx_mcdi_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO,
 					      vlan->mc[i]);
 	for (i = 0; i < EFX_EF10_NUM_DEFAULT_FILTERS; i++)
 		if (vlan->default_filters[i] != EFX_EF10_FILTER_ID_INVALID)
-			efx_ef10_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO,
+			efx_mcdi_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO,
 						      vlan->default_filters[i]);
 
 	kfree(vlan);
 }
 
-static void efx_ef10_filter_del_vlan(struct efx_nic *efx, u16 vid)
+static void efx_mcdi_filter_del_vlan(struct efx_nic *efx, u16 vid)
 {
-	struct efx_ef10_filter_vlan *vlan;
+	struct efx_mcdi_filter_vlan *vlan;
 
-	/* See comment in efx_ef10_filter_table_remove() */
+	/* See comment in efx_mcdi_filter_table_remove() */
 	if (!efx_rwsem_assert_write_locked(&efx->filter_sem))
 		return;
 
-	vlan = efx_ef10_filter_find_vlan(efx, vid);
+	vlan = efx_mcdi_filter_find_vlan(efx, vid);
 	if (!vlan) {
 		netif_err(efx, drv, efx->net_dev,
 			  "VLAN %u not found in filter state\n", vid);
 		return;
 	}
 
-	efx_ef10_filter_del_vlan_internal(efx, vlan);
+	efx_mcdi_filter_del_vlan_internal(efx, vlan);
 }
 
 static int efx_ef10_set_mac_address(struct efx_nic *efx)
@@ -5544,7 +5550,7 @@ static int efx_ef10_set_mac_address(stru
 
 	mutex_lock(&efx->mac_lock);
 	down_write(&efx->filter_sem);
-	efx_ef10_filter_table_remove(efx);
+	efx_mcdi_filter_table_remove(efx);
 
 	ether_addr_copy(MCDI_PTR(inbuf, VADAPTOR_SET_MAC_IN_MACADDR),
 			efx->net_dev->dev_addr);
@@ -5553,7 +5559,7 @@ static int efx_ef10_set_mac_address(stru
 	rc = efx_mcdi_rpc_quiet(efx, MC_CMD_VADAPTOR_SET_MAC, inbuf,
 				sizeof(inbuf), NULL, 0, NULL);
 
-	efx_ef10_filter_table_probe(efx);
+	efx_mcdi_filter_table_probe(efx);
 	up_write(&efx->filter_sem);
 	mutex_unlock(&efx->mac_lock);
 
@@ -5615,14 +5621,14 @@ static int efx_ef10_set_mac_address(stru
 
 static int efx_ef10_mac_reconfigure(struct efx_nic *efx)
 {
-	efx_ef10_filter_sync_rx_mode(efx);
+	efx_mcdi_filter_sync_rx_mode(efx);
 
 	return efx_mcdi_set_mac(efx);
 }
 
 static int efx_ef10_mac_reconfigure_vf(struct efx_nic *efx)
 {
-	efx_ef10_filter_sync_rx_mode(efx);
+	efx_mcdi_filter_sync_rx_mode(efx);
 
 	return 0;
 }
@@ -6337,8 +6343,8 @@ const struct efx_nic_type efx_hunt_a0_vf
 	.tx_remove = efx_mcdi_tx_remove,
 	.tx_write = efx_ef10_tx_write,
 	.tx_limit_len = efx_ef10_tx_limit_len,
-	.rx_push_rss_config = efx_ef10_vf_rx_push_rss_config,
-	.rx_pull_rss_config = efx_ef10_rx_pull_rss_config,
+	.rx_push_rss_config = efx_mcdi_vf_rx_push_rss_config,
+	.rx_pull_rss_config = efx_mcdi_rx_pull_rss_config,
 	.rx_probe = efx_mcdi_rx_probe,
 	.rx_init = efx_mcdi_rx_init,
 	.rx_remove = efx_mcdi_rx_remove,
@@ -6351,19 +6357,19 @@ const struct efx_nic_type efx_hunt_a0_vf
 	.ev_process = efx_ef10_ev_process,
 	.ev_read_ack = efx_ef10_ev_read_ack,
 	.ev_test_generate = efx_ef10_ev_test_generate,
-	.filter_table_probe = efx_ef10_filter_table_probe,
-	.filter_table_restore = efx_ef10_filter_table_restore,
-	.filter_table_remove = efx_ef10_filter_table_remove,
-	.filter_update_rx_scatter = efx_ef10_filter_update_rx_scatter,
-	.filter_insert = efx_ef10_filter_insert,
-	.filter_remove_safe = efx_ef10_filter_remove_safe,
-	.filter_get_safe = efx_ef10_filter_get_safe,
-	.filter_clear_rx = efx_ef10_filter_clear_rx,
-	.filter_count_rx_used = efx_ef10_filter_count_rx_used,
-	.filter_get_rx_id_limit = efx_ef10_filter_get_rx_id_limit,
-	.filter_get_rx_ids = efx_ef10_filter_get_rx_ids,
+	.filter_table_probe = efx_mcdi_filter_table_probe,
+	.filter_table_restore = efx_mcdi_filter_table_restore,
+	.filter_table_remove = efx_mcdi_filter_table_remove,
+	.filter_update_rx_scatter = efx_mcdi_update_rx_scatter,
+	.filter_insert = efx_mcdi_filter_insert,
+	.filter_remove_safe = efx_mcdi_filter_remove_safe,
+	.filter_get_safe = efx_mcdi_filter_get_safe,
+	.filter_clear_rx = efx_mcdi_filter_clear_rx,
+	.filter_count_rx_used = efx_mcdi_filter_count_rx_used,
+	.filter_get_rx_id_limit = efx_mcdi_filter_get_rx_id_limit,
+	.filter_get_rx_ids = efx_mcdi_filter_get_rx_ids,
 #ifdef CONFIG_RFS_ACCEL
-	.filter_rfs_expire_one = efx_ef10_filter_rfs_expire_one,
+	.filter_rfs_expire_one = efx_mcdi_filter_rfs_expire_one,
 #endif
 #ifdef CONFIG_SFC_MTD
 	.mtd_probe = efx_port_dummy_op_int,
@@ -6393,7 +6399,7 @@ const struct efx_nic_type efx_hunt_a0_vf
 	.timer_period_max = 1 << ERF_DD_EVQ_IND_TIMER_VAL_WIDTH,
 	.offload_features = EF10_OFFLOAD_FEATURES,
 	.mcdi_max_ver = 2,
-	.max_rx_ip_filters = HUNT_FILTER_TBL_ROWS,
+	.max_rx_ip_filters = EFX_MCDI_FILTER_TBL_ROWS,
 	.hwtstamp_filters = 1 << HWTSTAMP_FILTER_NONE |
 			    1 << HWTSTAMP_FILTER_ALL,
 	.rx_hash_key_size = 40,
@@ -6446,11 +6452,11 @@ const struct efx_nic_type efx_hunt_a0_ni
 	.tx_remove = efx_mcdi_tx_remove,
 	.tx_write = efx_ef10_tx_write,
 	.tx_limit_len = efx_ef10_tx_limit_len,
-	.rx_push_rss_config = efx_ef10_pf_rx_push_rss_config,
-	.rx_pull_rss_config = efx_ef10_rx_pull_rss_config,
-	.rx_push_rss_context_config = efx_ef10_rx_push_rss_context_config,
-	.rx_pull_rss_context_config = efx_ef10_rx_pull_rss_context_config,
-	.rx_restore_rss_contexts = efx_ef10_rx_restore_rss_contexts,
+	.rx_push_rss_config = efx_mcdi_pf_rx_push_rss_config,
+	.rx_pull_rss_config = efx_mcdi_rx_pull_rss_config,
+	.rx_push_rss_context_config = efx_mcdi_rx_push_rss_context_config,
+	.rx_pull_rss_context_config = efx_mcdi_rx_pull_rss_context_config,
+	.rx_restore_rss_contexts = efx_mcdi_rx_restore_rss_contexts,
 	.rx_probe = efx_mcdi_rx_probe,
 	.rx_init = efx_mcdi_rx_init,
 	.rx_remove = efx_mcdi_rx_remove,
@@ -6463,19 +6469,19 @@ const struct efx_nic_type efx_hunt_a0_ni
 	.ev_process = efx_ef10_ev_process,
 	.ev_read_ack = efx_ef10_ev_read_ack,
 	.ev_test_generate = efx_ef10_ev_test_generate,
-	.filter_table_probe = efx_ef10_filter_table_probe,
-	.filter_table_restore = efx_ef10_filter_table_restore,
-	.filter_table_remove = efx_ef10_filter_table_remove,
-	.filter_update_rx_scatter = efx_ef10_filter_update_rx_scatter,
-	.filter_insert = efx_ef10_filter_insert,
-	.filter_remove_safe = efx_ef10_filter_remove_safe,
-	.filter_get_safe = efx_ef10_filter_get_safe,
-	.filter_clear_rx = efx_ef10_filter_clear_rx,
-	.filter_count_rx_used = efx_ef10_filter_count_rx_used,
-	.filter_get_rx_id_limit = efx_ef10_filter_get_rx_id_limit,
-	.filter_get_rx_ids = efx_ef10_filter_get_rx_ids,
+	.filter_table_probe = efx_mcdi_filter_table_probe,
+	.filter_table_restore = efx_mcdi_filter_table_restore,
+	.filter_table_remove = efx_mcdi_filter_table_remove,
+	.filter_update_rx_scatter = efx_mcdi_update_rx_scatter,
+	.filter_insert = efx_mcdi_filter_insert,
+	.filter_remove_safe = efx_mcdi_filter_remove_safe,
+	.filter_get_safe = efx_mcdi_filter_get_safe,
+	.filter_clear_rx = efx_mcdi_filter_clear_rx,
+	.filter_count_rx_used = efx_mcdi_filter_count_rx_used,
+	.filter_get_rx_id_limit = efx_mcdi_filter_get_rx_id_limit,
+	.filter_get_rx_ids = efx_mcdi_filter_get_rx_ids,
 #ifdef CONFIG_RFS_ACCEL
-	.filter_rfs_expire_one = efx_ef10_filter_rfs_expire_one,
+	.filter_rfs_expire_one = efx_mcdi_filter_rfs_expire_one,
 #endif
 #ifdef CONFIG_SFC_MTD
 	.mtd_probe = efx_ef10_mtd_probe,
@@ -6528,7 +6534,7 @@ const struct efx_nic_type efx_hunt_a0_ni
 	.timer_period_max = 1 << ERF_DD_EVQ_IND_TIMER_VAL_WIDTH,
 	.offload_features = EF10_OFFLOAD_FEATURES,
 	.mcdi_max_ver = 2,
-	.max_rx_ip_filters = HUNT_FILTER_TBL_ROWS,
+	.max_rx_ip_filters = EFX_MCDI_FILTER_TBL_ROWS,
 	.hwtstamp_filters = 1 << HWTSTAMP_FILTER_NONE |
 			    1 << HWTSTAMP_FILTER_ALL,
 	.rx_hash_key_size = 40,
