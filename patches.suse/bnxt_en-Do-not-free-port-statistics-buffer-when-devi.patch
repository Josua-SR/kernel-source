From: Michael Chan <michael.chan@broadcom.com>
Date: Sun, 16 Dec 2018 18:46:30 -0500
Subject: bnxt_en: Do not free port statistics buffer when device is down.
Patch-mainline: v5.0-rc1
Git-commit: fd3ab1c70e0b953f4f772142051d215bffada718
References: bsc#1104745 FATE#325918

Port statistics which include RDMA counters are useful even when the
netdevice is down.  Do not free the port statistics DMA buffers
when the netdevice is down.  This is keep the snapshot of the port
statistics and counters will just continue counting when the
netdevice goes back up.

Split the bnxt_free_stats() function into 2 functions.  The port
statistics buffers will only be freed when the netdevice is
removed.

Signed-off-by: Michael Chan <michael.chan@broadcom.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/broadcom/bnxt/bnxt.c         |   23 +++++++++++++++++++---
 drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c |    7 ++++--
 2 files changed, 25 insertions(+), 5 deletions(-)

--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -3320,9 +3320,8 @@ static int bnxt_alloc_hwrm_short_cmd_req
 	return 0;
 }
 
-static void bnxt_free_stats(struct bnxt *bp)
+static void bnxt_free_port_stats(struct bnxt *bp)
 {
-	u32 size, i;
 	struct pci_dev *pdev = bp->pdev;
 
 	bp->flags &= ~BNXT_FLAG_PORT_STATS;
@@ -3348,6 +3347,12 @@ static void bnxt_free_stats(struct bnxt
 				  bp->hw_rx_port_stats_ext_map);
 		bp->hw_rx_port_stats_ext = NULL;
 	}
+}
+
+static void bnxt_free_ring_stats(struct bnxt *bp)
+{
+	struct pci_dev *pdev = bp->pdev;
+	int size, i;
 
 	if (!bp->bnapi)
 		return;
@@ -3387,6 +3392,9 @@ static int bnxt_alloc_stats(struct bnxt
 	}
 
 	if (BNXT_PF(bp) && bp->chip_num != CHIP_NUM_58700) {
+		if (bp->hw_rx_port_stats)
+			goto alloc_ext_stats;
+
 		bp->hw_port_stats_size = sizeof(struct rx_port_stats) +
 					 sizeof(struct tx_port_stats) + 1024;
 
@@ -3403,11 +3411,15 @@ static int bnxt_alloc_stats(struct bnxt
 					   sizeof(struct rx_port_stats) + 512;
 		bp->flags |= BNXT_FLAG_PORT_STATS;
 
+alloc_ext_stats:
 		/* Display extended statistics only if FW supports it */
 		if (bp->hwrm_spec_code < 0x10804 ||
 		    bp->hwrm_spec_code == 0x10900)
 			return 0;
 
+		if (bp->hw_rx_port_stats_ext)
+			goto alloc_tx_ext_stats;
+
 		bp->hw_rx_port_stats_ext =
 			dma_zalloc_coherent(&pdev->dev,
 					    sizeof(struct rx_port_stats_ext),
@@ -3416,6 +3428,10 @@ static int bnxt_alloc_stats(struct bnxt
 		if (!bp->hw_rx_port_stats_ext)
 			return 0;
 
+alloc_tx_ext_stats:
+		if (bp->hw_tx_port_stats_ext)
+			return 0;
+
 		if (bp->hwrm_spec_code >= 0x10902) {
 			bp->hw_tx_port_stats_ext =
 				dma_zalloc_coherent(&pdev->dev,
@@ -3523,7 +3539,7 @@ static void bnxt_free_mem(struct bnxt *b
 	bnxt_free_cp_rings(bp);
 	bnxt_free_ntp_fltrs(bp, irq_re_init);
 	if (irq_re_init) {
-		bnxt_free_stats(bp);
+		bnxt_free_ring_stats(bp);
 		bnxt_free_ring_grps(bp);
 		bnxt_free_vnics(bp);
 		kfree(bp->tx_ring_map);
@@ -9864,6 +9880,7 @@ static void bnxt_remove_one(struct pci_d
 	kfree(bp->ctx);
 	bp->ctx = NULL;
 	bnxt_cleanup_pci(bp);
+	bnxt_free_port_stats(bp);
 	free_netdev(dev);
 }
 
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
@@ -433,8 +433,10 @@ static void bnxt_get_ethtool_stats(struc
 	struct bnxt *bp = netdev_priv(dev);
 	u32 stat_fields = sizeof(struct ctx_hw_stats) / 8;
 
-	if (!bp->bnapi)
-		return;
+	if (!bp->bnapi) {
+		j += BNXT_NUM_STATS * bp->cp_nr_rings + BNXT_NUM_SW_FUNC_STATS;
+		goto skip_ring_stats;
+	}
 
 	for (i = 0; i < BNXT_NUM_SW_FUNC_STATS; i++)
 		bnxt_sw_func_stats[i].counter = 0;
@@ -459,6 +461,7 @@ static void bnxt_get_ethtool_stats(struc
 	for (i = 0; i < BNXT_NUM_SW_FUNC_STATS; i++, j++)
 		buf[j] = bnxt_sw_func_stats[i].counter;
 
+skip_ring_stats:
 	if (bp->flags & BNXT_FLAG_PORT_STATS) {
 		__le64 *port_stats = (__le64 *)bp->hw_rx_port_stats;
 
