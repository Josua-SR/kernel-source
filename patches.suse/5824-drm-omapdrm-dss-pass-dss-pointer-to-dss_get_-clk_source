From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Tue, 13 Feb 2018 14:00:25 +0200
Subject: drm: omapdrm: dss: Pass DSS pointer to dss_get_*_clk_source()
Git-commit: 3cc62aadf414102785adbfc3dd2f2f3be85d60db
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

This removes the need to access the global DSS private data in those
functions (both for the current accesses and the future ones that will
be introduced when allocating the DSS device dynamically).

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/omapdrm/dss/dispc.c |   11 +++++++----
 drivers/gpu/drm/omapdrm/dss/dsi.c   |    8 +++++---
 drivers/gpu/drm/omapdrm/dss/dss.c   |   18 ++++++++++--------
 drivers/gpu/drm/omapdrm/dss/dss.h   |    8 +++++---
 4 files changed, 27 insertions(+), 18 deletions(-)

--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -165,6 +165,7 @@ struct dispc_features {
 static struct {
 	struct platform_device *pdev;
 	void __iomem    *base;
+	struct dss_device *dss;
 
 	int irq;
 	irq_handler_t user_handler;
@@ -3112,7 +3113,7 @@ static unsigned long dispc_fclk_rate(voi
 	unsigned long r;
 	enum dss_clk_source src;
 
-	src = dss_get_dispc_clk_source();
+	src = dss_get_dispc_clk_source(dispc.dss);
 
 	if (src == DSS_CLK_SRC_FCK) {
 		r = dss_get_dispc_clk_rate();
@@ -3139,7 +3140,7 @@ static unsigned long dispc_mgr_lclk_rate
 	if (!dss_mgr_is_lcd(channel))
 		return dispc_fclk_rate();
 
-	src = dss_get_lcd_clk_source(channel);
+	src = dss_get_lcd_clk_source(dispc.dss, channel);
 
 	if (src == DSS_CLK_SRC_FCK) {
 		r = dss_get_dispc_clk_rate();
@@ -3219,7 +3220,7 @@ static void dispc_dump_clocks_channel(st
 
 	seq_printf(s, "- %s -\n", mgr_desc[channel].name);
 
-	lcd_clk_src = dss_get_lcd_clk_source(channel);
+	lcd_clk_src = dss_get_lcd_clk_source(dispc.dss, channel);
 
 	seq_printf(s, "%s clk source = %s\n", mgr_desc[channel].name,
 		dss_get_clk_source_name(lcd_clk_src));
@@ -3236,7 +3237,7 @@ void dispc_dump_clocks(struct seq_file *
 {
 	int lcd;
 	u32 l;
-	enum dss_clk_source dispc_clk_src = dss_get_dispc_clk_source();
+	enum dss_clk_source dispc_clk_src = dss_get_dispc_clk_source(dispc.dss);
 
 	if (dispc_runtime_get())
 		return;
@@ -4549,12 +4550,14 @@ static int dispc_bind(struct device *dev
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	const struct soc_device_attribute *soc;
+	struct dss_device *dss = dss_get_device(master);
 	u32 rev;
 	int r = 0;
 	struct resource *dispc_mem;
 	struct device_node *np = pdev->dev.of_node;
 
 	dispc.pdev = pdev;
+	dispc.dss = dss;
 
 	spin_lock_init(&dispc.control_lock);
 
--- a/drivers/gpu/drm/omapdrm/dss/dsi.c
+++ b/drivers/gpu/drm/omapdrm/dss/dsi.c
@@ -1286,8 +1286,10 @@ static unsigned long dsi_fclk_rate(struc
 {
 	unsigned long r;
 	struct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);
+	enum dss_clk_source source;
 
-	if (dss_get_dsi_clk_source(dsi->module_id) == DSS_CLK_SRC_FCK) {
+	source = dss_get_dsi_clk_source(dsi->dss, dsi->module_id);
+	if (source == DSS_CLK_SRC_FCK) {
 		/* DSI FCLK source is DSS_CLK_FCK */
 		r = clk_get_rate(dsi->dss_clk);
 	} else {
@@ -1506,8 +1508,8 @@ static void dsi_dump_dsidev_clocks(struc
 	int dsi_module = dsi->module_id;
 	struct dss_pll *pll = &dsi->pll;
 
-	dispc_clk_src = dss_get_dispc_clk_source();
-	dsi_clk_src = dss_get_dsi_clk_source(dsi_module);
+	dispc_clk_src = dss_get_dispc_clk_source(dsi->dss);
+	dsi_clk_src = dss_get_dsi_clk_source(dsi->dss, dsi_module);
 
 	if (dsi_runtime_get(dsidev))
 		return;
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -570,25 +570,27 @@ void dss_select_lcd_clk_source(struct ds
 	dss->lcd_clk_source[idx] = clk_src;
 }
 
-enum dss_clk_source dss_get_dispc_clk_source(void)
+enum dss_clk_source dss_get_dispc_clk_source(struct dss_device *dss)
 {
-	return dss.dispc_clk_source;
+	return dss->dispc_clk_source;
 }
 
-enum dss_clk_source dss_get_dsi_clk_source(int dsi_module)
+enum dss_clk_source dss_get_dsi_clk_source(struct dss_device *dss,
+					   int dsi_module)
 {
-	return dss.dsi_clk_source[dsi_module];
+	return dss->dsi_clk_source[dsi_module];
 }
 
-enum dss_clk_source dss_get_lcd_clk_source(enum omap_channel channel)
+enum dss_clk_source dss_get_lcd_clk_source(struct dss_device *dss,
+					   enum omap_channel channel)
 {
-	if (dss.feat->has_lcd_clk_src) {
+	if (dss->feat->has_lcd_clk_src) {
 		int idx = dss_get_channel_index(channel);
-		return dss.lcd_clk_source[idx];
+		return dss->lcd_clk_source[idx];
 	} else {
 		/* LCD_CLK source is the same as DISPC_FCLK source for
 		 * OMAP2 and OMAP3 */
-		return dss.dispc_clk_source;
+		return dss->dispc_clk_source;
 	}
 }
 
--- a/drivers/gpu/drm/omapdrm/dss/dss.h
+++ b/drivers/gpu/drm/omapdrm/dss/dss.h
@@ -323,9 +323,11 @@ void dss_select_dsi_clk_source(struct ds
 void dss_select_lcd_clk_source(struct dss_device *dss,
 			       enum omap_channel channel,
 			       enum dss_clk_source clk_src);
-enum dss_clk_source dss_get_dispc_clk_source(void);
-enum dss_clk_source dss_get_dsi_clk_source(int dsi_module);
-enum dss_clk_source dss_get_lcd_clk_source(enum omap_channel channel);
+enum dss_clk_source dss_get_dispc_clk_source(struct dss_device *dss);
+enum dss_clk_source dss_get_dsi_clk_source(struct dss_device *dss,
+					   int dsi_module);
+enum dss_clk_source dss_get_lcd_clk_source(struct dss_device *dss,
+					   enum omap_channel channel);
 
 void dss_set_venc_output(enum omap_dss_venc_type type);
 void dss_set_dac_pwrdn_bgz(bool enable);
