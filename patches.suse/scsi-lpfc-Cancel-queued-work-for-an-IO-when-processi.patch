From: James Smart <jsmart2021@gmail.com>
Date: Tue, 21 May 2019 17:49:00 -0700
Subject: [PATCH] scsi: lpfc: Cancel queued work for an IO when processing a
 received ABTS
References: bsc#1136217,jsc#SLE-4722
Git-commit: 6594d31bab02e4a1d02355ff2f16a87dfc11b34f
Patch-mainline: v5.3-rc1

When queued work is executed posting a new command to the transport
the driver is reporting a null buffer.

The driver had received an ABTS which matched a command that had
been scheduled for delivery to the transport. The driver proceeded
to cancel the command, but the work item was never cancelled.

Fix by cancelling the queued work item. Also turns out the ABTS
response was not properly sending a BA_ACC, so set the flag to
send the ACC.

Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
Signed-off-by: James Smart <jsmart2021@gmail.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/lpfc/lpfc_nvmet.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/drivers/scsi/lpfc/lpfc_nvmet.c b/drivers/scsi/lpfc/lpfc_nvmet.c
index c93c64d18bae..18eae8725161 100644
--- a/drivers/scsi/lpfc/lpfc_nvmet.c
+++ b/drivers/scsi/lpfc/lpfc_nvmet.c
@@ -1765,6 +1765,7 @@ lpfc_nvmet_rcv_unsol_abort(struct lpfc_vport *vport,
 			nvmet_fc_rcv_fcp_abort(phba->targetport,
 					       &ctxp->ctx.fcp_req);
 		} else {
+			cancel_work_sync(&ctxp->ctxbuf->defer_work);
 			spin_lock_irqsave(&ctxp->ctxlock, iflag);
 			lpfc_nvmet_defer_release(phba, ctxp);
 			spin_unlock_irqrestore(&ctxp->ctxlock, iflag);
@@ -1776,7 +1777,7 @@ lpfc_nvmet_rcv_unsol_abort(struct lpfc_vport *vport,
 			lpfc_nvmet_sol_fcp_issue_abort(phba, ctxp, ctxp->sid,
 						       ctxp->oxid);
 
-		lpfc_sli4_seq_abort_rsp(vport, fc_hdr, 0);
+		lpfc_sli4_seq_abort_rsp(vport, fc_hdr, 1);
 		return 0;
 	}
 
-- 
2.16.4

