From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Fri, 2 Mar 2018 13:12:46 +0000
Subject: drm/i915/execlists: Move irq state manipulation inside irq disabled
 region
Git-commit: aebbc2d7b3887202c9b02e69e2a470901d0eda71
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Although this state (execlists->active and engine->irq_posted) itself is
not protected by the engine->timeline spinlock, it does conveniently
ensure that irqs are disabled. We can use this to protect our
manipulation of the state and so ensure that the next IRQ to arrive sees
consistent state and (hopefully) ignores the reset engine.

Suggested-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Cc: Michel Thierry <michel.thierry@intel.com>
Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20180302131246.22036-1-chris@chris-wilson.co.uk

Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/i915/intel_lrc.c |    8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

--- a/drivers/gpu/drm/i915/intel_lrc.c
+++ b/drivers/gpu/drm/i915/intel_lrc.c
@@ -1618,10 +1618,10 @@ static void reset_common_ring(struct int
 	GEM_TRACE("%s seqno=%x\n",
 		  engine->name, request ? request->global_seqno : 0);
 
-	reset_irq(engine);
-
 	spin_lock_irqsave(&engine->timeline->lock, flags);
 
+	reset_irq(engine);
+
 	/*
 	 * Catch up with any missed context-switch interrupts.
 	 *
@@ -1636,11 +1636,11 @@ static void reset_common_ring(struct int
 	/* Push back any incomplete requests for replay after the reset. */
 	__unwind_incomplete_requests(engine);
 
-	spin_unlock_irqrestore(&engine->timeline->lock, flags);
-
 	/* Mark all CS interrupts as complete */
 	execlists->active = 0;
 
+	spin_unlock_irqrestore(&engine->timeline->lock, flags);
+
 	/* If the request was innocent, we leave the request in the ELSP
 	 * and will try to replay it on restarting. The context image may
 	 * have been corrupted by the reset, in which case we may have
