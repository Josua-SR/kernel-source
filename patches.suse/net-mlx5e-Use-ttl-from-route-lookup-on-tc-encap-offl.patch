From: Or Gerlitz <ogerlitz@mellanox.com>
Date: Tue, 24 Jul 2018 13:59:33 +0300
Subject: net/mlx5e: Use ttl from route lookup on tc encap offload only if
 needed
Patch-mainline: v4.19-rc1
Git-commit: 6360cd625e88a557f823001a796ca9e6065b3f0e
References: bsc#1103990 FATE#326006

Currnetly, the ttl for the encapsulation headers is taken from the
route lookup result. As a pre-step to allow for an offload case when
the user specifies the ttl, take it from the route lookup only if
not zero. While here, also move to use u8 instead int for the ttl.

Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
Reviewed-by: Roi Dayan <roid@mellanox.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/mellanox/mlx5/core/en_tc.c |   27 +++++++++++++++---------
 1 file changed, 17 insertions(+), 10 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@ -2129,7 +2129,7 @@ static int mlx5e_route_lookup_ipv4(struc
 				   struct net_device **out_dev,
 				   struct flowi4 *fl4,
 				   struct neighbour **out_n,
-				   int *out_ttl)
+				   u8 *out_ttl)
 {
 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 	struct mlx5e_rep_priv *uplink_rpriv;
@@ -2153,7 +2153,8 @@ static int mlx5e_route_lookup_ipv4(struc
 	else
 		*out_dev = rt->dst.dev;
 
-	*out_ttl = ip4_dst_hoplimit(&rt->dst);
+	if (!(*out_ttl))
+		*out_ttl = ip4_dst_hoplimit(&rt->dst);
 	n = dst_neigh_lookup(&rt->dst, &fl4->daddr);
 	ip_rt_put(rt);
 	if (!n)
@@ -2182,7 +2183,7 @@ static int mlx5e_route_lookup_ipv6(struc
 				   struct net_device **out_dev,
 				   struct flowi6 *fl6,
 				   struct neighbour **out_n,
-				   int *out_ttl)
+				   u8 *out_ttl)
 {
 	struct neighbour *n = NULL;
 	struct dst_entry *dst;
@@ -2197,7 +2198,8 @@ static int mlx5e_route_lookup_ipv6(struc
 	if (ret < 0)
 		return ret;
 
-	*out_ttl = ip6_dst_hoplimit(dst);
+	if (!(*out_ttl))
+		*out_ttl = ip6_dst_hoplimit(dst);
 
 	uplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);
 	/* if the egress device isn't on the same HW e-switch, we use the uplink */
@@ -2221,7 +2223,7 @@ static int mlx5e_route_lookup_ipv6(struc
 static void gen_vxlan_header_ipv4(struct net_device *out_dev,
 				  char buf[], int encap_size,
 				  unsigned char h_dest[ETH_ALEN],
-				  int ttl,
+				  u8 ttl,
 				  __be32 daddr,
 				  __be32 saddr,
 				  __be16 udp_dst_port,
@@ -2254,7 +2256,7 @@ static void gen_vxlan_header_ipv4(struct
 static void gen_vxlan_header_ipv6(struct net_device *out_dev,
 				  char buf[], int encap_size,
 				  unsigned char h_dest[ETH_ALEN],
-				  int ttl,
+				  u8 ttl,
 				  struct in6_addr *daddr,
 				  struct in6_addr *saddr,
 				  __be16 udp_dst_port,
@@ -2294,8 +2296,8 @@ static int mlx5e_create_encap_header_ipv
 	struct neighbour *n = NULL;
 	struct flowi4 fl4 = {};
 	char *encap_header;
-	int ttl, err;
-	u8 nud_state;
+	u8 nud_state, ttl;
+	int err;
 
 	if (max_encap_size < ipv4_encap_size) {
 		mlx5_core_warn(priv->mdev, "encap size %d too big, max supported is %d\n",
@@ -2316,6 +2318,9 @@ static int mlx5e_create_encap_header_ipv
 		err = -EOPNOTSUPP;
 		goto free_encap;
 	}
+
+	ttl = 0;
+
 	fl4.flowi4_tos = tun_key->tos;
 	fl4.daddr = tun_key->u.ipv4.dst;
 	fl4.saddr = tun_key->u.ipv4.src;
@@ -2399,8 +2404,8 @@ static int mlx5e_create_encap_header_ipv
 	struct neighbour *n = NULL;
 	struct flowi6 fl6 = {};
 	char *encap_header;
-	int err, ttl = 0;
-	u8 nud_state;
+	u8 ttl, nud_state;
+	int err;
 
 	if (max_encap_size < ipv6_encap_size) {
 		mlx5_core_warn(priv->mdev, "encap size %d too big, max supported is %d\n",
@@ -2422,6 +2427,8 @@ static int mlx5e_create_encap_header_ipv
 		goto free_encap;
 	}
 
+	ttl = 0;
+
 	fl6.flowlabel = ip6_make_flowinfo(RT_TOS(tun_key->tos), tun_key->label);
 	fl6.daddr = tun_key->u.ipv6.dst;
 	fl6.saddr = tun_key->u.ipv6.src;
