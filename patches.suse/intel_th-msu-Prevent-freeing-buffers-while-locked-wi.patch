From ed5207afc580937cd6cc671357fe1119f1b5b0f5 Mon Sep 17 00:00:00 2001
From: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date: Fri, 5 Jul 2019 17:14:24 +0300
Subject: [PATCH] intel_th: msu: Prevent freeing buffers while locked windows exist
Git-commit: ed5207afc580937cd6cc671357fe1119f1b5b0f5
Patch-mainline: v5.4-rc1
References: jsc#SLE-12705

We already prevent freeing buffers via sysfs interface in case there are
existing users or if trace is active. Treat the existence of locked windows
similarly and return -EBUSY on attempts to free the buffer. When the last
window is unlocked, the freeing will succeed.

Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Link: https://lore.kernel.org/r/20190705141425.19894-5-alexander.shishkin@linux.intel.com
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/hwtracing/intel_th/msu.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/drivers/hwtracing/intel_th/msu.c b/drivers/hwtracing/intel_th/msu.c
index a6c0eb09c515..b200d9d1c7a0 100644
--- a/drivers/hwtracing/intel_th/msu.c
+++ b/drivers/hwtracing/intel_th/msu.c
@@ -724,6 +724,11 @@ static int msc_win_set_lockout(struct msc_window *win,
 
 	win->lockout = new;
 
+	if (old == expect && new == WIN_LOCKED)
+		atomic_inc(&win->msc->user_count);
+	else if (old == expect && old == WIN_LOCKED)
+		atomic_dec(&win->msc->user_count);
+
 unlock:
 	spin_unlock_irqrestore(&win->lo_lock, flags);
 
-- 
2.16.4

