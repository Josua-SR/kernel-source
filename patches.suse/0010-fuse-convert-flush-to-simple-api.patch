From: Miklos Szeredi <mszeredi@redhat.com>
Date: Tue, 10 Sep 2019 15:04:08 +0200
Subject: fuse: convert flush to simple api
Git-commit: c500ebaa908dbf6b3c562778a25d7e945b04f40f
Patch-mainline: v5.4-rc1
References: jsc#SLE-13782

Add 'force' to fuse_args and use fuse_get_req_nofail_nopages() to allocate
the request in that case.

Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Acked-by: Luis Henriques <lhenriques@suse.com>
---
 fs/fuse/dev.c    | 13 +++++++++----
 fs/fuse/file.c   | 20 +++++++++-----------
 fs/fuse/fuse_i.h |  6 +-----
 3 files changed, 19 insertions(+), 20 deletions(-)

diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c
index 7833aee97565..a7be13b5d6ef 100644
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@ -255,7 +255,7 @@ EXPORT_SYMBOL_GPL(fuse_get_req_for_background);
  * filesystem should not have it's own file open.  If deadlock is
  * intentional, it can still be broken by "aborting" the filesystem.
  */
-struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc)
+static struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc)
 {
 	struct fuse_req *req;
 
@@ -570,9 +570,14 @@ ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)
 	struct fuse_req *req;
 	ssize_t ret;
 
-	req = fuse_get_req(fc, 0);
-	if (IS_ERR(req))
-		return PTR_ERR(req);
+	if (args->force) {
+		req = fuse_get_req_nofail_nopages(fc);
+		__set_bit(FR_FORCE, &req->flags);
+	} else {
+		req = fuse_get_req(fc, 0);
+		if (IS_ERR(req))
+			return PTR_ERR(req);
+	}
 
 	/* Needs to be done after fuse_get_req() so that fc->minor is valid */
 	fuse_adjust_compat(fc, args);
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 7d12c1d27132..f404e15357a6 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -410,8 +410,8 @@ static int fuse_flush(struct file *file, fl_owner_t id)
 	struct inode *inode = file_inode(file);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_file *ff = file->private_data;
-	struct fuse_req *req;
 	struct fuse_flush_in inarg;
+	FUSE_ARGS(args);
 	int err;
 
 	if (is_bad_inode(inode))
@@ -432,19 +432,17 @@ static int fuse_flush(struct file *file, fl_owner_t id)
 	if (err)
 		return err;
 
-	req = fuse_get_req_nofail_nopages(fc);
 	memset(&inarg, 0, sizeof(inarg));
 	inarg.fh = ff->fh;
 	inarg.lock_owner = fuse_lock_owner_id(fc, id);
-	req->in.h.opcode = FUSE_FLUSH;
-	req->in.h.nodeid = get_node_id(inode);
-	req->in.numargs = 1;
-	req->in.args[0].size = sizeof(inarg);
-	req->in.args[0].value = &inarg;
-	__set_bit(FR_FORCE, &req->flags);
-	fuse_request_send(fc, req);
-	err = req->out.h.error;
-	fuse_put_request(fc, req);
+	args.opcode = FUSE_FLUSH;
+	args.nodeid = get_node_id(inode);
+	args.in_numargs = 1;
+	args.in_args[0].size = sizeof(inarg);
+	args.in_args[0].value = &inarg;
+	args.force = true;
+
+	err = fuse_simple_request(fc, &args);
 	if (err == -ENOSYS) {
 		fc->no_flush = 1;
 		err = 0;
diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index dd199391d6b9..24269f470c0e 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -291,6 +291,7 @@ struct fuse_args {
 	uint32_t opcode;
 	unsigned short in_numargs;
 	unsigned short out_numargs;
+	bool force:1;
 	bool out_argvar:1;
 	struct fuse_in_arg in_args[3];
 	struct fuse_arg out_args[2];
@@ -919,11 +920,6 @@ struct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,
  */
 void __fuse_get_request(struct fuse_req *req);
 
-/**
- * Gets a requests for a file operation, always succeeds
- */
-struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc);
-
 /**
  * Decrement reference count of a request.  If count goes to zero free
  * the request.

