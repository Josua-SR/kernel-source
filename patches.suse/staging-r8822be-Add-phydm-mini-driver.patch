From 9ce99b04b5b82fdf11e4c76b60a5f82c1e541297 Mon Sep 17 00:00:00 2001
From: Ping-Ke Shih <pkshih@realtek.com>
Date: Thu, 17 Aug 2017 12:46:49 -0500
Subject: [PATCH] staging: r8822be: Add phydm mini driver
Git-commit: 9ce99b04b5b82fdf11e4c76b60a5f82c1e541297
Patch-mainline: v4.14-rc1
References: FATE#326887

The RTL8822BE, an 802.11ac wireless network card, is now appearing in
new computers. Its driver is being placed in staging to reduce the time
that users of this new card will have access to in-kernel drivers.

New Realtek wireless devices have a new method for PHY control and
dynamic management. The RTL8822BE is the first of these devices, thus
there is additional code required.

In the final version, this code will be a separate module; however,
it is combined with the r8822be driver to minimize the interference
with the drivers in the wireless tree.

Signed-off-by: Ping-Ke Shih <pkshih@realtek.com>
Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
Cc: Yan-Hsuan Chuang <yhchuang@realtek.com>
Cc: Birming Chiu <birming@realtek.com>
Cc: Shaofu <shaofu@realtek.com>
Cc: Steven Ting <steventing@realtek.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/staging/rtlwifi/phydm/halphyrf_ce.c   |  965 ++++
 drivers/staging/rtlwifi/phydm/halphyrf_ce.h   |   85 +
 drivers/staging/rtlwifi/phydm/mp_precomp.h    |   24 +
 drivers/staging/rtlwifi/phydm/phydm.c         | 1986 +++++++
 drivers/staging/rtlwifi/phydm/phydm.h         |  946 ++++
 drivers/staging/rtlwifi/phydm/phydm_acs.c     |  200 +
 drivers/staging/rtlwifi/phydm/phydm_acs.h     |   57 +
 .../staging/rtlwifi/phydm/phydm_adaptivity.c  |  941 ++++
 .../staging/rtlwifi/phydm/phydm_adaptivity.h  |  119 +
 .../rtlwifi/phydm/phydm_adc_sampling.c        |  628 +++
 .../rtlwifi/phydm/phydm_adc_sampling.h        |   96 +
 drivers/staging/rtlwifi/phydm/phydm_antdiv.c  |   83 +
 drivers/staging/rtlwifi/phydm/phydm_antdiv.h  |  301 ++
 .../staging/rtlwifi/phydm/phydm_beamforming.h |   48 +
 drivers/staging/rtlwifi/phydm/phydm_ccx.c     |  457 ++
 drivers/staging/rtlwifi/phydm/phydm_ccx.h     |   83 +
 .../staging/rtlwifi/phydm/phydm_cfotracking.c |  343 ++
 .../staging/rtlwifi/phydm/phydm_cfotracking.h |   60 +
 drivers/staging/rtlwifi/phydm/phydm_debug.c   | 2910 ++++++++++
 drivers/staging/rtlwifi/phydm/phydm_debug.h   |  175 +
 drivers/staging/rtlwifi/phydm/phydm_dfs.h     |   59 +
 drivers/staging/rtlwifi/phydm/phydm_dig.c     | 1535 ++++++
 drivers/staging/rtlwifi/phydm/phydm_dig.h     |  241 +
 .../rtlwifi/phydm/phydm_dynamic_rx_path.h     |   37 +
 .../phydm/phydm_dynamicbbpowersaving.c        |  129 +
 .../phydm/phydm_dynamicbbpowersaving.h        |   50 +
 .../rtlwifi/phydm/phydm_dynamictxpower.c      |  102 +
 .../rtlwifi/phydm/phydm_dynamictxpower.h      |   64 +
 .../rtlwifi/phydm/phydm_edcaturbocheck.c      |  139 +
 .../rtlwifi/phydm/phydm_edcaturbocheck.h      |   44 +
 .../staging/rtlwifi/phydm/phydm_features.h    |   33 +
 .../staging/rtlwifi/phydm/phydm_hwconfig.c    | 1928 +++++++
 .../staging/rtlwifi/phydm/phydm_hwconfig.h    |  510 ++
 .../staging/rtlwifi/phydm/phydm_interface.c   |  341 ++
 .../staging/rtlwifi/phydm/phydm_interface.h   |  205 +
 drivers/staging/rtlwifi/phydm/phydm_iqk.h     |   76 +
 drivers/staging/rtlwifi/phydm/phydm_kfree.c   |  228 +
 drivers/staging/rtlwifi/phydm/phydm_kfree.h   |   42 +
 .../rtlwifi/phydm/phydm_noisemonitor.c        |  330 ++
 .../rtlwifi/phydm/phydm_noisemonitor.h        |   46 +
 .../rtlwifi/phydm/phydm_powertracking_ce.c    |  644 +++
 .../rtlwifi/phydm/phydm_powertracking_ce.h    |  293 +
 .../staging/rtlwifi/phydm/phydm_pre_define.h  |  613 +++
 drivers/staging/rtlwifi/phydm/phydm_precomp.h |   85 +
 drivers/staging/rtlwifi/phydm/phydm_psd.c     |  422 ++
 drivers/staging/rtlwifi/phydm/phydm_psd.h     |   67 +
 drivers/staging/rtlwifi/phydm/phydm_rainfo.c  | 1208 +++++
 drivers/staging/rtlwifi/phydm/phydm_rainfo.h  |  269 +
 drivers/staging/rtlwifi/phydm/phydm_reg.h     |  151 +
 .../rtlwifi/phydm/phydm_regdefine11ac.h       |   94 +
 .../rtlwifi/phydm/phydm_regdefine11n.h        |  213 +
 drivers/staging/rtlwifi/phydm/phydm_types.h   |  130 +
 .../rtlwifi/phydm/rtl8822b/halhwimg8822b_bb.c | 1969 +++++++
 .../rtlwifi/phydm/rtl8822b/halhwimg8822b_bb.h |   54 +
 .../phydm/rtl8822b/halhwimg8822b_mac.c        |  222 +
 .../phydm/rtl8822b/halhwimg8822b_mac.h        |   38 +
 .../rtlwifi/phydm/rtl8822b/halhwimg8822b_rf.c | 4744 +++++++++++++++++
 .../rtlwifi/phydm/rtl8822b/halhwimg8822b_rf.h |  129 +
 .../rtlwifi/phydm/rtl8822b/halphyrf_8822b.c   |  351 ++
 .../rtlwifi/phydm/rtl8822b/halphyrf_8822b.h   |   45 +
 .../phydm/rtl8822b/phydm_hal_api8822b.c       | 1815 +++++++
 .../phydm/rtl8822b/phydm_hal_api8822b.h       |   84 +
 .../rtlwifi/phydm/rtl8822b/phydm_iqk_8822b.c  | 1410 +++++
 .../rtlwifi/phydm/rtl8822b/phydm_iqk_8822b.h  |   48 +
 .../phydm/rtl8822b/phydm_regconfig8822b.c     |  168 +
 .../phydm/rtl8822b/phydm_regconfig8822b.h     |   54 +
 .../rtlwifi/phydm/rtl8822b/phydm_rtl8822b.c   |  225 +
 .../rtlwifi/phydm/rtl8822b/phydm_rtl8822b.h   |   30 +
 .../rtlwifi/phydm/rtl8822b/version_rtl8822b.h |   34 +
 drivers/staging/rtlwifi/phydm/rtl_phydm.c     |  874 +++
 drivers/staging/rtlwifi/phydm/rtl_phydm.h     |   45 +
 .../staging/rtlwifi/phydm/txbf/halcomtxbf.h   |   67 +
 .../staging/rtlwifi/phydm/txbf/haltxbf8822b.h |   39 +
 .../rtlwifi/phydm/txbf/haltxbfinterface.h     |   38 +
 .../rtlwifi/phydm/txbf/haltxbfjaguar.h        |   36 +
 .../rtlwifi/phydm/txbf/phydm_hal_txbf_api.h   |   41 +
 76 files changed, 33395 insertions(+)
 create mode 100644 drivers/staging/rtlwifi/phydm/halphyrf_ce.c
 create mode 100644 drivers/staging/rtlwifi/phydm/halphyrf_ce.h
 create mode 100644 drivers/staging/rtlwifi/phydm/mp_precomp.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_acs.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_acs.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_adaptivity.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_adaptivity.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_adc_sampling.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_adc_sampling.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_antdiv.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_antdiv.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_beamforming.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_ccx.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_ccx.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_cfotracking.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_cfotracking.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_debug.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_debug.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_dfs.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_dig.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_dig.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_dynamic_rx_path.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_dynamicbbpowersaving.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_dynamicbbpowersaving.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_dynamictxpower.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_dynamictxpower.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_edcaturbocheck.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_edcaturbocheck.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_features.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_hwconfig.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_hwconfig.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_interface.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_interface.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_iqk.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_kfree.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_kfree.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_noisemonitor.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_noisemonitor.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_powertracking_ce.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_powertracking_ce.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_pre_define.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_precomp.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_psd.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_psd.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_rainfo.c
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_rainfo.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_reg.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_regdefine11ac.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_regdefine11n.h
 create mode 100644 drivers/staging/rtlwifi/phydm/phydm_types.h
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_bb.c
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_bb.h
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_mac.c
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_mac.h
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_rf.c
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_rf.h
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/halphyrf_8822b.c
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/halphyrf_8822b.h
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/phydm_hal_api8822b.c
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/phydm_hal_api8822b.h
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/phydm_iqk_8822b.c
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/phydm_iqk_8822b.h
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/phydm_regconfig8822b.c
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/phydm_regconfig8822b.h
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/phydm_rtl8822b.c
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/phydm_rtl8822b.h
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl8822b/version_rtl8822b.h
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl_phydm.c
 create mode 100644 drivers/staging/rtlwifi/phydm/rtl_phydm.h
 create mode 100644 drivers/staging/rtlwifi/phydm/txbf/halcomtxbf.h
 create mode 100644 drivers/staging/rtlwifi/phydm/txbf/haltxbf8822b.h
 create mode 100644 drivers/staging/rtlwifi/phydm/txbf/haltxbfinterface.h
 create mode 100644 drivers/staging/rtlwifi/phydm/txbf/haltxbfjaguar.h
 create mode 100644 drivers/staging/rtlwifi/phydm/txbf/phydm_hal_txbf_api.h

diff --git a/drivers/staging/rtlwifi/phydm/halphyrf_ce.c b/drivers/staging/rtlwifi/phydm/halphyrf_ce.c
new file mode 100644
index 000000000000..684e383201d6
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/halphyrf_ce.c
@@ -0,0 +1,965 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+#define CALCULATE_SWINGTALBE_OFFSET(_offset, _direction, _size,                \
+				    _delta_thermal)                            \
+	do {                                                                   \
+		for (_offset = 0; _offset < _size; _offset++) {                \
+			if (_delta_thermal <                                   \
+			    thermal_threshold[_direction][_offset]) {          \
+				if (_offset != 0)                              \
+					_offset--;                             \
+				break;                                         \
+			}                                                      \
+		}                                                              \
+		if (_offset >= _size)                                          \
+			_offset = _size - 1;                                   \
+	} while (0)
+
+static inline void phydm_set_calibrate_info_up(
+	struct phy_dm_struct *dm, struct txpwrtrack_cfg *c, u8 delta,
+	struct dm_rf_calibration_struct *cali_info,
+	u8 *delta_swing_table_idx_tup_a, u8 *delta_swing_table_idx_tup_b,
+	u8 *delta_swing_table_idx_tup_c, u8 *delta_swing_table_idx_tup_d)
+{
+	u8 p = 0;
+
+	for (p = ODM_RF_PATH_A; p < c->rf_path_count; p++) {
+		cali_info->delta_power_index_last[p] =
+			cali_info->delta_power_index
+				[p]; /*recording poer index offset*/
+		switch (p) {
+		case ODM_RF_PATH_B:
+			ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+				     "delta_swing_table_idx_tup_b[%d] = %d\n",
+				     delta, delta_swing_table_idx_tup_b[delta]);
+
+			cali_info->delta_power_index[p] =
+				delta_swing_table_idx_tup_b[delta];
+			/*Record delta swing for mix mode pwr tracking*/
+			cali_info->absolute_ofdm_swing_idx[p] =
+				delta_swing_table_idx_tup_b[delta];
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"******Temp is higher and cali_info->absolute_ofdm_swing_idx[ODM_RF_PATH_B] = %d\n",
+				cali_info->absolute_ofdm_swing_idx[p]);
+			break;
+
+		case ODM_RF_PATH_C:
+			ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+				     "delta_swing_table_idx_tup_c[%d] = %d\n",
+				     delta, delta_swing_table_idx_tup_c[delta]);
+
+			cali_info->delta_power_index[p] =
+				delta_swing_table_idx_tup_c[delta];
+			/*Record delta swing for mix mode pwr tracking*/
+			cali_info->absolute_ofdm_swing_idx[p] =
+				delta_swing_table_idx_tup_c[delta];
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"******Temp is higher and cali_info->absolute_ofdm_swing_idx[ODM_RF_PATH_C] = %d\n",
+				cali_info->absolute_ofdm_swing_idx[p]);
+			break;
+
+		case ODM_RF_PATH_D:
+			ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+				     "delta_swing_table_idx_tup_d[%d] = %d\n",
+				     delta, delta_swing_table_idx_tup_d[delta]);
+
+			cali_info->delta_power_index[p] =
+				delta_swing_table_idx_tup_d[delta];
+			/*Record delta swing for mix mode pwr tracking*/
+			cali_info->absolute_ofdm_swing_idx[p] =
+				delta_swing_table_idx_tup_d[delta];
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"******Temp is higher and cali_info->absolute_ofdm_swing_idx[ODM_RF_PATH_D] = %d\n",
+				cali_info->absolute_ofdm_swing_idx[p]);
+			break;
+
+		default:
+			ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+				     "delta_swing_table_idx_tup_a[%d] = %d\n",
+				     delta, delta_swing_table_idx_tup_a[delta]);
+
+			cali_info->delta_power_index[p] =
+				delta_swing_table_idx_tup_a[delta];
+			/*Record delta swing for mix mode pwr tracking*/
+			cali_info->absolute_ofdm_swing_idx[p] =
+				delta_swing_table_idx_tup_a[delta];
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"******Temp is higher and cali_info->absolute_ofdm_swing_idx[ODM_RF_PATH_A] = %d\n",
+				cali_info->absolute_ofdm_swing_idx[p]);
+			break;
+		}
+	}
+}
+
+static inline void phydm_set_calibrate_info_down(
+	struct phy_dm_struct *dm, struct txpwrtrack_cfg *c, u8 delta,
+	struct dm_rf_calibration_struct *cali_info,
+	u8 *delta_swing_table_idx_tdown_a, u8 *delta_swing_table_idx_tdown_b,
+	u8 *delta_swing_table_idx_tdown_c, u8 *delta_swing_table_idx_tdown_d)
+{
+	u8 p = 0;
+
+	for (p = ODM_RF_PATH_A; p < c->rf_path_count; p++) {
+		cali_info->delta_power_index_last[p] =
+			cali_info->delta_power_index
+				[p]; /*recording poer index offset*/
+
+		switch (p) {
+		case ODM_RF_PATH_B:
+			ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+				     "delta_swing_table_idx_tdown_b[%d] = %d\n",
+				     delta,
+				     delta_swing_table_idx_tdown_b[delta]);
+			cali_info->delta_power_index[p] =
+				-1 * delta_swing_table_idx_tdown_b[delta];
+			/*Record delta swing for mix mode pwr tracking*/
+			cali_info->absolute_ofdm_swing_idx[p] =
+				-1 * delta_swing_table_idx_tdown_b[delta];
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"******Temp is lower and cali_info->absolute_ofdm_swing_idx[ODM_RF_PATH_B] = %d\n",
+				cali_info->absolute_ofdm_swing_idx[p]);
+			break;
+
+		case ODM_RF_PATH_C:
+			ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+				     "delta_swing_table_idx_tdown_c[%d] = %d\n",
+				     delta,
+				     delta_swing_table_idx_tdown_c[delta]);
+			cali_info->delta_power_index[p] =
+				-1 * delta_swing_table_idx_tdown_c[delta];
+			/*Record delta swing for mix mode pwr tracking*/
+			cali_info->absolute_ofdm_swing_idx[p] =
+				-1 * delta_swing_table_idx_tdown_c[delta];
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"******Temp is lower and cali_info->absolute_ofdm_swing_idx[ODM_RF_PATH_C] = %d\n",
+				cali_info->absolute_ofdm_swing_idx[p]);
+			break;
+
+		case ODM_RF_PATH_D:
+			ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+				     "delta_swing_table_idx_tdown_d[%d] = %d\n",
+				     delta,
+				     delta_swing_table_idx_tdown_d[delta]);
+			cali_info->delta_power_index[p] =
+				-1 * delta_swing_table_idx_tdown_d[delta];
+			/*Record delta swing for mix mode pwr tracking*/
+			cali_info->absolute_ofdm_swing_idx[p] =
+				-1 * delta_swing_table_idx_tdown_d[delta];
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"******Temp is lower and cali_info->absolute_ofdm_swing_idx[ODM_RF_PATH_D] = %d\n",
+				cali_info->absolute_ofdm_swing_idx[p]);
+			break;
+
+		default:
+			ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+				     "delta_swing_table_idx_tdown_a[%d] = %d\n",
+				     delta,
+				     delta_swing_table_idx_tdown_a[delta]);
+			cali_info->delta_power_index[p] =
+				-1 * delta_swing_table_idx_tdown_a[delta];
+			/*Record delta swing for mix mode pwr tracking*/
+			cali_info->absolute_ofdm_swing_idx[p] =
+				-1 * delta_swing_table_idx_tdown_a[delta];
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"******Temp is lower and cali_info->absolute_ofdm_swing_idx[ODM_RF_PATH_A] = %d\n",
+				cali_info->absolute_ofdm_swing_idx[p]);
+			break;
+		}
+	}
+}
+
+static inline void phydm_odm_tx_power_set(struct phy_dm_struct *dm,
+					  struct txpwrtrack_cfg *c,
+					  u8 indexforchannel, u8 flag)
+{
+	u8 p = 0;
+
+	if (dm->support_ic_type == ODM_RTL8188E ||
+	    dm->support_ic_type == ODM_RTL8192E ||
+	    dm->support_ic_type == ODM_RTL8821 ||
+	    dm->support_ic_type == ODM_RTL8812 ||
+	    dm->support_ic_type == ODM_RTL8723B ||
+	    dm->support_ic_type == ODM_RTL8814A ||
+	    dm->support_ic_type == ODM_RTL8703B ||
+	    dm->support_ic_type == ODM_RTL8188F ||
+	    dm->support_ic_type == ODM_RTL8822B ||
+	    dm->support_ic_type == ODM_RTL8723D ||
+	    dm->support_ic_type == ODM_RTL8821C ||
+	    dm->support_ic_type == ODM_RTL8710B) { /* JJ ADD 20161014 */
+
+		ODM_RT_TRACE(
+			dm, ODM_COMP_TX_PWR_TRACK,
+			"**********Enter POWER Tracking MIX_MODE**********\n");
+		for (p = ODM_RF_PATH_A; p < c->rf_path_count; p++) {
+			if (flag == 0)
+				(*c->odm_tx_pwr_track_set_pwr)(dm, MIX_MODE, p,
+							       0);
+			else
+				(*c->odm_tx_pwr_track_set_pwr)(dm, MIX_MODE, p,
+							       indexforchannel);
+		}
+	} else {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_TX_PWR_TRACK,
+			"**********Enter POWER Tracking BBSWING_MODE**********\n");
+		for (p = ODM_RF_PATH_A; p < c->rf_path_count; p++)
+			(*c->odm_tx_pwr_track_set_pwr)(dm, BBSWING, p,
+						       indexforchannel);
+	}
+}
+
+void configure_txpower_track(void *dm_void, struct txpwrtrack_cfg *config)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	/* JJ ADD 20161014 */
+
+	if (dm->support_ic_type == ODM_RTL8822B)
+		configure_txpower_track_8822b(config);
+}
+
+/* **********************************************************************
+ * <20121113, Kordan> This function should be called when tx_agc changed.
+ * Otherwise the previous compensation is gone, because we record the
+ * delta of temperature between two TxPowerTracking watch dogs.
+ *
+ * NOTE: If Tx BB swing or Tx scaling is varified during run-time, still
+ * need to call this function.
+ * ***********************************************************************/
+void odm_clear_txpowertracking_state(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+	struct rtl_efuse *rtlefu = rtl_efuse(rtlpriv);
+	u8 p = 0;
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+
+	cali_info->bb_swing_idx_cck_base = cali_info->default_cck_index;
+	cali_info->bb_swing_idx_cck = cali_info->default_cck_index;
+	dm->rf_calibrate_info.CCK_index = 0;
+
+	for (p = ODM_RF_PATH_A; p < MAX_RF_PATH; ++p) {
+		cali_info->bb_swing_idx_ofdm_base[p] =
+			cali_info->default_ofdm_index;
+		cali_info->bb_swing_idx_ofdm[p] = cali_info->default_ofdm_index;
+		cali_info->OFDM_index[p] = cali_info->default_ofdm_index;
+
+		cali_info->power_index_offset[p] = 0;
+		cali_info->delta_power_index[p] = 0;
+		cali_info->delta_power_index_last[p] = 0;
+
+		cali_info->absolute_ofdm_swing_idx[p] =
+			0; /* Initial Mix mode power tracking*/
+		cali_info->remnant_ofdm_swing_idx[p] = 0;
+		cali_info->kfree_offset[p] = 0;
+	}
+
+	cali_info->modify_tx_agc_flag_path_a =
+		false; /*Initial at Modify Tx Scaling mode*/
+	cali_info->modify_tx_agc_flag_path_b =
+		false; /*Initial at Modify Tx Scaling mode*/
+	cali_info->modify_tx_agc_flag_path_c =
+		false; /*Initial at Modify Tx Scaling mode*/
+	cali_info->modify_tx_agc_flag_path_d =
+		false; /*Initial at Modify Tx Scaling mode*/
+	cali_info->remnant_cck_swing_idx = 0;
+	cali_info->thermal_value = rtlefu->eeprom_thermalmeter;
+
+	cali_info->modify_tx_agc_value_cck = 0; /* modify by Mingzhi.Guo */
+	cali_info->modify_tx_agc_value_ofdm = 0; /* modify by Mingzhi.Guo */
+}
+
+void odm_txpowertracking_callback_thermal_meter(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+	struct rtl_efuse *rtlefu = rtl_efuse(rtlpriv);
+	void *adapter = dm->adapter;
+
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+
+	u8 thermal_value = 0, delta, delta_LCK, delta_IQK, p = 0, i = 0;
+	s8 diff_DPK[4]; /* use 'for..loop' to initialize */
+	u8 thermal_value_avg_count = 0;
+	u32 thermal_value_avg = 0, regc80, regcd0, regcd4, regab4;
+
+	/* OFDM BB Swing should be less than +3.0dB (required by Arthur) */
+	u8 OFDM_min_index = 0;
+	/* get_right_chnl_place_for_iqk(hal_data->current_channel) */
+	u8 indexforchannel = 0;
+	u8 power_tracking_type = 0; /* no specify type */
+	u8 xtal_offset_eanble = 0;
+
+	struct txpwrtrack_cfg c;
+
+	/* 4 1. The following TWO tables decide the final index of
+	 *      OFDM/CCK swing table.
+	 */
+	u8 *delta_swing_table_idx_tup_a = NULL;
+	u8 *delta_swing_table_idx_tdown_a = NULL;
+	u8 *delta_swing_table_idx_tup_b = NULL;
+	u8 *delta_swing_table_idx_tdown_b = NULL;
+	/*for 8814 add by Yu Chen*/
+	u8 *delta_swing_table_idx_tup_c = NULL;
+	u8 *delta_swing_table_idx_tdown_c = NULL;
+	u8 *delta_swing_table_idx_tup_d = NULL;
+	u8 *delta_swing_table_idx_tdown_d = NULL;
+	/*for Xtal Offset by James.Tung*/
+	s8 *delta_swing_table_xtal_up = NULL;
+	s8 *delta_swing_table_xtal_down = NULL;
+
+	/* 4 2. Initialization ( 7 steps in total ) */
+
+	configure_txpower_track(dm, &c);
+
+	(*c.get_delta_swing_table)(dm, (u8 **)&delta_swing_table_idx_tup_a,
+				   (u8 **)&delta_swing_table_idx_tdown_a,
+				   (u8 **)&delta_swing_table_idx_tup_b,
+				   (u8 **)&delta_swing_table_idx_tdown_b);
+
+	if (dm->support_ic_type & ODM_RTL8814A) /*for 8814 path C & D*/
+		(*c.get_delta_swing_table8814only)(
+			dm, (u8 **)&delta_swing_table_idx_tup_c,
+			(u8 **)&delta_swing_table_idx_tdown_c,
+			(u8 **)&delta_swing_table_idx_tup_d,
+			(u8 **)&delta_swing_table_idx_tdown_d);
+	/* JJ ADD 20161014 */
+	if (dm->support_ic_type &
+	    (ODM_RTL8703B | ODM_RTL8723D | ODM_RTL8710B)) /*for Xtal Offset*/
+		(*c.get_delta_swing_xtal_table)(
+			dm, (s8 **)&delta_swing_table_xtal_up,
+			(s8 **)&delta_swing_table_xtal_down);
+
+	cali_info->txpowertracking_callback_cnt++; /*cosa add for debug*/
+	cali_info->is_txpowertracking_init = true;
+
+	/*cali_info->txpowertrack_control = hal_data->txpowertrack_control;
+	 *<Kordan> We should keep updating ctrl variable according to HalData.
+	 *<Kordan> rf_calibrate_info.rega24 will be initialized when
+	 *ODM HW configuring, but MP configures with para files.
+	 */
+	if (dm->mp_mode)
+		cali_info->rega24 = 0x090e1317;
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_TX_PWR_TRACK,
+		"===>%s\n cali_info->bb_swing_idx_cck_base: %d, cali_info->bb_swing_idx_ofdm_base[A]: %d, cali_info->default_ofdm_index: %d\n",
+		__func__, cali_info->bb_swing_idx_cck_base,
+		cali_info->bb_swing_idx_ofdm_base[ODM_RF_PATH_A],
+		cali_info->default_ofdm_index);
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_TX_PWR_TRACK,
+		"cali_info->txpowertrack_control=%d,  rtlefu->eeprom_thermalmeter %d\n",
+		cali_info->txpowertrack_control, rtlefu->eeprom_thermalmeter);
+
+	thermal_value =
+		(u8)odm_get_rf_reg(dm, ODM_RF_PATH_A, c.thermal_reg_addr,
+				   0xfc00); /* 0x42: RF Reg[15:10] 88E */
+
+	/*add log by zhao he, check c80/c94/c14/ca0 value*/
+	if (dm->support_ic_type == ODM_RTL8723D) {
+		regc80 = odm_get_bb_reg(dm, 0xc80, MASKDWORD);
+		regcd0 = odm_get_bb_reg(dm, 0xcd0, MASKDWORD);
+		regcd4 = odm_get_bb_reg(dm, 0xcd4, MASKDWORD);
+		regab4 = odm_get_bb_reg(dm, 0xab4, 0x000007FF);
+		ODM_RT_TRACE(
+			dm, ODM_COMP_CALIBRATION,
+			"0xc80 = 0x%x 0xcd0 = 0x%x 0xcd4 = 0x%x 0xab4 = 0x%x\n",
+			regc80, regcd0, regcd4, regab4);
+	}
+	/* JJ ADD 20161014 */
+	if (dm->support_ic_type == ODM_RTL8710B) {
+		regc80 = odm_get_bb_reg(dm, 0xc80, MASKDWORD);
+		regcd0 = odm_get_bb_reg(dm, 0xcd0, MASKDWORD);
+		regcd4 = odm_get_bb_reg(dm, 0xcd4, MASKDWORD);
+		regab4 = odm_get_bb_reg(dm, 0xab4, 0x000007FF);
+		ODM_RT_TRACE(
+			dm, ODM_COMP_CALIBRATION,
+			"0xc80 = 0x%x 0xcd0 = 0x%x 0xcd4 = 0x%x 0xab4 = 0x%x\n",
+			regc80, regcd0, regcd4, regab4);
+	}
+
+	if (!cali_info->txpowertrack_control)
+		return;
+
+	/*4 3. Initialize ThermalValues of rf_calibrate_info*/
+
+	if (cali_info->is_reloadtxpowerindex)
+		ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+			     "reload ofdm index for band switch\n");
+
+	/*4 4. Calculate average thermal meter*/
+
+	cali_info->thermal_value_avg[cali_info->thermal_value_avg_index] =
+		thermal_value;
+	cali_info->thermal_value_avg_index++;
+	if (cali_info->thermal_value_avg_index ==
+	    c.average_thermal_num) /*Average times =  c.average_thermal_num*/
+		cali_info->thermal_value_avg_index = 0;
+
+	for (i = 0; i < c.average_thermal_num; i++) {
+		if (cali_info->thermal_value_avg[i]) {
+			thermal_value_avg += cali_info->thermal_value_avg[i];
+			thermal_value_avg_count++;
+		}
+	}
+
+	if (thermal_value_avg_count) {
+		/* Calculate Average thermal_value after average enough times */
+		thermal_value =
+			(u8)(thermal_value_avg / thermal_value_avg_count);
+		cali_info->thermal_value_delta =
+			thermal_value - rtlefu->eeprom_thermalmeter;
+		ODM_RT_TRACE(
+			dm, ODM_COMP_TX_PWR_TRACK,
+			"AVG Thermal Meter = 0x%X, EFUSE Thermal base = 0x%X\n",
+			thermal_value, rtlefu->eeprom_thermalmeter);
+	}
+
+	/* 4 5. Calculate delta, delta_LCK, delta_IQK. */
+
+	/* "delta" is used to determine whether thermal value changes or not*/
+	delta = (thermal_value > cali_info->thermal_value) ?
+			(thermal_value - cali_info->thermal_value) :
+			(cali_info->thermal_value - thermal_value);
+	delta_LCK = (thermal_value > cali_info->thermal_value_lck) ?
+			    (thermal_value - cali_info->thermal_value_lck) :
+			    (cali_info->thermal_value_lck - thermal_value);
+	delta_IQK = (thermal_value > cali_info->thermal_value_iqk) ?
+			    (thermal_value - cali_info->thermal_value_iqk) :
+			    (cali_info->thermal_value_iqk - thermal_value);
+
+	if (cali_info->thermal_value_iqk ==
+	    0xff) { /*no PG, use thermal value for IQK*/
+		cali_info->thermal_value_iqk = thermal_value;
+		delta_IQK =
+			(thermal_value > cali_info->thermal_value_iqk) ?
+				(thermal_value - cali_info->thermal_value_iqk) :
+				(cali_info->thermal_value_iqk - thermal_value);
+		ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+			     "no PG, use thermal_value for IQK\n");
+	}
+
+	for (p = ODM_RF_PATH_A; p < c.rf_path_count; p++)
+		diff_DPK[p] = (s8)thermal_value - (s8)cali_info->dpk_thermal[p];
+
+	/*4 6. If necessary, do LCK.*/
+
+	if (!(dm->support_ic_type &
+	      ODM_RTL8821)) { /*no PG, do LCK at initial status*/
+		if (cali_info->thermal_value_lck == 0xff) {
+			ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+				     "no PG, do LCK\n");
+			cali_info->thermal_value_lck = thermal_value;
+
+			/*Use RTLCK, so close power tracking driver LCK*/
+			if (!(dm->support_ic_type & ODM_RTL8814A) &&
+			    c.phy_lc_calibrate)
+				(*c.phy_lc_calibrate)(dm);
+
+			delta_LCK =
+				(thermal_value > cali_info->thermal_value_lck) ?
+					(thermal_value -
+					 cali_info->thermal_value_lck) :
+					(cali_info->thermal_value_lck -
+					 thermal_value);
+		}
+
+		ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+			     "(delta, delta_LCK, delta_IQK) = (%d, %d, %d)\n",
+			     delta, delta_LCK, delta_IQK);
+
+		/*Delta temperature is equal to or larger than 20 centigrade.*/
+		if (delta_LCK >= c.threshold_iqk) {
+			ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+				     "delta_LCK(%d) >= threshold_iqk(%d)\n",
+				     delta_LCK, c.threshold_iqk);
+			cali_info->thermal_value_lck = thermal_value;
+
+			/*Use RTLCK, so close power tracking driver LCK*/
+			if (!(dm->support_ic_type & ODM_RTL8814A) &&
+			    c.phy_lc_calibrate)
+				(*c.phy_lc_calibrate)(dm);
+		}
+	}
+
+	/*3 7. If necessary, move the index of swing table to adjust Tx power.*/
+
+	if (delta > 0 && cali_info->txpowertrack_control) {
+		/* "delta" here is used to record the abs value of difference.*/
+		delta = thermal_value > rtlefu->eeprom_thermalmeter ?
+				(thermal_value - rtlefu->eeprom_thermalmeter) :
+				(rtlefu->eeprom_thermalmeter - thermal_value);
+		if (delta >= TXPWR_TRACK_TABLE_SIZE)
+			delta = TXPWR_TRACK_TABLE_SIZE - 1;
+
+		/*4 7.1 The Final Power index = BaseIndex + power_index_offset*/
+
+		if (thermal_value > rtlefu->eeprom_thermalmeter) {
+			phydm_set_calibrate_info_up(
+				dm, &c, delta, cali_info,
+				delta_swing_table_idx_tup_a,
+				delta_swing_table_idx_tup_b,
+				delta_swing_table_idx_tup_c,
+				delta_swing_table_idx_tup_d);
+			/* JJ ADD 20161014 */
+			if (dm->support_ic_type &
+			    (ODM_RTL8703B | ODM_RTL8723D | ODM_RTL8710B)) {
+				/*Save xtal_offset from Xtal table*/
+
+				/*recording last Xtal offset*/
+				cali_info->xtal_offset_last =
+					cali_info->xtal_offset;
+				ODM_RT_TRACE(
+					dm, ODM_COMP_TX_PWR_TRACK,
+					"[Xtal] delta_swing_table_xtal_up[%d] = %d\n",
+					delta,
+					delta_swing_table_xtal_up[delta]);
+				cali_info->xtal_offset =
+					delta_swing_table_xtal_up[delta];
+				xtal_offset_eanble =
+					(cali_info->xtal_offset_last ==
+					 cali_info->xtal_offset) ?
+						0 :
+						1;
+			}
+
+		} else {
+			phydm_set_calibrate_info_down(
+				dm, &c, delta, cali_info,
+				delta_swing_table_idx_tdown_a,
+				delta_swing_table_idx_tdown_b,
+				delta_swing_table_idx_tdown_c,
+				delta_swing_table_idx_tdown_d);
+			/* JJ ADD 20161014 */
+			if (dm->support_ic_type &
+			    (ODM_RTL8703B | ODM_RTL8723D | ODM_RTL8710B)) {
+				/*Save xtal_offset from Xtal table*/
+
+				/*recording last Xtal offset*/
+				cali_info->xtal_offset_last =
+					cali_info->xtal_offset;
+				ODM_RT_TRACE(
+					dm, ODM_COMP_TX_PWR_TRACK,
+					"[Xtal] delta_swing_table_xtal_down[%d] = %d\n",
+					delta,
+					delta_swing_table_xtal_down[delta]);
+				cali_info->xtal_offset =
+					delta_swing_table_xtal_down[delta];
+				xtal_offset_eanble =
+					(cali_info->xtal_offset_last ==
+					 cali_info->xtal_offset) ?
+						0 :
+						1;
+			}
+		}
+
+		for (p = ODM_RF_PATH_A; p < c.rf_path_count; p++) {
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"\n\n=========================== [path-%d] Calculating power_index_offset===========================\n",
+				p);
+
+			if (cali_info->delta_power_index[p] ==
+			    cali_info->delta_power_index_last[p]) {
+				/* If Thermal value changes but lookup table
+				 * value still the same
+				 */
+				cali_info->power_index_offset[p] = 0;
+			} else {
+				/*Power idx diff between 2 times Pwr Tracking*/
+				cali_info->power_index_offset[p] =
+					cali_info->delta_power_index[p] -
+					cali_info->delta_power_index_last[p];
+			}
+
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"[path-%d] power_index_offset(%d) = delta_power_index(%d) - delta_power_index_last(%d)\n",
+				p, cali_info->power_index_offset[p],
+				cali_info->delta_power_index[p],
+				cali_info->delta_power_index_last[p]);
+
+			cali_info->OFDM_index[p] =
+				cali_info->bb_swing_idx_ofdm_base[p] +
+				cali_info->power_index_offset[p];
+			cali_info->CCK_index =
+				cali_info->bb_swing_idx_cck_base +
+				cali_info->power_index_offset[p];
+
+			cali_info->bb_swing_idx_cck = cali_info->CCK_index;
+			cali_info->bb_swing_idx_ofdm[p] =
+				cali_info->OFDM_index[p];
+
+			/*******Print BB Swing base and index Offset**********/
+
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"The 'CCK' final index(%d) = BaseIndex(%d) + power_index_offset(%d)\n",
+				cali_info->bb_swing_idx_cck,
+				cali_info->bb_swing_idx_cck_base,
+				cali_info->power_index_offset[p]);
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"The 'OFDM' final index(%d) = BaseIndex[%d](%d) + power_index_offset(%d)\n",
+				cali_info->bb_swing_idx_ofdm[p], p,
+				cali_info->bb_swing_idx_ofdm_base[p],
+				cali_info->power_index_offset[p]);
+
+			/*4 7.1 Handle boundary conditions of index.*/
+
+			if (cali_info->OFDM_index[p] >
+			    c.swing_table_size_ofdm - 1)
+				cali_info->OFDM_index[p] =
+					c.swing_table_size_ofdm - 1;
+			else if (cali_info->OFDM_index[p] <= OFDM_min_index)
+				cali_info->OFDM_index[p] = OFDM_min_index;
+		}
+
+		ODM_RT_TRACE(
+			dm, ODM_COMP_TX_PWR_TRACK,
+			"\n\n========================================================================================================\n");
+
+		if (cali_info->CCK_index > c.swing_table_size_cck - 1)
+			cali_info->CCK_index = c.swing_table_size_cck - 1;
+		else if (cali_info->CCK_index <= 0)
+			cali_info->CCK_index = 0;
+	} else {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_TX_PWR_TRACK,
+			"The thermal meter is unchanged or TxPowerTracking OFF(%d): thermal_value: %d, cali_info->thermal_value: %d\n",
+			cali_info->txpowertrack_control, thermal_value,
+			cali_info->thermal_value);
+
+		for (p = ODM_RF_PATH_A; p < c.rf_path_count; p++)
+			cali_info->power_index_offset[p] = 0;
+	}
+
+	/*Print Swing base & current*/
+	ODM_RT_TRACE(
+		dm, ODM_COMP_TX_PWR_TRACK,
+		"TxPowerTracking: [CCK] Swing Current index: %d, Swing base index: %d\n",
+		cali_info->CCK_index, cali_info->bb_swing_idx_cck_base);
+
+	for (p = ODM_RF_PATH_A; p < c.rf_path_count; p++)
+		ODM_RT_TRACE(
+			dm, ODM_COMP_TX_PWR_TRACK,
+			"TxPowerTracking: [OFDM] Swing Current index: %d, Swing base index[%d]: %d\n",
+			cali_info->OFDM_index[p], p,
+			cali_info->bb_swing_idx_ofdm_base[p]);
+
+	if ((dm->support_ic_type & ODM_RTL8814A)) {
+		ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+			     "power_tracking_type=%d\n", power_tracking_type);
+
+		if (power_tracking_type == 0) {
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"**********Enter POWER Tracking MIX_MODE**********\n");
+			for (p = ODM_RF_PATH_A; p < c.rf_path_count; p++)
+				(*c.odm_tx_pwr_track_set_pwr)(dm, MIX_MODE, p,
+							      0);
+		} else if (power_tracking_type == 1) {
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"**********Enter POWER Tracking MIX(2G) TSSI(5G) MODE**********\n");
+			for (p = ODM_RF_PATH_A; p < c.rf_path_count; p++)
+				(*c.odm_tx_pwr_track_set_pwr)(
+					dm, MIX_2G_TSSI_5G_MODE, p, 0);
+		} else if (power_tracking_type == 2) {
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"**********Enter POWER Tracking MIX(5G) TSSI(2G)MODE**********\n");
+			for (p = ODM_RF_PATH_A; p < c.rf_path_count; p++)
+				(*c.odm_tx_pwr_track_set_pwr)(
+					dm, MIX_5G_TSSI_2G_MODE, p, 0);
+		} else if (power_tracking_type == 3) {
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"**********Enter POWER Tracking TSSI MODE**********\n");
+			for (p = ODM_RF_PATH_A; p < c.rf_path_count; p++)
+				(*c.odm_tx_pwr_track_set_pwr)(dm, TSSI_MODE, p,
+							      0);
+		}
+		/*Record last Power Tracking Thermal value*/
+		cali_info->thermal_value = thermal_value;
+
+	} else if ((cali_info->power_index_offset[ODM_RF_PATH_A] != 0 ||
+		    cali_info->power_index_offset[ODM_RF_PATH_B] != 0 ||
+		    cali_info->power_index_offset[ODM_RF_PATH_C] != 0 ||
+		    cali_info->power_index_offset[ODM_RF_PATH_D] != 0) &&
+		   cali_info->txpowertrack_control &&
+		   (rtlefu->eeprom_thermalmeter != 0xff)) {
+		/* 4 7.2 Configure the Swing Table to adjust Tx Power. */
+
+		/*Always true after Tx Power is adjusted by power tracking.*/
+		cali_info->is_tx_power_changed = true;
+		/* 2012/04/23 MH According to Luke's suggestion, we can not
+		 * write BB digital to increase TX power. Otherwise, EVM will
+		 * be bad.
+		 */
+		/* 2012/04/25 MH Add for tx power tracking to set tx power in
+		 * tx agc for 88E.
+		 */
+		if (thermal_value > cali_info->thermal_value) {
+			for (p = ODM_RF_PATH_A; p < c.rf_path_count; p++) {
+				/* print temperature increasing */
+				ODM_RT_TRACE(
+					dm, ODM_COMP_TX_PWR_TRACK,
+					"Temperature Increasing(%d): delta_pi: %d, delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n",
+					p, cali_info->power_index_offset[p],
+					delta, thermal_value,
+					rtlefu->eeprom_thermalmeter,
+					cali_info->thermal_value);
+			}
+		} else if (thermal_value <
+			   cali_info->thermal_value) { /*Low temperature*/
+			for (p = ODM_RF_PATH_A; p < c.rf_path_count; p++) {
+				/* print temperature decreasing */
+				ODM_RT_TRACE(
+					dm, ODM_COMP_TX_PWR_TRACK,
+					"Temperature Decreasing(%d): delta_pi: %d, delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n",
+					p, cali_info->power_index_offset[p],
+					delta, thermal_value,
+					rtlefu->eeprom_thermalmeter,
+					cali_info->thermal_value);
+			}
+		}
+
+		if (thermal_value > rtlefu->eeprom_thermalmeter) {
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"Temperature(%d) higher than PG value(%d)\n",
+				thermal_value, rtlefu->eeprom_thermalmeter);
+
+			phydm_odm_tx_power_set(dm, &c, indexforchannel, 0);
+		} else {
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"Temperature(%d) lower than PG value(%d)\n",
+				thermal_value, rtlefu->eeprom_thermalmeter);
+			phydm_odm_tx_power_set(dm, &c, indexforchannel, 1);
+		}
+
+		/*Record last time Power Tracking result as base.*/
+		cali_info->bb_swing_idx_cck_base = cali_info->bb_swing_idx_cck;
+
+		for (p = ODM_RF_PATH_A; p < c.rf_path_count; p++)
+			cali_info->bb_swing_idx_ofdm_base[p] =
+				cali_info->bb_swing_idx_ofdm[p];
+
+		ODM_RT_TRACE(
+			dm, ODM_COMP_TX_PWR_TRACK,
+			"cali_info->thermal_value = %d thermal_value= %d\n",
+			cali_info->thermal_value, thermal_value);
+
+		/*Record last Power Tracking Thermal value*/
+		cali_info->thermal_value = thermal_value;
+	}
+
+	if (dm->support_ic_type == ODM_RTL8703B ||
+	    dm->support_ic_type == ODM_RTL8723D ||
+	    dm->support_ic_type == ODM_RTL8710B) { /* JJ ADD 20161014 */
+
+		if (xtal_offset_eanble != 0 &&
+		    cali_info->txpowertrack_control &&
+		    (rtlefu->eeprom_thermalmeter != 0xff)) {
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"**********Enter Xtal Tracking**********\n");
+
+			if (thermal_value > rtlefu->eeprom_thermalmeter) {
+				ODM_RT_TRACE(
+					dm, ODM_COMP_TX_PWR_TRACK,
+					"Temperature(%d) higher than PG value(%d)\n",
+					thermal_value,
+					rtlefu->eeprom_thermalmeter);
+				(*c.odm_txxtaltrack_set_xtal)(dm);
+			} else {
+				ODM_RT_TRACE(
+					dm, ODM_COMP_TX_PWR_TRACK,
+					"Temperature(%d) lower than PG value(%d)\n",
+					thermal_value,
+					rtlefu->eeprom_thermalmeter);
+				(*c.odm_txxtaltrack_set_xtal)(dm);
+			}
+		}
+		ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+			     "**********End Xtal Tracking**********\n");
+	}
+
+	if (!IS_HARDWARE_TYPE_8723B(adapter)) {
+		/* Delta temperature is equal to or larger than 20 centigrade
+		 * (When threshold is 8).
+		 */
+		if (delta_IQK >= c.threshold_iqk) {
+			ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+				     "delta_IQK(%d) >= threshold_iqk(%d)\n",
+				     delta_IQK, c.threshold_iqk);
+			if (!cali_info->is_iqk_in_progress)
+				(*c.do_iqk)(dm, delta_IQK, thermal_value, 8);
+		}
+	}
+	if (cali_info->dpk_thermal[ODM_RF_PATH_A] != 0) {
+		if (diff_DPK[ODM_RF_PATH_A] >= c.threshold_dpk) {
+			odm_set_bb_reg(dm, 0x82c, BIT(31), 0x1);
+			odm_set_bb_reg(
+				dm, 0xcc4,
+				BIT(14) | BIT(13) | BIT(12) | BIT(11) | BIT(10),
+				(diff_DPK[ODM_RF_PATH_A] / c.threshold_dpk));
+			odm_set_bb_reg(dm, 0x82c, BIT(31), 0x0);
+		} else if ((diff_DPK[ODM_RF_PATH_A] <= -1 * c.threshold_dpk)) {
+			s32 value = 0x20 +
+				    (diff_DPK[ODM_RF_PATH_A] / c.threshold_dpk);
+
+			odm_set_bb_reg(dm, 0x82c, BIT(31), 0x1);
+			odm_set_bb_reg(dm, 0xcc4, BIT(14) | BIT(13) | BIT(12) |
+							  BIT(11) | BIT(10),
+				       value);
+			odm_set_bb_reg(dm, 0x82c, BIT(31), 0x0);
+		} else {
+			odm_set_bb_reg(dm, 0x82c, BIT(31), 0x1);
+			odm_set_bb_reg(dm, 0xcc4, BIT(14) | BIT(13) | BIT(12) |
+							  BIT(11) | BIT(10),
+				       0);
+			odm_set_bb_reg(dm, 0x82c, BIT(31), 0x0);
+		}
+	}
+	if (cali_info->dpk_thermal[ODM_RF_PATH_B] != 0) {
+		if (diff_DPK[ODM_RF_PATH_B] >= c.threshold_dpk) {
+			odm_set_bb_reg(dm, 0x82c, BIT(31), 0x1);
+			odm_set_bb_reg(
+				dm, 0xec4,
+				BIT(14) | BIT(13) | BIT(12) | BIT(11) | BIT(10),
+				(diff_DPK[ODM_RF_PATH_B] / c.threshold_dpk));
+			odm_set_bb_reg(dm, 0x82c, BIT(31), 0x0);
+		} else if ((diff_DPK[ODM_RF_PATH_B] <= -1 * c.threshold_dpk)) {
+			s32 value = 0x20 +
+				    (diff_DPK[ODM_RF_PATH_B] / c.threshold_dpk);
+
+			odm_set_bb_reg(dm, 0x82c, BIT(31), 0x1);
+			odm_set_bb_reg(dm, 0xec4, BIT(14) | BIT(13) | BIT(12) |
+							  BIT(11) | BIT(10),
+				       value);
+			odm_set_bb_reg(dm, 0x82c, BIT(31), 0x0);
+		} else {
+			odm_set_bb_reg(dm, 0x82c, BIT(31), 0x1);
+			odm_set_bb_reg(dm, 0xec4, BIT(14) | BIT(13) | BIT(12) |
+							  BIT(11) | BIT(10),
+				       0);
+			odm_set_bb_reg(dm, 0x82c, BIT(31), 0x0);
+		}
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK, "<===%s\n", __func__);
+
+	cali_info->tx_powercount = 0;
+}
+
+/* 3============================================================
+ * 3 IQ Calibration
+ * 3============================================================
+ */
+
+void odm_reset_iqk_result(void *dm_void) { return; }
+
+u8 odm_get_right_chnl_place_for_iqk(u8 chnl)
+{
+	u8 channel_all[ODM_TARGET_CHNL_NUM_2G_5G] = {
+		1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,
+		13,  14,  36,  38,  40,  42,  44,  46,  48,  50,  52,  54,
+		56,  58,  60,  62,  64,  100, 102, 104, 106, 108, 110, 112,
+		114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136,
+		138, 140, 149, 151, 153, 155, 157, 159, 161, 163, 165};
+	u8 place = chnl;
+
+	if (chnl > 14) {
+		for (place = 14; place < sizeof(channel_all); place++) {
+			if (channel_all[place] == chnl)
+				return place - 13;
+		}
+	}
+	return 0;
+}
+
+static void odm_iq_calibrate(struct phy_dm_struct *dm)
+{
+	void *adapter = dm->adapter;
+
+	if (IS_HARDWARE_TYPE_8812AU(adapter))
+		return;
+
+	if (dm->is_linked) {
+		if ((*dm->channel != dm->pre_channel) &&
+		    (!*dm->is_scan_in_process)) {
+			dm->pre_channel = *dm->channel;
+			dm->linked_interval = 0;
+		}
+
+		if (dm->linked_interval < 3)
+			dm->linked_interval++;
+
+		if (dm->linked_interval == 2) {
+			if (IS_HARDWARE_TYPE_8814A(adapter))
+				;
+
+			else if (IS_HARDWARE_TYPE_8822B(adapter))
+				phy_iq_calibrate_8822b(dm, false);
+		}
+	} else {
+		dm->linked_interval = 0;
+	}
+}
+
+void phydm_rf_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	odm_txpowertracking_init(dm);
+
+	odm_clear_txpowertracking_state(dm);
+}
+
+void phydm_rf_watchdog(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	odm_txpowertracking_check(dm);
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES)
+		odm_iq_calibrate(dm);
+}
diff --git a/drivers/staging/rtlwifi/phydm/halphyrf_ce.h b/drivers/staging/rtlwifi/phydm/halphyrf_ce.h
new file mode 100644
index 000000000000..e5d6257efb2b
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/halphyrf_ce.h
@@ -0,0 +1,85 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __HAL_PHY_RF_H__
+#define __HAL_PHY_RF_H__
+
+#include "phydm_kfree.h"
+
+#include "rtl8822b/phydm_iqk_8822b.h"
+
+#include "phydm_powertracking_ce.h"
+
+enum spur_cal_method { PLL_RESET, AFE_PHASE_SEL };
+
+enum pwrtrack_method {
+	BBSWING,
+	TXAGC,
+	MIX_MODE,
+	TSSI_MODE,
+	MIX_2G_TSSI_5G_MODE,
+	MIX_5G_TSSI_2G_MODE
+};
+
+typedef void (*func_set_pwr)(void *, enum pwrtrack_method, u8, u8);
+typedef void (*func_iqk)(void *, u8, u8, u8);
+typedef void (*func_lck)(void *);
+typedef void (*func_swing)(void *, u8 **, u8 **, u8 **, u8 **);
+typedef void (*func_swing8814only)(void *, u8 **, u8 **, u8 **, u8 **);
+typedef void (*func_swing_xtal)(void *, s8 **, s8 **);
+typedef void (*func_set_xtal)(void *);
+
+struct txpwrtrack_cfg {
+	u8 swing_table_size_cck;
+	u8 swing_table_size_ofdm;
+	u8 threshold_iqk;
+	u8 threshold_dpk;
+	u8 average_thermal_num;
+	u8 rf_path_count;
+	u32 thermal_reg_addr;
+	func_set_pwr odm_tx_pwr_track_set_pwr;
+	func_iqk do_iqk;
+	func_lck phy_lc_calibrate;
+	func_swing get_delta_swing_table;
+	func_swing8814only get_delta_swing_table8814only;
+	func_swing_xtal get_delta_swing_xtal_table;
+	func_set_xtal odm_txxtaltrack_set_xtal;
+};
+
+void configure_txpower_track(void *dm_void, struct txpwrtrack_cfg *config);
+
+void odm_clear_txpowertracking_state(void *dm_void);
+
+void odm_txpowertracking_callback_thermal_meter(void *dm);
+
+#define ODM_TARGET_CHNL_NUM_2G_5G 59
+
+void odm_reset_iqk_result(void *dm_void);
+u8 odm_get_right_chnl_place_for_iqk(u8 chnl);
+
+void phydm_rf_init(void *dm_void);
+void phydm_rf_watchdog(void *dm_void);
+
+#endif /*  #ifndef __HAL_PHY_RF_H__ */
diff --git a/drivers/staging/rtlwifi/phydm/mp_precomp.h b/drivers/staging/rtlwifi/phydm/mp_precomp.h
new file mode 100644
index 000000000000..b313de511ed6
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/mp_precomp.h
@@ -0,0 +1,24 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
diff --git a/drivers/staging/rtlwifi/phydm/phydm.c b/drivers/staging/rtlwifi/phydm/phydm.c
new file mode 100644
index 000000000000..37888c3087a4
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm.c
@@ -0,0 +1,1986 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/* ************************************************************
+ * include files
+ * *************************************************************/
+
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+static const u16 db_invert_table[12][8] = {
+	{1, 1, 1, 2, 2, 2, 2, 3},
+	{3, 3, 4, 4, 4, 5, 6, 6},
+	{7, 8, 9, 10, 11, 13, 14, 16},
+	{18, 20, 22, 25, 28, 32, 35, 40},
+	{45, 50, 56, 63, 71, 79, 89, 100},
+	{112, 126, 141, 158, 178, 200, 224, 251},
+	{282, 316, 355, 398, 447, 501, 562, 631},
+	{708, 794, 891, 1000, 1122, 1259, 1413, 1585},
+	{1778, 1995, 2239, 2512, 2818, 3162, 3548, 3981},
+	{4467, 5012, 5623, 6310, 7079, 7943, 8913, 10000},
+	{11220, 12589, 14125, 15849, 17783, 19953, 22387, 25119},
+	{28184, 31623, 35481, 39811, 44668, 50119, 56234, 65535},
+};
+
+/* ************************************************************
+ * Local Function predefine.
+ * *************************************************************/
+
+/* START------------COMMON INFO RELATED--------------- */
+
+static void odm_update_power_training_state(struct phy_dm_struct *dm);
+
+/* ************************************************************
+ * 3 Export Interface
+ * *************************************************************/
+
+/*Y = 10*log(X)*/
+s32 odm_pwdb_conversion(s32 X, u32 total_bit, u32 decimal_bit)
+{
+	s32 Y, integer = 0, decimal = 0;
+	u32 i;
+
+	if (X == 0)
+		X = 1; /* log2(x), x can't be 0 */
+
+	for (i = (total_bit - 1); i > 0; i--) {
+		if (X & BIT(i)) {
+			integer = i;
+			if (i > 0) {
+				/* decimal is 0.5dB*3=1.5dB~=2dB */
+				decimal = (X & BIT(i - 1)) ? 2 : 0;
+			}
+			break;
+		}
+	}
+
+	Y = 3 * (integer - decimal_bit) + decimal; /* 10*log(x)=3*log2(x), */
+
+	return Y;
+}
+
+s32 odm_sign_conversion(s32 value, u32 total_bit)
+{
+	if (value & BIT(total_bit - 1))
+		value -= BIT(total_bit);
+	return value;
+}
+
+void phydm_seq_sorting(void *dm_void, u32 *value, u32 *rank_idx, u32 *idx_out,
+		       u8 seq_length)
+{
+	u8 i = 0, j = 0;
+	u32 tmp_a, tmp_b;
+	u32 tmp_idx_a, tmp_idx_b;
+
+	for (i = 0; i < seq_length; i++) {
+		rank_idx[i] = i;
+		/**/
+	}
+
+	for (i = 0; i < (seq_length - 1); i++) {
+		for (j = 0; j < (seq_length - 1 - i); j++) {
+			tmp_a = value[j];
+			tmp_b = value[j + 1];
+
+			tmp_idx_a = rank_idx[j];
+			tmp_idx_b = rank_idx[j + 1];
+
+			if (tmp_a < tmp_b) {
+				value[j] = tmp_b;
+				value[j + 1] = tmp_a;
+
+				rank_idx[j] = tmp_idx_b;
+				rank_idx[j + 1] = tmp_idx_a;
+			}
+		}
+	}
+
+	for (i = 0; i < seq_length; i++) {
+		idx_out[rank_idx[i]] = i + 1;
+		/**/
+	}
+}
+
+void odm_init_mp_driver_status(struct phy_dm_struct *dm)
+{
+	dm->mp_mode = false;
+}
+
+static void odm_update_mp_driver_status(struct phy_dm_struct *dm)
+{
+	/* Do nothing. */
+}
+
+static void phydm_init_trx_antenna_setting(struct phy_dm_struct *dm)
+{
+	/*#if (RTL8814A_SUPPORT == 1)*/
+
+	if (dm->support_ic_type & (ODM_RTL8814A)) {
+		u8 rx_ant = 0, tx_ant = 0;
+
+		rx_ant = (u8)odm_get_bb_reg(dm, ODM_REG(BB_RX_PATH, dm),
+					    ODM_BIT(BB_RX_PATH, dm));
+		tx_ant = (u8)odm_get_bb_reg(dm, ODM_REG(BB_TX_PATH, dm),
+					    ODM_BIT(BB_TX_PATH, dm));
+		dm->tx_ant_status = (tx_ant & 0xf);
+		dm->rx_ant_status = (rx_ant & 0xf);
+	} else if (dm->support_ic_type & (ODM_RTL8723D | ODM_RTL8821C |
+					  ODM_RTL8710B)) { /* JJ ADD 20161014 */
+		dm->tx_ant_status = 0x1;
+		dm->rx_ant_status = 0x1;
+	}
+	/*#endif*/
+}
+
+static void phydm_traffic_load_decision(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	/*---TP & Trafic-load calculation---*/
+
+	if (dm->last_tx_ok_cnt > *dm->num_tx_bytes_unicast)
+		dm->last_tx_ok_cnt = *dm->num_tx_bytes_unicast;
+
+	if (dm->last_rx_ok_cnt > *dm->num_rx_bytes_unicast)
+		dm->last_rx_ok_cnt = *dm->num_rx_bytes_unicast;
+
+	dm->cur_tx_ok_cnt = *dm->num_tx_bytes_unicast - dm->last_tx_ok_cnt;
+	dm->cur_rx_ok_cnt = *dm->num_rx_bytes_unicast - dm->last_rx_ok_cnt;
+	dm->last_tx_ok_cnt = *dm->num_tx_bytes_unicast;
+	dm->last_rx_ok_cnt = *dm->num_rx_bytes_unicast;
+
+	dm->tx_tp = ((dm->tx_tp) >> 1) +
+		    (u32)(((dm->cur_tx_ok_cnt) >> 18) >>
+			  1); /* <<3(8bit), >>20(10^6,M), >>1(2sec)*/
+	dm->rx_tp = ((dm->rx_tp) >> 1) +
+		    (u32)(((dm->cur_rx_ok_cnt) >> 18) >>
+			  1); /* <<3(8bit), >>20(10^6,M), >>1(2sec)*/
+	dm->total_tp = dm->tx_tp + dm->rx_tp;
+
+	dm->pre_traffic_load = dm->traffic_load;
+
+	if (dm->cur_tx_ok_cnt > 1875000 ||
+	    dm->cur_rx_ok_cnt >
+		    1875000) { /* ( 1.875M * 8bit ) / 2sec= 7.5M bits /sec )*/
+
+		dm->traffic_load = TRAFFIC_HIGH;
+		/**/
+	} else if (
+		dm->cur_tx_ok_cnt > 500000 ||
+		dm->cur_rx_ok_cnt >
+			500000) { /*( 0.5M * 8bit ) / 2sec =  2M bits /sec )*/
+
+		dm->traffic_load = TRAFFIC_MID;
+		/**/
+	} else if (
+		dm->cur_tx_ok_cnt > 100000 ||
+		dm->cur_rx_ok_cnt >
+			100000) { /*( 0.1M * 8bit ) / 2sec =  0.4M bits /sec )*/
+
+		dm->traffic_load = TRAFFIC_LOW;
+		/**/
+	} else {
+		dm->traffic_load = TRAFFIC_ULTRA_LOW;
+		/**/
+	}
+}
+
+static void phydm_config_ofdm_tx_path(struct phy_dm_struct *dm, u32 path) {}
+
+void phydm_config_ofdm_rx_path(struct phy_dm_struct *dm, u32 path)
+{
+	u8 ofdm_rx_path = 0;
+
+	if (dm->support_ic_type & (ODM_RTL8192E)) {
+	} else if (dm->support_ic_type & (ODM_RTL8812 | ODM_RTL8822B)) {
+		if (path == PHYDM_A) {
+			ofdm_rx_path = 1;
+			/**/
+		} else if (path == PHYDM_B) {
+			ofdm_rx_path = 2;
+			/**/
+		} else if (path == PHYDM_AB) {
+			ofdm_rx_path = 3;
+			/**/
+		}
+
+		odm_set_bb_reg(dm, 0x808, MASKBYTE0,
+			       ((ofdm_rx_path << 4) | ofdm_rx_path));
+	}
+}
+
+static void phydm_config_cck_rx_antenna_init(struct phy_dm_struct *dm) {}
+
+static void phydm_config_cck_rx_path(struct phy_dm_struct *dm, u8 path,
+				     u8 path_div_en)
+{
+}
+
+void phydm_config_trx_path(void *dm_void, u32 *const dm_value, u32 *_used,
+			   char *output, u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	/* CCK */
+	if (dm_value[0] == 0) {
+		if (dm_value[1] == 1) { /*TX*/
+			if (dm_value[2] == 1)
+				odm_set_bb_reg(dm, 0xa04, 0xf0000000, 0x8);
+			else if (dm_value[2] == 2)
+				odm_set_bb_reg(dm, 0xa04, 0xf0000000, 0x4);
+			else if (dm_value[2] == 3)
+				odm_set_bb_reg(dm, 0xa04, 0xf0000000, 0xc);
+		} else if (dm_value[1] == 2) { /*RX*/
+
+			phydm_config_cck_rx_antenna_init(dm);
+
+			if (dm_value[2] == 1)
+				phydm_config_cck_rx_path(dm, PHYDM_A,
+							 CCA_PATHDIV_DISABLE);
+			else if (dm_value[2] == 2)
+				phydm_config_cck_rx_path(dm, PHYDM_B,
+							 CCA_PATHDIV_DISABLE);
+			else if (dm_value[2] == 3 &&
+				 dm_value[3] == 1) /*enable path diversity*/
+				phydm_config_cck_rx_path(dm, PHYDM_AB,
+							 CCA_PATHDIV_ENABLE);
+			else if (dm_value[2] == 3 && dm_value[3] != 1)
+				phydm_config_cck_rx_path(dm, PHYDM_B,
+							 CCA_PATHDIV_DISABLE);
+		}
+	}
+	/* OFDM */
+	else if (dm_value[0] == 1) {
+		if (dm_value[1] == 1) { /*TX*/
+			phydm_config_ofdm_tx_path(dm, dm_value[2]);
+			/**/
+		} else if (dm_value[1] == 2) { /*RX*/
+			phydm_config_ofdm_rx_path(dm, dm_value[2]);
+			/**/
+		}
+	}
+
+	PHYDM_SNPRINTF(
+		output + used, out_len - used,
+		"PHYDM Set path [%s] [%s] = [%s%s%s%s]\n",
+		(dm_value[0] == 1) ? "OFDM" : "CCK",
+		(dm_value[1] == 1) ? "TX" : "RX",
+		(dm_value[2] & 0x1) ? "A" : "", (dm_value[2] & 0x2) ? "B" : "",
+		(dm_value[2] & 0x4) ? "C" : "", (dm_value[2] & 0x8) ? "D" : "");
+}
+
+static void phydm_init_cck_setting(struct phy_dm_struct *dm)
+{
+	dm->is_cck_high_power = (bool)odm_get_bb_reg(
+		dm, ODM_REG(CCK_RPT_FORMAT, dm), ODM_BIT(CCK_RPT_FORMAT, dm));
+
+	/* JJ ADD 20161014 */
+	/* JJ ADD 20161014 */
+	if (dm->support_ic_type & (ODM_RTL8723D | ODM_RTL8822B | ODM_RTL8197F |
+				   ODM_RTL8821C | ODM_RTL8710B))
+		dm->cck_new_agc = odm_get_bb_reg(dm, 0xa9c, BIT(17)) ?
+					  true :
+					  false; /*1: new agc  0: old agc*/
+	else
+		dm->cck_new_agc = false;
+}
+
+static void phydm_init_soft_ml_setting(struct phy_dm_struct *dm)
+{
+	if (!dm->mp_mode) {
+		if (dm->support_ic_type & ODM_RTL8822B)
+			odm_set_bb_reg(dm, 0x19a8, MASKDWORD, 0xc10a0000);
+	}
+}
+
+static void phydm_init_hw_info_by_rfe(struct phy_dm_struct *dm)
+{
+	if (dm->support_ic_type & ODM_RTL8822B)
+		phydm_init_hw_info_by_rfe_type_8822b(dm);
+}
+
+static void odm_common_info_self_init(struct phy_dm_struct *dm)
+{
+	phydm_init_cck_setting(dm);
+	dm->rf_path_rx_enable = (u8)odm_get_bb_reg(dm, ODM_REG(BB_RX_PATH, dm),
+						   ODM_BIT(BB_RX_PATH, dm));
+	odm_init_mp_driver_status(dm);
+	phydm_init_trx_antenna_setting(dm);
+	phydm_init_soft_ml_setting(dm);
+
+	dm->phydm_period = PHYDM_WATCH_DOG_PERIOD;
+	dm->phydm_sys_up_time = 0;
+
+	if (dm->support_ic_type & ODM_IC_1SS)
+		dm->num_rf_path = 1;
+	else if (dm->support_ic_type & ODM_IC_2SS)
+		dm->num_rf_path = 2;
+	else if (dm->support_ic_type & ODM_IC_3SS)
+		dm->num_rf_path = 3;
+	else if (dm->support_ic_type & ODM_IC_4SS)
+		dm->num_rf_path = 4;
+
+	dm->tx_rate = 0xFF;
+
+	dm->number_linked_client = 0;
+	dm->pre_number_linked_client = 0;
+	dm->number_active_client = 0;
+	dm->pre_number_active_client = 0;
+
+	dm->last_tx_ok_cnt = 0;
+	dm->last_rx_ok_cnt = 0;
+	dm->tx_tp = 0;
+	dm->rx_tp = 0;
+	dm->total_tp = 0;
+	dm->traffic_load = TRAFFIC_LOW;
+
+	dm->nbi_set_result = 0;
+	dm->is_init_hw_info_by_rfe = false;
+	dm->pre_dbg_priority = BB_DBGPORT_RELEASE;
+}
+
+static void odm_common_info_self_update(struct phy_dm_struct *dm)
+{
+	u8 entry_cnt = 0, num_active_client = 0;
+	u32 i, one_entry_macid = 0;
+	struct rtl_sta_info *entry;
+
+	/* THis variable cannot be used because it is wrong*/
+	if (*dm->band_width == ODM_BW40M) {
+		if (*dm->sec_ch_offset == 1)
+			dm->control_channel = *dm->channel - 2;
+		else if (*dm->sec_ch_offset == 2)
+			dm->control_channel = *dm->channel + 2;
+	} else {
+		dm->control_channel = *dm->channel;
+	}
+
+	for (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {
+		entry = dm->odm_sta_info[i];
+		if (IS_STA_VALID(entry)) {
+			entry_cnt++;
+			if (entry_cnt == 1)
+				one_entry_macid = i;
+		}
+	}
+
+	if (entry_cnt == 1) {
+		dm->is_one_entry_only = true;
+		dm->one_entry_macid = one_entry_macid;
+	} else {
+		dm->is_one_entry_only = false;
+	}
+
+	dm->pre_number_linked_client = dm->number_linked_client;
+	dm->pre_number_active_client = dm->number_active_client;
+
+	dm->number_linked_client = entry_cnt;
+	dm->number_active_client = num_active_client;
+
+	/* Update MP driver status*/
+	odm_update_mp_driver_status(dm);
+
+	/*Traffic load information update*/
+	phydm_traffic_load_decision(dm);
+
+	dm->phydm_sys_up_time += dm->phydm_period;
+}
+
+static void odm_common_info_self_reset(struct phy_dm_struct *dm)
+{
+	dm->phy_dbg_info.num_qry_beacon_pkt = 0;
+}
+
+void *phydm_get_structure(struct phy_dm_struct *dm, u8 structure_type)
+
+{
+	void *p_struct = NULL;
+
+	switch (structure_type) {
+	case PHYDM_FALSEALMCNT:
+		p_struct = &dm->false_alm_cnt;
+		break;
+
+	case PHYDM_CFOTRACK:
+		p_struct = &dm->dm_cfo_track;
+		break;
+
+	case PHYDM_ADAPTIVITY:
+		p_struct = &dm->adaptivity;
+		break;
+
+	default:
+		break;
+	}
+
+	return p_struct;
+}
+
+static void odm_hw_setting(struct phy_dm_struct *dm)
+{
+	if (dm->support_ic_type & ODM_RTL8822B)
+		phydm_hwsetting_8822b(dm);
+}
+
+static void phydm_supportability_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 support_ability = 0;
+
+	if (dm->support_ic_type != ODM_RTL8821C)
+		return;
+
+	switch (dm->support_ic_type) {
+	/*---------------AC Series-------------------*/
+
+	case ODM_RTL8822B:
+		support_ability |= ODM_BB_DIG | ODM_BB_FA_CNT | ODM_BB_CCK_PD |
+				   ODM_BB_CFO_TRACKING | ODM_BB_RATE_ADAPTIVE |
+				   ODM_BB_RSSI_MONITOR | ODM_BB_RA_MASK |
+				   ODM_RF_TX_PWR_TRACK;
+		break;
+
+	default:
+		support_ability |= ODM_BB_DIG | ODM_BB_FA_CNT | ODM_BB_CCK_PD |
+				   ODM_BB_CFO_TRACKING | ODM_BB_RATE_ADAPTIVE |
+				   ODM_BB_RSSI_MONITOR | ODM_BB_RA_MASK |
+				   ODM_RF_TX_PWR_TRACK;
+
+		ODM_RT_TRACE(dm, ODM_COMP_UNCOND,
+			     "[Warning] Supportability Init Warning !!!\n");
+		break;
+	}
+
+	if (*dm->enable_antdiv)
+		support_ability |= ODM_BB_ANT_DIV;
+
+	if (*dm->enable_adaptivity) {
+		ODM_RT_TRACE(dm, ODM_COMP_INIT,
+			     "ODM adaptivity is set to Enabled!!!\n");
+
+		support_ability |= ODM_BB_ADAPTIVITY;
+
+	} else {
+		ODM_RT_TRACE(dm, ODM_COMP_INIT,
+			     "ODM adaptivity is set to disnabled!!!\n");
+		/**/
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT, "PHYDM support_ability = ((0x%x))\n",
+		     support_ability);
+	odm_cmn_info_init(dm, ODM_CMNINFO_ABILITY, support_ability);
+}
+
+/*
+ * 2011/09/21 MH Add to describe different team necessary resource allocate??
+ */
+void odm_dm_init(struct phy_dm_struct *dm)
+{
+	phydm_supportability_init(dm);
+	odm_common_info_self_init(dm);
+	odm_dig_init(dm);
+	phydm_nhm_counter_statistics_init(dm);
+	phydm_adaptivity_init(dm);
+	phydm_ra_info_init(dm);
+	odm_rate_adaptive_mask_init(dm);
+	odm_cfo_tracking_init(dm);
+	odm_edca_turbo_init(dm);
+	odm_rssi_monitor_init(dm);
+	phydm_rf_init(dm);
+	odm_txpowertracking_init(dm);
+
+	if (dm->support_ic_type & ODM_RTL8822B)
+		phydm_txcurrentcalibration(dm);
+
+	odm_antenna_diversity_init(dm);
+	odm_auto_channel_select_init(dm);
+	odm_dynamic_tx_power_init(dm);
+	phydm_init_ra_info(dm);
+	adc_smp_init(dm);
+
+	phydm_beamforming_init(dm);
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		/* 11n series */
+		odm_dynamic_bb_power_saving_init(dm);
+	}
+
+	phydm_psd_init(dm);
+}
+
+void odm_dm_reset(struct phy_dm_struct *dm)
+{
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+
+	odm_ant_div_reset(dm);
+	phydm_set_edcca_threshold_api(dm, dig_tab->cur_ig_value);
+}
+
+void phydm_support_ability_debug(void *dm_void, u32 *const dm_value, u32 *_used,
+				 char *output, u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 pre_support_ability;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	pre_support_ability = dm->support_ability;
+	PHYDM_SNPRINTF(output + used, out_len - used, "\n%s\n",
+		       "================================");
+	if (dm_value[0] == 100) {
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "[Supportability] PhyDM Selection\n");
+		PHYDM_SNPRINTF(output + used, out_len - used, "%s\n",
+			       "================================");
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "00. (( %s ))DIG\n",
+			((dm->support_ability & ODM_BB_DIG) ? ("V") : (".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "01. (( %s ))RA_MASK\n",
+			((dm->support_ability & ODM_BB_RA_MASK) ? ("V") :
+								  (".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "02. (( %s ))DYNAMIC_TXPWR\n",
+			       ((dm->support_ability & ODM_BB_DYNAMIC_TXPWR) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "03. (( %s ))FA_CNT\n",
+			       ((dm->support_ability & ODM_BB_FA_CNT) ? ("V") :
+									(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "04. (( %s ))RSSI_MONITOR\n",
+			       ((dm->support_ability & ODM_BB_RSSI_MONITOR) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "05. (( %s ))CCK_PD\n",
+			       ((dm->support_ability & ODM_BB_CCK_PD) ? ("V") :
+									(".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "06. (( %s ))ANT_DIV\n",
+			((dm->support_ability & ODM_BB_ANT_DIV) ? ("V") :
+								  (".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "08. (( %s ))PWR_TRAIN\n",
+			       ((dm->support_ability & ODM_BB_PWR_TRAIN) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "09. (( %s ))RATE_ADAPTIVE\n",
+			       ((dm->support_ability & ODM_BB_RATE_ADAPTIVE) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "10. (( %s ))PATH_DIV\n",
+			((dm->support_ability & ODM_BB_PATH_DIV) ? ("V") :
+								   (".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "13. (( %s ))ADAPTIVITY\n",
+			       ((dm->support_ability & ODM_BB_ADAPTIVITY) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "14. (( %s ))struct cfo_tracking\n",
+			       ((dm->support_ability & ODM_BB_CFO_TRACKING) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "15. (( %s ))NHM_CNT\n",
+			((dm->support_ability & ODM_BB_NHM_CNT) ? ("V") :
+								  (".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "16. (( %s ))PRIMARY_CCA\n",
+			       ((dm->support_ability & ODM_BB_PRIMARY_CCA) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "17. (( %s ))TXBF\n",
+			((dm->support_ability & ODM_BB_TXBF) ? ("V") : (".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "18. (( %s ))DYNAMIC_ARFR\n",
+			       ((dm->support_ability & ODM_BB_DYNAMIC_ARFR) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "20. (( %s ))EDCA_TURBO\n",
+			       ((dm->support_ability & ODM_MAC_EDCA_TURBO) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "21. (( %s ))DYNAMIC_RX_PATH\n",
+			       ((dm->support_ability & ODM_BB_DYNAMIC_RX_PATH) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "24. (( %s ))TX_PWR_TRACK\n",
+			       ((dm->support_ability & ODM_RF_TX_PWR_TRACK) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "25. (( %s ))RX_GAIN_TRACK\n",
+			       ((dm->support_ability & ODM_RF_RX_GAIN_TRACK) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "26. (( %s ))RF_CALIBRATION\n",
+			       ((dm->support_ability & ODM_RF_CALIBRATION) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used, "%s\n",
+			       "================================");
+	} else {
+		if (dm_value[1] == 1) { /* enable */
+			dm->support_ability |= BIT(dm_value[0]);
+		} else if (dm_value[1] == 2) /* disable */
+			dm->support_ability &= ~(BIT(dm_value[0]));
+		else {
+			PHYDM_SNPRINTF(output + used, out_len - used, "%s\n",
+				       "[Warning!!!]  1:enable,  2:disable");
+		}
+	}
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "pre-support_ability  =  0x%x\n", pre_support_ability);
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "Curr-support_ability =  0x%x\n", dm->support_ability);
+	PHYDM_SNPRINTF(output + used, out_len - used, "%s\n",
+		       "================================");
+}
+
+void phydm_watchdog_mp(struct phy_dm_struct *dm) {}
+/*
+ * 2011/09/20 MH This is the entry pointer for all team to execute HW outsrc DM.
+ * You can not add any dummy function here, be care, you can only use DM struct
+ * to perform any new ODM_DM.
+ */
+void odm_dm_watchdog(struct phy_dm_struct *dm)
+{
+	odm_common_info_self_update(dm);
+	phydm_basic_dbg_message(dm);
+	odm_hw_setting(dm);
+
+	odm_false_alarm_counter_statistics(dm);
+	phydm_noisy_detection(dm);
+
+	odm_rssi_monitor_check(dm);
+
+	if (*dm->is_power_saving) {
+		odm_dig_by_rssi_lps(dm);
+		phydm_adaptivity(dm);
+		odm_antenna_diversity(
+			dm); /*enable AntDiv in PS mode, request from SD4 Jeff*/
+		ODM_RT_TRACE(dm, ODM_COMP_COMMON,
+			     "DMWatchdog in power saving mode\n");
+		return;
+	}
+
+	phydm_check_adaptivity(dm);
+	odm_update_power_training_state(dm);
+	odm_DIG(dm);
+	phydm_adaptivity(dm);
+	odm_cck_packet_detection_thresh(dm);
+
+	phydm_ra_info_watchdog(dm);
+	odm_edca_turbo_check(dm);
+	odm_cfo_tracking(dm);
+	odm_dynamic_tx_power(dm);
+	odm_antenna_diversity(dm);
+
+	phydm_beamforming_watchdog(dm);
+
+	phydm_rf_watchdog(dm);
+
+	odm_dtc(dm);
+
+	odm_common_info_self_reset(dm);
+}
+
+/*
+ * Init /.. Fixed HW value. Only init time.
+ */
+void odm_cmn_info_init(struct phy_dm_struct *dm, enum odm_cmninfo cmn_info,
+		       u32 value)
+{
+	/* This section is used for init value */
+	switch (cmn_info) {
+	/* Fixed ODM value. */
+	case ODM_CMNINFO_ABILITY:
+		dm->support_ability = (u32)value;
+		break;
+
+	case ODM_CMNINFO_RF_TYPE:
+		dm->rf_type = (u8)value;
+		break;
+
+	case ODM_CMNINFO_PLATFORM:
+		dm->support_platform = (u8)value;
+		break;
+
+	case ODM_CMNINFO_INTERFACE:
+		dm->support_interface = (u8)value;
+		break;
+
+	case ODM_CMNINFO_MP_TEST_CHIP:
+		dm->is_mp_chip = (u8)value;
+		break;
+
+	case ODM_CMNINFO_IC_TYPE:
+		dm->support_ic_type = value;
+		break;
+
+	case ODM_CMNINFO_CUT_VER:
+		dm->cut_version = (u8)value;
+		break;
+
+	case ODM_CMNINFO_FAB_VER:
+		dm->fab_version = (u8)value;
+		break;
+
+	case ODM_CMNINFO_RFE_TYPE:
+		dm->rfe_type = (u8)value;
+		phydm_init_hw_info_by_rfe(dm);
+		break;
+
+	case ODM_CMNINFO_RF_ANTENNA_TYPE:
+		dm->ant_div_type = (u8)value;
+		break;
+
+	case ODM_CMNINFO_WITH_EXT_ANTENNA_SWITCH:
+		dm->with_extenal_ant_switch = (u8)value;
+		break;
+
+	case ODM_CMNINFO_BE_FIX_TX_ANT:
+		dm->dm_fat_table.b_fix_tx_ant = (u8)value;
+		break;
+
+	case ODM_CMNINFO_BOARD_TYPE:
+		if (!dm->is_init_hw_info_by_rfe)
+			dm->board_type = (u8)value;
+		break;
+
+	case ODM_CMNINFO_PACKAGE_TYPE:
+		if (!dm->is_init_hw_info_by_rfe)
+			dm->package_type = (u8)value;
+		break;
+
+	case ODM_CMNINFO_EXT_LNA:
+		if (!dm->is_init_hw_info_by_rfe)
+			dm->ext_lna = (u8)value;
+		break;
+
+	case ODM_CMNINFO_5G_EXT_LNA:
+		if (!dm->is_init_hw_info_by_rfe)
+			dm->ext_lna_5g = (u8)value;
+		break;
+
+	case ODM_CMNINFO_EXT_PA:
+		if (!dm->is_init_hw_info_by_rfe)
+			dm->ext_pa = (u8)value;
+		break;
+
+	case ODM_CMNINFO_5G_EXT_PA:
+		if (!dm->is_init_hw_info_by_rfe)
+			dm->ext_pa_5g = (u8)value;
+		break;
+
+	case ODM_CMNINFO_GPA:
+		if (!dm->is_init_hw_info_by_rfe)
+			dm->type_gpa = (u16)value;
+		break;
+
+	case ODM_CMNINFO_APA:
+		if (!dm->is_init_hw_info_by_rfe)
+			dm->type_apa = (u16)value;
+		break;
+
+	case ODM_CMNINFO_GLNA:
+		if (!dm->is_init_hw_info_by_rfe)
+			dm->type_glna = (u16)value;
+		break;
+
+	case ODM_CMNINFO_ALNA:
+		if (!dm->is_init_hw_info_by_rfe)
+			dm->type_alna = (u16)value;
+		break;
+
+	case ODM_CMNINFO_EXT_TRSW:
+		if (!dm->is_init_hw_info_by_rfe)
+			dm->ext_trsw = (u8)value;
+		break;
+	case ODM_CMNINFO_EXT_LNA_GAIN:
+		dm->ext_lna_gain = (u8)value;
+		break;
+	case ODM_CMNINFO_PATCH_ID:
+		dm->patch_id = (u8)value;
+		break;
+	case ODM_CMNINFO_BINHCT_TEST:
+		dm->is_in_hct_test = (bool)value;
+		break;
+	case ODM_CMNINFO_BWIFI_TEST:
+		dm->wifi_test = (u8)value;
+		break;
+	case ODM_CMNINFO_SMART_CONCURRENT:
+		dm->is_dual_mac_smart_concurrent = (bool)value;
+		break;
+	case ODM_CMNINFO_DOMAIN_CODE_2G:
+		dm->odm_regulation_2_4g = (u8)value;
+		break;
+	case ODM_CMNINFO_DOMAIN_CODE_5G:
+		dm->odm_regulation_5g = (u8)value;
+		break;
+	case ODM_CMNINFO_CONFIG_BB_RF:
+		dm->config_bbrf = (bool)value;
+		break;
+	case ODM_CMNINFO_IQKFWOFFLOAD:
+		dm->iqk_fw_offload = (u8)value;
+		break;
+	case ODM_CMNINFO_IQKPAOFF:
+		dm->rf_calibrate_info.is_iqk_pa_off = (bool)value;
+		break;
+	case ODM_CMNINFO_REGRFKFREEENABLE:
+		dm->rf_calibrate_info.reg_rf_kfree_enable = (u8)value;
+		break;
+	case ODM_CMNINFO_RFKFREEENABLE:
+		dm->rf_calibrate_info.rf_kfree_enable = (u8)value;
+		break;
+	case ODM_CMNINFO_NORMAL_RX_PATH_CHANGE:
+		dm->normal_rx_path = (u8)value;
+		break;
+	case ODM_CMNINFO_EFUSE0X3D8:
+		dm->efuse0x3d8 = (u8)value;
+		break;
+	case ODM_CMNINFO_EFUSE0X3D7:
+		dm->efuse0x3d7 = (u8)value;
+		break;
+	/* To remove the compiler warning, must add an empty default statement
+	 * to handle the other values.
+	 */
+	default:
+		/* do nothing */
+		break;
+	}
+}
+
+void odm_cmn_info_hook(struct phy_dm_struct *dm, enum odm_cmninfo cmn_info,
+		       void *value)
+{
+	/*  */
+	/* Hook call by reference pointer. */
+	/*  */
+	switch (cmn_info) {
+	/*  */
+	/* Dynamic call by reference pointer. */
+	/*  */
+	case ODM_CMNINFO_MAC_PHY_MODE:
+		dm->mac_phy_mode = (u8 *)value;
+		break;
+
+	case ODM_CMNINFO_TX_UNI:
+		dm->num_tx_bytes_unicast = (u64 *)value;
+		break;
+
+	case ODM_CMNINFO_RX_UNI:
+		dm->num_rx_bytes_unicast = (u64 *)value;
+		break;
+
+	case ODM_CMNINFO_WM_MODE:
+		dm->wireless_mode = (u8 *)value;
+		break;
+
+	case ODM_CMNINFO_BAND:
+		dm->band_type = (u8 *)value;
+		break;
+
+	case ODM_CMNINFO_SEC_CHNL_OFFSET:
+		dm->sec_ch_offset = (u8 *)value;
+		break;
+
+	case ODM_CMNINFO_SEC_MODE:
+		dm->security = (u8 *)value;
+		break;
+
+	case ODM_CMNINFO_BW:
+		dm->band_width = (u8 *)value;
+		break;
+
+	case ODM_CMNINFO_CHNL:
+		dm->channel = (u8 *)value;
+		break;
+
+	case ODM_CMNINFO_DMSP_GET_VALUE:
+		dm->is_get_value_from_other_mac = (bool *)value;
+		break;
+
+	case ODM_CMNINFO_BUDDY_ADAPTOR:
+		dm->buddy_adapter = (void **)value;
+		break;
+
+	case ODM_CMNINFO_DMSP_IS_MASTER:
+		dm->is_master_of_dmsp = (bool *)value;
+		break;
+
+	case ODM_CMNINFO_SCAN:
+		dm->is_scan_in_process = (bool *)value;
+		break;
+
+	case ODM_CMNINFO_POWER_SAVING:
+		dm->is_power_saving = (bool *)value;
+		break;
+
+	case ODM_CMNINFO_ONE_PATH_CCA:
+		dm->one_path_cca = (u8 *)value;
+		break;
+
+	case ODM_CMNINFO_DRV_STOP:
+		dm->is_driver_stopped = (bool *)value;
+		break;
+
+	case ODM_CMNINFO_PNP_IN:
+		dm->is_driver_is_going_to_pnp_set_power_sleep = (bool *)value;
+		break;
+
+	case ODM_CMNINFO_INIT_ON:
+		dm->pinit_adpt_in_progress = (bool *)value;
+		break;
+
+	case ODM_CMNINFO_ANT_TEST:
+		dm->antenna_test = (u8 *)value;
+		break;
+
+	case ODM_CMNINFO_NET_CLOSED:
+		dm->is_net_closed = (bool *)value;
+		break;
+
+	case ODM_CMNINFO_FORCED_RATE:
+		dm->forced_data_rate = (u16 *)value;
+		break;
+	case ODM_CMNINFO_ANT_DIV:
+		dm->enable_antdiv = (u8 *)value;
+		break;
+	case ODM_CMNINFO_ADAPTIVITY:
+		dm->enable_adaptivity = (u8 *)value;
+		break;
+	case ODM_CMNINFO_FORCED_IGI_LB:
+		dm->pu1_forced_igi_lb = (u8 *)value;
+		break;
+
+	case ODM_CMNINFO_P2P_LINK:
+		dm->dm_dig_table.is_p2p_in_process = (u8 *)value;
+		break;
+
+	case ODM_CMNINFO_IS1ANTENNA:
+		dm->is_1_antenna = (bool *)value;
+		break;
+
+	case ODM_CMNINFO_RFDEFAULTPATH:
+		dm->rf_default_path = (u8 *)value;
+		break;
+
+	case ODM_CMNINFO_FCS_MODE:
+		dm->is_fcs_mode_enable = (bool *)value;
+		break;
+	/*add by YuChen for beamforming PhyDM*/
+	case ODM_CMNINFO_HUBUSBMODE:
+		dm->hub_usb_mode = (u8 *)value;
+		break;
+	case ODM_CMNINFO_FWDWRSVDPAGEINPROGRESS:
+		dm->is_fw_dw_rsvd_page_in_progress = (bool *)value;
+		break;
+	case ODM_CMNINFO_TX_TP:
+		dm->current_tx_tp = (u32 *)value;
+		break;
+	case ODM_CMNINFO_RX_TP:
+		dm->current_rx_tp = (u32 *)value;
+		break;
+	case ODM_CMNINFO_SOUNDING_SEQ:
+		dm->sounding_seq = (u8 *)value;
+		break;
+	case ODM_CMNINFO_FORCE_TX_ANT_BY_TXDESC:
+		dm->dm_fat_table.p_force_tx_ant_by_desc = (u8 *)value;
+		break;
+	case ODM_CMNINFO_SET_S0S1_DEFAULT_ANTENNA:
+		dm->dm_fat_table.p_default_s0_s1 = (u8 *)value;
+		break;
+
+	default:
+		/*do nothing*/
+		break;
+	}
+}
+
+void odm_cmn_info_ptr_array_hook(struct phy_dm_struct *dm,
+				 enum odm_cmninfo cmn_info, u16 index,
+				 void *value)
+{
+	/*Hook call by reference pointer.*/
+	switch (cmn_info) {
+	/*Dynamic call by reference pointer.	*/
+	case ODM_CMNINFO_STA_STATUS:
+		dm->odm_sta_info[index] = (struct rtl_sta_info *)value;
+
+		if (IS_STA_VALID(dm->odm_sta_info[index]))
+			dm->platform2phydm_macid_table[index] = index;
+
+		break;
+	/* To remove the compiler warning, must add an empty default statement
+	 * to handle the other values.
+	 */
+	default:
+		/* do nothing */
+		break;
+	}
+}
+
+/*
+ * Update band/CHannel/.. The values are dynamic but non-per-packet.
+ */
+void odm_cmn_info_update(struct phy_dm_struct *dm, u32 cmn_info, u64 value)
+{
+	/* This init variable may be changed in run time. */
+	switch (cmn_info) {
+	case ODM_CMNINFO_LINK_IN_PROGRESS:
+		dm->is_link_in_process = (bool)value;
+		break;
+
+	case ODM_CMNINFO_ABILITY:
+		dm->support_ability = (u32)value;
+		break;
+
+	case ODM_CMNINFO_RF_TYPE:
+		dm->rf_type = (u8)value;
+		break;
+
+	case ODM_CMNINFO_WIFI_DIRECT:
+		dm->is_wifi_direct = (bool)value;
+		break;
+
+	case ODM_CMNINFO_WIFI_DISPLAY:
+		dm->is_wifi_display = (bool)value;
+		break;
+
+	case ODM_CMNINFO_LINK:
+		dm->is_linked = (bool)value;
+		break;
+
+	case ODM_CMNINFO_CMW500LINK:
+		dm->is_linkedcmw500 = (bool)value;
+		break;
+
+	case ODM_CMNINFO_LPSPG:
+		dm->is_in_lps_pg = (bool)value;
+		break;
+
+	case ODM_CMNINFO_STATION_STATE:
+		dm->bsta_state = (bool)value;
+		break;
+
+	case ODM_CMNINFO_RSSI_MIN:
+		dm->rssi_min = (u8)value;
+		break;
+
+	case ODM_CMNINFO_DBG_COMP:
+		dm->debug_components = (u32)value;
+		break;
+
+	case ODM_CMNINFO_DBG_LEVEL:
+		dm->debug_level = (u32)value;
+		break;
+	case ODM_CMNINFO_RA_THRESHOLD_HIGH:
+		dm->rate_adaptive.high_rssi_thresh = (u8)value;
+		break;
+
+	case ODM_CMNINFO_RA_THRESHOLD_LOW:
+		dm->rate_adaptive.low_rssi_thresh = (u8)value;
+		break;
+	/* The following is for BT HS mode and BT coexist mechanism. */
+	case ODM_CMNINFO_BT_ENABLED:
+		dm->is_bt_enabled = (bool)value;
+		break;
+
+	case ODM_CMNINFO_BT_HS_CONNECT_PROCESS:
+		dm->is_bt_connect_process = (bool)value;
+		break;
+
+	case ODM_CMNINFO_BT_HS_RSSI:
+		dm->bt_hs_rssi = (u8)value;
+		break;
+
+	case ODM_CMNINFO_BT_OPERATION:
+		dm->is_bt_hs_operation = (bool)value;
+		break;
+
+	case ODM_CMNINFO_BT_LIMITED_DIG:
+		dm->is_bt_limited_dig = (bool)value;
+		break;
+
+	case ODM_CMNINFO_BT_DIG:
+		dm->bt_hs_dig_val = (u8)value;
+		break;
+
+	case ODM_CMNINFO_BT_BUSY:
+		dm->is_bt_busy = (bool)value;
+		break;
+
+	case ODM_CMNINFO_BT_DISABLE_EDCA:
+		dm->is_bt_disable_edca_turbo = (bool)value;
+		break;
+
+	case ODM_CMNINFO_AP_TOTAL_NUM:
+		dm->ap_total_num = (u8)value;
+		break;
+
+	case ODM_CMNINFO_POWER_TRAINING:
+		dm->is_disable_power_training = (bool)value;
+		break;
+
+	default:
+		/* do nothing */
+		break;
+	}
+}
+
+u32 phydm_cmn_info_query(struct phy_dm_struct *dm,
+			 enum phydm_info_query info_type)
+{
+	struct false_alarm_stat *false_alm_cnt =
+		(struct false_alarm_stat *)phydm_get_structure(
+			dm, PHYDM_FALSEALMCNT);
+
+	switch (info_type) {
+	case PHYDM_INFO_FA_OFDM:
+		return false_alm_cnt->cnt_ofdm_fail;
+
+	case PHYDM_INFO_FA_CCK:
+		return false_alm_cnt->cnt_cck_fail;
+
+	case PHYDM_INFO_FA_TOTAL:
+		return false_alm_cnt->cnt_all;
+
+	case PHYDM_INFO_CCA_OFDM:
+		return false_alm_cnt->cnt_ofdm_cca;
+
+	case PHYDM_INFO_CCA_CCK:
+		return false_alm_cnt->cnt_cck_cca;
+
+	case PHYDM_INFO_CCA_ALL:
+		return false_alm_cnt->cnt_cca_all;
+
+	case PHYDM_INFO_CRC32_OK_VHT:
+		return false_alm_cnt->cnt_vht_crc32_ok;
+
+	case PHYDM_INFO_CRC32_OK_HT:
+		return false_alm_cnt->cnt_ht_crc32_ok;
+
+	case PHYDM_INFO_CRC32_OK_LEGACY:
+		return false_alm_cnt->cnt_ofdm_crc32_ok;
+
+	case PHYDM_INFO_CRC32_OK_CCK:
+		return false_alm_cnt->cnt_cck_crc32_ok;
+
+	case PHYDM_INFO_CRC32_ERROR_VHT:
+		return false_alm_cnt->cnt_vht_crc32_error;
+
+	case PHYDM_INFO_CRC32_ERROR_HT:
+		return false_alm_cnt->cnt_ht_crc32_error;
+
+	case PHYDM_INFO_CRC32_ERROR_LEGACY:
+		return false_alm_cnt->cnt_ofdm_crc32_error;
+
+	case PHYDM_INFO_CRC32_ERROR_CCK:
+		return false_alm_cnt->cnt_cck_crc32_error;
+
+	case PHYDM_INFO_EDCCA_FLAG:
+		return false_alm_cnt->edcca_flag;
+
+	case PHYDM_INFO_OFDM_ENABLE:
+		return false_alm_cnt->ofdm_block_enable;
+
+	case PHYDM_INFO_CCK_ENABLE:
+		return false_alm_cnt->cck_block_enable;
+
+	case PHYDM_INFO_DBG_PORT_0:
+		return false_alm_cnt->dbg_port0;
+
+	default:
+		return 0xffffffff;
+	}
+}
+
+void odm_init_all_timers(struct phy_dm_struct *dm) {}
+
+void odm_cancel_all_timers(struct phy_dm_struct *dm) {}
+
+void odm_release_all_timers(struct phy_dm_struct *dm) {}
+
+/* 3============================================================
+ * 3 Tx Power Tracking
+ * 3============================================================
+ */
+
+/* need to ODM CE Platform
+ * move to here for ANT detection mechanism using
+ */
+
+u32 odm_convert_to_db(u32 value)
+{
+	u8 i;
+	u8 j;
+	u32 dB;
+
+	value = value & 0xFFFF;
+
+	for (i = 0; i < 12; i++) {
+		if (value <= db_invert_table[i][7])
+			break;
+	}
+
+	if (i >= 12)
+		return 96; /* maximum 96 dB */
+
+	for (j = 0; j < 8; j++) {
+		if (value <= db_invert_table[i][j])
+			break;
+	}
+
+	dB = (i << 3) + j + 1;
+
+	return dB;
+}
+
+u32 odm_convert_to_linear(u32 value)
+{
+	u8 i;
+	u8 j;
+	u32 linear;
+
+	/* 1dB~96dB */
+
+	value = value & 0xFF;
+
+	i = (u8)((value - 1) >> 3);
+	j = (u8)(value - 1) - (i << 3);
+
+	linear = db_invert_table[i][j];
+
+	return linear;
+}
+
+/*
+ * ODM multi-port consideration, added by Roger, 2013.10.01.
+ */
+void odm_asoc_entry_init(struct phy_dm_struct *dm) {}
+
+/* Justin: According to the current RRSI to adjust Response Frame TX power */
+void odm_dtc(struct phy_dm_struct *dm) {}
+
+static void odm_update_power_training_state(struct phy_dm_struct *dm)
+{
+	struct false_alarm_stat *false_alm_cnt =
+		(struct false_alarm_stat *)phydm_get_structure(
+			dm, PHYDM_FALSEALMCNT);
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+	u32 score = 0;
+
+	if (!(dm->support_ability & ODM_BB_PWR_TRAIN))
+		return;
+
+	ODM_RT_TRACE(dm, ODM_COMP_RA_MASK, "%s()============>\n", __func__);
+	dm->is_change_state = false;
+
+	/* Debug command */
+	if (dm->force_power_training_state) {
+		if (dm->force_power_training_state == 1 &&
+		    !dm->is_disable_power_training) {
+			dm->is_change_state = true;
+			dm->is_disable_power_training = true;
+		} else if (dm->force_power_training_state == 2 &&
+			   dm->is_disable_power_training) {
+			dm->is_change_state = true;
+			dm->is_disable_power_training = false;
+		}
+
+		dm->PT_score = 0;
+		dm->phy_dbg_info.num_qry_phy_status_ofdm = 0;
+		dm->phy_dbg_info.num_qry_phy_status_cck = 0;
+		ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+			     "%s(): force_power_training_state = %d\n",
+			     __func__, dm->force_power_training_state);
+		return;
+	}
+
+	if (!dm->is_linked)
+		return;
+
+	/* First connect */
+	if ((dm->is_linked) && !dig_tab->is_media_connect_0) {
+		dm->PT_score = 0;
+		dm->is_change_state = true;
+		dm->phy_dbg_info.num_qry_phy_status_ofdm = 0;
+		dm->phy_dbg_info.num_qry_phy_status_cck = 0;
+		ODM_RT_TRACE(dm, ODM_COMP_RA_MASK, "%s(): First Connect\n",
+			     __func__);
+		return;
+	}
+
+	/* Compute score */
+	if (dm->nhm_cnt_0 >= 215) {
+		score = 2;
+	} else if (dm->nhm_cnt_0 >= 190) {
+		score = 1; /* unknown state */
+	} else {
+		u32 rx_pkt_cnt;
+
+		rx_pkt_cnt = (u32)(dm->phy_dbg_info.num_qry_phy_status_ofdm) +
+			     (u32)(dm->phy_dbg_info.num_qry_phy_status_cck);
+
+		if ((false_alm_cnt->cnt_cca_all > 31 && rx_pkt_cnt > 31) &&
+		    (false_alm_cnt->cnt_cca_all >= rx_pkt_cnt)) {
+			if ((rx_pkt_cnt + (rx_pkt_cnt >> 1)) <=
+			    false_alm_cnt->cnt_cca_all)
+				score = 0;
+			else if ((rx_pkt_cnt + (rx_pkt_cnt >> 2)) <=
+				 false_alm_cnt->cnt_cca_all)
+				score = 1;
+			else
+				score = 2;
+		}
+		ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+			     "%s(): rx_pkt_cnt = %d, cnt_cca_all = %d\n",
+			     __func__, rx_pkt_cnt, false_alm_cnt->cnt_cca_all);
+	}
+	ODM_RT_TRACE(
+		dm, ODM_COMP_RA_MASK,
+		"%s(): num_qry_phy_status_ofdm = %d, num_qry_phy_status_cck = %d\n",
+		__func__, (u32)(dm->phy_dbg_info.num_qry_phy_status_ofdm),
+		(u32)(dm->phy_dbg_info.num_qry_phy_status_cck));
+	ODM_RT_TRACE(dm, ODM_COMP_RA_MASK, "%s(): nhm_cnt_0 = %d, score = %d\n",
+		     __func__, dm->nhm_cnt_0, score);
+
+	/* smoothing */
+	dm->PT_score = (score << 4) + (dm->PT_score >> 1) + (dm->PT_score >> 2);
+	score = (dm->PT_score + 32) >> 6;
+	ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+		     "%s(): PT_score = %d, score after smoothing = %d\n",
+		     __func__, dm->PT_score, score);
+
+	/* mode decision */
+	if (score == 2) {
+		if (dm->is_disable_power_training) {
+			dm->is_change_state = true;
+			dm->is_disable_power_training = false;
+			ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+				     "%s(): Change state\n", __func__);
+		}
+		ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+			     "%s(): Enable Power Training\n", __func__);
+	} else if (score == 0) {
+		if (!dm->is_disable_power_training) {
+			dm->is_change_state = true;
+			dm->is_disable_power_training = true;
+			ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+				     "%s(): Change state\n", __func__);
+		}
+		ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+			     "%s(): Disable Power Training\n", __func__);
+	}
+
+	dm->phy_dbg_info.num_qry_phy_status_ofdm = 0;
+	dm->phy_dbg_info.num_qry_phy_status_cck = 0;
+}
+
+/*===========================================================*/
+/* The following is for compile only*/
+/*===========================================================*/
+/*#define TARGET_CHNL_NUM_2G_5G	59*/
+/*===========================================================*/
+
+void phydm_noisy_detection(struct phy_dm_struct *dm)
+{
+	u32 total_fa_cnt, total_cca_cnt;
+	u32 score = 0, i, score_smooth;
+
+	total_cca_cnt = dm->false_alm_cnt.cnt_cca_all;
+	total_fa_cnt = dm->false_alm_cnt.cnt_all;
+
+	for (i = 0; i <= 16; i++) {
+		if (total_fa_cnt * 16 >= total_cca_cnt * (16 - i)) {
+			score = 16 - i;
+			break;
+		}
+	}
+
+	/* noisy_decision_smooth = noisy_decision_smooth>>1 + (score<<3)>>1; */
+	dm->noisy_decision_smooth =
+		(dm->noisy_decision_smooth >> 1) + (score << 2);
+
+	/* Round the noisy_decision_smooth: +"3" comes from (2^3)/2-1 */
+	score_smooth = (total_cca_cnt >= 300) ?
+			       ((dm->noisy_decision_smooth + 3) >> 3) :
+			       0;
+
+	dm->noisy_decision = (score_smooth >= 3) ? 1 : 0;
+	ODM_RT_TRACE(
+		dm, ODM_COMP_NOISY_DETECT,
+		"[NoisyDetection] total_cca_cnt=%d, total_fa_cnt=%d, noisy_decision_smooth=%d, score=%d, score_smooth=%d, dm->noisy_decision=%d\n",
+		total_cca_cnt, total_fa_cnt, dm->noisy_decision_smooth, score,
+		score_smooth, dm->noisy_decision);
+}
+
+void phydm_set_ext_switch(void *dm_void, u32 *const dm_value, u32 *_used,
+			  char *output, u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 ext_ant_switch = dm_value[0];
+
+	if (dm->support_ic_type & (ODM_RTL8821 | ODM_RTL8881A)) {
+		/*Output Pin Settings*/
+		odm_set_mac_reg(dm, 0x4C, BIT(23),
+				0); /*select DPDT_P and DPDT_N as output pin*/
+		odm_set_mac_reg(dm, 0x4C, BIT(24), 1); /*by WLAN control*/
+
+		odm_set_bb_reg(dm, 0xCB4, 0xF, 7); /*DPDT_P = 1b'0*/
+		odm_set_bb_reg(dm, 0xCB4, 0xF0, 7); /*DPDT_N = 1b'0*/
+
+		if (ext_ant_switch == MAIN_ANT) {
+			odm_set_bb_reg(dm, 0xCB4, (BIT(29) | BIT(28)), 1);
+			ODM_RT_TRACE(
+				dm, ODM_COMP_API,
+				"***8821A set ant switch = 2b'01 (Main)\n");
+		} else if (ext_ant_switch == AUX_ANT) {
+			odm_set_bb_reg(dm, 0xCB4, BIT(29) | BIT(28), 2);
+			ODM_RT_TRACE(dm, ODM_COMP_API,
+				     "***8821A set ant switch = 2b'10 (Aux)\n");
+		}
+	}
+}
+
+static void phydm_csi_mask_enable(void *dm_void, u32 enable)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 reg_value = 0;
+
+	reg_value = (enable == CSI_MASK_ENABLE) ? 1 : 0;
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		odm_set_bb_reg(dm, 0xD2C, BIT(28), reg_value);
+		ODM_RT_TRACE(dm, ODM_COMP_API,
+			     "Enable CSI Mask:  Reg 0xD2C[28] = ((0x%x))\n",
+			     reg_value);
+
+	} else if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		odm_set_bb_reg(dm, 0x874, BIT(0), reg_value);
+		ODM_RT_TRACE(dm, ODM_COMP_API,
+			     "Enable CSI Mask:  Reg 0x874[0] = ((0x%x))\n",
+			     reg_value);
+	}
+}
+
+static void phydm_clean_all_csi_mask(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		odm_set_bb_reg(dm, 0xD40, MASKDWORD, 0);
+		odm_set_bb_reg(dm, 0xD44, MASKDWORD, 0);
+		odm_set_bb_reg(dm, 0xD48, MASKDWORD, 0);
+		odm_set_bb_reg(dm, 0xD4c, MASKDWORD, 0);
+
+	} else if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		odm_set_bb_reg(dm, 0x880, MASKDWORD, 0);
+		odm_set_bb_reg(dm, 0x884, MASKDWORD, 0);
+		odm_set_bb_reg(dm, 0x888, MASKDWORD, 0);
+		odm_set_bb_reg(dm, 0x88c, MASKDWORD, 0);
+		odm_set_bb_reg(dm, 0x890, MASKDWORD, 0);
+		odm_set_bb_reg(dm, 0x894, MASKDWORD, 0);
+		odm_set_bb_reg(dm, 0x898, MASKDWORD, 0);
+		odm_set_bb_reg(dm, 0x89c, MASKDWORD, 0);
+	}
+}
+
+static void phydm_set_csi_mask_reg(void *dm_void, u32 tone_idx_tmp,
+				   u8 tone_direction)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 byte_offset, bit_offset;
+	u32 target_reg;
+	u8 reg_tmp_value;
+	u32 tone_num = 64;
+	u32 tone_num_shift = 0;
+	u32 csi_mask_reg_p = 0, csi_mask_reg_n = 0;
+
+	/* calculate real tone idx*/
+	if ((tone_idx_tmp % 10) >= 5)
+		tone_idx_tmp += 10;
+
+	tone_idx_tmp = (tone_idx_tmp / 10);
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		tone_num = 64;
+		csi_mask_reg_p = 0xD40;
+		csi_mask_reg_n = 0xD48;
+
+	} else if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		tone_num = 128;
+		csi_mask_reg_p = 0x880;
+		csi_mask_reg_n = 0x890;
+	}
+
+	if (tone_direction == FREQ_POSITIVE) {
+		if (tone_idx_tmp >= (tone_num - 1))
+			tone_idx_tmp = (tone_num - 1);
+
+		byte_offset = (u8)(tone_idx_tmp >> 3);
+		bit_offset = (u8)(tone_idx_tmp & 0x7);
+		target_reg = csi_mask_reg_p + byte_offset;
+
+	} else {
+		tone_num_shift = tone_num;
+
+		if (tone_idx_tmp >= tone_num)
+			tone_idx_tmp = tone_num;
+
+		tone_idx_tmp = tone_num - tone_idx_tmp;
+
+		byte_offset = (u8)(tone_idx_tmp >> 3);
+		bit_offset = (u8)(tone_idx_tmp & 0x7);
+		target_reg = csi_mask_reg_n + byte_offset;
+	}
+
+	reg_tmp_value = odm_read_1byte(dm, target_reg);
+	ODM_RT_TRACE(dm, ODM_COMP_API,
+		     "Pre Mask tone idx[%d]:  Reg0x%x = ((0x%x))\n",
+		     (tone_idx_tmp + tone_num_shift), target_reg,
+		     reg_tmp_value);
+	reg_tmp_value |= BIT(bit_offset);
+	odm_write_1byte(dm, target_reg, reg_tmp_value);
+	ODM_RT_TRACE(dm, ODM_COMP_API,
+		     "New Mask tone idx[%d]:  Reg0x%x = ((0x%x))\n",
+		     (tone_idx_tmp + tone_num_shift), target_reg,
+		     reg_tmp_value);
+}
+
+static void phydm_set_nbi_reg(void *dm_void, u32 tone_idx_tmp, u32 bw)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 nbi_table_128[NBI_TABLE_SIZE_128] = {
+		25, 55, 85, 115, 135, 155, 185, 205, 225, 245,
+		/*1~10*/ /*tone_idx X 10*/
+		265, 285, 305, 335, 355, 375, 395, 415, 435, 455, /*11~20*/
+		485, 505, 525, 555, 585, 615, 635}; /*21~27*/
+
+	u32 nbi_table_256[NBI_TABLE_SIZE_256] = {
+		25,   55,   85,   115,  135,  155,  175,  195,  225,
+		245, /*1~10*/
+		265,  285,  305,  325,  345,  365,  385,  405,  425,
+		445, /*11~20*/
+		465,  485,  505,  525,  545,  565,  585,  605,  625,
+		645, /*21~30*/
+		665,  695,  715,  735,  755,  775,  795,  815,  835,
+		855, /*31~40*/
+		875,  895,  915,  935,  955,  975,  995,  1015, 1035,
+		1055, /*41~50*/
+		1085, 1105, 1125, 1145, 1175, 1195, 1225, 1255, 1275}; /*51~59*/
+
+	u32 reg_idx = 0;
+	u32 i;
+	u8 nbi_table_idx = FFT_128_TYPE;
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		nbi_table_idx = FFT_128_TYPE;
+	} else if (dm->support_ic_type & ODM_IC_11AC_1_SERIES) {
+		nbi_table_idx = FFT_256_TYPE;
+	} else if (dm->support_ic_type & ODM_IC_11AC_2_SERIES) {
+		if (bw == 80)
+			nbi_table_idx = FFT_256_TYPE;
+		else /*20M, 40M*/
+			nbi_table_idx = FFT_128_TYPE;
+	}
+
+	if (nbi_table_idx == FFT_128_TYPE) {
+		for (i = 0; i < NBI_TABLE_SIZE_128; i++) {
+			if (tone_idx_tmp < nbi_table_128[i]) {
+				reg_idx = i + 1;
+				break;
+			}
+		}
+
+	} else if (nbi_table_idx == FFT_256_TYPE) {
+		for (i = 0; i < NBI_TABLE_SIZE_256; i++) {
+			if (tone_idx_tmp < nbi_table_256[i]) {
+				reg_idx = i + 1;
+				break;
+			}
+		}
+	}
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		odm_set_bb_reg(dm, 0xc40, 0x1f000000, reg_idx);
+		ODM_RT_TRACE(dm, ODM_COMP_API,
+			     "Set tone idx:  Reg0xC40[28:24] = ((0x%x))\n",
+			     reg_idx);
+		/**/
+	} else {
+		odm_set_bb_reg(dm, 0x87c, 0xfc000, reg_idx);
+		ODM_RT_TRACE(dm, ODM_COMP_API,
+			     "Set tone idx: Reg0x87C[19:14] = ((0x%x))\n",
+			     reg_idx);
+		/**/
+	}
+}
+
+static void phydm_nbi_enable(void *dm_void, u32 enable)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 reg_value = 0;
+
+	reg_value = (enable == NBI_ENABLE) ? 1 : 0;
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		odm_set_bb_reg(dm, 0xc40, BIT(9), reg_value);
+		ODM_RT_TRACE(dm, ODM_COMP_API,
+			     "Enable NBI Reg0xC40[9] = ((0x%x))\n", reg_value);
+
+	} else if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		odm_set_bb_reg(dm, 0x87c, BIT(13), reg_value);
+		ODM_RT_TRACE(dm, ODM_COMP_API,
+			     "Enable NBI Reg0x87C[13] = ((0x%x))\n", reg_value);
+	}
+}
+
+static u8 phydm_calculate_fc(void *dm_void, u32 channel, u32 bw, u32 second_ch,
+			     u32 *fc_in)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 fc = *fc_in;
+	u32 start_ch_per_40m[NUM_START_CH_40M + 1] = {
+		36,  44,  52,  60,  100, 108, 116,     124,
+		132, 140, 149, 157, 165, 173, 173 + 8,
+	};
+	u32 start_ch_per_80m[NUM_START_CH_80M + 1] = {
+		36, 52, 100, 116, 132, 149, 165, 165 + 16,
+	};
+	u32 *start_ch = &start_ch_per_40m[0];
+	u32 num_start_channel = NUM_START_CH_40M;
+	u32 channel_offset = 0;
+	u32 i;
+
+	/*2.4G*/
+	if (channel <= 14 && channel > 0) {
+		if (bw == 80)
+			return SET_ERROR;
+
+		fc = 2412 + (channel - 1) * 5;
+
+		if (bw == 40 && (second_ch == PHYDM_ABOVE)) {
+			if (channel >= 10) {
+				ODM_RT_TRACE(
+					dm, ODM_COMP_API,
+					"CH = ((%d)), Scnd_CH = ((%d)) Error setting\n",
+					channel, second_ch);
+				return SET_ERROR;
+			}
+			fc += 10;
+		} else if (bw == 40 && (second_ch == PHYDM_BELOW)) {
+			if (channel <= 2) {
+				ODM_RT_TRACE(
+					dm, ODM_COMP_API,
+					"CH = ((%d)), Scnd_CH = ((%d)) Error setting\n",
+					channel, second_ch);
+				return SET_ERROR;
+			}
+			fc -= 10;
+		}
+	}
+	/*5G*/
+	else if (channel >= 36 && channel <= 177) {
+		if (bw == 20) {
+			fc = 5180 + (channel - 36) * 5;
+			*fc_in = fc;
+			return SET_SUCCESS;
+		}
+
+		if (bw == 40) {
+			num_start_channel = NUM_START_CH_40M;
+			start_ch = &start_ch_per_40m[0];
+			channel_offset = CH_OFFSET_40M;
+		} else if (bw == 80) {
+			num_start_channel = NUM_START_CH_80M;
+			start_ch = &start_ch_per_80m[0];
+			channel_offset = CH_OFFSET_80M;
+		}
+
+		for (i = 0; i < num_start_channel; i++) {
+			if (channel < start_ch[i + 1]) {
+				channel = start_ch[i] + channel_offset;
+				break;
+			}
+		}
+
+		ODM_RT_TRACE(dm, ODM_COMP_API, "Mod_CH = ((%d))\n", channel);
+
+		fc = 5180 + (channel - 36) * 5;
+
+	} else {
+		ODM_RT_TRACE(dm, ODM_COMP_API, "CH = ((%d)) Error setting\n",
+			     channel);
+		return SET_ERROR;
+	}
+
+	*fc_in = fc;
+
+	return SET_SUCCESS;
+}
+
+static u8 phydm_calculate_intf_distance(void *dm_void, u32 bw, u32 fc,
+					u32 f_interference,
+					u32 *tone_idx_tmp_in)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 bw_up, bw_low;
+	u32 int_distance;
+	u32 tone_idx_tmp;
+	u8 set_result = SET_NO_NEED;
+
+	bw_up = fc + bw / 2;
+	bw_low = fc - bw / 2;
+
+	ODM_RT_TRACE(dm, ODM_COMP_API,
+		     "[f_l, fc, fh] = [ %d, %d, %d ], f_int = ((%d))\n", bw_low,
+		     fc, bw_up, f_interference);
+
+	if ((f_interference >= bw_low) && (f_interference <= bw_up)) {
+		int_distance = (fc >= f_interference) ? (fc - f_interference) :
+							(f_interference - fc);
+		tone_idx_tmp =
+			(int_distance << 5); /* =10*(int_distance /0.3125) */
+		ODM_RT_TRACE(
+			dm, ODM_COMP_API,
+			"int_distance = ((%d MHz)) Mhz, tone_idx_tmp = ((%d.%d))\n",
+			int_distance, (tone_idx_tmp / 10), (tone_idx_tmp % 10));
+		*tone_idx_tmp_in = tone_idx_tmp;
+		set_result = SET_SUCCESS;
+	}
+
+	return set_result;
+}
+
+static u8 phydm_csi_mask_setting(void *dm_void, u32 enable, u32 channel, u32 bw,
+				 u32 f_interference, u32 second_ch)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 fc;
+	u8 tone_direction;
+	u32 tone_idx_tmp;
+	u8 set_result = SET_SUCCESS;
+
+	if (enable == CSI_MASK_DISABLE) {
+		set_result = SET_SUCCESS;
+		phydm_clean_all_csi_mask(dm);
+
+	} else {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_API,
+			"[Set CSI MASK_] CH = ((%d)), BW = ((%d)), f_intf = ((%d)), Scnd_CH = ((%s))\n",
+			channel, bw, f_interference,
+			(((bw == 20) || (channel > 14)) ?
+				 "Don't care" :
+				 (second_ch == PHYDM_ABOVE) ? "H" : "L"));
+
+		/*calculate fc*/
+		if (phydm_calculate_fc(dm, channel, bw, second_ch, &fc) ==
+		    SET_ERROR) {
+			set_result = SET_ERROR;
+		} else {
+			/*calculate interference distance*/
+			if (phydm_calculate_intf_distance(
+				    dm, bw, fc, f_interference,
+				    &tone_idx_tmp) == SET_SUCCESS) {
+				tone_direction = (f_interference >= fc) ?
+							 FREQ_POSITIVE :
+							 FREQ_NEGATIVE;
+				phydm_set_csi_mask_reg(dm, tone_idx_tmp,
+						       tone_direction);
+				set_result = SET_SUCCESS;
+			} else {
+				set_result = SET_NO_NEED;
+			}
+		}
+	}
+
+	if (set_result == SET_SUCCESS)
+		phydm_csi_mask_enable(dm, enable);
+	else
+		phydm_csi_mask_enable(dm, CSI_MASK_DISABLE);
+
+	return set_result;
+}
+
+u8 phydm_nbi_setting(void *dm_void, u32 enable, u32 channel, u32 bw,
+		     u32 f_interference, u32 second_ch)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 fc;
+	u32 tone_idx_tmp;
+	u8 set_result = SET_SUCCESS;
+
+	if (enable == NBI_DISABLE) {
+		set_result = SET_SUCCESS;
+	} else {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_API,
+			"[Set NBI] CH = ((%d)), BW = ((%d)), f_intf = ((%d)), Scnd_CH = ((%s))\n",
+			channel, bw, f_interference,
+			(((second_ch == PHYDM_DONT_CARE) || (bw == 20) ||
+			  (channel > 14)) ?
+				 "Don't care" :
+				 (second_ch == PHYDM_ABOVE) ? "H" : "L"));
+
+		/*calculate fc*/
+		if (phydm_calculate_fc(dm, channel, bw, second_ch, &fc) ==
+		    SET_ERROR) {
+			set_result = SET_ERROR;
+		} else {
+			/*calculate interference distance*/
+			if (phydm_calculate_intf_distance(
+				    dm, bw, fc, f_interference,
+				    &tone_idx_tmp) == SET_SUCCESS) {
+				phydm_set_nbi_reg(dm, tone_idx_tmp, bw);
+				set_result = SET_SUCCESS;
+			} else {
+				set_result = SET_NO_NEED;
+			}
+		}
+	}
+
+	if (set_result == SET_SUCCESS)
+		phydm_nbi_enable(dm, enable);
+	else
+		phydm_nbi_enable(dm, NBI_DISABLE);
+
+	return set_result;
+}
+
+void phydm_api_debug(void *dm_void, u32 function_map, u32 *const dm_value,
+		     u32 *_used, char *output, u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+	u32 channel = dm_value[1];
+	u32 bw = dm_value[2];
+	u32 f_interference = dm_value[3];
+	u32 second_ch = dm_value[4];
+	u8 set_result = 0;
+
+	/*PHYDM_API_NBI*/
+	/*--------------------------------------------------------------------*/
+	if (function_map == PHYDM_API_NBI) {
+		if (dm_value[0] == 100) {
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"[HELP-NBI]  EN(on=1, off=2)   CH   BW(20/40/80)  f_intf(Mhz)    Scnd_CH(L=1, H=2)\n");
+			return;
+
+		} else if (dm_value[0] == NBI_ENABLE) {
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"[Enable NBI] CH = ((%d)), BW = ((%d)), f_intf = ((%d)), Scnd_CH = ((%s))\n",
+				channel, bw, f_interference,
+				((second_ch == PHYDM_DONT_CARE) || (bw == 20) ||
+				 (channel > 14)) ?
+					"Don't care" :
+					((second_ch == PHYDM_ABOVE) ? "H" :
+								      "L"));
+			set_result =
+				phydm_nbi_setting(dm, NBI_ENABLE, channel, bw,
+						  f_interference, second_ch);
+
+		} else if (dm_value[0] == NBI_DISABLE) {
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "[Disable NBI]\n");
+			set_result =
+				phydm_nbi_setting(dm, NBI_DISABLE, channel, bw,
+						  f_interference, second_ch);
+
+		} else {
+			set_result = SET_ERROR;
+		}
+
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "[NBI set result: %s]\n",
+			(set_result == SET_SUCCESS) ?
+				"Success" :
+				((set_result == SET_NO_NEED) ? "No need" :
+							       "Error"));
+	}
+
+	/*PHYDM_CSI_MASK*/
+	/*--------------------------------------------------------------------*/
+	else if (function_map == PHYDM_API_CSI_MASK) {
+		if (dm_value[0] == 100) {
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"[HELP-CSI MASK]  EN(on=1, off=2)   CH   BW(20/40/80)  f_intf(Mhz)    Scnd_CH(L=1, H=2)\n");
+			return;
+
+		} else if (dm_value[0] == CSI_MASK_ENABLE) {
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"[Enable CSI MASK] CH = ((%d)), BW = ((%d)), f_intf = ((%d)), Scnd_CH = ((%s))\n",
+				channel, bw, f_interference,
+				(channel > 14) ?
+					"Don't care" :
+					(((second_ch == PHYDM_DONT_CARE) ||
+					  (bw == 20) || (channel > 14)) ?
+						 "H" :
+						 "L"));
+			set_result = phydm_csi_mask_setting(
+				dm, CSI_MASK_ENABLE, channel, bw,
+				f_interference, second_ch);
+
+		} else if (dm_value[0] == CSI_MASK_DISABLE) {
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "[Disable CSI MASK]\n");
+			set_result = phydm_csi_mask_setting(
+				dm, CSI_MASK_DISABLE, channel, bw,
+				f_interference, second_ch);
+
+		} else {
+			set_result = SET_ERROR;
+		}
+
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "[CSI MASK set result: %s]\n",
+			       (set_result == SET_SUCCESS) ?
+				       "Success" :
+				       ((set_result == SET_NO_NEED) ?
+						"No need" :
+						"Error"));
+	}
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm.h b/drivers/staging/rtlwifi/phydm/phydm.h
new file mode 100644
index 000000000000..5812ff427ead
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm.h
@@ -0,0 +1,946 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __HALDMOUTSRC_H__
+#define __HALDMOUTSRC_H__
+
+/*============================================================*/
+/*include files*/
+/*============================================================*/
+#include "phydm_pre_define.h"
+#include "phydm_dig.h"
+#include "phydm_edcaturbocheck.h"
+#include "phydm_antdiv.h"
+#include "phydm_dynamicbbpowersaving.h"
+#include "phydm_rainfo.h"
+#include "phydm_dynamictxpower.h"
+#include "phydm_cfotracking.h"
+#include "phydm_acs.h"
+#include "phydm_adaptivity.h"
+#include "phydm_iqk.h"
+#include "phydm_dfs.h"
+#include "phydm_ccx.h"
+#include "txbf/phydm_hal_txbf_api.h"
+
+#include "phydm_adc_sampling.h"
+#include "phydm_dynamic_rx_path.h"
+#include "phydm_psd.h"
+
+#include "phydm_beamforming.h"
+
+#include "phydm_noisemonitor.h"
+#include "halphyrf_ce.h"
+
+/*============================================================*/
+/*Definition */
+/*============================================================*/
+
+/* Traffic load decision */
+#define TRAFFIC_ULTRA_LOW 1
+#define TRAFFIC_LOW 2
+#define TRAFFIC_MID 3
+#define TRAFFIC_HIGH 4
+
+#define NONE 0
+
+/*NBI API------------------------------------*/
+#define NBI_ENABLE 1
+#define NBI_DISABLE 2
+
+#define NBI_TABLE_SIZE_128 27
+#define NBI_TABLE_SIZE_256 59
+
+#define NUM_START_CH_80M 7
+#define NUM_START_CH_40M 14
+
+#define CH_OFFSET_40M 2
+#define CH_OFFSET_80M 6
+
+/*CSI MASK API------------------------------------*/
+#define CSI_MASK_ENABLE 1
+#define CSI_MASK_DISABLE 2
+
+/*------------------------------------------------*/
+
+#define FFT_128_TYPE 1
+#define FFT_256_TYPE 2
+
+#define SET_SUCCESS 1
+#define SET_ERROR 2
+#define SET_NO_NEED 3
+
+#define FREQ_POSITIVE 1
+#define FREQ_NEGATIVE 2
+
+#define PHYDM_WATCH_DOG_PERIOD 2
+
+/*============================================================*/
+/*structure and define*/
+/*============================================================*/
+
+/*2011/09/20 MH Add for AP/ADSLpseudo DM structuer requirement.*/
+/*We need to remove to other position???*/
+
+struct rtl8192cd_priv {
+	u8 temp;
+};
+
+struct dyn_primary_cca {
+	u8 pri_cca_flag;
+	u8 intf_flag;
+	u8 intf_type;
+	u8 dup_rts_flag;
+	u8 monitor_flag;
+	u8 ch_offset;
+	u8 mf_state;
+};
+
+#define dm_type_by_fw 0
+#define dm_type_by_driver 1
+
+/*Declare for common info*/
+
+#define IQK_THRESHOLD 8
+#define DPK_THRESHOLD 4
+
+struct dm_phy_status_info {
+	/*  */
+	/* Be care, if you want to add any element please insert between */
+	/* rx_pwdb_all & signal_strength. */
+	/*  */
+	u8 rx_pwdb_all;
+	u8 signal_quality; /* in 0-100 index. */
+	s8 rx_mimo_signal_quality[4]; /* per-path's EVM translate to 0~100% */
+	u8 rx_mimo_evm_dbm[4]; /* per-path's original EVM (dbm) */
+	u8 rx_mimo_signal_strength[4]; /* in 0~100 index */
+	s16 cfo_short[4]; /* per-path's cfo_short */
+	s16 cfo_tail[4]; /* per-path's cfo_tail */
+	s8 rx_power; /* in dBm Translate from PWdB */
+	s8 recv_signal_power; /* Real power in dBm for this packet,
+			       * no beautification and aggregation.
+			       * Keep this raw info to be used for the other
+			       * procedures.
+			       */
+	u8 bt_rx_rssi_percentage;
+	u8 signal_strength; /* in 0-100 index. */
+	s8 rx_pwr[4]; /* per-path's pwdb */
+	s8 rx_snr[4]; /* per-path's SNR	*/
+	/* s8      BB_Backup[13];                   backup reg. */
+	u8 rx_count : 2; /* RX path counter---*/
+	u8 band_width : 2;
+	u8 rxsc : 4; /* sub-channel---*/
+	u8 bt_coex_pwr_adjust;
+	u8 channel; /* channel number---*/
+	bool is_mu_packet; /* is MU packet or not---*/
+	bool is_beamformed; /* BF packet---*/
+};
+
+struct dm_per_pkt_info {
+	u8 data_rate;
+	u8 station_id;
+	bool is_packet_match_bssid;
+	bool is_packet_to_self;
+	bool is_packet_beacon;
+	bool is_to_self;
+	u8 ppdu_cnt;
+};
+
+struct odm_phy_dbg_info {
+	/*ODM Write,debug info*/
+	s8 rx_snr_db[4];
+	u32 num_qry_phy_status;
+	u32 num_qry_phy_status_cck;
+	u32 num_qry_phy_status_ofdm;
+	u32 num_qry_mu_pkt;
+	u32 num_qry_bf_pkt;
+	u32 num_qry_mu_vht_pkt[40];
+	u32 num_qry_vht_pkt[40];
+	bool is_ldpc_pkt;
+	bool is_stbc_pkt;
+	u8 num_of_ppdu[4];
+	u8 gid_num[4];
+	u8 num_qry_beacon_pkt;
+	/* Others */
+	s32 rx_evm[4];
+};
+
+/*2011/20/20 MH For MP driver RT_WLAN_STA =  struct rtl_sta_info*/
+/*Please declare below ODM relative info in your STA info structure.*/
+
+struct odm_sta_info {
+	/*Driver Write*/
+	bool is_used; /*record the sta status link or not?*/
+	u8 iot_peer; /*Enum value.	HT_IOT_PEER_E*/
+
+	/*ODM Write*/
+	/*PHY_STATUS_INFO*/
+	u8 rssi_path[4];
+	u8 rssi_ave;
+	u8 RXEVM[4];
+	u8 RXSNR[4];
+};
+
+enum odm_cmninfo {
+	/*Fixed value*/
+	/*-----------HOOK BEFORE REG INIT-----------*/
+	ODM_CMNINFO_PLATFORM = 0,
+	ODM_CMNINFO_ABILITY,
+	ODM_CMNINFO_INTERFACE,
+	ODM_CMNINFO_MP_TEST_CHIP,
+	ODM_CMNINFO_IC_TYPE,
+	ODM_CMNINFO_CUT_VER,
+	ODM_CMNINFO_FAB_VER,
+	ODM_CMNINFO_RF_TYPE,
+	ODM_CMNINFO_RFE_TYPE,
+	ODM_CMNINFO_BOARD_TYPE,
+	ODM_CMNINFO_PACKAGE_TYPE,
+	ODM_CMNINFO_EXT_LNA,
+	ODM_CMNINFO_5G_EXT_LNA,
+	ODM_CMNINFO_EXT_PA,
+	ODM_CMNINFO_5G_EXT_PA,
+	ODM_CMNINFO_GPA,
+	ODM_CMNINFO_APA,
+	ODM_CMNINFO_GLNA,
+	ODM_CMNINFO_ALNA,
+	ODM_CMNINFO_EXT_TRSW,
+	ODM_CMNINFO_DPK_EN,
+	ODM_CMNINFO_EXT_LNA_GAIN,
+	ODM_CMNINFO_PATCH_ID,
+	ODM_CMNINFO_BINHCT_TEST,
+	ODM_CMNINFO_BWIFI_TEST,
+	ODM_CMNINFO_SMART_CONCURRENT,
+	ODM_CMNINFO_CONFIG_BB_RF,
+	ODM_CMNINFO_DOMAIN_CODE_2G,
+	ODM_CMNINFO_DOMAIN_CODE_5G,
+	ODM_CMNINFO_IQKFWOFFLOAD,
+	ODM_CMNINFO_IQKPAOFF,
+	ODM_CMNINFO_HUBUSBMODE,
+	ODM_CMNINFO_FWDWRSVDPAGEINPROGRESS,
+	ODM_CMNINFO_TX_TP,
+	ODM_CMNINFO_RX_TP,
+	ODM_CMNINFO_SOUNDING_SEQ,
+	ODM_CMNINFO_REGRFKFREEENABLE,
+	ODM_CMNINFO_RFKFREEENABLE,
+	ODM_CMNINFO_NORMAL_RX_PATH_CHANGE,
+	ODM_CMNINFO_EFUSE0X3D8,
+	ODM_CMNINFO_EFUSE0X3D7,
+	/*-----------HOOK BEFORE REG INIT-----------*/
+
+	/*Dynamic value:*/
+
+	/*--------- POINTER REFERENCE-----------*/
+	ODM_CMNINFO_MAC_PHY_MODE,
+	ODM_CMNINFO_TX_UNI,
+	ODM_CMNINFO_RX_UNI,
+	ODM_CMNINFO_WM_MODE,
+	ODM_CMNINFO_BAND,
+	ODM_CMNINFO_SEC_CHNL_OFFSET,
+	ODM_CMNINFO_SEC_MODE,
+	ODM_CMNINFO_BW,
+	ODM_CMNINFO_CHNL,
+	ODM_CMNINFO_FORCED_RATE,
+	ODM_CMNINFO_ANT_DIV,
+	ODM_CMNINFO_ADAPTIVITY,
+	ODM_CMNINFO_DMSP_GET_VALUE,
+	ODM_CMNINFO_BUDDY_ADAPTOR,
+	ODM_CMNINFO_DMSP_IS_MASTER,
+	ODM_CMNINFO_SCAN,
+	ODM_CMNINFO_POWER_SAVING,
+	ODM_CMNINFO_ONE_PATH_CCA,
+	ODM_CMNINFO_DRV_STOP,
+	ODM_CMNINFO_PNP_IN,
+	ODM_CMNINFO_INIT_ON,
+	ODM_CMNINFO_ANT_TEST,
+	ODM_CMNINFO_NET_CLOSED,
+	ODM_CMNINFO_FORCED_IGI_LB,
+	ODM_CMNINFO_P2P_LINK,
+	ODM_CMNINFO_FCS_MODE,
+	ODM_CMNINFO_IS1ANTENNA,
+	ODM_CMNINFO_RFDEFAULTPATH,
+	ODM_CMNINFO_DFS_MASTER_ENABLE,
+	ODM_CMNINFO_FORCE_TX_ANT_BY_TXDESC,
+	ODM_CMNINFO_SET_S0S1_DEFAULT_ANTENNA,
+	/*--------- POINTER REFERENCE-----------*/
+
+	/*------------CALL BY VALUE-------------*/
+	ODM_CMNINFO_WIFI_DIRECT,
+	ODM_CMNINFO_WIFI_DISPLAY,
+	ODM_CMNINFO_LINK_IN_PROGRESS,
+	ODM_CMNINFO_LINK,
+	ODM_CMNINFO_CMW500LINK,
+	ODM_CMNINFO_LPSPG,
+	ODM_CMNINFO_STATION_STATE,
+	ODM_CMNINFO_RSSI_MIN,
+	ODM_CMNINFO_DBG_COMP,
+	ODM_CMNINFO_DBG_LEVEL,
+	ODM_CMNINFO_RA_THRESHOLD_HIGH,
+	ODM_CMNINFO_RA_THRESHOLD_LOW,
+	ODM_CMNINFO_RF_ANTENNA_TYPE,
+	ODM_CMNINFO_WITH_EXT_ANTENNA_SWITCH,
+	ODM_CMNINFO_BE_FIX_TX_ANT,
+	ODM_CMNINFO_BT_ENABLED,
+	ODM_CMNINFO_BT_HS_CONNECT_PROCESS,
+	ODM_CMNINFO_BT_HS_RSSI,
+	ODM_CMNINFO_BT_OPERATION,
+	ODM_CMNINFO_BT_LIMITED_DIG,
+	ODM_CMNINFO_BT_DIG,
+	ODM_CMNINFO_BT_BUSY,
+	ODM_CMNINFO_BT_DISABLE_EDCA,
+	ODM_CMNINFO_AP_TOTAL_NUM,
+	ODM_CMNINFO_POWER_TRAINING,
+	ODM_CMNINFO_DFS_REGION_DOMAIN,
+	/*------------CALL BY VALUE-------------*/
+
+	/*Dynamic ptr array hook itms.*/
+	ODM_CMNINFO_STA_STATUS,
+	ODM_CMNINFO_MAX,
+
+};
+
+enum phydm_info_query {
+	PHYDM_INFO_FA_OFDM,
+	PHYDM_INFO_FA_CCK,
+	PHYDM_INFO_FA_TOTAL,
+	PHYDM_INFO_CCA_OFDM,
+	PHYDM_INFO_CCA_CCK,
+	PHYDM_INFO_CCA_ALL,
+	PHYDM_INFO_CRC32_OK_VHT,
+	PHYDM_INFO_CRC32_OK_HT,
+	PHYDM_INFO_CRC32_OK_LEGACY,
+	PHYDM_INFO_CRC32_OK_CCK,
+	PHYDM_INFO_CRC32_ERROR_VHT,
+	PHYDM_INFO_CRC32_ERROR_HT,
+	PHYDM_INFO_CRC32_ERROR_LEGACY,
+	PHYDM_INFO_CRC32_ERROR_CCK,
+	PHYDM_INFO_EDCCA_FLAG,
+	PHYDM_INFO_OFDM_ENABLE,
+	PHYDM_INFO_CCK_ENABLE,
+	PHYDM_INFO_DBG_PORT_0
+};
+
+enum phydm_api {
+	PHYDM_API_NBI = 1,
+	PHYDM_API_CSI_MASK,
+
+};
+
+/*2011/10/20 MH Define ODM support ability.  ODM_CMNINFO_ABILITY*/
+enum odm_ability {
+	/*BB ODM section BIT 0-19*/
+	ODM_BB_DIG = BIT(0),
+	ODM_BB_RA_MASK = BIT(1),
+	ODM_BB_DYNAMIC_TXPWR = BIT(2),
+	ODM_BB_FA_CNT = BIT(3),
+	ODM_BB_RSSI_MONITOR = BIT(4),
+	ODM_BB_CCK_PD = BIT(5),
+	ODM_BB_ANT_DIV = BIT(6),
+	ODM_BB_PWR_TRAIN = BIT(8),
+	ODM_BB_RATE_ADAPTIVE = BIT(9),
+	ODM_BB_PATH_DIV = BIT(10),
+	ODM_BB_ADAPTIVITY = BIT(13),
+	ODM_BB_CFO_TRACKING = BIT(14),
+	ODM_BB_NHM_CNT = BIT(15),
+	ODM_BB_PRIMARY_CCA = BIT(16),
+	ODM_BB_TXBF = BIT(17),
+	ODM_BB_DYNAMIC_ARFR = BIT(18),
+
+	ODM_MAC_EDCA_TURBO = BIT(20),
+	ODM_BB_DYNAMIC_RX_PATH = BIT(21),
+
+	/*RF ODM section BIT 24-31*/
+	ODM_RF_TX_PWR_TRACK = BIT(24),
+	ODM_RF_RX_GAIN_TRACK = BIT(25),
+	ODM_RF_CALIBRATION = BIT(26),
+
+};
+
+/*ODM_CMNINFO_ONE_PATH_CCA*/
+enum odm_cca_path {
+	ODM_CCA_2R = 0,
+	ODM_CCA_1R_A = 1,
+	ODM_CCA_1R_B = 2,
+};
+
+enum cca_pathdiv_en {
+	CCA_PATHDIV_DISABLE = 0,
+	CCA_PATHDIV_ENABLE = 1,
+
+};
+
+enum phy_reg_pg_type {
+	PHY_REG_PG_RELATIVE_VALUE = 0,
+	PHY_REG_PG_EXACT_VALUE = 1
+};
+
+/*2011/09/22 MH Copy from SD4 defined structure.
+ *We use to support PHY DM integration.
+ */
+
+struct phy_dm_struct {
+	/*Add for different team use temporarily*/
+	void *adapter; /*For CE/NIC team*/
+	struct rtl8192cd_priv *priv; /*For AP/ADSL team*/
+	/*When you use adapter or priv pointer,
+	 *you must make sure the pointer is ready.
+	 */
+	bool odm_ready;
+
+	struct rtl8192cd_priv fake_priv;
+
+	enum phy_reg_pg_type phy_reg_pg_value_type;
+	u8 phy_reg_pg_version;
+
+	u32 debug_components;
+	u32 fw_debug_components;
+	u32 debug_level;
+
+	u32 num_qry_phy_status_all; /*CCK + OFDM*/
+	u32 last_num_qry_phy_status_all;
+	u32 rx_pwdb_ave;
+	bool MPDIG_2G; /*off MPDIG*/
+	u8 times_2g;
+	bool is_init_hw_info_by_rfe;
+
+	/*------ ODM HANDLE, DRIVER NEEDS NOT TO HOOK------*/
+	bool is_cck_high_power;
+	u8 rf_path_rx_enable;
+	u8 control_channel;
+	/*------ ODM HANDLE, DRIVER NEEDS NOT TO HOOK------*/
+
+	/* 1  COMMON INFORMATION */
+
+	/*Init value*/
+	/*-----------HOOK BEFORE REG INIT-----------*/
+	/*ODM Platform info AP/ADSL/CE/MP = 1/2/3/4*/
+	u8 support_platform;
+	/* ODM Platform info WIN/AP/CE = 1/2/3 */
+	u8 normal_rx_path;
+	/*ODM Support Ability DIG/RATR/TX_PWR_TRACK/ ... = 1/2/3/...*/
+	u32 support_ability;
+	/*ODM PCIE/USB/SDIO = 1/2/3*/
+	u8 support_interface;
+	/*ODM composite or independent. Bit oriented/ 92C+92D+ .... or
+	 *any other type = 1/2/3/...
+	 */
+	u32 support_ic_type;
+	/*cut version TestChip/A-cut/B-cut... = 0/1/2/3/...*/
+	u8 cut_version;
+	/*Fab version TSMC/UMC = 0/1*/
+	u8 fab_version;
+	/*RF type 4T4R/3T3R/2T2R/1T2R/1T1R/...*/
+	u8 rf_type;
+	u8 rfe_type;
+	/*Board type Normal/HighPower/MiniCard/SLIM/Combo/... = 0/1/2/3/4/...*/
+	/*Enable Function DPK OFF/ON = 0/1*/
+	u8 dpk_en;
+	u8 board_type;
+	u8 package_type;
+	u16 type_glna;
+	u16 type_gpa;
+	u16 type_alna;
+	u16 type_apa;
+	/*with external LNA  NO/Yes = 0/1*/
+	u8 ext_lna; /*2G*/
+	u8 ext_lna_5g; /*5G*/
+	/*with external PA  NO/Yes = 0/1*/
+	u8 ext_pa; /*2G*/
+	u8 ext_pa_5g; /*5G*/
+	/*with Efuse number*/
+	u8 efuse0x3d7;
+	u8 efuse0x3d8;
+	/*with external TRSW  NO/Yes = 0/1*/
+	u8 ext_trsw;
+	u8 ext_lna_gain; /*2G*/
+	u8 patch_id; /*Customer ID*/
+	bool is_in_hct_test;
+	u8 wifi_test;
+
+	bool is_dual_mac_smart_concurrent;
+	u32 bk_support_ability;
+	u8 ant_div_type;
+	u8 with_extenal_ant_switch;
+	bool config_bbrf;
+	u8 odm_regulation_2_4g;
+	u8 odm_regulation_5g;
+	u8 iqk_fw_offload;
+	bool cck_new_agc;
+	u8 phydm_period;
+	u32 phydm_sys_up_time;
+	u8 num_rf_path;
+	/*-----------HOOK BEFORE REG INIT-----------*/
+
+	/*Dynamic value*/
+
+	/*--------- POINTER REFERENCE-----------*/
+
+	u8 u1_byte_temp;
+	bool BOOLEAN_temp;
+	void *PADAPTER_temp;
+
+	/*MAC PHY mode SMSP/DMSP/DMDP = 0/1/2*/
+	u8 *mac_phy_mode;
+	/*TX Unicast byte count*/
+	u64 *num_tx_bytes_unicast;
+	/*RX Unicast byte count*/
+	u64 *num_rx_bytes_unicast;
+	/*Wireless mode B/G/A/N = BIT0/BIT1/BIT2/BIT3*/
+	u8 *wireless_mode;
+	/*Frequence band 2.4G/5G = 0/1*/
+	u8 *band_type;
+	/*Secondary channel offset don't_care/below/above = 0/1/2*/
+	u8 *sec_ch_offset;
+	/*security mode Open/WEP/AES/TKIP = 0/1/2/3*/
+	u8 *security;
+	/*BW info 20M/40M/80M = 0/1/2*/
+	u8 *band_width;
+	/*Central channel location Ch1/Ch2/....*/
+	u8 *channel; /*central channel number*/
+	bool dpk_done;
+	/*Common info for 92D DMSP*/
+
+	bool *is_get_value_from_other_mac;
+	void **buddy_adapter;
+	bool *is_master_of_dmsp; /* MAC0: master, MAC1: slave */
+	/*Common info for status*/
+	bool *is_scan_in_process;
+	bool *is_power_saving;
+	/*CCA path 2-path/path-A/path-B = 0/1/2; using enum odm_cca_path.*/
+	u8 *one_path_cca;
+	u8 *antenna_test;
+	bool *is_net_closed;
+	u8 *pu1_forced_igi_lb;
+	bool *is_fcs_mode_enable;
+	/*--------- For 8723B IQK-----------*/
+	bool *is_1_antenna;
+	u8 *rf_default_path;
+	/* 0:S1, 1:S0 */
+
+	/*--------- POINTER REFERENCE-----------*/
+	u16 *forced_data_rate;
+	u8 *enable_antdiv;
+	u8 *enable_adaptivity;
+	u8 *hub_usb_mode;
+	bool *is_fw_dw_rsvd_page_in_progress;
+	u32 *current_tx_tp;
+	u32 *current_rx_tp;
+	u8 *sounding_seq;
+	/*------------CALL BY VALUE-------------*/
+	bool is_link_in_process;
+	bool is_wifi_direct;
+	bool is_wifi_display;
+	bool is_linked;
+	bool is_linkedcmw500;
+	bool is_in_lps_pg;
+	bool bsta_state;
+	u8 rssi_min;
+	u8 interface_index; /*Add for 92D  dual MAC: 0--Mac0 1--Mac1*/
+	bool is_mp_chip;
+	bool is_one_entry_only;
+	bool mp_mode;
+	u32 one_entry_macid;
+	u8 pre_number_linked_client;
+	u8 number_linked_client;
+	u8 pre_number_active_client;
+	u8 number_active_client;
+	/*Common info for BTDM*/
+	bool is_bt_enabled; /*BT is enabled*/
+	bool is_bt_connect_process; /*BT HS is under connection progress.*/
+	u8 bt_hs_rssi; /*BT HS mode wifi rssi value.*/
+	bool is_bt_hs_operation; /*BT HS mode is under progress*/
+	u8 bt_hs_dig_val; /*use BT rssi to decide the DIG value*/
+	bool is_bt_disable_edca_turbo; /*Under some condition, don't enable*/
+	bool is_bt_busy; /*BT is busy.*/
+	bool is_bt_limited_dig; /*BT is busy.*/
+	bool is_disable_phy_api;
+	/*------------CALL BY VALUE-------------*/
+	u8 rssi_a;
+	u8 rssi_b;
+	u8 rssi_c;
+	u8 rssi_d;
+	u64 rssi_trsw;
+	u64 rssi_trsw_h;
+	u64 rssi_trsw_l;
+	u64 rssi_trsw_iso;
+	u8 tx_ant_status;
+	u8 rx_ant_status;
+	u8 cck_lna_idx;
+	u8 cck_vga_idx;
+	u8 curr_station_id;
+	u8 ofdm_agc_idx[4];
+
+	u8 rx_rate;
+	bool is_noisy_state;
+	u8 tx_rate;
+	u8 linked_interval;
+	u8 pre_channel;
+	u32 txagc_offset_value_a;
+	bool is_txagc_offset_positive_a;
+	u32 txagc_offset_value_b;
+	bool is_txagc_offset_positive_b;
+	u32 tx_tp;
+	u32 rx_tp;
+	u32 total_tp;
+	u64 cur_tx_ok_cnt;
+	u64 cur_rx_ok_cnt;
+	u64 last_tx_ok_cnt;
+	u64 last_rx_ok_cnt;
+	u32 bb_swing_offset_a;
+	bool is_bb_swing_offset_positive_a;
+	u32 bb_swing_offset_b;
+	bool is_bb_swing_offset_positive_b;
+	u8 igi_lower_bound;
+	u8 igi_upper_bound;
+	u8 antdiv_rssi;
+	u8 fat_comb_a;
+	u8 fat_comb_b;
+	u8 antdiv_intvl;
+	u8 ant_type;
+	u8 pre_ant_type;
+	u8 antdiv_period;
+	u8 evm_antdiv_period;
+	u8 antdiv_select;
+	u8 path_select;
+	u8 antdiv_evm_en;
+	u8 bdc_holdstate;
+	u8 ndpa_period;
+	bool h2c_rarpt_connect;
+	bool cck_agc_report_type;
+
+	u8 dm_dig_max_TH;
+	u8 dm_dig_min_TH;
+	u8 print_agc;
+	u8 traffic_load;
+	u8 pre_traffic_load;
+	/*8821C Antenna BTG/WLG/WLA Select*/
+	u8 current_rf_set_8821c;
+	u8 default_rf_set_8821c;
+	/*For Adaptivtiy*/
+	u16 nhm_cnt_0;
+	u16 nhm_cnt_1;
+	s8 TH_L2H_default;
+	s8 th_edcca_hl_diff_default;
+	s8 th_l2h_ini;
+	s8 th_edcca_hl_diff;
+	s8 th_l2h_ini_mode2;
+	s8 th_edcca_hl_diff_mode2;
+	bool carrier_sense_enable;
+	u8 adaptivity_igi_upper;
+	bool adaptivity_flag;
+	u8 dc_backoff;
+	bool adaptivity_enable;
+	u8 ap_total_num;
+	bool edcca_enable;
+	u8 pre_dbg_priority;
+	struct adaptivity_statistics adaptivity;
+	/*For Adaptivtiy*/
+	u8 last_usb_hub;
+	u8 tx_bf_data_rate;
+
+	u8 nbi_set_result;
+
+	u8 c2h_cmd_start;
+	u8 fw_debug_trace[60];
+	u8 pre_c2h_seq;
+	bool fw_buff_is_enpty;
+	u32 data_frame_num;
+
+	/*for noise detection*/
+	bool noisy_decision; /*b_noisy*/
+	bool pre_b_noisy;
+	u32 noisy_decision_smooth;
+	bool is_disable_dym_ecs;
+
+	struct odm_noise_monitor noise_level;
+	/*Define STA info.*/
+	/*odm_sta_info*/
+	/*2012/01/12 MH For MP,
+	 *we need to reduce one array pointer for default port.??
+	 */
+	struct rtl_sta_info *odm_sta_info[ODM_ASSOCIATE_ENTRY_NUM];
+	u16 platform2phydm_macid_table[ODM_ASSOCIATE_ENTRY_NUM];
+	/* platform_macid_table[platform_macid] = phydm_macid */
+	s32 accumulate_pwdb[ODM_ASSOCIATE_ENTRY_NUM];
+
+	/*2012/02/14 MH Add to share 88E ra with other SW team.*/
+	/*We need to colelct all support abilit to a proper area.*/
+
+	bool ra_support88e;
+
+	struct odm_phy_dbg_info phy_dbg_info;
+
+	/*ODM Structure*/
+	struct fast_antenna_training dm_fat_table;
+	struct dig_thres dm_dig_table;
+	struct dyn_pwr_saving dm_ps_table;
+	struct dyn_primary_cca dm_pri_cca;
+	struct ra_table dm_ra_table;
+	struct false_alarm_stat false_alm_cnt;
+	struct false_alarm_stat flase_alm_cnt_buddy_adapter;
+	struct sw_antenna_switch dm_swat_table;
+	struct cfo_tracking dm_cfo_track;
+	struct acs_info dm_acs;
+	struct ccx_info dm_ccx_info;
+	struct psd_info dm_psd_table;
+
+	struct rt_adcsmp adcsmp;
+
+	struct dm_iqk_info IQK_info;
+
+	struct edca_turbo dm_edca_table;
+	u32 WMMEDCA_BE;
+
+	bool *is_driver_stopped;
+	bool *is_driver_is_going_to_pnp_set_power_sleep;
+	bool *pinit_adpt_in_progress;
+
+	/*PSD*/
+	bool is_user_assign_level;
+	u8 RSSI_BT; /*come from BT*/
+	bool is_psd_in_process;
+	bool is_psd_active;
+	bool is_dm_initial_gain_enable;
+
+	/*MPT DIG*/
+	struct timer_list mpt_dig_timer;
+
+	/*for rate adaptive, in fact,  88c/92c fw will handle this*/
+	u8 is_use_ra_mask;
+
+	/* for dynamic SoML control */
+	bool bsomlenabled;
+
+	struct odm_rate_adaptive rate_adaptive;
+	struct dm_rf_calibration_struct rf_calibrate_info;
+	u32 n_iqk_cnt;
+	u32 n_iqk_ok_cnt;
+	u32 n_iqk_fail_cnt;
+
+	/*Power Training*/
+	u8 force_power_training_state;
+	bool is_change_state;
+	u32 PT_score;
+	u64 ofdm_rx_cnt;
+	u64 cck_rx_cnt;
+	bool is_disable_power_training;
+	u8 dynamic_tx_high_power_lvl;
+	u8 last_dtp_lvl;
+	u32 tx_agc_ofdm_18_6;
+	u8 rx_pkt_type;
+
+	/*ODM relative time.*/
+	struct timer_list path_div_switch_timer;
+	/*2011.09.27 add for path Diversity*/
+	struct timer_list cck_path_diversity_timer;
+	struct timer_list fast_ant_training_timer;
+	struct timer_list sbdcnt_timer;
+
+	/*ODM relative workitem.*/
+};
+
+enum phydm_structure_type {
+	PHYDM_FALSEALMCNT,
+	PHYDM_CFOTRACK,
+	PHYDM_ADAPTIVITY,
+	PHYDM_ROMINFO,
+
+};
+
+enum odm_rf_content {
+	odm_radioa_txt = 0x1000,
+	odm_radiob_txt = 0x1001,
+	odm_radioc_txt = 0x1002,
+	odm_radiod_txt = 0x1003
+};
+
+enum odm_bb_config_type {
+	CONFIG_BB_PHY_REG,
+	CONFIG_BB_AGC_TAB,
+	CONFIG_BB_AGC_TAB_2G,
+	CONFIG_BB_AGC_TAB_5G,
+	CONFIG_BB_PHY_REG_PG,
+	CONFIG_BB_PHY_REG_MP,
+	CONFIG_BB_AGC_TAB_DIFF,
+};
+
+enum odm_rf_config_type {
+	CONFIG_RF_RADIO,
+	CONFIG_RF_TXPWR_LMT,
+};
+
+enum odm_fw_config_type {
+	CONFIG_FW_NIC,
+	CONFIG_FW_NIC_2,
+	CONFIG_FW_AP,
+	CONFIG_FW_AP_2,
+	CONFIG_FW_MP,
+	CONFIG_FW_WOWLAN,
+	CONFIG_FW_WOWLAN_2,
+	CONFIG_FW_AP_WOWLAN,
+	CONFIG_FW_BT,
+};
+
+/*status code*/
+enum rt_status {
+	RT_STATUS_SUCCESS,
+	RT_STATUS_FAILURE,
+	RT_STATUS_PENDING,
+	RT_STATUS_RESOURCE,
+	RT_STATUS_INVALID_CONTEXT,
+	RT_STATUS_INVALID_PARAMETER,
+	RT_STATUS_NOT_SUPPORT,
+	RT_STATUS_OS_API_FAILED,
+};
+
+/*===========================================================*/
+/*AGC RX High Power mode*/
+/*===========================================================*/
+#define lna_low_gain_1 0x64
+#define lna_low_gain_2 0x5A
+#define lna_low_gain_3 0x58
+
+#define FA_RXHP_TH1 5000
+#define FA_RXHP_TH2 1500
+#define FA_RXHP_TH3 800
+#define FA_RXHP_TH4 600
+#define FA_RXHP_TH5 500
+
+enum dm_1r_cca {
+	CCA_1R = 0,
+	CCA_2R = 1,
+	CCA_MAX = 2,
+};
+
+enum dm_rf {
+	rf_save = 0,
+	rf_normal = 1,
+	RF_MAX = 2,
+};
+
+/*check Sta pointer valid or not*/
+
+#define IS_STA_VALID(sta) (sta)
+
+u32 odm_convert_to_db(u32 value);
+
+u32 odm_convert_to_linear(u32 value);
+
+s32 odm_pwdb_conversion(s32 X, u32 total_bit, u32 decimal_bit);
+
+s32 odm_sign_conversion(s32 value, u32 total_bit);
+
+void odm_init_mp_driver_status(struct phy_dm_struct *dm);
+
+void phydm_txcurrentcalibration(struct phy_dm_struct *dm);
+
+void phydm_seq_sorting(void *dm_void, u32 *value, u32 *rank_idx, u32 *idx_out,
+		       u8 seq_length);
+
+void odm_dm_init(struct phy_dm_struct *dm);
+
+void odm_dm_reset(struct phy_dm_struct *dm);
+
+void phydm_support_ability_debug(void *dm_void, u32 *const dm_value, u32 *_used,
+				 char *output, u32 *_out_len);
+
+void phydm_config_ofdm_rx_path(struct phy_dm_struct *dm, u32 path);
+
+void phydm_config_trx_path(void *dm_void, u32 *const dm_value, u32 *_used,
+			   char *output, u32 *_out_len);
+
+void odm_dm_watchdog(struct phy_dm_struct *dm);
+
+void phydm_watchdog_mp(struct phy_dm_struct *dm);
+
+void odm_cmn_info_init(struct phy_dm_struct *dm, enum odm_cmninfo cmn_info,
+		       u32 value);
+
+void odm_cmn_info_hook(struct phy_dm_struct *dm, enum odm_cmninfo cmn_info,
+		       void *value);
+
+void odm_cmn_info_ptr_array_hook(struct phy_dm_struct *dm,
+				 enum odm_cmninfo cmn_info, u16 index,
+				 void *value);
+
+void odm_cmn_info_update(struct phy_dm_struct *dm, u32 cmn_info, u64 value);
+
+u32 phydm_cmn_info_query(struct phy_dm_struct *dm,
+			 enum phydm_info_query info_type);
+
+void odm_init_all_timers(struct phy_dm_struct *dm);
+
+void odm_cancel_all_timers(struct phy_dm_struct *dm);
+
+void odm_release_all_timers(struct phy_dm_struct *dm);
+
+void odm_asoc_entry_init(struct phy_dm_struct *dm);
+
+void *phydm_get_structure(struct phy_dm_struct *dm, u8 structure_type);
+
+/*===========================================================*/
+/* The following is for compile only*/
+/*===========================================================*/
+
+#define IS_HARDWARE_TYPE_8188E(_adapter) false
+#define IS_HARDWARE_TYPE_8188F(_adapter) false
+#define IS_HARDWARE_TYPE_8703B(_adapter) false
+#define IS_HARDWARE_TYPE_8723D(_adapter) false
+#define IS_HARDWARE_TYPE_8821C(_adapter) false
+#define IS_HARDWARE_TYPE_8812AU(_adapter) false
+#define IS_HARDWARE_TYPE_8814A(_adapter) false
+#define IS_HARDWARE_TYPE_8814AU(_adapter) false
+#define IS_HARDWARE_TYPE_8814AE(_adapter) false
+#define IS_HARDWARE_TYPE_8814AS(_adapter) false
+#define IS_HARDWARE_TYPE_8723BU(_adapter) false
+#define IS_HARDWARE_TYPE_8822BU(_adapter) false
+#define IS_HARDWARE_TYPE_8822BS(_adapter) false
+#define IS_HARDWARE_TYPE_JAGUAR(_adapter)                                      \
+	(IS_HARDWARE_TYPE_8812(_adapter) || IS_HARDWARE_TYPE_8821(_adapter))
+#define IS_HARDWARE_TYPE_8723AE(_adapter) false
+#define IS_HARDWARE_TYPE_8192C(_adapter) false
+#define IS_HARDWARE_TYPE_8192D(_adapter) false
+#define RF_T_METER_92D 0x42
+
+#define GET_RX_STATUS_DESC_RX_MCS(__prx_status_desc)                           \
+	LE_BITS_TO_1BYTE(__prx_status_desc + 12, 0, 6)
+
+#define REG_CONFIG_RAM64X16 0xb2c
+
+#define TARGET_CHNL_NUM_2G_5G 59
+
+/* *********************************************************** */
+
+void odm_dtc(struct phy_dm_struct *dm);
+
+void phydm_noisy_detection(struct phy_dm_struct *dm);
+
+void phydm_set_ext_switch(void *dm_void, u32 *const dm_value, u32 *_used,
+			  char *output, u32 *_out_len);
+
+void phydm_api_debug(void *dm_void, u32 function_map, u32 *const dm_value,
+		     u32 *_used, char *output, u32 *_out_len);
+
+u8 phydm_nbi_setting(void *dm_void, u32 enable, u32 channel, u32 bw,
+		     u32 f_interference, u32 second_ch);
+#endif /* __HALDMOUTSRC_H__ */
diff --git a/drivers/staging/rtlwifi/phydm/phydm_acs.c b/drivers/staging/rtlwifi/phydm/phydm_acs.c
new file mode 100644
index 000000000000..eae5a0a24b9b
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_acs.c
@@ -0,0 +1,200 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/* ************************************************************
+ * include files
+ * *************************************************************/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+u8 odm_get_auto_channel_select_result(void *dm_void, u8 band)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct acs_info *acs = &dm->dm_acs;
+	u8 result;
+
+	if (band == ODM_BAND_2_4G) {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_ACS,
+			"[struct acs_info] %s(): clean_channel_2g(%d)\n",
+			__func__, acs->clean_channel_2g);
+		result = (u8)acs->clean_channel_2g;
+	} else {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_ACS,
+			"[struct acs_info] %s(): clean_channel_5g(%d)\n",
+			__func__, acs->clean_channel_5g);
+		result = (u8)acs->clean_channel_5g;
+	}
+
+	return result;
+}
+
+static void odm_auto_channel_select_setting(void *dm_void, bool is_enable)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u16 period = 0x2710; /* 40ms in default */
+	u16 nhm_type = 0x7;
+
+	ODM_RT_TRACE(dm, ODM_COMP_ACS, "%s()=========>\n", __func__);
+
+	if (is_enable) {
+		/* 20 ms */
+		period = 0x1388;
+		nhm_type = 0x1;
+	}
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		/* PHY parameters initialize for ac series */
+
+		/* 0x990[31:16]=0x2710
+		 * Time duration for NHM unit: 4us, 0x2710=40ms
+		 */
+		odm_write_2byte(dm, ODM_REG_CCX_PERIOD_11AC + 2, period);
+	} else if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		/* PHY parameters initialize for n series */
+
+		/* 0x894[31:16]=0x2710
+		 * Time duration for NHM unit: 4us, 0x2710=40ms
+		 */
+		odm_write_2byte(dm, ODM_REG_CCX_PERIOD_11N + 2, period);
+	}
+}
+
+void odm_auto_channel_select_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct acs_info *acs = &dm->dm_acs;
+	u8 i;
+
+	if (!(dm->support_ability & ODM_BB_NHM_CNT))
+		return;
+
+	if (acs->is_force_acs_result)
+		return;
+
+	ODM_RT_TRACE(dm, ODM_COMP_ACS, "%s()=========>\n", __func__);
+
+	acs->clean_channel_2g = 1;
+	acs->clean_channel_5g = 36;
+
+	for (i = 0; i < ODM_MAX_CHANNEL_2G; ++i) {
+		acs->channel_info_2g[0][i] = 0;
+		acs->channel_info_2g[1][i] = 0;
+	}
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		for (i = 0; i < ODM_MAX_CHANNEL_5G; ++i) {
+			acs->channel_info_5g[0][i] = 0;
+			acs->channel_info_5g[1][i] = 0;
+		}
+	}
+}
+
+void odm_auto_channel_select_reset(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct acs_info *acs = &dm->dm_acs;
+
+	if (!(dm->support_ability & ODM_BB_NHM_CNT))
+		return;
+
+	if (acs->is_force_acs_result)
+		return;
+
+	ODM_RT_TRACE(dm, ODM_COMP_ACS, "%s()=========>\n", __func__);
+
+	odm_auto_channel_select_setting(dm, true); /* for 20ms measurement */
+	phydm_nhm_counter_statistics_reset(dm);
+}
+
+void odm_auto_channel_select(void *dm_void, u8 channel)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct acs_info *acs = &dm->dm_acs;
+	u8 channel_idx = 0, search_idx = 0;
+	u16 max_score = 0;
+
+	if (!(dm->support_ability & ODM_BB_NHM_CNT)) {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_DIG,
+			"%s(): Return: support_ability ODM_BB_NHM_CNT is disabled\n",
+			__func__);
+		return;
+	}
+
+	if (acs->is_force_acs_result) {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_DIG,
+			"%s(): Force 2G clean channel = %d, 5G clean channel = %d\n",
+			__func__, acs->clean_channel_2g, acs->clean_channel_5g);
+		return;
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_ACS, "%s(): channel = %d=========>\n",
+		     __func__, channel);
+
+	phydm_get_nhm_counter_statistics(dm);
+	odm_auto_channel_select_setting(dm, false);
+
+	if (channel >= 1 && channel <= 14) {
+		channel_idx = channel - 1;
+		acs->channel_info_2g[1][channel_idx]++;
+
+		if (acs->channel_info_2g[1][channel_idx] >= 2)
+			acs->channel_info_2g[0][channel_idx] =
+				(acs->channel_info_2g[0][channel_idx] >> 1) +
+				(acs->channel_info_2g[0][channel_idx] >> 2) +
+				(dm->nhm_cnt_0 >> 2);
+		else
+			acs->channel_info_2g[0][channel_idx] = dm->nhm_cnt_0;
+
+		ODM_RT_TRACE(dm, ODM_COMP_ACS, "%s(): nhm_cnt_0 = %d\n",
+			     __func__, dm->nhm_cnt_0);
+		ODM_RT_TRACE(
+			dm, ODM_COMP_ACS,
+			"%s(): Channel_Info[0][%d] = %d, Channel_Info[1][%d] = %d\n",
+			__func__, channel_idx,
+			acs->channel_info_2g[0][channel_idx], channel_idx,
+			acs->channel_info_2g[1][channel_idx]);
+
+		for (search_idx = 0; search_idx < ODM_MAX_CHANNEL_2G;
+		     search_idx++) {
+			if (acs->channel_info_2g[1][search_idx] != 0 &&
+			    acs->channel_info_2g[0][search_idx] >= max_score) {
+				max_score = acs->channel_info_2g[0][search_idx];
+				acs->clean_channel_2g = search_idx + 1;
+			}
+		}
+		ODM_RT_TRACE(
+			dm, ODM_COMP_ACS,
+			"(1)%s(): 2G: clean_channel_2g = %d, max_score = %d\n",
+			__func__, acs->clean_channel_2g, max_score);
+
+	} else if (channel >= 36) {
+		/* Need to do */
+		acs->clean_channel_5g = channel;
+	}
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_acs.h b/drivers/staging/rtlwifi/phydm/phydm_acs.h
new file mode 100644
index 000000000000..51d72b72bd6f
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_acs.h
@@ -0,0 +1,57 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDMACS_H__
+#define __PHYDMACS_H__
+
+#define ACS_VERSION "1.1" /*20150729 by YuChen*/
+#define CLM_VERSION "1.0"
+
+#define ODM_MAX_CHANNEL_2G 14
+#define ODM_MAX_CHANNEL_5G 24
+
+/* For phydm_auto_channel_select_setting_ap() */
+#define STORE_DEFAULT_NHM_SETTING 0
+#define RESTORE_DEFAULT_NHM_SETTING 1
+#define ACS_NHM_SETTING 2
+
+struct acs_info {
+	bool is_force_acs_result;
+	u8 clean_channel_2g;
+	u8 clean_channel_5g;
+	/* channel_info[1]: channel score, channel_info[2]:channel_scan_times */
+	u16 channel_info_2g[2][ODM_MAX_CHANNEL_2G];
+	u16 channel_info_5g[2][ODM_MAX_CHANNEL_5G];
+};
+
+void odm_auto_channel_select_init(void *dm_void);
+
+void odm_auto_channel_select_reset(void *dm_void);
+
+void odm_auto_channel_select(void *dm_void, u8 channel);
+
+u8 odm_get_auto_channel_select_result(void *dm_void, u8 band);
+
+#endif /* #ifndef	__PHYDMACS_H__ */
diff --git a/drivers/staging/rtlwifi/phydm/phydm_adaptivity.c b/drivers/staging/rtlwifi/phydm/phydm_adaptivity.c
new file mode 100644
index 000000000000..4f9e267409f6
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_adaptivity.c
@@ -0,0 +1,941 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/* ************************************************************
+ * include files
+ * *************************************************************/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+void phydm_check_adaptivity(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct adaptivity_statistics *adaptivity =
+		(struct adaptivity_statistics *)phydm_get_structure(
+			dm, PHYDM_ADAPTIVITY);
+
+	if (dm->support_ability & ODM_BB_ADAPTIVITY) {
+		if (adaptivity->dynamic_link_adaptivity ||
+		    adaptivity->acs_for_adaptivity) {
+			if (dm->is_linked && !adaptivity->is_check) {
+				phydm_nhm_counter_statistics(dm);
+				phydm_check_environment(dm);
+			} else if (!dm->is_linked) {
+				adaptivity->is_check = false;
+			}
+		} else {
+			dm->adaptivity_enable = true;
+
+			if (dm->support_ic_type & (ODM_IC_11AC_GAIN_IDX_EDCCA |
+						   ODM_IC_11N_GAIN_IDX_EDCCA))
+				dm->adaptivity_flag = false;
+			else
+				dm->adaptivity_flag = true;
+		}
+	} else {
+		dm->adaptivity_enable = false;
+		dm->adaptivity_flag = false;
+	}
+}
+
+void phydm_nhm_counter_statistics_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		/*PHY parameters initialize for n series*/
+
+		/*0x894[31:16]=0x0xC350
+		 *Time duration for NHM unit: us, 0xc350=200ms
+		 */
+		odm_write_2byte(dm, ODM_REG_CCX_PERIOD_11N + 2, 0xC350);
+		/*0x890[31:16]=0xffff		th_9, th_10*/
+		odm_write_2byte(dm, ODM_REG_NHM_TH9_TH10_11N + 2, 0xffff);
+		/*0x898=0xffffff52		th_3, th_2, th_1, th_0*/
+		odm_write_4byte(dm, ODM_REG_NHM_TH3_TO_TH0_11N, 0xffffff50);
+		/*0x89c=0xffffffff		th_7, th_6, th_5, th_4*/
+		odm_write_4byte(dm, ODM_REG_NHM_TH7_TO_TH4_11N, 0xffffffff);
+		/*0xe28[7:0]=0xff		th_8*/
+		odm_set_bb_reg(dm, ODM_REG_FPGA0_IQK_11N, MASKBYTE0, 0xff);
+		/*0x890[10:8]=1		ignoreCCA ignore PHYTXON enable CCX*/
+		odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11N,
+			       BIT(10) | BIT(9) | BIT(8), 0x1);
+		/*0xc0c[7]=1			max power among all RX ants*/
+		odm_set_bb_reg(dm, ODM_REG_OFDM_FA_RSTC_11N, BIT(7), 0x1);
+	} else if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		/*PHY parameters initialize for ac series*/
+
+		odm_write_2byte(dm, ODM_REG_CCX_PERIOD_11AC + 2, 0xC350);
+		/*0x994[31:16]=0xffff		th_9, th_10*/
+		odm_write_2byte(dm, ODM_REG_NHM_TH9_TH10_11AC + 2, 0xffff);
+		/*0x998=0xffffff52		th_3, th_2, th_1, th_0*/
+		odm_write_4byte(dm, ODM_REG_NHM_TH3_TO_TH0_11AC, 0xffffff50);
+		/*0x99c=0xffffffff		th_7, th_6, th_5, th_4*/
+		odm_write_4byte(dm, ODM_REG_NHM_TH7_TO_TH4_11AC, 0xffffffff);
+		/*0x9a0[7:0]=0xff		th_8*/
+		odm_set_bb_reg(dm, ODM_REG_NHM_TH8_11AC, MASKBYTE0, 0xff);
+		/*0x994[10:8]=1		ignoreCCA ignore PHYTXON enable CCX*/
+		odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11AC,
+			       BIT(8) | BIT(9) | BIT(10), 0x1);
+		/*0x9e8[7]=1			max power among all RX ants*/
+		odm_set_bb_reg(dm, ODM_REG_NHM_9E8_11AC, BIT(0), 0x1);
+	}
+}
+
+void phydm_nhm_counter_statistics(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (!(dm->support_ability & ODM_BB_NHM_CNT))
+		return;
+
+	/*Get NHM report*/
+	phydm_get_nhm_counter_statistics(dm);
+
+	/*Reset NHM counter*/
+	phydm_nhm_counter_statistics_reset(dm);
+}
+
+void phydm_get_nhm_counter_statistics(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 value32 = 0;
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES)
+		value32 = odm_get_bb_reg(dm, ODM_REG_NHM_CNT_11AC, MASKDWORD);
+	else if (dm->support_ic_type & ODM_IC_11N_SERIES)
+		value32 = odm_get_bb_reg(dm, ODM_REG_NHM_CNT_11N, MASKDWORD);
+
+	dm->nhm_cnt_0 = (u8)(value32 & MASKBYTE0);
+	dm->nhm_cnt_1 = (u8)((value32 & MASKBYTE1) >> 8);
+}
+
+void phydm_nhm_counter_statistics_reset(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11N, BIT(1), 0);
+		odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11N, BIT(1), 1);
+	} else if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11AC, BIT(1), 0);
+		odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11AC, BIT(1), 1);
+	}
+}
+
+void phydm_set_edcca_threshold(void *dm_void, s8 H2L, s8 L2H)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES)
+		odm_set_bb_reg(dm, REG_OFDM_0_ECCA_THRESHOLD,
+			       MASKBYTE2 | MASKBYTE0,
+			       (u32)((u8)L2H | (u8)H2L << 16));
+	else if (dm->support_ic_type & ODM_IC_11AC_SERIES)
+		odm_set_bb_reg(dm, REG_FPGA0_XB_LSSI_READ_BACK, MASKLWORD,
+			       (u16)((u8)L2H | (u8)H2L << 8));
+}
+
+static void phydm_set_lna(void *dm_void, enum phydm_set_lna type)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (dm->support_ic_type & (ODM_RTL8188E | ODM_RTL8192E)) {
+		if (type == phydm_disable_lna) {
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x30, 0xfffff,
+				       0x18000); /*select Rx mode*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x31, 0xfffff,
+				       0x0000f);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x32, 0xfffff,
+				       0x37f82); /*disable LNA*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);
+			if (dm->rf_type > ODM_1T1R) {
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0xef, 0x80000,
+					       0x1);
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0x30, 0xfffff,
+					       0x18000);
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0x31, 0xfffff,
+					       0x0000f);
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0x32, 0xfffff,
+					       0x37f82);
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0xef, 0x80000,
+					       0x0);
+			}
+		} else if (type == phydm_enable_lna) {
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x30, 0xfffff,
+				       0x18000); /*select Rx mode*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x31, 0xfffff,
+				       0x0000f);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x32, 0xfffff,
+				       0x77f82); /*back to normal*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);
+			if (dm->rf_type > ODM_1T1R) {
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0xef, 0x80000,
+					       0x1);
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0x30, 0xfffff,
+					       0x18000);
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0x31, 0xfffff,
+					       0x0000f);
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0x32, 0xfffff,
+					       0x77f82);
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0xef, 0x80000,
+					       0x0);
+			}
+		}
+	} else if (dm->support_ic_type & ODM_RTL8723B) {
+		if (type == phydm_disable_lna) {
+			/*S0*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x30, 0xfffff,
+				       0x18000); /*select Rx mode*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x31, 0xfffff,
+				       0x0001f);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x32, 0xfffff,
+				       0xe6137); /*disable LNA*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);
+			/*S1*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xed, 0x00020, 0x1);
+			odm_set_rf_reg(
+				dm, ODM_RF_PATH_A, 0x43, 0xfffff,
+				0x3008d); /*select Rx mode and disable LNA*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xed, 0x00020, 0x0);
+		} else if (type == phydm_enable_lna) {
+			/*S0*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x30, 0xfffff,
+				       0x18000); /*select Rx mode*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x31, 0xfffff,
+				       0x0001f);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x32, 0xfffff,
+				       0xe6177); /*disable LNA*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);
+			/*S1*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xed, 0x00020, 0x1);
+			odm_set_rf_reg(
+				dm, ODM_RF_PATH_A, 0x43, 0xfffff,
+				0x300bd); /*select Rx mode and disable LNA*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xed, 0x00020, 0x0);
+		}
+
+	} else if (dm->support_ic_type & ODM_RTL8812) {
+		if (type == phydm_disable_lna) {
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x30, 0xfffff,
+				       0x18000); /*select Rx mode*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x31, 0xfffff,
+				       0x3f7ff);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x32, 0xfffff,
+				       0xc22bf); /*disable LNA*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);
+			if (dm->rf_type > ODM_1T1R) {
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0xef, 0x80000,
+					       0x1);
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0x30, 0xfffff,
+					       0x18000); /*select Rx mode*/
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0x31, 0xfffff,
+					       0x3f7ff);
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0x32, 0xfffff,
+					       0xc22bf); /*disable LNA*/
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0xef, 0x80000,
+					       0x0);
+			}
+		} else if (type == phydm_enable_lna) {
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x30, 0xfffff,
+				       0x18000); /*select Rx mode*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x31, 0xfffff,
+				       0x3f7ff);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x32, 0xfffff,
+				       0xc26bf); /*disable LNA*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);
+			if (dm->rf_type > ODM_1T1R) {
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0xef, 0x80000,
+					       0x1);
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0x30, 0xfffff,
+					       0x18000); /*select Rx mode*/
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0x31, 0xfffff,
+					       0x3f7ff);
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0x32, 0xfffff,
+					       0xc26bf); /*disable LNA*/
+				odm_set_rf_reg(dm, ODM_RF_PATH_B, 0xef, 0x80000,
+					       0x0);
+			}
+		}
+	} else if (dm->support_ic_type & (ODM_RTL8821 | ODM_RTL8881A)) {
+		if (type == phydm_disable_lna) {
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x30, 0xfffff,
+				       0x18000); /*select Rx mode*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x31, 0xfffff,
+				       0x0002f);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x32, 0xfffff,
+				       0xfb09b); /*disable LNA*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);
+		} else if (type == phydm_enable_lna) {
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x1);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x30, 0xfffff,
+				       0x18000); /*select Rx mode*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x31, 0xfffff,
+				       0x0002f);
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x32, 0xfffff,
+				       0xfb0bb); /*disable LNA*/
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, 0x80000, 0x0);
+		}
+	}
+}
+
+void phydm_set_trx_mux(void *dm_void, enum phydm_trx_mux_type tx_mode,
+		       enum phydm_trx_mux_type rx_mode)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		/*set TXmod to standby mode to remove outside noise affect*/
+		odm_set_bb_reg(dm, ODM_REG_CCK_RPT_FORMAT_11N,
+			       BIT(3) | BIT(2) | BIT(1), tx_mode);
+		/*set RXmod to standby mode to remove outside noise affect*/
+		odm_set_bb_reg(dm, ODM_REG_CCK_RPT_FORMAT_11N,
+			       BIT(22) | BIT(21) | BIT(20), rx_mode);
+		if (dm->rf_type > ODM_1T1R) {
+			/*set TXmod to standby mode to rm outside noise affect*/
+			odm_set_bb_reg(dm, ODM_REG_CCK_RPT_FORMAT_11N_B,
+				       BIT(3) | BIT(2) | BIT(1), tx_mode);
+			/*set RXmod to standby mode to rm outside noise affect*/
+			odm_set_bb_reg(dm, ODM_REG_CCK_RPT_FORMAT_11N_B,
+				       BIT(22) | BIT(21) | BIT(20), rx_mode);
+		}
+	} else if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		/*set TXmod to standby mode to remove outside noise affect*/
+		odm_set_bb_reg(dm, ODM_REG_TRMUX_11AC,
+			       BIT(11) | BIT(10) | BIT(9) | BIT(8), tx_mode);
+		/*set RXmod to standby mode to remove outside noise affect*/
+		odm_set_bb_reg(dm, ODM_REG_TRMUX_11AC,
+			       BIT(7) | BIT(6) | BIT(5) | BIT(4), rx_mode);
+		if (dm->rf_type > ODM_1T1R) {
+			/*set TXmod to standby mode to rm outside noise affect*/
+			odm_set_bb_reg(dm, ODM_REG_TRMUX_11AC_B,
+				       BIT(11) | BIT(10) | BIT(9) | BIT(8),
+				       tx_mode);
+			/*set RXmod to standby mode to rm outside noise affect*/
+			odm_set_bb_reg(dm, ODM_REG_TRMUX_11AC_B,
+				       BIT(7) | BIT(6) | BIT(5) | BIT(4),
+				       rx_mode);
+		}
+	}
+}
+
+void phydm_mac_edcca_state(void *dm_void, enum phydm_mac_edcca_type state)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (state == phydm_ignore_edcca) {
+		/*ignore EDCCA	reg520[15]=1*/
+		odm_set_mac_reg(dm, REG_TX_PTCL_CTRL, BIT(15), 1);
+	} else { /*don't set MAC ignore EDCCA signal*/
+		/*don't ignore EDCCA	 reg520[15]=0*/
+		odm_set_mac_reg(dm, REG_TX_PTCL_CTRL, BIT(15), 0);
+	}
+	ODM_RT_TRACE(dm, PHYDM_COMP_ADAPTIVITY, "EDCCA enable state = %d\n",
+		     state);
+}
+
+bool phydm_cal_nhm_cnt(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u16 base = 0;
+
+	base = dm->nhm_cnt_0 + dm->nhm_cnt_1;
+
+	if (base != 0) {
+		dm->nhm_cnt_0 = ((dm->nhm_cnt_0) << 8) / base;
+		dm->nhm_cnt_1 = ((dm->nhm_cnt_1) << 8) / base;
+	}
+	if ((dm->nhm_cnt_0 - dm->nhm_cnt_1) >= 100)
+		return true; /*clean environment*/
+	else
+		return false; /*noisy environment*/
+}
+
+void phydm_check_environment(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct adaptivity_statistics *adaptivity =
+		(struct adaptivity_statistics *)phydm_get_structure(
+			dm, PHYDM_ADAPTIVITY);
+	bool is_clean_environment = false;
+
+	if (adaptivity->is_first_link) {
+		if (dm->support_ic_type &
+		    (ODM_IC_11AC_GAIN_IDX_EDCCA | ODM_IC_11N_GAIN_IDX_EDCCA))
+			dm->adaptivity_flag = false;
+		else
+			dm->adaptivity_flag = true;
+
+		adaptivity->is_first_link = false;
+		return;
+	}
+
+	if (adaptivity->nhm_wait < 3) { /*Start enter NHM after 4 nhm_wait*/
+		adaptivity->nhm_wait++;
+		phydm_nhm_counter_statistics(dm);
+		return;
+	}
+
+	phydm_nhm_counter_statistics(dm);
+	is_clean_environment = phydm_cal_nhm_cnt(dm);
+
+	if (is_clean_environment) {
+		dm->th_l2h_ini =
+			adaptivity->th_l2h_ini_backup; /*adaptivity mode*/
+		dm->th_edcca_hl_diff = adaptivity->th_edcca_hl_diff_backup;
+
+		dm->adaptivity_enable = true;
+
+		if (dm->support_ic_type &
+		    (ODM_IC_11AC_GAIN_IDX_EDCCA | ODM_IC_11N_GAIN_IDX_EDCCA))
+			dm->adaptivity_flag = false;
+		else
+			dm->adaptivity_flag = true;
+	} else {
+		if (!adaptivity->acs_for_adaptivity) {
+			dm->th_l2h_ini = dm->th_l2h_ini_mode2; /*mode2*/
+			dm->th_edcca_hl_diff = dm->th_edcca_hl_diff_mode2;
+
+			dm->adaptivity_flag = false;
+			dm->adaptivity_enable = false;
+		}
+	}
+
+	adaptivity->nhm_wait = 0;
+	adaptivity->is_first_link = true;
+	adaptivity->is_check = true;
+}
+
+void phydm_search_pwdb_lower_bound(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct adaptivity_statistics *adaptivity =
+		(struct adaptivity_statistics *)phydm_get_structure(
+			dm, PHYDM_ADAPTIVITY);
+	u32 value32 = 0, reg_value32 = 0;
+	u8 cnt, try_count = 0;
+	u8 tx_edcca1 = 0, tx_edcca0 = 0;
+	bool is_adjust = true;
+	s8 th_l2h_dmc, th_h2l_dmc, igi_target = 0x32;
+	s8 diff;
+	u8 IGI = adaptivity->igi_base + 30 + (u8)dm->th_l2h_ini -
+		 (u8)dm->th_edcca_hl_diff;
+
+	if (dm->support_ic_type & (ODM_RTL8723B | ODM_RTL8188E | ODM_RTL8192E |
+				   ODM_RTL8812 | ODM_RTL8821 | ODM_RTL8881A)) {
+		phydm_set_lna(dm, phydm_disable_lna);
+	} else {
+		phydm_set_trx_mux(dm, phydm_standby_mode, phydm_standby_mode);
+		odm_pause_dig(dm, PHYDM_PAUSE, PHYDM_PAUSE_LEVEL_0, 0x7e);
+	}
+
+	diff = igi_target - (s8)IGI;
+	th_l2h_dmc = dm->th_l2h_ini + diff;
+	if (th_l2h_dmc > 10)
+		th_l2h_dmc = 10;
+	th_h2l_dmc = th_l2h_dmc - dm->th_edcca_hl_diff;
+
+	phydm_set_edcca_threshold(dm, th_h2l_dmc, th_l2h_dmc);
+	ODM_delay_ms(30);
+
+	while (is_adjust) {
+		if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+			odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11N, MASKDWORD, 0x0);
+			reg_value32 =
+				odm_get_bb_reg(dm, ODM_REG_RPT_11N, MASKDWORD);
+		} else if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+			odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD,
+				       0x0);
+			reg_value32 =
+				odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		}
+		while (reg_value32 & BIT(3) && try_count < 3) {
+			ODM_delay_ms(3);
+			try_count = try_count + 1;
+			if (dm->support_ic_type & ODM_IC_11N_SERIES)
+				reg_value32 = odm_get_bb_reg(
+					dm, ODM_REG_RPT_11N, MASKDWORD);
+			else if (dm->support_ic_type & ODM_IC_11AC_SERIES)
+				reg_value32 = odm_get_bb_reg(
+					dm, ODM_REG_RPT_11AC, MASKDWORD);
+		}
+		try_count = 0;
+
+		for (cnt = 0; cnt < 20; cnt++) {
+			if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+				odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11N,
+					       MASKDWORD, 0x208);
+				value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11N,
+							 MASKDWORD);
+			} else if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+				odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC,
+					       MASKDWORD, 0x209);
+				value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC,
+							 MASKDWORD);
+			}
+			if (value32 & BIT(30) &&
+			    (dm->support_ic_type &
+			     (ODM_RTL8723B | ODM_RTL8188E)))
+				tx_edcca1 = tx_edcca1 + 1;
+			else if (value32 & BIT(29))
+				tx_edcca1 = tx_edcca1 + 1;
+			else
+				tx_edcca0 = tx_edcca0 + 1;
+		}
+
+		if (tx_edcca1 > 1) {
+			IGI = IGI - 1;
+			th_l2h_dmc = th_l2h_dmc + 1;
+			if (th_l2h_dmc > 10)
+				th_l2h_dmc = 10;
+			th_h2l_dmc = th_l2h_dmc - dm->th_edcca_hl_diff;
+
+			phydm_set_edcca_threshold(dm, th_h2l_dmc, th_l2h_dmc);
+			if (th_l2h_dmc == 10) {
+				is_adjust = false;
+				adaptivity->h2l_lb = th_h2l_dmc;
+				adaptivity->l2h_lb = th_l2h_dmc;
+				dm->adaptivity_igi_upper = IGI;
+			}
+
+			tx_edcca1 = 0;
+			tx_edcca0 = 0;
+
+		} else {
+			is_adjust = false;
+			adaptivity->h2l_lb = th_h2l_dmc;
+			adaptivity->l2h_lb = th_l2h_dmc;
+			dm->adaptivity_igi_upper = IGI;
+			tx_edcca1 = 0;
+			tx_edcca0 = 0;
+		}
+	}
+
+	dm->adaptivity_igi_upper = dm->adaptivity_igi_upper - dm->dc_backoff;
+	adaptivity->h2l_lb = adaptivity->h2l_lb + dm->dc_backoff;
+	adaptivity->l2h_lb = adaptivity->l2h_lb + dm->dc_backoff;
+
+	if (dm->support_ic_type & (ODM_RTL8723B | ODM_RTL8188E | ODM_RTL8192E |
+				   ODM_RTL8812 | ODM_RTL8821 | ODM_RTL8881A)) {
+		phydm_set_lna(dm, phydm_enable_lna);
+	} else {
+		phydm_set_trx_mux(dm, phydm_tx_mode, phydm_rx_mode);
+		odm_pause_dig(dm, PHYDM_RESUME, PHYDM_PAUSE_LEVEL_0, NONE);
+	}
+
+	phydm_set_edcca_threshold(dm, 0x7f, 0x7f); /*resume to no link state*/
+}
+
+static bool phydm_re_search_condition(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 adaptivity_igi_upper;
+	u8 count = 0;
+
+	adaptivity_igi_upper = dm->adaptivity_igi_upper + dm->dc_backoff;
+
+	if (adaptivity_igi_upper <= 0x26 && count < 3) {
+		count = count + 1;
+		return true;
+	}
+
+	return false;
+}
+
+void phydm_adaptivity_info_init(void *dm_void, enum phydm_adapinfo cmn_info,
+				u32 value)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct adaptivity_statistics *adaptivity =
+		(struct adaptivity_statistics *)phydm_get_structure(
+			dm, PHYDM_ADAPTIVITY);
+
+	switch (cmn_info) {
+	case PHYDM_ADAPINFO_CARRIER_SENSE_ENABLE:
+		dm->carrier_sense_enable = (bool)value;
+		break;
+
+	case PHYDM_ADAPINFO_DCBACKOFF:
+		dm->dc_backoff = (u8)value;
+		break;
+
+	case PHYDM_ADAPINFO_DYNAMICLINKADAPTIVITY:
+		adaptivity->dynamic_link_adaptivity = (bool)value;
+		break;
+
+	case PHYDM_ADAPINFO_TH_L2H_INI:
+		dm->th_l2h_ini = (s8)value;
+		break;
+
+	case PHYDM_ADAPINFO_TH_EDCCA_HL_DIFF:
+		dm->th_edcca_hl_diff = (s8)value;
+		break;
+
+	case PHYDM_ADAPINFO_AP_NUM_TH:
+		adaptivity->ap_num_th = (u8)value;
+		break;
+
+	default:
+		break;
+	}
+}
+
+void phydm_adaptivity_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct adaptivity_statistics *adaptivity =
+		(struct adaptivity_statistics *)phydm_get_structure(
+			dm, PHYDM_ADAPTIVITY);
+	s8 igi_target = 0x32;
+
+	if (!dm->carrier_sense_enable) {
+		if (dm->th_l2h_ini == 0)
+			dm->th_l2h_ini = 0xf5;
+	} else {
+		dm->th_l2h_ini = 0xa;
+	}
+
+	if (dm->th_edcca_hl_diff == 0)
+		dm->th_edcca_hl_diff = 7;
+	if (dm->wifi_test || dm->mp_mode) {
+		/*even no adaptivity, we still enable EDCCA, AP use mib ctrl*/
+		dm->edcca_enable = false;
+	} else {
+		dm->edcca_enable = true;
+	}
+
+	dm->adaptivity_igi_upper = 0;
+	dm->adaptivity_enable =
+		false; /*use this flag to decide enable or disable*/
+
+	dm->th_l2h_ini_mode2 = 20;
+	dm->th_edcca_hl_diff_mode2 = 8;
+	adaptivity->th_l2h_ini_backup = dm->th_l2h_ini;
+	adaptivity->th_edcca_hl_diff_backup = dm->th_edcca_hl_diff;
+
+	adaptivity->igi_base = 0x32;
+	adaptivity->igi_target = 0x1c;
+	adaptivity->h2l_lb = 0;
+	adaptivity->l2h_lb = 0;
+	adaptivity->nhm_wait = 0;
+	adaptivity->is_check = false;
+	adaptivity->is_first_link = true;
+	adaptivity->adajust_igi_level = 0;
+	adaptivity->is_stop_edcca = false;
+	adaptivity->backup_h2l = 0;
+	adaptivity->backup_l2h = 0;
+
+	phydm_mac_edcca_state(dm, phydm_dont_ignore_edcca);
+
+	/*Search pwdB lower bound*/
+	if (dm->support_ic_type & ODM_IC_11N_SERIES)
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11N, MASKDWORD, 0x208);
+	else if (dm->support_ic_type & ODM_IC_11AC_SERIES)
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0x209);
+
+	if (dm->support_ic_type & ODM_IC_11N_GAIN_IDX_EDCCA) {
+		if (dm->support_ic_type & ODM_RTL8197F) {
+			/*set to page B1*/
+			odm_set_bb_reg(dm, ODM_REG_PAGE_B1_97F, BIT(30), 0x1);
+			/*0:rx_dfir, 1: dcnf_out, 2 :rx_iq, 3: rx_nbi_nf_out*/
+			odm_set_bb_reg(dm, ODM_REG_EDCCA_DCNF_97F,
+				       BIT(27) | BIT(26), 0x1);
+			odm_set_bb_reg(dm, ODM_REG_PAGE_B1_97F, BIT(30), 0x0);
+		} else {
+			/*0:rx_dfir, 1: dcnf_out, 2 :rx_iq, 3: rx_nbi_nf_out*/
+			odm_set_bb_reg(dm, ODM_REG_EDCCA_DCNF_11N,
+				       BIT(21) | BIT(20), 0x1);
+		}
+	}
+	/*8814a no need to find pwdB lower bound, maybe*/
+	if (dm->support_ic_type & ODM_IC_11AC_GAIN_IDX_EDCCA) {
+		/*0:rx_dfir, 1: dcnf_out, 2 :rx_iq, 3: rx_nbi_nf_out*/
+		odm_set_bb_reg(dm, ODM_REG_ACBB_EDCCA_ENHANCE,
+			       BIT(29) | BIT(28), 0x1);
+	}
+
+	if (!(dm->support_ic_type &
+	      (ODM_IC_11AC_GAIN_IDX_EDCCA | ODM_IC_11N_GAIN_IDX_EDCCA))) {
+		phydm_search_pwdb_lower_bound(dm);
+		if (phydm_re_search_condition(dm))
+			phydm_search_pwdb_lower_bound(dm);
+	}
+
+	/*we need to consider PwdB upper bound for 8814 later IC*/
+	adaptivity->adajust_igi_level =
+		(u8)((dm->th_l2h_ini + igi_target) - pwdb_upper_bound +
+		     dfir_loss); /*IGI = L2H - PwdB - dfir_loss*/
+
+	ODM_RT_TRACE(
+		dm, PHYDM_COMP_ADAPTIVITY,
+		"th_l2h_ini = 0x%x, th_edcca_hl_diff = 0x%x, adaptivity->adajust_igi_level = 0x%x\n",
+		dm->th_l2h_ini, dm->th_edcca_hl_diff,
+		adaptivity->adajust_igi_level);
+
+	/*Check this later on Windows*/
+	/*phydm_set_edcca_threshold_api(dm, dig_tab->cur_ig_value);*/
+}
+
+void phydm_adaptivity(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+	u8 IGI = dig_tab->cur_ig_value;
+	s8 th_l2h_dmc, th_h2l_dmc;
+	s8 diff = 0, igi_target;
+	struct adaptivity_statistics *adaptivity =
+		(struct adaptivity_statistics *)phydm_get_structure(
+			dm, PHYDM_ADAPTIVITY);
+
+	if (!dm->edcca_enable || adaptivity->is_stop_edcca) {
+		ODM_RT_TRACE(dm, PHYDM_COMP_ADAPTIVITY, "Disable EDCCA!!!\n");
+		return;
+	}
+
+	if (!(dm->support_ability & ODM_BB_ADAPTIVITY)) {
+		ODM_RT_TRACE(dm, PHYDM_COMP_ADAPTIVITY,
+			     "adaptivity disable, enable EDCCA mode!!!\n");
+		dm->th_l2h_ini = dm->th_l2h_ini_mode2;
+		dm->th_edcca_hl_diff = dm->th_edcca_hl_diff_mode2;
+	}
+
+	ODM_RT_TRACE(dm, PHYDM_COMP_ADAPTIVITY, "%s() =====>\n", __func__);
+	ODM_RT_TRACE(dm, PHYDM_COMP_ADAPTIVITY,
+		     "igi_base=0x%x, th_l2h_ini = %d, th_edcca_hl_diff = %d\n",
+		     adaptivity->igi_base, dm->th_l2h_ini,
+		     dm->th_edcca_hl_diff);
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		/*fix AC series when enable EDCCA hang issue*/
+		odm_set_bb_reg(dm, 0x800, BIT(10), 1); /*ADC_mask disable*/
+		odm_set_bb_reg(dm, 0x800, BIT(10), 0); /*ADC_mask enable*/
+	}
+	if (*dm->band_width == ODM_BW20M) /*CHANNEL_WIDTH_20*/
+		igi_target = adaptivity->igi_base;
+	else if (*dm->band_width == ODM_BW40M)
+		igi_target = adaptivity->igi_base + 2;
+	else if (*dm->band_width == ODM_BW80M)
+		igi_target = adaptivity->igi_base + 2;
+	else
+		igi_target = adaptivity->igi_base;
+	adaptivity->igi_target = (u8)igi_target;
+
+	ODM_RT_TRACE(
+		dm, PHYDM_COMP_ADAPTIVITY,
+		"band_width=%s, igi_target=0x%x, dynamic_link_adaptivity = %d, acs_for_adaptivity = %d\n",
+		(*dm->band_width == ODM_BW80M) ?
+			"80M" :
+			((*dm->band_width == ODM_BW40M) ? "40M" : "20M"),
+		igi_target, adaptivity->dynamic_link_adaptivity,
+		adaptivity->acs_for_adaptivity);
+	ODM_RT_TRACE(
+		dm, PHYDM_COMP_ADAPTIVITY,
+		"rssi_min = %d, adaptivity->adajust_igi_level= 0x%x, adaptivity_flag = %d, adaptivity_enable = %d\n",
+		dm->rssi_min, adaptivity->adajust_igi_level,
+		dm->adaptivity_flag, dm->adaptivity_enable);
+
+	if (adaptivity->dynamic_link_adaptivity && (!dm->is_linked) &&
+	    !dm->adaptivity_enable) {
+		phydm_set_edcca_threshold(dm, 0x7f, 0x7f);
+		ODM_RT_TRACE(
+			dm, PHYDM_COMP_ADAPTIVITY,
+			"In DynamicLink mode(noisy) and No link, Turn off EDCCA!!\n");
+		return;
+	}
+
+	if (dm->support_ic_type &
+	    (ODM_IC_11AC_GAIN_IDX_EDCCA | ODM_IC_11N_GAIN_IDX_EDCCA)) {
+		if ((adaptivity->adajust_igi_level > IGI) &&
+		    dm->adaptivity_enable)
+			diff = adaptivity->adajust_igi_level - IGI;
+
+		th_l2h_dmc = dm->th_l2h_ini - diff + igi_target;
+		th_h2l_dmc = th_l2h_dmc - dm->th_edcca_hl_diff;
+	} else {
+		diff = igi_target - (s8)IGI;
+		th_l2h_dmc = dm->th_l2h_ini + diff;
+		if (th_l2h_dmc > 10 && dm->adaptivity_enable)
+			th_l2h_dmc = 10;
+
+		th_h2l_dmc = th_l2h_dmc - dm->th_edcca_hl_diff;
+
+		/*replace lower bound to prevent EDCCA always equal 1*/
+		if (th_h2l_dmc < adaptivity->h2l_lb)
+			th_h2l_dmc = adaptivity->h2l_lb;
+		if (th_l2h_dmc < adaptivity->l2h_lb)
+			th_l2h_dmc = adaptivity->l2h_lb;
+	}
+	ODM_RT_TRACE(dm, PHYDM_COMP_ADAPTIVITY,
+		     "IGI=0x%x, th_l2h_dmc = %d, th_h2l_dmc = %d\n", IGI,
+		     th_l2h_dmc, th_h2l_dmc);
+	ODM_RT_TRACE(
+		dm, PHYDM_COMP_ADAPTIVITY,
+		"adaptivity_igi_upper=0x%x, h2l_lb = 0x%x, l2h_lb = 0x%x\n",
+		dm->adaptivity_igi_upper, adaptivity->h2l_lb,
+		adaptivity->l2h_lb);
+
+	phydm_set_edcca_threshold(dm, th_h2l_dmc, th_l2h_dmc);
+
+	if (dm->adaptivity_enable)
+		odm_set_mac_reg(dm, REG_RD_CTRL, BIT(11), 1);
+}
+
+/*This is for solving USB can't Tx problem due to USB3.0 interference in 2.4G*/
+void phydm_pause_edcca(void *dm_void, bool is_pasue_edcca)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct adaptivity_statistics *adaptivity =
+		(struct adaptivity_statistics *)phydm_get_structure(
+			dm, PHYDM_ADAPTIVITY);
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+	u8 IGI = dig_tab->cur_ig_value;
+	s8 diff = 0;
+
+	if (is_pasue_edcca) {
+		adaptivity->is_stop_edcca = true;
+
+		if (dm->support_ic_type &
+		    (ODM_IC_11AC_GAIN_IDX_EDCCA | ODM_IC_11N_GAIN_IDX_EDCCA)) {
+			if (adaptivity->adajust_igi_level > IGI)
+				diff = adaptivity->adajust_igi_level - IGI;
+
+			adaptivity->backup_l2h =
+				dm->th_l2h_ini - diff + adaptivity->igi_target;
+			adaptivity->backup_h2l =
+				adaptivity->backup_l2h - dm->th_edcca_hl_diff;
+		} else {
+			diff = adaptivity->igi_target - (s8)IGI;
+			adaptivity->backup_l2h = dm->th_l2h_ini + diff;
+			if (adaptivity->backup_l2h > 10)
+				adaptivity->backup_l2h = 10;
+
+			adaptivity->backup_h2l =
+				adaptivity->backup_l2h - dm->th_edcca_hl_diff;
+
+			/*replace lower bound to prevent EDCCA always equal 1*/
+			if (adaptivity->backup_h2l < adaptivity->h2l_lb)
+				adaptivity->backup_h2l = adaptivity->h2l_lb;
+			if (adaptivity->backup_l2h < adaptivity->l2h_lb)
+				adaptivity->backup_l2h = adaptivity->l2h_lb;
+		}
+		ODM_RT_TRACE(
+			dm, PHYDM_COMP_ADAPTIVITY,
+			"pauseEDCCA : L2Hbak = 0x%x, H2Lbak = 0x%x, IGI = 0x%x\n",
+			adaptivity->backup_l2h, adaptivity->backup_h2l, IGI);
+
+		/*Disable EDCCA*/
+		phydm_pause_edcca_work_item_callback(dm);
+
+	} else {
+		adaptivity->is_stop_edcca = false;
+		ODM_RT_TRACE(
+			dm, PHYDM_COMP_ADAPTIVITY,
+			"resumeEDCCA : L2Hbak = 0x%x, H2Lbak = 0x%x, IGI = 0x%x\n",
+			adaptivity->backup_l2h, adaptivity->backup_h2l, IGI);
+		/*Resume EDCCA*/
+		phydm_resume_edcca_work_item_callback(dm);
+	}
+}
+
+void phydm_pause_edcca_work_item_callback(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES)
+		odm_set_bb_reg(dm, REG_OFDM_0_ECCA_THRESHOLD,
+			       MASKBYTE2 | MASKBYTE0, (u32)(0x7f | 0x7f << 16));
+	else if (dm->support_ic_type & ODM_IC_11AC_SERIES)
+		odm_set_bb_reg(dm, REG_FPGA0_XB_LSSI_READ_BACK, MASKLWORD,
+			       (u16)(0x7f | 0x7f << 8));
+}
+
+void phydm_resume_edcca_work_item_callback(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct adaptivity_statistics *adaptivity =
+		(struct adaptivity_statistics *)phydm_get_structure(
+			dm, PHYDM_ADAPTIVITY);
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES)
+		odm_set_bb_reg(dm, REG_OFDM_0_ECCA_THRESHOLD,
+			       MASKBYTE2 | MASKBYTE0,
+			       (u32)((u8)adaptivity->backup_l2h |
+				     (u8)adaptivity->backup_h2l << 16));
+	else if (dm->support_ic_type & ODM_IC_11AC_SERIES)
+		odm_set_bb_reg(dm, REG_FPGA0_XB_LSSI_READ_BACK, MASKLWORD,
+			       (u16)((u8)adaptivity->backup_l2h |
+				     (u8)adaptivity->backup_h2l << 8));
+}
+
+void phydm_set_edcca_threshold_api(void *dm_void, u8 IGI)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct adaptivity_statistics *adaptivity =
+		(struct adaptivity_statistics *)phydm_get_structure(
+			dm, PHYDM_ADAPTIVITY);
+	s8 th_l2h_dmc, th_h2l_dmc;
+	s8 diff = 0, igi_target = 0x32;
+
+	if (dm->support_ability & ODM_BB_ADAPTIVITY) {
+		if (dm->support_ic_type &
+		    (ODM_IC_11AC_GAIN_IDX_EDCCA | ODM_IC_11N_GAIN_IDX_EDCCA)) {
+			if (adaptivity->adajust_igi_level > IGI)
+				diff = adaptivity->adajust_igi_level - IGI;
+
+			th_l2h_dmc = dm->th_l2h_ini - diff + igi_target;
+			th_h2l_dmc = th_l2h_dmc - dm->th_edcca_hl_diff;
+		} else {
+			diff = igi_target - (s8)IGI;
+			th_l2h_dmc = dm->th_l2h_ini + diff;
+			if (th_l2h_dmc > 10)
+				th_l2h_dmc = 10;
+
+			th_h2l_dmc = th_l2h_dmc - dm->th_edcca_hl_diff;
+
+			/*replace lower bound to prevent EDCCA always equal 1*/
+			if (th_h2l_dmc < adaptivity->h2l_lb)
+				th_h2l_dmc = adaptivity->h2l_lb;
+			if (th_l2h_dmc < adaptivity->l2h_lb)
+				th_l2h_dmc = adaptivity->l2h_lb;
+		}
+		ODM_RT_TRACE(
+			dm, PHYDM_COMP_ADAPTIVITY,
+			"API :IGI=0x%x, th_l2h_dmc = %d, th_h2l_dmc = %d\n",
+			IGI, th_l2h_dmc, th_h2l_dmc);
+		ODM_RT_TRACE(
+			dm, PHYDM_COMP_ADAPTIVITY,
+			"API :adaptivity_igi_upper=0x%x, h2l_lb = 0x%x, l2h_lb = 0x%x\n",
+			dm->adaptivity_igi_upper, adaptivity->h2l_lb,
+			adaptivity->l2h_lb);
+
+		phydm_set_edcca_threshold(dm, th_h2l_dmc, th_l2h_dmc);
+	}
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_adaptivity.h b/drivers/staging/rtlwifi/phydm/phydm_adaptivity.h
new file mode 100644
index 000000000000..fdb39b4f9df2
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_adaptivity.h
@@ -0,0 +1,119 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDMADAPTIVITY_H__
+#define __PHYDMADAPTIVITY_H__
+
+/*20160902 changed by Kevin, refine method for searching pwdb lower bound*/
+#define ADAPTIVITY_VERSION "9.3.5"
+
+#define pwdb_upper_bound 7
+#define dfir_loss 5
+
+enum phydm_adapinfo {
+	PHYDM_ADAPINFO_CARRIER_SENSE_ENABLE = 0,
+	PHYDM_ADAPINFO_DCBACKOFF,
+	PHYDM_ADAPINFO_DYNAMICLINKADAPTIVITY,
+	PHYDM_ADAPINFO_TH_L2H_INI,
+	PHYDM_ADAPINFO_TH_EDCCA_HL_DIFF,
+	PHYDM_ADAPINFO_AP_NUM_TH
+
+};
+
+enum phydm_set_lna {
+	phydm_disable_lna = 0,
+	phydm_enable_lna = 1,
+};
+
+enum phydm_trx_mux_type {
+	phydm_shutdown = 0,
+	phydm_standby_mode = 1,
+	phydm_tx_mode = 2,
+	phydm_rx_mode = 3
+};
+
+enum phydm_mac_edcca_type {
+	phydm_ignore_edcca = 0,
+	phydm_dont_ignore_edcca = 1
+};
+
+struct adaptivity_statistics {
+	s8 th_l2h_ini_backup;
+	s8 th_edcca_hl_diff_backup;
+	s8 igi_base;
+	u8 igi_target;
+	u8 nhm_wait;
+	s8 h2l_lb;
+	s8 l2h_lb;
+	bool is_first_link;
+	bool is_check;
+	bool dynamic_link_adaptivity;
+	u8 ap_num_th;
+	u8 adajust_igi_level;
+	bool acs_for_adaptivity;
+	s8 backup_l2h;
+	s8 backup_h2l;
+	bool is_stop_edcca;
+};
+
+void phydm_pause_edcca(void *dm_void, bool is_pasue_edcca);
+
+void phydm_check_adaptivity(void *dm_void);
+
+void phydm_check_environment(void *dm_void);
+
+void phydm_nhm_counter_statistics_init(void *dm_void);
+
+void phydm_nhm_counter_statistics(void *dm_void);
+
+void phydm_nhm_counter_statistics_reset(void *dm_void);
+
+void phydm_get_nhm_counter_statistics(void *dm_void);
+
+void phydm_mac_edcca_state(void *dm_void, enum phydm_mac_edcca_type state);
+
+void phydm_set_edcca_threshold(void *dm_void, s8 H2L, s8 L2H);
+
+void phydm_set_trx_mux(void *dm_void, enum phydm_trx_mux_type tx_mode,
+		       enum phydm_trx_mux_type rx_mode);
+
+bool phydm_cal_nhm_cnt(void *dm_void);
+
+void phydm_search_pwdb_lower_bound(void *dm_void);
+
+void phydm_adaptivity_info_init(void *dm_void, enum phydm_adapinfo cmn_info,
+				u32 value);
+
+void phydm_adaptivity_init(void *dm_void);
+
+void phydm_adaptivity(void *dm_void);
+
+void phydm_set_edcca_threshold_api(void *dm_void, u8 IGI);
+
+void phydm_pause_edcca_work_item_callback(void *dm_void);
+
+void phydm_resume_edcca_work_item_callback(void *dm_void);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_adc_sampling.c b/drivers/staging/rtlwifi/phydm/phydm_adc_sampling.c
new file mode 100644
index 000000000000..158dd5d05de4
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_adc_sampling.c
@@ -0,0 +1,628 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+static bool phydm_la_buffer_allocate(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct rt_adcsmp *adc_smp = &dm->adcsmp;
+	struct rt_adcsmp_string *adc_smp_buf = &adc_smp->adc_smp_buf;
+	bool ret = false;
+
+	ODM_RT_TRACE(dm, ODM_COMP_UNCOND, "[LA mode BufferAllocate]\n");
+
+	if (adc_smp_buf->length == 0) {
+		odm_allocate_memory(dm, (void **)&adc_smp_buf->octet,
+				    adc_smp_buf->buffer_size);
+		if (!adc_smp_buf->octet) {
+			ret = false;
+		} else {
+			adc_smp_buf->length = adc_smp_buf->buffer_size;
+			ret = true;
+		}
+	}
+
+	return ret;
+}
+
+static void phydm_la_get_tx_pkt_buf(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct rt_adcsmp *adc_smp = &dm->adcsmp;
+	struct rt_adcsmp_string *adc_smp_buf = &adc_smp->adc_smp_buf;
+	u32 i = 0, value32, data_l = 0, data_h = 0;
+	u32 addr, finish_addr;
+	u32 end_addr = (adc_smp_buf->start_pos + adc_smp_buf->buffer_size) -
+		       1; /*end_addr = 0x3ffff;*/
+	bool is_round_up;
+	static u32 page = 0xFF;
+	u32 smp_cnt = 0, smp_number = 0, addr_8byte = 0;
+
+	odm_memory_set(dm, adc_smp_buf->octet, 0, adc_smp_buf->length);
+	odm_write_1byte(dm, 0x0106, 0x69);
+
+	ODM_RT_TRACE(dm, ODM_COMP_UNCOND, "GetTxPktBuf\n");
+
+	value32 = odm_read_4byte(dm, 0x7c0);
+	is_round_up = (bool)((value32 & BIT(31)) >> 31);
+	/*Reg7C0[30:16]: finish addr (unit: 8byte)*/
+	finish_addr = (value32 & 0x7FFF0000) >> 16;
+
+	if (is_round_up) {
+		addr = (finish_addr + 1) << 3;
+		ODM_RT_TRACE(
+			dm, ODM_COMP_UNCOND,
+			"is_round_up = ((%d)), finish_addr=((0x%x)), 0x7c0=((0x%x))\n",
+			is_round_up, finish_addr, value32);
+		/*Byte to 64Byte*/
+		smp_number = ((adc_smp_buf->buffer_size) >> 3);
+	} else {
+		addr = adc_smp_buf->start_pos;
+
+		addr_8byte = addr >> 3;
+		if (addr_8byte > finish_addr)
+			smp_number = addr_8byte - finish_addr;
+		else
+			smp_number = finish_addr - addr_8byte;
+
+		ODM_RT_TRACE(
+			dm, ODM_COMP_UNCOND,
+			"is_round_up = ((%d)), finish_addr=((0x%x * 8Byte)), Start_Addr = ((0x%x * 8Byte)), smp_number = ((%d))\n",
+			is_round_up, finish_addr, addr_8byte, smp_number);
+	}
+
+	if (dm->support_ic_type & ODM_RTL8197F) {
+		/*64K byte*/
+		for (addr = 0x0, i = 0; addr < end_addr; addr += 8, i += 2) {
+			if ((addr & 0xfff) == 0)
+				odm_set_bb_reg(dm, 0x0140, MASKLWORD,
+					       0x780 + (addr >> 12));
+			data_l = odm_get_bb_reg(dm, 0x8000 + (addr & 0xfff),
+						MASKDWORD);
+			data_h = odm_get_bb_reg(dm, 0x8000 + (addr & 0xfff) + 4,
+						MASKDWORD);
+
+			ODM_RT_TRACE(dm, ODM_COMP_UNCOND, "%08x%08x\n", data_h,
+				     data_l);
+		}
+	} else {
+		while (addr != (finish_addr << 3)) {
+			if (page != (addr >> 12)) {
+				/*Reg140=0x780+(addr>>12),
+				 *addr=0x30~0x3F, total 16 pages
+				 */
+				page = (addr >> 12);
+			}
+			odm_set_bb_reg(dm, 0x0140, MASKLWORD, 0x780 + page);
+
+			/*pDataL = 0x8000+(addr&0xfff);*/
+			data_l = odm_get_bb_reg(dm, 0x8000 + (addr & 0xfff),
+						MASKDWORD);
+			data_h = odm_get_bb_reg(dm, 0x8000 + (addr & 0xfff) + 4,
+						MASKDWORD);
+
+			adc_smp_buf->octet[i] = data_h;
+			adc_smp_buf->octet[i + 1] = data_l;
+
+			ODM_RT_TRACE(dm, ODM_COMP_UNCOND, "%08x%08x\n", data_h,
+				     data_l);
+
+			i = i + 2;
+
+			if ((addr + 8) >= end_addr)
+				addr = adc_smp_buf->start_pos;
+			else
+				addr = addr + 8;
+
+			smp_cnt++;
+			if (smp_cnt >= (smp_number - 1))
+				break;
+		}
+		ODM_RT_TRACE(dm, ODM_COMP_UNCOND, "smp_cnt = ((%d))\n",
+			     smp_cnt);
+	}
+}
+
+static void phydm_la_mode_set_mac_iq_dump(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct rt_adcsmp *adc_smp = &dm->adcsmp;
+	u32 reg_value;
+
+	odm_write_1byte(dm, 0x7c0, 0); /*clear all 0x7c0*/
+	odm_set_mac_reg(dm, 0x7c0, BIT(0), 1); /*Enable LA mode HW block*/
+
+	if (adc_smp->la_trig_mode == PHYDM_MAC_TRIG) {
+		adc_smp->is_bb_trigger = 0;
+		odm_set_mac_reg(dm, 0x7c0, BIT(2),
+				1); /*polling bit for MAC mode*/
+		odm_set_mac_reg(
+			dm, 0x7c0, BIT(4) | BIT(3),
+			adc_smp->la_trigger_edge); /*trigger mode for MAC*/
+
+		ODM_RT_TRACE(
+			dm, ODM_COMP_UNCOND,
+			"[MAC_trig] ref_mask = ((0x%x)), ref_value = ((0x%x)), dbg_port = ((0x%x))\n",
+			adc_smp->la_mac_ref_mask, adc_smp->la_trig_sig_sel,
+			adc_smp->la_dbg_port);
+		/*[Set MAC Debug Port]*/
+		odm_set_mac_reg(dm, 0xF4, BIT(16), 1);
+		odm_set_mac_reg(dm, 0x38, 0xff0000, adc_smp->la_dbg_port);
+		odm_set_mac_reg(dm, 0x7c4, MASKDWORD, adc_smp->la_mac_ref_mask);
+		odm_set_mac_reg(dm, 0x7c8, MASKDWORD, adc_smp->la_trig_sig_sel);
+
+	} else {
+		adc_smp->is_bb_trigger = 1;
+		odm_set_mac_reg(dm, 0x7c0, BIT(1),
+				1); /*polling bit for BB ADC mode*/
+
+		if (adc_smp->la_trig_mode == PHYDM_ADC_MAC_TRIG) {
+			odm_set_mac_reg(
+				dm, 0x7c0, BIT(3),
+				1); /*polling bit for MAC trigger event*/
+			odm_set_mac_reg(dm, 0x7c0, BIT(7) | BIT(6),
+					adc_smp->la_trig_sig_sel);
+
+			if (adc_smp->la_trig_sig_sel == ADCSMP_TRIG_REG)
+				odm_set_mac_reg(
+					dm, 0x7c0, BIT(5),
+					1); /* manual trigger 0x7C0[5] = 0->1*/
+		}
+	}
+
+	reg_value = odm_get_bb_reg(dm, 0x7c0, 0xff);
+	ODM_RT_TRACE(dm, ODM_COMP_UNCOND,
+		     "4. [Set MAC IQ dump] 0x7c0[7:0] = ((0x%x))\n", reg_value);
+}
+
+static void phydm_la_mode_set_dma_type(void *dm_void, u8 la_dma_type)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	ODM_RT_TRACE(dm, ODM_COMP_UNCOND,
+		     "2. [LA mode DMA setting] Dma_type = ((%d))\n",
+		     la_dma_type);
+
+	if (dm->support_ic_type & ODM_N_ANTDIV_SUPPORT)
+		odm_set_bb_reg(dm, 0x9a0, 0xf00, la_dma_type); /*0x9A0[11:8]*/
+	else
+		odm_set_bb_reg(dm, odm_adc_trigger_jaguar2, 0xf00,
+			       la_dma_type); /*0x95C[11:8]*/
+}
+
+static void phydm_adc_smp_start(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct rt_adcsmp *adc_smp = &dm->adcsmp;
+	u8 tmp_u1b;
+	u8 while_cnt = 0;
+	u8 polling_ok = false, target_polling_bit;
+
+	phydm_la_mode_bb_setting(dm);
+	phydm_la_mode_set_dma_type(dm, adc_smp->la_dma_type);
+	phydm_la_mode_set_trigger_time(dm, adc_smp->la_trigger_time);
+
+	if (dm->support_ic_type & ODM_RTL8197F) {
+		odm_set_bb_reg(dm, 0xd00, BIT(26), 0x1);
+	} else { /*for 8814A and 8822B?*/
+		odm_write_1byte(dm, 0x198c, 0x7);
+		odm_write_1byte(dm, 0x8b4, 0x80);
+		/* odm_set_bb_reg(dm, 0x8b4, BIT(7), 1); */
+	}
+
+	phydm_la_mode_set_mac_iq_dump(dm);
+	/* return; */
+
+	target_polling_bit = (adc_smp->is_bb_trigger) ? BIT(1) : BIT(2);
+	do { /*Poll time always use 100ms, when it exceed 2s, break while loop*/
+		tmp_u1b = odm_read_1byte(dm, 0x7c0);
+
+		if (adc_smp->adc_smp_state != ADCSMP_STATE_SET) {
+			ODM_RT_TRACE(
+				dm, ODM_COMP_UNCOND,
+				"[state Error] adc_smp_state != ADCSMP_STATE_SET\n");
+			break;
+
+		} else if (tmp_u1b & target_polling_bit) {
+			ODM_delay_ms(100);
+			while_cnt = while_cnt + 1;
+			continue;
+		} else {
+			ODM_RT_TRACE(dm, ODM_COMP_UNCOND,
+				     "[LA Query OK] polling_bit=((0x%x))\n",
+				     target_polling_bit);
+			polling_ok = true;
+			if (dm->support_ic_type & ODM_RTL8197F)
+				odm_set_bb_reg(dm, 0x7c0, BIT(0), 0x0);
+			break;
+		}
+	} while (while_cnt < 20);
+
+	if (adc_smp->adc_smp_state == ADCSMP_STATE_SET) {
+		if (polling_ok)
+			phydm_la_get_tx_pkt_buf(dm);
+		else
+			ODM_RT_TRACE(dm, ODM_COMP_UNCOND,
+				     "[Polling timeout]\n");
+	}
+
+	if (adc_smp->adc_smp_state == ADCSMP_STATE_SET)
+		adc_smp->adc_smp_state = ADCSMP_STATE_QUERY;
+
+	ODM_RT_TRACE(dm, ODM_COMP_UNCOND,
+		     "[LA mode] LA_pattern_count = ((%d))\n",
+		     adc_smp->la_count);
+
+	adc_smp_stop(dm);
+
+	if (adc_smp->la_count == 0) {
+		ODM_RT_TRACE(dm, ODM_COMP_UNCOND,
+			     "LA Dump finished ---------->\n\n\n");
+		/**/
+	} else {
+		adc_smp->la_count--;
+		ODM_RT_TRACE(dm, ODM_COMP_UNCOND,
+			     "LA Dump more ---------->\n\n\n");
+		adc_smp_set(dm, adc_smp->la_trig_mode, adc_smp->la_trig_sig_sel,
+			    adc_smp->la_dma_type, adc_smp->la_trigger_time, 0);
+	}
+}
+
+void adc_smp_set(void *dm_void, u8 trig_mode, u32 trig_sig_sel,
+		 u8 dma_data_sig_sel, u32 trigger_time, u16 polling_time)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	bool is_set_success = true;
+	struct rt_adcsmp *adc_smp = &dm->adcsmp;
+
+	adc_smp->la_trig_mode = trig_mode;
+	adc_smp->la_trig_sig_sel = trig_sig_sel;
+	adc_smp->la_dma_type = dma_data_sig_sel;
+	adc_smp->la_trigger_time = trigger_time;
+
+	if (adc_smp->adc_smp_state != ADCSMP_STATE_IDLE)
+		is_set_success = false;
+	else if (adc_smp->adc_smp_buf.length == 0)
+		is_set_success = phydm_la_buffer_allocate(dm);
+
+	if (is_set_success) {
+		adc_smp->adc_smp_state = ADCSMP_STATE_SET;
+
+		ODM_RT_TRACE(dm, ODM_COMP_UNCOND,
+			     "[LA Set Success] LA_State=((%d))\n",
+			     adc_smp->adc_smp_state);
+
+		phydm_adc_smp_start(dm);
+	} else {
+		ODM_RT_TRACE(dm, ODM_COMP_UNCOND,
+			     "[LA Set Fail] LA_State=((%d))\n",
+			     adc_smp->adc_smp_state);
+	}
+}
+
+void adc_smp_query(void *dm_void, void *output, u32 out_len, u32 *pused)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct rt_adcsmp *adc_smp = &dm->adcsmp;
+	struct rt_adcsmp_string *adc_smp_buf = &adc_smp->adc_smp_buf;
+	u32 used = *pused;
+	u32 i;
+
+	ODM_RT_TRACE(dm, ODM_COMP_UNCOND, "%s adc_smp_state %d", __func__,
+		     adc_smp->adc_smp_state);
+
+	for (i = 0; i < (adc_smp_buf->length >> 2) - 2; i += 2) {
+		PHYDM_SNPRINTF(output + used, out_len - used, "%08x%08x\n",
+			       adc_smp_buf->octet[i],
+			       adc_smp_buf->octet[i + 1]);
+	}
+
+	PHYDM_SNPRINTF(output + used, out_len - used, "\n");
+	*pused = used;
+}
+
+s32 adc_smp_get_sample_counts(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct rt_adcsmp *adc_smp = &dm->adcsmp;
+	struct rt_adcsmp_string *adc_smp_buf = &adc_smp->adc_smp_buf;
+
+	return (adc_smp_buf->length >> 2) - 2;
+}
+
+s32 adc_smp_query_single_data(void *dm_void, void *output, u32 out_len,
+			      u32 index)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct rt_adcsmp *adc_smp = &dm->adcsmp;
+	struct rt_adcsmp_string *adc_smp_buf = &adc_smp->adc_smp_buf;
+	u32 used = 0;
+
+	if (adc_smp->adc_smp_state != ADCSMP_STATE_QUERY) {
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "Error: la data is not ready yet ...\n");
+		return -1;
+	}
+
+	if (index < ((adc_smp_buf->length >> 2) - 2)) {
+		PHYDM_SNPRINTF(output + used, out_len - used, "%08x%08x\n",
+			       adc_smp_buf->octet[index],
+			       adc_smp_buf->octet[index + 1]);
+	}
+	return 0;
+}
+
+void adc_smp_stop(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct rt_adcsmp *adc_smp = &dm->adcsmp;
+
+	adc_smp->adc_smp_state = ADCSMP_STATE_IDLE;
+	ODM_RT_TRACE(dm, ODM_COMP_UNCOND, "[LA_Stop] LA_state = ((%d))\n",
+		     adc_smp->adc_smp_state);
+}
+
+void adc_smp_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct rt_adcsmp *adc_smp = &dm->adcsmp;
+	struct rt_adcsmp_string *adc_smp_buf = &adc_smp->adc_smp_buf;
+
+	adc_smp->adc_smp_state = ADCSMP_STATE_IDLE;
+
+	if (dm->support_ic_type & ODM_RTL8814A) {
+		adc_smp_buf->start_pos = 0x30000;
+		adc_smp_buf->buffer_size = 0x10000;
+	} else if (dm->support_ic_type & ODM_RTL8822B) {
+		adc_smp_buf->start_pos = 0x20000;
+		adc_smp_buf->buffer_size = 0x20000;
+	} else if (dm->support_ic_type & ODM_RTL8197F) {
+		adc_smp_buf->start_pos = 0x00000;
+		adc_smp_buf->buffer_size = 0x10000;
+	} else if (dm->support_ic_type & ODM_RTL8821C) {
+		adc_smp_buf->start_pos = 0x8000;
+		adc_smp_buf->buffer_size = 0x8000;
+	}
+}
+
+void adc_smp_de_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct rt_adcsmp *adc_smp = &dm->adcsmp;
+	struct rt_adcsmp_string *adc_smp_buf = &adc_smp->adc_smp_buf;
+
+	adc_smp_stop(dm);
+
+	if (adc_smp_buf->length != 0x0) {
+		odm_free_memory(dm, adc_smp_buf->octet, adc_smp_buf->length);
+		adc_smp_buf->length = 0x0;
+	}
+}
+
+void phydm_la_mode_bb_setting(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct rt_adcsmp *adc_smp = &dm->adcsmp;
+
+	u8 trig_mode = adc_smp->la_trig_mode;
+	u32 trig_sig_sel = adc_smp->la_trig_sig_sel;
+	u32 dbg_port = adc_smp->la_dbg_port;
+	u8 is_trigger_edge = adc_smp->la_trigger_edge;
+	u8 sampling_rate = adc_smp->la_smp_rate;
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_UNCOND,
+		"1. [LA mode bb_setting] trig_mode = ((%d)), dbg_port = ((0x%x)), Trig_Edge = ((%d)), smp_rate = ((%d)), Trig_Sel = ((0x%x))\n",
+		trig_mode, dbg_port, is_trigger_edge, sampling_rate,
+		trig_sig_sel);
+
+	if (trig_mode == PHYDM_MAC_TRIG)
+		trig_sig_sel = 0; /*ignore this setting*/
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		if (trig_mode == PHYDM_ADC_RF0_TRIG) {
+			/*DBGOUT_RFC_a[31:0]*/
+			odm_set_bb_reg(dm, 0x8f8,
+				       BIT(25) | BIT(24) | BIT(23) | BIT(22),
+				       9);
+		} else if (trig_mode == PHYDM_ADC_RF1_TRIG) {
+			/*DBGOUT_RFC_b[31:0]*/
+			odm_set_bb_reg(dm, 0x8f8,
+				       BIT(25) | BIT(24) | BIT(23) | BIT(22),
+				       8);
+		} else {
+			odm_set_bb_reg(dm, 0x8f8,
+				       BIT(25) | BIT(24) | BIT(23) | BIT(22),
+				       0);
+		}
+		/*
+		 *	(0:) '{ofdm_dbg[31:0]}'
+		 *	(1:) '{cca,crc32_fail,dbg_ofdm[29:0]}'
+		 *	(2:) '{vbon,crc32_fail,dbg_ofdm[29:0]}'
+		 *	(3:) '{cca,crc32_ok,dbg_ofdm[29:0]}'
+		 *	(4:) '{vbon,crc32_ok,dbg_ofdm[29:0]}'
+		 *	(5:) '{dbg_iqk_anta}'
+		 *	(6:) '{cca,ofdm_crc_ok,dbg_dp_anta[29:0]}'
+		 *	(7:) '{dbg_iqk_antb}'
+		 *	(8:) '{DBGOUT_RFC_b[31:0]}'
+		 *	(9:) '{DBGOUT_RFC_a[31:0]}'
+		 *	(a:) '{dbg_ofdm}'
+		 *	(b:) '{dbg_cck}'
+		 */
+
+		/*disable dbg clk gating*/
+		odm_set_bb_reg(dm, 0x198C, BIT(2) | BIT(1) | BIT(0), 7);
+
+		/*0x95C[4:0], BB debug port bit*/
+		odm_set_bb_reg(dm, 0x95C, 0x1f, trig_sig_sel);
+		odm_set_bb_reg(dm, 0x8FC, MASKDWORD, dbg_port);
+		/*0: posedge, 1: negedge*/
+		odm_set_bb_reg(dm, 0x95C, BIT(31), is_trigger_edge);
+		odm_set_bb_reg(dm, 0x95c, 0xe0, sampling_rate);
+		/*	(0:) '80MHz'
+		 *	(1:) '40MHz'
+		 *	(2:) '20MHz'
+		 *	(3:) '10MHz'
+		 *	(4:) '5MHz'
+		 *	(5:) '2.5MHz'
+		 *	(6:) '1.25MHz'
+		 *	(7:) '160MHz (for BW160 ic)'
+		 */
+	} else {
+		/*0x9A0[4:0], BB debug port bit*/
+		odm_set_bb_reg(dm, 0x9a0, 0x1f, trig_sig_sel);
+		odm_set_bb_reg(dm, 0x908, MASKDWORD, dbg_port);
+		/*0: posedge, 1: negedge*/
+		odm_set_bb_reg(dm, 0x9A0, BIT(31), is_trigger_edge);
+		odm_set_bb_reg(dm, 0x9A0, 0xe0, sampling_rate);
+		/*	(0:) '80MHz'
+		 *	(1:) '40MHz'
+		 *	(2:) '20MHz'
+		 *	(3:) '10MHz'
+		 *	(4:) '5MHz'
+		 *	(5:) '2.5MHz'
+		 *	(6:) '1.25MHz'
+		 *	(7:) '160MHz (for BW160 ic)'
+		 */
+	}
+}
+
+void phydm_la_mode_set_trigger_time(void *dm_void, u32 trigger_time_mu_sec)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 trigger_time_unit_num;
+	u32 time_unit = 0;
+
+	if (trigger_time_mu_sec < 128)
+		time_unit = 0; /*unit: 1mu sec*/
+	else if (trigger_time_mu_sec < 256)
+		time_unit = 1; /*unit: 2mu sec*/
+	else if (trigger_time_mu_sec < 512)
+		time_unit = 2; /*unit: 4mu sec*/
+	else if (trigger_time_mu_sec < 1024)
+		time_unit = 3; /*unit: 8mu sec*/
+	else if (trigger_time_mu_sec < 2048)
+		time_unit = 4; /*unit: 16mu sec*/
+	else if (trigger_time_mu_sec < 4096)
+		time_unit = 5; /*unit: 32mu sec*/
+	else if (trigger_time_mu_sec < 8192)
+		time_unit = 6; /*unit: 64mu sec*/
+
+	trigger_time_unit_num = (u8)(trigger_time_mu_sec >> time_unit);
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_UNCOND,
+		"3. [Set Trigger Time] Trig_Time = ((%d)) * unit = ((2^%d us))\n",
+		trigger_time_unit_num, time_unit);
+
+	odm_set_mac_reg(dm, 0x7cc, BIT(20) | BIT(19) | BIT(18), time_unit);
+	odm_set_mac_reg(dm, 0x7c0, 0x7f00, (trigger_time_unit_num & 0x7f));
+}
+
+void phydm_lamode_trigger_setting(void *dm_void, char input[][16], u32 *_used,
+				  char *output, u32 *_out_len, u32 input_num)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct rt_adcsmp *adc_smp = &dm->adcsmp;
+	u8 trig_mode, dma_data_sig_sel;
+	u32 trig_sig_sel;
+	bool is_enable_la_mode;
+	u32 trigger_time_mu_sec;
+	char help[] = "-h";
+	u32 var1[10] = {0};
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	if (dm->support_ic_type & PHYDM_IC_SUPPORT_LA_MODE) {
+		PHYDM_SSCANF(input[1], DCMD_DECIMAL, &var1[0]);
+		is_enable_la_mode = (bool)var1[0];
+		/*dbg_print("echo cmd input_num = %d\n", input_num);*/
+
+		if ((strcmp(input[1], help) == 0)) {
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"{En} {0:BB,1:BB_MAC,2:RF0,3:RF1,4:MAC}\n {BB:dbg_port[bit],BB_MAC:0-ok/1-fail/2-cca,MAC:ref} {DMA type} {TrigTime}\n {polling_time/ref_mask} {dbg_port} {0:P_Edge, 1:N_Edge} {SpRate:0-80M,1-40M,2-20M} {Capture num}\n");
+			/**/
+		} else if ((is_enable_la_mode == 1)) {
+			PHYDM_SSCANF(input[2], DCMD_DECIMAL, &var1[1]);
+
+			trig_mode = (u8)var1[1];
+
+			if (trig_mode == PHYDM_MAC_TRIG)
+				PHYDM_SSCANF(input[3], DCMD_HEX, &var1[2]);
+			else
+				PHYDM_SSCANF(input[3], DCMD_DECIMAL, &var1[2]);
+			trig_sig_sel = var1[2];
+
+			PHYDM_SSCANF(input[4], DCMD_DECIMAL, &var1[3]);
+			PHYDM_SSCANF(input[5], DCMD_DECIMAL, &var1[4]);
+			PHYDM_SSCANF(input[6], DCMD_HEX, &var1[5]);
+			PHYDM_SSCANF(input[7], DCMD_HEX, &var1[6]);
+			PHYDM_SSCANF(input[8], DCMD_DECIMAL, &var1[7]);
+			PHYDM_SSCANF(input[9], DCMD_DECIMAL, &var1[8]);
+			PHYDM_SSCANF(input[10], DCMD_DECIMAL, &var1[9]);
+
+			dma_data_sig_sel = (u8)var1[3];
+			trigger_time_mu_sec = var1[4]; /*unit: us*/
+
+			adc_smp->la_mac_ref_mask = var1[5];
+			adc_smp->la_dbg_port = var1[6];
+			adc_smp->la_trigger_edge = (u8)var1[7];
+			adc_smp->la_smp_rate = (u8)(var1[8] & 0x7);
+			adc_smp->la_count = var1[9];
+
+			ODM_RT_TRACE(
+				dm, ODM_COMP_UNCOND,
+				"echo lamode %d %d %d %d %d %d %x %d %d %d\n",
+				var1[0], var1[1], var1[2], var1[3], var1[4],
+				var1[5], var1[6], var1[7], var1[8], var1[9]);
+
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"a.En= ((1)),  b.mode = ((%d)), c.Trig_Sel = ((0x%x)), d.Dma_type = ((%d))\n",
+				trig_mode, trig_sig_sel, dma_data_sig_sel);
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"e.Trig_Time = ((%dus)), f.mac_ref_mask = ((0x%x)), g.dbg_port = ((0x%x))\n",
+				trigger_time_mu_sec, adc_smp->la_mac_ref_mask,
+				adc_smp->la_dbg_port);
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"h.Trig_edge = ((%d)), i.smp rate = ((%d MHz)), j.Cap_num = ((%d))\n",
+				adc_smp->la_trigger_edge,
+				(80 >> adc_smp->la_smp_rate),
+				adc_smp->la_count);
+
+			adc_smp_set(dm, trig_mode, trig_sig_sel,
+				    dma_data_sig_sel, trigger_time_mu_sec, 0);
+
+		} else {
+			adc_smp_stop(dm);
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "Disable LA mode\n");
+		}
+	}
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_adc_sampling.h b/drivers/staging/rtlwifi/phydm/phydm_adc_sampling.h
new file mode 100644
index 000000000000..460931489be3
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_adc_sampling.h
@@ -0,0 +1,96 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __INC_ADCSMP_H
+#define __INC_ADCSMP_H
+
+#define DYNAMIC_LA_MODE "1.0" /*2016.07.15  Dino */
+
+struct rt_adcsmp_string {
+	u32 *octet;
+	u32 length;
+	u32 buffer_size;
+	u32 start_pos;
+};
+
+enum rt_adcsmp_trig_sel {
+	PHYDM_ADC_BB_TRIG = 0,
+	PHYDM_ADC_MAC_TRIG = 1,
+	PHYDM_ADC_RF0_TRIG = 2,
+	PHYDM_ADC_RF1_TRIG = 3,
+	PHYDM_MAC_TRIG = 4
+};
+
+enum rt_adcsmp_trig_sig_sel {
+	ADCSMP_TRIG_CRCOK = 0,
+	ADCSMP_TRIG_CRCFAIL = 1,
+	ADCSMP_TRIG_CCA = 2,
+	ADCSMP_TRIG_REG = 3
+};
+
+enum rt_adcsmp_state {
+	ADCSMP_STATE_IDLE = 0,
+	ADCSMP_STATE_SET = 1,
+	ADCSMP_STATE_QUERY = 2
+};
+
+struct rt_adcsmp {
+	struct rt_adcsmp_string adc_smp_buf;
+	enum rt_adcsmp_state adc_smp_state;
+	u8 la_trig_mode;
+	u32 la_trig_sig_sel;
+	u8 la_dma_type;
+	u32 la_trigger_time;
+	u32 la_mac_ref_mask;
+	u32 la_dbg_port;
+	u8 la_trigger_edge;
+	u8 la_smp_rate;
+	u32 la_count;
+	u8 is_bb_trigger;
+	u8 la_work_item_index;
+};
+
+void adc_smp_set(void *dm_void, u8 trig_mode, u32 trig_sig_sel,
+		 u8 dma_data_sig_sel, u32 trigger_time, u16 polling_time);
+
+void adc_smp_query(void *dm_void, void *output, u32 out_len, u32 *pused);
+
+s32 adc_smp_get_sample_counts(void *dm_void);
+
+s32 adc_smp_query_single_data(void *dm_void, void *output, u32 out_len,
+			      u32 index);
+
+void adc_smp_stop(void *dm_void);
+
+void adc_smp_init(void *dm_void);
+
+void adc_smp_de_init(void *dm_void);
+
+void phydm_la_mode_bb_setting(void *dm_void);
+
+void phydm_la_mode_set_trigger_time(void *dm_void, u32 trigger_time_mu_sec);
+
+void phydm_lamode_trigger_setting(void *dm_void, char input[][16], u32 *_used,
+				  char *output, u32 *_out_len, u32 input_num);
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_antdiv.c b/drivers/staging/rtlwifi/phydm/phydm_antdiv.c
new file mode 100644
index 000000000000..39d3c6947556
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_antdiv.c
@@ -0,0 +1,83 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/* ************************************************************
+ * include files
+ * *************************************************************/
+
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+/* ******************************************************
+ * when antenna test utility is on or some testing need to disable antenna
+ * diversity, call this function to disable all ODM related mechanisms which
+ * will switch antenna.
+ * *******************************************************/
+void odm_stop_antenna_switch_dm(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	/* disable ODM antenna diversity */
+	dm->support_ability &= ~ODM_BB_ANT_DIV;
+	ODM_RT_TRACE(dm, ODM_COMP_ANT_DIV, "STOP Antenna Diversity\n");
+}
+
+void phydm_enable_antenna_diversity(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	dm->support_ability |= ODM_BB_ANT_DIV;
+	ODM_RT_TRACE(dm, ODM_COMP_ANT_DIV,
+		     "AntDiv is enabled & Re-Init AntDiv\n");
+	odm_antenna_diversity_init(dm);
+}
+
+void odm_set_ant_config(void *dm_void, u8 ant_setting /* 0=A, 1=B, 2=C, .... */
+			)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (dm->support_ic_type == ODM_RTL8723B) {
+		if (ant_setting == 0) /* ant A*/
+			odm_set_bb_reg(dm, 0x948, MASKDWORD, 0x00000000);
+		else if (ant_setting == 1)
+			odm_set_bb_reg(dm, 0x948, MASKDWORD, 0x00000280);
+	} else if (dm->support_ic_type == ODM_RTL8723D) {
+		if (ant_setting == 0) /* ant A*/
+			odm_set_bb_reg(dm, 0x948, MASKLWORD, 0x0000);
+		else if (ant_setting == 1)
+			odm_set_bb_reg(dm, 0x948, MASKLWORD, 0x0280);
+	}
+}
+
+/* ****************************************************** */
+
+void odm_sw_ant_div_rest_after_link(void *dm_void) {}
+
+void odm_ant_div_reset(void *dm_void) {}
+
+void odm_antenna_diversity_init(void *dm_void) {}
+
+void odm_antenna_diversity(void *dm_void) {}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_antdiv.h b/drivers/staging/rtlwifi/phydm/phydm_antdiv.h
new file mode 100644
index 000000000000..ebbff2f56c5e
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_antdiv.h
@@ -0,0 +1,301 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDMANTDIV_H__
+#define __PHYDMANTDIV_H__
+
+/* 2.0 2014.11.04
+ * 2.1 2015.01.13 Dino
+ * 2.2 2015.01.16 Dino
+ * 3.1 2015.07.29 YuChen, remove 92c 92d 8723a
+ * 3.2 2015.08.11 Stanley, disable antenna diversity when BT is enable for 8723B
+ * 3.3 2015.08.12 Stanley. 8723B does not need to check the antenna is control
+ *		  by BT, because antenna diversity only works when BT is disable
+ *		  or radio off
+ * 3.4 2015.08.28 Dino  1.Add 8821A Smart Antenna 2. Add 8188F SW S0S1 Antenna
+ *		  Diversity
+ * 3.5 2015.10.07 Stanley  Always check antenna detection result from BT-coex.
+ *		  for 8723B, not from PHYDM
+ * 3.6 2015.11.16 Stanley
+ * 3.7 2015.11.20 Dino Add SmartAnt FAT Patch
+ * 3.8 2015.12.21 Dino, Add SmartAnt dynamic training packet num
+ * 3.9 2016.01.05 Dino, Add SmartAnt cmd for converting single & two smtant, and
+ *		  add cmd for adjust truth table
+ */
+#define ANTDIV_VERSION "3.9"
+
+/* 1 ============================================================
+ * 1  Definition
+ * 1 ============================================================
+ */
+
+#define ANTDIV_INIT 0xff
+#define MAIN_ANT 1 /*ant A or ant Main   or S1*/
+#define AUX_ANT 2 /*AntB or ant Aux   or S0*/
+#define MAX_ANT 3 /* 3 for AP using*/
+
+#define ANT1_2G 0 /* = ANT2_5G	for 8723D  BTG S1 RX S0S1 diversity for 8723D,
+		   * TX fixed at S1
+		   */
+#define ANT2_2G 1 /* = ANT1_5G	for 8723D  BTG S0  RX S0S1 diversity for 8723D,
+		   * TX fixed at S1
+		   */
+/*smart antenna*/
+#define SUPPORT_RF_PATH_NUM 4
+#define SUPPORT_BEAM_PATTERN_NUM 4
+#define NUM_ANTENNA_8821A 2
+
+#define SUPPORT_BEAM_SET_PATTERN_NUM 8
+
+#define NO_FIX_TX_ANT 0
+#define FIX_TX_AT_MAIN 1
+#define FIX_AUX_AT_MAIN 2
+
+/* Antenna Diversty Control type */
+#define ODM_AUTO_ANT 0
+#define ODM_FIX_MAIN_ANT 1
+#define ODM_FIX_AUX_ANT 2
+
+#define ODM_N_ANTDIV_SUPPORT                                                   \
+	(ODM_RTL8188E | ODM_RTL8192E | ODM_RTL8723B | ODM_RTL8188F |           \
+	 ODM_RTL8723D | ODM_RTL8195A)
+#define ODM_AC_ANTDIV_SUPPORT                                                  \
+	(ODM_RTL8821 | ODM_RTL8881A | ODM_RTL8812 | ODM_RTL8821C |             \
+	 ODM_RTL8822B | ODM_RTL8814B)
+#define ODM_ANTDIV_SUPPORT (ODM_N_ANTDIV_SUPPORT | ODM_AC_ANTDIV_SUPPORT)
+#define ODM_SMART_ANT_SUPPORT (ODM_RTL8188E | ODM_RTL8192E)
+#define ODM_HL_SMART_ANT_TYPE1_SUPPORT (ODM_RTL8821 | ODM_RTL8822B)
+
+#define ODM_ANTDIV_2G_SUPPORT_IC                                               \
+	(ODM_RTL8188E | ODM_RTL8192E | ODM_RTL8723B | ODM_RTL8881A |           \
+	 ODM_RTL8188F | ODM_RTL8723D)
+#define ODM_ANTDIV_5G_SUPPORT_IC                                               \
+	(ODM_RTL8821 | ODM_RTL8881A | ODM_RTL8812 | ODM_RTL8821C)
+
+#define ODM_EVM_ENHANCE_ANTDIV_SUPPORT_IC (ODM_RTL8192E)
+
+#define ODM_ANTDIV_2G BIT(0)
+#define ODM_ANTDIV_5G BIT(1)
+
+#define ANTDIV_ON 1
+#define ANTDIV_OFF 0
+
+#define FAT_ON 1
+#define FAT_OFF 0
+
+#define TX_BY_DESC 1
+#define TX_BY_REG 0
+
+#define RSSI_METHOD 0
+#define EVM_METHOD 1
+#define CRC32_METHOD 2
+
+#define INIT_ANTDIV_TIMMER 0
+#define CANCEL_ANTDIV_TIMMER 1
+#define RELEASE_ANTDIV_TIMMER 2
+
+#define CRC32_FAIL 1
+#define CRC32_OK 0
+
+#define evm_rssi_th_high 25
+#define evm_rssi_th_low 20
+
+#define NORMAL_STATE_MIAN 1
+#define NORMAL_STATE_AUX 2
+#define TRAINING_STATE 3
+
+#define FORCE_RSSI_DIFF 10
+
+#define CSI_ON 1
+#define CSI_OFF 0
+
+#define DIVON_CSIOFF 1
+#define DIVOFF_CSION 2
+
+#define BDC_DIV_TRAIN_STATE 0
+#define bdc_bfer_train_state 1
+#define BDC_DECISION_STATE 2
+#define BDC_BF_HOLD_STATE 3
+#define BDC_DIV_HOLD_STATE 4
+
+#define BDC_MODE_1 1
+#define BDC_MODE_2 2
+#define BDC_MODE_3 3
+#define BDC_MODE_4 4
+#define BDC_MODE_NULL 0xff
+
+/*SW S0S1 antenna diversity*/
+#define SWAW_STEP_INIT 0xff
+#define SWAW_STEP_PEEK 0
+#define SWAW_STEP_DETERMINE 1
+
+#define RSSI_CHECK_RESET_PERIOD 10
+#define RSSI_CHECK_THRESHOLD 50
+
+/*Hong Lin Smart antenna*/
+#define HL_SMTANT_2WIRE_DATA_LEN 24
+
+/* 1 ============================================================
+ * 1  structure
+ * 1 ============================================================
+ */
+
+struct sw_antenna_switch {
+	u8 double_chk_flag; /*If current antenna RSSI > "RSSI_CHECK_THRESHOLD",
+			     *than check this antenna again
+			     */
+	u8 try_flag;
+	s32 pre_rssi;
+	u8 cur_antenna;
+	u8 pre_antenna;
+	u8 rssi_trying;
+	u8 reset_idx;
+	u8 train_time;
+	u8 train_time_flag; /*base on RSSI difference between two antennas*/
+	struct timer_list phydm_sw_antenna_switch_timer;
+	u32 pkt_cnt_sw_ant_div_by_ctrl_frame;
+	bool is_sw_ant_div_by_ctrl_frame;
+
+	/* AntDect (Before link Antenna Switch check) need to be moved*/
+	u16 single_ant_counter;
+	u16 dual_ant_counter;
+	u16 aux_fail_detec_counter;
+	u16 retry_counter;
+	u8 swas_no_link_state;
+	u32 swas_no_link_bk_reg948;
+	bool ANTA_ON; /*To indicate ant A is or not*/
+	bool ANTB_ON; /*To indicate ant B is on or not*/
+	bool pre_aux_fail_detec;
+	bool rssi_ant_dect_result;
+	u8 ant_5g;
+	u8 ant_2g;
+};
+
+struct fast_antenna_training {
+	u8 bssid[6];
+	u8 antsel_rx_keep_0;
+	u8 antsel_rx_keep_1;
+	u8 antsel_rx_keep_2;
+	u8 antsel_rx_keep_3;
+	u32 ant_sum_rssi[7];
+	u32 ant_rssi_cnt[7];
+	u32 ant_ave_rssi[7];
+	u8 fat_state;
+	u32 train_idx;
+	u8 antsel_a[ODM_ASSOCIATE_ENTRY_NUM];
+	u8 antsel_b[ODM_ASSOCIATE_ENTRY_NUM];
+	u8 antsel_c[ODM_ASSOCIATE_ENTRY_NUM];
+	u16 main_ant_sum[ODM_ASSOCIATE_ENTRY_NUM];
+	u16 aux_ant_sum[ODM_ASSOCIATE_ENTRY_NUM];
+	u16 main_ant_cnt[ODM_ASSOCIATE_ENTRY_NUM];
+	u16 aux_ant_cnt[ODM_ASSOCIATE_ENTRY_NUM];
+	u16 main_ant_sum_cck[ODM_ASSOCIATE_ENTRY_NUM];
+	u16 aux_ant_sum_cck[ODM_ASSOCIATE_ENTRY_NUM];
+	u16 main_ant_cnt_cck[ODM_ASSOCIATE_ENTRY_NUM];
+	u16 aux_ant_cnt_cck[ODM_ASSOCIATE_ENTRY_NUM];
+	u8 rx_idle_ant;
+	u8 ant_div_on_off;
+	bool is_become_linked;
+	u32 min_max_rssi;
+	u8 idx_ant_div_counter_2g;
+	u8 idx_ant_div_counter_5g;
+	u8 ant_div_2g_5g;
+
+	u32 cck_ctrl_frame_cnt_main;
+	u32 cck_ctrl_frame_cnt_aux;
+	u32 ofdm_ctrl_frame_cnt_main;
+	u32 ofdm_ctrl_frame_cnt_aux;
+	u32 main_ant_ctrl_frame_sum;
+	u32 aux_ant_ctrl_frame_sum;
+	u32 main_ant_ctrl_frame_cnt;
+	u32 aux_ant_ctrl_frame_cnt;
+	u8 b_fix_tx_ant;
+	bool fix_ant_bfee;
+	bool enable_ctrl_frame_antdiv;
+	bool use_ctrl_frame_antdiv;
+	u8 hw_antsw_occur;
+	u8 *p_force_tx_ant_by_desc;
+	u8 force_tx_ant_by_desc; /*A temp value, will hook to driver team's
+				  *outer parameter later
+				  */
+	u8 *p_default_s0_s1;
+	u8 default_s0_s1;
+};
+
+/* 1 ============================================================
+ * 1  enumeration
+ * 1 ============================================================
+ */
+
+/*Fast antenna training*/
+enum fat_state {
+	FAT_BEFORE_LINK_STATE = 0,
+	FAT_PREPARE_STATE = 1,
+	FAT_TRAINING_STATE = 2,
+	FAT_DECISION_STATE = 3
+};
+
+enum ant_div_type {
+	NO_ANTDIV = 0xFF,
+	CG_TRX_HW_ANTDIV = 0x01,
+	CGCS_RX_HW_ANTDIV = 0x02,
+	FIXED_HW_ANTDIV = 0x03,
+	CG_TRX_SMART_ANTDIV = 0x04,
+	CGCS_RX_SW_ANTDIV = 0x05,
+	/*8723B intrnal switch S0 S1*/
+	S0S1_SW_ANTDIV = 0x06,
+	/*TRX S0S1 diversity for 8723D*/
+	S0S1_TRX_HW_ANTDIV = 0x07,
+	/*Hong-Lin Smart antenna use for 8821AE which is a 2 ant. entitys, and
+	 *each ant. is equipped with 4 antenna patterns
+	 */
+	HL_SW_SMART_ANT_TYPE1 = 0x10,
+	/*Hong-Bo Smart antenna use for 8822B which is a 2 ant. entitys*/
+	HL_SW_SMART_ANT_TYPE2 = 0x11,
+};
+
+/* 1 ============================================================
+ * 1  function prototype
+ * 1 ============================================================
+ */
+
+void odm_stop_antenna_switch_dm(void *dm_void);
+
+void phydm_enable_antenna_diversity(void *dm_void);
+
+void odm_set_ant_config(void *dm_void, u8 ant_setting /* 0=A, 1=B, 2=C, .... */
+			);
+
+#define sw_ant_div_rest_after_link odm_sw_ant_div_rest_after_link
+
+void odm_sw_ant_div_rest_after_link(void *dm_void);
+
+void odm_ant_div_reset(void *dm_void);
+
+void odm_antenna_diversity_init(void *dm_void);
+
+void odm_antenna_diversity(void *dm_void);
+
+#endif /*#ifndef	__ODMANTDIV_H__*/
diff --git a/drivers/staging/rtlwifi/phydm/phydm_beamforming.h b/drivers/staging/rtlwifi/phydm/phydm_beamforming.h
new file mode 100644
index 000000000000..adc04ba4e218
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_beamforming.h
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __INC_PHYDM_BEAMFORMING_H
+#define __INC_PHYDM_BEAMFORMING_H
+
+/*Beamforming Related*/
+#include "txbf/halcomtxbf.h"
+#include "txbf/haltxbfjaguar.h"
+#include "txbf/haltxbf8822b.h"
+#include "txbf/haltxbfinterface.h"
+
+#define beamforming_gid_paid(adapter, tcb)
+#define phydm_acting_determine(dm, type) false
+#define beamforming_enter(dm, sta_idx)
+#define beamforming_leave(dm, RA)
+#define beamforming_end_fw(dm)
+#define beamforming_control_v1(dm, RA, AID, mode, BW, rate) true
+#define beamforming_control_v2(dm, idx, mode, BW, period) true
+#define phydm_beamforming_end_sw(dm, _status)
+#define beamforming_timer_callback(dm)
+#define phydm_beamforming_init(dm)
+#define phydm_beamforming_control_v2(dm, _idx, _mode, _BW, _period) false
+#define beamforming_watchdog(dm)
+#define phydm_beamforming_watchdog(dm)
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_ccx.c b/drivers/staging/rtlwifi/phydm/phydm_ccx.c
new file mode 100644
index 000000000000..2e0dc68757dc
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_ccx.c
@@ -0,0 +1,457 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+/*Set NHM period, threshold, disable ignore cca or not,
+ *disable ignore txon or not
+ */
+void phydm_nhm_setting(void *dm_void, u8 nhm_setting)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct ccx_info *ccx_info = &dm->dm_ccx_info;
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		if (nhm_setting == SET_NHM_SETTING) {
+			/*Set inexclude_cca, inexclude_txon*/
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11AC, BIT(9),
+				       ccx_info->nhm_inexclude_cca);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11AC, BIT(10),
+				       ccx_info->nhm_inexclude_txon);
+
+			/*Set NHM period*/
+			odm_set_bb_reg(dm, ODM_REG_CCX_PERIOD_11AC, MASKHWORD,
+				       ccx_info->NHM_period);
+
+			/*Set NHM threshold*/
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11AC,
+				       MASKBYTE0, ccx_info->NHM_th[0]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11AC,
+				       MASKBYTE1, ccx_info->NHM_th[1]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11AC,
+				       MASKBYTE2, ccx_info->NHM_th[2]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11AC,
+				       MASKBYTE3, ccx_info->NHM_th[3]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11AC,
+				       MASKBYTE0, ccx_info->NHM_th[4]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11AC,
+				       MASKBYTE1, ccx_info->NHM_th[5]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11AC,
+				       MASKBYTE2, ccx_info->NHM_th[6]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11AC,
+				       MASKBYTE3, ccx_info->NHM_th[7]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH8_11AC, MASKBYTE0,
+				       ccx_info->NHM_th[8]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11AC, MASKBYTE2,
+				       ccx_info->NHM_th[9]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11AC, MASKBYTE3,
+				       ccx_info->NHM_th[10]);
+
+			/*CCX EN*/
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11AC, BIT(8),
+				       CCX_EN);
+		} else if (nhm_setting == STORE_NHM_SETTING) {
+			/*Store prev. disable_ignore_cca, disable_ignore_txon*/
+			ccx_info->NHM_inexclude_cca_restore =
+				(enum nhm_inexclude_cca)odm_get_bb_reg(
+					dm, ODM_REG_NHM_TH9_TH10_11AC, BIT(9));
+			ccx_info->NHM_inexclude_txon_restore =
+				(enum nhm_inexclude_txon)odm_get_bb_reg(
+					dm, ODM_REG_NHM_TH9_TH10_11AC, BIT(10));
+
+			/*Store pervious NHM period*/
+			ccx_info->NHM_period_restore = (u16)odm_get_bb_reg(
+				dm, ODM_REG_CCX_PERIOD_11AC, MASKHWORD);
+
+			/*Store NHM threshold*/
+			ccx_info->NHM_th_restore[0] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH3_TO_TH0_11AC, MASKBYTE0);
+			ccx_info->NHM_th_restore[1] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH3_TO_TH0_11AC, MASKBYTE1);
+			ccx_info->NHM_th_restore[2] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH3_TO_TH0_11AC, MASKBYTE2);
+			ccx_info->NHM_th_restore[3] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH3_TO_TH0_11AC, MASKBYTE3);
+			ccx_info->NHM_th_restore[4] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH7_TO_TH4_11AC, MASKBYTE0);
+			ccx_info->NHM_th_restore[5] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH7_TO_TH4_11AC, MASKBYTE1);
+			ccx_info->NHM_th_restore[6] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH7_TO_TH4_11AC, MASKBYTE2);
+			ccx_info->NHM_th_restore[7] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH7_TO_TH4_11AC, MASKBYTE3);
+			ccx_info->NHM_th_restore[8] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH8_11AC, MASKBYTE0);
+			ccx_info->NHM_th_restore[9] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH9_TH10_11AC, MASKBYTE2);
+			ccx_info->NHM_th_restore[10] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH9_TH10_11AC, MASKBYTE3);
+		} else if (nhm_setting == RESTORE_NHM_SETTING) {
+			/*Set disable_ignore_cca, disable_ignore_txon*/
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11AC, BIT(9),
+				       ccx_info->NHM_inexclude_cca_restore);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11AC, BIT(10),
+				       ccx_info->NHM_inexclude_txon_restore);
+
+			/*Set NHM period*/
+			odm_set_bb_reg(dm, ODM_REG_CCX_PERIOD_11AC, MASKHWORD,
+				       ccx_info->NHM_period);
+
+			/*Set NHM threshold*/
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11AC,
+				       MASKBYTE0, ccx_info->NHM_th_restore[0]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11AC,
+				       MASKBYTE1, ccx_info->NHM_th_restore[1]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11AC,
+				       MASKBYTE2, ccx_info->NHM_th_restore[2]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11AC,
+				       MASKBYTE3, ccx_info->NHM_th_restore[3]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11AC,
+				       MASKBYTE0, ccx_info->NHM_th_restore[4]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11AC,
+				       MASKBYTE1, ccx_info->NHM_th_restore[5]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11AC,
+				       MASKBYTE2, ccx_info->NHM_th_restore[6]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11AC,
+				       MASKBYTE3, ccx_info->NHM_th_restore[7]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH8_11AC, MASKBYTE0,
+				       ccx_info->NHM_th_restore[8]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11AC, MASKBYTE2,
+				       ccx_info->NHM_th_restore[9]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11AC, MASKBYTE3,
+				       ccx_info->NHM_th_restore[10]);
+		} else {
+			return;
+		}
+	}
+
+	else if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		if (nhm_setting == SET_NHM_SETTING) {
+			/*Set disable_ignore_cca, disable_ignore_txon*/
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11N, BIT(9),
+				       ccx_info->nhm_inexclude_cca);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11N, BIT(10),
+				       ccx_info->nhm_inexclude_txon);
+
+			/*Set NHM period*/
+			odm_set_bb_reg(dm, ODM_REG_CCX_PERIOD_11N, MASKHWORD,
+				       ccx_info->NHM_period);
+
+			/*Set NHM threshold*/
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11N,
+				       MASKBYTE0, ccx_info->NHM_th[0]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11N,
+				       MASKBYTE1, ccx_info->NHM_th[1]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11N,
+				       MASKBYTE2, ccx_info->NHM_th[2]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11N,
+				       MASKBYTE3, ccx_info->NHM_th[3]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11N,
+				       MASKBYTE0, ccx_info->NHM_th[4]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11N,
+				       MASKBYTE1, ccx_info->NHM_th[5]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11N,
+				       MASKBYTE2, ccx_info->NHM_th[6]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11N,
+				       MASKBYTE3, ccx_info->NHM_th[7]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH8_11N, MASKBYTE0,
+				       ccx_info->NHM_th[8]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11N, MASKBYTE2,
+				       ccx_info->NHM_th[9]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11N, MASKBYTE3,
+				       ccx_info->NHM_th[10]);
+
+			/*CCX EN*/
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11N, BIT(8),
+				       CCX_EN);
+		} else if (nhm_setting == STORE_NHM_SETTING) {
+			/*Store prev. disable_ignore_cca, disable_ignore_txon*/
+			ccx_info->NHM_inexclude_cca_restore =
+				(enum nhm_inexclude_cca)odm_get_bb_reg(
+					dm, ODM_REG_NHM_TH9_TH10_11N, BIT(9));
+			ccx_info->NHM_inexclude_txon_restore =
+				(enum nhm_inexclude_txon)odm_get_bb_reg(
+					dm, ODM_REG_NHM_TH9_TH10_11N, BIT(10));
+
+			/*Store pervious NHM period*/
+			ccx_info->NHM_period_restore = (u16)odm_get_bb_reg(
+				dm, ODM_REG_CCX_PERIOD_11N, MASKHWORD);
+
+			/*Store NHM threshold*/
+			ccx_info->NHM_th_restore[0] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH3_TO_TH0_11N, MASKBYTE0);
+			ccx_info->NHM_th_restore[1] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH3_TO_TH0_11N, MASKBYTE1);
+			ccx_info->NHM_th_restore[2] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH3_TO_TH0_11N, MASKBYTE2);
+			ccx_info->NHM_th_restore[3] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH3_TO_TH0_11N, MASKBYTE3);
+			ccx_info->NHM_th_restore[4] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH7_TO_TH4_11N, MASKBYTE0);
+			ccx_info->NHM_th_restore[5] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH7_TO_TH4_11N, MASKBYTE1);
+			ccx_info->NHM_th_restore[6] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH7_TO_TH4_11N, MASKBYTE2);
+			ccx_info->NHM_th_restore[7] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH7_TO_TH4_11N, MASKBYTE3);
+			ccx_info->NHM_th_restore[8] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH8_11N, MASKBYTE0);
+			ccx_info->NHM_th_restore[9] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH9_TH10_11N, MASKBYTE2);
+			ccx_info->NHM_th_restore[10] = (u8)odm_get_bb_reg(
+				dm, ODM_REG_NHM_TH9_TH10_11N, MASKBYTE3);
+		} else if (nhm_setting == RESTORE_NHM_SETTING) {
+			/*Set disable_ignore_cca, disable_ignore_txon*/
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11N, BIT(9),
+				       ccx_info->NHM_inexclude_cca_restore);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11N, BIT(10),
+				       ccx_info->NHM_inexclude_txon_restore);
+
+			/*Set NHM period*/
+			odm_set_bb_reg(dm, ODM_REG_CCX_PERIOD_11N, MASKHWORD,
+				       ccx_info->NHM_period_restore);
+
+			/*Set NHM threshold*/
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11N,
+				       MASKBYTE0, ccx_info->NHM_th_restore[0]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11N,
+				       MASKBYTE1, ccx_info->NHM_th_restore[1]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11N,
+				       MASKBYTE2, ccx_info->NHM_th_restore[2]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH3_TO_TH0_11N,
+				       MASKBYTE3, ccx_info->NHM_th_restore[3]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11N,
+				       MASKBYTE0, ccx_info->NHM_th_restore[4]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11N,
+				       MASKBYTE1, ccx_info->NHM_th_restore[5]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11N,
+				       MASKBYTE2, ccx_info->NHM_th_restore[6]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH7_TO_TH4_11N,
+				       MASKBYTE3, ccx_info->NHM_th_restore[7]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH8_11N, MASKBYTE0,
+				       ccx_info->NHM_th_restore[8]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11N, MASKBYTE2,
+				       ccx_info->NHM_th_restore[9]);
+			odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11N, MASKBYTE3,
+				       ccx_info->NHM_th_restore[10]);
+		} else {
+			return;
+		}
+	}
+}
+
+void phydm_nhm_trigger(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		/*Trigger NHM*/
+		odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11AC, BIT(1), 0);
+		odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11AC, BIT(1), 1);
+	} else if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		/*Trigger NHM*/
+		odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11N, BIT(1), 0);
+		odm_set_bb_reg(dm, ODM_REG_NHM_TH9_TH10_11N, BIT(1), 1);
+	}
+}
+
+void phydm_get_nhm_result(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 value32;
+	struct ccx_info *ccx_info = &dm->dm_ccx_info;
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		value32 = odm_read_4byte(dm, ODM_REG_NHM_CNT_11AC);
+		ccx_info->NHM_result[0] = (u8)(value32 & MASKBYTE0);
+		ccx_info->NHM_result[1] = (u8)((value32 & MASKBYTE1) >> 8);
+		ccx_info->NHM_result[2] = (u8)((value32 & MASKBYTE2) >> 16);
+		ccx_info->NHM_result[3] = (u8)((value32 & MASKBYTE3) >> 24);
+
+		value32 = odm_read_4byte(dm, ODM_REG_NHM_CNT7_TO_CNT4_11AC);
+		ccx_info->NHM_result[4] = (u8)(value32 & MASKBYTE0);
+		ccx_info->NHM_result[5] = (u8)((value32 & MASKBYTE1) >> 8);
+		ccx_info->NHM_result[6] = (u8)((value32 & MASKBYTE2) >> 16);
+		ccx_info->NHM_result[7] = (u8)((value32 & MASKBYTE3) >> 24);
+
+		value32 = odm_read_4byte(dm, ODM_REG_NHM_CNT11_TO_CNT8_11AC);
+		ccx_info->NHM_result[8] = (u8)(value32 & MASKBYTE0);
+		ccx_info->NHM_result[9] = (u8)((value32 & MASKBYTE1) >> 8);
+		ccx_info->NHM_result[10] = (u8)((value32 & MASKBYTE2) >> 16);
+		ccx_info->NHM_result[11] = (u8)((value32 & MASKBYTE3) >> 24);
+
+		/*Get NHM duration*/
+		value32 = odm_read_4byte(dm, ODM_REG_NHM_DUR_READY_11AC);
+		ccx_info->NHM_duration = (u16)(value32 & MASKLWORD);
+	}
+
+	else if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		value32 = odm_read_4byte(dm, ODM_REG_NHM_CNT_11N);
+		ccx_info->NHM_result[0] = (u8)(value32 & MASKBYTE0);
+		ccx_info->NHM_result[1] = (u8)((value32 & MASKBYTE1) >> 8);
+		ccx_info->NHM_result[2] = (u8)((value32 & MASKBYTE2) >> 16);
+		ccx_info->NHM_result[3] = (u8)((value32 & MASKBYTE3) >> 24);
+
+		value32 = odm_read_4byte(dm, ODM_REG_NHM_CNT7_TO_CNT4_11N);
+		ccx_info->NHM_result[4] = (u8)(value32 & MASKBYTE0);
+		ccx_info->NHM_result[5] = (u8)((value32 & MASKBYTE1) >> 8);
+		ccx_info->NHM_result[6] = (u8)((value32 & MASKBYTE2) >> 16);
+		ccx_info->NHM_result[7] = (u8)((value32 & MASKBYTE3) >> 24);
+
+		value32 = odm_read_4byte(dm, ODM_REG_NHM_CNT9_TO_CNT8_11N);
+		ccx_info->NHM_result[8] = (u8)((value32 & MASKBYTE2) >> 16);
+		ccx_info->NHM_result[9] = (u8)((value32 & MASKBYTE3) >> 24);
+
+		value32 = odm_read_4byte(dm, ODM_REG_NHM_CNT10_TO_CNT11_11N);
+		ccx_info->NHM_result[10] = (u8)((value32 & MASKBYTE2) >> 16);
+		ccx_info->NHM_result[11] = (u8)((value32 & MASKBYTE3) >> 24);
+
+		/*Get NHM duration*/
+		value32 = odm_read_4byte(dm, ODM_REG_NHM_CNT10_TO_CNT11_11N);
+		ccx_info->NHM_duration = (u16)(value32 & MASKLWORD);
+	}
+}
+
+bool phydm_check_nhm_ready(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 value32 = 0;
+	u8 i;
+	bool ret = false;
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		value32 =
+			odm_get_bb_reg(dm, ODM_REG_CLM_RESULT_11AC, MASKDWORD);
+
+		for (i = 0; i < 200; i++) {
+			ODM_delay_ms(1);
+			if (odm_get_bb_reg(dm, ODM_REG_NHM_DUR_READY_11AC,
+					   BIT(17))) {
+				ret = 1;
+				break;
+			}
+		}
+	}
+
+	else if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		value32 = odm_get_bb_reg(dm, ODM_REG_CLM_READY_11N, MASKDWORD);
+
+		for (i = 0; i < 200; i++) {
+			ODM_delay_ms(1);
+			if (odm_get_bb_reg(dm, ODM_REG_NHM_DUR_READY_11AC,
+					   BIT(17))) {
+				ret = 1;
+				break;
+			}
+		}
+	}
+	return ret;
+}
+
+void phydm_clm_setting(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct ccx_info *ccx_info = &dm->dm_ccx_info;
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		odm_set_bb_reg(dm, ODM_REG_CCX_PERIOD_11AC, MASKLWORD,
+			       ccx_info->CLM_period); /*4us sample 1 time*/
+		odm_set_bb_reg(dm, ODM_REG_CLM_11AC, BIT(8),
+			       0x1); /*Enable CCX for CLM*/
+
+	} else if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		odm_set_bb_reg(dm, ODM_REG_CCX_PERIOD_11N, MASKLWORD,
+			       ccx_info->CLM_period); /*4us sample 1 time*/
+		odm_set_bb_reg(dm, ODM_REG_CLM_11N, BIT(8),
+			       0x1); /*Enable CCX for CLM*/
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_CCX, "[%s] : CLM period = %dus\n", __func__,
+		     ccx_info->CLM_period * 4);
+}
+
+void phydm_clm_trigger(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		odm_set_bb_reg(dm, ODM_REG_CLM_11AC, BIT(0),
+			       0x0); /*Trigger CLM*/
+		odm_set_bb_reg(dm, ODM_REG_CLM_11AC, BIT(0), 0x1);
+	} else if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		odm_set_bb_reg(dm, ODM_REG_CLM_11N, BIT(0),
+			       0x0); /*Trigger CLM*/
+		odm_set_bb_reg(dm, ODM_REG_CLM_11N, BIT(0), 0x1);
+	}
+}
+
+bool phydm_check_cl_mready(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 value32 = 0;
+	bool ret = false;
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES)
+		value32 = odm_get_bb_reg(
+			dm, ODM_REG_CLM_RESULT_11AC,
+			MASKDWORD); /*make sure CLM calc is ready*/
+	else if (dm->support_ic_type & ODM_IC_11N_SERIES)
+		value32 = odm_get_bb_reg(
+			dm, ODM_REG_CLM_READY_11N,
+			MASKDWORD); /*make sure CLM calc is ready*/
+
+	if ((dm->support_ic_type & ODM_IC_11AC_SERIES) && (value32 & BIT(16)))
+		ret = true;
+	else if ((dm->support_ic_type & ODM_IC_11N_SERIES) &&
+		 (value32 & BIT(16)))
+		ret = true;
+	else
+		ret = false;
+
+	ODM_RT_TRACE(dm, ODM_COMP_CCX, "[%s] : CLM ready = %d\n", __func__,
+		     ret);
+
+	return ret;
+}
+
+void phydm_get_cl_mresult(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct ccx_info *ccx_info = &dm->dm_ccx_info;
+
+	u32 value32 = 0;
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES)
+		value32 = odm_get_bb_reg(dm, ODM_REG_CLM_RESULT_11AC,
+					 MASKDWORD); /*read CLM calc result*/
+	else if (dm->support_ic_type & ODM_IC_11N_SERIES)
+		value32 = odm_get_bb_reg(dm, ODM_REG_CLM_RESULT_11N,
+					 MASKDWORD); /*read CLM calc result*/
+
+	ccx_info->CLM_result = (u16)(value32 & MASKLWORD);
+
+	ODM_RT_TRACE(dm, ODM_COMP_CCX, "[%s] : CLM result = %dus\n", __func__,
+		     ccx_info->CLM_result * 4);
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_ccx.h b/drivers/staging/rtlwifi/phydm/phydm_ccx.h
new file mode 100644
index 000000000000..a3517f4642f9
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_ccx.h
@@ -0,0 +1,83 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __PHYDMCCX_H__
+#define __PHYDMCCX_H__
+
+#define CCX_EN 1
+
+#define SET_NHM_SETTING 0
+#define STORE_NHM_SETTING 1
+#define RESTORE_NHM_SETTING 2
+
+enum nhm_inexclude_cca { NHM_EXCLUDE_CCA, NHM_INCLUDE_CCA };
+
+enum nhm_inexclude_txon { NHM_EXCLUDE_TXON, NHM_INCLUDE_TXON };
+
+struct ccx_info {
+	/*Settings*/
+	u8 NHM_th[11];
+	u16 NHM_period; /* 4us per unit */
+	u16 CLM_period; /* 4us per unit */
+	enum nhm_inexclude_txon nhm_inexclude_txon;
+	enum nhm_inexclude_cca nhm_inexclude_cca;
+
+	/*Previous Settings*/
+	u8 NHM_th_restore[11];
+	u16 NHM_period_restore; /* 4us per unit */
+	u16 CLM_period_restore; /* 4us per unit */
+	enum nhm_inexclude_txon NHM_inexclude_txon_restore;
+	enum nhm_inexclude_cca NHM_inexclude_cca_restore;
+
+	/*Report*/
+	u8 NHM_result[12];
+	u16 NHM_duration;
+	u16 CLM_result;
+
+	bool echo_NHM_en;
+	bool echo_CLM_en;
+	u8 echo_IGI;
+};
+
+/*NHM*/
+
+void phydm_nhm_setting(void *dm_void, u8 nhm_setting);
+
+void phydm_nhm_trigger(void *dm_void);
+
+void phydm_get_nhm_result(void *dm_void);
+
+bool phydm_check_nhm_ready(void *dm_void);
+
+/*CLM*/
+
+void phydm_clm_setting(void *dm_void);
+
+void phydm_clm_trigger(void *dm_void);
+
+bool phydm_check_cl_mready(void *dm_void);
+
+void phydm_get_cl_mresult(void *dm_void);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_cfotracking.c b/drivers/staging/rtlwifi/phydm/phydm_cfotracking.c
new file mode 100644
index 000000000000..2ec8444f31a7
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_cfotracking.c
@@ -0,0 +1,343 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+static void odm_set_crystal_cap(void *dm_void, u8 crystal_cap)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct cfo_tracking *cfo_track =
+		(struct cfo_tracking *)phydm_get_structure(dm, PHYDM_CFOTRACK);
+
+	if (cfo_track->crystal_cap == crystal_cap)
+		return;
+
+	cfo_track->crystal_cap = crystal_cap;
+
+	if (dm->support_ic_type & (ODM_RTL8188E | ODM_RTL8188F)) {
+		/* write 0x24[22:17] = 0x24[16:11] = crystal_cap */
+		crystal_cap = crystal_cap & 0x3F;
+		odm_set_bb_reg(dm, REG_AFE_XTAL_CTRL, 0x007ff800,
+			       (crystal_cap | (crystal_cap << 6)));
+	} else if (dm->support_ic_type & ODM_RTL8812) {
+		/* write 0x2C[30:25] = 0x2C[24:19] = crystal_cap */
+		crystal_cap = crystal_cap & 0x3F;
+		odm_set_bb_reg(dm, REG_MAC_PHY_CTRL, 0x7FF80000,
+			       (crystal_cap | (crystal_cap << 6)));
+	} else if ((dm->support_ic_type & (ODM_RTL8703B | ODM_RTL8723B |
+					   ODM_RTL8192E | ODM_RTL8821))) {
+		/* 0x2C[23:18] = 0x2C[17:12] = crystal_cap */
+		crystal_cap = crystal_cap & 0x3F;
+		odm_set_bb_reg(dm, REG_MAC_PHY_CTRL, 0x00FFF000,
+			       (crystal_cap | (crystal_cap << 6)));
+	} else if (dm->support_ic_type & ODM_RTL8814A) {
+		/* write 0x2C[26:21] = 0x2C[20:15] = crystal_cap */
+		crystal_cap = crystal_cap & 0x3F;
+		odm_set_bb_reg(dm, REG_MAC_PHY_CTRL, 0x07FF8000,
+			       (crystal_cap | (crystal_cap << 6)));
+	} else if (dm->support_ic_type & (ODM_RTL8822B | ODM_RTL8821C)) {
+		/* write 0x24[30:25] = 0x28[6:1] = crystal_cap */
+		crystal_cap = crystal_cap & 0x3F;
+		odm_set_bb_reg(dm, REG_AFE_XTAL_CTRL, 0x7e000000, crystal_cap);
+		odm_set_bb_reg(dm, REG_AFE_PLL_CTRL, 0x7e, crystal_cap);
+	} else {
+		ODM_RT_TRACE(dm, ODM_COMP_CFO_TRACKING,
+			     "%s(): Use default setting.\n", __func__);
+		odm_set_bb_reg(dm, REG_MAC_PHY_CTRL, 0xFFF000,
+			       (crystal_cap | (crystal_cap << 6)));
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_CFO_TRACKING, "%s(): crystal_cap = 0x%x\n",
+		     __func__, crystal_cap);
+
+	/* JJ modified 20161115 */
+}
+
+static u8 odm_get_default_crytaltal_cap(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 crystal_cap = 0x20;
+
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
+
+	crystal_cap = rtlefuse->crystalcap;
+
+	crystal_cap = crystal_cap & 0x3f;
+
+	return crystal_cap;
+}
+
+static void odm_set_atc_status(void *dm_void, bool atc_status)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct cfo_tracking *cfo_track =
+		(struct cfo_tracking *)phydm_get_structure(dm, PHYDM_CFOTRACK);
+
+	if (cfo_track->is_atc_status == atc_status)
+		return;
+
+	odm_set_bb_reg(dm, ODM_REG(BB_ATC, dm), ODM_BIT(BB_ATC, dm),
+		       atc_status);
+	cfo_track->is_atc_status = atc_status;
+}
+
+static bool odm_get_atc_status(void *dm_void)
+{
+	bool atc_status;
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	atc_status = (bool)odm_get_bb_reg(dm, ODM_REG(BB_ATC, dm),
+					  ODM_BIT(BB_ATC, dm));
+	return atc_status;
+}
+
+void odm_cfo_tracking_reset(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct cfo_tracking *cfo_track =
+		(struct cfo_tracking *)phydm_get_structure(dm, PHYDM_CFOTRACK);
+
+	cfo_track->def_x_cap = odm_get_default_crytaltal_cap(dm);
+	cfo_track->is_adjust = true;
+
+	if (cfo_track->crystal_cap > cfo_track->def_x_cap) {
+		odm_set_crystal_cap(dm, cfo_track->crystal_cap - 1);
+		ODM_RT_TRACE(dm, ODM_COMP_CFO_TRACKING,
+			     "%s(): approch default value (0x%x)\n", __func__,
+			     cfo_track->crystal_cap);
+	} else if (cfo_track->crystal_cap < cfo_track->def_x_cap) {
+		odm_set_crystal_cap(dm, cfo_track->crystal_cap + 1);
+		ODM_RT_TRACE(dm, ODM_COMP_CFO_TRACKING,
+			     "%s(): approch default value (0x%x)\n", __func__,
+			     cfo_track->crystal_cap);
+	}
+
+	odm_set_atc_status(dm, true);
+}
+
+void odm_cfo_tracking_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct cfo_tracking *cfo_track =
+		(struct cfo_tracking *)phydm_get_structure(dm, PHYDM_CFOTRACK);
+
+	cfo_track->crystal_cap = odm_get_default_crytaltal_cap(dm);
+	cfo_track->def_x_cap = cfo_track->crystal_cap;
+	cfo_track->is_atc_status = odm_get_atc_status(dm);
+	cfo_track->is_adjust = true;
+	ODM_RT_TRACE(dm, ODM_COMP_CFO_TRACKING, "%s()=========>\n", __func__);
+	ODM_RT_TRACE(dm, ODM_COMP_CFO_TRACKING,
+		     "%s(): is_atc_status = %d, crystal_cap = 0x%x\n", __func__,
+		     cfo_track->is_atc_status, cfo_track->def_x_cap);
+
+	/* Crystal cap. control by WiFi */
+	if (dm->support_ic_type & ODM_RTL8822B)
+		odm_set_bb_reg(dm, 0x10, 0x40, 0x1);
+}
+
+void odm_cfo_tracking(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct cfo_tracking *cfo_track =
+		(struct cfo_tracking *)phydm_get_structure(dm, PHYDM_CFOTRACK);
+	s32 cfo_ave = 0;
+	u32 cfo_rpt_sum, cfo_khz_avg[4] = {0};
+	s32 cfo_ave_diff;
+	s8 crystal_cap = cfo_track->crystal_cap;
+	u8 adjust_xtal = 1, i, valid_path_cnt = 0;
+
+	/* 4 Support ability */
+	if (!(dm->support_ability & ODM_BB_CFO_TRACKING)) {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_CFO_TRACKING,
+			"%s(): Return: support_ability ODM_BB_CFO_TRACKING is disabled\n",
+			__func__);
+		return;
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_CFO_TRACKING, "%s()=========>\n", __func__);
+
+	if (!dm->is_linked || !dm->is_one_entry_only) {
+		/* 4 No link or more than one entry */
+		odm_cfo_tracking_reset(dm);
+		ODM_RT_TRACE(
+			dm, ODM_COMP_CFO_TRACKING,
+			"%s(): Reset: is_linked = %d, is_one_entry_only = %d\n",
+			__func__, dm->is_linked, dm->is_one_entry_only);
+	} else {
+		/* 3 1. CFO Tracking */
+		/* 4 1.1 No new packet */
+		if (cfo_track->packet_count == cfo_track->packet_count_pre) {
+			ODM_RT_TRACE(dm, ODM_COMP_CFO_TRACKING,
+				     "%s(): packet counter doesn't change\n",
+				     __func__);
+			return;
+		}
+		cfo_track->packet_count_pre = cfo_track->packet_count;
+
+		/* 4 1.2 Calculate CFO */
+		for (i = 0; i < dm->num_rf_path; i++) {
+			if (cfo_track->CFO_cnt[i] == 0)
+				continue;
+
+			valid_path_cnt++;
+			cfo_rpt_sum =
+				(u32)((cfo_track->CFO_tail[i] < 0) ?
+					      (0 - cfo_track->CFO_tail[i]) :
+					      cfo_track->CFO_tail[i]);
+			cfo_khz_avg[i] = CFO_HW_RPT_2_MHZ(cfo_rpt_sum) /
+					 cfo_track->CFO_cnt[i];
+
+			ODM_RT_TRACE(
+				dm, ODM_COMP_CFO_TRACKING,
+				"[path %d] cfo_rpt_sum = (( %d )), CFO_cnt = (( %d )) , CFO_avg= (( %s%d )) kHz\n",
+				i, cfo_rpt_sum, cfo_track->CFO_cnt[i],
+				((cfo_track->CFO_tail[i] < 0) ? "-" : " "),
+				cfo_khz_avg[i]);
+		}
+
+		for (i = 0; i < valid_path_cnt; i++) {
+			if (cfo_track->CFO_tail[i] < 0) {
+				/* */
+				cfo_ave += (0 - (s32)cfo_khz_avg[i]);
+			} else {
+				cfo_ave += (s32)cfo_khz_avg[i];
+			}
+		}
+
+		if (valid_path_cnt >= 2)
+			cfo_ave = cfo_ave / valid_path_cnt;
+
+		ODM_RT_TRACE(dm, ODM_COMP_CFO_TRACKING,
+			     "valid_path_cnt = ((%d)), cfo_ave = ((%d kHz))\n",
+			     valid_path_cnt, cfo_ave);
+
+		/*reset counter*/
+		for (i = 0; i < dm->num_rf_path; i++) {
+			cfo_track->CFO_tail[i] = 0;
+			cfo_track->CFO_cnt[i] = 0;
+		}
+
+		/* 4 1.3 Avoid abnormal large CFO */
+		cfo_ave_diff = (cfo_track->CFO_ave_pre >= cfo_ave) ?
+				       (cfo_track->CFO_ave_pre - cfo_ave) :
+				       (cfo_ave - cfo_track->CFO_ave_pre);
+		if (cfo_ave_diff > 20 && cfo_track->large_cfo_hit == 0 &&
+		    !cfo_track->is_adjust) {
+			ODM_RT_TRACE(dm, ODM_COMP_CFO_TRACKING,
+				     "%s(): first large CFO hit\n", __func__);
+			cfo_track->large_cfo_hit = 1;
+			return;
+		}
+
+		cfo_track->large_cfo_hit = 0;
+		cfo_track->CFO_ave_pre = cfo_ave;
+
+		/* 4 1.4 Dynamic Xtal threshold */
+		if (!cfo_track->is_adjust) {
+			if (cfo_ave > CFO_TH_XTAL_HIGH ||
+			    cfo_ave < (-CFO_TH_XTAL_HIGH))
+				cfo_track->is_adjust = true;
+		} else {
+			if (cfo_ave < CFO_TH_XTAL_LOW &&
+			    cfo_ave > (-CFO_TH_XTAL_LOW))
+				cfo_track->is_adjust = false;
+		}
+
+		/* 4 1.5 BT case: Disable CFO tracking */
+		if (dm->is_bt_enabled) {
+			cfo_track->is_adjust = false;
+			odm_set_crystal_cap(dm, cfo_track->def_x_cap);
+			ODM_RT_TRACE(dm, ODM_COMP_CFO_TRACKING,
+				     "%s(): Disable CFO tracking for BT!!\n",
+				     __func__);
+		}
+
+		/* 4 1.7 Adjust Crystal Cap. */
+		if (cfo_track->is_adjust) {
+			if (cfo_ave > CFO_TH_XTAL_LOW)
+				crystal_cap = crystal_cap + adjust_xtal;
+			else if (cfo_ave < (-CFO_TH_XTAL_LOW))
+				crystal_cap = crystal_cap - adjust_xtal;
+
+			if (crystal_cap > 0x3f)
+				crystal_cap = 0x3f;
+			else if (crystal_cap < 0)
+				crystal_cap = 0;
+
+			odm_set_crystal_cap(dm, (u8)crystal_cap);
+		}
+		ODM_RT_TRACE(
+			dm, ODM_COMP_CFO_TRACKING,
+			"%s(): Crystal cap = 0x%x, Default Crystal cap = 0x%x\n",
+			__func__, cfo_track->crystal_cap, cfo_track->def_x_cap);
+
+		if (dm->support_ic_type & ODM_IC_11AC_SERIES)
+			return;
+
+		/* 3 2. Dynamic ATC switch */
+		if (cfo_ave < CFO_TH_ATC && cfo_ave > -CFO_TH_ATC) {
+			odm_set_atc_status(dm, false);
+			ODM_RT_TRACE(dm, ODM_COMP_CFO_TRACKING,
+				     "%s(): Disable ATC!!\n", __func__);
+		} else {
+			odm_set_atc_status(dm, true);
+			ODM_RT_TRACE(dm, ODM_COMP_CFO_TRACKING,
+				     "%s(): Enable ATC!!\n", __func__);
+		}
+	}
+}
+
+void odm_parsing_cfo(void *dm_void, void *pktinfo_void, s8 *pcfotail, u8 num_ss)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dm_per_pkt_info *pktinfo =
+		(struct dm_per_pkt_info *)pktinfo_void;
+	struct cfo_tracking *cfo_track =
+		(struct cfo_tracking *)phydm_get_structure(dm, PHYDM_CFOTRACK);
+	u8 i;
+
+	if (!(dm->support_ability & ODM_BB_CFO_TRACKING))
+		return;
+
+	if (pktinfo->is_packet_match_bssid) {
+		if (num_ss > dm->num_rf_path) /*For fool proof*/
+			num_ss = dm->num_rf_path;
+
+		/* 3 Update CFO report for path-A & path-B */
+		/* Only paht-A and path-B have CFO tail and short CFO */
+		for (i = 0; i < num_ss; i++) {
+			cfo_track->CFO_tail[i] += pcfotail[i];
+			cfo_track->CFO_cnt[i]++;
+		}
+
+		/* 3 Update packet counter */
+		if (cfo_track->packet_count == 0xffffffff)
+			cfo_track->packet_count = 0;
+		else
+			cfo_track->packet_count++;
+	}
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_cfotracking.h b/drivers/staging/rtlwifi/phydm/phydm_cfotracking.h
new file mode 100644
index 000000000000..e8436a31019d
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_cfotracking.h
@@ -0,0 +1,60 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDMCFOTRACK_H__
+#define __PHYDMCFOTRACK_H__
+
+#define CFO_TRACKING_VERSION "1.4" /*2015.10.01	Stanley, Modify for 8822B*/
+
+#define CFO_TH_XTAL_HIGH 20 /* kHz */
+#define CFO_TH_XTAL_LOW 10 /* kHz */
+#define CFO_TH_ATC 80 /* kHz */
+
+struct cfo_tracking {
+	bool is_atc_status;
+	bool large_cfo_hit;
+	bool is_adjust;
+	u8 crystal_cap;
+	u8 def_x_cap;
+	s32 CFO_tail[4];
+	u32 CFO_cnt[4];
+	s32 CFO_ave_pre;
+	u32 packet_count;
+	u32 packet_count_pre;
+
+	bool is_force_xtal_cap;
+	bool is_reset;
+};
+
+void odm_cfo_tracking_reset(void *dm_void);
+
+void odm_cfo_tracking_init(void *dm_void);
+
+void odm_cfo_tracking(void *dm_void);
+
+void odm_parsing_cfo(void *dm_void, void *pktinfo_void, s8 *pcfotail,
+		     u8 num_ss);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_debug.c b/drivers/staging/rtlwifi/phydm/phydm_debug.c
new file mode 100644
index 000000000000..a5f90afdae9b
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_debug.c
@@ -0,0 +1,2910 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/* ************************************************************
+ * include files
+ * *************************************************************/
+
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+bool phydm_api_set_txagc(struct phy_dm_struct *, u32, enum odm_rf_radio_path,
+			 u8, bool);
+static inline void phydm_check_dmval_txagc(struct phy_dm_struct *dm, u32 used,
+					   u32 out_len, u32 *const dm_value,
+					   char *output)
+{
+	if ((u8)dm_value[2] != 0xff) {
+		if (phydm_api_set_txagc(dm, dm_value[3],
+					(enum odm_rf_radio_path)dm_value[1],
+					(u8)dm_value[2], true))
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "  %s%d   %s%x%s%x\n", "Write path-",
+				       dm_value[1], "rate index-0x",
+				       dm_value[2], " = 0x", dm_value[3]);
+		else
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "  %s%d   %s%x%s\n", "Write path-",
+				       (dm_value[1] & 0x1), "rate index-0x",
+				       (dm_value[2] & 0x7f), " fail");
+	} else {
+		u8 i;
+		u32 power_index;
+		bool status = true;
+
+		power_index = (dm_value[3] & 0x3f);
+
+		if (dm->support_ic_type & (ODM_RTL8822B | ODM_RTL8821C)) {
+			power_index = (power_index << 24) |
+				      (power_index << 16) | (power_index << 8) |
+				      (power_index);
+			for (i = 0; i < ODM_RATEVHTSS2MCS9; i += 4)
+				status = (status &
+					  phydm_api_set_txagc(
+						  dm, power_index,
+						  (enum odm_rf_radio_path)
+							  dm_value[1],
+						  i, false));
+		} else if (dm->support_ic_type & ODM_RTL8197F) {
+			for (i = 0; i <= ODM_RATEMCS15; i++)
+				status = (status &
+					  phydm_api_set_txagc(
+						  dm, power_index,
+						  (enum odm_rf_radio_path)
+							  dm_value[1],
+						  i, false));
+		}
+
+		if (status)
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "  %s%d   %s%x\n",
+				       "Write all TXAGC of path-", dm_value[1],
+				       " = 0x", dm_value[3]);
+		else
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "  %s%d   %s\n",
+				       "Write all TXAGC of path-", dm_value[1],
+				       " fail");
+	}
+}
+
+static inline void phydm_print_nhm_trigger(char *output, u32 used, u32 out_len,
+					   struct ccx_info *ccx_info)
+{
+	int i;
+
+	for (i = 0; i <= 10; i++) {
+		if (i == 5)
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"\r\n NHM_th[%d] = 0x%x, echo_IGI = 0x%x", i,
+				ccx_info->NHM_th[i], ccx_info->echo_IGI);
+		else if (i == 10)
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r\n NHM_th[%d] = 0x%x\n", i,
+				       ccx_info->NHM_th[i]);
+		else
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r\n NHM_th[%d] = 0x%x", i,
+				       ccx_info->NHM_th[i]);
+	}
+}
+
+static inline void phydm_print_nhm_result(char *output, u32 used, u32 out_len,
+					  struct ccx_info *ccx_info)
+{
+	int i;
+
+	for (i = 0; i <= 11; i++) {
+		if (i == 5)
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"\r\n nhm_result[%d] = %d, echo_IGI = 0x%x", i,
+				ccx_info->NHM_result[i], ccx_info->echo_IGI);
+		else if (i == 11)
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r\n nhm_result[%d] = %d\n", i,
+				       ccx_info->NHM_result[i]);
+		else
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r\n nhm_result[%d] = %d", i,
+				       ccx_info->NHM_result[i]);
+	}
+}
+
+static inline void phydm_print_csi(struct phy_dm_struct *dm, u32 used,
+				   u32 out_len, char *output)
+{
+	int index, ptr;
+	u32 dword_h, dword_l;
+
+	for (index = 0; index < 80; index++) {
+		ptr = index + 256;
+
+		if (ptr > 311)
+			ptr -= 312;
+
+		odm_set_bb_reg(dm, 0x1910, 0x03FF0000, ptr); /*Select Address*/
+		dword_h = odm_get_bb_reg(dm, 0xF74, MASKDWORD);
+		dword_l = odm_get_bb_reg(dm, 0xF5C, MASKDWORD);
+
+		if (index % 2 == 0)
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"%02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\n",
+				dword_l & MASKBYTE0, (dword_l & MASKBYTE1) >> 8,
+				(dword_l & MASKBYTE2) >> 16,
+				(dword_l & MASKBYTE3) >> 24,
+				dword_h & MASKBYTE0, (dword_h & MASKBYTE1) >> 8,
+				(dword_h & MASKBYTE2) >> 16,
+				(dword_h & MASKBYTE3) >> 24);
+		else
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"%02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\n",
+				dword_l & MASKBYTE0, (dword_l & MASKBYTE1) >> 8,
+				(dword_l & MASKBYTE2) >> 16,
+				(dword_l & MASKBYTE3) >> 24,
+				dword_h & MASKBYTE0, (dword_h & MASKBYTE1) >> 8,
+				(dword_h & MASKBYTE2) >> 16,
+				(dword_h & MASKBYTE3) >> 24);
+	}
+}
+
+void phydm_init_debug_setting(struct phy_dm_struct *dm)
+{
+	dm->debug_level = ODM_DBG_TRACE;
+
+	dm->fw_debug_components = 0;
+	dm->debug_components =
+
+		0;
+
+	dm->fw_buff_is_enpty = true;
+	dm->pre_c2h_seq = 0;
+}
+
+u8 phydm_set_bb_dbg_port(void *dm_void, u8 curr_dbg_priority, u32 debug_port)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 dbg_port_result = false;
+
+	if (curr_dbg_priority > dm->pre_dbg_priority) {
+		if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+			odm_set_bb_reg(dm, 0x8fc, MASKDWORD, debug_port);
+			/**/
+		} else /*if (dm->support_ic_type & ODM_IC_11N_SERIES)*/ {
+			odm_set_bb_reg(dm, 0x908, MASKDWORD, debug_port);
+			/**/
+		}
+		ODM_RT_TRACE(
+			dm, ODM_COMP_API,
+			"DbgPort set success, Reg((0x%x)), Cur_priority=((%d)), Pre_priority=((%d))\n",
+			debug_port, curr_dbg_priority, dm->pre_dbg_priority);
+		dm->pre_dbg_priority = curr_dbg_priority;
+		dbg_port_result = true;
+	}
+
+	return dbg_port_result;
+}
+
+void phydm_release_bb_dbg_port(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	dm->pre_dbg_priority = BB_DBGPORT_RELEASE;
+	ODM_RT_TRACE(dm, ODM_COMP_API, "Release BB dbg_port\n");
+}
+
+u32 phydm_get_bb_dbg_port_value(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 dbg_port_value = 0;
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		dbg_port_value = odm_get_bb_reg(dm, 0xfa0, MASKDWORD);
+		/**/
+	} else /*if (dm->support_ic_type & ODM_IC_11N_SERIES)*/ {
+		dbg_port_value = odm_get_bb_reg(dm, 0xdf4, MASKDWORD);
+		/**/
+	}
+	ODM_RT_TRACE(dm, ODM_COMP_API, "dbg_port_value = 0x%x\n",
+		     dbg_port_value);
+	return dbg_port_value;
+}
+
+static void phydm_bb_rx_hang_info(void *dm_void, u32 *_used, char *output,
+				  u32 *_out_len)
+{
+	u32 value32 = 0;
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES)
+		return;
+
+	value32 = odm_get_bb_reg(dm, 0xF80, MASKDWORD);
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = 0x%x",
+		       "rptreg of sc/bw/ht/...", value32);
+
+	if (dm->support_ic_type & ODM_RTL8822B)
+		odm_set_bb_reg(dm, 0x198c, BIT(2) | BIT(1) | BIT(0), 7);
+
+	/* dbg_port = basic state machine */
+	{
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0x000);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "basic state machine",
+			       value32);
+	}
+
+	/* dbg_port = state machine */
+	{
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0x007);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "state machine", value32);
+	}
+
+	/* dbg_port = CCA-related*/
+	{
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0x204);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "CCA-related", value32);
+	}
+
+	/* dbg_port = edcca/rxd*/
+	{
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0x278);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "edcca/rxd", value32);
+	}
+
+	/* dbg_port = rx_state/mux_state/ADC_MASK_OFDM*/
+	{
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0x290);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x",
+			       "rx_state/mux_state/ADC_MASK_OFDM", value32);
+	}
+
+	/* dbg_port = bf-related*/
+	{
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0x2B2);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "bf-related", value32);
+	}
+
+	/* dbg_port = bf-related*/
+	{
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0x2B8);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "bf-related", value32);
+	}
+
+	/* dbg_port = txon/rxd*/
+	{
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0xA03);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "txon/rxd", value32);
+	}
+
+	/* dbg_port = l_rate/l_length*/
+	{
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0xA0B);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "l_rate/l_length", value32);
+	}
+
+	/* dbg_port = rxd/rxd_hit*/
+	{
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0xA0D);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "rxd/rxd_hit", value32);
+	}
+
+	/* dbg_port = dis_cca*/
+	{
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0xAA0);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "dis_cca", value32);
+	}
+
+	/* dbg_port = tx*/
+	{
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0xAB0);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "tx", value32);
+	}
+
+	/* dbg_port = rx plcp*/
+	{
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0xAD0);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "rx plcp", value32);
+
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0xAD1);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "rx plcp", value32);
+
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0xAD2);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "rx plcp", value32);
+
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD, 0xAD3);
+		value32 = odm_get_bb_reg(dm, ODM_REG_DBG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "0x8fc", value32);
+
+		value32 = odm_get_bb_reg(dm, ODM_REG_RPT_11AC, MASKDWORD);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = 0x%x", "rx plcp", value32);
+	}
+}
+
+static void phydm_bb_debug_info_n_series(void *dm_void, u32 *_used,
+					 char *output, u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	u32 value32 = 0, value32_1 = 0;
+	u8 rf_gain_a = 0, rf_gain_b = 0, rf_gain_c = 0, rf_gain_d = 0;
+	u8 rx_snr_a = 0, rx_snr_b = 0, rx_snr_c = 0, rx_snr_d = 0;
+
+	s8 rxevm_0 = 0, rxevm_1 = 0;
+	s32 short_cfo_a = 0, short_cfo_b = 0, long_cfo_a = 0, long_cfo_b = 0;
+	s32 scfo_a = 0, scfo_b = 0, avg_cfo_a = 0, avg_cfo_b = 0;
+	s32 cfo_end_a = 0, cfo_end_b = 0, acq_cfo_a = 0, acq_cfo_b = 0;
+
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s\n",
+		       "BB Report Info");
+
+	/*AGC result*/
+	value32 = odm_get_bb_reg(dm, 0xdd0, MASKDWORD);
+	rf_gain_a = (u8)(value32 & 0x3f);
+	rf_gain_a = rf_gain_a << 1;
+
+	rf_gain_b = (u8)((value32 >> 8) & 0x3f);
+	rf_gain_b = rf_gain_b << 1;
+
+	rf_gain_c = (u8)((value32 >> 16) & 0x3f);
+	rf_gain_c = rf_gain_c << 1;
+
+	rf_gain_d = (u8)((value32 >> 24) & 0x3f);
+	rf_gain_d = rf_gain_d << 1;
+
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %d / %d / %d / %d",
+		       "OFDM RX RF Gain(A/B/C/D)", rf_gain_a, rf_gain_b,
+		       rf_gain_c, rf_gain_d);
+
+	/*SNR report*/
+	value32 = odm_get_bb_reg(dm, 0xdd4, MASKDWORD);
+	rx_snr_a = (u8)(value32 & 0xff);
+	rx_snr_a = rx_snr_a >> 1;
+
+	rx_snr_b = (u8)((value32 >> 8) & 0xff);
+	rx_snr_b = rx_snr_b >> 1;
+
+	rx_snr_c = (u8)((value32 >> 16) & 0xff);
+	rx_snr_c = rx_snr_c >> 1;
+
+	rx_snr_d = (u8)((value32 >> 24) & 0xff);
+	rx_snr_d = rx_snr_d >> 1;
+
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %d / %d / %d / %d", "RXSNR(A/B/C/D, dB)",
+		       rx_snr_a, rx_snr_b, rx_snr_c, rx_snr_d);
+
+	/* PostFFT related info*/
+	value32 = odm_get_bb_reg(dm, 0xdd8, MASKDWORD);
+
+	rxevm_0 = (s8)((value32 & MASKBYTE2) >> 16);
+	rxevm_0 /= 2;
+	if (rxevm_0 < -63)
+		rxevm_0 = 0;
+
+	rxevm_1 = (s8)((value32 & MASKBYTE3) >> 24);
+	rxevm_1 /= 2;
+	if (rxevm_1 < -63)
+		rxevm_1 = 0;
+
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = %d / %d",
+		       "RXEVM (1ss/2ss)", rxevm_0, rxevm_1);
+
+	/*CFO Report Info*/
+	odm_set_bb_reg(dm, 0xd00, BIT(26), 1);
+
+	/*Short CFO*/
+	value32 = odm_get_bb_reg(dm, 0xdac, MASKDWORD);
+	value32_1 = odm_get_bb_reg(dm, 0xdb0, MASKDWORD);
+
+	short_cfo_b = (s32)(value32 & 0xfff); /*S(12,11)*/
+	short_cfo_a = (s32)((value32 & 0x0fff0000) >> 16);
+
+	long_cfo_b = (s32)(value32_1 & 0x1fff); /*S(13,12)*/
+	long_cfo_a = (s32)((value32_1 & 0x1fff0000) >> 16);
+
+	/*SFO 2's to dec*/
+	if (short_cfo_a > 2047)
+		short_cfo_a = short_cfo_a - 4096;
+	if (short_cfo_b > 2047)
+		short_cfo_b = short_cfo_b - 4096;
+
+	short_cfo_a = (short_cfo_a * 312500) / 2048;
+	short_cfo_b = (short_cfo_b * 312500) / 2048;
+
+	/*LFO 2's to dec*/
+
+	if (long_cfo_a > 4095)
+		long_cfo_a = long_cfo_a - 8192;
+
+	if (long_cfo_b > 4095)
+		long_cfo_b = long_cfo_b - 8192;
+
+	long_cfo_a = long_cfo_a * 312500 / 4096;
+	long_cfo_b = long_cfo_b * 312500 / 4096;
+
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s",
+		       "CFO Report Info");
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = %d / %d",
+		       "Short CFO(Hz) <A/B>", short_cfo_a, short_cfo_b);
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = %d / %d",
+		       "Long CFO(Hz) <A/B>", long_cfo_a, long_cfo_b);
+
+	/*SCFO*/
+	value32 = odm_get_bb_reg(dm, 0xdb8, MASKDWORD);
+	value32_1 = odm_get_bb_reg(dm, 0xdb4, MASKDWORD);
+
+	scfo_b = (s32)(value32 & 0x7ff); /*S(11,10)*/
+	scfo_a = (s32)((value32 & 0x07ff0000) >> 16);
+
+	if (scfo_a > 1023)
+		scfo_a = scfo_a - 2048;
+
+	if (scfo_b > 1023)
+		scfo_b = scfo_b - 2048;
+
+	scfo_a = scfo_a * 312500 / 1024;
+	scfo_b = scfo_b * 312500 / 1024;
+
+	avg_cfo_b = (s32)(value32_1 & 0x1fff); /*S(13,12)*/
+	avg_cfo_a = (s32)((value32_1 & 0x1fff0000) >> 16);
+
+	if (avg_cfo_a > 4095)
+		avg_cfo_a = avg_cfo_a - 8192;
+
+	if (avg_cfo_b > 4095)
+		avg_cfo_b = avg_cfo_b - 8192;
+
+	avg_cfo_a = avg_cfo_a * 312500 / 4096;
+	avg_cfo_b = avg_cfo_b * 312500 / 4096;
+
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = %d / %d",
+		       "value SCFO(Hz) <A/B>", scfo_a, scfo_b);
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = %d / %d",
+		       "Avg CFO(Hz) <A/B>", avg_cfo_a, avg_cfo_b);
+
+	value32 = odm_get_bb_reg(dm, 0xdbc, MASKDWORD);
+	value32_1 = odm_get_bb_reg(dm, 0xde0, MASKDWORD);
+
+	cfo_end_b = (s32)(value32 & 0x1fff); /*S(13,12)*/
+	cfo_end_a = (s32)((value32 & 0x1fff0000) >> 16);
+
+	if (cfo_end_a > 4095)
+		cfo_end_a = cfo_end_a - 8192;
+
+	if (cfo_end_b > 4095)
+		cfo_end_b = cfo_end_b - 8192;
+
+	cfo_end_a = cfo_end_a * 312500 / 4096;
+	cfo_end_b = cfo_end_b * 312500 / 4096;
+
+	acq_cfo_b = (s32)(value32_1 & 0x1fff); /*S(13,12)*/
+	acq_cfo_a = (s32)((value32_1 & 0x1fff0000) >> 16);
+
+	if (acq_cfo_a > 4095)
+		acq_cfo_a = acq_cfo_a - 8192;
+
+	if (acq_cfo_b > 4095)
+		acq_cfo_b = acq_cfo_b - 8192;
+
+	acq_cfo_a = acq_cfo_a * 312500 / 4096;
+	acq_cfo_b = acq_cfo_b * 312500 / 4096;
+
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = %d / %d",
+		       "End CFO(Hz) <A/B>", cfo_end_a, cfo_end_b);
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = %d / %d",
+		       "ACQ CFO(Hz) <A/B>", acq_cfo_a, acq_cfo_b);
+}
+
+static void phydm_bb_debug_info(void *dm_void, u32 *_used, char *output,
+				u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	char *tmp_string = NULL;
+
+	u8 rx_ht_bw, rx_vht_bw, rxsc, rx_ht, rx_bw;
+	static u8 v_rx_bw;
+	u32 value32, value32_1, value32_2, value32_3;
+	s32 sfo_a, sfo_b, sfo_c, sfo_d;
+	s32 lfo_a, lfo_b, lfo_c, lfo_d;
+	static u8 MCSS, tail, parity, rsv, vrsv, idx, smooth, htsound, agg,
+		stbc, vstbc, fec, fecext, sgi, sgiext, htltf, vgid, v_nsts,
+		vtxops, vrsv2, vbrsv, bf, vbcrc;
+	static u16 h_length, htcrc8, length;
+	static u16 vpaid;
+	static u16 v_length, vhtcrc8, v_mcss, v_tail, vb_tail;
+	static u8 hmcss, hrx_bw;
+
+	u8 pwdb;
+	s8 rxevm_0, rxevm_1, rxevm_2;
+	u8 rf_gain_path_a, rf_gain_path_b, rf_gain_path_c, rf_gain_path_d;
+	u8 rx_snr_path_a, rx_snr_path_b, rx_snr_path_c, rx_snr_path_d;
+	s32 sig_power;
+
+	const char *L_rate[8] = {"6M",  "9M",  "12M", "18M",
+				 "24M", "36M", "48M", "54M"};
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		phydm_bb_debug_info_n_series(dm, &used, output, &out_len);
+		return;
+	}
+
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s\n",
+		       "BB Report Info");
+
+	/*BW & mode Detection*/
+
+	value32 = odm_get_bb_reg(dm, 0xf80, MASKDWORD);
+	value32_2 = value32;
+	rx_ht_bw = (u8)(value32 & 0x1);
+	rx_vht_bw = (u8)((value32 >> 1) & 0x3);
+	rxsc = (u8)(value32 & 0x78);
+	value32_1 = (value32 & 0x180) >> 7;
+	rx_ht = (u8)(value32_1);
+
+	rx_bw = 0;
+
+	if (rx_ht == 2) {
+		if (rx_vht_bw == 0)
+			tmp_string = "20M";
+		else if (rx_vht_bw == 1)
+			tmp_string = "40M";
+		else
+			tmp_string = "80M";
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s %s %s", "mode", "VHT", tmp_string);
+		rx_bw = rx_vht_bw;
+	} else if (rx_ht == 1) {
+		if (rx_ht_bw == 0)
+			tmp_string = "20M";
+		else if (rx_ht_bw == 1)
+			tmp_string = "40M";
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s %s %s", "mode", "HT", tmp_string);
+		rx_bw = rx_ht_bw;
+	} else {
+		PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s %s",
+			       "mode", "Legacy");
+	}
+	if (rx_ht != 0) {
+		if (rxsc == 0)
+			tmp_string = "duplicate/full bw";
+		else if (rxsc == 1)
+			tmp_string = "usc20-1";
+		else if (rxsc == 2)
+			tmp_string = "lsc20-1";
+		else if (rxsc == 3)
+			tmp_string = "usc20-2";
+		else if (rxsc == 4)
+			tmp_string = "lsc20-2";
+		else if (rxsc == 9)
+			tmp_string = "usc40";
+		else if (rxsc == 10)
+			tmp_string = "lsc40";
+		PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s",
+			       tmp_string);
+	}
+
+	/* RX signal power and AGC related info*/
+
+	value32 = odm_get_bb_reg(dm, 0xF90, MASKDWORD);
+	pwdb = (u8)((value32 & MASKBYTE1) >> 8);
+	pwdb = pwdb >> 1;
+	sig_power = -110 + pwdb;
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = %d",
+		       "OFDM RX Signal Power(dB)", sig_power);
+
+	value32 = odm_get_bb_reg(dm, 0xd14, MASKDWORD);
+	rx_snr_path_a = (u8)(value32 & 0xFF) >> 1;
+	rf_gain_path_a = (s8)((value32 & MASKBYTE1) >> 8);
+	rf_gain_path_a *= 2;
+	value32 = odm_get_bb_reg(dm, 0xd54, MASKDWORD);
+	rx_snr_path_b = (u8)(value32 & 0xFF) >> 1;
+	rf_gain_path_b = (s8)((value32 & MASKBYTE1) >> 8);
+	rf_gain_path_b *= 2;
+	value32 = odm_get_bb_reg(dm, 0xd94, MASKDWORD);
+	rx_snr_path_c = (u8)(value32 & 0xFF) >> 1;
+	rf_gain_path_c = (s8)((value32 & MASKBYTE1) >> 8);
+	rf_gain_path_c *= 2;
+	value32 = odm_get_bb_reg(dm, 0xdd4, MASKDWORD);
+	rx_snr_path_d = (u8)(value32 & 0xFF) >> 1;
+	rf_gain_path_d = (s8)((value32 & MASKBYTE1) >> 8);
+	rf_gain_path_d *= 2;
+
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %d / %d / %d / %d",
+		       "OFDM RX RF Gain(A/B/C/D)", rf_gain_path_a,
+		       rf_gain_path_b, rf_gain_path_c, rf_gain_path_d);
+
+	/* RX counter related info*/
+
+	value32 = odm_get_bb_reg(dm, 0xF08, MASKDWORD);
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = %d",
+		       "OFDM CCA counter", ((value32 & 0xFFFF0000) >> 16));
+
+	value32 = odm_get_bb_reg(dm, 0xFD0, MASKDWORD);
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = %d",
+		       "OFDM SBD Fail counter", value32 & 0xFFFF);
+
+	value32 = odm_get_bb_reg(dm, 0xFC4, MASKDWORD);
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = %d / %d",
+		       "VHT SIGA/SIGB CRC8 Fail counter", value32 & 0xFFFF,
+		       ((value32 & 0xFFFF0000) >> 16));
+
+	value32 = odm_get_bb_reg(dm, 0xFCC, MASKDWORD);
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = %d",
+		       "CCK CCA counter", value32 & 0xFFFF);
+
+	value32 = odm_get_bb_reg(dm, 0xFBC, MASKDWORD);
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = %d / %d",
+		       "LSIG (parity Fail/rate Illegal) counter",
+		       value32 & 0xFFFF, ((value32 & 0xFFFF0000) >> 16));
+
+	value32_1 = odm_get_bb_reg(dm, 0xFC8, MASKDWORD);
+	value32_2 = odm_get_bb_reg(dm, 0xFC0, MASKDWORD);
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = %d / %d",
+		       "HT/VHT MCS NOT SUPPORT counter",
+		       ((value32_2 & 0xFFFF0000) >> 16), value32_1 & 0xFFFF);
+
+	/* PostFFT related info*/
+	value32 = odm_get_bb_reg(dm, 0xF8c, MASKDWORD);
+	rxevm_0 = (s8)((value32 & MASKBYTE2) >> 16);
+	rxevm_0 /= 2;
+	if (rxevm_0 < -63)
+		rxevm_0 = 0;
+
+	rxevm_1 = (s8)((value32 & MASKBYTE3) >> 24);
+	rxevm_1 /= 2;
+	value32 = odm_get_bb_reg(dm, 0xF88, MASKDWORD);
+	rxevm_2 = (s8)((value32 & MASKBYTE2) >> 16);
+	rxevm_2 /= 2;
+
+	if (rxevm_1 < -63)
+		rxevm_1 = 0;
+	if (rxevm_2 < -63)
+		rxevm_2 = 0;
+
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %d / %d / %d", "RXEVM (1ss/2ss/3ss)",
+		       rxevm_0, rxevm_1, rxevm_2);
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %d / %d / %d / %d", "RXSNR(A/B/C/D, dB)",
+		       rx_snr_path_a, rx_snr_path_b, rx_snr_path_c,
+		       rx_snr_path_d);
+
+	value32 = odm_get_bb_reg(dm, 0xF8C, MASKDWORD);
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s = %d / %d",
+		       "CSI_1st /CSI_2nd", value32 & 0xFFFF,
+		       ((value32 & 0xFFFF0000) >> 16));
+
+	/*BW & mode Detection*/
+
+	/*Reset Page F counter*/
+	odm_set_bb_reg(dm, 0xB58, BIT(0), 1);
+	odm_set_bb_reg(dm, 0xB58, BIT(0), 0);
+
+	/*CFO Report Info*/
+	/*Short CFO*/
+	value32 = odm_get_bb_reg(dm, 0xd0c, MASKDWORD);
+	value32_1 = odm_get_bb_reg(dm, 0xd4c, MASKDWORD);
+	value32_2 = odm_get_bb_reg(dm, 0xd8c, MASKDWORD);
+	value32_3 = odm_get_bb_reg(dm, 0xdcc, MASKDWORD);
+
+	sfo_a = (s32)(value32 & 0xfff);
+	sfo_b = (s32)(value32_1 & 0xfff);
+	sfo_c = (s32)(value32_2 & 0xfff);
+	sfo_d = (s32)(value32_3 & 0xfff);
+
+	lfo_a = (s32)(value32 >> 16);
+	lfo_b = (s32)(value32_1 >> 16);
+	lfo_c = (s32)(value32_2 >> 16);
+	lfo_d = (s32)(value32_3 >> 16);
+
+	/*SFO 2's to dec*/
+	if (sfo_a > 2047)
+		sfo_a = sfo_a - 4096;
+	sfo_a = (sfo_a * 312500) / 2048;
+	if (sfo_b > 2047)
+		sfo_b = sfo_b - 4096;
+	sfo_b = (sfo_b * 312500) / 2048;
+	if (sfo_c > 2047)
+		sfo_c = sfo_c - 4096;
+	sfo_c = (sfo_c * 312500) / 2048;
+	if (sfo_d > 2047)
+		sfo_d = sfo_d - 4096;
+	sfo_d = (sfo_d * 312500) / 2048;
+
+	/*LFO 2's to dec*/
+
+	if (lfo_a > 4095)
+		lfo_a = lfo_a - 8192;
+
+	if (lfo_b > 4095)
+		lfo_b = lfo_b - 8192;
+
+	if (lfo_c > 4095)
+		lfo_c = lfo_c - 8192;
+
+	if (lfo_d > 4095)
+		lfo_d = lfo_d - 8192;
+	lfo_a = lfo_a * 312500 / 4096;
+	lfo_b = lfo_b * 312500 / 4096;
+	lfo_c = lfo_c * 312500 / 4096;
+	lfo_d = lfo_d * 312500 / 4096;
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s",
+		       "CFO Report Info");
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %d / %d / %d /%d",
+		       "Short CFO(Hz) <A/B/C/D>", sfo_a, sfo_b, sfo_c, sfo_d);
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %d / %d / %d /%d",
+		       "Long CFO(Hz) <A/B/C/D>", lfo_a, lfo_b, lfo_c, lfo_d);
+
+	/*SCFO*/
+	value32 = odm_get_bb_reg(dm, 0xd10, MASKDWORD);
+	value32_1 = odm_get_bb_reg(dm, 0xd50, MASKDWORD);
+	value32_2 = odm_get_bb_reg(dm, 0xd90, MASKDWORD);
+	value32_3 = odm_get_bb_reg(dm, 0xdd0, MASKDWORD);
+
+	sfo_a = (s32)(value32 & 0x7ff);
+	sfo_b = (s32)(value32_1 & 0x7ff);
+	sfo_c = (s32)(value32_2 & 0x7ff);
+	sfo_d = (s32)(value32_3 & 0x7ff);
+
+	if (sfo_a > 1023)
+		sfo_a = sfo_a - 2048;
+
+	if (sfo_b > 2047)
+		sfo_b = sfo_b - 4096;
+
+	if (sfo_c > 2047)
+		sfo_c = sfo_c - 4096;
+
+	if (sfo_d > 2047)
+		sfo_d = sfo_d - 4096;
+
+	sfo_a = sfo_a * 312500 / 1024;
+	sfo_b = sfo_b * 312500 / 1024;
+	sfo_c = sfo_c * 312500 / 1024;
+	sfo_d = sfo_d * 312500 / 1024;
+
+	lfo_a = (s32)(value32 >> 16);
+	lfo_b = (s32)(value32_1 >> 16);
+	lfo_c = (s32)(value32_2 >> 16);
+	lfo_d = (s32)(value32_3 >> 16);
+
+	if (lfo_a > 4095)
+		lfo_a = lfo_a - 8192;
+
+	if (lfo_b > 4095)
+		lfo_b = lfo_b - 8192;
+
+	if (lfo_c > 4095)
+		lfo_c = lfo_c - 8192;
+
+	if (lfo_d > 4095)
+		lfo_d = lfo_d - 8192;
+	lfo_a = lfo_a * 312500 / 4096;
+	lfo_b = lfo_b * 312500 / 4096;
+	lfo_c = lfo_c * 312500 / 4096;
+	lfo_d = lfo_d * 312500 / 4096;
+
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %d / %d / %d /%d",
+		       "value SCFO(Hz) <A/B/C/D>", sfo_a, sfo_b, sfo_c, sfo_d);
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %d / %d / %d /%d", "ACQ CFO(Hz) <A/B/C/D>",
+		       lfo_a, lfo_b, lfo_c, lfo_d);
+
+	value32 = odm_get_bb_reg(dm, 0xd14, MASKDWORD);
+	value32_1 = odm_get_bb_reg(dm, 0xd54, MASKDWORD);
+	value32_2 = odm_get_bb_reg(dm, 0xd94, MASKDWORD);
+	value32_3 = odm_get_bb_reg(dm, 0xdd4, MASKDWORD);
+
+	lfo_a = (s32)(value32 >> 16);
+	lfo_b = (s32)(value32_1 >> 16);
+	lfo_c = (s32)(value32_2 >> 16);
+	lfo_d = (s32)(value32_3 >> 16);
+
+	if (lfo_a > 4095)
+		lfo_a = lfo_a - 8192;
+
+	if (lfo_b > 4095)
+		lfo_b = lfo_b - 8192;
+
+	if (lfo_c > 4095)
+		lfo_c = lfo_c - 8192;
+
+	if (lfo_d > 4095)
+		lfo_d = lfo_d - 8192;
+
+	lfo_a = lfo_a * 312500 / 4096;
+	lfo_b = lfo_b * 312500 / 4096;
+	lfo_c = lfo_c * 312500 / 4096;
+	lfo_d = lfo_d * 312500 / 4096;
+
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %d / %d / %d /%d", "End CFO(Hz) <A/B/C/D>",
+		       lfo_a, lfo_b, lfo_c, lfo_d);
+
+	value32 = odm_get_bb_reg(dm, 0xf20, MASKDWORD); /*L SIG*/
+
+	tail = (u8)((value32 & 0xfc0000) >> 16);
+	parity = (u8)((value32 & 0x20000) >> 16);
+	length = (u16)((value32 & 0x1ffe00) >> 8);
+	rsv = (u8)(value32 & 0x10);
+	MCSS = (u8)(value32 & 0x0f);
+
+	switch (MCSS) {
+	case 0x0b:
+		idx = 0;
+		break;
+	case 0x0f:
+		idx = 1;
+		break;
+	case 0x0a:
+		idx = 2;
+		break;
+	case 0x0e:
+		idx = 3;
+		break;
+	case 0x09:
+		idx = 4;
+		break;
+	case 0x08:
+		idx = 5;
+		break;
+	case 0x0c:
+		idx = 6;
+		break;
+	default:
+		idx = 6;
+		break;
+	}
+
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s", "L-SIG");
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s : %s", "rate",
+		       L_rate[idx]);
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %x / %x / %x", "Rsv/length/parity", rsv,
+		       rx_bw, length);
+
+	value32 = odm_get_bb_reg(dm, 0xf2c, MASKDWORD); /*HT SIG*/
+	if (rx_ht == 1) {
+		hmcss = (u8)(value32 & 0x7F);
+		hrx_bw = (u8)(value32 & 0x80);
+		h_length = (u16)((value32 >> 8) & 0xffff);
+	}
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s", "HT-SIG1");
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %x / %x / %x", "MCS/BW/length", hmcss,
+		       hrx_bw, h_length);
+
+	value32 = odm_get_bb_reg(dm, 0xf30, MASKDWORD); /*HT SIG*/
+
+	if (rx_ht == 1) {
+		smooth = (u8)(value32 & 0x01);
+		htsound = (u8)(value32 & 0x02);
+		rsv = (u8)(value32 & 0x04);
+		agg = (u8)(value32 & 0x08);
+		stbc = (u8)(value32 & 0x30);
+		fec = (u8)(value32 & 0x40);
+		sgi = (u8)(value32 & 0x80);
+		htltf = (u8)((value32 & 0x300) >> 8);
+		htcrc8 = (u16)((value32 & 0x3fc00) >> 8);
+		tail = (u8)((value32 & 0xfc0000) >> 16);
+	}
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s", "HT-SIG2");
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %x / %x / %x / %x / %x / %x",
+		       "Smooth/NoSound/Rsv/Aggregate/STBC/LDPC", smooth,
+		       htsound, rsv, agg, stbc, fec);
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %x / %x / %x / %x",
+		       "SGI/E-HT-LTFs/CRC/tail", sgi, htltf, htcrc8, tail);
+
+	value32 = odm_get_bb_reg(dm, 0xf2c, MASKDWORD); /*VHT SIG A1*/
+	if (rx_ht == 2) {
+		/* value32 = odm_get_bb_reg(dm, 0xf2c,MASKDWORD);*/
+		v_rx_bw = (u8)(value32 & 0x03);
+		vrsv = (u8)(value32 & 0x04);
+		vstbc = (u8)(value32 & 0x08);
+		vgid = (u8)((value32 & 0x3f0) >> 4);
+		v_nsts = (u8)(((value32 & 0x1c00) >> 8) + 1);
+		vpaid = (u16)(value32 & 0x3fe);
+		vtxops = (u8)((value32 & 0x400000) >> 20);
+		vrsv2 = (u8)((value32 & 0x800000) >> 20);
+	}
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s",
+		       "VHT-SIG-A1");
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %x / %x / %x / %x / %x / %x / %x / %x",
+		       "BW/Rsv1/STBC/GID/Nsts/PAID/TXOPPS/Rsv2", v_rx_bw, vrsv,
+		       vstbc, vgid, v_nsts, vpaid, vtxops, vrsv2);
+
+	value32 = odm_get_bb_reg(dm, 0xf30, MASKDWORD); /*VHT SIG*/
+
+	if (rx_ht == 2) {
+		/*value32 = odm_get_bb_reg(dm, 0xf30,MASKDWORD); */ /*VHT SIG*/
+
+		/* sgi=(u8)(value32&0x01); */
+		sgiext = (u8)(value32 & 0x03);
+		/* fec = (u8)(value32&0x04); */
+		fecext = (u8)(value32 & 0x0C);
+
+		v_mcss = (u8)(value32 & 0xf0);
+		bf = (u8)((value32 & 0x100) >> 8);
+		vrsv = (u8)((value32 & 0x200) >> 8);
+		vhtcrc8 = (u16)((value32 & 0x3fc00) >> 8);
+		v_tail = (u8)((value32 & 0xfc0000) >> 16);
+	}
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s",
+		       "VHT-SIG-A2");
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %x / %x / %x / %x / %x / %x / %x",
+		       "SGI/FEC/MCS/BF/Rsv/CRC/tail", sgiext, fecext, v_mcss,
+		       bf, vrsv, vhtcrc8, v_tail);
+
+	value32 = odm_get_bb_reg(dm, 0xf34, MASKDWORD); /*VHT SIG*/
+	{
+		v_length = (u16)(value32 & 0x1fffff);
+		vbrsv = (u8)((value32 & 0x600000) >> 20);
+		vb_tail = (u16)((value32 & 0x1f800000) >> 20);
+		vbcrc = (u8)((value32 & 0x80000000) >> 28);
+	}
+	PHYDM_SNPRINTF(output + used, out_len - used, "\r\n %-35s",
+		       "VHT-SIG-B");
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "\r\n %-35s = %x / %x / %x / %x", "length/Rsv/tail/CRC",
+		       v_length, vbrsv, vb_tail, vbcrc);
+
+	/*for Condition number*/
+	if (dm->support_ic_type & ODM_RTL8822B) {
+		s32 condition_num = 0;
+		char *factor = NULL;
+
+		/*enable report condition number*/
+		odm_set_bb_reg(dm, 0x1988, BIT(22), 0x1);
+
+		condition_num = odm_get_bb_reg(dm, 0xf84, MASKDWORD);
+		condition_num = (condition_num & 0x3ffff) >> 4;
+
+		if (*dm->band_width == ODM_BW80M) {
+			factor = "256/234";
+		} else if (*dm->band_width == ODM_BW40M) {
+			factor = "128/108";
+		} else if (*dm->band_width == ODM_BW20M) {
+			if (rx_ht == 2 || rx_ht == 1)
+				factor = "64/52"; /*HT or VHT*/
+			else
+				factor = "64/48"; /*legacy*/
+		}
+
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n %-35s = %d (factor = %s)",
+			       "Condition number", condition_num, factor);
+	}
+}
+
+void phydm_basic_dbg_message(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct false_alarm_stat *false_alm_cnt =
+		(struct false_alarm_stat *)phydm_get_structure(
+			dm, PHYDM_FALSEALMCNT);
+	struct cfo_tracking *cfo_track =
+		(struct cfo_tracking *)phydm_get_structure(dm, PHYDM_CFOTRACK);
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+	struct ra_table *ra_tab = &dm->dm_ra_table;
+	u16 macid, phydm_macid, client_cnt = 0;
+	struct rtl_sta_info *entry;
+	s32 tmp_val = 0;
+	u8 tmp_val_u1 = 0;
+
+	ODM_RT_TRACE(dm, ODM_COMP_COMMON,
+		     "[PHYDM Common MSG] System up time: ((%d sec))----->\n",
+		     dm->phydm_sys_up_time);
+
+	if (dm->is_linked) {
+		ODM_RT_TRACE(dm, ODM_COMP_COMMON,
+			     "ID=%d, BW=((%d)), CH=((%d))\n",
+			     dm->curr_station_id, 20 << *dm->band_width,
+			     *dm->channel);
+
+		/*Print RX rate*/
+		if (dm->rx_rate <= ODM_RATE11M)
+			ODM_RT_TRACE(
+				dm, ODM_COMP_COMMON,
+				"[CCK AGC Report] LNA_idx = 0x%x, VGA_idx = 0x%x\n",
+				dm->cck_lna_idx, dm->cck_vga_idx);
+		else
+			ODM_RT_TRACE(
+				dm, ODM_COMP_COMMON,
+				"[OFDM AGC Report] { 0x%x, 0x%x, 0x%x, 0x%x }\n",
+				dm->ofdm_agc_idx[0], dm->ofdm_agc_idx[1],
+				dm->ofdm_agc_idx[2], dm->ofdm_agc_idx[3]);
+
+		ODM_RT_TRACE(dm, ODM_COMP_COMMON,
+			     "RSSI: { %d,  %d,  %d,  %d },    rx_rate:",
+			     (dm->rssi_a == 0xff) ? 0 : dm->rssi_a,
+			     (dm->rssi_b == 0xff) ? 0 : dm->rssi_b,
+			     (dm->rssi_c == 0xff) ? 0 : dm->rssi_c,
+			     (dm->rssi_d == 0xff) ? 0 : dm->rssi_d);
+
+		phydm_print_rate(dm, dm->rx_rate, ODM_COMP_COMMON);
+
+		/*Print TX rate*/
+		for (macid = 0; macid < ODM_ASSOCIATE_ENTRY_NUM; macid++) {
+			entry = dm->odm_sta_info[macid];
+			if (!IS_STA_VALID(entry))
+				continue;
+
+			phydm_macid = (dm->platform2phydm_macid_table[macid]);
+			ODM_RT_TRACE(dm, ODM_COMP_COMMON, "TXRate [%d]:",
+				     macid);
+			phydm_print_rate(dm, ra_tab->link_tx_rate[macid],
+					 ODM_COMP_COMMON);
+
+			client_cnt++;
+
+			if (client_cnt == dm->number_linked_client)
+				break;
+		}
+
+		ODM_RT_TRACE(
+			dm, ODM_COMP_COMMON,
+			"TP { TX, RX, total} = {%d, %d, %d }Mbps, traffic_load = (%d))\n",
+			dm->tx_tp, dm->rx_tp, dm->total_tp, dm->traffic_load);
+
+		tmp_val_u1 =
+			(cfo_track->crystal_cap > cfo_track->def_x_cap) ?
+				(cfo_track->crystal_cap -
+				 cfo_track->def_x_cap) :
+				(cfo_track->def_x_cap - cfo_track->crystal_cap);
+		ODM_RT_TRACE(
+			dm, ODM_COMP_COMMON,
+			"CFO_avg = ((%d kHz)) , CrystalCap_tracking = ((%s%d))\n",
+			cfo_track->CFO_ave_pre,
+			((cfo_track->crystal_cap > cfo_track->def_x_cap) ? "+" :
+									   "-"),
+			tmp_val_u1);
+
+		/* Condition number */
+		if (dm->support_ic_type == ODM_RTL8822B) {
+			tmp_val = phydm_get_condition_number_8822B(dm);
+			ODM_RT_TRACE(dm, ODM_COMP_COMMON,
+				     "Condition number = ((%d))\n", tmp_val);
+		}
+
+		/*STBC or LDPC pkt*/
+		ODM_RT_TRACE(dm, ODM_COMP_COMMON, "LDPC = %s, STBC = %s\n",
+			     (dm->phy_dbg_info.is_ldpc_pkt) ? "Y" : "N",
+			     (dm->phy_dbg_info.is_stbc_pkt) ? "Y" : "N");
+	} else {
+		ODM_RT_TRACE(dm, ODM_COMP_COMMON, "No Link !!!\n");
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_COMMON,
+		     "[CCA Cnt] {CCK, OFDM, Total} = {%d, %d, %d}\n",
+		     false_alm_cnt->cnt_cck_cca, false_alm_cnt->cnt_ofdm_cca,
+		     false_alm_cnt->cnt_cca_all);
+
+	ODM_RT_TRACE(dm, ODM_COMP_COMMON,
+		     "[FA Cnt] {CCK, OFDM, Total} = {%d, %d, %d}\n",
+		     false_alm_cnt->cnt_cck_fail, false_alm_cnt->cnt_ofdm_fail,
+		     false_alm_cnt->cnt_all);
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES)
+		ODM_RT_TRACE(
+			dm, ODM_COMP_COMMON,
+			"[OFDM FA Detail] Parity_Fail = (( %d )), Rate_Illegal = (( %d )), CRC8_fail = (( %d )), Mcs_fail = (( %d )), Fast_Fsync = (( %d )), SB_Search_fail = (( %d ))\n",
+			false_alm_cnt->cnt_parity_fail,
+			false_alm_cnt->cnt_rate_illegal,
+			false_alm_cnt->cnt_crc8_fail,
+			false_alm_cnt->cnt_mcs_fail,
+			false_alm_cnt->cnt_fast_fsync,
+			false_alm_cnt->cnt_sb_search_fail);
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_COMMON,
+		"is_linked = %d, Num_client = %d, rssi_min = %d, current_igi = 0x%x, bNoisy=%d\n\n",
+		dm->is_linked, dm->number_linked_client, dm->rssi_min,
+		dig_tab->cur_ig_value, dm->noisy_decision);
+}
+
+void phydm_basic_profile(void *dm_void, u32 *_used, char *output, u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	char *cut = NULL;
+	char *ic_type = NULL;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+	u32 date = 0;
+	char *commit_by = NULL;
+	u32 release_ver = 0;
+
+	PHYDM_SNPRINTF(output + used, out_len - used, "%-35s\n",
+		       "% Basic Profile %");
+
+	if (dm->support_ic_type == ODM_RTL8188E) {
+	} else if (dm->support_ic_type == ODM_RTL8822B) {
+		ic_type = "RTL8822B";
+		date = RELEASE_DATE_8822B;
+		commit_by = COMMIT_BY_8822B;
+		release_ver = RELEASE_VERSION_8822B;
+	}
+
+	/* JJ ADD 20161014 */
+
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "  %-35s: %s (MP Chip: %s)\n", "IC type", ic_type,
+		       dm->is_mp_chip ? "Yes" : "No");
+
+	if (dm->cut_version == ODM_CUT_A)
+		cut = "A";
+	else if (dm->cut_version == ODM_CUT_B)
+		cut = "B";
+	else if (dm->cut_version == ODM_CUT_C)
+		cut = "C";
+	else if (dm->cut_version == ODM_CUT_D)
+		cut = "D";
+	else if (dm->cut_version == ODM_CUT_E)
+		cut = "E";
+	else if (dm->cut_version == ODM_CUT_F)
+		cut = "F";
+	else if (dm->cut_version == ODM_CUT_I)
+		cut = "I";
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+		       "cut version", cut);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %d\n",
+		       "PHY Parameter version", odm_get_hw_img_version(dm));
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %d\n",
+		       "PHY Parameter Commit date", date);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+		       "PHY Parameter Commit by", commit_by);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %d\n",
+		       "PHY Parameter Release version", release_ver);
+
+	{
+		struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+		struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "  %-35s: %d (Subversion: %d)\n", "FW version",
+			       rtlhal->fw_version, rtlhal->fw_subversion);
+	}
+	/* 1 PHY DM version List */
+	PHYDM_SNPRINTF(output + used, out_len - used, "%-35s\n",
+		       "% PHYDM version %");
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+		       "Code base", PHYDM_CODE_BASE);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+		       "Release Date", PHYDM_RELEASE_DATE);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+		       "adaptivity", ADAPTIVITY_VERSION);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n", "DIG",
+		       DIG_VERSION);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+		       "Dynamic BB PowerSaving", DYNAMIC_BBPWRSAV_VERSION);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+		       "CFO Tracking", CFO_TRACKING_VERSION);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+		       "Antenna Diversity", ANTDIV_VERSION);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+		       "Power Tracking", POWRTRACKING_VERSION);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+		       "Dynamic TxPower", DYNAMIC_TXPWR_VERSION);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+		       "RA Info", RAINFO_VERSION);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+		       "Auto channel Selection", ACS_VERSION);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+		       "EDCA Turbo", EDCATURBO_VERSION);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+		       "LA mode", DYNAMIC_LA_MODE);
+	PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+		       "Dynamic RX path", DYNAMIC_RX_PATH_VERSION);
+
+	if (dm->support_ic_type & ODM_RTL8822B)
+		PHYDM_SNPRINTF(output + used, out_len - used, "  %-35s: %s\n",
+			       "PHY config 8822B", PHY_CONFIG_VERSION_8822B);
+
+	*_used = used;
+	*_out_len = out_len;
+}
+
+void phydm_fw_trace_en_h2c(void *dm_void, bool enable, u32 fw_debug_component,
+			   u32 monitor_mode, u32 macid)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 h2c_parameter[7] = {0};
+	u8 cmd_length;
+
+	if (dm->support_ic_type & PHYDM_IC_3081_SERIES) {
+		h2c_parameter[0] = enable;
+		h2c_parameter[1] = (u8)(fw_debug_component & MASKBYTE0);
+		h2c_parameter[2] = (u8)((fw_debug_component & MASKBYTE1) >> 8);
+		h2c_parameter[3] = (u8)((fw_debug_component & MASKBYTE2) >> 16);
+		h2c_parameter[4] = (u8)((fw_debug_component & MASKBYTE3) >> 24);
+		h2c_parameter[5] = (u8)monitor_mode;
+		h2c_parameter[6] = (u8)macid;
+		cmd_length = 7;
+
+	} else {
+		h2c_parameter[0] = enable;
+		h2c_parameter[1] = (u8)monitor_mode;
+		h2c_parameter[2] = (u8)macid;
+		cmd_length = 3;
+	}
+
+	ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "---->\n");
+	if (monitor_mode == 0)
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE,
+			     "[H2C] FW_debug_en: (( %d ))\n", enable);
+	else
+		ODM_RT_TRACE(
+			dm, ODM_FW_DEBUG_TRACE,
+			"[H2C] FW_debug_en: (( %d )), mode: (( %d )), macid: (( %d ))\n",
+			enable, monitor_mode, macid);
+	odm_fill_h2c_cmd(dm, PHYDM_H2C_FW_TRACE_EN, cmd_length, h2c_parameter);
+}
+
+bool phydm_api_set_txagc(struct phy_dm_struct *dm, u32 power_index,
+			 enum odm_rf_radio_path path, u8 hw_rate,
+			 bool is_single_rate)
+{
+	bool ret = false;
+
+	if (dm->support_ic_type & (ODM_RTL8822B | ODM_RTL8821C)) {
+		if (is_single_rate) {
+			if (dm->support_ic_type == ODM_RTL8822B)
+				ret = phydm_write_txagc_1byte_8822b(
+					dm, power_index, path, hw_rate);
+
+		} else {
+			if (dm->support_ic_type == ODM_RTL8822B)
+				ret = config_phydm_write_txagc_8822b(
+					dm, power_index, path, hw_rate);
+		}
+	}
+
+	return ret;
+}
+
+static u8 phydm_api_get_txagc(struct phy_dm_struct *dm,
+			      enum odm_rf_radio_path path, u8 hw_rate)
+{
+	u8 ret = 0;
+
+	if (dm->support_ic_type & ODM_RTL8822B)
+		ret = config_phydm_read_txagc_8822b(dm, path, hw_rate);
+
+	return ret;
+}
+
+static bool phydm_api_switch_bw_channel(struct phy_dm_struct *dm, u8 central_ch,
+					u8 primary_ch_idx,
+					enum odm_bw bandwidth)
+{
+	bool ret = false;
+
+	if (dm->support_ic_type & ODM_RTL8822B)
+		ret = config_phydm_switch_channel_bw_8822b(
+			dm, central_ch, primary_ch_idx, bandwidth);
+
+	return ret;
+}
+
+bool phydm_api_trx_mode(struct phy_dm_struct *dm, enum odm_rf_path tx_path,
+			enum odm_rf_path rx_path, bool is_tx2_path)
+{
+	bool ret = false;
+
+	if (dm->support_ic_type & ODM_RTL8822B)
+		ret = config_phydm_trx_mode_8822b(dm, tx_path, rx_path,
+						  is_tx2_path);
+
+	return ret;
+}
+
+static void phydm_get_per_path_txagc(void *dm_void, u8 path, u32 *_used,
+				     char *output, u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 rate_idx;
+	u8 txagc;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	if (((dm->support_ic_type & (ODM_RTL8822B | ODM_RTL8197F)) &&
+	     (path <= ODM_RF_PATH_B)) ||
+	    ((dm->support_ic_type & (ODM_RTL8821C)) &&
+	     (path <= ODM_RF_PATH_A))) {
+		for (rate_idx = 0; rate_idx <= 0x53; rate_idx++) {
+			if (rate_idx == ODM_RATE1M)
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "  %-35s\n", "CCK====>");
+			else if (rate_idx == ODM_RATE6M)
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "\n  %-35s\n", "OFDM====>");
+			else if (rate_idx == ODM_RATEMCS0)
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "\n  %-35s\n", "HT 1ss====>");
+			else if (rate_idx == ODM_RATEMCS8)
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "\n  %-35s\n", "HT 2ss====>");
+			else if (rate_idx == ODM_RATEMCS16)
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "\n  %-35s\n", "HT 3ss====>");
+			else if (rate_idx == ODM_RATEMCS24)
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "\n  %-35s\n", "HT 4ss====>");
+			else if (rate_idx == ODM_RATEVHTSS1MCS0)
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "\n  %-35s\n", "VHT 1ss====>");
+			else if (rate_idx == ODM_RATEVHTSS2MCS0)
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "\n  %-35s\n", "VHT 2ss====>");
+			else if (rate_idx == ODM_RATEVHTSS3MCS0)
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "\n  %-35s\n", "VHT 3ss====>");
+			else if (rate_idx == ODM_RATEVHTSS4MCS0)
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "\n  %-35s\n", "VHT 4ss====>");
+
+			txagc = phydm_api_get_txagc(
+				dm, (enum odm_rf_radio_path)path, rate_idx);
+			if (config_phydm_read_txagc_check(txagc))
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "  0x%02x    ", txagc);
+			else
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "  0x%s    ", "xx");
+		}
+	}
+}
+
+static void phydm_get_txagc(void *dm_void, u32 *_used, char *output,
+			    u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	/* path-A */
+	PHYDM_SNPRINTF(output + used, out_len - used, "%-35s\n",
+		       "path-A====================");
+	phydm_get_per_path_txagc(dm, ODM_RF_PATH_A, _used, output, _out_len);
+
+	/* path-B */
+	PHYDM_SNPRINTF(output + used, out_len - used, "\n%-35s\n",
+		       "path-B====================");
+	phydm_get_per_path_txagc(dm, ODM_RF_PATH_B, _used, output, _out_len);
+
+	/* path-C */
+	PHYDM_SNPRINTF(output + used, out_len - used, "\n%-35s\n",
+		       "path-C====================");
+	phydm_get_per_path_txagc(dm, ODM_RF_PATH_C, _used, output, _out_len);
+
+	/* path-D */
+	PHYDM_SNPRINTF(output + used, out_len - used, "\n%-35s\n",
+		       "path-D====================");
+	phydm_get_per_path_txagc(dm, ODM_RF_PATH_D, _used, output, _out_len);
+}
+
+static void phydm_set_txagc(void *dm_void, u32 *const dm_value, u32 *_used,
+			    char *output, u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	/*dm_value[1] = path*/
+	/*dm_value[2] = hw_rate*/
+	/*dm_value[3] = power_index*/
+
+	if (dm->support_ic_type &
+	    (ODM_RTL8822B | ODM_RTL8197F | ODM_RTL8821C)) {
+		if (dm_value[1] <= 1) {
+			phydm_check_dmval_txagc(dm, used, out_len, dm_value,
+						output);
+		} else {
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "  %s%d   %s%x%s\n", "Write path-",
+				       (dm_value[1] & 0x1), "rate index-0x",
+				       (dm_value[2] & 0x7f), " fail");
+		}
+	}
+}
+
+static void phydm_debug_trace(void *dm_void, u32 *const dm_value, u32 *_used,
+			      char *output, u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 pre_debug_components, one = 1;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	pre_debug_components = dm->debug_components;
+
+	PHYDM_SNPRINTF(output + used, out_len - used, "\n%s\n",
+		       "================================");
+	if (dm_value[0] == 100) {
+		PHYDM_SNPRINTF(output + used, out_len - used, "%s\n",
+			       "[Debug Message] PhyDM Selection");
+		PHYDM_SNPRINTF(output + used, out_len - used, "%s\n",
+			       "================================");
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "00. (( %s ))DIG\n",
+			       ((dm->debug_components & ODM_COMP_DIG) ? ("V") :
+									(".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "01. (( %s ))RA_MASK\n",
+			((dm->debug_components & ODM_COMP_RA_MASK) ? ("V") :
+								     (".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used,
+			"02. (( %s ))DYNAMIC_TXPWR\n",
+			((dm->debug_components & ODM_COMP_DYNAMIC_TXPWR) ?
+				 ("V") :
+				 (".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "03. (( %s ))FA_CNT\n",
+			((dm->debug_components & ODM_COMP_FA_CNT) ? ("V") :
+								    (".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "04. (( %s ))RSSI_MONITOR\n",
+			       ((dm->debug_components & ODM_COMP_RSSI_MONITOR) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "05. (( %s ))SNIFFER\n",
+			((dm->debug_components & ODM_COMP_SNIFFER) ? ("V") :
+								     (".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "06. (( %s ))ANT_DIV\n",
+			((dm->debug_components & ODM_COMP_ANT_DIV) ? ("V") :
+								     (".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "07. (( %s ))DFS\n",
+			       ((dm->debug_components & ODM_COMP_DFS) ? ("V") :
+									(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "08. (( %s ))NOISY_DETECT\n",
+			       ((dm->debug_components & ODM_COMP_NOISY_DETECT) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used,
+			"09. (( %s ))RATE_ADAPTIVE\n",
+			((dm->debug_components & ODM_COMP_RATE_ADAPTIVE) ?
+				 ("V") :
+				 (".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "10. (( %s ))PATH_DIV\n",
+			((dm->debug_components & ODM_COMP_PATH_DIV) ? ("V") :
+								      (".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used,
+			"12. (( %s ))DYNAMIC_PRICCA\n",
+			((dm->debug_components & ODM_COMP_DYNAMIC_PRICCA) ?
+				 ("V") :
+				 (".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "14. (( %s ))MP\n",
+			((dm->debug_components & ODM_COMP_MP) ? ("V") : (".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "15. (( %s ))struct cfo_tracking\n",
+			       ((dm->debug_components & ODM_COMP_CFO_TRACKING) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "16. (( %s ))struct acs_info\n",
+			       ((dm->debug_components & ODM_COMP_ACS) ? ("V") :
+									(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "17. (( %s ))ADAPTIVITY\n",
+			       ((dm->debug_components & PHYDM_COMP_ADAPTIVITY) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "18. (( %s ))RA_DBG\n",
+			((dm->debug_components & PHYDM_COMP_RA_DBG) ? ("V") :
+								      (".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "19. (( %s ))TXBF\n",
+			((dm->debug_components & PHYDM_COMP_TXBF) ? ("V") :
+								    (".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "20. (( %s ))EDCA_TURBO\n",
+			       ((dm->debug_components & ODM_COMP_EDCA_TURBO) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "22. (( %s ))FW_DEBUG_TRACE\n",
+			       ((dm->debug_components & ODM_FW_DEBUG_TRACE) ?
+					("V") :
+					(".")));
+
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "24. (( %s ))TX_PWR_TRACK\n",
+			       ((dm->debug_components & ODM_COMP_TX_PWR_TRACK) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "26. (( %s ))CALIBRATION\n",
+			       ((dm->debug_components & ODM_COMP_CALIBRATION) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "28. (( %s ))PHY_CONFIG\n",
+			       ((dm->debug_components & ODM_PHY_CONFIG) ?
+					("V") :
+					(".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "29. (( %s ))INIT\n",
+			((dm->debug_components & ODM_COMP_INIT) ? ("V") :
+								  (".")));
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "30. (( %s ))COMMON\n",
+			((dm->debug_components & ODM_COMP_COMMON) ? ("V") :
+								    (".")));
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "31. (( %s ))API\n",
+			       ((dm->debug_components & ODM_COMP_API) ? ("V") :
+									(".")));
+		PHYDM_SNPRINTF(output + used, out_len - used, "%s\n",
+			       "================================");
+
+	} else if (dm_value[0] == 101) {
+		dm->debug_components = 0;
+		PHYDM_SNPRINTF(output + used, out_len - used, "%s\n",
+			       "Disable all debug components");
+	} else {
+		if (dm_value[1] == 1) /*enable*/
+			dm->debug_components |= (one << dm_value[0]);
+		else if (dm_value[1] == 2) /*disable*/
+			dm->debug_components &= ~(one << dm_value[0]);
+		else
+			PHYDM_SNPRINTF(output + used, out_len - used, "%s\n",
+				       "[Warning!!!]  1:enable,  2:disable");
+	}
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "pre-DbgComponents = 0x%x\n", pre_debug_components);
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "Curr-DbgComponents = 0x%x\n", dm->debug_components);
+	PHYDM_SNPRINTF(output + used, out_len - used, "%s\n",
+		       "================================");
+}
+
+static void phydm_fw_debug_trace(void *dm_void, u32 *const dm_value, u32 *_used,
+				 char *output, u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 pre_fw_debug_components, one = 1;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	pre_fw_debug_components = dm->fw_debug_components;
+
+	PHYDM_SNPRINTF(output + used, out_len - used, "\n%s\n",
+		       "================================");
+	if (dm_value[0] == 100) {
+		PHYDM_SNPRINTF(output + used, out_len - used, "%s\n",
+			       "[FW Debug Component]");
+		PHYDM_SNPRINTF(output + used, out_len - used, "%s\n",
+			       "================================");
+		PHYDM_SNPRINTF(
+			output + used, out_len - used, "00. (( %s ))RA\n",
+			((dm->fw_debug_components & PHYDM_FW_COMP_RA) ? ("V") :
+									(".")));
+
+		if (dm->support_ic_type & PHYDM_IC_3081_SERIES) {
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"01. (( %s ))MU\n",
+				((dm->fw_debug_components & PHYDM_FW_COMP_MU) ?
+					 ("V") :
+					 (".")));
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "02. (( %s ))path Div\n",
+				       ((dm->fw_debug_components &
+					 PHYDM_FW_COMP_PHY_CONFIG) ?
+						("V") :
+						(".")));
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "03. (( %s ))Phy Config\n",
+				       ((dm->fw_debug_components &
+					 PHYDM_FW_COMP_PHY_CONFIG) ?
+						("V") :
+						(".")));
+		}
+		PHYDM_SNPRINTF(output + used, out_len - used, "%s\n",
+			       "================================");
+
+	} else {
+		if (dm_value[0] == 101) {
+			dm->fw_debug_components = 0;
+			PHYDM_SNPRINTF(output + used, out_len - used, "%s\n",
+				       "Clear all fw debug components");
+		} else {
+			if (dm_value[1] == 1) /*enable*/
+				dm->fw_debug_components |= (one << dm_value[0]);
+			else if (dm_value[1] == 2) /*disable*/
+				dm->fw_debug_components &=
+					~(one << dm_value[0]);
+			else
+				PHYDM_SNPRINTF(
+					output + used, out_len - used, "%s\n",
+					"[Warning!!!]  1:enable,  2:disable");
+		}
+
+		if (dm->fw_debug_components == 0) {
+			dm->debug_components &= ~ODM_FW_DEBUG_TRACE;
+			phydm_fw_trace_en_h2c(
+				dm, false, dm->fw_debug_components, dm_value[2],
+				dm_value[3]); /*H2C to enable C2H Msg*/
+		} else {
+			dm->debug_components |= ODM_FW_DEBUG_TRACE;
+			phydm_fw_trace_en_h2c(
+				dm, true, dm->fw_debug_components, dm_value[2],
+				dm_value[3]); /*H2C to enable C2H Msg*/
+		}
+	}
+}
+
+static void phydm_dump_bb_reg(void *dm_void, u32 *_used, char *output,
+			      u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 addr = 0;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	/* For Nseries IC we only need to dump page8 to pageF using 3 digits*/
+	for (addr = 0x800; addr < 0xfff; addr += 4) {
+		if (dm->support_ic_type & ODM_IC_11N_SERIES)
+			PHYDM_VAST_INFO_SNPRINTF(
+				output + used, out_len - used,
+				"0x%03x 0x%08x\n", addr,
+				odm_get_bb_reg(dm, addr, MASKDWORD));
+		else
+			PHYDM_VAST_INFO_SNPRINTF(
+				output + used, out_len - used,
+				"0x%04x 0x%08x\n", addr,
+				odm_get_bb_reg(dm, addr, MASKDWORD));
+	}
+
+	if (dm->support_ic_type &
+	    (ODM_RTL8822B | ODM_RTL8814A | ODM_RTL8821C)) {
+		if (dm->rf_type > ODM_2T2R) {
+			for (addr = 0x1800; addr < 0x18ff; addr += 4)
+				PHYDM_VAST_INFO_SNPRINTF(
+					output + used, out_len - used,
+					"0x%04x 0x%08x\n", addr,
+					odm_get_bb_reg(dm, addr, MASKDWORD));
+		}
+
+		if (dm->rf_type > ODM_3T3R) {
+			for (addr = 0x1a00; addr < 0x1aff; addr += 4)
+				PHYDM_VAST_INFO_SNPRINTF(
+					output + used, out_len - used,
+					"0x%04x 0x%08x\n", addr,
+					odm_get_bb_reg(dm, addr, MASKDWORD));
+		}
+
+		for (addr = 0x1900; addr < 0x19ff; addr += 4)
+			PHYDM_VAST_INFO_SNPRINTF(
+				output + used, out_len - used,
+				"0x%04x 0x%08x\n", addr,
+				odm_get_bb_reg(dm, addr, MASKDWORD));
+
+		for (addr = 0x1c00; addr < 0x1cff; addr += 4)
+			PHYDM_VAST_INFO_SNPRINTF(
+				output + used, out_len - used,
+				"0x%04x 0x%08x\n", addr,
+				odm_get_bb_reg(dm, addr, MASKDWORD));
+
+		for (addr = 0x1f00; addr < 0x1fff; addr += 4)
+			PHYDM_VAST_INFO_SNPRINTF(
+				output + used, out_len - used,
+				"0x%04x 0x%08x\n", addr,
+				odm_get_bb_reg(dm, addr, MASKDWORD));
+	}
+}
+
+static void phydm_dump_all_reg(void *dm_void, u32 *_used, char *output,
+			       u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 addr = 0;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	/* dump MAC register */
+	PHYDM_VAST_INFO_SNPRINTF(output + used, out_len - used,
+				 "MAC==========\n");
+	for (addr = 0; addr < 0x7ff; addr += 4)
+		PHYDM_VAST_INFO_SNPRINTF(output + used, out_len - used,
+					 "0x%04x 0x%08x\n", addr,
+					 odm_get_bb_reg(dm, addr, MASKDWORD));
+
+	for (addr = 0x1000; addr < 0x17ff; addr += 4)
+		PHYDM_VAST_INFO_SNPRINTF(output + used, out_len - used,
+					 "0x%04x 0x%08x\n", addr,
+					 odm_get_bb_reg(dm, addr, MASKDWORD));
+
+	/* dump BB register */
+	PHYDM_VAST_INFO_SNPRINTF(output + used, out_len - used,
+				 "BB==========\n");
+	phydm_dump_bb_reg(dm, &used, output, &out_len);
+
+	/* dump RF register */
+	PHYDM_VAST_INFO_SNPRINTF(output + used, out_len - used,
+				 "RF-A==========\n");
+	for (addr = 0; addr < 0xFF; addr++)
+		PHYDM_VAST_INFO_SNPRINTF(output + used, out_len - used,
+					 "0x%02x 0x%05x\n", addr,
+					 odm_get_rf_reg(dm, ODM_RF_PATH_A, addr,
+							RFREGOFFSETMASK));
+
+	if (dm->rf_type > ODM_1T1R) {
+		PHYDM_VAST_INFO_SNPRINTF(output + used, out_len - used,
+					 "RF-B==========\n");
+		for (addr = 0; addr < 0xFF; addr++)
+			PHYDM_VAST_INFO_SNPRINTF(
+				output + used, out_len - used,
+				"0x%02x 0x%05x\n", addr,
+				odm_get_rf_reg(dm, ODM_RF_PATH_B, addr,
+					       RFREGOFFSETMASK));
+	}
+
+	if (dm->rf_type > ODM_2T2R) {
+		PHYDM_VAST_INFO_SNPRINTF(output + used, out_len - used,
+					 "RF-C==========\n");
+		for (addr = 0; addr < 0xFF; addr++)
+			PHYDM_VAST_INFO_SNPRINTF(
+				output + used, out_len - used,
+				"0x%02x 0x%05x\n", addr,
+				odm_get_rf_reg(dm, ODM_RF_PATH_C, addr,
+					       RFREGOFFSETMASK));
+	}
+
+	if (dm->rf_type > ODM_3T3R) {
+		PHYDM_VAST_INFO_SNPRINTF(output + used, out_len - used,
+					 "RF-D==========\n");
+		for (addr = 0; addr < 0xFF; addr++)
+			PHYDM_VAST_INFO_SNPRINTF(
+				output + used, out_len - used,
+				"0x%02x 0x%05x\n", addr,
+				odm_get_rf_reg(dm, ODM_RF_PATH_D, addr,
+					       RFREGOFFSETMASK));
+	}
+}
+
+static void phydm_enable_big_jump(struct phy_dm_struct *dm, bool state)
+{
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+
+	if (!state) {
+		dm->dm_dig_table.enable_adjust_big_jump = false;
+		odm_set_bb_reg(dm, 0x8c8, 0xfe,
+			       ((dig_tab->big_jump_step3 << 5) |
+				(dig_tab->big_jump_step2 << 3) |
+				dig_tab->big_jump_step1));
+	} else {
+		dm->dm_dig_table.enable_adjust_big_jump = true;
+	}
+}
+
+static void phydm_show_rx_rate(struct phy_dm_struct *dm, u32 *_used,
+			       char *output, u32 *_out_len)
+{
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "=====Rx SU rate Statistics=====\n");
+	PHYDM_SNPRINTF(
+		output + used, out_len - used,
+		"1SS MCS0 = %d, 1SS MCS1 = %d, 1SS MCS2 = %d, 1SS MCS 3 = %d\n",
+		dm->phy_dbg_info.num_qry_vht_pkt[0],
+		dm->phy_dbg_info.num_qry_vht_pkt[1],
+		dm->phy_dbg_info.num_qry_vht_pkt[2],
+		dm->phy_dbg_info.num_qry_vht_pkt[3]);
+	PHYDM_SNPRINTF(
+		output + used, out_len - used,
+		"1SS MCS4 = %d, 1SS MCS5 = %d, 1SS MCS6 = %d, 1SS MCS 7 = %d\n",
+		dm->phy_dbg_info.num_qry_vht_pkt[4],
+		dm->phy_dbg_info.num_qry_vht_pkt[5],
+		dm->phy_dbg_info.num_qry_vht_pkt[6],
+		dm->phy_dbg_info.num_qry_vht_pkt[7]);
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "1SS MCS8 = %d, 1SS MCS9 = %d\n",
+		       dm->phy_dbg_info.num_qry_vht_pkt[8],
+		       dm->phy_dbg_info.num_qry_vht_pkt[9]);
+	PHYDM_SNPRINTF(
+		output + used, out_len - used,
+		"2SS MCS0 = %d, 2SS MCS1 = %d, 2SS MCS2 = %d, 2SS MCS 3 = %d\n",
+		dm->phy_dbg_info.num_qry_vht_pkt[10],
+		dm->phy_dbg_info.num_qry_vht_pkt[11],
+		dm->phy_dbg_info.num_qry_vht_pkt[12],
+		dm->phy_dbg_info.num_qry_vht_pkt[13]);
+	PHYDM_SNPRINTF(
+		output + used, out_len - used,
+		"2SS MCS4 = %d, 2SS MCS5 = %d, 2SS MCS6 = %d, 2SS MCS 7 = %d\n",
+		dm->phy_dbg_info.num_qry_vht_pkt[14],
+		dm->phy_dbg_info.num_qry_vht_pkt[15],
+		dm->phy_dbg_info.num_qry_vht_pkt[16],
+		dm->phy_dbg_info.num_qry_vht_pkt[17]);
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "2SS MCS8 = %d, 2SS MCS9 = %d\n",
+		       dm->phy_dbg_info.num_qry_vht_pkt[18],
+		       dm->phy_dbg_info.num_qry_vht_pkt[19]);
+
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "=====Rx MU rate Statistics=====\n");
+	PHYDM_SNPRINTF(
+		output + used, out_len - used,
+		"1SS MCS0 = %d, 1SS MCS1 = %d, 1SS MCS2 = %d, 1SS MCS 3 = %d\n",
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[0],
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[1],
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[2],
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[3]);
+	PHYDM_SNPRINTF(
+		output + used, out_len - used,
+		"1SS MCS4 = %d, 1SS MCS5 = %d, 1SS MCS6 = %d, 1SS MCS 7 = %d\n",
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[4],
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[5],
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[6],
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[7]);
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "1SS MCS8 = %d, 1SS MCS9 = %d\n",
+		       dm->phy_dbg_info.num_qry_mu_vht_pkt[8],
+		       dm->phy_dbg_info.num_qry_mu_vht_pkt[9]);
+	PHYDM_SNPRINTF(
+		output + used, out_len - used,
+		"2SS MCS0 = %d, 2SS MCS1 = %d, 2SS MCS2 = %d, 2SS MCS 3 = %d\n",
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[10],
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[11],
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[12],
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[13]);
+	PHYDM_SNPRINTF(
+		output + used, out_len - used,
+		"2SS MCS4 = %d, 2SS MCS5 = %d, 2SS MCS6 = %d, 2SS MCS 7 = %d\n",
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[14],
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[15],
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[16],
+		dm->phy_dbg_info.num_qry_mu_vht_pkt[17]);
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "2SS MCS8 = %d, 2SS MCS9 = %d\n",
+		       dm->phy_dbg_info.num_qry_mu_vht_pkt[18],
+		       dm->phy_dbg_info.num_qry_mu_vht_pkt[19]);
+}
+
+struct phydm_command {
+	char name[16];
+	u8 id;
+};
+
+enum PHYDM_CMD_ID {
+	PHYDM_HELP,
+	PHYDM_DEMO,
+	PHYDM_RA,
+	PHYDM_PROFILE,
+	PHYDM_ANTDIV,
+	PHYDM_PATHDIV,
+	PHYDM_DEBUG,
+	PHYDM_FW_DEBUG,
+	PHYDM_SUPPORT_ABILITY,
+	PHYDM_GET_TXAGC,
+	PHYDM_SET_TXAGC,
+	PHYDM_SMART_ANT,
+	PHYDM_API,
+	PHYDM_TRX_PATH,
+	PHYDM_LA_MODE,
+	PHYDM_DUMP_REG,
+	PHYDM_MU_MIMO,
+	PHYDM_HANG,
+	PHYDM_BIG_JUMP,
+	PHYDM_SHOW_RXRATE,
+	PHYDM_NBI_EN,
+	PHYDM_CSI_MASK_EN,
+	PHYDM_DFS,
+	PHYDM_IQK,
+	PHYDM_NHM,
+	PHYDM_CLM,
+	PHYDM_BB_INFO,
+	PHYDM_TXBF,
+	PHYDM_PAUSE_DIG_EN,
+	PHYDM_H2C,
+	PHYDM_ANT_SWITCH,
+	PHYDM_DYNAMIC_RA_PATH,
+	PHYDM_PSD,
+	PHYDM_DEBUG_PORT
+};
+
+static struct phydm_command phy_dm_ary[] = {
+	{"-h", PHYDM_HELP}, /*do not move this element to other position*/
+	{"demo", PHYDM_DEMO}, /*do not move this element to other position*/
+	{"ra", PHYDM_RA},
+	{"profile", PHYDM_PROFILE},
+	{"antdiv", PHYDM_ANTDIV},
+	{"pathdiv", PHYDM_PATHDIV},
+	{"dbg", PHYDM_DEBUG},
+	{"fw_dbg", PHYDM_FW_DEBUG},
+	{"ability", PHYDM_SUPPORT_ABILITY},
+	{"get_txagc", PHYDM_GET_TXAGC},
+	{"set_txagc", PHYDM_SET_TXAGC},
+	{"smtant", PHYDM_SMART_ANT},
+	{"api", PHYDM_API},
+	{"trxpath", PHYDM_TRX_PATH},
+	{"lamode", PHYDM_LA_MODE},
+	{"dumpreg", PHYDM_DUMP_REG},
+	{"mu", PHYDM_MU_MIMO},
+	{"hang", PHYDM_HANG},
+	{"bigjump", PHYDM_BIG_JUMP},
+	{"rxrate", PHYDM_SHOW_RXRATE},
+	{"nbi", PHYDM_NBI_EN},
+	{"csi_mask", PHYDM_CSI_MASK_EN},
+	{"dfs", PHYDM_DFS},
+	{"iqk", PHYDM_IQK},
+	{"nhm", PHYDM_NHM},
+	{"clm", PHYDM_CLM},
+	{"bbinfo", PHYDM_BB_INFO},
+	{"txbf", PHYDM_TXBF},
+	{"pause_dig", PHYDM_PAUSE_DIG_EN},
+	{"h2c", PHYDM_H2C},
+	{"ant_switch", PHYDM_ANT_SWITCH},
+	{"drp", PHYDM_DYNAMIC_RA_PATH},
+	{"psd", PHYDM_PSD},
+	{"dbgport", PHYDM_DEBUG_PORT},
+};
+
+void phydm_cmd_parser(struct phy_dm_struct *dm, char input[][MAX_ARGV],
+		      u32 input_num, u8 flag, char *output, u32 out_len)
+{
+	u32 used = 0;
+	u8 id = 0;
+	int var1[10] = {0};
+	int i, input_idx = 0, phydm_ary_size;
+	char help[] = "-h";
+
+	bool is_enable_dbg_mode;
+	u8 central_ch, primary_ch_idx, bandwidth;
+
+	if (flag == 0) {
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "GET, nothing to print\n");
+		return;
+	}
+
+	PHYDM_SNPRINTF(output + used, out_len - used, "\n");
+
+	/* Parsing Cmd ID */
+	if (input_num) {
+		phydm_ary_size =
+			sizeof(phy_dm_ary) / sizeof(struct phydm_command);
+		for (i = 0; i < phydm_ary_size; i++) {
+			if (strcmp(phy_dm_ary[i].name, input[0]) == 0) {
+				id = phy_dm_ary[i].id;
+				break;
+			}
+		}
+		if (i == phydm_ary_size) {
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "SET, command not found!\n");
+			return;
+		}
+	}
+
+	switch (id) {
+	case PHYDM_HELP: {
+		PHYDM_SNPRINTF(output + used, out_len - used, "BB cmd ==>\n");
+		for (i = 0; i < phydm_ary_size - 2; i++) {
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "  %-5d: %s\n", i,
+				       phy_dm_ary[i + 2].name);
+			/**/
+		}
+	} break;
+
+	case PHYDM_DEMO: { /*echo demo 10 0x3a z abcde >cmd*/
+		u32 directory = 0;
+
+		char char_temp;
+
+		PHYDM_SSCANF(input[1], DCMD_DECIMAL, &directory);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "Decimal value = %d\n", directory);
+		PHYDM_SSCANF(input[2], DCMD_HEX, &directory);
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "Hex value = 0x%x\n", directory);
+		PHYDM_SSCANF(input[3], DCMD_CHAR, &char_temp);
+		PHYDM_SNPRINTF(output + used, out_len - used, "Char = %c\n",
+			       char_temp);
+		PHYDM_SNPRINTF(output + used, out_len - used, "String = %s\n",
+			       input[4]);
+	} break;
+
+	case PHYDM_RA:
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL,
+					     &var1[i]);
+
+				input_idx++;
+			}
+		}
+
+		if (input_idx >= 1) {
+			phydm_RA_debug_PCR(dm, (u32 *)var1, &used, output,
+					   &out_len);
+		}
+
+		break;
+
+	case PHYDM_ANTDIV:
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_HEX, &var1[i]);
+
+				input_idx++;
+			}
+		}
+
+		break;
+
+	case PHYDM_PATHDIV:
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_HEX, &var1[i]);
+
+				input_idx++;
+			}
+		}
+
+		break;
+
+	case PHYDM_DEBUG:
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL,
+					     &var1[i]);
+
+				input_idx++;
+			}
+		}
+
+		if (input_idx >= 1) {
+			phydm_debug_trace(dm, (u32 *)var1, &used, output,
+					  &out_len);
+		}
+
+		break;
+
+	case PHYDM_FW_DEBUG:
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL,
+					     &var1[i]);
+				input_idx++;
+			}
+		}
+
+		if (input_idx >= 1)
+			phydm_fw_debug_trace(dm, (u32 *)var1, &used, output,
+					     &out_len);
+
+		break;
+
+	case PHYDM_SUPPORT_ABILITY:
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL,
+					     &var1[i]);
+
+				input_idx++;
+			}
+		}
+
+		if (input_idx >= 1) {
+			phydm_support_ability_debug(dm, (u32 *)var1, &used,
+						    output, &out_len);
+		}
+
+		break;
+
+	case PHYDM_SMART_ANT:
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_HEX, &var1[i]);
+				input_idx++;
+			}
+		}
+
+		break;
+
+	case PHYDM_API:
+		if (!(dm->support_ic_type &
+		      (ODM_RTL8822B | ODM_RTL8197F | ODM_RTL8821C))) {
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"This IC doesn't support PHYDM API function\n");
+		}
+
+		for (i = 0; i < 4; i++) {
+			if (input[i + 1])
+				PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL,
+					     &var1[i]);
+		}
+
+		is_enable_dbg_mode = (bool)var1[0];
+		central_ch = (u8)var1[1];
+		primary_ch_idx = (u8)var1[2];
+		bandwidth = (enum odm_bw)var1[3];
+
+		if (is_enable_dbg_mode) {
+			dm->is_disable_phy_api = false;
+			phydm_api_switch_bw_channel(dm, central_ch,
+						    primary_ch_idx,
+						    (enum odm_bw)bandwidth);
+			dm->is_disable_phy_api = true;
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"central_ch = %d, primary_ch_idx = %d, bandwidth = %d\n",
+				central_ch, primary_ch_idx, bandwidth);
+		} else {
+			dm->is_disable_phy_api = false;
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "Disable API debug mode\n");
+		}
+		break;
+
+	case PHYDM_PROFILE: /*echo profile, >cmd*/
+		phydm_basic_profile(dm, &used, output, &out_len);
+		break;
+
+	case PHYDM_GET_TXAGC:
+		phydm_get_txagc(dm, &used, output, &out_len);
+		break;
+
+	case PHYDM_SET_TXAGC: {
+		bool is_enable_dbg_mode;
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_HEX, &var1[i]);
+				input_idx++;
+			}
+		}
+
+		if ((strcmp(input[1], help) == 0)) {
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"{En} {pathA~D(0~3)} {rate_idx(Hex), All_rate:0xff} {txagc_idx (Hex)}\n");
+			/**/
+
+		} else {
+			is_enable_dbg_mode = (bool)var1[0];
+			if (is_enable_dbg_mode) {
+				dm->is_disable_phy_api = false;
+				phydm_set_txagc(dm, (u32 *)var1, &used, output,
+						&out_len);
+				dm->is_disable_phy_api = true;
+			} else {
+				dm->is_disable_phy_api = false;
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "Disable API debug mode\n");
+			}
+		}
+	} break;
+
+	case PHYDM_TRX_PATH:
+
+		for (i = 0; i < 4; i++) {
+			if (input[i + 1])
+				PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL,
+					     &var1[i]);
+		}
+		if (dm->support_ic_type & (ODM_RTL8822B | ODM_RTL8197F)) {
+			u8 tx_path, rx_path;
+			bool is_enable_dbg_mode, is_tx2_path;
+
+			is_enable_dbg_mode = (bool)var1[0];
+			tx_path = (u8)var1[1];
+			rx_path = (u8)var1[2];
+			is_tx2_path = (bool)var1[3];
+
+			if (is_enable_dbg_mode) {
+				dm->is_disable_phy_api = false;
+				phydm_api_trx_mode(
+					dm, (enum odm_rf_path)tx_path,
+					(enum odm_rf_path)rx_path, is_tx2_path);
+				dm->is_disable_phy_api = true;
+				PHYDM_SNPRINTF(
+					output + used, out_len - used,
+					"tx_path = 0x%x, rx_path = 0x%x, is_tx2_path = %d\n",
+					tx_path, rx_path, is_tx2_path);
+			} else {
+				dm->is_disable_phy_api = false;
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "Disable API debug mode\n");
+			}
+		} else {
+			phydm_config_trx_path(dm, (u32 *)var1, &used, output,
+					      &out_len);
+		}
+		break;
+
+	case PHYDM_LA_MODE:
+
+		dm->support_ability &= ~(ODM_BB_FA_CNT);
+		phydm_lamode_trigger_setting(dm, &input[0], &used, output,
+					     &out_len, input_num);
+		dm->support_ability |= ODM_BB_FA_CNT;
+
+		break;
+
+	case PHYDM_DUMP_REG: {
+		u8 type = 0;
+
+		if (input[1]) {
+			PHYDM_SSCANF(input[1], DCMD_DECIMAL, &var1[0]);
+			type = (u8)var1[0];
+		}
+
+		if (type == 0)
+			phydm_dump_bb_reg(dm, &used, output, &out_len);
+		else if (type == 1)
+			phydm_dump_all_reg(dm, &used, output, &out_len);
+	} break;
+
+	case PHYDM_MU_MIMO:
+
+		if (input[1])
+			PHYDM_SSCANF(input[1], DCMD_DECIMAL, &var1[0]);
+		else
+			var1[0] = 0;
+
+		if (var1[0] == 1) {
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "Get MU BFee CSI\n");
+			odm_set_bb_reg(dm, 0x9e8, BIT(17) | BIT(16),
+				       2); /*Read BFee*/
+			odm_set_bb_reg(dm, 0x1910, BIT(15),
+				       1); /*Select BFee's CSI report*/
+			odm_set_bb_reg(dm, 0x19b8, BIT(6),
+				       1); /*set as CSI report*/
+			odm_set_bb_reg(dm, 0x19a8, 0xFFFF,
+				       0xFFFF); /*disable gated_clk*/
+			phydm_print_csi(dm, used, out_len, output);
+
+		} else if (var1[0] == 2) {
+			PHYDM_SSCANF(input[2], DCMD_DECIMAL, &var1[1]);
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "Get MU BFer's STA%d CSI\n", var1[1]);
+			odm_set_bb_reg(dm, 0x9e8, BIT(24), 0); /*Read BFer*/
+			odm_set_bb_reg(dm, 0x9e8, BIT(25),
+				       1); /*enable Read/Write RAM*/
+			odm_set_bb_reg(dm, 0x9e8, BIT(30) | BIT(29) | BIT(28),
+				       var1[1]); /*read which STA's CSI report*/
+			odm_set_bb_reg(dm, 0x1910, BIT(15),
+				       0); /*select BFer's CSI*/
+			odm_set_bb_reg(dm, 0x19e0, 0x00003FC0,
+				       0xFF); /*disable gated_clk*/
+			phydm_print_csi(dm, used, out_len, output);
+		}
+		break;
+
+	case PHYDM_BIG_JUMP: {
+		if (input[1]) {
+			PHYDM_SSCANF(input[1], DCMD_DECIMAL, &var1[0]);
+			phydm_enable_big_jump(dm, (bool)(var1[0]));
+		} else {
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "unknown command!\n");
+		}
+		break;
+	}
+
+	case PHYDM_HANG:
+		phydm_bb_rx_hang_info(dm, &used, output, &out_len);
+		break;
+
+	case PHYDM_SHOW_RXRATE: {
+		u8 rate_idx;
+
+		if (input[1])
+			PHYDM_SSCANF(input[1], DCMD_DECIMAL, &var1[0]);
+
+		if (var1[0] == 1) {
+			phydm_show_rx_rate(dm, &used, output, &out_len);
+		} else {
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "Reset Rx rate counter\n");
+
+			for (rate_idx = 0; rate_idx < 40; rate_idx++) {
+				dm->phy_dbg_info.num_qry_vht_pkt[rate_idx] = 0;
+				dm->phy_dbg_info.num_qry_mu_vht_pkt[rate_idx] =
+					0;
+			}
+		}
+	} break;
+
+	case PHYDM_NBI_EN:
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL,
+					     &var1[i]);
+				input_idx++;
+			}
+		}
+
+		if (input_idx >= 1) {
+			phydm_api_debug(dm, PHYDM_API_NBI, (u32 *)var1, &used,
+					output, &out_len);
+			/**/
+		}
+
+		break;
+
+	case PHYDM_CSI_MASK_EN:
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL,
+					     &var1[i]);
+				input_idx++;
+			}
+		}
+
+		if (input_idx >= 1) {
+			phydm_api_debug(dm, PHYDM_API_CSI_MASK, (u32 *)var1,
+					&used, output, &out_len);
+			/**/
+		}
+
+		break;
+
+	case PHYDM_DFS:
+		break;
+
+	case PHYDM_IQK:
+		break;
+
+	case PHYDM_NHM: {
+		u8 target_rssi;
+		u16 nhm_period = 0xC350; /* 200ms */
+		u8 IGI;
+		struct ccx_info *ccx_info = &dm->dm_ccx_info;
+
+		PHYDM_SSCANF(input[1], DCMD_DECIMAL, &var1[0]);
+
+		if (input_num == 1) {
+			ccx_info->echo_NHM_en = false;
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r\n Trigger NHM: echo nhm 1\n");
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r (Exclude CCA)\n");
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r Trigger NHM: echo nhm 2\n");
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r (Include CCA)\n");
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r Get NHM results: echo nhm 3\n");
+
+			return;
+		}
+
+		/* NMH trigger */
+		if ((var1[0] <= 2) && (var1[0] != 0)) {
+			ccx_info->echo_NHM_en = true;
+			ccx_info->echo_IGI =
+				(u8)odm_get_bb_reg(dm, 0xC50, MASKBYTE0);
+
+			target_rssi = ccx_info->echo_IGI - 10;
+
+			ccx_info->NHM_th[0] = (target_rssi - 15 + 10) * 2;
+
+			for (i = 1; i <= 10; i++)
+				ccx_info->NHM_th[i] =
+					ccx_info->NHM_th[0] + 6 * i;
+
+			/* 4 1. store previous NHM setting */
+			phydm_nhm_setting(dm, STORE_NHM_SETTING);
+
+			/* 4 2. Set NHM period, 0x990[31:16]=0xC350,
+			 * Time duration for NHM unit: 4us, 0xC350=200ms
+			 */
+			ccx_info->NHM_period = nhm_period;
+
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r\n Monitor NHM for %d us",
+				       nhm_period * 4);
+
+			/* 4 3. Set NHM inexclude_txon, inexclude_cca, ccx_en */
+
+			ccx_info->nhm_inexclude_cca = (var1[0] == 1) ?
+							      NHM_EXCLUDE_CCA :
+							      NHM_INCLUDE_CCA;
+			ccx_info->nhm_inexclude_txon = NHM_EXCLUDE_TXON;
+
+			phydm_nhm_setting(dm, SET_NHM_SETTING);
+			phydm_print_nhm_trigger(output, used, out_len,
+						ccx_info);
+
+			/* 4 4. Trigger NHM */
+			phydm_nhm_trigger(dm);
+		}
+
+		/*Get NHM results*/
+		else if (var1[0] == 3) {
+			IGI = (u8)odm_get_bb_reg(dm, 0xC50, MASKBYTE0);
+
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r\n Cur_IGI = 0x%x", IGI);
+
+			phydm_get_nhm_result(dm);
+
+			/* 4 Resotre NHM setting */
+			phydm_nhm_setting(dm, RESTORE_NHM_SETTING);
+			phydm_print_nhm_result(output, used, out_len, ccx_info);
+
+			ccx_info->echo_NHM_en = false;
+		} else {
+			ccx_info->echo_NHM_en = false;
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r\n Trigger NHM: echo nhm 1\n");
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r (Exclude CCA)\n");
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r Trigger NHM: echo nhm 2\n");
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r (Include CCA)\n");
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r Get NHM results: echo nhm 3\n");
+
+			return;
+		}
+	} break;
+
+	case PHYDM_CLM: {
+		struct ccx_info *ccx_info = &dm->dm_ccx_info;
+
+		PHYDM_SSCANF(input[1], DCMD_DECIMAL, &var1[0]);
+
+		if (input_num == 1) {
+			ccx_info->echo_CLM_en = false;
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r\n Trigger CLM: echo clm 1\n");
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r Get CLM results: echo clm 2\n");
+			return;
+		}
+
+		/* Set & trigger CLM */
+		if (var1[0] == 1) {
+			ccx_info->echo_CLM_en = true;
+			ccx_info->CLM_period = 0xC350; /*100ms*/
+			phydm_clm_setting(dm);
+			phydm_clm_trigger(dm);
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r\n Monitor CLM for 200ms\n");
+		}
+
+		/* Get CLM results */
+		else if (var1[0] == 2) {
+			ccx_info->echo_CLM_en = false;
+			phydm_get_cl_mresult(dm);
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r\n CLM_result = %d us\n",
+				       ccx_info->CLM_result * 4);
+
+		} else {
+			ccx_info->echo_CLM_en = false;
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\n\r Error command !\n");
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r Trigger CLM: echo clm 1\n");
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "\r Get CLM results: echo clm 2\n");
+		}
+	} break;
+
+	case PHYDM_BB_INFO: {
+		s32 value32 = 0;
+
+		phydm_bb_debug_info(dm, &used, output, &out_len);
+
+		if (dm->support_ic_type & ODM_RTL8822B && input[1]) {
+			PHYDM_SSCANF(input[1], DCMD_DECIMAL, &var1[0]);
+			odm_set_bb_reg(dm, 0x1988, 0x003fff00, var1[0]);
+			value32 = odm_get_bb_reg(dm, 0xf84, MASKDWORD);
+			value32 = (value32 & 0xff000000) >> 24;
+			PHYDM_SNPRINTF(
+				output + used, out_len - used,
+				"\r\n %-35s = condition num = %d, subcarriers = %d\n",
+				"Over condition num subcarrier", var1[0],
+				value32);
+			odm_set_bb_reg(dm, 0x1988, BIT(22),
+				       0x0); /*disable report condition number*/
+		}
+	} break;
+
+	case PHYDM_TXBF: {
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "\r\n no TxBF !!\n");
+	} break;
+
+	case PHYDM_PAUSE_DIG_EN:
+
+		for (i = 0; i < 5; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_HEX, &var1[i]);
+				input_idx++;
+			}
+		}
+
+		if (input_idx >= 1) {
+			if (var1[0] == 0) {
+				odm_pause_dig(dm, PHYDM_PAUSE,
+					      PHYDM_PAUSE_LEVEL_7, (u8)var1[1]);
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "Set IGI_value = ((%x))\n",
+					       var1[1]);
+			} else if (var1[0] == 1) {
+				odm_pause_dig(dm, PHYDM_RESUME,
+					      PHYDM_PAUSE_LEVEL_7, (u8)var1[1]);
+				PHYDM_SNPRINTF(output + used, out_len - used,
+					       "Resume IGI_value\n");
+			} else {
+				PHYDM_SNPRINTF(
+					output + used, out_len - used,
+					"echo  (1:pause, 2resume)  (IGI_value)\n");
+			}
+		}
+		break;
+	case PHYDM_H2C:
+
+		for (i = 0; i < 8; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_HEX, &var1[i]);
+				input_idx++;
+			}
+		}
+
+		if (input_idx >= 1)
+			phydm_h2C_debug(dm, (u32 *)var1, &used, output,
+					&out_len);
+
+		break;
+
+	case PHYDM_ANT_SWITCH:
+
+		for (i = 0; i < 8; i++) {
+			if (input[i + 1]) {
+				PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL,
+					     &var1[i]);
+				input_idx++;
+			}
+		}
+
+		if (input_idx >= 1) {
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "Not Support IC");
+		}
+
+		break;
+
+	case PHYDM_DYNAMIC_RA_PATH:
+
+		PHYDM_SNPRINTF(output + used, out_len - used, "Not Support IC");
+
+		break;
+
+	case PHYDM_PSD:
+
+		phydm_psd_debug(dm, &input[0], &used, output, &out_len,
+				input_num);
+
+		break;
+
+	case PHYDM_DEBUG_PORT: {
+		u32 dbg_port_value;
+
+		PHYDM_SSCANF(input[1], DCMD_HEX, &var1[0]);
+
+		if (phydm_set_bb_dbg_port(dm, BB_DBGPORT_PRIORITY_3,
+					  var1[0])) { /*set debug port to 0x0*/
+
+			dbg_port_value = phydm_get_bb_dbg_port_value(dm);
+			phydm_release_bb_dbg_port(dm);
+
+			PHYDM_SNPRINTF(output + used, out_len - used,
+				       "Debug Port[0x%x] = ((0x%x))\n", var1[1],
+				       dbg_port_value);
+		}
+	} break;
+
+	default:
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "SET, unknown command!\n");
+		break;
+	}
+}
+
+s32 phydm_cmd(struct phy_dm_struct *dm, char *input, u32 in_len, u8 flag,
+	      char *output, u32 out_len)
+{
+	char *token;
+	u32 argc = 0;
+	char argv[MAX_ARGC][MAX_ARGV];
+
+	do {
+		token = strsep(&input, ", ");
+		if (token) {
+			strcpy(argv[argc], token);
+			argc++;
+		} else {
+			break;
+		}
+	} while (argc < MAX_ARGC);
+
+	if (argc == 1)
+		argv[0][strlen(argv[0]) - 1] = '\0';
+
+	phydm_cmd_parser(dm, argv, argc, flag, output, out_len);
+
+	return 0;
+}
+
+void phydm_fw_trace_handler(void *dm_void, u8 *cmd_buf, u8 cmd_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	/*u8	debug_trace_11byte[60];*/
+	u8 freg_num, c2h_seq, buf_0 = 0;
+
+	if (!(dm->support_ic_type & PHYDM_IC_3081_SERIES))
+		return;
+
+	if (cmd_len > 12)
+		return;
+
+	buf_0 = cmd_buf[0];
+	freg_num = (buf_0 & 0xf);
+	c2h_seq = (buf_0 & 0xf0) >> 4;
+
+	if ((c2h_seq != dm->pre_c2h_seq) && !dm->fw_buff_is_enpty) {
+		dm->fw_debug_trace[dm->c2h_cmd_start] = '\0';
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE,
+			     "[FW Dbg Queue Overflow] %s\n",
+			     dm->fw_debug_trace);
+		dm->c2h_cmd_start = 0;
+	}
+
+	if ((cmd_len - 1) > (60 - dm->c2h_cmd_start)) {
+		dm->fw_debug_trace[dm->c2h_cmd_start] = '\0';
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE,
+			     "[FW Dbg Queue error: wrong C2H length] %s\n",
+			     dm->fw_debug_trace);
+		dm->c2h_cmd_start = 0;
+		return;
+	}
+
+	strncpy((char *)&dm->fw_debug_trace[dm->c2h_cmd_start],
+		(char *)&cmd_buf[1], (cmd_len - 1));
+	dm->c2h_cmd_start += (cmd_len - 1);
+	dm->fw_buff_is_enpty = false;
+
+	if (freg_num == 0 || dm->c2h_cmd_start >= 60) {
+		if (dm->c2h_cmd_start < 60)
+			dm->fw_debug_trace[dm->c2h_cmd_start] = '\0';
+		else
+			dm->fw_debug_trace[59] = '\0';
+
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "[FW DBG Msg] %s\n",
+			     dm->fw_debug_trace);
+		/*dbg_print("[FW DBG Msg] %s\n", dm->fw_debug_trace);*/
+		dm->c2h_cmd_start = 0;
+		dm->fw_buff_is_enpty = true;
+	}
+
+	dm->pre_c2h_seq = c2h_seq;
+}
+
+void phydm_fw_trace_handler_code(void *dm_void, u8 *buffer, u8 cmd_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 function = buffer[0];
+	u8 dbg_num = buffer[1];
+	u16 content_0 = (((u16)buffer[3]) << 8) | ((u16)buffer[2]);
+	u16 content_1 = (((u16)buffer[5]) << 8) | ((u16)buffer[4]);
+	u16 content_2 = (((u16)buffer[7]) << 8) | ((u16)buffer[6]);
+	u16 content_3 = (((u16)buffer[9]) << 8) | ((u16)buffer[8]);
+	u16 content_4 = (((u16)buffer[11]) << 8) | ((u16)buffer[10]);
+
+	if (cmd_len > 12)
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE,
+			     "[FW Msg] Invalid cmd length (( %d )) >12\n",
+			     cmd_len);
+
+	/*--------------------------------------------*/
+	ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE,
+		     "[FW][general][%d, %d, %d] = {%d, %d, %d, %d}\n", function,
+		     dbg_num, content_0, content_1, content_2, content_3,
+		     content_4);
+	/*--------------------------------------------*/
+}
+
+void phydm_fw_trace_handler_8051(void *dm_void, u8 *buffer, u8 cmd_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	int i = 0;
+	u8 extend_c2h_sub_id = 0, extend_c2h_dbg_len = 0,
+	   extend_c2h_dbg_seq = 0;
+	u8 fw_debug_trace[128];
+	u8 *extend_c2h_dbg_content = NULL;
+
+	if (cmd_len > 127)
+		return;
+
+	extend_c2h_sub_id = buffer[0];
+	extend_c2h_dbg_len = buffer[1];
+	extend_c2h_dbg_content = buffer + 2; /*DbgSeq+DbgContent  for show HEX*/
+
+go_backfor_aggre_dbg_pkt:
+	i = 0;
+	extend_c2h_dbg_seq = buffer[2];
+	extend_c2h_dbg_content = buffer + 3;
+
+	for (;; i++) {
+		fw_debug_trace[i] = extend_c2h_dbg_content[i];
+		if (extend_c2h_dbg_content[i + 1] == '\0') {
+			fw_debug_trace[i + 1] = '\0';
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "[FW DBG Msg] %s",
+				     &fw_debug_trace[0]);
+			break;
+		} else if (extend_c2h_dbg_content[i] == '\n') {
+			fw_debug_trace[i + 1] = '\0';
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "[FW DBG Msg] %s",
+				     &fw_debug_trace[0]);
+			buffer = extend_c2h_dbg_content + i + 3;
+			goto go_backfor_aggre_dbg_pkt;
+		}
+	}
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_debug.h b/drivers/staging/rtlwifi/phydm/phydm_debug.h
new file mode 100644
index 000000000000..f442f7c19595
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_debug.h
@@ -0,0 +1,175 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __ODM_DBG_H__
+#define __ODM_DBG_H__
+
+/*#define DEBUG_VERSION	"1.1"*/ /*2015.07.29 YuChen*/
+/*#define DEBUG_VERSION	"1.2"*/ /*2015.08.28 Dino*/
+#define DEBUG_VERSION "1.3" /*2016.04.28 YuChen*/
+#define ODM_DBG_TRACE 5
+
+/*FW DBG MSG*/
+#define RATE_DECISION BIT(0)
+#define INIT_RA_TABLE BIT(1)
+#define RATE_UP BIT(2)
+#define RATE_DOWN BIT(3)
+#define TRY_DONE BIT(4)
+#define RA_H2C BIT(5)
+#define F_RATE_AP_RPT BIT(7)
+
+/* -----------------------------------------------------------------------------
+ * Define the tracing components
+ *
+ * -----------------------------------------------------------------------------
+ */
+/*BB FW Functions*/
+#define PHYDM_FW_COMP_RA BIT(0)
+#define PHYDM_FW_COMP_MU BIT(1)
+#define PHYDM_FW_COMP_PATH_DIV BIT(2)
+#define PHYDM_FW_COMP_PHY_CONFIG BIT(3)
+
+/*BB Driver Functions*/
+#define ODM_COMP_DIG BIT(0)
+#define ODM_COMP_RA_MASK BIT(1)
+#define ODM_COMP_DYNAMIC_TXPWR BIT(2)
+#define ODM_COMP_FA_CNT BIT(3)
+#define ODM_COMP_RSSI_MONITOR BIT(4)
+#define ODM_COMP_SNIFFER BIT(5)
+#define ODM_COMP_ANT_DIV BIT(6)
+#define ODM_COMP_DFS BIT(7)
+#define ODM_COMP_NOISY_DETECT BIT(8)
+#define ODM_COMP_RATE_ADAPTIVE BIT(9)
+#define ODM_COMP_PATH_DIV BIT(10)
+#define ODM_COMP_CCX BIT(11)
+
+#define ODM_COMP_DYNAMIC_PRICCA BIT(12)
+/*BIT13 TBD*/
+#define ODM_COMP_MP BIT(14)
+#define ODM_COMP_CFO_TRACKING BIT(15)
+#define ODM_COMP_ACS BIT(16)
+#define PHYDM_COMP_ADAPTIVITY BIT(17)
+#define PHYDM_COMP_RA_DBG BIT(18)
+#define PHYDM_COMP_TXBF BIT(19)
+/* MAC Functions */
+#define ODM_COMP_EDCA_TURBO BIT(20)
+#define ODM_COMP_DYNAMIC_RX_PATH BIT(21)
+#define ODM_FW_DEBUG_TRACE BIT(22)
+/* RF Functions */
+/*BIT23 TBD*/
+#define ODM_COMP_TX_PWR_TRACK BIT(24)
+/*BIT25 TBD*/
+#define ODM_COMP_CALIBRATION BIT(26)
+/* Common Functions */
+/*BIT27 TBD*/
+#define ODM_PHY_CONFIG BIT(28)
+#define ODM_COMP_INIT BIT(29)
+#define ODM_COMP_COMMON BIT(30)
+#define ODM_COMP_API BIT(31)
+
+#define ODM_COMP_UNCOND 0xFFFFFFFF
+
+/*------------------------Export Marco Definition---------------------------*/
+
+#define config_phydm_read_txagc_check(data) (data != INVALID_TXAGC_DATA)
+
+#define ODM_RT_TRACE(dm, comp, fmt, ...)                                       \
+	do {                                                                   \
+		if (((comp) & dm->debug_components) ||                         \
+		    ((comp) == ODM_COMP_UNCOND))                               \
+			RT_TRACE(dm->adapter, COMP_PHYDM, DBG_DMESG, fmt,      \
+				 ##__VA_ARGS__);                               \
+	} while (0)
+
+#define BB_DBGPORT_PRIORITY_3 3 /*Debug function (the highest priority)*/
+#define BB_DBGPORT_PRIORITY_2 2 /*Check hang function & Strong function*/
+#define BB_DBGPORT_PRIORITY_1 1 /*Watch dog function*/
+#define BB_DBGPORT_RELEASE 0 /*Init value (the lowest priority)*/
+
+void phydm_init_debug_setting(struct phy_dm_struct *dm);
+
+u8 phydm_set_bb_dbg_port(void *dm_void, u8 curr_dbg_priority, u32 debug_port);
+
+void phydm_release_bb_dbg_port(void *dm_void);
+
+u32 phydm_get_bb_dbg_port_value(void *dm_void);
+
+void phydm_basic_dbg_message(void *dm_void);
+
+#define PHYDM_DBGPRINT 0
+#define MAX_ARGC 20
+#define MAX_ARGV 16
+#define DCMD_DECIMAL "%d"
+#define DCMD_CHAR "%c"
+#define DCMD_HEX "%x"
+
+#define PHYDM_SSCANF(x, y, z)                                                  \
+	do {                                                                   \
+		if (sscanf(x, y, z) != 1)                                      \
+			ODM_RT_TRACE(dm, ODM_COMP_UNCOND,                      \
+				     "%s:%d sscanf fail!", __func__,           \
+				     __LINE__);                                \
+	} while (0)
+
+#define PHYDM_VAST_INFO_SNPRINTF(msg, ...)                                     \
+	do {                                                                   \
+		snprintf(msg, ##__VA_ARGS__);                                  \
+		ODM_RT_TRACE(dm, ODM_COMP_UNCOND, output);                     \
+	} while (0)
+
+#if (PHYDM_DBGPRINT == 1)
+#define PHYDM_SNPRINTF(msg, ...)                                               \
+	do {                                                                   \
+		snprintf(msg, ##__VA_ARGS__);                                  \
+		ODM_RT_TRACE(dm, ODM_COMP_UNCOND, output);                     \
+	} while (0)
+#else
+#define PHYDM_SNPRINTF(msg, ...)                                               \
+	do {                                                                   \
+		if (out_len > used)                                            \
+			used += snprintf(msg, ##__VA_ARGS__);                  \
+	} while (0)
+#endif
+
+void phydm_basic_profile(void *dm_void, u32 *_used, char *output,
+			 u32 *_out_len);
+s32 phydm_cmd(struct phy_dm_struct *dm, char *input, u32 in_len, u8 flag,
+	      char *output, u32 out_len);
+void phydm_cmd_parser(struct phy_dm_struct *dm, char input[][16], u32 input_num,
+		      u8 flag, char *output, u32 out_len);
+
+bool phydm_api_trx_mode(struct phy_dm_struct *dm, enum odm_rf_path tx_path,
+			enum odm_rf_path rx_path, bool is_tx2_path);
+
+void phydm_fw_trace_en_h2c(void *dm_void, bool enable, u32 fw_debug_component,
+			   u32 monitor_mode, u32 macid);
+
+void phydm_fw_trace_handler(void *dm_void, u8 *cmd_buf, u8 cmd_len);
+
+void phydm_fw_trace_handler_code(void *dm_void, u8 *buffer, u8 cmd_len);
+
+void phydm_fw_trace_handler_8051(void *dm_void, u8 *cmd_buf, u8 cmd_len);
+
+#endif /* __ODM_DBG_H__ */
diff --git a/drivers/staging/rtlwifi/phydm/phydm_dfs.h b/drivers/staging/rtlwifi/phydm/phydm_dfs.h
new file mode 100644
index 000000000000..59a1d08cf381
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_dfs.h
@@ -0,0 +1,59 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDM_DFS_H__
+#define __PHYDM_DFS_H__
+
+#define DFS_VERSION "0.0"
+
+/* ============================================================
+ *  Definition
+ * ============================================================
+ */
+
+/* ============================================================
+ * 1  structure
+ * ============================================================
+ */
+
+/* ============================================================
+ *  enumeration
+ * ============================================================
+ */
+
+enum phydm_dfs_region_domain {
+	PHYDM_DFS_DOMAIN_UNKNOWN = 0,
+	PHYDM_DFS_DOMAIN_FCC = 1,
+	PHYDM_DFS_DOMAIN_MKK = 2,
+	PHYDM_DFS_DOMAIN_ETSI = 3,
+};
+
+/* ============================================================
+ *  function prototype
+ * ============================================================
+ */
+#define phydm_dfs_master_enabled(dm) false
+
+#endif /*#ifndef __PHYDM_DFS_H__ */
diff --git a/drivers/staging/rtlwifi/phydm/phydm_dig.c b/drivers/staging/rtlwifi/phydm/phydm_dig.c
new file mode 100644
index 000000000000..31a4f3fcad19
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_dig.c
@@ -0,0 +1,1535 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/* ************************************************************
+ * include files
+ * *************************************************************/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+static int get_igi_for_diff(int);
+
+static inline void phydm_check_ap_write_dig(struct phy_dm_struct *dm,
+					    u8 current_igi)
+{
+	switch (*dm->one_path_cca) {
+	case ODM_CCA_2R:
+		odm_set_bb_reg(dm, ODM_REG(IGI_A, dm), ODM_BIT(IGI, dm),
+			       current_igi);
+
+		if (dm->rf_type > ODM_1T1R)
+			odm_set_bb_reg(dm, ODM_REG(IGI_B, dm), ODM_BIT(IGI, dm),
+				       current_igi);
+		break;
+	case ODM_CCA_1R_A:
+		odm_set_bb_reg(dm, ODM_REG(IGI_A, dm), ODM_BIT(IGI, dm),
+			       current_igi);
+		if (dm->rf_type != ODM_1T1R)
+			odm_set_bb_reg(dm, ODM_REG(IGI_B, dm), ODM_BIT(IGI, dm),
+				       get_igi_for_diff(current_igi));
+		break;
+	case ODM_CCA_1R_B:
+		odm_set_bb_reg(dm, ODM_REG(IGI_B, dm), ODM_BIT(IGI, dm),
+			       get_igi_for_diff(current_igi));
+		if (dm->rf_type != ODM_1T1R)
+			odm_set_bb_reg(dm, ODM_REG(IGI_A, dm), ODM_BIT(IGI, dm),
+				       current_igi);
+		break;
+	}
+}
+
+static inline u8 phydm_get_current_igi(u8 dig_max_of_min, u8 rssi_min,
+				       u8 current_igi)
+{
+	if (rssi_min < dig_max_of_min) {
+		if (current_igi < rssi_min)
+			return rssi_min;
+	} else {
+		if (current_igi < dig_max_of_min)
+			return dig_max_of_min;
+	}
+	return current_igi;
+}
+
+void odm_change_dynamic_init_gain_thresh(void *dm_void, u32 dm_type,
+					 u32 dm_value)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+
+	if (dm_type == DIG_TYPE_THRESH_HIGH) {
+		dig_tab->rssi_high_thresh = dm_value;
+	} else if (dm_type == DIG_TYPE_THRESH_LOW) {
+		dig_tab->rssi_low_thresh = dm_value;
+	} else if (dm_type == DIG_TYPE_ENABLE) {
+		dig_tab->dig_enable_flag = true;
+	} else if (dm_type == DIG_TYPE_DISABLE) {
+		dig_tab->dig_enable_flag = false;
+	} else if (dm_type == DIG_TYPE_BACKOFF) {
+		if (dm_value > 30)
+			dm_value = 30;
+		dig_tab->backoff_val = (u8)dm_value;
+	} else if (dm_type == DIG_TYPE_RX_GAIN_MIN) {
+		if (dm_value == 0)
+			dm_value = 0x1;
+		dig_tab->rx_gain_range_min = (u8)dm_value;
+	} else if (dm_type == DIG_TYPE_RX_GAIN_MAX) {
+		if (dm_value > 0x50)
+			dm_value = 0x50;
+		dig_tab->rx_gain_range_max = (u8)dm_value;
+	}
+} /* dm_change_dynamic_init_gain_thresh */
+
+static int get_igi_for_diff(int value_IGI)
+{
+#define ONERCCA_LOW_TH 0x30
+#define ONERCCA_LOW_DIFF 8
+
+	if (value_IGI < ONERCCA_LOW_TH) {
+		if ((ONERCCA_LOW_TH - value_IGI) < ONERCCA_LOW_DIFF)
+			return ONERCCA_LOW_TH;
+		else
+			return value_IGI + ONERCCA_LOW_DIFF;
+	}
+
+	return value_IGI;
+}
+
+static void odm_fa_threshold_check(void *dm_void, bool is_dfs_band,
+				   bool is_performance, u32 rx_tp, u32 tx_tp,
+				   u32 *dm_FA_thres)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (dm->is_linked && (is_performance || is_dfs_band)) {
+		/*For NIC*/
+		dm_FA_thres[0] = DM_DIG_FA_TH0;
+		dm_FA_thres[1] = DM_DIG_FA_TH1;
+		dm_FA_thres[2] = DM_DIG_FA_TH2;
+	} else {
+		if (is_dfs_band) {
+			/* For DFS band and no link */
+			dm_FA_thres[0] = 250;
+			dm_FA_thres[1] = 1000;
+			dm_FA_thres[2] = 2000;
+		} else {
+			dm_FA_thres[0] = 2000;
+			dm_FA_thres[1] = 4000;
+			dm_FA_thres[2] = 5000;
+		}
+	}
+}
+
+static u8 odm_forbidden_igi_check(void *dm_void, u8 dig_dynamic_min,
+				  u8 current_igi)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+	struct false_alarm_stat *fa_cnt =
+		(struct false_alarm_stat *)phydm_get_structure(
+			dm, PHYDM_FALSEALMCNT);
+	u8 rx_gain_range_min = dig_tab->rx_gain_range_min;
+
+	if (dig_tab->large_fa_timeout) {
+		if (--dig_tab->large_fa_timeout == 0)
+			dig_tab->large_fa_hit = 0;
+	}
+
+	if (fa_cnt->cnt_all > 10000) {
+		ODM_RT_TRACE(dm, ODM_COMP_DIG,
+			     "%s(): Abnormally false alarm case.\n", __func__);
+
+		if (dig_tab->large_fa_hit != 3)
+			dig_tab->large_fa_hit++;
+
+		if (dig_tab->forbidden_igi < current_igi) {
+			dig_tab->forbidden_igi = current_igi;
+			dig_tab->large_fa_hit = 1;
+			dig_tab->large_fa_timeout = LARGE_FA_TIMEOUT;
+		}
+
+		if (dig_tab->large_fa_hit >= 3) {
+			if ((dig_tab->forbidden_igi + 2) >
+			    dig_tab->rx_gain_range_max)
+				rx_gain_range_min = dig_tab->rx_gain_range_max;
+			else
+				rx_gain_range_min =
+					(dig_tab->forbidden_igi + 2);
+			dig_tab->recover_cnt = 1800;
+			ODM_RT_TRACE(
+				dm, ODM_COMP_DIG,
+				"%s(): Abnormally false alarm case: recover_cnt = %d\n",
+				__func__, dig_tab->recover_cnt);
+		}
+	}
+
+	else if (fa_cnt->cnt_all > 2000) {
+		ODM_RT_TRACE(dm, ODM_COMP_DIG,
+			     "Abnormally false alarm case.\n");
+		ODM_RT_TRACE(
+			dm, ODM_COMP_DIG,
+			"cnt_all=%d, cnt_all_pre=%d, current_igi=0x%x, pre_ig_value=0x%x\n",
+			fa_cnt->cnt_all, fa_cnt->cnt_all_pre, current_igi,
+			dig_tab->pre_ig_value);
+
+		/* fa_cnt->cnt_all = 1.1875*fa_cnt->cnt_all_pre */
+		if ((fa_cnt->cnt_all >
+		     (fa_cnt->cnt_all_pre + (fa_cnt->cnt_all_pre >> 3) +
+		      (fa_cnt->cnt_all_pre >> 4))) &&
+		    (current_igi < dig_tab->pre_ig_value)) {
+			if (dig_tab->large_fa_hit != 3)
+				dig_tab->large_fa_hit++;
+
+			if (dig_tab->forbidden_igi < current_igi) {
+				ODM_RT_TRACE(
+					dm, ODM_COMP_DIG,
+					"Updating forbidden_igi by current_igi, forbidden_igi=0x%x, current_igi=0x%x\n",
+					dig_tab->forbidden_igi, current_igi);
+
+				dig_tab->forbidden_igi = current_igi;
+				dig_tab->large_fa_hit = 1;
+				dig_tab->large_fa_timeout = LARGE_FA_TIMEOUT;
+			}
+		}
+
+		if (dig_tab->large_fa_hit >= 3) {
+			ODM_RT_TRACE(
+				dm, ODM_COMP_DIG,
+				"FaHit is greater than 3, rx_gain_range_max=0x%x, rx_gain_range_min=0x%x, forbidden_igi=0x%x\n",
+				dig_tab->rx_gain_range_max, rx_gain_range_min,
+				dig_tab->forbidden_igi);
+
+			if ((dig_tab->forbidden_igi + 1) >
+			    dig_tab->rx_gain_range_max)
+				rx_gain_range_min = dig_tab->rx_gain_range_max;
+			else
+				rx_gain_range_min =
+					(dig_tab->forbidden_igi + 1);
+
+			dig_tab->recover_cnt = 1200;
+			ODM_RT_TRACE(
+				dm, ODM_COMP_DIG,
+				"Abnormally false alarm case: recover_cnt = %d,  rx_gain_range_min = 0x%x\n",
+				dig_tab->recover_cnt, rx_gain_range_min);
+		}
+	} else {
+		if (dig_tab->recover_cnt != 0) {
+			dig_tab->recover_cnt--;
+			ODM_RT_TRACE(dm, ODM_COMP_DIG,
+				     "%s(): Normal Case: recover_cnt = %d\n",
+				     __func__, dig_tab->recover_cnt);
+			return rx_gain_range_min;
+		}
+
+		if (dig_tab->large_fa_hit >= 3) {
+			dig_tab->large_fa_hit = 0;
+			return rx_gain_range_min;
+		}
+
+		if ((dig_tab->forbidden_igi - 2) <
+		    dig_dynamic_min) { /* DM_DIG_MIN) */
+			dig_tab->forbidden_igi =
+				dig_dynamic_min; /* DM_DIG_MIN; */
+			rx_gain_range_min = dig_dynamic_min; /* DM_DIG_MIN; */
+			ODM_RT_TRACE(dm, ODM_COMP_DIG,
+				     "%s(): Normal Case: At Lower Bound\n",
+				     __func__);
+		} else {
+			if (dig_tab->large_fa_hit == 0) {
+				dig_tab->forbidden_igi -= 2;
+				rx_gain_range_min =
+					(dig_tab->forbidden_igi + 2);
+				ODM_RT_TRACE(
+					dm, ODM_COMP_DIG,
+					"%s(): Normal Case: Approach Lower Bound\n",
+					__func__);
+			}
+		}
+	}
+
+	return rx_gain_range_min;
+}
+
+static void phydm_set_big_jump_step(void *dm_void, u8 current_igi)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+	u8 step1[8] = {24, 30, 40, 50, 60, 70, 80, 90};
+	u8 i;
+
+	if (dig_tab->enable_adjust_big_jump == 0)
+		return;
+
+	for (i = 0; i <= dig_tab->big_jump_step1; i++) {
+		if ((current_igi + step1[i]) >
+		    dig_tab->big_jump_lmt[dig_tab->agc_table_idx]) {
+			if (i != 0)
+				i = i - 1;
+			break;
+		} else if (i == dig_tab->big_jump_step1) {
+			break;
+		}
+	}
+	if (dm->support_ic_type & ODM_RTL8822B)
+		odm_set_bb_reg(dm, 0x8c8, 0xe, i);
+	else if (dm->support_ic_type & ODM_RTL8197F)
+		odm_set_bb_reg(dm, ODM_REG_BB_AGC_SET_2_11N, 0xe, i);
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG,
+		     "%s(): bigjump = %d (ori = 0x%x), LMT=0x%x\n", __func__, i,
+		     dig_tab->big_jump_step1,
+		     dig_tab->big_jump_lmt[dig_tab->agc_table_idx]);
+}
+
+void odm_write_dig(void *dm_void, u8 current_igi)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+
+	if (dig_tab->is_stop_dig) {
+		ODM_RT_TRACE(dm, ODM_COMP_DIG, "%s(): Stop Writing IGI\n",
+			     __func__);
+		return;
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG,
+		     "%s(): ODM_REG(IGI_A,dm)=0x%x, ODM_BIT(IGI,dm)=0x%x\n",
+		     __func__, ODM_REG(IGI_A, dm), ODM_BIT(IGI, dm));
+
+	/* 1 Check initial gain by upper bound */
+	if ((!dig_tab->is_psd_in_progress) && dm->is_linked) {
+		if (current_igi > dig_tab->rx_gain_range_max) {
+			ODM_RT_TRACE(
+				dm, ODM_COMP_DIG,
+				"%s(): current_igi(0x%02x) is larger than upper bound !!\n",
+				__func__, current_igi);
+			current_igi = dig_tab->rx_gain_range_max;
+		}
+		if (dm->support_ability & ODM_BB_ADAPTIVITY &&
+		    dm->adaptivity_flag) {
+			if (current_igi > dm->adaptivity_igi_upper)
+				current_igi = dm->adaptivity_igi_upper;
+
+			ODM_RT_TRACE(
+				dm, ODM_COMP_DIG,
+				"%s(): adaptivity case: Force upper bound to 0x%x !!!!!!\n",
+				__func__, current_igi);
+		}
+	}
+
+	if (dig_tab->cur_ig_value != current_igi) {
+		/* Modify big jump step for 8822B and 8197F */
+		if (dm->support_ic_type & (ODM_RTL8822B | ODM_RTL8197F))
+			phydm_set_big_jump_step(dm, current_igi);
+
+		/* Set IGI value of CCK for new CCK AGC */
+		if (dm->cck_new_agc) {
+			if (dm->support_ic_type & ODM_IC_PHY_STATUE_NEW_TYPE)
+				odm_set_bb_reg(dm, 0xa0c, 0x00003f00,
+					       (current_igi >> 1));
+		}
+
+		/*Add by YuChen for USB IO too slow issue*/
+		if ((dm->support_ability & ODM_BB_ADAPTIVITY) &&
+		    (current_igi > dig_tab->cur_ig_value)) {
+			dig_tab->cur_ig_value = current_igi;
+			phydm_adaptivity(dm);
+		}
+
+		/* 1 Set IGI value */
+		if (dm->support_platform & (ODM_WIN | ODM_CE)) {
+			odm_set_bb_reg(dm, ODM_REG(IGI_A, dm), ODM_BIT(IGI, dm),
+				       current_igi);
+
+			if (dm->rf_type > ODM_1T1R)
+				odm_set_bb_reg(dm, ODM_REG(IGI_B, dm),
+					       ODM_BIT(IGI, dm), current_igi);
+
+		} else if (dm->support_platform & (ODM_AP)) {
+			phydm_check_ap_write_dig(dm, current_igi);
+		}
+
+		dig_tab->cur_ig_value = current_igi;
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG, "%s(): current_igi(0x%02x).\n", __func__,
+		     current_igi);
+}
+
+void odm_pause_dig(void *dm_void, enum phydm_pause_type pause_type,
+		   enum phydm_pause_level pause_level, u8 igi_value)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+	s8 max_level;
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG, "%s()=========> level = %d\n", __func__,
+		     pause_level);
+
+	if ((dig_tab->pause_dig_level == 0) &&
+	    (!(dm->support_ability & ODM_BB_DIG) ||
+	     !(dm->support_ability & ODM_BB_FA_CNT))) {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_DIG,
+			"%s(): Return: support_ability DIG or FA is disabled !!\n",
+			__func__);
+		return;
+	}
+
+	if (pause_level > DM_DIG_MAX_PAUSE_TYPE) {
+		ODM_RT_TRACE(dm, ODM_COMP_DIG,
+			     "%s(): Return: Wrong pause level !!\n", __func__);
+		return;
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG,
+		     "%s(): pause level = 0x%x, Current value = 0x%x\n",
+		     __func__, dig_tab->pause_dig_level, igi_value);
+	ODM_RT_TRACE(
+		dm, ODM_COMP_DIG,
+		"%s(): pause value = 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+		__func__, dig_tab->pause_dig_value[7],
+		dig_tab->pause_dig_value[6], dig_tab->pause_dig_value[5],
+		dig_tab->pause_dig_value[4], dig_tab->pause_dig_value[3],
+		dig_tab->pause_dig_value[2], dig_tab->pause_dig_value[1],
+		dig_tab->pause_dig_value[0]);
+
+	switch (pause_type) {
+	/* Pause DIG */
+	case PHYDM_PAUSE: {
+		/* Disable DIG */
+		odm_cmn_info_update(dm, ODM_CMNINFO_ABILITY,
+				    dm->support_ability & (~ODM_BB_DIG));
+		ODM_RT_TRACE(dm, ODM_COMP_DIG, "%s(): Pause DIG !!\n",
+			     __func__);
+
+		/* Backup IGI value */
+		if (dig_tab->pause_dig_level == 0) {
+			dig_tab->igi_backup = dig_tab->cur_ig_value;
+			ODM_RT_TRACE(
+				dm, ODM_COMP_DIG,
+				"%s(): Backup IGI  = 0x%x, new IGI = 0x%x\n",
+				__func__, dig_tab->igi_backup, igi_value);
+		}
+
+		/* Record IGI value */
+		dig_tab->pause_dig_value[pause_level] = igi_value;
+
+		/* Update pause level */
+		dig_tab->pause_dig_level =
+			(dig_tab->pause_dig_level | BIT(pause_level));
+
+		/* Write new IGI value */
+		if (BIT(pause_level + 1) > dig_tab->pause_dig_level) {
+			odm_write_dig(dm, igi_value);
+			ODM_RT_TRACE(dm, ODM_COMP_DIG,
+				     "%s(): IGI of higher level = 0x%x\n",
+				     __func__, igi_value);
+		}
+		break;
+	}
+	/* Resume DIG */
+	case PHYDM_RESUME: {
+		/* check if the level is illegal or not */
+		if ((dig_tab->pause_dig_level & (BIT(pause_level))) != 0) {
+			dig_tab->pause_dig_level = dig_tab->pause_dig_level &
+						   (~(BIT(pause_level)));
+			dig_tab->pause_dig_value[pause_level] = 0;
+			ODM_RT_TRACE(dm, ODM_COMP_DIG, "%s(): Resume DIG !!\n",
+				     __func__);
+		} else {
+			ODM_RT_TRACE(dm, ODM_COMP_DIG,
+				     "%s(): Wrong resume level !!\n", __func__);
+			break;
+		}
+
+		/* Resume DIG */
+		if (dig_tab->pause_dig_level == 0) {
+			/* Write backup IGI value */
+			odm_write_dig(dm, dig_tab->igi_backup);
+			dig_tab->is_ignore_dig = true;
+			ODM_RT_TRACE(dm, ODM_COMP_DIG,
+				     "%s(): Write original IGI = 0x%x\n",
+				     __func__, dig_tab->igi_backup);
+
+			/* Enable DIG */
+			odm_cmn_info_update(dm, ODM_CMNINFO_ABILITY,
+					    dm->support_ability | ODM_BB_DIG);
+			break;
+		}
+
+		if (BIT(pause_level) <= dig_tab->pause_dig_level)
+			break;
+
+		/* Calculate the maximum level now */
+		for (max_level = (pause_level - 1); max_level >= 0;
+		     max_level--) {
+			if ((dig_tab->pause_dig_level & BIT(max_level)) > 0)
+				break;
+		}
+
+		/* write IGI of lower level */
+		odm_write_dig(dm, dig_tab->pause_dig_value[max_level]);
+		ODM_RT_TRACE(dm, ODM_COMP_DIG,
+			     "%s(): Write IGI (0x%x) of level (%d)\n", __func__,
+			     dig_tab->pause_dig_value[max_level], max_level);
+		break;
+	}
+	default:
+		ODM_RT_TRACE(dm, ODM_COMP_DIG, "%s(): Wrong  type !!\n",
+			     __func__);
+		break;
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG,
+		     "%s(): pause level = 0x%x, Current value = 0x%x\n",
+		     __func__, dig_tab->pause_dig_level, igi_value);
+	ODM_RT_TRACE(
+		dm, ODM_COMP_DIG,
+		"%s(): pause value = 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+		__func__, dig_tab->pause_dig_value[7],
+		dig_tab->pause_dig_value[6], dig_tab->pause_dig_value[5],
+		dig_tab->pause_dig_value[4], dig_tab->pause_dig_value[3],
+		dig_tab->pause_dig_value[2], dig_tab->pause_dig_value[1],
+		dig_tab->pause_dig_value[0]);
+}
+
+static bool odm_dig_abort(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+
+	/* support_ability */
+	if (!(dm->support_ability & ODM_BB_FA_CNT)) {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_DIG,
+			"%s(): Return: support_ability ODM_BB_FA_CNT is disabled\n",
+			__func__);
+		return true;
+	}
+
+	/* support_ability */
+	if (!(dm->support_ability & ODM_BB_DIG)) {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_DIG,
+			"%s(): Return: support_ability ODM_BB_DIG is disabled\n",
+			__func__);
+		return true;
+	}
+
+	/* ScanInProcess */
+	if (*dm->is_scan_in_process) {
+		ODM_RT_TRACE(dm, ODM_COMP_DIG,
+			     "%s(): Return: In Scan Progress\n", __func__);
+		return true;
+	}
+
+	if (dig_tab->is_ignore_dig) {
+		dig_tab->is_ignore_dig = false;
+		ODM_RT_TRACE(dm, ODM_COMP_DIG, "%s(): Return: Ignore DIG\n",
+			     __func__);
+		return true;
+	}
+
+	/* add by Neil Chen to avoid PSD is processing */
+	if (!dm->is_dm_initial_gain_enable) {
+		ODM_RT_TRACE(dm, ODM_COMP_DIG,
+			     "%s(): Return: PSD is Processing\n", __func__);
+		return true;
+	}
+
+	return false;
+}
+
+void odm_dig_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+	u32 ret_value;
+	u8 i;
+
+	dig_tab->is_stop_dig = false;
+	dig_tab->is_ignore_dig = false;
+	dig_tab->is_psd_in_progress = false;
+	dig_tab->cur_ig_value =
+		(u8)odm_get_bb_reg(dm, ODM_REG(IGI_A, dm), ODM_BIT(IGI, dm));
+	dig_tab->pre_ig_value = 0;
+	dig_tab->rssi_low_thresh = DM_DIG_THRESH_LOW;
+	dig_tab->rssi_high_thresh = DM_DIG_THRESH_HIGH;
+	dig_tab->fa_low_thresh = DM_FALSEALARM_THRESH_LOW;
+	dig_tab->fa_high_thresh = DM_FALSEALARM_THRESH_HIGH;
+	dig_tab->backoff_val = DM_DIG_BACKOFF_DEFAULT;
+	dig_tab->backoff_val_range_max = DM_DIG_BACKOFF_MAX;
+	dig_tab->backoff_val_range_min = DM_DIG_BACKOFF_MIN;
+	dig_tab->pre_cck_cca_thres = 0xFF;
+	dig_tab->cur_cck_cca_thres = 0x83;
+	dig_tab->forbidden_igi = DM_DIG_MIN_NIC;
+	dig_tab->large_fa_hit = 0;
+	dig_tab->large_fa_timeout = 0;
+	dig_tab->recover_cnt = 0;
+	dig_tab->is_media_connect_0 = false;
+	dig_tab->is_media_connect_1 = false;
+
+	/*To initialize dm->is_dm_initial_gain_enable==false to avoid DIG err*/
+	dm->is_dm_initial_gain_enable = true;
+
+	dig_tab->dig_dynamic_min_0 = DM_DIG_MIN_NIC;
+	dig_tab->dig_dynamic_min_1 = DM_DIG_MIN_NIC;
+
+	/* To Initi BT30 IGI */
+	dig_tab->bt30_cur_igi = 0x32;
+
+	odm_memory_set(dm, dig_tab->pause_dig_value, 0,
+		       (DM_DIG_MAX_PAUSE_TYPE + 1));
+	dig_tab->pause_dig_level = 0;
+	odm_memory_set(dm, dig_tab->pause_cckpd_value, 0,
+		       (DM_DIG_MAX_PAUSE_TYPE + 1));
+	dig_tab->pause_cckpd_level = 0;
+
+	if (dm->board_type & (ODM_BOARD_EXT_PA | ODM_BOARD_EXT_LNA)) {
+		dig_tab->rx_gain_range_max = DM_DIG_MAX_NIC;
+		dig_tab->rx_gain_range_min = DM_DIG_MIN_NIC;
+	} else {
+		dig_tab->rx_gain_range_max = DM_DIG_MAX_NIC;
+		dig_tab->rx_gain_range_min = DM_DIG_MIN_NIC;
+	}
+
+	dig_tab->enable_adjust_big_jump = 1;
+	if (dm->support_ic_type & ODM_RTL8822B) {
+		ret_value = odm_get_bb_reg(dm, 0x8c8, MASKLWORD);
+		dig_tab->big_jump_step1 = (u8)(ret_value & 0xe) >> 1;
+		dig_tab->big_jump_step2 = (u8)(ret_value & 0x30) >> 4;
+		dig_tab->big_jump_step3 = (u8)(ret_value & 0xc0) >> 6;
+
+	} else if (dm->support_ic_type & ODM_RTL8197F) {
+		ret_value =
+			odm_get_bb_reg(dm, ODM_REG_BB_AGC_SET_2_11N, MASKLWORD);
+		dig_tab->big_jump_step1 = (u8)(ret_value & 0xe) >> 1;
+		dig_tab->big_jump_step2 = (u8)(ret_value & 0x30) >> 4;
+		dig_tab->big_jump_step3 = (u8)(ret_value & 0xc0) >> 6;
+	}
+	if (dm->support_ic_type & (ODM_RTL8822B | ODM_RTL8197F)) {
+		for (i = 0; i < sizeof(dig_tab->big_jump_lmt); i++) {
+			if (dig_tab->big_jump_lmt[i] == 0)
+				dig_tab->big_jump_lmt[i] =
+					0x64; /* Set -10dBm as default value */
+		}
+	}
+}
+
+void odm_DIG(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	/* Common parameters */
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+	struct false_alarm_stat *fa_cnt =
+		(struct false_alarm_stat *)phydm_get_structure(
+			dm, PHYDM_FALSEALMCNT);
+	bool first_connect, first_dis_connect;
+	u8 dig_max_of_min, dig_dynamic_min;
+	u8 dm_dig_max, dm_dig_min;
+	u8 current_igi = dig_tab->cur_ig_value;
+	u8 offset;
+	u32 dm_FA_thres[3];
+	u32 tx_tp = 0, rx_tp = 0;
+	bool is_dfs_band = false;
+	bool is_performance = true, is_first_tp_target = false,
+	     is_first_coverage = false;
+
+	if (odm_dig_abort(dm))
+		return;
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG, "DIG Start===>\n");
+
+	/* 1 Update status */
+	{
+		dig_dynamic_min = dig_tab->dig_dynamic_min_0;
+		first_connect = (dm->is_linked) && !dig_tab->is_media_connect_0;
+		first_dis_connect =
+			(!dm->is_linked) && dig_tab->is_media_connect_0;
+	}
+
+	/* 1 Boundary Decision */
+	{
+		/* 2 For WIN\CE */
+		if (dm->support_ic_type >= ODM_RTL8188E)
+			dm_dig_max = 0x5A;
+		else
+			dm_dig_max = DM_DIG_MAX_NIC;
+
+		if (dm->support_ic_type != ODM_RTL8821)
+			dm_dig_min = DM_DIG_MIN_NIC;
+		else
+			dm_dig_min = 0x1C;
+
+		dig_max_of_min = DM_DIG_MAX_AP;
+
+		/* Modify lower bound for DFS band */
+		if ((((*dm->channel >= 52) && (*dm->channel <= 64)) ||
+		     ((*dm->channel >= 100) && (*dm->channel <= 140))) &&
+		    phydm_dfs_master_enabled(dm)) {
+			is_dfs_band = true;
+			if (*dm->band_width == ODM_BW20M)
+				dm_dig_min = DM_DIG_MIN_AP_DFS + 2;
+			else
+				dm_dig_min = DM_DIG_MIN_AP_DFS;
+			ODM_RT_TRACE(dm, ODM_COMP_DIG,
+				     "DIG: ====== In DFS band ======\n");
+		}
+	}
+	ODM_RT_TRACE(dm, ODM_COMP_DIG,
+		     "DIG: Absolutly upper bound = 0x%x, lower bound = 0x%x\n",
+		     dm_dig_max, dm_dig_min);
+
+	if (dm->pu1_forced_igi_lb && (*dm->pu1_forced_igi_lb > 0)) {
+		ODM_RT_TRACE(dm, ODM_COMP_DIG, "DIG: Force IGI lb to: 0x%02x\n",
+			     *dm->pu1_forced_igi_lb);
+		dm_dig_min = *dm->pu1_forced_igi_lb;
+		dm_dig_max = (dm_dig_min <= dm_dig_max) ? (dm_dig_max) :
+							  (dm_dig_min + 1);
+	}
+
+	/* 1 Adjust boundary by RSSI */
+	if (dm->is_linked && is_performance) {
+		/* 2 Modify DIG upper bound */
+		/* 4 Modify DIG upper bound for 92E, 8723A\B, 8821 & 8812 BT */
+		if ((dm->support_ic_type & (ODM_RTL8192E | ODM_RTL8723B |
+					    ODM_RTL8812 | ODM_RTL8821)) &&
+		    (dm->is_bt_limited_dig == 1)) {
+			offset = 10;
+			ODM_RT_TRACE(
+				dm, ODM_COMP_DIG,
+				"DIG: Coex. case: Force upper bound to RSSI + %d\n",
+				offset);
+		} else {
+			offset = 15;
+		}
+
+		if ((dm->rssi_min + offset) > dm_dig_max)
+			dig_tab->rx_gain_range_max = dm_dig_max;
+		else if ((dm->rssi_min + offset) < dm_dig_min)
+			dig_tab->rx_gain_range_max = dm_dig_min;
+		else
+			dig_tab->rx_gain_range_max = dm->rssi_min + offset;
+
+		/* 2 Modify DIG lower bound */
+		/* if(dm->is_one_entry_only) */
+		{
+			if (dm->rssi_min < dm_dig_min)
+				dig_dynamic_min = dm_dig_min;
+			else if (dm->rssi_min > dig_max_of_min)
+				dig_dynamic_min = dig_max_of_min;
+			else
+				dig_dynamic_min = dm->rssi_min;
+
+			if (is_dfs_band) {
+				dig_dynamic_min = dm_dig_min;
+				ODM_RT_TRACE(
+					dm, ODM_COMP_DIG,
+					"DIG: DFS band: Force lower bound to 0x%x after link\n",
+					dm_dig_min);
+			}
+		}
+	} else {
+		if (is_performance && is_dfs_band) {
+			dig_tab->rx_gain_range_max = 0x28;
+			ODM_RT_TRACE(
+				dm, ODM_COMP_DIG,
+				"DIG: DFS band: Force upper bound to 0x%x before link\n",
+				dig_tab->rx_gain_range_max);
+		} else {
+			if (is_performance)
+				dig_tab->rx_gain_range_max = DM_DIG_MAX_OF_MIN;
+			else
+				dig_tab->rx_gain_range_max = dm_dig_max;
+		}
+		dig_dynamic_min = dm_dig_min;
+	}
+
+	/* 1 Force Lower Bound for AntDiv */
+	if (dm->is_linked && !dm->is_one_entry_only &&
+	    (dm->support_ic_type & ODM_ANTDIV_SUPPORT) &&
+	    (dm->support_ability & ODM_BB_ANT_DIV)) {
+		if (dm->ant_div_type == CG_TRX_HW_ANTDIV ||
+		    dm->ant_div_type == CG_TRX_SMART_ANTDIV) {
+			if (dig_tab->ant_div_rssi_max > dig_max_of_min)
+				dig_dynamic_min = dig_max_of_min;
+			else
+				dig_dynamic_min = (u8)dig_tab->ant_div_rssi_max;
+			ODM_RT_TRACE(
+				dm, ODM_COMP_DIG,
+				"DIG: AntDiv case: Force lower bound to 0x%x\n",
+				dig_dynamic_min);
+			ODM_RT_TRACE(dm, ODM_COMP_DIG,
+				     "DIG: AntDiv case: rssi_max = 0x%x\n",
+				     dig_tab->ant_div_rssi_max);
+		}
+	}
+	ODM_RT_TRACE(
+		dm, ODM_COMP_DIG,
+		"DIG: Adjust boundary by RSSI Upper bound = 0x%x, Lower bound = 0x%x\n",
+		dig_tab->rx_gain_range_max, dig_dynamic_min);
+	ODM_RT_TRACE(
+		dm, ODM_COMP_DIG,
+		"DIG: Link status: is_linked = %d, RSSI = %d, bFirstConnect = %d, bFirsrDisConnect = %d\n",
+		dm->is_linked, dm->rssi_min, first_connect, first_dis_connect);
+
+	/* 1 Modify DIG lower bound, deal with abnormal case */
+	/* 2 Abnormal false alarm case */
+	if (is_dfs_band) {
+		dig_tab->rx_gain_range_min = dig_dynamic_min;
+	} else {
+		if (!dm->is_linked) {
+			dig_tab->rx_gain_range_min = dig_dynamic_min;
+
+			if (first_dis_connect)
+				dig_tab->forbidden_igi = dig_dynamic_min;
+		} else {
+			dig_tab->rx_gain_range_min = odm_forbidden_igi_check(
+				dm, dig_dynamic_min, current_igi);
+		}
+	}
+
+	/* 2 Abnormal # beacon case */
+	if (dm->is_linked && !first_connect) {
+		ODM_RT_TRACE(dm, ODM_COMP_DIG, "Beacon Num (%d)\n",
+			     dm->phy_dbg_info.num_qry_beacon_pkt);
+		if ((dm->phy_dbg_info.num_qry_beacon_pkt < 5) &&
+		    (dm->bsta_state)) {
+			dig_tab->rx_gain_range_min = 0x1c;
+			ODM_RT_TRACE(
+				dm, ODM_COMP_DIG,
+				"DIG: Abnrormal #beacon (%d) case in STA mode: Force lower bound to 0x%x\n",
+				dm->phy_dbg_info.num_qry_beacon_pkt,
+				dig_tab->rx_gain_range_min);
+		}
+	}
+
+	/* 2 Abnormal lower bound case */
+	if (dig_tab->rx_gain_range_min > dig_tab->rx_gain_range_max) {
+		dig_tab->rx_gain_range_min = dig_tab->rx_gain_range_max;
+		ODM_RT_TRACE(
+			dm, ODM_COMP_DIG,
+			"DIG: Abnrormal lower bound case: Force lower bound to 0x%x\n",
+			dig_tab->rx_gain_range_min);
+	}
+
+	/* 1 False alarm threshold decision */
+	odm_fa_threshold_check(dm, is_dfs_band, is_performance, rx_tp, tx_tp,
+			       dm_FA_thres);
+	ODM_RT_TRACE(dm, ODM_COMP_DIG,
+		     "DIG: False alarm threshold = %d, %d, %d\n",
+		     dm_FA_thres[0], dm_FA_thres[1], dm_FA_thres[2]);
+
+	/* 1 Adjust initial gain by false alarm */
+	if (dm->is_linked && is_performance) {
+		/* 2 After link */
+		ODM_RT_TRACE(dm, ODM_COMP_DIG, "DIG: Adjust IGI after link\n");
+
+		if (is_first_tp_target || (first_connect && is_performance)) {
+			dig_tab->large_fa_hit = 0;
+
+			if (is_dfs_band) {
+				u8 rssi = dm->rssi_min;
+
+				current_igi =
+					(dm->rssi_min > 0x28) ? 0x28 : rssi;
+				ODM_RT_TRACE(
+					dm, ODM_COMP_DIG,
+					"DIG: DFS band: One-shot to 0x28 upmost\n");
+			} else {
+				current_igi = phydm_get_current_igi(
+					dig_max_of_min, dm->rssi_min,
+					current_igi);
+			}
+
+			ODM_RT_TRACE(
+				dm, ODM_COMP_DIG,
+				"DIG: First connect case: IGI does on-shot to 0x%x\n",
+				current_igi);
+
+		} else {
+			if (fa_cnt->cnt_all > dm_FA_thres[2])
+				current_igi = current_igi + 4;
+			else if (fa_cnt->cnt_all > dm_FA_thres[1])
+				current_igi = current_igi + 2;
+			else if (fa_cnt->cnt_all < dm_FA_thres[0])
+				current_igi = current_igi - 2;
+
+			/* 4 Abnormal # beacon case */
+			if ((dm->phy_dbg_info.num_qry_beacon_pkt < 5) &&
+			    (fa_cnt->cnt_all < DM_DIG_FA_TH1) &&
+			    (dm->bsta_state)) {
+				current_igi = dig_tab->rx_gain_range_min;
+				ODM_RT_TRACE(
+					dm, ODM_COMP_DIG,
+					"DIG: Abnormal #beacon (%d) case: IGI does one-shot to 0x%x\n",
+					dm->phy_dbg_info.num_qry_beacon_pkt,
+					current_igi);
+			}
+		}
+	} else {
+		/* 2 Before link */
+		ODM_RT_TRACE(dm, ODM_COMP_DIG, "DIG: Adjust IGI before link\n");
+
+		if (first_dis_connect || is_first_coverage) {
+			current_igi = dm_dig_min;
+			ODM_RT_TRACE(
+				dm, ODM_COMP_DIG,
+				"DIG: First disconnect case: IGI does on-shot to lower bound\n");
+		} else {
+			if (fa_cnt->cnt_all > dm_FA_thres[2])
+				current_igi = current_igi + 4;
+			else if (fa_cnt->cnt_all > dm_FA_thres[1])
+				current_igi = current_igi + 2;
+			else if (fa_cnt->cnt_all < dm_FA_thres[0])
+				current_igi = current_igi - 2;
+		}
+	}
+
+	/* 1 Check initial gain by upper/lower bound */
+	if (current_igi < dig_tab->rx_gain_range_min)
+		current_igi = dig_tab->rx_gain_range_min;
+
+	if (current_igi > dig_tab->rx_gain_range_max)
+		current_igi = dig_tab->rx_gain_range_max;
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG, "DIG: cur_ig_value=0x%x, TotalFA = %d\n",
+		     current_igi, fa_cnt->cnt_all);
+
+	/* 1 Update status */
+	if (dm->is_bt_hs_operation) {
+		if (dm->is_linked) {
+			if (dig_tab->bt30_cur_igi > (current_igi))
+				odm_write_dig(dm, current_igi);
+			else
+				odm_write_dig(dm, dig_tab->bt30_cur_igi);
+
+			dig_tab->is_media_connect_0 = dm->is_linked;
+			dig_tab->dig_dynamic_min_0 = dig_dynamic_min;
+		} else {
+			if (dm->is_link_in_process)
+				odm_write_dig(dm, 0x1c);
+			else if (dm->is_bt_connect_process)
+				odm_write_dig(dm, 0x28);
+			else
+				odm_write_dig(dm, dig_tab->bt30_cur_igi);
+		}
+	} else { /* BT is not using */
+		odm_write_dig(dm, current_igi);
+		dig_tab->is_media_connect_0 = dm->is_linked;
+		dig_tab->dig_dynamic_min_0 = dig_dynamic_min;
+	}
+	ODM_RT_TRACE(dm, ODM_COMP_DIG, "DIG end\n");
+}
+
+void odm_dig_by_rssi_lps(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct false_alarm_stat *fa_cnt =
+		(struct false_alarm_stat *)phydm_get_structure(
+			dm, PHYDM_FALSEALMCNT);
+
+	u8 rssi_lower = DM_DIG_MIN_NIC; /* 0x1E or 0x1C */
+	u8 current_igi = dm->rssi_min;
+
+	if (odm_dig_abort(dm))
+		return;
+
+	current_igi = current_igi + RSSI_OFFSET_DIG;
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG, "%s()==>\n", __func__);
+
+	/* Using FW PS mode to make IGI */
+	/* Adjust by  FA in LPS MODE */
+	if (fa_cnt->cnt_all > DM_DIG_FA_TH2_LPS)
+		current_igi = current_igi + 4;
+	else if (fa_cnt->cnt_all > DM_DIG_FA_TH1_LPS)
+		current_igi = current_igi + 2;
+	else if (fa_cnt->cnt_all < DM_DIG_FA_TH0_LPS)
+		current_igi = current_igi - 2;
+
+	/* Lower bound checking */
+
+	/* RSSI Lower bound check */
+	if ((dm->rssi_min - 10) > DM_DIG_MIN_NIC)
+		rssi_lower = (dm->rssi_min - 10);
+	else
+		rssi_lower = DM_DIG_MIN_NIC;
+
+	/* Upper and Lower Bound checking */
+	if (current_igi > DM_DIG_MAX_NIC)
+		current_igi = DM_DIG_MAX_NIC;
+	else if (current_igi < rssi_lower)
+		current_igi = rssi_lower;
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG, "%s(): fa_cnt->cnt_all = %d\n", __func__,
+		     fa_cnt->cnt_all);
+	ODM_RT_TRACE(dm, ODM_COMP_DIG, "%s(): dm->rssi_min = %d\n", __func__,
+		     dm->rssi_min);
+	ODM_RT_TRACE(dm, ODM_COMP_DIG, "%s(): current_igi = 0x%x\n", __func__,
+		     current_igi);
+
+	odm_write_dig(
+		dm,
+		current_igi); /* odm_write_dig(dm, dig_tab->cur_ig_value); */
+}
+
+/* 3============================================================
+ * 3 FASLE ALARM CHECK
+ * 3============================================================
+ */
+
+void odm_false_alarm_counter_statistics(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct false_alarm_stat *false_alm_cnt =
+		(struct false_alarm_stat *)phydm_get_structure(
+			dm, PHYDM_FALSEALMCNT);
+	struct rt_adcsmp *adc_smp = &dm->adcsmp;
+	u32 ret_value;
+
+	if (!(dm->support_ability & ODM_BB_FA_CNT))
+		return;
+
+	ODM_RT_TRACE(dm, ODM_COMP_FA_CNT, "%s()======>\n", __func__);
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES) {
+		/* hold ofdm counter */
+		odm_set_bb_reg(dm, ODM_REG_OFDM_FA_HOLDC_11N, BIT(31),
+			       1); /* hold page C counter */
+		odm_set_bb_reg(dm, ODM_REG_OFDM_FA_RSTD_11N, BIT(31),
+			       1); /* hold page D counter */
+
+		ret_value = odm_get_bb_reg(dm, ODM_REG_OFDM_FA_TYPE1_11N,
+					   MASKDWORD);
+		false_alm_cnt->cnt_fast_fsync = (ret_value & 0xffff);
+		false_alm_cnt->cnt_sb_search_fail =
+			((ret_value & 0xffff0000) >> 16);
+
+		ret_value = odm_get_bb_reg(dm, ODM_REG_OFDM_FA_TYPE2_11N,
+					   MASKDWORD);
+		false_alm_cnt->cnt_ofdm_cca = (ret_value & 0xffff);
+		false_alm_cnt->cnt_parity_fail =
+			((ret_value & 0xffff0000) >> 16);
+
+		ret_value = odm_get_bb_reg(dm, ODM_REG_OFDM_FA_TYPE3_11N,
+					   MASKDWORD);
+		false_alm_cnt->cnt_rate_illegal = (ret_value & 0xffff);
+		false_alm_cnt->cnt_crc8_fail = ((ret_value & 0xffff0000) >> 16);
+
+		ret_value = odm_get_bb_reg(dm, ODM_REG_OFDM_FA_TYPE4_11N,
+					   MASKDWORD);
+		false_alm_cnt->cnt_mcs_fail = (ret_value & 0xffff);
+
+		false_alm_cnt->cnt_ofdm_fail =
+			false_alm_cnt->cnt_parity_fail +
+			false_alm_cnt->cnt_rate_illegal +
+			false_alm_cnt->cnt_crc8_fail +
+			false_alm_cnt->cnt_mcs_fail +
+			false_alm_cnt->cnt_fast_fsync +
+			false_alm_cnt->cnt_sb_search_fail;
+
+		/* read CCK CRC32 counter */
+		false_alm_cnt->cnt_cck_crc32_error = odm_get_bb_reg(
+			dm, ODM_REG_CCK_CRC32_ERROR_CNT_11N, MASKDWORD);
+		false_alm_cnt->cnt_cck_crc32_ok = odm_get_bb_reg(
+			dm, ODM_REG_CCK_CRC32_OK_CNT_11N, MASKDWORD);
+
+		/* read OFDM CRC32 counter */
+		ret_value = odm_get_bb_reg(dm, ODM_REG_OFDM_CRC32_CNT_11N,
+					   MASKDWORD);
+		false_alm_cnt->cnt_ofdm_crc32_error =
+			(ret_value & 0xffff0000) >> 16;
+		false_alm_cnt->cnt_ofdm_crc32_ok = ret_value & 0xffff;
+
+		/* read HT CRC32 counter */
+		ret_value =
+			odm_get_bb_reg(dm, ODM_REG_HT_CRC32_CNT_11N, MASKDWORD);
+		false_alm_cnt->cnt_ht_crc32_error =
+			(ret_value & 0xffff0000) >> 16;
+		false_alm_cnt->cnt_ht_crc32_ok = ret_value & 0xffff;
+
+		/* read VHT CRC32 counter */
+		false_alm_cnt->cnt_vht_crc32_error = 0;
+		false_alm_cnt->cnt_vht_crc32_ok = 0;
+
+		{
+			/* hold cck counter */
+			odm_set_bb_reg(dm, ODM_REG_CCK_FA_RST_11N, BIT(12), 1);
+			odm_set_bb_reg(dm, ODM_REG_CCK_FA_RST_11N, BIT(14), 1);
+
+			ret_value = odm_get_bb_reg(dm, ODM_REG_CCK_FA_LSB_11N,
+						   MASKBYTE0);
+			false_alm_cnt->cnt_cck_fail = ret_value;
+
+			ret_value = odm_get_bb_reg(dm, ODM_REG_CCK_FA_MSB_11N,
+						   MASKBYTE3);
+			false_alm_cnt->cnt_cck_fail += (ret_value & 0xff) << 8;
+
+			ret_value = odm_get_bb_reg(dm, ODM_REG_CCK_CCA_CNT_11N,
+						   MASKDWORD);
+			false_alm_cnt->cnt_cck_cca =
+				((ret_value & 0xFF) << 8) |
+				((ret_value & 0xFF00) >> 8);
+		}
+
+		false_alm_cnt->cnt_all_pre = false_alm_cnt->cnt_all;
+
+		false_alm_cnt->cnt_all = (false_alm_cnt->cnt_fast_fsync +
+					  false_alm_cnt->cnt_sb_search_fail +
+					  false_alm_cnt->cnt_parity_fail +
+					  false_alm_cnt->cnt_rate_illegal +
+					  false_alm_cnt->cnt_crc8_fail +
+					  false_alm_cnt->cnt_mcs_fail +
+					  false_alm_cnt->cnt_cck_fail);
+
+		false_alm_cnt->cnt_cca_all = false_alm_cnt->cnt_ofdm_cca +
+					     false_alm_cnt->cnt_cck_cca;
+
+		if (dm->support_ic_type >= ODM_RTL8188E) {
+			/*reset false alarm counter registers*/
+			odm_set_bb_reg(dm, ODM_REG_OFDM_FA_RSTC_11N, BIT(31),
+				       1);
+			odm_set_bb_reg(dm, ODM_REG_OFDM_FA_RSTC_11N, BIT(31),
+				       0);
+			odm_set_bb_reg(dm, ODM_REG_OFDM_FA_RSTD_11N, BIT(27),
+				       1);
+			odm_set_bb_reg(dm, ODM_REG_OFDM_FA_RSTD_11N, BIT(27),
+				       0);
+
+			/*update ofdm counter*/
+			odm_set_bb_reg(dm, ODM_REG_OFDM_FA_HOLDC_11N, BIT(31),
+				       0); /*update page C counter*/
+			odm_set_bb_reg(dm, ODM_REG_OFDM_FA_RSTD_11N, BIT(31),
+				       0); /*update page D counter*/
+
+			/*reset CCK CCA counter*/
+			odm_set_bb_reg(dm, ODM_REG_CCK_FA_RST_11N,
+				       BIT(13) | BIT(12), 0);
+			odm_set_bb_reg(dm, ODM_REG_CCK_FA_RST_11N,
+				       BIT(13) | BIT(12), 2);
+
+			/*reset CCK FA counter*/
+			odm_set_bb_reg(dm, ODM_REG_CCK_FA_RST_11N,
+				       BIT(15) | BIT(14), 0);
+			odm_set_bb_reg(dm, ODM_REG_CCK_FA_RST_11N,
+				       BIT(15) | BIT(14), 2);
+
+			/*reset CRC32 counter*/
+			odm_set_bb_reg(dm, ODM_REG_PAGE_F_RST_11N, BIT(16), 1);
+			odm_set_bb_reg(dm, ODM_REG_PAGE_F_RST_11N, BIT(16), 0);
+		}
+
+		/* Get debug port 0 */
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11N, MASKDWORD, 0x0);
+		false_alm_cnt->dbg_port0 =
+			odm_get_bb_reg(dm, ODM_REG_RPT_11N, MASKDWORD);
+
+		/* Get EDCCA flag */
+		odm_set_bb_reg(dm, ODM_REG_DBG_RPT_11N, MASKDWORD, 0x208);
+		false_alm_cnt->edcca_flag =
+			(bool)odm_get_bb_reg(dm, ODM_REG_RPT_11N, BIT(30));
+
+		ODM_RT_TRACE(
+			dm, ODM_COMP_FA_CNT,
+			"[OFDM FA Detail] Parity_Fail = (( %d )), Rate_Illegal = (( %d )), CRC8_fail = (( %d )), Mcs_fail = (( %d )), Fast_Fsync = (( %d )), SB_Search_fail = (( %d ))\n",
+			false_alm_cnt->cnt_parity_fail,
+			false_alm_cnt->cnt_rate_illegal,
+			false_alm_cnt->cnt_crc8_fail,
+			false_alm_cnt->cnt_mcs_fail,
+			false_alm_cnt->cnt_fast_fsync,
+			false_alm_cnt->cnt_sb_search_fail);
+	}
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		u32 cck_enable;
+
+		/* read OFDM FA counter */
+		false_alm_cnt->cnt_ofdm_fail =
+			odm_get_bb_reg(dm, ODM_REG_OFDM_FA_11AC, MASKLWORD);
+
+		/* Read CCK FA counter */
+		false_alm_cnt->cnt_cck_fail =
+			odm_get_bb_reg(dm, ODM_REG_CCK_FA_11AC, MASKLWORD);
+
+		/* read CCK/OFDM CCA counter */
+		ret_value =
+			odm_get_bb_reg(dm, ODM_REG_CCK_CCA_CNT_11AC, MASKDWORD);
+		false_alm_cnt->cnt_ofdm_cca = (ret_value & 0xffff0000) >> 16;
+		false_alm_cnt->cnt_cck_cca = ret_value & 0xffff;
+
+		/* read CCK CRC32 counter */
+		ret_value = odm_get_bb_reg(dm, ODM_REG_CCK_CRC32_CNT_11AC,
+					   MASKDWORD);
+		false_alm_cnt->cnt_cck_crc32_error =
+			(ret_value & 0xffff0000) >> 16;
+		false_alm_cnt->cnt_cck_crc32_ok = ret_value & 0xffff;
+
+		/* read OFDM CRC32 counter */
+		ret_value = odm_get_bb_reg(dm, ODM_REG_OFDM_CRC32_CNT_11AC,
+					   MASKDWORD);
+		false_alm_cnt->cnt_ofdm_crc32_error =
+			(ret_value & 0xffff0000) >> 16;
+		false_alm_cnt->cnt_ofdm_crc32_ok = ret_value & 0xffff;
+
+		/* read HT CRC32 counter */
+		ret_value = odm_get_bb_reg(dm, ODM_REG_HT_CRC32_CNT_11AC,
+					   MASKDWORD);
+		false_alm_cnt->cnt_ht_crc32_error =
+			(ret_value & 0xffff0000) >> 16;
+		false_alm_cnt->cnt_ht_crc32_ok = ret_value & 0xffff;
+
+		/* read VHT CRC32 counter */
+		ret_value = odm_get_bb_reg(dm, ODM_REG_VHT_CRC32_CNT_11AC,
+					   MASKDWORD);
+		false_alm_cnt->cnt_vht_crc32_error =
+			(ret_value & 0xffff0000) >> 16;
+		false_alm_cnt->cnt_vht_crc32_ok = ret_value & 0xffff;
+
+		/* reset OFDM FA counter */
+		odm_set_bb_reg(dm, ODM_REG_OFDM_FA_RST_11AC, BIT(17), 1);
+		odm_set_bb_reg(dm, ODM_REG_OFDM_FA_RST_11AC, BIT(17), 0);
+
+		/* reset CCK FA counter */
+		odm_set_bb_reg(dm, ODM_REG_CCK_FA_RST_11AC, BIT(15), 0);
+		odm_set_bb_reg(dm, ODM_REG_CCK_FA_RST_11AC, BIT(15), 1);
+
+		/* reset CCA counter */
+		odm_set_bb_reg(dm, ODM_REG_RST_RPT_11AC, BIT(0), 1);
+		odm_set_bb_reg(dm, ODM_REG_RST_RPT_11AC, BIT(0), 0);
+
+		cck_enable =
+			odm_get_bb_reg(dm, ODM_REG_BB_RX_PATH_11AC, BIT(28));
+		if (cck_enable) { /* if(*dm->band_type == ODM_BAND_2_4G) */
+			false_alm_cnt->cnt_all = false_alm_cnt->cnt_ofdm_fail +
+						 false_alm_cnt->cnt_cck_fail;
+			false_alm_cnt->cnt_cca_all =
+				false_alm_cnt->cnt_cck_cca +
+				false_alm_cnt->cnt_ofdm_cca;
+		} else {
+			false_alm_cnt->cnt_all = false_alm_cnt->cnt_ofdm_fail;
+			false_alm_cnt->cnt_cca_all =
+				false_alm_cnt->cnt_ofdm_cca;
+		}
+
+		if (adc_smp->adc_smp_state == ADCSMP_STATE_IDLE) {
+			if (phydm_set_bb_dbg_port(
+				    dm, BB_DBGPORT_PRIORITY_1,
+				    0x0)) { /*set debug port to 0x0*/
+				false_alm_cnt->dbg_port0 =
+					phydm_get_bb_dbg_port_value(dm);
+				phydm_release_bb_dbg_port(dm);
+			}
+
+			if (phydm_set_bb_dbg_port(
+				    dm, BB_DBGPORT_PRIORITY_1,
+				    0x209)) { /*set debug port to 0x0*/
+				false_alm_cnt->edcca_flag =
+					(bool)((phydm_get_bb_dbg_port_value(
+							dm) &
+						BIT(30)) >>
+					       30);
+				phydm_release_bb_dbg_port(dm);
+			}
+		}
+	}
+
+	false_alm_cnt->cnt_crc32_error_all =
+		false_alm_cnt->cnt_vht_crc32_error +
+		false_alm_cnt->cnt_ht_crc32_error +
+		false_alm_cnt->cnt_ofdm_crc32_error +
+		false_alm_cnt->cnt_cck_crc32_error;
+	false_alm_cnt->cnt_crc32_ok_all = false_alm_cnt->cnt_vht_crc32_ok +
+					  false_alm_cnt->cnt_ht_crc32_ok +
+					  false_alm_cnt->cnt_ofdm_crc32_ok +
+					  false_alm_cnt->cnt_cck_crc32_ok;
+
+	ODM_RT_TRACE(dm, ODM_COMP_FA_CNT,
+		     "[CCA Cnt] {CCK, OFDM, Total} = {%d, %d, %d}\n",
+		     false_alm_cnt->cnt_cck_cca, false_alm_cnt->cnt_ofdm_cca,
+		     false_alm_cnt->cnt_cca_all);
+
+	ODM_RT_TRACE(dm, ODM_COMP_FA_CNT,
+		     "[FA Cnt] {CCK, OFDM, Total} = {%d, %d, %d}\n",
+		     false_alm_cnt->cnt_cck_fail, false_alm_cnt->cnt_ofdm_fail,
+		     false_alm_cnt->cnt_all);
+
+	ODM_RT_TRACE(dm, ODM_COMP_FA_CNT,
+		     "[CCK]  CRC32 {error, ok}= {%d, %d}\n",
+		     false_alm_cnt->cnt_cck_crc32_error,
+		     false_alm_cnt->cnt_cck_crc32_ok);
+	ODM_RT_TRACE(dm, ODM_COMP_FA_CNT, "[OFDM]CRC32 {error, ok}= {%d, %d}\n",
+		     false_alm_cnt->cnt_ofdm_crc32_error,
+		     false_alm_cnt->cnt_ofdm_crc32_ok);
+	ODM_RT_TRACE(dm, ODM_COMP_FA_CNT,
+		     "[ HT ]  CRC32 {error, ok}= {%d, %d}\n",
+		     false_alm_cnt->cnt_ht_crc32_error,
+		     false_alm_cnt->cnt_ht_crc32_ok);
+	ODM_RT_TRACE(dm, ODM_COMP_FA_CNT,
+		     "[VHT]  CRC32 {error, ok}= {%d, %d}\n",
+		     false_alm_cnt->cnt_vht_crc32_error,
+		     false_alm_cnt->cnt_vht_crc32_ok);
+	ODM_RT_TRACE(dm, ODM_COMP_FA_CNT,
+		     "[VHT]  CRC32 {error, ok}= {%d, %d}\n",
+		     false_alm_cnt->cnt_crc32_error_all,
+		     false_alm_cnt->cnt_crc32_ok_all);
+	ODM_RT_TRACE(dm, ODM_COMP_FA_CNT,
+		     "FA_Cnt: Dbg port 0x0 = 0x%x, EDCCA = %d\n\n",
+		     false_alm_cnt->dbg_port0, false_alm_cnt->edcca_flag);
+}
+
+/* 3============================================================
+ * 3 CCK Packet Detect threshold
+ * 3============================================================
+ */
+
+void odm_pause_cck_packet_detection(void *dm_void,
+				    enum phydm_pause_type pause_type,
+				    enum phydm_pause_level pause_level,
+				    u8 cck_pd_threshold)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+	s8 max_level;
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG, "%s()=========> level = %d\n", __func__,
+		     pause_level);
+
+	if ((dig_tab->pause_cckpd_level == 0) &&
+	    (!(dm->support_ability & ODM_BB_CCK_PD) ||
+	     !(dm->support_ability & ODM_BB_FA_CNT))) {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_DIG,
+			"Return: support_ability ODM_BB_CCK_PD or ODM_BB_FA_CNT is disabled\n");
+		return;
+	}
+
+	if (pause_level > DM_DIG_MAX_PAUSE_TYPE) {
+		ODM_RT_TRACE(dm, ODM_COMP_DIG,
+			     "%s(): Return: Wrong pause level !!\n", __func__);
+		return;
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG,
+		     "%s(): pause level = 0x%x, Current value = 0x%x\n",
+		     __func__, dig_tab->pause_cckpd_level, cck_pd_threshold);
+	ODM_RT_TRACE(
+		dm, ODM_COMP_DIG,
+		"%s(): pause value = 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+		__func__, dig_tab->pause_cckpd_value[7],
+		dig_tab->pause_cckpd_value[6], dig_tab->pause_cckpd_value[5],
+		dig_tab->pause_cckpd_value[4], dig_tab->pause_cckpd_value[3],
+		dig_tab->pause_cckpd_value[2], dig_tab->pause_cckpd_value[1],
+		dig_tab->pause_cckpd_value[0]);
+
+	switch (pause_type) {
+	/* Pause CCK Packet Detection threshold */
+	case PHYDM_PAUSE: {
+		/* Disable CCK PD */
+		odm_cmn_info_update(dm, ODM_CMNINFO_ABILITY,
+				    dm->support_ability & (~ODM_BB_CCK_PD));
+		ODM_RT_TRACE(dm, ODM_COMP_DIG,
+			     "%s(): Pause CCK packet detection threshold !!\n",
+			     __func__);
+
+		/*Backup original CCK PD threshold decided by CCK PD mechanism*/
+		if (dig_tab->pause_cckpd_level == 0) {
+			dig_tab->cck_pd_backup = dig_tab->cur_cck_cca_thres;
+			ODM_RT_TRACE(
+				dm, ODM_COMP_DIG,
+				"%s(): Backup CCKPD  = 0x%x, new CCKPD = 0x%x\n",
+				__func__, dig_tab->cck_pd_backup,
+				cck_pd_threshold);
+		}
+
+		/* Update pause level */
+		dig_tab->pause_cckpd_level =
+			(dig_tab->pause_cckpd_level | BIT(pause_level));
+
+		/* Record CCK PD threshold */
+		dig_tab->pause_cckpd_value[pause_level] = cck_pd_threshold;
+
+		/* Write new CCK PD threshold */
+		if (BIT(pause_level + 1) > dig_tab->pause_cckpd_level) {
+			odm_write_cck_cca_thres(dm, cck_pd_threshold);
+			ODM_RT_TRACE(dm, ODM_COMP_DIG,
+				     "%s(): CCKPD of higher level = 0x%x\n",
+				     __func__, cck_pd_threshold);
+		}
+		break;
+	}
+	/* Resume CCK Packet Detection threshold */
+	case PHYDM_RESUME: {
+		/* check if the level is illegal or not */
+		if ((dig_tab->pause_cckpd_level & (BIT(pause_level))) != 0) {
+			dig_tab->pause_cckpd_level =
+				dig_tab->pause_cckpd_level &
+				(~(BIT(pause_level)));
+			dig_tab->pause_cckpd_value[pause_level] = 0;
+			ODM_RT_TRACE(dm, ODM_COMP_DIG,
+				     "%s(): Resume CCK PD !!\n", __func__);
+		} else {
+			ODM_RT_TRACE(dm, ODM_COMP_DIG,
+				     "%s(): Wrong resume level !!\n", __func__);
+			break;
+		}
+
+		/* Resume DIG */
+		if (dig_tab->pause_cckpd_level == 0) {
+			/* Write backup IGI value */
+			odm_write_cck_cca_thres(dm, dig_tab->cck_pd_backup);
+			/* dig_tab->is_ignore_dig = true; */
+			ODM_RT_TRACE(dm, ODM_COMP_DIG,
+				     "%s(): Write original CCKPD = 0x%x\n",
+				     __func__, dig_tab->cck_pd_backup);
+
+			/* Enable DIG */
+			odm_cmn_info_update(dm, ODM_CMNINFO_ABILITY,
+					    dm->support_ability |
+						    ODM_BB_CCK_PD);
+			break;
+		}
+
+		if (BIT(pause_level) <= dig_tab->pause_cckpd_level)
+			break;
+
+		/* Calculate the maximum level now */
+		for (max_level = (pause_level - 1); max_level >= 0;
+		     max_level--) {
+			if ((dig_tab->pause_cckpd_level & BIT(max_level)) > 0)
+				break;
+		}
+
+		/* write CCKPD of lower level */
+		odm_write_cck_cca_thres(dm,
+					dig_tab->pause_cckpd_value[max_level]);
+		ODM_RT_TRACE(dm, ODM_COMP_DIG,
+			     "%s(): Write CCKPD (0x%x) of level (%d)\n",
+			     __func__, dig_tab->pause_cckpd_value[max_level],
+			     max_level);
+		break;
+	}
+	default:
+		ODM_RT_TRACE(dm, ODM_COMP_DIG, "%s(): Wrong  type !!\n",
+			     __func__);
+		break;
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG,
+		     "%s(): pause level = 0x%x, Current value = 0x%x\n",
+		     __func__, dig_tab->pause_cckpd_level, cck_pd_threshold);
+	ODM_RT_TRACE(
+		dm, ODM_COMP_DIG,
+		"%s(): pause value = 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+		__func__, dig_tab->pause_cckpd_value[7],
+		dig_tab->pause_cckpd_value[6], dig_tab->pause_cckpd_value[5],
+		dig_tab->pause_cckpd_value[4], dig_tab->pause_cckpd_value[3],
+		dig_tab->pause_cckpd_value[2], dig_tab->pause_cckpd_value[1],
+		dig_tab->pause_cckpd_value[0]);
+}
+
+void odm_cck_packet_detection_thresh(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+	struct false_alarm_stat *false_alm_cnt =
+		(struct false_alarm_stat *)phydm_get_structure(
+			dm, PHYDM_FALSEALMCNT);
+	u8 cur_cck_cca_thres = dig_tab->cur_cck_cca_thres, rssi_thd = 35;
+
+	if ((!(dm->support_ability & ODM_BB_CCK_PD)) ||
+	    (!(dm->support_ability & ODM_BB_FA_CNT))) {
+		ODM_RT_TRACE(dm, ODM_COMP_DIG, "CCK_PD: return==========\n");
+		return;
+	}
+
+	if (dm->ext_lna)
+		return;
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG, "CCK_PD: ==========>\n");
+
+	if (dig_tab->cck_fa_ma == 0xffffffff)
+		dig_tab->cck_fa_ma = false_alm_cnt->cnt_cck_fail;
+	else
+		dig_tab->cck_fa_ma =
+			((dig_tab->cck_fa_ma << 1) + dig_tab->cck_fa_ma +
+			 false_alm_cnt->cnt_cck_fail) >>
+			2;
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG, "CCK_PD: CCK FA moving average = %d\n",
+		     dig_tab->cck_fa_ma);
+
+	if (dm->is_linked) {
+		if (dm->rssi_min > rssi_thd) {
+			cur_cck_cca_thres = 0xcd;
+		} else if (dm->rssi_min > 20) {
+			if (dig_tab->cck_fa_ma >
+			    ((DM_DIG_FA_TH1 >> 1) + (DM_DIG_FA_TH1 >> 3)))
+				cur_cck_cca_thres = 0xcd;
+			else if (dig_tab->cck_fa_ma < (DM_DIG_FA_TH0 >> 1))
+				cur_cck_cca_thres = 0x83;
+		} else if (dm->rssi_min > 7) {
+			cur_cck_cca_thres = 0x83;
+		} else {
+			cur_cck_cca_thres = 0x40;
+		}
+
+	} else {
+		if (dig_tab->cck_fa_ma > 0x400)
+			cur_cck_cca_thres = 0x83;
+		else if (dig_tab->cck_fa_ma < 0x200)
+			cur_cck_cca_thres = 0x40;
+	}
+
+	{
+		odm_write_cck_cca_thres(dm, cur_cck_cca_thres);
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_DIG, "CCK_PD: cck_cca_th=((0x%x))\n\n",
+		     cur_cck_cca_thres);
+}
+
+void odm_write_cck_cca_thres(void *dm_void, u8 cur_cck_cca_thres)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+
+	if (dig_tab->cur_cck_cca_thres !=
+	    cur_cck_cca_thres) { /* modify by Guo.Mingzhi 2012-01-03 */
+		odm_write_1byte(dm, ODM_REG(CCK_CCA, dm), cur_cck_cca_thres);
+		dig_tab->cck_fa_ma = 0xffffffff;
+	}
+	dig_tab->pre_cck_cca_thres = dig_tab->cur_cck_cca_thres;
+	dig_tab->cur_cck_cca_thres = cur_cck_cca_thres;
+}
+
+bool phydm_dig_go_up_check(void *dm_void)
+{
+	bool ret = true;
+
+	return ret;
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_dig.h b/drivers/staging/rtlwifi/phydm/phydm_dig.h
new file mode 100644
index 000000000000..af70aaec3b19
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_dig.h
@@ -0,0 +1,241 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDMDIG_H__
+#define __PHYDMDIG_H__
+
+#define DIG_VERSION "1.32" /* 2016.09.02  YuChen. add CCK PD for 8197F*/
+
+/* Pause DIG & CCKPD */
+#define DM_DIG_MAX_PAUSE_TYPE 0x7
+
+enum dig_goupcheck_level {
+	DIG_GOUPCHECK_LEVEL_0,
+	DIG_GOUPCHECK_LEVEL_1,
+	DIG_GOUPCHECK_LEVEL_2
+
+};
+
+struct dig_thres {
+	bool is_stop_dig; /* for debug */
+	bool is_ignore_dig;
+	bool is_psd_in_progress;
+
+	u8 dig_enable_flag;
+	u8 dig_ext_port_stage;
+
+	int rssi_low_thresh;
+	int rssi_high_thresh;
+
+	u32 fa_low_thresh;
+	u32 fa_high_thresh;
+
+	u8 cur_sta_connect_state;
+	u8 pre_sta_connect_state;
+	u8 cur_multi_sta_connect_state;
+
+	u8 pre_ig_value;
+	u8 cur_ig_value;
+	u8 backup_ig_value; /* MP DIG */
+	u8 bt30_cur_igi;
+	u8 igi_backup;
+
+	s8 backoff_val;
+	s8 backoff_val_range_max;
+	s8 backoff_val_range_min;
+	u8 rx_gain_range_max;
+	u8 rx_gain_range_min;
+	u8 rssi_val_min;
+
+	u8 pre_cck_cca_thres;
+	u8 cur_cck_cca_thres;
+	u8 pre_cck_pd_state;
+	u8 cur_cck_pd_state;
+	u8 cck_pd_backup;
+	u8 pause_cckpd_level;
+	u8 pause_cckpd_value[DM_DIG_MAX_PAUSE_TYPE + 1];
+
+	u8 large_fa_hit;
+	u8 large_fa_timeout; /*if (large_fa_hit), monitor "large_fa_timeout"
+			      *sec, if timeout, large_fa_hit=0
+			      */
+	u8 forbidden_igi;
+	u32 recover_cnt;
+
+	u8 dig_dynamic_min_0;
+	u8 dig_dynamic_min_1;
+	bool is_media_connect_0;
+	bool is_media_connect_1;
+
+	u32 ant_div_rssi_max;
+	u32 rssi_max;
+
+	u8 *is_p2p_in_process;
+
+	u8 pause_dig_level;
+	u8 pause_dig_value[DM_DIG_MAX_PAUSE_TYPE + 1];
+
+	u32 cck_fa_ma;
+	enum dig_goupcheck_level dig_go_up_check_level;
+	u8 aaa_default;
+
+	u8 rf_gain_idx;
+	u8 agc_table_idx;
+	u8 big_jump_lmt[16];
+	u8 enable_adjust_big_jump : 1;
+	u8 big_jump_step1 : 3;
+	u8 big_jump_step2 : 2;
+	u8 big_jump_step3 : 2;
+};
+
+struct false_alarm_stat {
+	u32 cnt_parity_fail;
+	u32 cnt_rate_illegal;
+	u32 cnt_crc8_fail;
+	u32 cnt_mcs_fail;
+	u32 cnt_ofdm_fail;
+	u32 cnt_ofdm_fail_pre; /* For RTL8881A */
+	u32 cnt_cck_fail;
+	u32 cnt_all;
+	u32 cnt_all_pre;
+	u32 cnt_fast_fsync;
+	u32 cnt_sb_search_fail;
+	u32 cnt_ofdm_cca;
+	u32 cnt_cck_cca;
+	u32 cnt_cca_all;
+	u32 cnt_bw_usc; /* Gary */
+	u32 cnt_bw_lsc; /* Gary */
+	u32 cnt_cck_crc32_error;
+	u32 cnt_cck_crc32_ok;
+	u32 cnt_ofdm_crc32_error;
+	u32 cnt_ofdm_crc32_ok;
+	u32 cnt_ht_crc32_error;
+	u32 cnt_ht_crc32_ok;
+	u32 cnt_vht_crc32_error;
+	u32 cnt_vht_crc32_ok;
+	u32 cnt_crc32_error_all;
+	u32 cnt_crc32_ok_all;
+	bool cck_block_enable;
+	bool ofdm_block_enable;
+	u32 dbg_port0;
+	bool edcca_flag;
+};
+
+enum dm_dig_op {
+	DIG_TYPE_THRESH_HIGH = 0,
+	DIG_TYPE_THRESH_LOW = 1,
+	DIG_TYPE_BACKOFF = 2,
+	DIG_TYPE_RX_GAIN_MIN = 3,
+	DIG_TYPE_RX_GAIN_MAX = 4,
+	DIG_TYPE_ENABLE = 5,
+	DIG_TYPE_DISABLE = 6,
+	DIG_OP_TYPE_MAX
+};
+
+enum phydm_pause_type { PHYDM_PAUSE = BIT(0), PHYDM_RESUME = BIT(1) };
+
+enum phydm_pause_level {
+	/* number of pause level can't exceed DM_DIG_MAX_PAUSE_TYPE */
+	PHYDM_PAUSE_LEVEL_0 = 0,
+	PHYDM_PAUSE_LEVEL_1 = 1,
+	PHYDM_PAUSE_LEVEL_2 = 2,
+	PHYDM_PAUSE_LEVEL_3 = 3,
+	PHYDM_PAUSE_LEVEL_4 = 4,
+	PHYDM_PAUSE_LEVEL_5 = 5,
+	PHYDM_PAUSE_LEVEL_6 = 6,
+	PHYDM_PAUSE_LEVEL_7 = DM_DIG_MAX_PAUSE_TYPE /* maximum level */
+};
+
+#define DM_DIG_THRESH_HIGH 40
+#define DM_DIG_THRESH_LOW 35
+
+#define DM_FALSEALARM_THRESH_LOW 400
+#define DM_FALSEALARM_THRESH_HIGH 1000
+
+#define DM_DIG_MAX_NIC 0x3e
+#define DM_DIG_MIN_NIC 0x20
+#define DM_DIG_MAX_OF_MIN_NIC 0x3e
+
+#define DM_DIG_MAX_AP 0x3e
+#define DM_DIG_MIN_AP 0x20
+#define DM_DIG_MAX_OF_MIN 0x2A /* 0x32 */
+#define DM_DIG_MIN_AP_DFS 0x20
+
+#define DM_DIG_MAX_NIC_HP 0x46
+#define DM_DIG_MIN_NIC_HP 0x2e
+
+#define DM_DIG_MAX_AP_HP 0x42
+#define DM_DIG_MIN_AP_HP 0x30
+
+/* vivi 92c&92d has different definition, 20110504
+ * this is for 92c
+ */
+#define DM_DIG_FA_TH0 0x200 /* 0x20 */
+
+#define DM_DIG_FA_TH1 0x300
+#define DM_DIG_FA_TH2 0x400
+/* this is for 92d */
+#define DM_DIG_FA_TH0_92D 0x100
+#define DM_DIG_FA_TH1_92D 0x400
+#define DM_DIG_FA_TH2_92D 0x600
+
+#define DM_DIG_BACKOFF_MAX 12
+#define DM_DIG_BACKOFF_MIN -4
+#define DM_DIG_BACKOFF_DEFAULT 10
+
+#define DM_DIG_FA_TH0_LPS 4 /* -> 4 in lps */
+#define DM_DIG_FA_TH1_LPS 15 /* -> 15 lps */
+#define DM_DIG_FA_TH2_LPS 30 /* -> 30 lps */
+#define RSSI_OFFSET_DIG 0x05
+#define LARGE_FA_TIMEOUT 60
+
+void odm_change_dynamic_init_gain_thresh(void *dm_void, u32 dm_type,
+					 u32 dm_value);
+
+void odm_write_dig(void *dm_void, u8 current_igi);
+
+void odm_pause_dig(void *dm_void, enum phydm_pause_type pause_type,
+		   enum phydm_pause_level pause_level, u8 igi_value);
+
+void odm_dig_init(void *dm_void);
+
+void odm_DIG(void *dm_void);
+
+void odm_dig_by_rssi_lps(void *dm_void);
+
+void odm_false_alarm_counter_statistics(void *dm_void);
+
+void odm_pause_cck_packet_detection(void *dm_void,
+				    enum phydm_pause_type pause_type,
+				    enum phydm_pause_level pause_level,
+				    u8 cck_pd_threshold);
+
+void odm_cck_packet_detection_thresh(void *dm_void);
+
+void odm_write_cck_cca_thres(void *dm_void, u8 cur_cck_cca_thres);
+
+bool phydm_dig_go_up_check(void *dm_void);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_dynamic_rx_path.h b/drivers/staging/rtlwifi/phydm/phydm_dynamic_rx_path.h
new file mode 100644
index 000000000000..9f3cb2468c02
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_dynamic_rx_path.h
@@ -0,0 +1,37 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDMDYMICRXPATH_H__
+#define __PHYDMDYMICRXPATH_H__
+
+#define DYNAMIC_RX_PATH_VERSION "1.0" /*2016.07.15  Dino */
+
+#define DRP_RSSI_TH 35
+
+#define INIT_DRP_TIMMER 0
+#define CANCEL_DRP_TIMMER 1
+#define RELEASE_DRP_TIMMER 2
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_dynamicbbpowersaving.c b/drivers/staging/rtlwifi/phydm/phydm_dynamicbbpowersaving.c
new file mode 100644
index 000000000000..7661c499aeb1
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_dynamicbbpowersaving.c
@@ -0,0 +1,129 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/* ************************************************************
+ * include files
+ * *************************************************************/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+static inline void phydm_update_rf_state(struct phy_dm_struct *dm,
+					 struct dyn_pwr_saving *dm_ps_table,
+					 int _rssi_up_bound,
+					 int _rssi_low_bound,
+					 int _is_force_in_normal)
+{
+	if (_is_force_in_normal) {
+		dm_ps_table->cur_rf_state = rf_normal;
+		return;
+	}
+
+	if (dm->rssi_min == 0xFF) {
+		dm_ps_table->cur_rf_state = RF_MAX;
+		return;
+	}
+
+	if (dm_ps_table->pre_rf_state == rf_normal) {
+		if (dm->rssi_min >= _rssi_up_bound)
+			dm_ps_table->cur_rf_state = rf_save;
+		else
+			dm_ps_table->cur_rf_state = rf_normal;
+	} else {
+		if (dm->rssi_min <= _rssi_low_bound)
+			dm_ps_table->cur_rf_state = rf_normal;
+		else
+			dm_ps_table->cur_rf_state = rf_save;
+	}
+}
+
+void odm_dynamic_bb_power_saving_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dyn_pwr_saving *dm_ps_table = &dm->dm_ps_table;
+
+	dm_ps_table->pre_cca_state = CCA_MAX;
+	dm_ps_table->cur_cca_state = CCA_MAX;
+	dm_ps_table->pre_rf_state = RF_MAX;
+	dm_ps_table->cur_rf_state = RF_MAX;
+	dm_ps_table->rssi_val_min = 0;
+	dm_ps_table->initialize = 0;
+}
+
+void odm_rf_saving(void *dm_void, u8 is_force_in_normal)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dyn_pwr_saving *dm_ps_table = &dm->dm_ps_table;
+	u8 rssi_up_bound = 30;
+	u8 rssi_low_bound = 25;
+
+	if (dm->patch_id == 40) { /* RT_CID_819x_FUNAI_TV */
+		rssi_up_bound = 50;
+		rssi_low_bound = 45;
+	}
+	if (dm_ps_table->initialize == 0) {
+		dm_ps_table->reg874 =
+			(odm_get_bb_reg(dm, 0x874, MASKDWORD) & 0x1CC000) >> 14;
+		dm_ps_table->regc70 =
+			(odm_get_bb_reg(dm, 0xc70, MASKDWORD) & BIT(3)) >> 3;
+		dm_ps_table->reg85c =
+			(odm_get_bb_reg(dm, 0x85c, MASKDWORD) & 0xFF000000) >>
+			24;
+		dm_ps_table->rega74 =
+			(odm_get_bb_reg(dm, 0xa74, MASKDWORD) & 0xF000) >> 12;
+		/* Reg818 = phy_query_bb_reg(adapter, 0x818, MASKDWORD); */
+		dm_ps_table->initialize = 1;
+	}
+
+	phydm_update_rf_state(dm, dm_ps_table, rssi_up_bound, rssi_low_bound,
+			      is_force_in_normal);
+
+	if (dm_ps_table->pre_rf_state != dm_ps_table->cur_rf_state) {
+		if (dm_ps_table->cur_rf_state == rf_save) {
+			odm_set_bb_reg(dm, 0x874, 0x1C0000,
+				       0x2); /* reg874[20:18]=3'b010 */
+			odm_set_bb_reg(dm, 0xc70, BIT(3),
+				       0); /* regc70[3]=1'b0 */
+			odm_set_bb_reg(dm, 0x85c, 0xFF000000,
+				       0x63); /* reg85c[31:24]=0x63 */
+			odm_set_bb_reg(dm, 0x874, 0xC000,
+				       0x2); /* reg874[15:14]=2'b10 */
+			odm_set_bb_reg(dm, 0xa74, 0xF000,
+				       0x3); /* RegA75[7:4]=0x3 */
+			odm_set_bb_reg(dm, 0x818, BIT(28),
+				       0x0); /* Reg818[28]=1'b0 */
+			odm_set_bb_reg(dm, 0x818, BIT(28),
+				       0x1); /* Reg818[28]=1'b1 */
+		} else {
+			odm_set_bb_reg(dm, 0x874, 0x1CC000,
+				       dm_ps_table->reg874);
+			odm_set_bb_reg(dm, 0xc70, BIT(3), dm_ps_table->regc70);
+			odm_set_bb_reg(dm, 0x85c, 0xFF000000,
+				       dm_ps_table->reg85c);
+			odm_set_bb_reg(dm, 0xa74, 0xF000, dm_ps_table->rega74);
+			odm_set_bb_reg(dm, 0x818, BIT(28), 0x0);
+		}
+		dm_ps_table->pre_rf_state = dm_ps_table->cur_rf_state;
+	}
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_dynamicbbpowersaving.h b/drivers/staging/rtlwifi/phydm/phydm_dynamicbbpowersaving.h
new file mode 100644
index 000000000000..e7394c475395
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_dynamicbbpowersaving.h
@@ -0,0 +1,50 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDMDYNAMICBBPOWERSAVING_H__
+#define __PHYDMDYNAMICBBPOWERSAVING_H__
+
+#define DYNAMIC_BBPWRSAV_VERSION "1.1"
+
+struct dyn_pwr_saving {
+	u8 pre_cca_state;
+	u8 cur_cca_state;
+
+	u8 pre_rf_state;
+	u8 cur_rf_state;
+
+	int rssi_val_min;
+
+	u8 initialize;
+	u32 reg874, regc70, reg85c, rega74;
+};
+
+#define dm_rf_saving odm_rf_saving
+
+void odm_rf_saving(void *dm_void, u8 is_force_in_normal);
+
+void odm_dynamic_bb_power_saving_init(void *dm_void);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_dynamictxpower.c b/drivers/staging/rtlwifi/phydm/phydm_dynamictxpower.c
new file mode 100644
index 000000000000..ebb43342b80b
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_dynamictxpower.c
@@ -0,0 +1,102 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/* ************************************************************
+ * include files
+ * *************************************************************/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+void odm_dynamic_tx_power_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	dm->last_dtp_lvl = tx_high_pwr_level_normal;
+	dm->dynamic_tx_high_power_lvl = tx_high_pwr_level_normal;
+	dm->tx_agc_ofdm_18_6 =
+		odm_get_bb_reg(dm, 0xC24, MASKDWORD); /*TXAGC {18M 12M 9M 6M}*/
+}
+
+void odm_dynamic_tx_power_save_power_index(void *dm_void) {}
+
+void odm_dynamic_tx_power_restore_power_index(void *dm_void) {}
+
+void odm_dynamic_tx_power_write_power_index(void *dm_void, u8 value)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 index;
+	u32 power_index_reg[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
+
+	for (index = 0; index < 6; index++)
+		odm_write_1byte(dm, power_index_reg[index], value);
+}
+
+static void odm_dynamic_tx_power_nic_ce(void *dm_void) {}
+
+void odm_dynamic_tx_power(void *dm_void)
+{
+	/*  */
+	/* For AP/ADSL use struct rtl8192cd_priv* */
+	/* For CE/NIC use struct void* */
+	/*  */
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (!(dm->support_ability & ODM_BB_DYNAMIC_TXPWR))
+		return;
+	/* 2011/09/29 MH In HW integration first stage, we provide 4 different
+	 * handle to operate at the same time.
+	 * In the stage2/3, we need to prive universal interface and merge all
+	 * HW dynamic mechanism.
+	 */
+	switch (dm->support_platform) {
+	case ODM_WIN:
+		odm_dynamic_tx_power_nic(dm);
+		break;
+	case ODM_CE:
+		odm_dynamic_tx_power_nic_ce(dm);
+		break;
+	case ODM_AP:
+		odm_dynamic_tx_power_ap(dm);
+		break;
+	default:
+		break;
+	}
+}
+
+void odm_dynamic_tx_power_nic(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (!(dm->support_ability & ODM_BB_DYNAMIC_TXPWR))
+		return;
+}
+
+void odm_dynamic_tx_power_ap(void *dm_void
+
+			     )
+{
+}
+
+void odm_dynamic_tx_power_8821(void *dm_void, u8 *desc, u8 mac_id) {}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_dynamictxpower.h b/drivers/staging/rtlwifi/phydm/phydm_dynamictxpower.h
new file mode 100644
index 000000000000..10bad1209db2
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_dynamictxpower.h
@@ -0,0 +1,64 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDMDYNAMICTXPOWER_H__
+#define __PHYDMDYNAMICTXPOWER_H__
+
+/*#define DYNAMIC_TXPWR_VERSION	"1.0"*/
+/*#define DYNAMIC_TXPWR_VERSION	"1.3" */ /*2015.08.26, Add 8814 Dynamic TX pwr*/
+#define DYNAMIC_TXPWR_VERSION "1.4" /*2015.11.06,Add CE 8821A Dynamic TX pwr*/
+
+#define TX_POWER_NEAR_FIELD_THRESH_LVL2 74
+#define TX_POWER_NEAR_FIELD_THRESH_LVL1 60
+
+#define tx_high_pwr_level_normal 0
+#define tx_high_pwr_level_level1 1
+#define tx_high_pwr_level_level2 2
+
+#define tx_high_pwr_level_bt1 3
+#define tx_high_pwr_level_bt2 4
+#define tx_high_pwr_level_15 5
+#define tx_high_pwr_level_35 6
+#define tx_high_pwr_level_50 7
+#define tx_high_pwr_level_70 8
+#define tx_high_pwr_level_100 9
+
+void odm_dynamic_tx_power_init(void *dm_void);
+
+void odm_dynamic_tx_power_restore_power_index(void *dm_void);
+
+void odm_dynamic_tx_power_nic(void *dm_void);
+
+void odm_dynamic_tx_power_save_power_index(void *dm_void);
+
+void odm_dynamic_tx_power_write_power_index(void *dm_void, u8 value);
+
+void odm_dynamic_tx_power_8821(void *dm_void, u8 *desc, u8 mac_id);
+
+void odm_dynamic_tx_power(void *dm_void);
+
+void odm_dynamic_tx_power_ap(void *dm_void);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_edcaturbocheck.c b/drivers/staging/rtlwifi/phydm/phydm_edcaturbocheck.c
new file mode 100644
index 000000000000..753a9b9834e4
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_edcaturbocheck.c
@@ -0,0 +1,139 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/* ************************************************************
+ * include files
+ * *************************************************************/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+void odm_edca_turbo_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	dm->dm_edca_table.is_current_turbo_edca = false;
+	dm->dm_edca_table.is_cur_rdl_state = false;
+
+	ODM_RT_TRACE(dm, ODM_COMP_EDCA_TURBO, "Orginial VO PARAM: 0x%x\n",
+		     odm_read_4byte(dm, ODM_EDCA_VO_PARAM));
+	ODM_RT_TRACE(dm, ODM_COMP_EDCA_TURBO, "Orginial VI PARAM: 0x%x\n",
+		     odm_read_4byte(dm, ODM_EDCA_VI_PARAM));
+	ODM_RT_TRACE(dm, ODM_COMP_EDCA_TURBO, "Orginial BE PARAM: 0x%x\n",
+		     odm_read_4byte(dm, ODM_EDCA_BE_PARAM));
+	ODM_RT_TRACE(dm, ODM_COMP_EDCA_TURBO, "Orginial BK PARAM: 0x%x\n",
+		     odm_read_4byte(dm, ODM_EDCA_BK_PARAM));
+
+} /* ODM_InitEdcaTurbo */
+
+void odm_edca_turbo_check(void *dm_void)
+{
+	/* For AP/ADSL use struct rtl8192cd_priv* */
+	/* For CE/NIC use struct void* */
+
+	/* 2011/09/29 MH In HW integration first stage, we provide 4 different
+	 * handle to operate at the same time.
+	 * In the stage2/3, we need to prive universal interface and merge all
+	 * HW dynamic mechanism.
+	 */
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	ODM_RT_TRACE(dm, ODM_COMP_EDCA_TURBO,
+		     "%s========================>\n", __func__);
+
+	if (!(dm->support_ability & ODM_MAC_EDCA_TURBO))
+		return;
+
+	switch (dm->support_platform) {
+	case ODM_WIN:
+
+		break;
+
+	case ODM_CE:
+		odm_edca_turbo_check_ce(dm);
+		break;
+	}
+	ODM_RT_TRACE(dm, ODM_COMP_EDCA_TURBO,
+		     "<========================%s\n", __func__);
+
+} /* odm_CheckEdcaTurbo */
+
+void odm_edca_turbo_check_ce(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+	u64 cur_txok_cnt = 0;
+	u64 cur_rxok_cnt = 0;
+	u32 edca_be_ul = 0x5ea42b;
+	u32 edca_be_dl = 0x5ea42b;
+	u32 edca_be = 0x5ea42b;
+	bool is_cur_rdlstate;
+	bool edca_turbo_on = false;
+
+	if (dm->wifi_test)
+		return;
+
+	if (!dm->is_linked) {
+		rtlpriv->dm.is_any_nonbepkts = false;
+		return;
+	}
+
+	if (rtlpriv->dm.dbginfo.num_non_be_pkt > 0x100)
+		rtlpriv->dm.is_any_nonbepkts = true;
+	rtlpriv->dm.dbginfo.num_non_be_pkt = 0;
+
+	cur_txok_cnt = rtlpriv->stats.txbytesunicast_inperiod;
+	cur_rxok_cnt = rtlpriv->stats.rxbytesunicast_inperiod;
+
+	/*b_bias_on_rx = false;*/
+	edca_turbo_on = ((!rtlpriv->dm.is_any_nonbepkts) &&
+			 (!rtlpriv->dm.disable_framebursting)) ?
+				true :
+				false;
+
+	if (rtlpriv->mac80211.mode == WIRELESS_MODE_B)
+		goto label_exit;
+
+	if (edca_turbo_on) {
+		is_cur_rdlstate =
+			(cur_rxok_cnt > cur_txok_cnt * 4) ? true : false;
+
+		edca_be = is_cur_rdlstate ? edca_be_dl : edca_be_ul;
+		rtl_write_dword(rtlpriv, REG_EDCA_BE_PARAM_8822B, edca_be);
+		rtlpriv->dm.is_cur_rdlstate = is_cur_rdlstate;
+		rtlpriv->dm.current_turbo_edca = true;
+	} else {
+		if (rtlpriv->dm.current_turbo_edca) {
+			u8 tmp = AC0_BE;
+
+			rtlpriv->cfg->ops->set_hw_reg(rtlpriv->hw,
+						      HW_VAR_AC_PARAM,
+						      (u8 *)(&tmp));
+			rtlpriv->dm.current_turbo_edca = false;
+		}
+	}
+
+label_exit:
+	rtlpriv->dm.is_any_nonbepkts = false;
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_edcaturbocheck.h b/drivers/staging/rtlwifi/phydm/phydm_edcaturbocheck.h
new file mode 100644
index 000000000000..5845b108a001
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_edcaturbocheck.h
@@ -0,0 +1,44 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDMEDCATURBOCHECK_H__
+#define __PHYDMEDCATURBOCHECK_H__
+
+/*#define EDCATURBO_VERSION	"2.1"*/
+#define EDCATURBO_VERSION "2.3" /*2015.07.29 by YuChen*/
+
+struct edca_turbo {
+	bool is_current_turbo_edca;
+	bool is_cur_rdl_state;
+
+	u32 prv_traffic_idx; /* edca turbo */
+};
+
+void odm_edca_turbo_check(void *dm_void);
+void odm_edca_turbo_init(void *dm_void);
+
+void odm_edca_turbo_check_ce(void *dm_void);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_features.h b/drivers/staging/rtlwifi/phydm/phydm_features.h
new file mode 100644
index 000000000000..37f6f0cd7235
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_features.h
@@ -0,0 +1,33 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDM_FEATURES_H__
+#define __PHYDM_FEATURES
+
+/*phydm debyg report & tools*/
+
+/*Antenna Diversity*/
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_hwconfig.c b/drivers/staging/rtlwifi/phydm/phydm_hwconfig.c
new file mode 100644
index 000000000000..0a1f11a926e4
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_hwconfig.c
@@ -0,0 +1,1928 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/* ************************************************************
+ * include files
+ * *************************************************************/
+
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+#define READ_AND_CONFIG_MP(ic, txt) (odm_read_and_config_mp_##ic##txt(dm))
+#define READ_AND_CONFIG_TC(ic, txt) (odm_read_and_config_tc_##ic##txt(dm))
+
+#define READ_AND_CONFIG READ_AND_CONFIG_MP
+
+#define READ_FIRMWARE_MP(ic, txt)                                              \
+	(odm_read_firmware_mp_##ic##txt(dm, p_firmware, size))
+#define READ_FIRMWARE_TC(ic, txt)                                              \
+	(odm_read_firmware_tc_##ic##txt(dm, p_firmware, size))
+
+#define READ_FIRMWARE READ_FIRMWARE_MP
+
+#define GET_VERSION_MP(ic, txt) (odm_get_version_mp_##ic##txt())
+#define GET_VERSION_TC(ic, txt) (odm_get_version_tc_##ic##txt())
+
+#define GET_VERSION(ic, txt) GET_VERSION_MP(ic, txt)
+
+static u32 phydm_process_rssi_pwdb(struct phy_dm_struct *dm,
+				   struct rtl_sta_info *entry,
+				   struct dm_per_pkt_info *pktinfo,
+				   u32 undecorated_smoothed_ofdm,
+				   u32 undecorated_smoothed_cck)
+{
+	u32 weighting = 0, undecorated_smoothed_pwdb;
+	/* 2011.07.28 LukeLee: modified to prevent unstable CCK RSSI */
+
+	if (entry->rssi_stat.ofdm_pkt ==
+	    64) { /* speed up when all packets are OFDM*/
+		undecorated_smoothed_pwdb = undecorated_smoothed_ofdm;
+		ODM_RT_TRACE(dm, ODM_COMP_RSSI_MONITOR,
+			     "PWDB_0[%d] = (( %d ))\n", pktinfo->station_id,
+			     undecorated_smoothed_cck);
+	} else {
+		if (entry->rssi_stat.valid_bit < 64)
+			entry->rssi_stat.valid_bit++;
+
+		if (entry->rssi_stat.valid_bit == 64) {
+			weighting = ((entry->rssi_stat.ofdm_pkt) > 4) ?
+					    64 :
+					    (entry->rssi_stat.ofdm_pkt << 4);
+			undecorated_smoothed_pwdb =
+				(weighting * undecorated_smoothed_ofdm +
+				 (64 - weighting) * undecorated_smoothed_cck) >>
+				6;
+			ODM_RT_TRACE(dm, ODM_COMP_RSSI_MONITOR,
+				     "PWDB_1[%d] = (( %d )), W = (( %d ))\n",
+				     pktinfo->station_id,
+				     undecorated_smoothed_cck, weighting);
+		} else {
+			if (entry->rssi_stat.valid_bit != 0)
+				undecorated_smoothed_pwdb =
+					(entry->rssi_stat.ofdm_pkt *
+						 undecorated_smoothed_ofdm +
+					 (entry->rssi_stat.valid_bit -
+					  entry->rssi_stat.ofdm_pkt) *
+						 undecorated_smoothed_cck) /
+					entry->rssi_stat.valid_bit;
+			else
+				undecorated_smoothed_pwdb = 0;
+
+			ODM_RT_TRACE(
+				dm, ODM_COMP_RSSI_MONITOR,
+				"PWDB_2[%d] = (( %d )), ofdm_pkt = (( %d )), Valid_Bit = (( %d ))\n",
+				pktinfo->station_id, undecorated_smoothed_cck,
+				entry->rssi_stat.ofdm_pkt,
+				entry->rssi_stat.valid_bit);
+		}
+	}
+
+	return undecorated_smoothed_pwdb;
+}
+
+static u32 phydm_process_rssi_cck(struct phy_dm_struct *dm,
+				  struct dm_phy_status_info *phy_info,
+				  struct rtl_sta_info *entry,
+				  u32 undecorated_smoothed_cck)
+{
+	u32 rssi_ave;
+	u8 i;
+
+	rssi_ave = phy_info->rx_pwdb_all;
+	dm->rssi_a = (u8)phy_info->rx_pwdb_all;
+	dm->rssi_b = 0xFF;
+	dm->rssi_c = 0xFF;
+	dm->rssi_d = 0xFF;
+
+	if (entry->rssi_stat.cck_pkt <= 63)
+		entry->rssi_stat.cck_pkt++;
+
+	/* 1 Process CCK RSSI */
+	if (undecorated_smoothed_cck <= 0) { /* initialize */
+		undecorated_smoothed_cck = phy_info->rx_pwdb_all;
+		entry->rssi_stat.cck_sum_power =
+			(u16)phy_info->rx_pwdb_all; /*reset*/
+		entry->rssi_stat.cck_pkt = 1; /*reset*/
+		ODM_RT_TRACE(dm, ODM_COMP_RSSI_MONITOR, "CCK_INIT: (( %d ))\n",
+			     undecorated_smoothed_cck);
+	} else if (entry->rssi_stat.cck_pkt <= CCK_RSSI_INIT_COUNT) {
+		entry->rssi_stat.cck_sum_power =
+			entry->rssi_stat.cck_sum_power +
+			(u16)phy_info->rx_pwdb_all;
+		undecorated_smoothed_cck = entry->rssi_stat.cck_sum_power /
+					   entry->rssi_stat.cck_pkt;
+
+		ODM_RT_TRACE(
+			dm, ODM_COMP_RSSI_MONITOR,
+			"CCK_0: (( %d )), SumPow = (( %d )), cck_pkt = (( %d ))\n",
+			undecorated_smoothed_cck,
+			entry->rssi_stat.cck_sum_power,
+			entry->rssi_stat.cck_pkt);
+	} else {
+		if (phy_info->rx_pwdb_all > (u32)undecorated_smoothed_cck) {
+			undecorated_smoothed_cck =
+				(((undecorated_smoothed_cck) *
+				  (RX_SMOOTH_FACTOR - 1)) +
+				 (phy_info->rx_pwdb_all)) /
+				(RX_SMOOTH_FACTOR);
+			undecorated_smoothed_cck = undecorated_smoothed_cck + 1;
+			ODM_RT_TRACE(dm, ODM_COMP_RSSI_MONITOR,
+				     "CCK_1: (( %d ))\n",
+				     undecorated_smoothed_cck);
+		} else {
+			undecorated_smoothed_cck =
+				(((undecorated_smoothed_cck) *
+				  (RX_SMOOTH_FACTOR - 1)) +
+				 (phy_info->rx_pwdb_all)) /
+				(RX_SMOOTH_FACTOR);
+			ODM_RT_TRACE(dm, ODM_COMP_RSSI_MONITOR,
+				     "CCK_2: (( %d ))\n",
+				     undecorated_smoothed_cck);
+		}
+	}
+
+	i = 63;
+	entry->rssi_stat.ofdm_pkt -=
+		(u8)((entry->rssi_stat.packet_map >> i) & BIT(0));
+	entry->rssi_stat.packet_map = entry->rssi_stat.packet_map << 1;
+	return undecorated_smoothed_cck;
+}
+
+static u32 phydm_process_rssi_ofdm(struct phy_dm_struct *dm,
+				   struct dm_phy_status_info *phy_info,
+				   struct rtl_sta_info *entry,
+				   u32 undecorated_smoothed_ofdm)
+{
+	u32 rssi_ave;
+	u8 rssi_max, rssi_min, i;
+
+	if (dm->support_ic_type & (ODM_RTL8814A | ODM_RTL8822B)) {
+		u8 rx_count = 0;
+		u32 rssi_linear = 0;
+
+		if (dm->rx_ant_status & ODM_RF_A) {
+			dm->rssi_a = phy_info->rx_mimo_signal_strength
+					     [ODM_RF_PATH_A];
+			rx_count++;
+			rssi_linear += odm_convert_to_linear(
+				phy_info->rx_mimo_signal_strength
+					[ODM_RF_PATH_A]);
+		} else {
+			dm->rssi_a = 0;
+		}
+
+		if (dm->rx_ant_status & ODM_RF_B) {
+			dm->rssi_b = phy_info->rx_mimo_signal_strength
+					     [ODM_RF_PATH_B];
+			rx_count++;
+			rssi_linear += odm_convert_to_linear(
+				phy_info->rx_mimo_signal_strength
+					[ODM_RF_PATH_B]);
+		} else {
+			dm->rssi_b = 0;
+		}
+
+		if (dm->rx_ant_status & ODM_RF_C) {
+			dm->rssi_c = phy_info->rx_mimo_signal_strength
+					     [ODM_RF_PATH_C];
+			rx_count++;
+			rssi_linear += odm_convert_to_linear(
+				phy_info->rx_mimo_signal_strength
+					[ODM_RF_PATH_C]);
+		} else {
+			dm->rssi_c = 0;
+		}
+
+		if (dm->rx_ant_status & ODM_RF_D) {
+			dm->rssi_d = phy_info->rx_mimo_signal_strength
+					     [ODM_RF_PATH_D];
+			rx_count++;
+			rssi_linear += odm_convert_to_linear(
+				phy_info->rx_mimo_signal_strength
+					[ODM_RF_PATH_D]);
+		} else {
+			dm->rssi_d = 0;
+		}
+
+		/* Calculate average RSSI */
+		switch (rx_count) {
+		case 2:
+			rssi_linear = (rssi_linear >> 1);
+			break;
+		case 3:
+			/* rssi_linear/3 ~ rssi_linear*11/32 */
+			rssi_linear = ((rssi_linear) + (rssi_linear << 1) +
+				       (rssi_linear << 3)) >>
+				      5;
+			break;
+		case 4:
+			rssi_linear = (rssi_linear >> 2);
+			break;
+		}
+
+		rssi_ave = odm_convert_to_db(rssi_linear);
+	} else {
+		if (phy_info->rx_mimo_signal_strength[ODM_RF_PATH_B] == 0) {
+			rssi_ave = phy_info->rx_mimo_signal_strength
+					   [ODM_RF_PATH_A];
+			dm->rssi_a = phy_info->rx_mimo_signal_strength
+					     [ODM_RF_PATH_A];
+			dm->rssi_b = 0;
+		} else {
+			dm->rssi_a = phy_info->rx_mimo_signal_strength
+					     [ODM_RF_PATH_A];
+			dm->rssi_b = phy_info->rx_mimo_signal_strength
+					     [ODM_RF_PATH_B];
+
+			if (phy_info->rx_mimo_signal_strength[ODM_RF_PATH_A] >
+			    phy_info->rx_mimo_signal_strength[ODM_RF_PATH_B]) {
+				rssi_max = phy_info->rx_mimo_signal_strength
+						   [ODM_RF_PATH_A];
+				rssi_min = phy_info->rx_mimo_signal_strength
+						   [ODM_RF_PATH_B];
+			} else {
+				rssi_max = phy_info->rx_mimo_signal_strength
+						   [ODM_RF_PATH_B];
+				rssi_min = phy_info->rx_mimo_signal_strength
+						   [ODM_RF_PATH_A];
+			}
+			if ((rssi_max - rssi_min) < 3)
+				rssi_ave = rssi_max;
+			else if ((rssi_max - rssi_min) < 6)
+				rssi_ave = rssi_max - 1;
+			else if ((rssi_max - rssi_min) < 10)
+				rssi_ave = rssi_max - 2;
+			else
+				rssi_ave = rssi_max - 3;
+		}
+	}
+
+	/* 1 Process OFDM RSSI */
+	if (undecorated_smoothed_ofdm <= 0) { /* initialize */
+		undecorated_smoothed_ofdm = phy_info->rx_pwdb_all;
+		ODM_RT_TRACE(dm, ODM_COMP_RSSI_MONITOR, "OFDM_INIT: (( %d ))\n",
+			     undecorated_smoothed_ofdm);
+	} else {
+		if (phy_info->rx_pwdb_all > (u32)undecorated_smoothed_ofdm) {
+			undecorated_smoothed_ofdm =
+				(((undecorated_smoothed_ofdm) *
+				  (RX_SMOOTH_FACTOR - 1)) +
+				 (rssi_ave)) /
+				(RX_SMOOTH_FACTOR);
+			undecorated_smoothed_ofdm =
+				undecorated_smoothed_ofdm + 1;
+			ODM_RT_TRACE(dm, ODM_COMP_RSSI_MONITOR,
+				     "OFDM_1: (( %d ))\n",
+				     undecorated_smoothed_ofdm);
+		} else {
+			undecorated_smoothed_ofdm =
+				(((undecorated_smoothed_ofdm) *
+				  (RX_SMOOTH_FACTOR - 1)) +
+				 (rssi_ave)) /
+				(RX_SMOOTH_FACTOR);
+			ODM_RT_TRACE(dm, ODM_COMP_RSSI_MONITOR,
+				     "OFDM_2: (( %d ))\n",
+				     undecorated_smoothed_ofdm);
+		}
+	}
+
+	if (entry->rssi_stat.ofdm_pkt != 64) {
+		i = 63;
+		entry->rssi_stat.ofdm_pkt -=
+			(u8)(((entry->rssi_stat.packet_map >> i) & BIT(0)) - 1);
+	}
+
+	entry->rssi_stat.packet_map =
+		(entry->rssi_stat.packet_map << 1) | BIT(0);
+	return undecorated_smoothed_ofdm;
+}
+
+static u8 odm_evm_db_to_percentage(s8);
+static u8 odm_evm_dbm_jaguar_series(s8);
+
+static inline u32 phydm_get_rssi_average(struct phy_dm_struct *dm,
+					 struct dm_phy_status_info *phy_info)
+{
+	u8 rssi_max = 0, rssi_min = 0;
+
+	dm->rssi_a = phy_info->rx_mimo_signal_strength[ODM_RF_PATH_A];
+	dm->rssi_b = phy_info->rx_mimo_signal_strength[ODM_RF_PATH_B];
+
+	if (phy_info->rx_mimo_signal_strength[ODM_RF_PATH_A] >
+	    phy_info->rx_mimo_signal_strength[ODM_RF_PATH_B]) {
+		rssi_max = phy_info->rx_mimo_signal_strength[ODM_RF_PATH_A];
+		rssi_min = phy_info->rx_mimo_signal_strength[ODM_RF_PATH_B];
+	} else {
+		rssi_max = phy_info->rx_mimo_signal_strength[ODM_RF_PATH_B];
+		rssi_min = phy_info->rx_mimo_signal_strength[ODM_RF_PATH_A];
+	}
+	if ((rssi_max - rssi_min) < 3)
+		return rssi_max;
+	else if ((rssi_max - rssi_min) < 6)
+		return rssi_max - 1;
+	else if ((rssi_max - rssi_min) < 10)
+		return rssi_max - 2;
+	else
+		return rssi_max - 3;
+}
+
+static inline u8 phydm_get_evm_dbm(u8 i, u8 EVM,
+				   struct phy_status_rpt_8812 *phy_sta_rpt,
+				   struct dm_phy_status_info *phy_info)
+{
+	if (i < ODM_RF_PATH_C)
+		return odm_evm_dbm_jaguar_series(phy_sta_rpt->rxevm[i]);
+	else
+		return odm_evm_dbm_jaguar_series(phy_sta_rpt->rxevm_cd[i - 2]);
+	/*RT_DISP(FRX, RX_PHY_SQ, ("RXRATE=%x RXEVM=%x EVM=%s%d\n",*/
+	/*pktinfo->data_rate, phy_sta_rpt->rxevm[i], "%", EVM));*/
+}
+
+static inline u8 phydm_get_odm_evm(u8 i, struct dm_per_pkt_info *pktinfo,
+				   struct phy_status_rpt_8812 *phy_sta_rpt)
+{
+	u8 evm = 0;
+
+	if (pktinfo->data_rate >= ODM_RATE6M &&
+	    pktinfo->data_rate <= ODM_RATE54M) {
+		if (i == ODM_RF_PATH_A) {
+			evm = odm_evm_db_to_percentage(
+				(phy_sta_rpt->sigevm)); /*dbm*/
+			evm += 20;
+			if (evm > 100)
+				evm = 100;
+		}
+	} else {
+		if (i < ODM_RF_PATH_C) {
+			if (phy_sta_rpt->rxevm[i] == -128)
+				phy_sta_rpt->rxevm[i] = -25;
+			evm = odm_evm_db_to_percentage(
+				(phy_sta_rpt->rxevm[i])); /*dbm*/
+		} else {
+			if (phy_sta_rpt->rxevm_cd[i - 2] == -128)
+				phy_sta_rpt->rxevm_cd[i - 2] = -25;
+			evm = odm_evm_db_to_percentage(
+				(phy_sta_rpt->rxevm_cd[i - 2])); /*dbm*/
+		}
+	}
+
+	return evm;
+}
+
+static inline s8 phydm_get_rx_pwr(u8 LNA_idx, u8 VGA_idx, u8 cck_highpwr)
+{
+	switch (LNA_idx) {
+	case 7:
+		if (VGA_idx <= 27)
+			return -100 + 2 * (27 - VGA_idx); /*VGA_idx = 27~2*/
+		else
+			return -100;
+		break;
+	case 6:
+		return -48 + 2 * (2 - VGA_idx); /*VGA_idx = 2~0*/
+	case 5:
+		return -42 + 2 * (7 - VGA_idx); /*VGA_idx = 7~5*/
+	case 4:
+		return -36 + 2 * (7 - VGA_idx); /*VGA_idx = 7~4*/
+	case 3:
+		return -24 + 2 * (7 - VGA_idx); /*VGA_idx = 7~0*/
+	case 2:
+		if (cck_highpwr)
+			return -12 + 2 * (5 - VGA_idx); /*VGA_idx = 5~0*/
+		else
+			return -6 + 2 * (5 - VGA_idx);
+		break;
+	case 1:
+		return 8 - 2 * VGA_idx;
+	case 0:
+		return 14 - 2 * VGA_idx;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static inline u8 phydm_adjust_pwdb(u8 cck_highpwr, u8 pwdb_all)
+{
+	if (!cck_highpwr) {
+		if (pwdb_all >= 80)
+			return ((pwdb_all - 80) << 1) + ((pwdb_all - 80) >> 1) +
+			       80;
+		else if ((pwdb_all <= 78) && (pwdb_all >= 20))
+			return pwdb_all + 3;
+		if (pwdb_all > 100)
+			return 100;
+	}
+	return pwdb_all;
+}
+
+static inline u8
+phydm_get_signal_quality_8812(struct dm_phy_status_info *phy_info,
+			      struct phy_dm_struct *dm,
+			      struct phy_status_rpt_8812 *phy_sta_rpt)
+{
+	u8 sq_rpt;
+
+	if (phy_info->rx_pwdb_all > 40 && !dm->is_in_hct_test)
+		return 100;
+
+	sq_rpt = phy_sta_rpt->pwdb_all;
+
+	if (sq_rpt > 64)
+		return 0;
+	else if (sq_rpt < 20)
+		return 100;
+	else
+		return ((64 - sq_rpt) * 100) / 44;
+}
+
+static inline u8
+phydm_get_signal_quality_8192(struct dm_phy_status_info *phy_info,
+			      struct phy_dm_struct *dm,
+			      struct phy_status_rpt_8192cd *phy_sta_rpt)
+{
+	u8 sq_rpt;
+
+	if (phy_info->rx_pwdb_all > 40 && !dm->is_in_hct_test)
+		return 100;
+
+	sq_rpt = phy_sta_rpt->cck_sig_qual_ofdm_pwdb_all;
+
+	if (sq_rpt > 64)
+		return 0;
+	else if (sq_rpt < 20)
+		return 100;
+	else
+		return ((64 - sq_rpt) * 100) / 44;
+}
+
+static u8 odm_query_rx_pwr_percentage(s8 ant_power)
+{
+	if ((ant_power <= -100) || (ant_power >= 20))
+		return 0;
+	else if (ant_power >= 0)
+		return 100;
+	else
+		return 100 + ant_power;
+}
+
+/*
+ * 2012/01/12 MH MOve some signal strength smooth method to MP HAL layer.
+ * IF other SW team do not support the feature, remove this section.??
+ */
+
+s32 odm_signal_scale_mapping(struct phy_dm_struct *dm, s32 curr_sig)
+{
+	{
+		return curr_sig;
+	}
+}
+
+static u8 odm_sq_process_patch_rt_cid_819x_lenovo(struct phy_dm_struct *dm,
+						  u8 is_cck_rate, u8 pwdb_all,
+						  u8 path, u8 RSSI)
+{
+	u8 sq = 0;
+	return sq;
+}
+
+static u8 odm_evm_db_to_percentage(s8 value)
+{
+	/* -33dB~0dB to 0%~99% */
+	s8 ret_val;
+
+	ret_val = value;
+	ret_val /= 2;
+
+	if (ret_val >= 0)
+		ret_val = 0;
+
+	if (ret_val <= -33)
+		ret_val = -33;
+
+	ret_val = 0 - ret_val;
+	ret_val *= 3;
+
+	if (ret_val == 99)
+		ret_val = 100;
+
+	return (u8)ret_val;
+}
+
+static u8 odm_evm_dbm_jaguar_series(s8 value)
+{
+	s8 ret_val = value;
+
+	/* -33dB~0dB to 33dB ~ 0dB */
+	if (ret_val == -128)
+		ret_val = 127;
+	else if (ret_val < 0)
+		ret_val = 0 - ret_val;
+
+	ret_val = ret_val >> 1;
+	return (u8)ret_val;
+}
+
+static s16 odm_cfo(s8 value)
+{
+	s16 ret_val;
+
+	if (value < 0) {
+		ret_val = 0 - value;
+		ret_val = (ret_val << 1) + (ret_val >> 1); /* *2.5~=312.5/2^7 */
+		ret_val =
+			ret_val | BIT(12); /* set bit12 as 1 for negative cfo */
+	} else {
+		ret_val = value;
+		ret_val = (ret_val << 1) + (ret_val >> 1); /* *2.5~=312.5/2^7 */
+	}
+	return ret_val;
+}
+
+static u8 phydm_rate_to_num_ss(struct phy_dm_struct *dm, u8 data_rate)
+{
+	u8 num_ss = 1;
+
+	if (data_rate <= ODM_RATE54M)
+		num_ss = 1;
+	else if (data_rate <= ODM_RATEMCS31)
+		num_ss = ((data_rate - ODM_RATEMCS0) >> 3) + 1;
+	else if (data_rate <= ODM_RATEVHTSS1MCS9)
+		num_ss = 1;
+	else if (data_rate <= ODM_RATEVHTSS2MCS9)
+		num_ss = 2;
+	else if (data_rate <= ODM_RATEVHTSS3MCS9)
+		num_ss = 3;
+	else if (data_rate <= ODM_RATEVHTSS4MCS9)
+		num_ss = 4;
+
+	return num_ss;
+}
+
+static void odm_rx_phy_status92c_series_parsing(
+	struct phy_dm_struct *dm, struct dm_phy_status_info *phy_info,
+	u8 *phy_status, struct dm_per_pkt_info *pktinfo)
+{
+	u8 i, max_spatial_stream;
+	s8 rx_pwr[4], rx_pwr_all = 0;
+	u8 EVM, pwdb_all = 0, pwdb_all_bt;
+	u8 RSSI, total_rssi = 0;
+	bool is_cck_rate = false;
+	u8 rf_rx_num = 0;
+	u8 LNA_idx = 0;
+	u8 VGA_idx = 0;
+	u8 cck_agc_rpt;
+	u8 num_ss;
+	struct phy_status_rpt_8192cd *phy_sta_rpt =
+		(struct phy_status_rpt_8192cd *)phy_status;
+
+	is_cck_rate = (pktinfo->data_rate <= ODM_RATE11M) ? true : false;
+
+	if (pktinfo->is_to_self)
+		dm->curr_station_id = pktinfo->station_id;
+
+	phy_info->rx_mimo_signal_quality[ODM_RF_PATH_A] = -1;
+	phy_info->rx_mimo_signal_quality[ODM_RF_PATH_B] = -1;
+
+	if (is_cck_rate) {
+		dm->phy_dbg_info.num_qry_phy_status_cck++;
+		cck_agc_rpt = phy_sta_rpt->cck_agc_rpt_ofdm_cfosho_a;
+
+		if (dm->support_ic_type & (ODM_RTL8703B)) {
+		} else { /*3 bit LNA*/
+
+			LNA_idx = ((cck_agc_rpt & 0xE0) >> 5);
+			VGA_idx = (cck_agc_rpt & 0x1F);
+		}
+
+		ODM_RT_TRACE(
+			dm, ODM_COMP_RSSI_MONITOR,
+			"ext_lna_gain (( %d )), LNA_idx: (( 0x%x )), VGA_idx: (( 0x%x )), rx_pwr_all: (( %d ))\n",
+			dm->ext_lna_gain, LNA_idx, VGA_idx, rx_pwr_all);
+
+		if (dm->board_type & ODM_BOARD_EXT_LNA)
+			rx_pwr_all -= dm->ext_lna_gain;
+
+		pwdb_all = odm_query_rx_pwr_percentage(rx_pwr_all);
+
+		if (pktinfo->is_to_self) {
+			dm->cck_lna_idx = LNA_idx;
+			dm->cck_vga_idx = VGA_idx;
+		}
+		phy_info->rx_pwdb_all = pwdb_all;
+
+		phy_info->bt_rx_rssi_percentage = pwdb_all;
+		phy_info->recv_signal_power = rx_pwr_all;
+		/* (3) Get Signal Quality (EVM) */
+		{
+			u8 sq;
+
+			sq = phydm_get_signal_quality_8192(phy_info, dm,
+							   phy_sta_rpt);
+			phy_info->signal_quality = sq;
+			phy_info->rx_mimo_signal_quality[ODM_RF_PATH_A] = sq;
+			phy_info->rx_mimo_signal_quality[ODM_RF_PATH_B] = -1;
+		}
+
+		for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX; i++) {
+			if (i == 0)
+				phy_info->rx_mimo_signal_strength[0] = pwdb_all;
+			else
+				phy_info->rx_mimo_signal_strength[1] = 0;
+		}
+	} else { /* 2 is OFDM rate */
+		dm->phy_dbg_info.num_qry_phy_status_ofdm++;
+
+		/*  */
+		/* (1)Get RSSI for HT rate */
+		/*  */
+
+		for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX; i++) {
+			/* 2008/01/30 MH we will judge RF RX path now. */
+			if (dm->rf_path_rx_enable & BIT(i))
+				rf_rx_num++;
+			/* else */
+			/* continue; */
+
+			rx_pwr[i] =
+				((phy_sta_rpt->path_agc[i].gain & 0x3F) * 2) -
+				110;
+
+			if (pktinfo->is_to_self) {
+				dm->ofdm_agc_idx[i] =
+					(phy_sta_rpt->path_agc[i].gain & 0x3F);
+				/**/
+			}
+
+			phy_info->rx_pwr[i] = rx_pwr[i];
+
+			/* Translate DBM to percentage. */
+			RSSI = odm_query_rx_pwr_percentage(rx_pwr[i]);
+			total_rssi += RSSI;
+
+			phy_info->rx_mimo_signal_strength[i] = (u8)RSSI;
+
+			/* Get Rx snr value in DB */
+			dm->phy_dbg_info.rx_snr_db[i] =
+				(s32)(phy_sta_rpt->path_rxsnr[i] / 2);
+			phy_info->rx_snr[i] = dm->phy_dbg_info.rx_snr_db[i];
+
+			/* Record Signal Strength for next packet */
+			/* if(pktinfo->is_packet_match_bssid) */
+			{
+			}
+		}
+
+		/*  */
+		/* (2)PWDB, Average PWDB calcuated by hardware (for RA) */
+		/*  */
+		rx_pwr_all = (((phy_sta_rpt->cck_sig_qual_ofdm_pwdb_all) >> 1) &
+			      0x7f) -
+			     110;
+
+		pwdb_all = odm_query_rx_pwr_percentage(rx_pwr_all);
+		pwdb_all_bt = pwdb_all;
+
+		phy_info->rx_pwdb_all = pwdb_all;
+		phy_info->bt_rx_rssi_percentage = pwdb_all_bt;
+		phy_info->rx_power = rx_pwr_all;
+		phy_info->recv_signal_power = rx_pwr_all;
+
+		if ((dm->support_platform == ODM_WIN) && (dm->patch_id == 19)) {
+			/* do nothing */
+		} else if ((dm->support_platform == ODM_WIN) &&
+			   (dm->patch_id == 25)) {
+			/* do nothing */
+		} else { /* mgnt_info->customer_id != RT_CID_819X_LENOVO */
+			/*  */
+			/* (3)EVM of HT rate */
+			/*  */
+			if (pktinfo->data_rate >= ODM_RATEMCS8 &&
+			    pktinfo->data_rate <= ODM_RATEMCS15) {
+				/* both spatial stream make sense */
+				max_spatial_stream = 2;
+			} else {
+				/* only spatial stream 1 makes sense */
+				max_spatial_stream = 1;
+			}
+
+			for (i = 0; i < max_spatial_stream; i++) {
+				/*Don't use shift operation like "rx_evmX >>= 1"
+				 *because the compilor of free build environment
+				 *fill most significant bit to "zero" when doing
+				 *shifting operation which may change a negative
+				 *value to positive one, then the dbm value
+				 *(which is supposed to be negative)  is not
+				 *correct anymore.
+				 */
+				EVM = odm_evm_db_to_percentage(
+					(phy_sta_rpt
+						 ->stream_rxevm[i])); /* dbm */
+
+				/* Fill value in RFD, Get the first spatial
+				 * stream only
+				 */
+				if (i == ODM_RF_PATH_A)
+					phy_info->signal_quality =
+						(u8)(EVM & 0xff);
+				phy_info->rx_mimo_signal_quality[i] =
+					(u8)(EVM & 0xff);
+			}
+		}
+
+		num_ss = phydm_rate_to_num_ss(dm, pktinfo->data_rate);
+		odm_parsing_cfo(dm, pktinfo, phy_sta_rpt->path_cfotail, num_ss);
+	}
+	/* UI BSS List signal strength(in percentage), make it good looking,
+	 * from 0~100.
+	 */
+	/* It is assigned to the BSS List in GetValueFromBeaconOrProbeRsp(). */
+	if (is_cck_rate) {
+		phy_info->signal_strength = (u8)(
+			odm_signal_scale_mapping(dm, pwdb_all)); /*pwdb_all;*/
+	} else {
+		if (rf_rx_num != 0) {
+			phy_info->signal_strength =
+				(u8)(odm_signal_scale_mapping(dm, total_rssi /=
+								  rf_rx_num));
+		}
+	}
+
+	/* For 92C/92D HW (Hybrid) Antenna Diversity */
+}
+
+static void
+odm_rx_phy_bw_jaguar_series_parsing(struct dm_phy_status_info *phy_info,
+				    struct dm_per_pkt_info *pktinfo,
+				    struct phy_status_rpt_8812 *phy_sta_rpt)
+{
+	if (pktinfo->data_rate <= ODM_RATE54M) {
+		switch (phy_sta_rpt->r_RFMOD) {
+		case 1:
+			if (phy_sta_rpt->sub_chnl == 0)
+				phy_info->band_width = 1;
+			else
+				phy_info->band_width = 0;
+			break;
+
+		case 2:
+			if (phy_sta_rpt->sub_chnl == 0)
+				phy_info->band_width = 2;
+			else if (phy_sta_rpt->sub_chnl == 9 ||
+				 phy_sta_rpt->sub_chnl == 10)
+				phy_info->band_width = 1;
+			else
+				phy_info->band_width = 0;
+			break;
+
+		default:
+		case 0:
+			phy_info->band_width = 0;
+			break;
+		}
+	}
+}
+
+static void odm_rx_phy_status_jaguar_series_parsing(
+	struct phy_dm_struct *dm, struct dm_phy_status_info *phy_info,
+	u8 *phy_status, struct dm_per_pkt_info *pktinfo)
+{
+	u8 i, max_spatial_stream;
+	s8 rx_pwr[4], rx_pwr_all = 0;
+	u8 EVM = 0, evm_dbm, pwdb_all = 0, pwdb_all_bt;
+	u8 RSSI, avg_rssi = 0, best_rssi = 0, second_rssi = 0;
+	u8 is_cck_rate = 0;
+	u8 rf_rx_num = 0;
+	u8 cck_highpwr = 0;
+	u8 LNA_idx, VGA_idx;
+	struct phy_status_rpt_8812 *phy_sta_rpt =
+		(struct phy_status_rpt_8812 *)phy_status;
+	struct fast_antenna_training *fat_tab = &dm->dm_fat_table;
+	u8 num_ss;
+
+	odm_rx_phy_bw_jaguar_series_parsing(phy_info, pktinfo, phy_sta_rpt);
+
+	if (pktinfo->data_rate <= ODM_RATE11M)
+		is_cck_rate = true;
+	else
+		is_cck_rate = false;
+
+	if (pktinfo->is_to_self)
+		dm->curr_station_id = pktinfo->station_id;
+	else
+		dm->curr_station_id = 0xff;
+
+	phy_info->rx_mimo_signal_quality[ODM_RF_PATH_A] = -1;
+	phy_info->rx_mimo_signal_quality[ODM_RF_PATH_B] = -1;
+	phy_info->rx_mimo_signal_quality[ODM_RF_PATH_C] = -1;
+	phy_info->rx_mimo_signal_quality[ODM_RF_PATH_D] = -1;
+
+	if (is_cck_rate) {
+		u8 cck_agc_rpt;
+
+		dm->phy_dbg_info.num_qry_phy_status_cck++;
+
+		/*(1)Hardware does not provide RSSI for CCK*/
+		/*(2)PWDB, Average PWDB calculated by hardware (for RA)*/
+
+		cck_highpwr = dm->is_cck_high_power;
+
+		cck_agc_rpt = phy_sta_rpt->cfosho[0];
+		LNA_idx = ((cck_agc_rpt & 0xE0) >> 5);
+		VGA_idx = (cck_agc_rpt & 0x1F);
+
+		if (dm->support_ic_type == ODM_RTL8812) {
+			rx_pwr_all =
+				phydm_get_rx_pwr(LNA_idx, VGA_idx, cck_highpwr);
+			rx_pwr_all += 6;
+			pwdb_all = odm_query_rx_pwr_percentage(rx_pwr_all);
+			pwdb_all = phydm_adjust_pwdb(cck_highpwr, pwdb_all);
+
+		} else if (dm->support_ic_type & (ODM_RTL8821 | ODM_RTL8881A)) {
+			s8 pout = -6;
+
+			switch (LNA_idx) {
+			case 5:
+				rx_pwr_all = pout - 32 - (2 * VGA_idx);
+				break;
+			case 4:
+				rx_pwr_all = pout - 24 - (2 * VGA_idx);
+				break;
+			case 2:
+				rx_pwr_all = pout - 11 - (2 * VGA_idx);
+				break;
+			case 1:
+				rx_pwr_all = pout + 5 - (2 * VGA_idx);
+				break;
+			case 0:
+				rx_pwr_all = pout + 21 - (2 * VGA_idx);
+				break;
+			}
+			pwdb_all = odm_query_rx_pwr_percentage(rx_pwr_all);
+		} else if (dm->support_ic_type == ODM_RTL8814A ||
+			   dm->support_ic_type == ODM_RTL8822B) {
+			s8 pout = -6;
+
+			switch (LNA_idx) {
+			/*CCK only use LNA: 2, 3, 5, 7*/
+			case 7:
+				rx_pwr_all = pout - 32 - (2 * VGA_idx);
+				break;
+			case 5:
+				rx_pwr_all = pout - 22 - (2 * VGA_idx);
+				break;
+			case 3:
+				rx_pwr_all = pout - 2 - (2 * VGA_idx);
+				break;
+			case 2:
+				rx_pwr_all = pout + 5 - (2 * VGA_idx);
+				break;
+			default:
+				break;
+			}
+			pwdb_all = odm_query_rx_pwr_percentage(rx_pwr_all);
+		}
+
+		dm->cck_lna_idx = LNA_idx;
+		dm->cck_vga_idx = VGA_idx;
+		phy_info->rx_pwdb_all = pwdb_all;
+		phy_info->bt_rx_rssi_percentage = pwdb_all;
+		phy_info->recv_signal_power = rx_pwr_all;
+		/*(3) Get Signal Quality (EVM)*/
+		{
+			u8 sq;
+
+			if ((dm->support_platform == ODM_WIN) &&
+			    (dm->patch_id == RT_CID_819X_LENOVO))
+				sq = odm_sq_process_patch_rt_cid_819x_lenovo(
+					dm, is_cck_rate, pwdb_all, 0, 0);
+			else
+				sq = phydm_get_signal_quality_8812(phy_info, dm,
+								   phy_sta_rpt);
+
+			phy_info->signal_quality = sq;
+			phy_info->rx_mimo_signal_quality[ODM_RF_PATH_A] = sq;
+		}
+
+		for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX_JAGUAR; i++) {
+			if (i == 0)
+				phy_info->rx_mimo_signal_strength[0] = pwdb_all;
+			else
+				phy_info->rx_mimo_signal_strength[i] = 0;
+		}
+	} else {
+		/*is OFDM rate*/
+		fat_tab->hw_antsw_occur = phy_sta_rpt->hw_antsw_occur;
+
+		dm->phy_dbg_info.num_qry_phy_status_ofdm++;
+
+		/*(1)Get RSSI for OFDM rate*/
+
+		for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX_JAGUAR; i++) {
+			/*2008/01/30 MH we will judge RF RX path now.*/
+			if (dm->rf_path_rx_enable & BIT(i))
+				rf_rx_num++;
+			/*2012.05.25 LukeLee: Testchip AGC report is wrong,
+			 *it should be restored back to old formula in MP chip
+			 */
+			if (i < ODM_RF_PATH_C)
+				rx_pwr[i] = (phy_sta_rpt->gain_trsw[i] & 0x7F) -
+					    110;
+			else
+				rx_pwr[i] = (phy_sta_rpt->gain_trsw_cd[i - 2] &
+					     0x7F) -
+					    110;
+
+			phy_info->rx_pwr[i] = rx_pwr[i];
+
+			/* Translate DBM to percentage. */
+			RSSI = odm_query_rx_pwr_percentage(rx_pwr[i]);
+
+			/*total_rssi += RSSI;*/
+			/*Get the best two RSSI*/
+			if (RSSI > best_rssi && RSSI > second_rssi) {
+				second_rssi = best_rssi;
+				best_rssi = RSSI;
+			} else if (RSSI > second_rssi && RSSI <= best_rssi) {
+				second_rssi = RSSI;
+			}
+
+			phy_info->rx_mimo_signal_strength[i] = (u8)RSSI;
+
+			/*Get Rx snr value in DB*/
+			if (i < ODM_RF_PATH_C)
+				phy_info->rx_snr[i] =
+					dm->phy_dbg_info.rx_snr_db[i] =
+						phy_sta_rpt->rxsnr[i] / 2;
+			else if (dm->support_ic_type &
+				 (ODM_RTL8814A | ODM_RTL8822B))
+				phy_info->rx_snr[i] = dm->phy_dbg_info
+							      .rx_snr_db[i] =
+					phy_sta_rpt->csi_current[i - 2] / 2;
+
+			/*(2) CFO_short  & CFO_tail*/
+			if (i < ODM_RF_PATH_C) {
+				phy_info->cfo_short[i] =
+					odm_cfo((phy_sta_rpt->cfosho[i]));
+				phy_info->cfo_tail[i] =
+					odm_cfo((phy_sta_rpt->cfotail[i]));
+			}
+		}
+
+		/*(3)PWDB, Average PWDB calculated by hardware (for RA)*/
+
+		/*2012.05.25 LukeLee: Testchip AGC report is wrong, it should be
+		 *restored back to old formula in MP chip
+		 */
+		if ((dm->support_ic_type &
+		     (ODM_RTL8812 | ODM_RTL8821 | ODM_RTL8881A)) &&
+		    (!dm->is_mp_chip))
+			rx_pwr_all = (phy_sta_rpt->pwdb_all & 0x7f) - 110;
+		else
+			rx_pwr_all = (((phy_sta_rpt->pwdb_all) >> 1) & 0x7f) -
+				     110; /*OLD FORMULA*/
+
+		pwdb_all = odm_query_rx_pwr_percentage(rx_pwr_all);
+		pwdb_all_bt = pwdb_all;
+
+		phy_info->rx_pwdb_all = pwdb_all;
+		phy_info->bt_rx_rssi_percentage = pwdb_all_bt;
+		phy_info->rx_power = rx_pwr_all;
+		phy_info->recv_signal_power = rx_pwr_all;
+
+		if ((dm->support_platform == ODM_WIN) && (dm->patch_id == 19)) {
+			/*do nothing*/
+		} else {
+			/*mgnt_info->customer_id != RT_CID_819X_LENOVO*/
+
+			/*(4)EVM of OFDM rate*/
+
+			if ((pktinfo->data_rate >= ODM_RATEMCS8) &&
+			    (pktinfo->data_rate <= ODM_RATEMCS15))
+				max_spatial_stream = 2;
+			else if ((pktinfo->data_rate >= ODM_RATEVHTSS2MCS0) &&
+				 (pktinfo->data_rate <= ODM_RATEVHTSS2MCS9))
+				max_spatial_stream = 2;
+			else if ((pktinfo->data_rate >= ODM_RATEMCS16) &&
+				 (pktinfo->data_rate <= ODM_RATEMCS23))
+				max_spatial_stream = 3;
+			else if ((pktinfo->data_rate >= ODM_RATEVHTSS3MCS0) &&
+				 (pktinfo->data_rate <= ODM_RATEVHTSS3MCS9))
+				max_spatial_stream = 3;
+			else
+				max_spatial_stream = 1;
+
+			for (i = 0; i < max_spatial_stream; i++) {
+				/*Don't use shift operation like "rx_evmX >>= 1"
+				 *because the compilor of free build environment
+				 *fill most significant bit to "zero" when doing
+				 *shifting operation which may change a negative
+				 *value to positive one, then the dbm value
+				 *(which is supposed to be negative) is not
+				 *correct anymore.
+				 */
+
+				EVM = phydm_get_odm_evm(i, pktinfo,
+							phy_sta_rpt);
+				evm_dbm = phydm_get_evm_dbm(i, EVM, phy_sta_rpt,
+							    phy_info);
+				phy_info->rx_mimo_signal_quality[i] = EVM;
+				phy_info->rx_mimo_evm_dbm[i] = evm_dbm;
+			}
+		}
+
+		num_ss = phydm_rate_to_num_ss(dm, pktinfo->data_rate);
+		odm_parsing_cfo(dm, pktinfo, phy_sta_rpt->cfotail, num_ss);
+	}
+
+	/*UI BSS List signal strength(in percentage), make it good looking,
+	 *from 0~100.
+	 */
+	/*It is assigned to the BSS List in GetValueFromBeaconOrProbeRsp().*/
+	if (is_cck_rate) {
+		phy_info->signal_strength = (u8)(
+			odm_signal_scale_mapping(dm, pwdb_all)); /*pwdb_all;*/
+	} else {
+		if (rf_rx_num != 0) {
+			/* 2015/01 Sean, use the best two RSSI only,
+			 * suggested by Ynlin and ChenYu.
+			 */
+			if (rf_rx_num == 1)
+				avg_rssi = best_rssi;
+			else
+				avg_rssi = (best_rssi + second_rssi) / 2;
+			phy_info->signal_strength =
+				(u8)(odm_signal_scale_mapping(dm, avg_rssi));
+		}
+	}
+	dm->rx_pwdb_ave = dm->rx_pwdb_ave + phy_info->rx_pwdb_all;
+
+	dm->dm_fat_table.antsel_rx_keep_0 = phy_sta_rpt->antidx_anta;
+	dm->dm_fat_table.antsel_rx_keep_1 = phy_sta_rpt->antidx_antb;
+	dm->dm_fat_table.antsel_rx_keep_2 = phy_sta_rpt->antidx_antc;
+	dm->dm_fat_table.antsel_rx_keep_3 = phy_sta_rpt->antidx_antd;
+}
+
+void phydm_reset_rssi_for_dm(struct phy_dm_struct *dm, u8 station_id)
+{
+	struct rtl_sta_info *entry;
+
+	entry = dm->odm_sta_info[station_id];
+
+	if (!IS_STA_VALID(entry))
+		return;
+
+	ODM_RT_TRACE(dm, ODM_COMP_RSSI_MONITOR,
+		     "Reset RSSI for macid = (( %d ))\n", station_id);
+
+	entry->rssi_stat.undecorated_smoothed_cck = -1;
+	entry->rssi_stat.undecorated_smoothed_ofdm = -1;
+	entry->rssi_stat.undecorated_smoothed_pwdb = -1;
+	entry->rssi_stat.ofdm_pkt = 0;
+	entry->rssi_stat.cck_pkt = 0;
+	entry->rssi_stat.cck_sum_power = 0;
+	entry->rssi_stat.is_send_rssi = RA_RSSI_STATE_INIT;
+	entry->rssi_stat.packet_map = 0;
+	entry->rssi_stat.valid_bit = 0;
+}
+
+void odm_init_rssi_for_dm(struct phy_dm_struct *dm) {}
+
+static void odm_process_rssi_for_dm(struct phy_dm_struct *dm,
+				    struct dm_phy_status_info *phy_info,
+				    struct dm_per_pkt_info *pktinfo)
+{
+	s32 undecorated_smoothed_pwdb, undecorated_smoothed_cck,
+		undecorated_smoothed_ofdm;
+	u8 is_cck_rate = 0;
+	u8 send_rssi_2_fw = 0;
+	struct rtl_sta_info *entry;
+
+	if (pktinfo->station_id >= ODM_ASSOCIATE_ENTRY_NUM)
+		return;
+
+	/* 2012/05/30 MH/Luke.Lee Add some description */
+	/* In windows driver: AP/IBSS mode STA */
+	entry = dm->odm_sta_info[pktinfo->station_id];
+
+	if (!IS_STA_VALID(entry))
+		return;
+
+	{
+		if ((!pktinfo->is_packet_match_bssid)) /*data frame only*/
+			return;
+	}
+
+	if (pktinfo->is_packet_beacon)
+		dm->phy_dbg_info.num_qry_beacon_pkt++;
+
+	is_cck_rate = (pktinfo->data_rate <= ODM_RATE11M) ? true : false;
+	dm->rx_rate = pktinfo->data_rate;
+
+	/* --------------Statistic for antenna/path diversity---------------- */
+
+	/* -----------------Smart Antenna Debug Message------------------ */
+
+	undecorated_smoothed_cck = entry->rssi_stat.undecorated_smoothed_cck;
+	undecorated_smoothed_ofdm = entry->rssi_stat.undecorated_smoothed_ofdm;
+	undecorated_smoothed_pwdb = entry->rssi_stat.undecorated_smoothed_pwdb;
+
+	if (pktinfo->is_packet_to_self || pktinfo->is_packet_beacon) {
+		if (!is_cck_rate) /* ofdm rate */
+			undecorated_smoothed_ofdm = phydm_process_rssi_ofdm(
+				dm, phy_info, entry, undecorated_smoothed_ofdm);
+		else
+			undecorated_smoothed_cck = phydm_process_rssi_cck(
+				dm, phy_info, entry, undecorated_smoothed_cck);
+
+		undecorated_smoothed_pwdb = phydm_process_rssi_pwdb(
+			dm, entry, pktinfo, undecorated_smoothed_ofdm,
+			undecorated_smoothed_cck);
+
+		if ((entry->rssi_stat.ofdm_pkt >= 1 ||
+		     entry->rssi_stat.cck_pkt >= 5) &&
+		    (entry->rssi_stat.is_send_rssi == RA_RSSI_STATE_INIT)) {
+			send_rssi_2_fw = 1;
+			entry->rssi_stat.is_send_rssi = RA_RSSI_STATE_SEND;
+		}
+
+		entry->rssi_stat.undecorated_smoothed_cck =
+			undecorated_smoothed_cck;
+		entry->rssi_stat.undecorated_smoothed_ofdm =
+			undecorated_smoothed_ofdm;
+		entry->rssi_stat.undecorated_smoothed_pwdb =
+			undecorated_smoothed_pwdb;
+
+		if (send_rssi_2_fw) { /* Trigger init rate by RSSI */
+
+			if (entry->rssi_stat.ofdm_pkt != 0)
+				entry->rssi_stat.undecorated_smoothed_pwdb =
+					undecorated_smoothed_ofdm;
+
+			ODM_RT_TRACE(
+				dm, ODM_COMP_RSSI_MONITOR,
+				"[Send to FW] PWDB = (( %d )), ofdm_pkt = (( %d )), cck_pkt = (( %d ))\n",
+				undecorated_smoothed_pwdb,
+				entry->rssi_stat.ofdm_pkt,
+				entry->rssi_stat.cck_pkt);
+		}
+	}
+}
+
+/*
+ * Endianness before calling this API
+ */
+static void odm_phy_status_query_92c_series(struct phy_dm_struct *dm,
+					    struct dm_phy_status_info *phy_info,
+					    u8 *phy_status,
+					    struct dm_per_pkt_info *pktinfo)
+{
+	odm_rx_phy_status92c_series_parsing(dm, phy_info, phy_status, pktinfo);
+	odm_process_rssi_for_dm(dm, phy_info, pktinfo);
+}
+
+/*
+ * Endianness before calling this API
+ */
+
+static void odm_phy_status_query_jaguar_series(
+	struct phy_dm_struct *dm, struct dm_phy_status_info *phy_info,
+	u8 *phy_status, struct dm_per_pkt_info *pktinfo)
+{
+	odm_rx_phy_status_jaguar_series_parsing(dm, phy_info, phy_status,
+						pktinfo);
+	odm_process_rssi_for_dm(dm, phy_info, pktinfo);
+}
+
+void odm_phy_status_query(struct phy_dm_struct *dm,
+			  struct dm_phy_status_info *phy_info, u8 *phy_status,
+			  struct dm_per_pkt_info *pktinfo)
+{
+	if (dm->support_ic_type & ODM_IC_PHY_STATUE_NEW_TYPE) {
+		phydm_rx_phy_status_new_type(dm, phy_status, pktinfo, phy_info);
+		return;
+	}
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES)
+		odm_phy_status_query_jaguar_series(dm, phy_info, phy_status,
+						   pktinfo);
+
+	if (dm->support_ic_type & ODM_IC_11N_SERIES)
+		odm_phy_status_query_92c_series(dm, phy_info, phy_status,
+						pktinfo);
+}
+
+/* For future use. */
+void odm_mac_status_query(struct phy_dm_struct *dm, u8 *mac_status, u8 mac_id,
+			  bool is_packet_match_bssid, bool is_packet_to_self,
+			  bool is_packet_beacon)
+{
+	/* 2011/10/19 Driver team will handle in the future. */
+}
+
+/*
+ * If you want to add a new IC, Please follow below template and generate
+ * a new one.
+ */
+
+enum hal_status
+odm_config_rf_with_header_file(struct phy_dm_struct *dm,
+			       enum odm_rf_config_type config_type,
+			       enum odm_rf_radio_path e_rf_path)
+{
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "===>%s (%s)\n", __func__,
+		     (dm->is_mp_chip) ? "MPChip" : "TestChip");
+	ODM_RT_TRACE(
+		dm, ODM_COMP_INIT,
+		"dm->support_platform: 0x%X, dm->support_interface: 0x%X, dm->board_type: 0x%X\n",
+		dm->support_platform, dm->support_interface, dm->board_type);
+
+	/* 1 AP doesn't use PHYDM power tracking table in these ICs */
+	/* JJ ADD 20161014 */
+
+	/* 1 All platforms support */
+	if (dm->support_ic_type == ODM_RTL8822B) {
+		if (config_type == CONFIG_RF_RADIO) {
+			if (e_rf_path == ODM_RF_PATH_A)
+				READ_AND_CONFIG_MP(8822b, _radioa);
+			else if (e_rf_path == ODM_RF_PATH_B)
+				READ_AND_CONFIG_MP(8822b, _radiob);
+		} else if (config_type == CONFIG_RF_TXPWR_LMT) {
+			if (dm->rfe_type == 5)
+				READ_AND_CONFIG_MP(8822b, _txpwr_lmt_type5);
+			else
+				READ_AND_CONFIG_MP(8822b, _txpwr_lmt);
+		}
+	}
+
+	return HAL_STATUS_SUCCESS;
+}
+
+enum hal_status
+odm_config_rf_with_tx_pwr_track_header_file(struct phy_dm_struct *dm)
+{
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "===>%s (%s)\n", __func__,
+		     (dm->is_mp_chip) ? "MPChip" : "TestChip");
+	ODM_RT_TRACE(
+		dm, ODM_COMP_INIT,
+		"dm->support_platform: 0x%X, dm->support_interface: 0x%X, dm->board_type: 0x%X\n",
+		dm->support_platform, dm->support_interface, dm->board_type);
+
+	/* 1 AP doesn't use PHYDM power tracking table in these ICs */
+	/* JJ ADD 20161014 */
+
+	/* 1 All platforms support */
+
+	if (dm->support_ic_type == ODM_RTL8822B) {
+		if (dm->rfe_type == 0)
+			READ_AND_CONFIG_MP(8822b, _txpowertrack_type0);
+		else if (dm->rfe_type == 1)
+			READ_AND_CONFIG_MP(8822b, _txpowertrack_type1);
+		else if (dm->rfe_type == 2)
+			READ_AND_CONFIG_MP(8822b, _txpowertrack_type2);
+		else if ((dm->rfe_type == 3) || (dm->rfe_type == 5))
+			READ_AND_CONFIG_MP(8822b, _txpowertrack_type3_type5);
+		else if (dm->rfe_type == 4)
+			READ_AND_CONFIG_MP(8822b, _txpowertrack_type4);
+		else if (dm->rfe_type == 6)
+			READ_AND_CONFIG_MP(8822b, _txpowertrack_type6);
+		else if (dm->rfe_type == 7)
+			READ_AND_CONFIG_MP(8822b, _txpowertrack_type7);
+		else if (dm->rfe_type == 8)
+			READ_AND_CONFIG_MP(8822b, _txpowertrack_type8);
+		else if (dm->rfe_type == 9)
+			READ_AND_CONFIG_MP(8822b, _txpowertrack_type9);
+		else
+			READ_AND_CONFIG_MP(8822b, _txpowertrack);
+	}
+
+	return HAL_STATUS_SUCCESS;
+}
+
+enum hal_status
+odm_config_bb_with_header_file(struct phy_dm_struct *dm,
+			       enum odm_bb_config_type config_type)
+{
+	/* 1 AP doesn't use PHYDM initialization in these ICs */
+	/* JJ ADD 20161014 */
+
+	/* 1 All platforms support */
+	if (dm->support_ic_type == ODM_RTL8822B) {
+		if (config_type == CONFIG_BB_PHY_REG)
+			READ_AND_CONFIG_MP(8822b, _phy_reg);
+		else if (config_type == CONFIG_BB_AGC_TAB)
+			READ_AND_CONFIG_MP(8822b, _agc_tab);
+		else if (config_type == CONFIG_BB_PHY_REG_PG)
+			READ_AND_CONFIG_MP(8822b, _phy_reg_pg);
+		/*else if (config_type == CONFIG_BB_PHY_REG_MP)*/
+		/*READ_AND_CONFIG_MP(8822b, _phy_reg_mp);*/
+	}
+
+	return HAL_STATUS_SUCCESS;
+}
+
+enum hal_status odm_config_mac_with_header_file(struct phy_dm_struct *dm)
+{
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "===>%s (%s)\n", __func__,
+		     (dm->is_mp_chip) ? "MPChip" : "TestChip");
+	ODM_RT_TRACE(
+		dm, ODM_COMP_INIT,
+		"dm->support_platform: 0x%X, dm->support_interface: 0x%X, dm->board_type: 0x%X\n",
+		dm->support_platform, dm->support_interface, dm->board_type);
+
+	/* 1 AP doesn't use PHYDM initialization in these ICs */
+	/* JJ ADD 20161014 */
+
+	/* 1 All platforms support */
+	if (dm->support_ic_type == ODM_RTL8822B)
+		READ_AND_CONFIG_MP(8822b, _mac_reg);
+
+	return HAL_STATUS_SUCCESS;
+}
+
+enum hal_status
+odm_config_fw_with_header_file(struct phy_dm_struct *dm,
+			       enum odm_fw_config_type config_type,
+			       u8 *p_firmware, u32 *size)
+{
+	return HAL_STATUS_SUCCESS;
+}
+
+u32 odm_get_hw_img_version(struct phy_dm_struct *dm)
+{
+	u32 version = 0;
+
+	/* 1 AP doesn't use PHYDM initialization in these ICs */
+	/* JJ ADD 20161014 */
+
+	/*1 All platforms support*/
+	if (dm->support_ic_type == ODM_RTL8822B)
+		version = GET_VERSION_MP(8822b, _mac_reg);
+
+	return version;
+}
+
+/* For 8822B only!! need to move to FW finally */
+/*==============================================*/
+
+bool phydm_query_is_mu_api(struct phy_dm_struct *phydm, u8 ppdu_idx,
+			   u8 *p_data_rate, u8 *p_gid)
+{
+	u8 data_rate = 0, gid = 0;
+	bool is_mu = false;
+
+	data_rate = phydm->phy_dbg_info.num_of_ppdu[ppdu_idx];
+	gid = phydm->phy_dbg_info.gid_num[ppdu_idx];
+
+	if (data_rate & BIT(7)) {
+		is_mu = true;
+		data_rate = data_rate & ~(BIT(7));
+	} else {
+		is_mu = false;
+	}
+
+	*p_data_rate = data_rate;
+	*p_gid = gid;
+
+	return is_mu;
+}
+
+static void phydm_rx_statistic_cal(struct phy_dm_struct *phydm, u8 *phy_status,
+				   struct dm_per_pkt_info *pktinfo)
+{
+	struct phy_status_rpt_jaguar2_type1 *phy_sta_rpt =
+		(struct phy_status_rpt_jaguar2_type1 *)phy_status;
+	u8 date_rate = pktinfo->data_rate & ~(BIT(7));
+
+	if ((phy_sta_rpt->gid != 0) && (phy_sta_rpt->gid != 63)) {
+		if (date_rate >= ODM_RATEVHTSS1MCS0) {
+			phydm->phy_dbg_info
+				.num_qry_mu_vht_pkt[date_rate - 0x2C]++;
+			phydm->phy_dbg_info.num_of_ppdu[pktinfo->ppdu_cnt] =
+				date_rate | BIT(7);
+			phydm->phy_dbg_info.gid_num[pktinfo->ppdu_cnt] =
+				phy_sta_rpt->gid;
+		}
+
+	} else {
+		if (date_rate >= ODM_RATEVHTSS1MCS0) {
+			phydm->phy_dbg_info.num_qry_vht_pkt[date_rate - 0x2C]++;
+			phydm->phy_dbg_info.num_of_ppdu[pktinfo->ppdu_cnt] =
+				date_rate;
+			phydm->phy_dbg_info.gid_num[pktinfo->ppdu_cnt] =
+				phy_sta_rpt->gid;
+		}
+	}
+}
+
+static void phydm_reset_phy_info(struct phy_dm_struct *phydm,
+				 struct dm_phy_status_info *phy_info)
+{
+	phy_info->rx_pwdb_all = 0;
+	phy_info->signal_quality = 0;
+	phy_info->band_width = 0;
+	phy_info->rx_count = 0;
+	odm_memory_set(phydm, phy_info->rx_mimo_signal_quality, 0, 4);
+	odm_memory_set(phydm, phy_info->rx_mimo_signal_strength, 0, 4);
+	odm_memory_set(phydm, phy_info->rx_snr, 0, 4);
+
+	phy_info->rx_power = -110;
+	phy_info->recv_signal_power = -110;
+	phy_info->bt_rx_rssi_percentage = 0;
+	phy_info->signal_strength = 0;
+	phy_info->bt_coex_pwr_adjust = 0;
+	phy_info->channel = 0;
+	phy_info->is_mu_packet = 0;
+	phy_info->is_beamformed = 0;
+	phy_info->rxsc = 0;
+	odm_memory_set(phydm, phy_info->rx_pwr, -110, 4);
+	odm_memory_set(phydm, phy_info->rx_mimo_evm_dbm, 0, 4);
+	odm_memory_set(phydm, phy_info->cfo_short, 0, 8);
+	odm_memory_set(phydm, phy_info->cfo_tail, 0, 8);
+}
+
+static void phydm_set_per_path_phy_info(u8 rx_path, s8 rx_pwr, s8 rx_evm,
+					s8 cfo_tail, s8 rx_snr,
+					struct dm_phy_status_info *phy_info)
+{
+	u8 evm_dbm = 0;
+	u8 evm_percentage = 0;
+
+	/* SNR is S(8,1), EVM is S(8,1), CFO is S(8,7) */
+
+	if (rx_evm < 0) {
+		/* Calculate EVM in dBm */
+		evm_dbm = ((u8)(0 - rx_evm) >> 1);
+
+		/* Calculate EVM in percentage */
+		if (evm_dbm >= 33)
+			evm_percentage = 100;
+		else
+			evm_percentage = (evm_dbm << 1) + (evm_dbm);
+	}
+
+	phy_info->rx_pwr[rx_path] = rx_pwr;
+	phy_info->rx_mimo_evm_dbm[rx_path] = evm_dbm;
+
+	/* CFO = CFO_tail * 312.5 / 2^7 ~= CFO tail * 39/512 (kHz)*/
+	phy_info->cfo_tail[rx_path] = cfo_tail;
+	phy_info->cfo_tail[rx_path] = ((phy_info->cfo_tail[rx_path] << 5) +
+				       (phy_info->cfo_tail[rx_path] << 2) +
+				       (phy_info->cfo_tail[rx_path] << 1) +
+				       (phy_info->cfo_tail[rx_path])) >>
+				      9;
+
+	phy_info->rx_mimo_signal_strength[rx_path] =
+		odm_query_rx_pwr_percentage(rx_pwr);
+	phy_info->rx_mimo_signal_quality[rx_path] = evm_percentage;
+	phy_info->rx_snr[rx_path] = rx_snr >> 1;
+}
+
+static void phydm_set_common_phy_info(s8 rx_power, u8 channel,
+				      bool is_beamformed, bool is_mu_packet,
+				      u8 bandwidth, u8 signal_quality, u8 rxsc,
+				      struct dm_phy_status_info *phy_info)
+{
+	phy_info->rx_power = rx_power; /* RSSI in dB */
+	phy_info->recv_signal_power = rx_power; /* RSSI in dB */
+	phy_info->channel = channel; /* channel number */
+	phy_info->is_beamformed = is_beamformed; /* apply BF */
+	phy_info->is_mu_packet = is_mu_packet; /* MU packet */
+	phy_info->rxsc = rxsc;
+	phy_info->rx_pwdb_all =
+		odm_query_rx_pwr_percentage(rx_power); /* RSSI in percentage */
+	phy_info->signal_quality = signal_quality; /* signal quality */
+	phy_info->band_width = bandwidth; /* bandwidth */
+}
+
+static void phydm_get_rx_phy_status_type0(struct phy_dm_struct *dm,
+					  u8 *phy_status,
+					  struct dm_per_pkt_info *pktinfo,
+					  struct dm_phy_status_info *phy_info)
+{
+	/* type 0 is used for cck packet */
+
+	struct phy_status_rpt_jaguar2_type0 *phy_sta_rpt =
+		(struct phy_status_rpt_jaguar2_type0 *)phy_status;
+	u8 sq = 0;
+	s8 rx_power = phy_sta_rpt->pwdb - 110;
+
+	/* JJ ADD 20161014 */
+
+	/* Calculate Signal Quality*/
+	if (pktinfo->is_packet_match_bssid) {
+		if (phy_sta_rpt->signal_quality >= 64) {
+			sq = 0;
+		} else if (phy_sta_rpt->signal_quality <= 20) {
+			sq = 100;
+		} else {
+			/* mapping to 2~99% */
+			sq = 64 - phy_sta_rpt->signal_quality;
+			sq = ((sq << 3) + sq) >> 2;
+		}
+	}
+
+	/* Modify CCK PWDB if old AGC */
+	if (!dm->cck_new_agc) {
+		u8 lna_idx, vga_idx;
+
+		lna_idx = ((phy_sta_rpt->lna_h << 3) | phy_sta_rpt->lna_l);
+		vga_idx = phy_sta_rpt->vga;
+
+		/* JJ ADD 20161014 */
+
+		/* Need to do !! */
+		/*if (dm->support_ic_type & ODM_RTL8822B) */
+		/*rx_power = odm_CCKRSSI_8822B(LNA_idx, VGA_idx);*/
+	}
+
+	/* Update CCK packet counter */
+	dm->phy_dbg_info.num_qry_phy_status_cck++;
+
+	/*CCK no STBC and LDPC*/
+	dm->phy_dbg_info.is_ldpc_pkt = false;
+	dm->phy_dbg_info.is_stbc_pkt = false;
+
+	/* Update Common information */
+	phydm_set_common_phy_info(rx_power, phy_sta_rpt->channel, false, false,
+				  ODM_BW20M, sq, phy_sta_rpt->rxsc, phy_info);
+
+	/* Update CCK pwdb */
+	/* Update per-path information */
+	phydm_set_per_path_phy_info(ODM_RF_PATH_A, rx_power, 0, 0, 0, phy_info);
+
+	dm->dm_fat_table.antsel_rx_keep_0 = phy_sta_rpt->antidx_a;
+	dm->dm_fat_table.antsel_rx_keep_1 = phy_sta_rpt->antidx_b;
+	dm->dm_fat_table.antsel_rx_keep_2 = phy_sta_rpt->antidx_c;
+	dm->dm_fat_table.antsel_rx_keep_3 = phy_sta_rpt->antidx_d;
+}
+
+static void phydm_get_rx_phy_status_type1(struct phy_dm_struct *dm,
+					  u8 *phy_status,
+					  struct dm_per_pkt_info *pktinfo,
+					  struct dm_phy_status_info *phy_info)
+{
+	/* type 1 is used for ofdm packet */
+
+	struct phy_status_rpt_jaguar2_type1 *phy_sta_rpt =
+		(struct phy_status_rpt_jaguar2_type1 *)phy_status;
+	s8 rx_pwr_db = -120;
+	u8 i, rxsc, bw = ODM_BW20M, rx_count = 0;
+	bool is_mu;
+	u8 num_ss;
+
+	/* Update OFDM packet counter */
+	dm->phy_dbg_info.num_qry_phy_status_ofdm++;
+
+	/* Update per-path information */
+	for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX_JAGUAR; i++) {
+		if (dm->rx_ant_status & BIT(i)) {
+			s8 rx_path_pwr_db;
+
+			/* RX path counter */
+			rx_count++;
+
+			/* Update per-path information
+			 * (RSSI_dB RSSI_percentage EVM SNR CFO sq)
+			 */
+			/* EVM report is reported by stream, not path */
+			rx_path_pwr_db = phy_sta_rpt->pwdb[i] -
+					 110; /* per-path pwdb in dB domain */
+			phydm_set_per_path_phy_info(
+				i, rx_path_pwr_db,
+				phy_sta_rpt->rxevm[rx_count - 1],
+				phy_sta_rpt->cfo_tail[i], phy_sta_rpt->rxsnr[i],
+				phy_info);
+
+			/* search maximum pwdb */
+			if (rx_path_pwr_db > rx_pwr_db)
+				rx_pwr_db = rx_path_pwr_db;
+		}
+	}
+
+	/* mapping RX counter from 1~4 to 0~3 */
+	if (rx_count > 0)
+		phy_info->rx_count = rx_count - 1;
+
+	/* Check if MU packet or not */
+	if ((phy_sta_rpt->gid != 0) && (phy_sta_rpt->gid != 63)) {
+		is_mu = true;
+		dm->phy_dbg_info.num_qry_mu_pkt++;
+	} else {
+		is_mu = false;
+	}
+
+	/* count BF packet */
+	dm->phy_dbg_info.num_qry_bf_pkt =
+		dm->phy_dbg_info.num_qry_bf_pkt + phy_sta_rpt->beamformed;
+
+	/*STBC or LDPC pkt*/
+	dm->phy_dbg_info.is_ldpc_pkt = phy_sta_rpt->ldpc;
+	dm->phy_dbg_info.is_stbc_pkt = phy_sta_rpt->stbc;
+
+	/* Check sub-channel */
+	if ((pktinfo->data_rate > ODM_RATE11M) &&
+	    (pktinfo->data_rate < ODM_RATEMCS0))
+		rxsc = phy_sta_rpt->l_rxsc;
+	else
+		rxsc = phy_sta_rpt->ht_rxsc;
+
+	/* Check RX bandwidth */
+	if (dm->support_ic_type & ODM_RTL8822B) {
+		if ((rxsc >= 1) && (rxsc <= 8))
+			bw = ODM_BW20M;
+		else if ((rxsc >= 9) && (rxsc <= 12))
+			bw = ODM_BW40M;
+		else if (rxsc >= 13)
+			bw = ODM_BW80M;
+		else
+			bw = phy_sta_rpt->rf_mode;
+	} else if (dm->support_ic_type & (ODM_RTL8197F | ODM_RTL8723D |
+					  ODM_RTL8710B)) { /* JJ ADD 20161014 */
+		if (phy_sta_rpt->rf_mode == 0)
+			bw = ODM_BW20M;
+		else if ((rxsc == 1) || (rxsc == 2))
+			bw = ODM_BW20M;
+		else
+			bw = ODM_BW40M;
+	}
+
+	/* Update packet information */
+	phydm_set_common_phy_info(
+		rx_pwr_db, phy_sta_rpt->channel, (bool)phy_sta_rpt->beamformed,
+		is_mu, bw, odm_evm_db_to_percentage(phy_sta_rpt->rxevm[0]),
+		rxsc, phy_info);
+
+	num_ss = phydm_rate_to_num_ss(dm, pktinfo->data_rate);
+
+	odm_parsing_cfo(dm, pktinfo, phy_sta_rpt->cfo_tail, num_ss);
+	dm->dm_fat_table.antsel_rx_keep_0 = phy_sta_rpt->antidx_a;
+	dm->dm_fat_table.antsel_rx_keep_1 = phy_sta_rpt->antidx_b;
+	dm->dm_fat_table.antsel_rx_keep_2 = phy_sta_rpt->antidx_c;
+	dm->dm_fat_table.antsel_rx_keep_3 = phy_sta_rpt->antidx_d;
+
+	if (pktinfo->is_packet_match_bssid) {
+		/* */
+		phydm_rx_statistic_cal(dm, phy_status, pktinfo);
+	}
+}
+
+static void phydm_get_rx_phy_status_type2(struct phy_dm_struct *dm,
+					  u8 *phy_status,
+					  struct dm_per_pkt_info *pktinfo,
+					  struct dm_phy_status_info *phy_info)
+{
+	struct phy_status_rpt_jaguar2_type2 *phy_sta_rpt =
+		(struct phy_status_rpt_jaguar2_type2 *)phy_status;
+	s8 rx_pwr_db = -120;
+	u8 i, rxsc, bw = ODM_BW20M, rx_count = 0;
+
+	/* Update OFDM packet counter */
+	dm->phy_dbg_info.num_qry_phy_status_ofdm++;
+
+	/* Update per-path information */
+	for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX_JAGUAR; i++) {
+		if (dm->rx_ant_status & BIT(i)) {
+			s8 rx_path_pwr_db;
+
+			/* RX path counter */
+			rx_count++;
+
+			/* Update per-path information
+			 * (RSSI_dB RSSI_percentage EVM SNR CFO sq)
+			 */
+			rx_path_pwr_db = phy_sta_rpt->pwdb[i] -
+					 110; /* per-path pwdb in dB domain */
+
+			phydm_set_per_path_phy_info(i, rx_path_pwr_db, 0, 0, 0,
+						    phy_info);
+
+			/* search maximum pwdb */
+			if (rx_path_pwr_db > rx_pwr_db)
+				rx_pwr_db = rx_path_pwr_db;
+		}
+	}
+
+	/* mapping RX counter from 1~4 to 0~3 */
+	if (rx_count > 0)
+		phy_info->rx_count = rx_count - 1;
+
+	/* Check RX sub-channel */
+	if ((pktinfo->data_rate > ODM_RATE11M) &&
+	    (pktinfo->data_rate < ODM_RATEMCS0))
+		rxsc = phy_sta_rpt->l_rxsc;
+	else
+		rxsc = phy_sta_rpt->ht_rxsc;
+
+	/*STBC or LDPC pkt*/
+	dm->phy_dbg_info.is_ldpc_pkt = phy_sta_rpt->ldpc;
+	dm->phy_dbg_info.is_stbc_pkt = phy_sta_rpt->stbc;
+
+	/* Check RX bandwidth */
+	/* the BW information of sc=0 is useless, because there is
+	 * no information of RF mode
+	 */
+
+	if (dm->support_ic_type & ODM_RTL8822B) {
+		if ((rxsc >= 1) && (rxsc <= 8))
+			bw = ODM_BW20M;
+		else if ((rxsc >= 9) && (rxsc <= 12))
+			bw = ODM_BW40M;
+		else if (rxsc >= 13)
+			bw = ODM_BW80M;
+		else
+			bw = ODM_BW20M;
+	} else if (dm->support_ic_type & (ODM_RTL8197F | ODM_RTL8723D |
+					  ODM_RTL8710B)) { /* JJ ADD 20161014 */
+		if (rxsc == 3)
+			bw = ODM_BW40M;
+		else if ((rxsc == 1) || (rxsc == 2))
+			bw = ODM_BW20M;
+		else
+			bw = ODM_BW20M;
+	}
+
+	/* Update packet information */
+	phydm_set_common_phy_info(rx_pwr_db, phy_sta_rpt->channel,
+				  (bool)phy_sta_rpt->beamformed, false, bw, 0,
+				  rxsc, phy_info);
+}
+
+static void
+phydm_process_rssi_for_dm_new_type(struct phy_dm_struct *dm,
+				   struct dm_phy_status_info *phy_info,
+				   struct dm_per_pkt_info *pktinfo)
+{
+	s32 undecorated_smoothed_pwdb, accumulate_pwdb;
+	u32 rssi_ave;
+	u8 i;
+	struct rtl_sta_info *entry;
+	u8 scaling_factor = 4;
+
+	if (pktinfo->station_id >= ODM_ASSOCIATE_ENTRY_NUM)
+		return;
+
+	entry = dm->odm_sta_info[pktinfo->station_id];
+
+	if (!IS_STA_VALID(entry))
+		return;
+
+	if ((!pktinfo->is_packet_match_bssid)) /*data frame only*/
+		return;
+
+	if (pktinfo->is_packet_beacon)
+		dm->phy_dbg_info.num_qry_beacon_pkt++;
+
+	if (pktinfo->is_packet_to_self || pktinfo->is_packet_beacon) {
+		u32 rssi_linear = 0;
+
+		dm->rx_rate = pktinfo->data_rate;
+		undecorated_smoothed_pwdb =
+			entry->rssi_stat.undecorated_smoothed_pwdb;
+		accumulate_pwdb = dm->accumulate_pwdb[pktinfo->station_id];
+		dm->rssi_a = phy_info->rx_mimo_signal_strength[ODM_RF_PATH_A];
+		dm->rssi_b = phy_info->rx_mimo_signal_strength[ODM_RF_PATH_B];
+		dm->rssi_c = phy_info->rx_mimo_signal_strength[ODM_RF_PATH_C];
+		dm->rssi_d = phy_info->rx_mimo_signal_strength[ODM_RF_PATH_D];
+
+		for (i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX_JAGUAR; i++) {
+			if (phy_info->rx_mimo_signal_strength[i] != 0)
+				rssi_linear += odm_convert_to_linear(
+					phy_info->rx_mimo_signal_strength[i]);
+		}
+
+		switch (phy_info->rx_count + 1) {
+		case 2:
+			rssi_linear = (rssi_linear >> 1);
+			break;
+		case 3:
+			/* rssi_linear/3 ~ rssi_linear*11/32 */
+			rssi_linear = ((rssi_linear) + (rssi_linear << 1) +
+				       (rssi_linear << 3)) >>
+				      5;
+			break;
+		case 4:
+			rssi_linear = (rssi_linear >> 2);
+			break;
+		}
+		rssi_ave = odm_convert_to_db(rssi_linear);
+
+		if (undecorated_smoothed_pwdb <= 0) {
+			accumulate_pwdb =
+				(phy_info->rx_pwdb_all << scaling_factor);
+			undecorated_smoothed_pwdb = phy_info->rx_pwdb_all;
+		} else {
+			accumulate_pwdb = accumulate_pwdb -
+					  (accumulate_pwdb >> scaling_factor) +
+					  rssi_ave;
+			undecorated_smoothed_pwdb =
+				(accumulate_pwdb +
+				 (1 << (scaling_factor - 1))) >>
+				scaling_factor;
+		}
+
+		entry->rssi_stat.undecorated_smoothed_pwdb =
+			undecorated_smoothed_pwdb;
+		dm->accumulate_pwdb[pktinfo->station_id] = accumulate_pwdb;
+	}
+}
+
+void phydm_rx_phy_status_new_type(struct phy_dm_struct *phydm, u8 *phy_status,
+				  struct dm_per_pkt_info *pktinfo,
+				  struct dm_phy_status_info *phy_info)
+{
+	u8 phy_status_type = (*phy_status & 0xf);
+
+	/* Memory reset */
+	phydm_reset_phy_info(phydm, phy_info);
+
+	/* Phy status parsing */
+	switch (phy_status_type) {
+	case 0: {
+		phydm_get_rx_phy_status_type0(phydm, phy_status, pktinfo,
+					      phy_info);
+		break;
+	}
+	case 1: {
+		phydm_get_rx_phy_status_type1(phydm, phy_status, pktinfo,
+					      phy_info);
+		break;
+	}
+	case 2: {
+		phydm_get_rx_phy_status_type2(phydm, phy_status, pktinfo,
+					      phy_info);
+		break;
+	}
+	default:
+		return;
+	}
+
+	/* Update signal strength to UI, and phy_info->rx_pwdb_all is the
+	 * maximum RSSI of all path
+	 */
+	phy_info->signal_strength =
+		(u8)(odm_signal_scale_mapping(phydm, phy_info->rx_pwdb_all));
+
+	/* Calculate average RSSI and smoothed RSSI */
+	phydm_process_rssi_for_dm_new_type(phydm, phy_info, pktinfo);
+}
+
+u32 query_phydm_trx_capability(struct phy_dm_struct *dm)
+{
+	u32 value32 = 0xFFFFFFFF;
+
+	return value32;
+}
+
+u32 query_phydm_stbc_capability(struct phy_dm_struct *dm)
+{
+	u32 value32 = 0xFFFFFFFF;
+
+	return value32;
+}
+
+u32 query_phydm_ldpc_capability(struct phy_dm_struct *dm)
+{
+	u32 value32 = 0xFFFFFFFF;
+
+	return value32;
+}
+
+u32 query_phydm_txbf_parameters(struct phy_dm_struct *dm)
+{
+	u32 value32 = 0xFFFFFFFF;
+
+	return value32;
+}
+
+u32 query_phydm_txbf_capability(struct phy_dm_struct *dm)
+{
+	u32 value32 = 0xFFFFFFFF;
+
+	return value32;
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_hwconfig.h b/drivers/staging/rtlwifi/phydm/phydm_hwconfig.h
new file mode 100644
index 000000000000..ec94c61df2b9
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_hwconfig.h
@@ -0,0 +1,510 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __HALHWOUTSRC_H__
+#define __HALHWOUTSRC_H__
+
+/*--------------------------Define -------------------------------------------*/
+#define CCK_RSSI_INIT_COUNT 5
+
+#define RA_RSSI_STATE_INIT 0
+#define RA_RSSI_STATE_SEND 1
+#define RA_RSSI_STATE_HOLD 2
+
+#define CFO_HW_RPT_2_MHZ(val) ((val << 1) + (val >> 1))
+/* ((X* 3125)  / 10)>>7 = (X*10)>>2 = X*2.5 = X<<1 + X>>1  */
+
+#define AGC_DIFF_CONFIG_MP(ic, band)                                           \
+	(odm_read_and_config_mp_##ic##_agc_tab_diff(                           \
+		dm, array_mp_##ic##_agc_tab_diff_##band,                       \
+		sizeof(array_mp_##ic##_agc_tab_diff_##band) / sizeof(u32)))
+#define AGC_DIFF_CONFIG_TC(ic, band)                                           \
+	(odm_read_and_config_tc_##ic##_agc_tab_diff(                           \
+		dm, array_tc_##ic##_agc_tab_diff_##band,                       \
+		sizeof(array_tc_##ic##_agc_tab_diff_##band) / sizeof(u32)))
+
+#define AGC_DIFF_CONFIG(ic, band)                                              \
+	do {                                                                   \
+		if (dm->is_mp_chip)                                            \
+			AGC_DIFF_CONFIG_MP(ic, band);                          \
+		else                                                           \
+			AGC_DIFF_CONFIG_TC(ic, band);                          \
+	} while (0)
+
+/* ************************************************************
+ * structure and define
+ * *************************************************************/
+
+struct phy_rx_agc_info {
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 gain : 7, trsw : 1;
+#else
+	u8 trsw : 1, gain : 7;
+#endif
+};
+
+struct phy_status_rpt_8192cd {
+	struct phy_rx_agc_info path_agc[2];
+	u8 ch_corr[2];
+	u8 cck_sig_qual_ofdm_pwdb_all;
+	u8 cck_agc_rpt_ofdm_cfosho_a;
+	u8 cck_rpt_b_ofdm_cfosho_b;
+	u8 rsvd_1; /*ch_corr_msb;*/
+	u8 noise_power_db_msb;
+	s8 path_cfotail[2];
+	u8 pcts_mask[2];
+	s8 stream_rxevm[2];
+	u8 path_rxsnr[2];
+	u8 noise_power_db_lsb;
+	u8 rsvd_2[3];
+	u8 stream_csi[2];
+	u8 stream_target_csi[2];
+	s8 sig_evm;
+	u8 rsvd_3;
+
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 antsel_rx_keep_2 : 1; /*ex_intf_flg:1;*/
+	u8 sgi_en : 1;
+	u8 rxsc : 2;
+	u8 idle_long : 1;
+	u8 r_ant_train_en : 1;
+	u8 ant_sel_b : 1;
+	u8 ant_sel : 1;
+#else /*_BIG_ENDIAN_	*/
+	u8 ant_sel : 1;
+	u8 ant_sel_b : 1;
+	u8 r_ant_train_en : 1;
+	u8 idle_long : 1;
+	u8 rxsc : 2;
+	u8 sgi_en : 1;
+	u8 antsel_rx_keep_2 : 1; /*ex_intf_flg:1;*/
+#endif
+};
+
+struct phy_status_rpt_8812 {
+	/*	DWORD 0*/
+	u8 gain_trsw[2]; /*path-A and path-B {TRSW, gain[6:0] }*/
+	u8 chl_num_LSB; /*channel number[7:0]*/
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 chl_num_MSB : 2; /*channel number[9:8]*/
+	u8 sub_chnl : 4; /*sub-channel location[3:0]*/
+	u8 r_RFMOD : 2; /*RF mode[1:0]*/
+#else /*_BIG_ENDIAN_	*/
+	u8 r_RFMOD : 2;
+	u8 sub_chnl : 4;
+	u8 chl_num_MSB : 2;
+#endif
+
+	/*	DWORD 1*/
+	u8 pwdb_all; /*CCK signal quality / OFDM pwdb all*/
+	s8 cfosho[2]; /*DW1 byte 1 DW1 byte2 */
+/*CCK AGC report and CCK_BB_Power / OFDM path-A and path-B short CFO*/
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	/*this should be checked again
+	 *because the definition of 8812 and 8814 is different
+	 */
+	u8 resvd_0 : 6;
+	u8 bt_RF_ch_MSB : 2; /*8812A:2'b0, 8814A: bt rf channel keep[7:6]*/
+#else /*_BIG_ENDIAN_*/
+	u8 bt_RF_ch_MSB : 2;
+	u8 resvd_0 : 6;
+#endif
+
+/*	DWORD 2*/
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 ant_div_sw_a : 1; /*8812A: ant_div_sw_a, 8814A: 1'b0*/
+	u8 ant_div_sw_b : 1; /*8812A: ant_div_sw_b, 8814A: 1'b0*/
+	u8 bt_RF_ch_LSB : 6; /*8812A: 6'b0, 8814A: bt rf channel keep[5:0]*/
+#else /*_BIG_ENDIAN_	*/
+	u8 bt_RF_ch_LSB : 6;
+	u8 ant_div_sw_b : 1;
+	u8 ant_div_sw_a : 1;
+#endif
+	s8 cfotail[2]; /*DW2 byte 1 DW2 byte 2	path-A and path-B CFO tail*/
+	u8 PCTS_MSK_RPT_0; /*PCTS mask report[7:0]*/
+	u8 PCTS_MSK_RPT_1; /*PCTS mask report[15:8]*/
+
+	/*	DWORD 3*/
+	s8 rxevm[2]; /*DW3 byte 1 DW3 byte 2	stream 1 and stream 2 RX EVM*/
+	s8 rxsnr[2]; /*DW3 byte 3 DW4 byte 0	path-A and path-B RX SNR*/
+
+	/*	DWORD 4*/
+	u8 PCTS_MSK_RPT_2; /*PCTS mask report[23:16]*/
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 PCTS_MSK_RPT_3 : 6; /*PCTS mask report[29:24]*/
+	u8 pcts_rpt_valid : 1; /*pcts_rpt_valid*/
+	u8 resvd_1 : 1; /*1'b0*/
+#else /*_BIG_ENDIAN_*/
+	u8 resvd_1 : 1;
+	u8 pcts_rpt_valid : 1;
+	u8 PCTS_MSK_RPT_3 : 6;
+#endif
+	s8 rxevm_cd[2]; /*DW 4 byte 3 DW5 byte 0 */
+	/* 8812A: 16'b0, 8814A: stream 3 and stream 4 RX EVM*/
+
+	/*	DWORD 5*/
+	u8 csi_current[2]; /*DW5 byte 1 DW5 byte 2 */
+	/* 8812A: stream 1 and 2 CSI, 8814A: path-C and path-D RX SNR*/
+	u8 gain_trsw_cd[2]; /*DW5 byte 3 DW6 byte 0 */
+	/* path-C and path-D {TRSW, gain[6:0] }*/
+
+	/*	DWORD 6*/
+	s8 sigevm; /*signal field EVM*/
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 antidx_antc : 3; /*8812A: 3'b0	8814A: antidx_antc[2:0]*/
+	u8 antidx_antd : 3; /*8812A: 3'b0	8814A: antidx_antd[2:0]*/
+	u8 dpdt_ctrl_keep : 1; /*8812A: 1'b0	8814A: dpdt_ctrl_keep*/
+	u8 GNT_BT_keep : 1; /*8812A: 1'b0	8814A: GNT_BT_keep*/
+#else /*_BIG_ENDIAN_*/
+	u8 GNT_BT_keep : 1;
+	u8 dpdt_ctrl_keep : 1;
+	u8 antidx_antd : 3;
+	u8 antidx_antc : 3;
+#endif
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 antidx_anta : 3; /*antidx_anta[2:0]*/
+	u8 antidx_antb : 3; /*antidx_antb[2:0]*/
+	u8 hw_antsw_occur : 2; /*1'b0*/
+#else /*_BIG_ENDIAN_*/
+	u8 hw_antsw_occur : 2;
+	u8 antidx_antb : 3;
+	u8 antidx_anta : 3;
+#endif
+};
+
+void phydm_reset_rssi_for_dm(struct phy_dm_struct *dm, u8 station_id);
+
+void odm_init_rssi_for_dm(struct phy_dm_struct *dm);
+
+void odm_phy_status_query(struct phy_dm_struct *dm,
+			  struct dm_phy_status_info *phy_info, u8 *phy_status,
+			  struct dm_per_pkt_info *pktinfo);
+
+void odm_mac_status_query(struct phy_dm_struct *dm, u8 *mac_status, u8 mac_id,
+			  bool is_packet_match_bssid, bool is_packet_to_self,
+			  bool is_packet_beacon);
+
+enum hal_status
+odm_config_rf_with_tx_pwr_track_header_file(struct phy_dm_struct *dm);
+
+enum hal_status
+odm_config_rf_with_header_file(struct phy_dm_struct *dm,
+			       enum odm_rf_config_type config_type,
+			       enum odm_rf_radio_path e_rf_path);
+
+enum hal_status
+odm_config_bb_with_header_file(struct phy_dm_struct *dm,
+			       enum odm_bb_config_type config_type);
+
+enum hal_status odm_config_mac_with_header_file(struct phy_dm_struct *dm);
+
+enum hal_status
+odm_config_fw_with_header_file(struct phy_dm_struct *dm,
+			       enum odm_fw_config_type config_type,
+			       u8 *p_firmware, u32 *size);
+
+u32 odm_get_hw_img_version(struct phy_dm_struct *dm);
+
+s32 odm_signal_scale_mapping(struct phy_dm_struct *dm, s32 curr_sig);
+
+/*For 8822B only!! need to move to FW finally */
+/*==============================================*/
+void phydm_rx_phy_status_new_type(struct phy_dm_struct *phydm, u8 *phy_status,
+				  struct dm_per_pkt_info *pktinfo,
+				  struct dm_phy_status_info *phy_info);
+
+bool phydm_query_is_mu_api(struct phy_dm_struct *phydm, u8 ppdu_idx,
+			   u8 *p_data_rate, u8 *p_gid);
+
+struct phy_status_rpt_jaguar2_type0 {
+	/* DW0 */
+	u8 page_num;
+	u8 pwdb;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 gain : 6;
+	u8 rsvd_0 : 1;
+	u8 trsw : 1;
+#else
+	u8 trsw : 1;
+	u8 rsvd_0 : 1;
+	u8 gain : 6;
+#endif
+	u8 rsvd_1;
+
+	/* DW1 */
+	u8 rsvd_2;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 rxsc : 4;
+	u8 agc_table : 4;
+#else
+	u8 agc_table : 4;
+	u8 rxsc : 4;
+#endif
+	u8 channel;
+	u8 band;
+
+	/* DW2 */
+	u16 length;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 antidx_a : 3;
+	u8 antidx_b : 3;
+	u8 rsvd_3 : 2;
+	u8 antidx_c : 3;
+	u8 antidx_d : 3;
+	u8 rsvd_4 : 2;
+#else
+	u8 rsvd_3 : 2;
+	u8 antidx_b : 3;
+	u8 antidx_a : 3;
+	u8 rsvd_4 : 2;
+	u8 antidx_d : 3;
+	u8 antidx_c : 3;
+#endif
+
+	/* DW3 */
+	u8 signal_quality;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 vga : 5;
+	u8 lna_l : 3;
+	u8 bb_power : 6;
+	u8 rsvd_9 : 1;
+	u8 lna_h : 1;
+#else
+	u8 lna_l : 3;
+	u8 vga : 5;
+	u8 lna_h : 1;
+	u8 rsvd_9 : 1;
+	u8 bb_power : 6;
+#endif
+	u8 rsvd_5;
+
+	/* DW4 */
+	u32 rsvd_6;
+
+	/* DW5 */
+	u32 rsvd_7;
+
+	/* DW6 */
+	u32 rsvd_8;
+};
+
+struct phy_status_rpt_jaguar2_type1 {
+	/* DW0 and DW1 */
+	u8 page_num;
+	u8 pwdb[4];
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 l_rxsc : 4;
+	u8 ht_rxsc : 4;
+#else
+	u8 ht_rxsc : 4;
+	u8 l_rxsc : 4;
+#endif
+	u8 channel;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 band : 2;
+	u8 rsvd_0 : 1;
+	u8 hw_antsw_occu : 1;
+	u8 gnt_bt : 1;
+	u8 ldpc : 1;
+	u8 stbc : 1;
+	u8 beamformed : 1;
+#else
+	u8 beamformed : 1;
+	u8 stbc : 1;
+	u8 ldpc : 1;
+	u8 gnt_bt : 1;
+	u8 hw_antsw_occu : 1;
+	u8 rsvd_0 : 1;
+	u8 band : 2;
+#endif
+
+	/* DW2 */
+	u16 lsig_length;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 antidx_a : 3;
+	u8 antidx_b : 3;
+	u8 rsvd_1 : 2;
+	u8 antidx_c : 3;
+	u8 antidx_d : 3;
+	u8 rsvd_2 : 2;
+#else
+	u8 rsvd_1 : 2;
+	u8 antidx_b : 3;
+	u8 antidx_a : 3;
+	u8 rsvd_2 : 2;
+	u8 antidx_d : 3;
+	u8 antidx_c : 3;
+#endif
+
+	/* DW3 */
+	u8 paid;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 paid_msb : 1;
+	u8 gid : 6;
+	u8 rsvd_3 : 1;
+#else
+	u8 rsvd_3 : 1;
+	u8 gid : 6;
+	u8 paid_msb : 1;
+#endif
+	u8 intf_pos;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 intf_pos_msb : 1;
+	u8 rsvd_4 : 2;
+	u8 nb_intf_flag : 1;
+	u8 rf_mode : 2;
+	u8 rsvd_5 : 2;
+#else
+	u8 rsvd_5 : 2;
+	u8 rf_mode : 2;
+	u8 nb_intf_flag : 1;
+	u8 rsvd_4 : 2;
+	u8 intf_pos_msb : 1;
+#endif
+
+	/* DW4 */
+	s8 rxevm[4]; /* s(8,1) */
+
+	/* DW5 */
+	s8 cfo_tail[4]; /* s(8,7) */
+
+	/* DW6 */
+	s8 rxsnr[4]; /* s(8,1) */
+};
+
+struct phy_status_rpt_jaguar2_type2 {
+	/* DW0 ane DW1 */
+	u8 page_num;
+	u8 pwdb[4];
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 l_rxsc : 4;
+	u8 ht_rxsc : 4;
+#else
+	u8 ht_rxsc : 4;
+	u8 l_rxsc : 4;
+#endif
+	u8 channel;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 band : 2;
+	u8 rsvd_0 : 1;
+	u8 hw_antsw_occu : 1;
+	u8 gnt_bt : 1;
+	u8 ldpc : 1;
+	u8 stbc : 1;
+	u8 beamformed : 1;
+#else
+	u8 beamformed : 1;
+	u8 stbc : 1;
+	u8 ldpc : 1;
+	u8 gnt_bt : 1;
+	u8 hw_antsw_occu : 1;
+	u8 rsvd_0 : 1;
+	u8 band : 2;
+#endif
+
+/* DW2 */
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 shift_l_map : 6;
+	u8 rsvd_1 : 2;
+#else
+	u8 rsvd_1 : 2;
+	u8 shift_l_map : 6;
+#endif
+	u8 cnt_pw2cca;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 agc_table_a : 4;
+	u8 agc_table_b : 4;
+	u8 agc_table_c : 4;
+	u8 agc_table_d : 4;
+#else
+	u8 agc_table_b : 4;
+	u8 agc_table_a : 4;
+	u8 agc_table_d : 4;
+	u8 agc_table_c : 4;
+#endif
+
+	/* DW3 ~ DW6*/
+	u8 cnt_cca2agc_rdy;
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 gain_a : 6;
+	u8 rsvd_2 : 1;
+	u8 trsw_a : 1;
+	u8 gain_b : 6;
+	u8 rsvd_3 : 1;
+	u8 trsw_b : 1;
+	u8 gain_c : 6;
+	u8 rsvd_4 : 1;
+	u8 trsw_c : 1;
+	u8 gain_d : 6;
+	u8 rsvd_5 : 1;
+	u8 trsw_d : 1;
+	u8 aagc_step_a : 2;
+	u8 aagc_step_b : 2;
+	u8 aagc_step_c : 2;
+	u8 aagc_step_d : 2;
+#else
+	u8 trsw_a : 1;
+	u8 rsvd_2 : 1;
+	u8 gain_a : 6;
+	u8 trsw_b : 1;
+	u8 rsvd_3 : 1;
+	u8 gain_b : 6;
+	u8 trsw_c : 1;
+	u8 rsvd_4 : 1;
+	u8 gain_c : 6;
+	u8 trsw_d : 1;
+	u8 rsvd_5 : 1;
+	u8 gain_d : 6;
+	u8 aagc_step_d : 2;
+	u8 aagc_step_c : 2;
+	u8 aagc_step_b : 2;
+	u8 aagc_step_a : 2;
+#endif
+	u8 ht_aagc_gain[4];
+	u8 dagc_gain[4];
+#if (ODM_ENDIAN_TYPE == ODM_ENDIAN_LITTLE)
+	u8 counter : 6;
+	u8 rsvd_6 : 2;
+	u8 syn_count : 5;
+	u8 rsvd_7 : 3;
+#else
+	u8 rsvd_6 : 2;
+	u8 counter : 6;
+	u8 rsvd_7 : 3;
+	u8 syn_count : 5;
+#endif
+};
+
+u32 query_phydm_trx_capability(struct phy_dm_struct *dm);
+
+u32 query_phydm_stbc_capability(struct phy_dm_struct *dm);
+
+u32 query_phydm_ldpc_capability(struct phy_dm_struct *dm);
+
+u32 query_phydm_txbf_parameters(struct phy_dm_struct *dm);
+
+u32 query_phydm_txbf_capability(struct phy_dm_struct *dm);
+
+#endif /*#ifndef	__HALHWOUTSRC_H__*/
diff --git a/drivers/staging/rtlwifi/phydm/phydm_interface.c b/drivers/staging/rtlwifi/phydm/phydm_interface.c
new file mode 100644
index 000000000000..102576a46c04
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_interface.c
@@ -0,0 +1,341 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/* ************************************************************
+ * include files
+ * *************************************************************/
+
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+/*
+ * ODM IO Relative API.
+ */
+
+u8 odm_read_1byte(struct phy_dm_struct *dm, u32 reg_addr)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+
+	return rtl_read_byte(rtlpriv, reg_addr);
+}
+
+u16 odm_read_2byte(struct phy_dm_struct *dm, u32 reg_addr)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+
+	return rtl_read_word(rtlpriv, reg_addr);
+}
+
+u32 odm_read_4byte(struct phy_dm_struct *dm, u32 reg_addr)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+
+	return rtl_read_dword(rtlpriv, reg_addr);
+}
+
+void odm_write_1byte(struct phy_dm_struct *dm, u32 reg_addr, u8 data)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+
+	rtl_write_byte(rtlpriv, reg_addr, data);
+}
+
+void odm_write_2byte(struct phy_dm_struct *dm, u32 reg_addr, u16 data)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+
+	rtl_write_word(rtlpriv, reg_addr, data);
+}
+
+void odm_write_4byte(struct phy_dm_struct *dm, u32 reg_addr, u32 data)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+
+	rtl_write_dword(rtlpriv, reg_addr, data);
+}
+
+void odm_set_mac_reg(struct phy_dm_struct *dm, u32 reg_addr, u32 bit_mask,
+		     u32 data)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+
+	rtl_set_bbreg(rtlpriv->hw, reg_addr, bit_mask, data);
+}
+
+u32 odm_get_mac_reg(struct phy_dm_struct *dm, u32 reg_addr, u32 bit_mask)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+
+	return rtl_get_bbreg(rtlpriv->hw, reg_addr, bit_mask);
+}
+
+void odm_set_bb_reg(struct phy_dm_struct *dm, u32 reg_addr, u32 bit_mask,
+		    u32 data)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+
+	rtl_set_bbreg(rtlpriv->hw, reg_addr, bit_mask, data);
+}
+
+u32 odm_get_bb_reg(struct phy_dm_struct *dm, u32 reg_addr, u32 bit_mask)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+
+	return rtl_get_bbreg(rtlpriv->hw, reg_addr, bit_mask);
+}
+
+void odm_set_rf_reg(struct phy_dm_struct *dm, enum odm_rf_radio_path e_rf_path,
+		    u32 reg_addr, u32 bit_mask, u32 data)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+
+	rtl_set_rfreg(rtlpriv->hw, (enum radio_path)e_rf_path, reg_addr,
+		      bit_mask, data);
+}
+
+u32 odm_get_rf_reg(struct phy_dm_struct *dm, enum odm_rf_radio_path e_rf_path,
+		   u32 reg_addr, u32 bit_mask)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+
+	return rtl_get_rfreg(rtlpriv->hw, (enum radio_path)e_rf_path, reg_addr,
+			     bit_mask);
+}
+
+/*
+ * ODM Memory relative API.
+ */
+void odm_allocate_memory(struct phy_dm_struct *dm, void **ptr, u32 length)
+{
+	*ptr = kmalloc(length, GFP_ATOMIC);
+}
+
+/* length could be ignored, used to detect memory leakage. */
+void odm_free_memory(struct phy_dm_struct *dm, void *ptr, u32 length)
+{
+	kfree(ptr);
+}
+
+void odm_move_memory(struct phy_dm_struct *dm, void *p_dest, void *src,
+		     u32 length)
+{
+	memcpy(p_dest, src, length);
+}
+
+void odm_memory_set(struct phy_dm_struct *dm, void *pbuf, s8 value, u32 length)
+{
+	memset(pbuf, value, length);
+}
+
+s32 odm_compare_memory(struct phy_dm_struct *dm, void *p_buf1, void *buf2,
+		       u32 length)
+{
+	return memcmp(p_buf1, buf2, length);
+}
+
+/*
+ * ODM MISC relative API.
+ */
+void odm_acquire_spin_lock(struct phy_dm_struct *dm, enum rt_spinlock_type type)
+{
+}
+
+void odm_release_spin_lock(struct phy_dm_struct *dm, enum rt_spinlock_type type)
+{
+}
+
+/*
+ * ODM Timer relative API.
+ */
+void odm_stall_execution(u32 us_delay) { udelay(us_delay); }
+
+void ODM_delay_ms(u32 ms) { mdelay(ms); }
+
+void ODM_delay_us(u32 us) { udelay(us); }
+
+void ODM_sleep_ms(u32 ms) { msleep(ms); }
+
+void ODM_sleep_us(u32 us) { usleep_range(us, us + 1); }
+
+void odm_set_timer(struct phy_dm_struct *dm, struct timer_list *timer,
+		   u32 ms_delay)
+{
+	mod_timer(timer, jiffies + msecs_to_jiffies(ms_delay));
+}
+
+void odm_initialize_timer(struct phy_dm_struct *dm, struct timer_list *timer,
+			  void *call_back_func, void *context,
+			  const char *sz_id)
+{
+	init_timer(timer);
+	timer->function = call_back_func;
+	timer->data = (unsigned long)dm;
+	/*mod_timer(timer, jiffies+RTL_MILISECONDS_TO_JIFFIES(10));	*/
+}
+
+void odm_cancel_timer(struct phy_dm_struct *dm, struct timer_list *timer)
+{
+	del_timer(timer);
+}
+
+void odm_release_timer(struct phy_dm_struct *dm, struct timer_list *timer) {}
+
+static u8 phydm_trans_h2c_id(struct phy_dm_struct *dm, u8 phydm_h2c_id)
+{
+	u8 platform_h2c_id = phydm_h2c_id;
+
+	switch (phydm_h2c_id) {
+	/* 1 [0] */
+	case ODM_H2C_RSSI_REPORT:
+
+		break;
+
+	/* 1 [3] */
+	case ODM_H2C_WIFI_CALIBRATION:
+
+		break;
+
+	/* 1 [4] */
+	case ODM_H2C_IQ_CALIBRATION:
+
+		break;
+	/* 1 [5] */
+	case ODM_H2C_RA_PARA_ADJUST:
+
+		break;
+
+	/* 1 [6] */
+	case PHYDM_H2C_DYNAMIC_TX_PATH:
+
+		break;
+
+	/* [7]*/
+	case PHYDM_H2C_FW_TRACE_EN:
+
+		platform_h2c_id = 0x49;
+
+		break;
+
+	case PHYDM_H2C_TXBF:
+		break;
+
+	case PHYDM_H2C_MU:
+		platform_h2c_id = 0x4a; /*H2C_MU*/
+		break;
+
+	default:
+		platform_h2c_id = phydm_h2c_id;
+		break;
+	}
+
+	return platform_h2c_id;
+}
+
+/*ODM FW relative API.*/
+
+void odm_fill_h2c_cmd(struct phy_dm_struct *dm, u8 phydm_h2c_id, u32 cmd_len,
+		      u8 *cmd_buffer)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+	u8 platform_h2c_id;
+
+	platform_h2c_id = phydm_trans_h2c_id(dm, phydm_h2c_id);
+
+	ODM_RT_TRACE(dm, PHYDM_COMP_RA_DBG,
+		     "[H2C]  platform_h2c_id = ((0x%x))\n", platform_h2c_id);
+
+	rtlpriv->cfg->ops->fill_h2c_cmd(rtlpriv->hw, platform_h2c_id, cmd_len,
+					cmd_buffer);
+}
+
+u8 phydm_c2H_content_parsing(void *dm_void, u8 c2h_cmd_id, u8 c2h_cmd_len,
+			     u8 *tmp_buf)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 extend_c2h_sub_id = 0;
+	u8 find_c2h_cmd = true;
+
+	switch (c2h_cmd_id) {
+	case PHYDM_C2H_DBG:
+		phydm_fw_trace_handler(dm, tmp_buf, c2h_cmd_len);
+		break;
+
+	case PHYDM_C2H_RA_RPT:
+		phydm_c2h_ra_report_handler(dm, tmp_buf, c2h_cmd_len);
+		break;
+
+	case PHYDM_C2H_RA_PARA_RPT:
+		odm_c2h_ra_para_report_handler(dm, tmp_buf, c2h_cmd_len);
+		break;
+
+	case PHYDM_C2H_DYNAMIC_TX_PATH_RPT:
+		break;
+
+	case PHYDM_C2H_IQK_FINISH:
+		break;
+
+	case PHYDM_C2H_DBG_CODE:
+		phydm_fw_trace_handler_code(dm, tmp_buf, c2h_cmd_len);
+		break;
+
+	case PHYDM_C2H_EXTEND:
+		extend_c2h_sub_id = tmp_buf[0];
+		if (extend_c2h_sub_id == PHYDM_EXTEND_C2H_DBG_PRINT)
+			phydm_fw_trace_handler_8051(dm, tmp_buf, c2h_cmd_len);
+
+		break;
+
+	default:
+		find_c2h_cmd = false;
+		break;
+	}
+
+	return find_c2h_cmd;
+}
+
+u64 odm_get_current_time(struct phy_dm_struct *dm) { return jiffies; }
+
+u64 odm_get_progressing_time(struct phy_dm_struct *dm, u64 start_time)
+{
+	return jiffies_to_msecs(jiffies - (u32)start_time);
+}
+
+void odm_set_tx_power_index_by_rate_section(struct phy_dm_struct *dm,
+					    u8 rf_path, u8 channel,
+					    u8 rate_section)
+{
+	void *adapter = dm->adapter;
+
+	phy_set_tx_power_index_by_rs(adapter, channel, rf_path, rate_section);
+}
+
+u8 odm_get_tx_power_index(struct phy_dm_struct *dm, u8 rf_path, u8 tx_rate,
+			  u8 band_width, u8 channel)
+{
+	void *adapter = dm->adapter;
+
+	return phy_get_tx_power_index(adapter, (enum odm_rf_radio_path)rf_path,
+				      tx_rate, band_width, channel);
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_interface.h b/drivers/staging/rtlwifi/phydm/phydm_interface.h
new file mode 100644
index 000000000000..d315c79c962a
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_interface.h
@@ -0,0 +1,205 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __ODM_INTERFACE_H__
+#define __ODM_INTERFACE_H__
+
+#define INTERFACE_VERSION "1.1" /*2015.07.29  YuChen*/
+
+/*
+ * =========== Constant/Structure/Enum/... Define
+ */
+
+/*
+ * =========== Macro Define
+ */
+
+#define _reg_all(_name) ODM_##_name
+#define _reg_ic(_name, _ic) ODM_##_name##_ic
+#define _bit_all(_name) BIT_##_name
+#define _bit_ic(_name, _ic) BIT_##_name##_ic
+
+/* _cat: implemented by Token-Pasting Operator. */
+
+/*===================================
+ *
+ * #define ODM_REG_DIG_11N	0xC50
+ * #define ODM_REG_DIG_11AC	0xDDD
+ *
+ * ODM_REG(DIG,_pdm_odm)
+ * ===================================
+ */
+
+#define _reg_11N(_name) ODM_REG_##_name##_11N
+#define _reg_11AC(_name) ODM_REG_##_name##_11AC
+#define _bit_11N(_name) ODM_BIT_##_name##_11N
+#define _bit_11AC(_name) ODM_BIT_##_name##_11AC
+
+#define _cat(_name, _ic_type, _func)                                           \
+	(((_ic_type) & ODM_IC_11N_SERIES) ? _func##_11N(_name) :               \
+					    _func##_11AC(_name))
+
+/* _name: name of register or bit.
+ * Example: "ODM_REG(R_A_AGC_CORE1, dm)"
+ * gets "ODM_R_A_AGC_CORE1" or "ODM_R_A_AGC_CORE1_8192C",
+ * depends on support_ic_type.
+ */
+#define ODM_REG(_name, _pdm_odm) _cat(_name, _pdm_odm->support_ic_type, _reg)
+#define ODM_BIT(_name, _pdm_odm) _cat(_name, _pdm_odm->support_ic_type, _bit)
+enum phydm_h2c_cmd {
+	PHYDM_H2C_TXBF = 0x41,
+	ODM_H2C_RSSI_REPORT = 0x42,
+	ODM_H2C_IQ_CALIBRATION = 0x45,
+	ODM_H2C_RA_PARA_ADJUST = 0x47,
+	PHYDM_H2C_DYNAMIC_TX_PATH = 0x48,
+	PHYDM_H2C_FW_TRACE_EN = 0x49,
+	ODM_H2C_WIFI_CALIBRATION = 0x6d,
+	PHYDM_H2C_MU = 0x4a,
+	ODM_MAX_H2CCMD
+};
+
+enum phydm_c2h_evt {
+	PHYDM_C2H_DBG = 0,
+	PHYDM_C2H_LB = 1,
+	PHYDM_C2H_XBF = 2,
+	PHYDM_C2H_TX_REPORT = 3,
+	PHYDM_C2H_INFO = 9,
+	PHYDM_C2H_BT_MP = 11,
+	PHYDM_C2H_RA_RPT = 12,
+	PHYDM_C2H_RA_PARA_RPT = 14,
+	PHYDM_C2H_DYNAMIC_TX_PATH_RPT = 15,
+	PHYDM_C2H_IQK_FINISH = 17, /*0x11*/
+	PHYDM_C2H_DBG_CODE = 0xFE,
+	PHYDM_C2H_EXTEND = 0xFF,
+};
+
+enum phydm_extend_c2h_evt {
+	PHYDM_EXTEND_C2H_DBG_PRINT = 0
+
+};
+
+/*
+ * =========== Extern Variable ??? It should be forbidden.
+ */
+
+/*
+ * =========== EXtern Function Prototype
+ */
+
+u8 odm_read_1byte(struct phy_dm_struct *dm, u32 reg_addr);
+
+u16 odm_read_2byte(struct phy_dm_struct *dm, u32 reg_addr);
+
+u32 odm_read_4byte(struct phy_dm_struct *dm, u32 reg_addr);
+
+void odm_write_1byte(struct phy_dm_struct *dm, u32 reg_addr, u8 data);
+
+void odm_write_2byte(struct phy_dm_struct *dm, u32 reg_addr, u16 data);
+
+void odm_write_4byte(struct phy_dm_struct *dm, u32 reg_addr, u32 data);
+
+void odm_set_mac_reg(struct phy_dm_struct *dm, u32 reg_addr, u32 bit_mask,
+		     u32 data);
+
+u32 odm_get_mac_reg(struct phy_dm_struct *dm, u32 reg_addr, u32 bit_mask);
+
+void odm_set_bb_reg(struct phy_dm_struct *dm, u32 reg_addr, u32 bit_mask,
+		    u32 data);
+
+u32 odm_get_bb_reg(struct phy_dm_struct *dm, u32 reg_addr, u32 bit_mask);
+
+void odm_set_rf_reg(struct phy_dm_struct *dm, enum odm_rf_radio_path e_rf_path,
+		    u32 reg_addr, u32 bit_mask, u32 data);
+
+u32 odm_get_rf_reg(struct phy_dm_struct *dm, enum odm_rf_radio_path e_rf_path,
+		   u32 reg_addr, u32 bit_mask);
+
+/*
+ * Memory Relative Function.
+ */
+void odm_allocate_memory(struct phy_dm_struct *dm, void **ptr, u32 length);
+void odm_free_memory(struct phy_dm_struct *dm, void *ptr, u32 length);
+
+void odm_move_memory(struct phy_dm_struct *dm, void *p_dest, void *src,
+		     u32 length);
+
+s32 odm_compare_memory(struct phy_dm_struct *dm, void *p_buf1, void *buf2,
+		       u32 length);
+
+void odm_memory_set(struct phy_dm_struct *dm, void *pbuf, s8 value, u32 length);
+
+/*
+ * ODM MISC-spin lock relative API.
+ */
+void odm_acquire_spin_lock(struct phy_dm_struct *dm,
+			   enum rt_spinlock_type type);
+
+void odm_release_spin_lock(struct phy_dm_struct *dm,
+			   enum rt_spinlock_type type);
+
+/*
+ * ODM Timer relative API.
+ */
+void odm_stall_execution(u32 us_delay);
+
+void ODM_delay_ms(u32 ms);
+
+void ODM_delay_us(u32 us);
+
+void ODM_sleep_ms(u32 ms);
+
+void ODM_sleep_us(u32 us);
+
+void odm_set_timer(struct phy_dm_struct *dm, struct timer_list *timer,
+		   u32 ms_delay);
+
+void odm_initialize_timer(struct phy_dm_struct *dm, struct timer_list *timer,
+			  void *call_back_func, void *context,
+			  const char *sz_id);
+
+void odm_cancel_timer(struct phy_dm_struct *dm, struct timer_list *timer);
+
+void odm_release_timer(struct phy_dm_struct *dm, struct timer_list *timer);
+
+/*
+ * ODM FW relative API.
+ */
+void odm_fill_h2c_cmd(struct phy_dm_struct *dm, u8 element_id, u32 cmd_len,
+		      u8 *cmd_buffer);
+
+u8 phydm_c2H_content_parsing(void *dm_void, u8 c2h_cmd_id, u8 c2h_cmd_len,
+			     u8 *tmp_buf);
+
+u64 odm_get_current_time(struct phy_dm_struct *dm);
+u64 odm_get_progressing_time(struct phy_dm_struct *dm, u64 start_time);
+
+void odm_set_tx_power_index_by_rate_section(struct phy_dm_struct *dm,
+					    u8 rf_path, u8 channel,
+					    u8 rate_section);
+
+u8 odm_get_tx_power_index(struct phy_dm_struct *dm, u8 rf_path, u8 tx_rate,
+			  u8 band_width, u8 channel);
+
+#endif /* __ODM_INTERFACE_H__ */
diff --git a/drivers/staging/rtlwifi/phydm/phydm_iqk.h b/drivers/staging/rtlwifi/phydm/phydm_iqk.h
new file mode 100644
index 000000000000..0d45bf099aeb
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_iqk.h
@@ -0,0 +1,76 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDMIQK_H__
+#define __PHYDMIQK_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+#define LOK_delay 1
+#define WBIQK_delay 10
+#define TX_IQK 0
+#define RX_IQK 1
+#define TXIQK 0
+#define RXIQK1 1
+#define RXIQK2 2
+#define GSRXK1 0
+#define GSRXK2 1
+#define kcount_limit_80m 2
+#define kcount_limit_others 4
+#define rxiqk_gs_limit 4
+
+#define NUM 4
+/*----------------------End Define Parameters-------------------------------*/
+
+struct dm_iqk_info {
+	bool lok_fail[NUM];
+	bool iqk_fail[2][NUM];
+	u32 iqc_matrix[2][NUM];
+	u8 iqk_times;
+	u32 rf_reg18;
+	u32 lna_idx;
+	u8 rxiqk_step;
+	u8 tmp1bcc;
+	u8 kcount;
+
+	u32 iqk_channel[2];
+	bool iqk_fail_report[2][4][2]; /*channel/path/TRX(TX:0, RX:1) */
+	u32 iqk_cfir_real[2][4][2]
+			 [8]; /*channel / path / TRX(TX:0, RX:1) / CFIR_real*/
+	u32 iqk_cfir_imag[2][4][2]
+			 [8]; /*channel / path / TRX(TX:0, RX:1) / CFIR_imag*/
+	u8 retry_count[2][4][3]; /* channel / path / (TXK:0, RXK1:1, RXK2:2) */
+	u8 gs_retry_count[2][4][2]; /* channel / path / (GSRXK1:0, GSRXK2:1) */
+	u8 rxiqk_fail_code[2][4]; /* channel / path
+				   * 0:SRXK1 fail, 1:RXK1 fail 2:RXK2 fail
+				   */
+	u32 lok_idac[2][4]; /*channel / path*/
+	u16 rxiqk_agc[2][4]; /*channel / path*/
+	u32 bypass_iqk[2][4]; /*channel / 0xc94/0xe94*/
+	u32 tmp_gntwl;
+	bool is_btg;
+	bool isbnd;
+};
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_kfree.c b/drivers/staging/rtlwifi/phydm/phydm_kfree.c
new file mode 100644
index 000000000000..5f3582341806
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_kfree.c
@@ -0,0 +1,228 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/*============================================================*/
+/*include files*/
+/*============================================================*/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+/*<YuChen, 150720> Add for KFree Feature Requested by RF David.*/
+/*This is a phydm API*/
+
+static void phydm_set_kfree_to_rf_8814a(void *dm_void, u8 e_rf_path, u8 data)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+	bool is_odd;
+
+	if ((data % 2) != 0) { /*odd->positive*/
+		data = data - 1;
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET, BIT(19),
+			       1);
+		is_odd = true;
+	} else { /*even->negative*/
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET, BIT(19),
+			       0);
+		is_odd = false;
+	}
+	ODM_RT_TRACE(dm, ODM_COMP_MP, "%s(): RF_0x55[19]= %d\n", __func__,
+		     is_odd);
+	switch (data) {
+	case 0:
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET, BIT(14),
+			       0);
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET,
+			       BIT(17) | BIT(16) | BIT(15), 0);
+		cali_info->kfree_offset[e_rf_path] = 0;
+		break;
+	case 2:
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET, BIT(14),
+			       1);
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET,
+			       BIT(17) | BIT(16) | BIT(15), 0);
+		cali_info->kfree_offset[e_rf_path] = 0;
+		break;
+	case 4:
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET, BIT(14),
+			       0);
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET,
+			       BIT(17) | BIT(16) | BIT(15), 1);
+		cali_info->kfree_offset[e_rf_path] = 1;
+		break;
+	case 6:
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET, BIT(14),
+			       1);
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET,
+			       BIT(17) | BIT(16) | BIT(15), 1);
+		cali_info->kfree_offset[e_rf_path] = 1;
+		break;
+	case 8:
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET, BIT(14),
+			       0);
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET,
+			       BIT(17) | BIT(16) | BIT(15), 2);
+		cali_info->kfree_offset[e_rf_path] = 2;
+		break;
+	case 10:
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET, BIT(14),
+			       1);
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET,
+			       BIT(17) | BIT(16) | BIT(15), 2);
+		cali_info->kfree_offset[e_rf_path] = 2;
+		break;
+	case 12:
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET, BIT(14),
+			       0);
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET,
+			       BIT(17) | BIT(16) | BIT(15), 3);
+		cali_info->kfree_offset[e_rf_path] = 3;
+		break;
+	case 14:
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET, BIT(14),
+			       1);
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET,
+			       BIT(17) | BIT(16) | BIT(15), 3);
+		cali_info->kfree_offset[e_rf_path] = 3;
+		break;
+	case 16:
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET, BIT(14),
+			       0);
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET,
+			       BIT(17) | BIT(16) | BIT(15), 4);
+		cali_info->kfree_offset[e_rf_path] = 4;
+		break;
+	case 18:
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET, BIT(14),
+			       1);
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET,
+			       BIT(17) | BIT(16) | BIT(15), 4);
+		cali_info->kfree_offset[e_rf_path] = 4;
+		break;
+	case 20:
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET, BIT(14),
+			       0);
+		odm_set_rf_reg(dm, e_rf_path, REG_RF_TX_GAIN_OFFSET,
+			       BIT(17) | BIT(16) | BIT(15), 5);
+		cali_info->kfree_offset[e_rf_path] = 5;
+		break;
+
+	default:
+		break;
+	}
+
+	if (!is_odd) {
+		/*that means Kfree offset is negative, we need to record it.*/
+		cali_info->kfree_offset[e_rf_path] =
+			(-1) * cali_info->kfree_offset[e_rf_path];
+		ODM_RT_TRACE(dm, ODM_COMP_MP, "%s(): kfree_offset = %d\n",
+			     __func__, cali_info->kfree_offset[e_rf_path]);
+	} else {
+		ODM_RT_TRACE(dm, ODM_COMP_MP, "%s(): kfree_offset = %d\n",
+			     __func__, cali_info->kfree_offset[e_rf_path]);
+	}
+}
+
+static void phydm_set_kfree_to_rf(void *dm_void, u8 e_rf_path, u8 data)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (dm->support_ic_type & ODM_RTL8814A)
+		phydm_set_kfree_to_rf_8814a(dm, e_rf_path, data);
+}
+
+void phydm_config_kfree(void *dm_void, u8 channel_to_sw, u8 *kfree_table)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+	u8 rfpath = 0, max_rf_path = 0;
+	u8 channel_idx = 0;
+
+	if (dm->support_ic_type & ODM_RTL8814A)
+		max_rf_path = 4; /*0~3*/
+	else if (dm->support_ic_type &
+		 (ODM_RTL8812 | ODM_RTL8192E | ODM_RTL8822B))
+		max_rf_path = 2; /*0~1*/
+	else
+		max_rf_path = 1;
+
+	ODM_RT_TRACE(dm, ODM_COMP_MP, "===>%s()\n", __func__);
+
+	if (cali_info->reg_rf_kfree_enable == 2) {
+		ODM_RT_TRACE(dm, ODM_COMP_MP,
+			     "%s(): reg_rf_kfree_enable == 2, Disable\n",
+			     __func__);
+		return;
+	}
+
+	if (cali_info->reg_rf_kfree_enable != 1 &&
+	    cali_info->reg_rf_kfree_enable != 0) {
+		ODM_RT_TRACE(dm, ODM_COMP_MP, "<===%s()\n", __func__);
+		return;
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_MP, "%s(): reg_rf_kfree_enable == true\n",
+		     __func__);
+	/*Make sure the targetval is defined*/
+	if (((cali_info->reg_rf_kfree_enable == 1) &&
+	     (kfree_table[0] != 0xFF)) ||
+	    cali_info->rf_kfree_enable) {
+		/*if kfree_table[0] == 0xff, means no Kfree*/
+		if (*dm->band_type == ODM_BAND_2_4G) {
+			if (channel_to_sw <= 14 && channel_to_sw >= 1)
+				channel_idx = PHYDM_2G;
+		} else if (*dm->band_type == ODM_BAND_5G) {
+			if (channel_to_sw >= 36 && channel_to_sw <= 48)
+				channel_idx = PHYDM_5GLB1;
+			if (channel_to_sw >= 52 && channel_to_sw <= 64)
+				channel_idx = PHYDM_5GLB2;
+			if (channel_to_sw >= 100 && channel_to_sw <= 120)
+				channel_idx = PHYDM_5GMB1;
+			if (channel_to_sw >= 124 && channel_to_sw <= 144)
+				channel_idx = PHYDM_5GMB2;
+			if (channel_to_sw >= 149 && channel_to_sw <= 177)
+				channel_idx = PHYDM_5GHB;
+		}
+
+		for (rfpath = ODM_RF_PATH_A; rfpath < max_rf_path; rfpath++) {
+			ODM_RT_TRACE(dm, ODM_COMP_MP, "%s(): PATH_%d: %#x\n",
+				     __func__, rfpath,
+				     kfree_table[channel_idx * max_rf_path +
+						 rfpath]);
+			phydm_set_kfree_to_rf(
+				dm, rfpath,
+				kfree_table[channel_idx * max_rf_path +
+					    rfpath]);
+		}
+	} else {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_MP,
+			"%s(): targetval not defined, Don't execute KFree Process.\n",
+			__func__);
+		return;
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_MP, "<===%s()\n", __func__);
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_kfree.h b/drivers/staging/rtlwifi/phydm/phydm_kfree.h
new file mode 100644
index 000000000000..1ee60059afc1
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_kfree.h
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDMKFREE_H__
+#define __PHYDKFREE_H__
+
+#define KFREE_VERSION "1.0"
+
+enum phydm_kfree_channeltosw {
+	PHYDM_2G = 0,
+	PHYDM_5GLB1 = 1,
+	PHYDM_5GLB2 = 2,
+	PHYDM_5GMB1 = 3,
+	PHYDM_5GMB2 = 4,
+	PHYDM_5GHB = 5,
+};
+
+void phydm_config_kfree(void *dm_void, u8 channel_to_sw, u8 *kfree_table);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_noisemonitor.c b/drivers/staging/rtlwifi/phydm/phydm_noisemonitor.c
new file mode 100644
index 000000000000..8d79a5add1b4
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_noisemonitor.c
@@ -0,0 +1,330 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/* ************************************************************
+ * include files
+ * *************************************************************/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+#include "phydm_noisemonitor.h"
+
+/* *************************************************
+ * This function is for inband noise test utility only
+ * To obtain the inband noise level(dbm), do the following.
+ * 1. disable DIG and Power Saving
+ * 2. Set initial gain = 0x1a
+ * 3. Stop updating idle time pwer report (for driver read)
+ *	- 0x80c[25]
+ *
+ * **************************************************/
+
+#define VALID_MIN -35
+#define VALID_MAX 10
+#define VALID_CNT 5
+
+static inline void phydm_set_noise_data_sum(struct noise_level *noise_data,
+					    u8 max_rf_path)
+{
+	u8 rf_path;
+
+	for (rf_path = ODM_RF_PATH_A; rf_path < max_rf_path; rf_path++) {
+		if (noise_data->valid_cnt[rf_path])
+			noise_data->sum[rf_path] /=
+				noise_data->valid_cnt[rf_path];
+		else
+			noise_data->sum[rf_path] = 0;
+	}
+}
+
+static s16 odm_inband_noise_monitor_n_series(struct phy_dm_struct *dm,
+					     u8 is_pause_dig, u8 igi_value,
+					     u32 max_time)
+{
+	u32 tmp4b;
+	u8 max_rf_path = 0, rf_path;
+	u8 reg_c50, reg_c58, valid_done = 0;
+	struct noise_level noise_data;
+	u64 start = 0, func_start = 0, func_end = 0;
+
+	func_start = odm_get_current_time(dm);
+	dm->noise_level.noise_all = 0;
+
+	if ((dm->rf_type == ODM_1T2R) || (dm->rf_type == ODM_2T2R))
+		max_rf_path = 2;
+	else
+		max_rf_path = 1;
+
+	ODM_RT_TRACE(dm, ODM_COMP_COMMON, "%s() ==>\n", __func__);
+
+	odm_memory_set(dm, &noise_data, 0, sizeof(struct noise_level));
+
+	/*  */
+	/* step 1. Disable DIG && Set initial gain. */
+	/*  */
+
+	if (is_pause_dig)
+		odm_pause_dig(dm, PHYDM_PAUSE, PHYDM_PAUSE_LEVEL_1, igi_value);
+	/*  */
+	/* step 2. Disable all power save for read registers */
+	/*  */
+	/* dcmd_DebugControlPowerSave(adapter, PSDisable); */
+
+	/*  */
+	/* step 3. Get noise power level */
+	/*  */
+	start = odm_get_current_time(dm);
+	while (1) {
+		/* Stop updating idle time pwer report (for driver read) */
+		odm_set_bb_reg(dm, REG_FPGA0_TX_GAIN_STAGE, BIT(25), 1);
+
+		/* Read Noise Floor Report */
+		tmp4b = odm_get_bb_reg(dm, 0x8f8, MASKDWORD);
+		ODM_RT_TRACE(dm, ODM_COMP_COMMON,
+			     "Noise Floor Report (0x8f8) = 0x%08x\n", tmp4b);
+
+		/* update idle time pwer report per 5us */
+		odm_set_bb_reg(dm, REG_FPGA0_TX_GAIN_STAGE, BIT(25), 0);
+
+		noise_data.value[ODM_RF_PATH_A] = (u8)(tmp4b & 0xff);
+		noise_data.value[ODM_RF_PATH_B] = (u8)((tmp4b & 0xff00) >> 8);
+
+		ODM_RT_TRACE(dm, ODM_COMP_COMMON,
+			     "value_a = 0x%x(%d), value_b = 0x%x(%d)\n",
+			     noise_data.value[ODM_RF_PATH_A],
+			     noise_data.value[ODM_RF_PATH_A],
+			     noise_data.value[ODM_RF_PATH_B],
+			     noise_data.value[ODM_RF_PATH_B]);
+
+		for (rf_path = ODM_RF_PATH_A; rf_path < max_rf_path;
+		     rf_path++) {
+			noise_data.sval[rf_path] =
+				(s8)noise_data.value[rf_path];
+			noise_data.sval[rf_path] /= 2;
+		}
+
+		ODM_RT_TRACE(dm, ODM_COMP_COMMON, "sval_a = %d, sval_b = %d\n",
+			     noise_data.sval[ODM_RF_PATH_A],
+			     noise_data.sval[ODM_RF_PATH_B]);
+
+		for (rf_path = ODM_RF_PATH_A; rf_path < max_rf_path;
+		     rf_path++) {
+			if (!(noise_data.valid_cnt[rf_path] < VALID_CNT) ||
+			    !(noise_data.sval[rf_path] < VALID_MAX &&
+			      noise_data.sval[rf_path] >= VALID_MIN)) {
+				continue;
+			}
+
+			noise_data.valid_cnt[rf_path]++;
+			noise_data.sum[rf_path] += noise_data.sval[rf_path];
+			ODM_RT_TRACE(dm, ODM_COMP_COMMON,
+				     "rf_path:%d Valid sval = %d\n", rf_path,
+				     noise_data.sval[rf_path]);
+			ODM_RT_TRACE(dm, ODM_COMP_COMMON, "Sum of sval = %d,\n",
+				     noise_data.sum[rf_path]);
+			if (noise_data.valid_cnt[rf_path] == VALID_CNT) {
+				valid_done++;
+				ODM_RT_TRACE(
+					dm, ODM_COMP_COMMON,
+					"After divided, rf_path:%d,sum = %d\n",
+					rf_path, noise_data.sum[rf_path]);
+			}
+		}
+
+		if ((valid_done == max_rf_path) ||
+		    (odm_get_progressing_time(dm, start) > max_time)) {
+			phydm_set_noise_data_sum(&noise_data, max_rf_path);
+			break;
+		}
+	}
+	reg_c50 = (u8)odm_get_bb_reg(dm, REG_OFDM_0_XA_AGC_CORE1, MASKBYTE0);
+	reg_c50 &= ~BIT(7);
+	ODM_RT_TRACE(dm, ODM_COMP_COMMON, "0x%x = 0x%02x(%d)\n",
+		     REG_OFDM_0_XA_AGC_CORE1, reg_c50, reg_c50);
+	dm->noise_level.noise[ODM_RF_PATH_A] =
+		(u8)(-110 + reg_c50 + noise_data.sum[ODM_RF_PATH_A]);
+	dm->noise_level.noise_all += dm->noise_level.noise[ODM_RF_PATH_A];
+
+	if (max_rf_path == 2) {
+		reg_c58 = (u8)odm_get_bb_reg(dm, REG_OFDM_0_XB_AGC_CORE1,
+					     MASKBYTE0);
+		reg_c58 &= ~BIT(7);
+		ODM_RT_TRACE(dm, ODM_COMP_COMMON, "0x%x = 0x%02x(%d)\n",
+			     REG_OFDM_0_XB_AGC_CORE1, reg_c58, reg_c58);
+		dm->noise_level.noise[ODM_RF_PATH_B] =
+			(u8)(-110 + reg_c58 + noise_data.sum[ODM_RF_PATH_B]);
+		dm->noise_level.noise_all +=
+			dm->noise_level.noise[ODM_RF_PATH_B];
+	}
+	dm->noise_level.noise_all /= max_rf_path;
+
+	ODM_RT_TRACE(dm, ODM_COMP_COMMON, "noise_a = %d, noise_b = %d\n",
+		     dm->noise_level.noise[ODM_RF_PATH_A],
+		     dm->noise_level.noise[ODM_RF_PATH_B]);
+
+	/*  */
+	/* step 4. Recover the Dig */
+	/*  */
+	if (is_pause_dig)
+		odm_pause_dig(dm, PHYDM_RESUME, PHYDM_PAUSE_LEVEL_1, igi_value);
+	func_end = odm_get_progressing_time(dm, func_start);
+
+	ODM_RT_TRACE(dm, ODM_COMP_COMMON, "%s() <==\n", __func__);
+	return dm->noise_level.noise_all;
+}
+
+static s16 odm_inband_noise_monitor_ac_series(struct phy_dm_struct *dm,
+					      u8 is_pause_dig, u8 igi_value,
+					      u32 max_time)
+{
+	s32 rxi_buf_anta, rxq_buf_anta; /*rxi_buf_antb, rxq_buf_antb;*/
+	s32 value32, pwdb_A = 0, sval, noise, sum;
+	bool pd_flag;
+	u8 valid_cnt;
+	u64 start = 0, func_start = 0, func_end = 0;
+
+	if (!(dm->support_ic_type & (ODM_RTL8812 | ODM_RTL8821 | ODM_RTL8814A)))
+		return 0;
+
+	func_start = odm_get_current_time(dm);
+	dm->noise_level.noise_all = 0;
+
+	ODM_RT_TRACE(dm, ODM_COMP_COMMON, "%s() ==>\n", __func__);
+
+	/* step 1. Disable DIG && Set initial gain. */
+	if (is_pause_dig)
+		odm_pause_dig(dm, PHYDM_PAUSE, PHYDM_PAUSE_LEVEL_1, igi_value);
+
+	/* step 2. Disable all power save for read registers */
+	/*dcmd_DebugControlPowerSave(adapter, PSDisable); */
+
+	/* step 3. Get noise power level */
+	start = odm_get_current_time(dm);
+
+	/* reset counters */
+	sum = 0;
+	valid_cnt = 0;
+
+	/* step 3. Get noise power level */
+	while (1) {
+		/*Set IGI=0x1C */
+		odm_write_dig(dm, 0x1C);
+		/*stop CK320&CK88 */
+		odm_set_bb_reg(dm, 0x8B4, BIT(6), 1);
+		/*Read path-A */
+		odm_set_bb_reg(dm, 0x8FC, MASKDWORD, 0x200); /*set debug port*/
+		value32 = odm_get_bb_reg(dm, 0xFA0,
+					 MASKDWORD); /*read debug port*/
+
+		rxi_buf_anta = (value32 & 0xFFC00) >>
+			       10; /*rxi_buf_anta=RegFA0[19:10]*/
+		rxq_buf_anta = value32 & 0x3FF; /*rxq_buf_anta=RegFA0[19:10]*/
+
+		pd_flag = (bool)((value32 & BIT(31)) >> 31);
+
+		/*Not in packet detection period or Tx state */
+		if ((!pd_flag) || (rxi_buf_anta != 0x200)) {
+			/*sign conversion*/
+			rxi_buf_anta = odm_sign_conversion(rxi_buf_anta, 10);
+			rxq_buf_anta = odm_sign_conversion(rxq_buf_anta, 10);
+
+			pwdb_A = odm_pwdb_conversion(
+				rxi_buf_anta * rxi_buf_anta +
+					rxq_buf_anta * rxq_buf_anta,
+				20, 18); /*S(10,9)*S(10,9)=S(20,18)*/
+
+			ODM_RT_TRACE(
+				dm, ODM_COMP_COMMON,
+				"pwdb_A= %d dB, rxi_buf_anta= 0x%x, rxq_buf_anta= 0x%x\n",
+				pwdb_A, rxi_buf_anta & 0x3FF,
+				rxq_buf_anta & 0x3FF);
+		}
+		/*Start CK320&CK88*/
+		odm_set_bb_reg(dm, 0x8B4, BIT(6), 0);
+		/*BB Reset*/
+		odm_write_1byte(dm, 0x02, odm_read_1byte(dm, 0x02) & (~BIT(0)));
+		odm_write_1byte(dm, 0x02, odm_read_1byte(dm, 0x02) | BIT(0));
+		/*PMAC Reset*/
+		odm_write_1byte(dm, 0xB03,
+				odm_read_1byte(dm, 0xB03) & (~BIT(0)));
+		odm_write_1byte(dm, 0xB03, odm_read_1byte(dm, 0xB03) | BIT(0));
+		/*CCK Reset*/
+		if (odm_read_1byte(dm, 0x80B) & BIT(4)) {
+			odm_write_1byte(dm, 0x80B,
+					odm_read_1byte(dm, 0x80B) & (~BIT(4)));
+			odm_write_1byte(dm, 0x80B,
+					odm_read_1byte(dm, 0x80B) | BIT(4));
+		}
+
+		sval = pwdb_A;
+
+		if ((sval < 0 && sval >= -27) && (valid_cnt < VALID_CNT)) {
+			valid_cnt++;
+			sum += sval;
+			ODM_RT_TRACE(dm, ODM_COMP_COMMON, "Valid sval = %d\n",
+				     sval);
+			ODM_RT_TRACE(dm, ODM_COMP_COMMON, "Sum of sval = %d,\n",
+				     sum);
+			if ((valid_cnt >= VALID_CNT) ||
+			    (odm_get_progressing_time(dm, start) > max_time)) {
+				sum /= VALID_CNT;
+				ODM_RT_TRACE(dm, ODM_COMP_COMMON,
+					     "After divided, sum = %d\n", sum);
+				break;
+			}
+		}
+	}
+
+	/*ADC backoff is 12dB,*/
+	/*Ptarget=0x1C-110=-82dBm*/
+	noise = sum + 12 + 0x1C - 110;
+
+	/*Offset*/
+	noise = noise - 3;
+	ODM_RT_TRACE(dm, ODM_COMP_COMMON, "noise = %d\n", noise);
+	dm->noise_level.noise_all = (s16)noise;
+
+	/* step 4. Recover the Dig*/
+	if (is_pause_dig)
+		odm_pause_dig(dm, PHYDM_RESUME, PHYDM_PAUSE_LEVEL_1, igi_value);
+
+	func_end = odm_get_progressing_time(dm, func_start);
+
+	ODM_RT_TRACE(dm, ODM_COMP_COMMON, "%s() <==\n", __func__);
+
+	return dm->noise_level.noise_all;
+}
+
+s16 odm_inband_noise_monitor(void *dm_void, u8 is_pause_dig, u8 igi_value,
+			     u32 max_time)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES)
+		return odm_inband_noise_monitor_ac_series(dm, is_pause_dig,
+							  igi_value, max_time);
+	else
+		return odm_inband_noise_monitor_n_series(dm, is_pause_dig,
+							 igi_value, max_time);
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_noisemonitor.h b/drivers/staging/rtlwifi/phydm/phydm_noisemonitor.h
new file mode 100644
index 000000000000..a711b7954985
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_noisemonitor.h
@@ -0,0 +1,46 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __ODMNOISEMONITOR_H__
+#define __ODMNOISEMONITOR_H__
+
+#define ODM_MAX_CHANNEL_NUM 38 /* 14+24 */
+struct noise_level {
+	u8 value[MAX_RF_PATH];
+	s8 sval[MAX_RF_PATH];
+
+	s32 sum[MAX_RF_PATH];
+	u8 valid[MAX_RF_PATH];
+	u8 valid_cnt[MAX_RF_PATH];
+};
+
+struct odm_noise_monitor {
+	s8 noise[MAX_RF_PATH];
+	s16 noise_all;
+};
+
+s16 odm_inband_noise_monitor(void *dm_void, u8 is_pause_dig, u8 igi_value,
+			     u32 max_time);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_powertracking_ce.c b/drivers/staging/rtlwifi/phydm/phydm_powertracking_ce.c
new file mode 100644
index 000000000000..48e73eb1622b
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_powertracking_ce.c
@@ -0,0 +1,644 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/*============================================================	*/
+/* include files						*/
+/*============================================================	*/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+/* ************************************************************
+ * Global var
+ * *************************************************************/
+
+u32 ofdm_swing_table[OFDM_TABLE_SIZE] = {
+	0x7f8001fe, /* 0, +6.0dB */
+	0x788001e2, /* 1, +5.5dB */
+	0x71c001c7, /* 2, +5.0dB*/
+	0x6b8001ae, /* 3, +4.5dB*/
+	0x65400195, /* 4, +4.0dB*/
+	0x5fc0017f, /* 5, +3.5dB*/
+	0x5a400169, /* 6, +3.0dB*/
+	0x55400155, /* 7, +2.5dB*/
+	0x50800142, /* 8, +2.0dB*/
+	0x4c000130, /* 9, +1.5dB*/
+	0x47c0011f, /* 10, +1.0dB*/
+	0x43c0010f, /* 11, +0.5dB*/
+	0x40000100, /* 12, +0dB*/
+	0x3c8000f2, /* 13, -0.5dB*/
+	0x390000e4, /* 14, -1.0dB*/
+	0x35c000d7, /* 15, -1.5dB*/
+	0x32c000cb, /* 16, -2.0dB*/
+	0x300000c0, /* 17, -2.5dB*/
+	0x2d4000b5, /* 18, -3.0dB*/
+	0x2ac000ab, /* 19, -3.5dB*/
+	0x288000a2, /* 20, -4.0dB*/
+	0x26000098, /* 21, -4.5dB*/
+	0x24000090, /* 22, -5.0dB*/
+	0x22000088, /* 23, -5.5dB*/
+	0x20000080, /* 24, -6.0dB*/
+	0x1e400079, /* 25, -6.5dB*/
+	0x1c800072, /* 26, -7.0dB*/
+	0x1b00006c, /* 27. -7.5dB*/
+	0x19800066, /* 28, -8.0dB*/
+	0x18000060, /* 29, -8.5dB*/
+	0x16c0005b, /* 30, -9.0dB*/
+	0x15800056, /* 31, -9.5dB*/
+	0x14400051, /* 32, -10.0dB*/
+	0x1300004c, /* 33, -10.5dB*/
+	0x12000048, /* 34, -11.0dB*/
+	0x11000044, /* 35, -11.5dB*/
+	0x10000040, /* 36, -12.0dB*/
+};
+
+u8 cck_swing_table_ch1_ch13[CCK_TABLE_SIZE][8] = {
+	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04}, /* 0, +0dB */
+	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04}, /* 1, -0.5dB */
+	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03}, /* 2, -1.0dB*/
+	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03}, /* 3, -1.5dB*/
+	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03}, /* 4, -2.0dB */
+	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03}, /* 5, -2.5dB*/
+	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03}, /* 6, -3.0dB*/
+	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03}, /* 7, -3.5dB*/
+	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02}, /* 8, -4.0dB */
+	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02}, /* 9, -4.5dB*/
+	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02}, /* 10, -5.0dB */
+	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02}, /* 11, -5.5dB*/
+	{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04,
+	 0x02}, /* 12, -6.0dB <== default */
+	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02}, /* 13, -6.5dB*/
+	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02}, /* 14, -7.0dB */
+	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02}, /* 15, -7.5dB*/
+	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01}, /* 16, -8.0dB */
+	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02}, /* 17, -8.5dB*/
+	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01}, /* 18, -9.0dB */
+	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01}, /* 19, -9.5dB*/
+	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01}, /* 20, -10.0dB*/
+	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01}, /* 21, -10.5dB*/
+	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01}, /* 22, -11.0dB*/
+	{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01}, /* 23, -11.5dB*/
+	{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01}, /* 24, -12.0dB*/
+	{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01}, /* 25, -12.5dB*/
+	{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01}, /* 26, -13.0dB*/
+	{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01}, /* 27, -13.5dB*/
+	{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01}, /* 28, -14.0dB*/
+	{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01}, /* 29, -14.5dB*/
+	{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01}, /* 30, -15.0dB*/
+	{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01}, /* 31, -15.5dB*/
+	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01} /* 32, -16.0dB*/
+};
+
+u8 cck_swing_table_ch14[CCK_TABLE_SIZE][8] = {
+	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00}, /* 0, +0dB */
+	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00}, /* 1, -0.5dB */
+	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00}, /* 2, -1.0dB */
+	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00}, /* 3, -1.5dB*/
+	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00}, /* 4, -2.0dB */
+	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00}, /* 5, -2.5dB*/
+	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00}, /* 6, -3.0dB */
+	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00}, /* 7, -3.5dB */
+	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00}, /* 8, -4.0dB */
+	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00}, /* 9, -4.5dB*/
+	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00}, /* 10, -5.0dB */
+	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00}, /* 11, -5.5dB*/
+	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00,
+	 0x00}, /* 12, -6.0dB  <== default*/
+	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00}, /* 13, -6.5dB */
+	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00}, /* 14, -7.0dB */
+	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00}, /* 15, -7.5dB*/
+	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00}, /* 16, -8.0dB */
+	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00}, /* 17, -8.5dB*/
+	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00}, /* 18, -9.0dB */
+	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00}, /* 19, -9.5dB*/
+	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00}, /* 20, -10.0dB*/
+	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00}, /* 21, -10.5dB*/
+	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00}, /* 22, -11.0dB*/
+	{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00}, /* 23, -11.5dB*/
+	{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00}, /* 24, -12.0dB*/
+	{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00}, /* 25, -12.5dB*/
+	{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00}, /* 26, -13.0dB*/
+	{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00}, /* 27, -13.5dB*/
+	{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00}, /* 28, -14.0dB*/
+	{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00}, /* 29, -14.5dB*/
+	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00}, /* 30, -15.0dB*/
+	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00}, /* 31, -15.5dB*/
+	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00} /* 32, -16.0dB*/
+};
+
+u32 ofdm_swing_table_new[OFDM_TABLE_SIZE] = {
+	0x0b40002d, /* 0,  -15.0dB	*/
+	0x0c000030, /* 1,  -14.5dB*/
+	0x0cc00033, /* 2,  -14.0dB*/
+	0x0d800036, /* 3,  -13.5dB*/
+	0x0e400039, /* 4,  -13.0dB */
+	0x0f00003c, /* 5,  -12.5dB*/
+	0x10000040, /* 6,  -12.0dB*/
+	0x11000044, /* 7,  -11.5dB*/
+	0x12000048, /* 8,  -11.0dB*/
+	0x1300004c, /* 9,  -10.5dB*/
+	0x14400051, /* 10, -10.0dB*/
+	0x15800056, /* 11, -9.5dB*/
+	0x16c0005b, /* 12, -9.0dB*/
+	0x18000060, /* 13, -8.5dB*/
+	0x19800066, /* 14, -8.0dB*/
+	0x1b00006c, /* 15, -7.5dB*/
+	0x1c800072, /* 16, -7.0dB*/
+	0x1e400079, /* 17, -6.5dB*/
+	0x20000080, /* 18, -6.0dB*/
+	0x22000088, /* 19, -5.5dB*/
+	0x24000090, /* 20, -5.0dB*/
+	0x26000098, /* 21, -4.5dB*/
+	0x288000a2, /* 22, -4.0dB*/
+	0x2ac000ab, /* 23, -3.5dB*/
+	0x2d4000b5, /* 24, -3.0dB*/
+	0x300000c0, /* 25, -2.5dB*/
+	0x32c000cb, /* 26, -2.0dB*/
+	0x35c000d7, /* 27, -1.5dB*/
+	0x390000e4, /* 28, -1.0dB*/
+	0x3c8000f2, /* 29, -0.5dB*/
+	0x40000100, /* 30, +0dB*/
+	0x43c0010f, /* 31, +0.5dB*/
+	0x47c0011f, /* 32, +1.0dB*/
+	0x4c000130, /* 33, +1.5dB*/
+	0x50800142, /* 34, +2.0dB*/
+	0x55400155, /* 35, +2.5dB*/
+	0x5a400169, /* 36, +3.0dB*/
+	0x5fc0017f, /* 37, +3.5dB*/
+	0x65400195, /* 38, +4.0dB*/
+	0x6b8001ae, /* 39, +4.5dB*/
+	0x71c001c7, /* 40, +5.0dB*/
+	0x788001e2, /* 41, +5.5dB*/
+	0x7f8001fe /* 42, +6.0dB*/
+};
+
+u8 cck_swing_table_ch1_ch14_88f[CCK_TABLE_SIZE_88F][16] = {
+	{0x44, 0x42, 0x3C, 0x33, 0x28, 0x1C, 0x13, 0x0B, 0x05, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-16dB*/
+	{0x48, 0x46, 0x3F, 0x36, 0x2A, 0x1E, 0x14, 0x0B, 0x05, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-15.5dB*/
+	{0x4D, 0x4A, 0x43, 0x39, 0x2C, 0x20, 0x15, 0x0C, 0x06, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-15dB*/
+	{0x51, 0x4F, 0x47, 0x3C, 0x2F, 0x22, 0x16, 0x0D, 0x06, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-14.5dB*/
+	{0x56, 0x53, 0x4B, 0x40, 0x32, 0x24, 0x17, 0x0E, 0x06, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-14dB*/
+	{0x5B, 0x58, 0x50, 0x43, 0x35, 0x26, 0x19, 0x0E, 0x07, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-13.5dB*/
+	{0x60, 0x5D, 0x54, 0x47, 0x38, 0x28, 0x1A, 0x0F, 0x07, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-13dB*/
+	{0x66, 0x63, 0x59, 0x4C, 0x3B, 0x2B, 0x1C, 0x10, 0x08, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-12.5dB*/
+	{0x6C, 0x69, 0x5F, 0x50, 0x3F, 0x2D, 0x1E, 0x11, 0x08, 0x03, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-12dB*/
+	{0x73, 0x6F, 0x64, 0x55, 0x42, 0x30, 0x1F, 0x12, 0x08, 0x03, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-11.5dB*/
+	{0x79, 0x76, 0x6A, 0x5A, 0x46, 0x33, 0x21, 0x13, 0x09, 0x03, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-11dB*/
+	{0x81, 0x7C, 0x71, 0x5F, 0x4A, 0x36, 0x23, 0x14, 0x0A, 0x03, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-10.5dB*/
+	{0x88, 0x84, 0x77, 0x65, 0x4F, 0x39, 0x25, 0x15, 0x0A, 0x03, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-10dB*/
+	{0x90, 0x8C, 0x7E, 0x6B, 0x54, 0x3C, 0x27, 0x17, 0x0B, 0x03, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-9.5dB*/
+	{0x99, 0x94, 0x86, 0x71, 0x58, 0x40, 0x2A, 0x18, 0x0B, 0x04, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-9dB*/
+	{0xA2, 0x9D, 0x8E, 0x78, 0x5E, 0x43, 0x2C, 0x19, 0x0C, 0x04, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-8.5dB*/
+	{0xAC, 0xA6, 0x96, 0x7F, 0x63, 0x47, 0x2F, 0x1B, 0x0D, 0x04, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-8dB*/
+	{0xB6, 0xB0, 0x9F, 0x87, 0x69, 0x4C, 0x32, 0x1D, 0x0D, 0x04, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-7.5dB*/
+	{0xC1, 0xBA, 0xA8, 0x8F, 0x6F, 0x50, 0x35, 0x1E, 0x0E, 0x04, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-7dB*/
+	{0xCC, 0xC5, 0xB2, 0x97, 0x76, 0x55, 0x38, 0x20, 0x0F, 0x05, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-6.5dB*/
+	{0xD8, 0xD1, 0xBD, 0xA0, 0x7D, 0x5A, 0x3B, 0x22, 0x10, 0x05, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00} /*-6dB*/
+};
+
+u8 cck_swing_table_ch1_ch13_88f[CCK_TABLE_SIZE_88F][16] = {
+	{0x44, 0x42, 0x3C, 0x33, 0x28, 0x1C, 0x13, 0x0B, 0x05, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-16dB*/
+	{0x48, 0x46, 0x3F, 0x36, 0x2A, 0x1E, 0x14, 0x0B, 0x05, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-15.5dB*/
+	{0x4D, 0x4A, 0x43, 0x39, 0x2C, 0x20, 0x15, 0x0C, 0x06, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-15dB*/
+	{0x51, 0x4F, 0x47, 0x3C, 0x2F, 0x22, 0x16, 0x0D, 0x06, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-14.5dB*/
+	{0x56, 0x53, 0x4B, 0x40, 0x32, 0x24, 0x17, 0x0E, 0x06, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-14dB*/
+	{0x5B, 0x58, 0x50, 0x43, 0x35, 0x26, 0x19, 0x0E, 0x07, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-13.5dB*/
+	{0x60, 0x5D, 0x54, 0x47, 0x38, 0x28, 0x1A, 0x0F, 0x07, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-13dB*/
+	{0x66, 0x63, 0x59, 0x4C, 0x3B, 0x2B, 0x1C, 0x10, 0x08, 0x02, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-12.5dB*/
+	{0x6C, 0x69, 0x5F, 0x50, 0x3F, 0x2D, 0x1E, 0x11, 0x08, 0x03, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-12dB*/
+	{0x73, 0x6F, 0x64, 0x55, 0x42, 0x30, 0x1F, 0x12, 0x08, 0x03, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-11.5dB*/
+	{0x79, 0x76, 0x6A, 0x5A, 0x46, 0x33, 0x21, 0x13, 0x09, 0x03, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-11dB*/
+	{0x81, 0x7C, 0x71, 0x5F, 0x4A, 0x36, 0x23, 0x14, 0x0A, 0x03, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-10.5dB*/
+	{0x88, 0x84, 0x77, 0x65, 0x4F, 0x39, 0x25, 0x15, 0x0A, 0x03, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-10dB*/
+	{0x90, 0x8C, 0x7E, 0x6B, 0x54, 0x3C, 0x27, 0x17, 0x0B, 0x03, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-9.5dB*/
+	{0x99, 0x94, 0x86, 0x71, 0x58, 0x40, 0x2A, 0x18, 0x0B, 0x04, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-9dB*/
+	{0xA2, 0x9D, 0x8E, 0x78, 0x5E, 0x43, 0x2C, 0x19, 0x0C, 0x04, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-8.5dB*/
+	{0xAC, 0xA6, 0x96, 0x7F, 0x63, 0x47, 0x2F, 0x1B, 0x0D, 0x04, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-8dB*/
+	{0xB6, 0xB0, 0x9F, 0x87, 0x69, 0x4C, 0x32, 0x1D, 0x0D, 0x04, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-7.5dB*/
+	{0xC1, 0xBA, 0xA8, 0x8F, 0x6F, 0x50, 0x35, 0x1E, 0x0E, 0x04, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-7dB*/
+	{0xCC, 0xC5, 0xB2, 0x97, 0x76, 0x55, 0x38, 0x20, 0x0F, 0x05, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-6.5dB*/
+	{0xD8, 0xD1, 0xBD, 0xA0, 0x7D, 0x5A, 0x3B, 0x22, 0x10, 0x05, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00} /*-6dB*/
+};
+
+u8 cck_swing_table_ch14_88f[CCK_TABLE_SIZE_88F][16] = {
+	{0x44, 0x42, 0x3C, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-16dB*/
+	{0x48, 0x46, 0x3F, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-15.5dB*/
+	{0x4D, 0x4A, 0x43, 0x2C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-15dB*/
+	{0x51, 0x4F, 0x47, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-14.5dB*/
+	{0x56, 0x53, 0x4B, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-14dB*/
+	{0x5B, 0x58, 0x50, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-13.5dB*/
+	{0x60, 0x5D, 0x54, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-13dB*/
+	{0x66, 0x63, 0x59, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-12.5dB*/
+	{0x6C, 0x69, 0x5F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-12dB*/
+	{0x73, 0x6F, 0x64, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-11.5dB*/
+	{0x79, 0x76, 0x6A, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-11dB*/
+	{0x81, 0x7C, 0x71, 0x4A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-10.5dB*/
+	{0x88, 0x84, 0x77, 0x4F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-10dB*/
+	{0x90, 0x8C, 0x7E, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-9.5dB*/
+	{0x99, 0x94, 0x86, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-9dB*/
+	{0xA2, 0x9D, 0x8E, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-8.5dB*/
+	{0xAC, 0xA6, 0x96, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-8dB*/
+	{0xB6, 0xB0, 0x9F, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-7.5dB*/
+	{0xC1, 0xBA, 0xA8, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-7dB*/
+	{0xCC, 0xC5, 0xB2, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}, /*-6.5dB*/
+	{0xD8, 0xD1, 0xBD, 0x7D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00} /*-6dB*/
+};
+
+u8 cck_swing_table_ch1_ch13_new[CCK_TABLE_SIZE][8] = {
+	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01}, /*  0, -16.0dB*/
+	{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01}, /*   1, -15.5dB*/
+	{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01}, /*  2, -15.0dB*/
+	{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01}, /*   3, -14.5dB*/
+	{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01}, /*   4, -14.0dB*/
+	{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01}, /*   5, -13.5dB*/
+	{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01}, /*   6, -13.0dB*/
+	{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01}, /*   7, -12.5dB*/
+	{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01}, /*  8, -12.0dB*/
+	{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01}, /*   9, -11.5dB*/
+	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01}, /*  10, -11.0dB*/
+	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01}, /*  11, -10.5dB*/
+	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01}, /*  12, -10.0dB*/
+	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01}, /*  13, -9.5dB*/
+	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01}, /*  14, -9.0dB */
+	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02}, /*  15, -8.5dB*/
+	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01}, /*  16, -8.0dB */
+	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02}, /*  17, -7.5dB*/
+	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02}, /*  18, -7.0dB */
+	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02}, /*  19, -6.5dB*/
+	{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02}, /*20, -6.0dB */
+	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02}, /*  21, -5.5dB*/
+	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02}, /* 22, -5.0dB */
+	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02}, /*  23, -4.5dB*/
+	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02}, /*  24, -4.0dB */
+	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03}, /*  25, -3.5dB*/
+	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03}, /*  26, -3.0dB*/
+	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03}, /*  27, -2.5dB*/
+	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03}, /*  28, -2.0dB */
+	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03}, /*  29, -1.5dB*/
+	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03}, /*  30, -1.0dB*/
+	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04}, /*  31, -0.5dB*/
+	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04} /*  32, +0dB*/
+};
+
+u8 cck_swing_table_ch14_new[CCK_TABLE_SIZE][8] = {
+	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00}, /*  0, -16.0dB*/
+	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00}, /* 1, -15.5dB*/
+	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00}, /*  2, -15.0dB*/
+	{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00}, /* 3, -14.5dB*/
+	{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00}, /*  4, -14.0dB*/
+	{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00}, /*5, -13.5dB*/
+	{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00}, /* 6, -13.0dB*/
+	{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00}, /*  7, -12.5dB*/
+	{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00}, /* 8, -12.0dB*/
+	{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00}, /* 9, -11.5dB*/
+	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00}, /* 10, -11.0dB*/
+	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00}, /*11, -10.5dB*/
+	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00}, /* 12, -10.0dB*/
+	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00}, /* 13, -9.5dB*/
+	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00}, /*14, -9.0dB */
+	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00}, /* 15, -8.5dB*/
+	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00}, /* 16, -8.0dB */
+	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00}, /* 17, -7.5dB*/
+	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00}, /* 18, -7.0dB */
+	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00}, /* 19, -6.5dB */
+	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00}, /* 20, -6.0dB */
+	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00}, /* 21, -5.5dB*/
+	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00}, /* 22, -5.0dB */
+	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00}, /*23, -4.5dB*/
+	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00}, /* 24, -4.0dB */
+	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00}, /* 25, -3.5dB */
+	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00}, /* 26, -3.0dB */
+	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00}, /*27, -2.5dB*/
+	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00}, /* 28, -2.0dB */
+	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00}, /*29, -1.5dB*/
+	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00}, /* 30, -1.0dB */
+	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00}, /* 31, -0.5dB */
+	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00} /* 32, +0dB	*/
+};
+
+u32 cck_swing_table_ch1_ch14_8723d[CCK_TABLE_SIZE_8723D] = {
+	0x0CD, /*0 ,    -20dB*/
+	0x0D9, 0x0E6, 0x0F3, 0x102, 0x111, 0x121, 0x132, 0x144, 0x158, 0x16C,
+	0x182, 0x198, 0x1B1, 0x1CA, 0x1E5, 0x202, 0x221, 0x241, 0x263, 0x287,
+	0x2AE, 0x2D6, 0x301, 0x32F, 0x35F, 0x392, 0x3C9, 0x402, 0x43F, 0x47F,
+	0x4C3, 0x50C, 0x558, 0x5A9, 0x5FF, 0x65A, 0x6BA, 0x720, 0x78C, 0x7FF,
+};
+
+/* JJ ADD 20161014 */
+u32 cck_swing_table_ch1_ch14_8710b[CCK_TABLE_SIZE_8710B] = {
+	0x0CD, /*0 ,    -20dB*/
+	0x0D9, 0x0E6, 0x0F3, 0x102, 0x111, 0x121, 0x132, 0x144, 0x158, 0x16C,
+	0x182, 0x198, 0x1B1, 0x1CA, 0x1E5, 0x202, 0x221, 0x241, 0x263, 0x287,
+	0x2AE, 0x2D6, 0x301, 0x32F, 0x35F, 0x392, 0x3C9, 0x402, 0x43F, 0x47F,
+	0x4C3, 0x50C, 0x558, 0x5A9, 0x5FF, 0x65A, 0x6BA, 0x720, 0x78C, 0x7FF,
+};
+
+u32 tx_scaling_table_jaguar[TXSCALE_TABLE_SIZE] = {
+	0x081, /* 0,  -12.0dB*/
+	0x088, /* 1,  -11.5dB*/
+	0x090, /* 2,  -11.0dB*/
+	0x099, /* 3,  -10.5dB*/
+	0x0A2, /* 4,  -10.0dB*/
+	0x0AC, /* 5,  -9.5dB*/
+	0x0B6, /* 6,  -9.0dB*/
+	0x0C0, /*7,  -8.5dB*/
+	0x0CC, /* 8,  -8.0dB*/
+	0x0D8, /* 9,  -7.5dB*/
+	0x0E5, /* 10, -7.0dB*/
+	0x0F2, /* 11, -6.5dB*/
+	0x101, /* 12, -6.0dB*/
+	0x110, /* 13, -5.5dB*/
+	0x120, /* 14, -5.0dB*/
+	0x131, /* 15, -4.5dB*/
+	0x143, /* 16, -4.0dB*/
+	0x156, /* 17, -3.5dB*/
+	0x16A, /* 18, -3.0dB*/
+	0x180, /* 19, -2.5dB*/
+	0x197, /* 20, -2.0dB*/
+	0x1AF, /* 21, -1.5dB*/
+	0x1C8, /* 22, -1.0dB*/
+	0x1E3, /* 23, -0.5dB*/
+	0x200, /* 24, +0  dB*/
+	0x21E, /* 25, +0.5dB*/
+	0x23E, /* 26, +1.0dB*/
+	0x261, /* 27, +1.5dB*/
+	0x285, /* 28, +2.0dB*/
+	0x2AB, /* 29, +2.5dB*/
+	0x2D3, /*30, +3.0dB*/
+	0x2FE, /* 31, +3.5dB*/
+	0x32B, /* 32, +4.0dB*/
+	0x35C, /* 33, +4.5dB*/
+	0x38E, /* 34, +5.0dB*/
+	0x3C4, /* 35, +5.5dB*/
+	0x3FE /* 36, +6.0dB	*/
+};
+
+void odm_txpowertracking_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	odm_txpowertracking_thermal_meter_init(dm);
+}
+
+static u8 get_swing_index(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 i = 0;
+	u32 bb_swing;
+	u32 swing_table_size;
+	u32 *swing_table;
+
+	if (dm->support_ic_type == ODM_RTL8188E ||
+	    dm->support_ic_type == ODM_RTL8723B ||
+	    dm->support_ic_type == ODM_RTL8192E ||
+	    dm->support_ic_type == ODM_RTL8188F ||
+	    dm->support_ic_type == ODM_RTL8703B) {
+		bb_swing = odm_get_bb_reg(dm, REG_OFDM_0_XA_TX_IQ_IMBALANCE,
+					  0xFFC00000);
+
+		swing_table = ofdm_swing_table_new;
+		swing_table_size = OFDM_TABLE_SIZE;
+	} else {
+		{
+			bb_swing = 0;
+			swing_table = ofdm_swing_table;
+			swing_table_size = OFDM_TABLE_SIZE;
+		}
+	}
+
+	for (i = 0; i < swing_table_size; ++i) {
+		u32 table_value = swing_table[i];
+
+		if (table_value >= 0x100000)
+			table_value >>= 22;
+		if (bb_swing == table_value)
+			break;
+	}
+	return i;
+}
+
+void odm_txpowertracking_thermal_meter_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 default_swing_index = get_swing_index(dm);
+	u8 p = 0;
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+	struct rtl_efuse *rtlefu = rtl_efuse(rtlpriv);
+
+	cali_info->is_txpowertracking = true;
+	cali_info->tx_powercount = 0;
+	cali_info->is_txpowertracking_init = false;
+
+	if (!dm->mp_mode)
+		cali_info->txpowertrack_control = true;
+	else
+		cali_info->txpowertrack_control = false;
+
+	if (!dm->mp_mode)
+		cali_info->txpowertrack_control = true;
+
+	ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION, "dm txpowertrack_control = %d\n",
+		     cali_info->txpowertrack_control);
+
+	/* dm->rf_calibrate_info.txpowertrack_control = true; */
+	cali_info->thermal_value = rtlefu->eeprom_thermalmeter;
+	cali_info->thermal_value_iqk = rtlefu->eeprom_thermalmeter;
+	cali_info->thermal_value_lck = rtlefu->eeprom_thermalmeter;
+
+	if (!cali_info->default_bb_swing_index_flag) {
+		/*The index of "0 dB" in SwingTable.*/
+		if (dm->support_ic_type == ODM_RTL8188E ||
+		    dm->support_ic_type == ODM_RTL8723B ||
+		    dm->support_ic_type == ODM_RTL8192E ||
+		    dm->support_ic_type == ODM_RTL8703B) {
+			cali_info->default_ofdm_index =
+				(default_swing_index >= OFDM_TABLE_SIZE) ?
+					30 :
+					default_swing_index;
+			cali_info->default_cck_index = 20;
+		} else if (dm->support_ic_type ==
+			   ODM_RTL8188F) { /*add by Mingzhi.Guo  2015-03-23*/
+			cali_info->default_ofdm_index = 28; /*OFDM: -1dB*/
+			cali_info->default_cck_index = 20; /*CCK:-6dB*/
+		} else if (dm->support_ic_type ==
+			   ODM_RTL8723D) { /*add by zhaohe  2015-10-27*/
+			cali_info->default_ofdm_index = 28; /*OFDM: -1dB*/
+			cali_info->default_cck_index = 28; /*CCK:   -6dB*/
+		} else if (dm->support_ic_type ==
+			   ODM_RTL8710B) { /* JJ ADD 20161014 */
+			cali_info->default_ofdm_index = 28; /*OFDM: -1dB*/
+			cali_info->default_cck_index = 28; /*CCK:   -6dB*/
+		} else {
+			cali_info->default_ofdm_index =
+				(default_swing_index >= TXSCALE_TABLE_SIZE) ?
+					24 :
+					default_swing_index;
+			cali_info->default_cck_index = 24;
+		}
+		cali_info->default_bb_swing_index_flag = true;
+	}
+
+	cali_info->bb_swing_idx_cck_base = cali_info->default_cck_index;
+	cali_info->CCK_index = cali_info->default_cck_index;
+
+	for (p = ODM_RF_PATH_A; p < MAX_RF_PATH; ++p) {
+		cali_info->bb_swing_idx_ofdm_base[p] =
+			cali_info->default_ofdm_index;
+		cali_info->OFDM_index[p] = cali_info->default_ofdm_index;
+		cali_info->delta_power_index[p] = 0;
+		cali_info->delta_power_index_last[p] = 0;
+		cali_info->power_index_offset[p] = 0;
+	}
+	cali_info->modify_tx_agc_value_ofdm = 0;
+	cali_info->modify_tx_agc_value_cck = 0;
+}
+
+void odm_txpowertracking_check(void *dm_void)
+{
+	/* 2011/09/29 MH In HW integration first stage, we provide 4 different
+	 * handle to operate at the same time.
+	 * In the stage2/3, we need to prive universal interface and merge all
+	 * HW dynamic mechanism.
+	 */
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	switch (dm->support_platform) {
+	case ODM_WIN:
+		odm_txpowertracking_check_mp(dm);
+		break;
+
+	case ODM_CE:
+		odm_txpowertracking_check_ce(dm);
+		break;
+
+	case ODM_AP:
+		odm_txpowertracking_check_ap(dm);
+		break;
+
+	default:
+		break;
+	}
+}
+
+void odm_txpowertracking_check_ce(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	void *adapter = dm->adapter;
+
+	if (!(dm->support_ability & ODM_RF_TX_PWR_TRACK))
+		return;
+
+	if (!dm->rf_calibrate_info.tm_trigger) {
+		if (IS_HARDWARE_TYPE_8188E(adapter) ||
+		    IS_HARDWARE_TYPE_8188F(adapter) ||
+		    IS_HARDWARE_TYPE_8192E(adapter) ||
+		    IS_HARDWARE_TYPE_8723B(adapter) ||
+		    IS_HARDWARE_TYPE_JAGUAR(adapter) ||
+		    IS_HARDWARE_TYPE_8814A(adapter) ||
+		    IS_HARDWARE_TYPE_8703B(adapter) ||
+		    IS_HARDWARE_TYPE_8723D(adapter) ||
+		    IS_HARDWARE_TYPE_8822B(adapter) ||
+		    IS_HARDWARE_TYPE_8821C(adapter) ||
+		    (dm->support_ic_type == ODM_RTL8710B)) /* JJ ADD 20161014 */
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, RF_T_METER_NEW,
+				       (BIT(17) | BIT(16)), 0x03);
+		else
+			odm_set_rf_reg(dm, ODM_RF_PATH_A, RF_T_METER_OLD,
+				       RFREGOFFSETMASK, 0x60);
+
+		dm->rf_calibrate_info.tm_trigger = 1;
+		return;
+	}
+
+	odm_txpowertracking_callback_thermal_meter(dm);
+	dm->rf_calibrate_info.tm_trigger = 0;
+}
+
+void odm_txpowertracking_check_mp(void *dm_void) {}
+
+void odm_txpowertracking_check_ap(void *dm_void) {}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_powertracking_ce.h b/drivers/staging/rtlwifi/phydm/phydm_powertracking_ce.h
new file mode 100644
index 000000000000..757d7720d931
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_powertracking_ce.h
@@ -0,0 +1,293 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDMPOWERTRACKING_H__
+#define __PHYDMPOWERTRACKING_H__
+
+#define POWRTRACKING_VERSION "1.1"
+
+#define DPK_DELTA_MAPPING_NUM 13
+#define index_mapping_HP_NUM 15
+#define OFDM_TABLE_SIZE 43
+#define CCK_TABLE_SIZE 33
+#define CCK_TABLE_SIZE_88F 21
+#define TXSCALE_TABLE_SIZE 37
+#define CCK_TABLE_SIZE_8723D 41
+/* JJ ADD 20161014 */
+#define CCK_TABLE_SIZE_8710B 41
+
+#define TXPWR_TRACK_TABLE_SIZE 30
+#define DELTA_SWINGIDX_SIZE 30
+#define DELTA_SWINTSSI_SIZE 61
+#define BAND_NUM 4
+
+#define AVG_THERMAL_NUM 8
+#define HP_THERMAL_NUM 8
+#define IQK_MAC_REG_NUM 4
+#define IQK_ADDA_REG_NUM 16
+#define IQK_BB_REG_NUM_MAX 10
+
+#define IQK_BB_REG_NUM 9
+
+#define iqk_matrix_reg_num 8
+
+extern u32 ofdm_swing_table[OFDM_TABLE_SIZE];
+extern u8 cck_swing_table_ch1_ch13[CCK_TABLE_SIZE][8];
+extern u8 cck_swing_table_ch14[CCK_TABLE_SIZE][8];
+
+extern u32 ofdm_swing_table_new[OFDM_TABLE_SIZE];
+extern u8 cck_swing_table_ch1_ch13_new[CCK_TABLE_SIZE][8];
+extern u8 cck_swing_table_ch14_new[CCK_TABLE_SIZE][8];
+extern u8 cck_swing_table_ch1_ch14_88f[CCK_TABLE_SIZE_88F][16];
+extern u8 cck_swing_table_ch1_ch13_88f[CCK_TABLE_SIZE_88F][16];
+extern u8 cck_swing_table_ch14_88f[CCK_TABLE_SIZE_88F][16];
+extern u32 cck_swing_table_ch1_ch14_8723d[CCK_TABLE_SIZE_8723D];
+/* JJ ADD 20161014 */
+extern u32 cck_swing_table_ch1_ch14_8710b[CCK_TABLE_SIZE_8710B];
+
+extern u32 tx_scaling_table_jaguar[TXSCALE_TABLE_SIZE];
+
+/* <20121018, Kordan> In case fail to read TxPowerTrack.txt,
+ * we use the table of 88E as the default table.
+ */
+
+#define dm_check_txpowertracking odm_txpowertracking_check
+
+struct iqk_matrix_regs_setting {
+	bool is_iqk_done;
+	s32 value[3][iqk_matrix_reg_num];
+	bool is_bw_iqk_result_saved[3];
+};
+
+struct dm_rf_calibration_struct {
+	/* for tx power tracking */
+
+	u32 rega24; /* for TempCCK */
+	s32 rege94;
+	s32 rege9c;
+	s32 regeb4;
+	s32 regebc;
+
+	u8 tx_powercount;
+	bool is_txpowertracking_init;
+	bool is_txpowertracking;
+	/* for mp mode, turn off txpwrtracking as default */
+	u8 txpowertrack_control;
+	u8 tm_trigger;
+	u8 internal_pa_5g[2]; /* pathA / pathB */
+
+	u8 thermal_meter
+		[2]; /* thermal_meter, index 0 for RFIC0, and 1 for RFIC1 */
+	u8 thermal_value;
+	u8 thermal_value_lck;
+	u8 thermal_value_iqk;
+	s8 thermal_value_delta; /* delta of thermal_value and efuse thermal */
+	u8 thermal_value_dpk;
+	u8 thermal_value_avg[AVG_THERMAL_NUM];
+	u8 thermal_value_avg_index;
+	u8 thermal_value_rx_gain;
+	u8 thermal_value_crystal;
+	u8 thermal_value_dpk_store;
+	u8 thermal_value_dpk_track;
+	bool txpowertracking_in_progress;
+
+	bool is_reloadtxpowerindex;
+	u8 is_rf_pi_enable;
+	u32 txpowertracking_callback_cnt; /* cosa add for debug */
+
+	/* ---------------------- Tx power Tracking ------------------------- */
+	u8 is_cck_in_ch14;
+	u8 CCK_index;
+	u8 OFDM_index[MAX_RF_PATH];
+	s8 power_index_offset[MAX_RF_PATH];
+	s8 delta_power_index[MAX_RF_PATH];
+	s8 delta_power_index_last[MAX_RF_PATH];
+	bool is_tx_power_changed;
+	s8 xtal_offset;
+	s8 xtal_offset_last;
+
+	u8 thermal_value_hp[HP_THERMAL_NUM];
+	u8 thermal_value_hp_index;
+	struct iqk_matrix_regs_setting
+		iqk_matrix_reg_setting[IQK_MATRIX_SETTINGS_NUM];
+	u8 delta_lck;
+	s8 bb_swing_diff_2g, bb_swing_diff_5g; /* Unit: dB */
+	u8 delta_swing_table_idx_2g_cck_a_p[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2g_cck_a_n[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2g_cck_b_p[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2g_cck_b_n[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2g_cck_c_p[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2g_cck_c_n[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2g_cck_d_p[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2g_cck_d_n[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2ga_p[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2ga_n[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2gb_p[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2gb_n[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2gc_p[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2gc_n[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2gd_p[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2gd_n[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_5ga_p[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_5ga_n[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_5gb_p[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_5gb_n[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_5gc_p[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_5gc_n[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_5gd_p[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_5gd_n[BAND_NUM][DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_tssi_table_2g_cck_a[DELTA_SWINTSSI_SIZE];
+	u8 delta_swing_tssi_table_2g_cck_b[DELTA_SWINTSSI_SIZE];
+	u8 delta_swing_tssi_table_2g_cck_c[DELTA_SWINTSSI_SIZE];
+	u8 delta_swing_tssi_table_2g_cck_d[DELTA_SWINTSSI_SIZE];
+	u8 delta_swing_tssi_table_2ga[DELTA_SWINTSSI_SIZE];
+	u8 delta_swing_tssi_table_2gb[DELTA_SWINTSSI_SIZE];
+	u8 delta_swing_tssi_table_2gc[DELTA_SWINTSSI_SIZE];
+	u8 delta_swing_tssi_table_2gd[DELTA_SWINTSSI_SIZE];
+	u8 delta_swing_tssi_table_5ga[BAND_NUM][DELTA_SWINTSSI_SIZE];
+	u8 delta_swing_tssi_table_5gb[BAND_NUM][DELTA_SWINTSSI_SIZE];
+	u8 delta_swing_tssi_table_5gc[BAND_NUM][DELTA_SWINTSSI_SIZE];
+	u8 delta_swing_tssi_table_5gd[BAND_NUM][DELTA_SWINTSSI_SIZE];
+	s8 delta_swing_table_xtal_p[DELTA_SWINGIDX_SIZE];
+	s8 delta_swing_table_xtal_n[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2ga_p_8188e[DELTA_SWINGIDX_SIZE];
+	u8 delta_swing_table_idx_2ga_n_8188e[DELTA_SWINGIDX_SIZE];
+
+	u8 bb_swing_idx_ofdm[MAX_RF_PATH];
+	u8 bb_swing_idx_ofdm_current;
+	u8 bb_swing_idx_ofdm_base[MAX_RF_PATH];
+	bool default_bb_swing_index_flag;
+	bool bb_swing_flag_ofdm;
+	u8 bb_swing_idx_cck;
+	u8 bb_swing_idx_cck_current;
+	u8 bb_swing_idx_cck_base;
+	u8 default_ofdm_index;
+	u8 default_cck_index;
+	bool bb_swing_flag_cck;
+
+	s8 absolute_ofdm_swing_idx[MAX_RF_PATH];
+	s8 remnant_ofdm_swing_idx[MAX_RF_PATH];
+	s8 absolute_cck_swing_idx[MAX_RF_PATH];
+	s8 remnant_cck_swing_idx;
+	s8 modify_tx_agc_value; /*Remnat compensate value at tx_agc */
+	bool modify_tx_agc_flag_path_a;
+	bool modify_tx_agc_flag_path_b;
+	bool modify_tx_agc_flag_path_c;
+	bool modify_tx_agc_flag_path_d;
+	bool modify_tx_agc_flag_path_a_cck;
+
+	s8 kfree_offset[MAX_RF_PATH];
+
+	/* ------------------------------------------------------------------ */
+
+	/* for IQK */
+	u32 regc04;
+	u32 reg874;
+	u32 regc08;
+	u32 regb68;
+	u32 regb6c;
+	u32 reg870;
+	u32 reg860;
+	u32 reg864;
+
+	bool is_iqk_initialized;
+	bool is_lck_in_progress;
+	bool is_antenna_detected;
+	bool is_need_iqk;
+	bool is_iqk_in_progress;
+	bool is_iqk_pa_off;
+	u8 delta_iqk;
+	u32 ADDA_backup[IQK_ADDA_REG_NUM];
+	u32 IQK_MAC_backup[IQK_MAC_REG_NUM];
+	u32 IQK_BB_backup_recover[9];
+	/* { {S1: 0xc94, 0xc80, 0xc4c} , {S0: 0xc9c, 0xc88, 0xc4c}} */
+	u32 IQK_BB_backup[IQK_BB_REG_NUM];
+	u32 tx_iqc_8723b[2][3][2];
+	/* { {S1: 0xc14, 0xca0} ,           {S0: 0xc14, 0xca0}} */
+	u32 rx_iqc_8723b[2][2][2];
+	/* { {S1: 0xc94, 0xc80, 0xc4c} , {S0: 0xc9c, 0xc88, 0xc4c}}*/
+	u32 tx_iqc_8703b[3][2];
+	/* { {S1: 0xc14, 0xca0} ,           {S0: 0xc14, 0xca0}}*/
+	u32 rx_iqc_8703b[2][2];
+	/* { {S1: 0xc94, 0xc80, 0xc4c} , {S0: 0xc9c, 0xc88, 0xc4c}}*/
+	u32 tx_iqc_8723d[2][3][2];
+	/* { {S1: 0xc14, 0xca0} ,           {S0: 0xc14, 0xca0}}*/
+	u32 rx_iqc_8723d[2][2][2];
+	/* JJ ADD 20161014 */
+	/* { {S1: 0xc94, 0xc80, 0xc4c} , {S0: 0xc9c, 0xc88, 0xc4c}}*/
+	u32 tx_iqc_8710b[2][3][2];
+	/* { {S1: 0xc14, 0xca0} ,           {S0: 0xc14, 0xca0}}*/
+	u32 rx_iqc_8710b[2][2][2];
+
+	u8 iqk_step;
+	u8 kcount;
+	u8 retry_count[4][2]; /* [4]: path ABCD, [2] TXK, RXK */
+	bool is_mp_mode;
+
+	/* <James> IQK time measurement */
+	u64 iqk_start_time;
+	u64 iqk_progressing_time;
+	u64 iqk_total_progressing_time;
+
+	u32 lok_result;
+
+	/* for APK */
+	u32 ap_koutput[2][2]; /* path A/B; output1_1a/output1_2a */
+	u8 is_ap_kdone;
+	u8 is_apk_thermal_meter_ignore;
+
+	/* DPK */
+	bool is_dpk_fail;
+	u8 is_dp_done;
+	u8 is_dp_path_aok;
+	u8 is_dp_path_bok;
+
+	u32 tx_lok[2];
+	u32 dpk_tx_agc;
+	s32 dpk_gain;
+	u32 dpk_thermal[4];
+	s8 modify_tx_agc_value_ofdm;
+	s8 modify_tx_agc_value_cck;
+
+	/*Add by Yuchen for Kfree Phydm*/
+	u8 reg_rf_kfree_enable; /*for registry*/
+	u8 rf_kfree_enable; /*for efuse enable check*/
+};
+
+void odm_txpowertracking_check(void *dm_void);
+
+void odm_txpowertracking_init(void *dm_void);
+
+void odm_txpowertracking_check_ap(void *dm_void);
+
+void odm_txpowertracking_thermal_meter_init(void *dm_void);
+
+void odm_txpowertracking_init(void *dm_void);
+
+void odm_txpowertracking_check_mp(void *dm_void);
+
+void odm_txpowertracking_check_ce(void *dm_void);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_pre_define.h b/drivers/staging/rtlwifi/phydm/phydm_pre_define.h
new file mode 100644
index 000000000000..6c301fe87b3d
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_pre_define.h
@@ -0,0 +1,613 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDMPREDEFINE_H__
+#define __PHYDMPREDEFINE_H__
+
+/* 1 ============================================================
+ * 1  Definition
+ * 1 ============================================================
+ */
+
+#define PHYDM_CODE_BASE "PHYDM_TRUNK"
+#define PHYDM_RELEASE_DATE "00000000"
+
+/* Max path of IC */
+#define MAX_PATH_NUM_8188E 1
+#define MAX_PATH_NUM_8192E 2
+#define MAX_PATH_NUM_8723B 1
+#define MAX_PATH_NUM_8812A 2
+#define MAX_PATH_NUM_8821A 1
+#define MAX_PATH_NUM_8814A 4
+#define MAX_PATH_NUM_8822B 2
+#define MAX_PATH_NUM_8821B 2
+#define MAX_PATH_NUM_8703B 1
+#define MAX_PATH_NUM_8188F 1
+#define MAX_PATH_NUM_8723D 1
+#define MAX_PATH_NUM_8197F 2
+#define MAX_PATH_NUM_8821C 1
+/* JJ ADD 20161014 */
+#define MAX_PATH_NUM_8710B 1
+
+/* Max RF path */
+#define ODM_RF_PATH_MAX 2
+#define ODM_RF_PATH_MAX_JAGUAR 4
+
+/*Bit define path*/
+#define PHYDM_A BIT(0)
+#define PHYDM_B BIT(1)
+#define PHYDM_C BIT(2)
+#define PHYDM_D BIT(3)
+#define PHYDM_AB (BIT(0) | BIT(1))
+#define PHYDM_AC (BIT(0) | BIT(2))
+#define PHYDM_AD (BIT(0) | BIT(3))
+#define PHYDM_BC (BIT(1) | BIT(2))
+#define PHYDM_BD (BIT(1) | BIT(3))
+#define PHYDM_CD (BIT(2) | BIT(3))
+#define PHYDM_ABC (BIT(0) | BIT(1) | BIT(2))
+#define PHYDM_ABD (BIT(0) | BIT(1) | BIT(3))
+#define PHYDM_ACD (BIT(0) | BIT(2) | BIT(3))
+#define PHYDM_BCD (BIT(1) | BIT(2) | BIT(3))
+#define PHYDM_ABCD (BIT(0) | BIT(1) | BIT(2) | BIT(3))
+
+/* number of entry */
+/* defined in wifi.h (32+1) */
+#define ODM_ASSOCIATE_ENTRY_NUM ASSOCIATE_ENTRY_NUM
+
+#define RX_SMOOTH_FACTOR 20
+
+/* -----MGN rate--------------------------------- */
+
+enum ODM_MGN_RATE {
+	ODM_MGN_1M = 0x02,
+	ODM_MGN_2M = 0x04,
+	ODM_MGN_5_5M = 0x0B,
+	ODM_MGN_6M = 0x0C,
+	ODM_MGN_9M = 0x12,
+	ODM_MGN_11M = 0x16,
+	ODM_MGN_12M = 0x18,
+	ODM_MGN_18M = 0x24,
+	ODM_MGN_24M = 0x30,
+	ODM_MGN_36M = 0x48,
+	ODM_MGN_48M = 0x60,
+	ODM_MGN_54M = 0x6C,
+	ODM_MGN_MCS32 = 0x7F,
+	ODM_MGN_MCS0,
+	ODM_MGN_MCS1,
+	ODM_MGN_MCS2,
+	ODM_MGN_MCS3,
+	ODM_MGN_MCS4,
+	ODM_MGN_MCS5,
+	ODM_MGN_MCS6,
+	ODM_MGN_MCS7,
+	ODM_MGN_MCS8,
+	ODM_MGN_MCS9,
+	ODM_MGN_MCS10,
+	ODM_MGN_MCS11,
+	ODM_MGN_MCS12,
+	ODM_MGN_MCS13,
+	ODM_MGN_MCS14,
+	ODM_MGN_MCS15,
+	ODM_MGN_MCS16,
+	ODM_MGN_MCS17,
+	ODM_MGN_MCS18,
+	ODM_MGN_MCS19,
+	ODM_MGN_MCS20,
+	ODM_MGN_MCS21,
+	ODM_MGN_MCS22,
+	ODM_MGN_MCS23,
+	ODM_MGN_MCS24,
+	ODM_MGN_MCS25,
+	ODM_MGN_MCS26,
+	ODM_MGN_MCS27,
+	ODM_MGN_MCS28,
+	ODM_MGN_MCS29,
+	ODM_MGN_MCS30,
+	ODM_MGN_MCS31,
+	ODM_MGN_VHT1SS_MCS0,
+	ODM_MGN_VHT1SS_MCS1,
+	ODM_MGN_VHT1SS_MCS2,
+	ODM_MGN_VHT1SS_MCS3,
+	ODM_MGN_VHT1SS_MCS4,
+	ODM_MGN_VHT1SS_MCS5,
+	ODM_MGN_VHT1SS_MCS6,
+	ODM_MGN_VHT1SS_MCS7,
+	ODM_MGN_VHT1SS_MCS8,
+	ODM_MGN_VHT1SS_MCS9,
+	ODM_MGN_VHT2SS_MCS0,
+	ODM_MGN_VHT2SS_MCS1,
+	ODM_MGN_VHT2SS_MCS2,
+	ODM_MGN_VHT2SS_MCS3,
+	ODM_MGN_VHT2SS_MCS4,
+	ODM_MGN_VHT2SS_MCS5,
+	ODM_MGN_VHT2SS_MCS6,
+	ODM_MGN_VHT2SS_MCS7,
+	ODM_MGN_VHT2SS_MCS8,
+	ODM_MGN_VHT2SS_MCS9,
+	ODM_MGN_VHT3SS_MCS0,
+	ODM_MGN_VHT3SS_MCS1,
+	ODM_MGN_VHT3SS_MCS2,
+	ODM_MGN_VHT3SS_MCS3,
+	ODM_MGN_VHT3SS_MCS4,
+	ODM_MGN_VHT3SS_MCS5,
+	ODM_MGN_VHT3SS_MCS6,
+	ODM_MGN_VHT3SS_MCS7,
+	ODM_MGN_VHT3SS_MCS8,
+	ODM_MGN_VHT3SS_MCS9,
+	ODM_MGN_VHT4SS_MCS0,
+	ODM_MGN_VHT4SS_MCS1,
+	ODM_MGN_VHT4SS_MCS2,
+	ODM_MGN_VHT4SS_MCS3,
+	ODM_MGN_VHT4SS_MCS4,
+	ODM_MGN_VHT4SS_MCS5,
+	ODM_MGN_VHT4SS_MCS6,
+	ODM_MGN_VHT4SS_MCS7,
+	ODM_MGN_VHT4SS_MCS8,
+	ODM_MGN_VHT4SS_MCS9,
+	ODM_MGN_UNKNOWN
+};
+
+#define ODM_MGN_MCS0_SG 0xc0
+#define ODM_MGN_MCS1_SG 0xc1
+#define ODM_MGN_MCS2_SG 0xc2
+#define ODM_MGN_MCS3_SG 0xc3
+#define ODM_MGN_MCS4_SG 0xc4
+#define ODM_MGN_MCS5_SG 0xc5
+#define ODM_MGN_MCS6_SG 0xc6
+#define ODM_MGN_MCS7_SG 0xc7
+#define ODM_MGN_MCS8_SG 0xc8
+#define ODM_MGN_MCS9_SG 0xc9
+#define ODM_MGN_MCS10_SG 0xca
+#define ODM_MGN_MCS11_SG 0xcb
+#define ODM_MGN_MCS12_SG 0xcc
+#define ODM_MGN_MCS13_SG 0xcd
+#define ODM_MGN_MCS14_SG 0xce
+#define ODM_MGN_MCS15_SG 0xcf
+
+/* -----DESC rate--------------------------------- */
+
+#define ODM_RATEMCS15_SG 0x1c
+#define ODM_RATEMCS32 0x20
+
+/* CCK Rates, TxHT = 0 */
+#define ODM_RATE1M 0x00
+#define ODM_RATE2M 0x01
+#define ODM_RATE5_5M 0x02
+#define ODM_RATE11M 0x03
+/* OFDM Rates, TxHT = 0 */
+#define ODM_RATE6M 0x04
+#define ODM_RATE9M 0x05
+#define ODM_RATE12M 0x06
+#define ODM_RATE18M 0x07
+#define ODM_RATE24M 0x08
+#define ODM_RATE36M 0x09
+#define ODM_RATE48M 0x0A
+#define ODM_RATE54M 0x0B
+/* MCS Rates, TxHT = 1 */
+#define ODM_RATEMCS0 0x0C
+#define ODM_RATEMCS1 0x0D
+#define ODM_RATEMCS2 0x0E
+#define ODM_RATEMCS3 0x0F
+#define ODM_RATEMCS4 0x10
+#define ODM_RATEMCS5 0x11
+#define ODM_RATEMCS6 0x12
+#define ODM_RATEMCS7 0x13
+#define ODM_RATEMCS8 0x14
+#define ODM_RATEMCS9 0x15
+#define ODM_RATEMCS10 0x16
+#define ODM_RATEMCS11 0x17
+#define ODM_RATEMCS12 0x18
+#define ODM_RATEMCS13 0x19
+#define ODM_RATEMCS14 0x1A
+#define ODM_RATEMCS15 0x1B
+#define ODM_RATEMCS16 0x1C
+#define ODM_RATEMCS17 0x1D
+#define ODM_RATEMCS18 0x1E
+#define ODM_RATEMCS19 0x1F
+#define ODM_RATEMCS20 0x20
+#define ODM_RATEMCS21 0x21
+#define ODM_RATEMCS22 0x22
+#define ODM_RATEMCS23 0x23
+#define ODM_RATEMCS24 0x24
+#define ODM_RATEMCS25 0x25
+#define ODM_RATEMCS26 0x26
+#define ODM_RATEMCS27 0x27
+#define ODM_RATEMCS28 0x28
+#define ODM_RATEMCS29 0x29
+#define ODM_RATEMCS30 0x2A
+#define ODM_RATEMCS31 0x2B
+#define ODM_RATEVHTSS1MCS0 0x2C
+#define ODM_RATEVHTSS1MCS1 0x2D
+#define ODM_RATEVHTSS1MCS2 0x2E
+#define ODM_RATEVHTSS1MCS3 0x2F
+#define ODM_RATEVHTSS1MCS4 0x30
+#define ODM_RATEVHTSS1MCS5 0x31
+#define ODM_RATEVHTSS1MCS6 0x32
+#define ODM_RATEVHTSS1MCS7 0x33
+#define ODM_RATEVHTSS1MCS8 0x34
+#define ODM_RATEVHTSS1MCS9 0x35
+#define ODM_RATEVHTSS2MCS0 0x36
+#define ODM_RATEVHTSS2MCS1 0x37
+#define ODM_RATEVHTSS2MCS2 0x38
+#define ODM_RATEVHTSS2MCS3 0x39
+#define ODM_RATEVHTSS2MCS4 0x3A
+#define ODM_RATEVHTSS2MCS5 0x3B
+#define ODM_RATEVHTSS2MCS6 0x3C
+#define ODM_RATEVHTSS2MCS7 0x3D
+#define ODM_RATEVHTSS2MCS8 0x3E
+#define ODM_RATEVHTSS2MCS9 0x3F
+#define ODM_RATEVHTSS3MCS0 0x40
+#define ODM_RATEVHTSS3MCS1 0x41
+#define ODM_RATEVHTSS3MCS2 0x42
+#define ODM_RATEVHTSS3MCS3 0x43
+#define ODM_RATEVHTSS3MCS4 0x44
+#define ODM_RATEVHTSS3MCS5 0x45
+#define ODM_RATEVHTSS3MCS6 0x46
+#define ODM_RATEVHTSS3MCS7 0x47
+#define ODM_RATEVHTSS3MCS8 0x48
+#define ODM_RATEVHTSS3MCS9 0x49
+#define ODM_RATEVHTSS4MCS0 0x4A
+#define ODM_RATEVHTSS4MCS1 0x4B
+#define ODM_RATEVHTSS4MCS2 0x4C
+#define ODM_RATEVHTSS4MCS3 0x4D
+#define ODM_RATEVHTSS4MCS4 0x4E
+#define ODM_RATEVHTSS4MCS5 0x4F
+#define ODM_RATEVHTSS4MCS6 0x50
+#define ODM_RATEVHTSS4MCS7 0x51
+#define ODM_RATEVHTSS4MCS8 0x52
+#define ODM_RATEVHTSS4MCS9 0x53
+
+#define ODM_NUM_RATE_IDX (ODM_RATEVHTSS4MCS9 + 1)
+
+/* 1 ============================================================
+ * 1  enumeration
+ * 1 ============================================================
+ */
+
+/*	ODM_CMNINFO_INTERFACE */
+enum odm_interface {
+	ODM_ITRF_PCIE = 0x1,
+	ODM_ITRF_USB = 0x2,
+	ODM_ITRF_SDIO = 0x4,
+	ODM_ITRF_ALL = 0x7,
+};
+
+/* ODM_CMNINFO_IC_TYPE */
+enum odm_ic_type {
+	ODM_RTL8188E = BIT(0),
+	ODM_RTL8812 = BIT(1),
+	ODM_RTL8821 = BIT(2),
+	ODM_RTL8192E = BIT(3),
+	ODM_RTL8723B = BIT(4),
+	ODM_RTL8814A = BIT(5),
+	ODM_RTL8881A = BIT(6),
+	ODM_RTL8822B = BIT(7),
+	ODM_RTL8703B = BIT(8),
+	ODM_RTL8195A = BIT(9),
+	ODM_RTL8188F = BIT(10),
+	ODM_RTL8723D = BIT(11),
+	ODM_RTL8197F = BIT(12),
+	ODM_RTL8821C = BIT(13),
+	ODM_RTL8814B = BIT(14),
+	ODM_RTL8198F = BIT(15),
+	/* JJ ADD 20161014 */
+	ODM_RTL8710B = BIT(16),
+};
+
+/* JJ ADD 20161014 */
+#define ODM_IC_1SS                                                             \
+	(ODM_RTL8188E | ODM_RTL8188F | ODM_RTL8723B | ODM_RTL8703B |           \
+	 ODM_RTL8723D | ODM_RTL8881A | ODM_RTL8821 | ODM_RTL8821C |            \
+	 ODM_RTL8195A | ODM_RTL8710B)
+#define ODM_IC_2SS (ODM_RTL8192E | ODM_RTL8197F | ODM_RTL8812 | ODM_RTL8822B)
+#define ODM_IC_3SS (ODM_RTL8814A)
+#define ODM_IC_4SS (ODM_RTL8814B | ODM_RTL8198F)
+
+/* JJ ADD 20161014 */
+#define ODM_IC_11N_SERIES                                                      \
+	(ODM_RTL8188E | ODM_RTL8192E | ODM_RTL8723B | ODM_RTL8703B |           \
+	 ODM_RTL8188F | ODM_RTL8723D | ODM_RTL8197F | ODM_RTL8710B)
+#define ODM_IC_11AC_SERIES                                                     \
+	(ODM_RTL8812 | ODM_RTL8821 | ODM_RTL8814A | ODM_RTL8881A |             \
+	 ODM_RTL8822B | ODM_RTL8821C)
+#define ODM_IC_11AC_1_SERIES (ODM_RTL8812 | ODM_RTL8821 | ODM_RTL8881A)
+#define ODM_IC_11AC_2_SERIES (ODM_RTL8814A | ODM_RTL8822B | ODM_RTL8821C)
+#define ODM_IC_TXBF_SUPPORT                                                    \
+	(ODM_RTL8192E | ODM_RTL8812 | ODM_RTL8821 | ODM_RTL8814A |             \
+	 ODM_RTL8881A | ODM_RTL8822B | ODM_RTL8197F | ODM_RTL8821C)
+#define ODM_IC_11N_GAIN_IDX_EDCCA                                              \
+	(ODM_RTL8195A | ODM_RTL8703B | ODM_RTL8188F | ODM_RTL8723D |           \
+	 ODM_RTL8197F | ODM_RTL8710B)
+#define ODM_IC_11AC_GAIN_IDX_EDCCA (ODM_RTL8814A | ODM_RTL8822B | ODM_RTL8821C)
+#define ODM_IC_PHY_STATUE_NEW_TYPE                                             \
+	(ODM_RTL8197F | ODM_RTL8822B | ODM_RTL8723D | ODM_RTL8821C |           \
+	 ODM_RTL8710B)
+
+#define PHYDM_IC_8051_SERIES                                                   \
+	(ODM_RTL8881A | ODM_RTL8812 | ODM_RTL8821 | ODM_RTL8188E |             \
+	 ODM_RTL8192E | ODM_RTL8723B | ODM_RTL8703B | ODM_RTL8188F)
+#define PHYDM_IC_3081_SERIES                                                   \
+	(ODM_RTL8814A | ODM_RTL8822B | ODM_RTL8197F | ODM_RTL8821C)
+
+#define PHYDM_IC_SUPPORT_LA_MODE                                               \
+	(ODM_RTL8814A | ODM_RTL8822B | ODM_RTL8197F | ODM_RTL8821C)
+
+/* JJ ADD 20161014 */
+
+/* ODM_CMNINFO_CUT_VER */
+enum odm_cut_version {
+	ODM_CUT_A = 0,
+	ODM_CUT_B = 1,
+	ODM_CUT_C = 2,
+	ODM_CUT_D = 3,
+	ODM_CUT_E = 4,
+	ODM_CUT_F = 5,
+
+	ODM_CUT_I = 8,
+	ODM_CUT_J = 9,
+	ODM_CUT_K = 10,
+	ODM_CUT_TEST = 15,
+};
+
+/* ODM_CMNINFO_FAB_VER */
+enum odm_fab {
+	ODM_TSMC = 0,
+	ODM_UMC = 1,
+};
+
+/* ODM_CMNINFO_RF_TYPE
+ *
+ * For example 1T2R (A+AB = BIT(0)|BIT(4)|BIT(5))
+ */
+enum odm_rf_path {
+	ODM_RF_A = BIT(0),
+	ODM_RF_B = BIT(1),
+	ODM_RF_C = BIT(2),
+	ODM_RF_D = BIT(3),
+};
+
+enum odm_rf_tx_num {
+	ODM_1T = 1,
+	ODM_2T = 2,
+	ODM_3T = 3,
+	ODM_4T = 4,
+};
+
+enum odm_rf_type {
+	ODM_1T1R,
+	ODM_1T2R,
+	ODM_2T2R,
+	ODM_2T2R_GREEN,
+	ODM_2T3R,
+	ODM_2T4R,
+	ODM_3T3R,
+	ODM_3T4R,
+	ODM_4T4R,
+	ODM_XTXR
+};
+
+enum odm_mac_phy_mode {
+	ODM_SMSP = 0,
+	ODM_DMSP = 1,
+	ODM_DMDP = 2,
+};
+
+enum odm_bt_coexist {
+	ODM_BT_BUSY = 1,
+	ODM_BT_ON = 2,
+	ODM_BT_OFF = 3,
+	ODM_BT_NONE = 4,
+};
+
+/* ODM_CMNINFO_OP_MODE */
+enum odm_operation_mode {
+	ODM_NO_LINK = BIT(0),
+	ODM_LINK = BIT(1),
+	ODM_SCAN = BIT(2),
+	ODM_POWERSAVE = BIT(3),
+	ODM_AP_MODE = BIT(4),
+	ODM_CLIENT_MODE = BIT(5),
+	ODM_AD_HOC = BIT(6),
+	ODM_WIFI_DIRECT = BIT(7),
+	ODM_WIFI_DISPLAY = BIT(8),
+};
+
+/* ODM_CMNINFO_WM_MODE */
+enum odm_wireless_mode {
+	ODM_WM_UNKNOWN = 0x0,
+	ODM_WM_B = BIT(0),
+	ODM_WM_G = BIT(1),
+	ODM_WM_A = BIT(2),
+	ODM_WM_N24G = BIT(3),
+	ODM_WM_N5G = BIT(4),
+	ODM_WM_AUTO = BIT(5),
+	ODM_WM_AC = BIT(6),
+};
+
+/* ODM_CMNINFO_BAND */
+enum odm_band_type {
+	ODM_BAND_2_4G = 0,
+	ODM_BAND_5G,
+	ODM_BAND_ON_BOTH,
+	ODM_BANDMAX
+};
+
+/* ODM_CMNINFO_SEC_CHNL_OFFSET */
+enum phydm_sec_chnl_offset {
+	PHYDM_DONT_CARE = 0,
+	PHYDM_BELOW = 1,
+	PHYDM_ABOVE = 2
+};
+
+/* ODM_CMNINFO_SEC_MODE */
+enum odm_security {
+	ODM_SEC_OPEN = 0,
+	ODM_SEC_WEP40 = 1,
+	ODM_SEC_TKIP = 2,
+	ODM_SEC_RESERVE = 3,
+	ODM_SEC_AESCCMP = 4,
+	ODM_SEC_WEP104 = 5,
+	ODM_WEP_WPA_MIXED = 6, /* WEP + WPA */
+	ODM_SEC_SMS4 = 7,
+};
+
+/* ODM_CMNINFO_BW */
+enum odm_bw {
+	ODM_BW20M = 0,
+	ODM_BW40M = 1,
+	ODM_BW80M = 2,
+	ODM_BW160M = 3,
+	ODM_BW5M = 4,
+	ODM_BW10M = 5,
+	ODM_BW_MAX = 6
+};
+
+/* ODM_CMNINFO_CHNL */
+
+/* ODM_CMNINFO_BOARD_TYPE */
+enum odm_board_type {
+	ODM_BOARD_DEFAULT = 0, /* The DEFAULT case. */
+	ODM_BOARD_MINICARD = BIT(0), /* 0 = non-mini card, 1= mini card. */
+	ODM_BOARD_SLIM = BIT(1), /* 0 = non-slim card, 1 = slim card */
+	ODM_BOARD_BT = BIT(2), /* 0 = without BT card, 1 = with BT */
+	ODM_BOARD_EXT_PA =
+		BIT(3), /* 0 = no 2G ext-PA, 1 = existing 2G ext-PA */
+	ODM_BOARD_EXT_LNA =
+		BIT(4), /* 0 = no 2G ext-LNA, 1 = existing 2G ext-LNA */
+	ODM_BOARD_EXT_TRSW =
+		BIT(5), /* 0 = no ext-TRSW, 1 = existing ext-TRSW */
+	ODM_BOARD_EXT_PA_5G =
+		BIT(6), /* 0 = no 5G ext-PA, 1 = existing 5G ext-PA */
+	ODM_BOARD_EXT_LNA_5G =
+		BIT(7), /* 0 = no 5G ext-LNA, 1 = existing 5G ext-LNA */
+};
+
+enum odm_package_type {
+	ODM_PACKAGE_DEFAULT = 0,
+	ODM_PACKAGE_QFN68 = BIT(0),
+	ODM_PACKAGE_TFBGA90 = BIT(1),
+	ODM_PACKAGE_TFBGA79 = BIT(2),
+};
+
+enum odm_type_gpa {
+	TYPE_GPA0 = 0x0000,
+	TYPE_GPA1 = 0x0055,
+	TYPE_GPA2 = 0x00AA,
+	TYPE_GPA3 = 0x00FF,
+	TYPE_GPA4 = 0x5500,
+	TYPE_GPA5 = 0x5555,
+	TYPE_GPA6 = 0x55AA,
+	TYPE_GPA7 = 0x55FF,
+	TYPE_GPA8 = 0xAA00,
+	TYPE_GPA9 = 0xAA55,
+	TYPE_GPA10 = 0xAAAA,
+	TYPE_GPA11 = 0xAAFF,
+	TYPE_GPA12 = 0xFF00,
+	TYPE_GPA13 = 0xFF55,
+	TYPE_GPA14 = 0xFFAA,
+	TYPE_GPA15 = 0xFFFF,
+};
+
+enum odm_type_apa {
+	TYPE_APA0 = 0x0000,
+	TYPE_APA1 = 0x0055,
+	TYPE_APA2 = 0x00AA,
+	TYPE_APA3 = 0x00FF,
+	TYPE_APA4 = 0x5500,
+	TYPE_APA5 = 0x5555,
+	TYPE_APA6 = 0x55AA,
+	TYPE_APA7 = 0x55FF,
+	TYPE_APA8 = 0xAA00,
+	TYPE_APA9 = 0xAA55,
+	TYPE_APA10 = 0xAAAA,
+	TYPE_APA11 = 0xAAFF,
+	TYPE_APA12 = 0xFF00,
+	TYPE_APA13 = 0xFF55,
+	TYPE_APA14 = 0xFFAA,
+	TYPE_APA15 = 0xFFFF,
+};
+
+enum odm_type_glna {
+	TYPE_GLNA0 = 0x0000,
+	TYPE_GLNA1 = 0x0055,
+	TYPE_GLNA2 = 0x00AA,
+	TYPE_GLNA3 = 0x00FF,
+	TYPE_GLNA4 = 0x5500,
+	TYPE_GLNA5 = 0x5555,
+	TYPE_GLNA6 = 0x55AA,
+	TYPE_GLNA7 = 0x55FF,
+	TYPE_GLNA8 = 0xAA00,
+	TYPE_GLNA9 = 0xAA55,
+	TYPE_GLNA10 = 0xAAAA,
+	TYPE_GLNA11 = 0xAAFF,
+	TYPE_GLNA12 = 0xFF00,
+	TYPE_GLNA13 = 0xFF55,
+	TYPE_GLNA14 = 0xFFAA,
+	TYPE_GLNA15 = 0xFFFF,
+};
+
+enum odm_type_alna {
+	TYPE_ALNA0 = 0x0000,
+	TYPE_ALNA1 = 0x0055,
+	TYPE_ALNA2 = 0x00AA,
+	TYPE_ALNA3 = 0x00FF,
+	TYPE_ALNA4 = 0x5500,
+	TYPE_ALNA5 = 0x5555,
+	TYPE_ALNA6 = 0x55AA,
+	TYPE_ALNA7 = 0x55FF,
+	TYPE_ALNA8 = 0xAA00,
+	TYPE_ALNA9 = 0xAA55,
+	TYPE_ALNA10 = 0xAAAA,
+	TYPE_ALNA11 = 0xAAFF,
+	TYPE_ALNA12 = 0xFF00,
+	TYPE_ALNA13 = 0xFF55,
+	TYPE_ALNA14 = 0xFFAA,
+	TYPE_ALNA15 = 0xFFFF,
+};
+
+enum odm_rf_radio_path {
+	ODM_RF_PATH_A = 0, /* Radio path A */
+	ODM_RF_PATH_B = 1, /* Radio path B */
+	ODM_RF_PATH_C = 2, /* Radio path C */
+	ODM_RF_PATH_D = 3, /* Radio path D */
+	ODM_RF_PATH_AB,
+	ODM_RF_PATH_AC,
+	ODM_RF_PATH_AD,
+	ODM_RF_PATH_BC,
+	ODM_RF_PATH_BD,
+	ODM_RF_PATH_CD,
+	ODM_RF_PATH_ABC,
+	ODM_RF_PATH_ACD,
+	ODM_RF_PATH_BCD,
+	ODM_RF_PATH_ABCD,
+	/* ODM_RF_PATH_MAX,    */ /* Max RF number 90 support */
+};
+
+enum odm_parameter_init {
+	ODM_PRE_SETTING = 0,
+	ODM_POST_SETTING = 1,
+};
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_precomp.h b/drivers/staging/rtlwifi/phydm/phydm_precomp.h
new file mode 100644
index 000000000000..bada15c4d2d8
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_precomp.h
@@ -0,0 +1,85 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __ODM_PRECOMP_H__
+#define __ODM_PRECOMP_H__
+
+#include "phydm_types.h"
+
+/* 2 Config Flags and Structs - defined by each ODM type */
+
+#include "../wifi.h"
+#include "rtl_phydm.h"
+
+/* 2 OutSrc Header Files */
+
+#include "phydm.h"
+#include "phydm_hwconfig.h"
+#include "phydm_debug.h"
+#include "phydm_regdefine11ac.h"
+#include "phydm_regdefine11n.h"
+#include "phydm_interface.h"
+#include "phydm_reg.h"
+
+#include "phydm_adc_sampling.h"
+
+/* JJ ADD 20161014 */
+
+#include "../halmac/halmac_reg2.h"
+
+#define LDPC_HT_ENABLE_RX BIT(0)
+#define LDPC_HT_ENABLE_TX BIT(1)
+#define LDPC_HT_TEST_TX_ENABLE BIT(2)
+#define LDPC_HT_CAP_TX BIT(3)
+
+#define STBC_HT_ENABLE_RX BIT(0)
+#define STBC_HT_ENABLE_TX BIT(1)
+#define STBC_HT_TEST_TX_ENABLE BIT(2)
+#define STBC_HT_CAP_TX BIT(3)
+
+#define LDPC_VHT_ENABLE_RX BIT(0)
+#define LDPC_VHT_ENABLE_TX BIT(1)
+#define LDPC_VHT_TEST_TX_ENABLE BIT(2)
+#define LDPC_VHT_CAP_TX BIT(3)
+
+#define STBC_VHT_ENABLE_RX BIT(0)
+#define STBC_VHT_ENABLE_TX BIT(1)
+#define STBC_VHT_TEST_TX_ENABLE BIT(2)
+#define STBC_VHT_CAP_TX BIT(3)
+
+#include "rtl8822b/halhwimg8822b_mac.h"
+#include "rtl8822b/halhwimg8822b_rf.h"
+#include "rtl8822b/halhwimg8822b_bb.h"
+#include "rtl8822b/phydm_regconfig8822b.h"
+#include "rtl8822b/halphyrf_8822b.h"
+#include "rtl8822b/phydm_rtl8822b.h"
+#include "rtl8822b/phydm_hal_api8822b.h"
+#include "rtl8822b/version_rtl8822b.h"
+
+#include "../halmac/halmac_reg_8822b.h"
+
+/* JJ ADD 20161014 */
+
+#endif /* __ODM_PRECOMP_H__ */
diff --git a/drivers/staging/rtlwifi/phydm/phydm_psd.c b/drivers/staging/rtlwifi/phydm/phydm_psd.c
new file mode 100644
index 000000000000..48f8776bc8f9
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_psd.c
@@ -0,0 +1,422 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/*============================================================
+ * include files
+ *============================================================
+ */
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+u32 phydm_get_psd_data(void *dm_void, u32 psd_tone_idx, u32 igi)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct psd_info *dm_psd_table = &dm->dm_psd_table;
+	u32 psd_report = 0;
+
+	odm_set_bb_reg(dm, dm_psd_table->psd_reg, 0x3ff, psd_tone_idx);
+
+	odm_set_bb_reg(dm, dm_psd_table->psd_reg, BIT(22),
+		       1); /*PSD trigger start*/
+	ODM_delay_us(10);
+	odm_set_bb_reg(dm, dm_psd_table->psd_reg, BIT(22),
+		       0); /*PSD trigger stop*/
+
+	psd_report = odm_get_bb_reg(dm, dm_psd_table->psd_report_reg, 0xffff);
+	psd_report = odm_convert_to_db(psd_report) + igi;
+
+	return psd_report;
+}
+
+static u8 phydm_psd_stop_trx(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u32 i;
+	u8 trx_idle_success = false;
+	u32 dbg_port_value = 0;
+
+	/*[Stop TRX]----------------------------------------------------------*/
+	if (!phydm_set_bb_dbg_port(dm, BB_DBGPORT_PRIORITY_3,
+				   0x0)) /*set debug port to 0x0*/
+		return STOP_TRX_FAIL;
+
+	for (i = 0; i < 10000; i++) {
+		dbg_port_value = phydm_get_bb_dbg_port_value(dm);
+		if ((dbg_port_value & (BIT(17) | BIT(3))) ==
+		    0) /* PHYTXON && CCA_all */ {
+			ODM_RT_TRACE(dm, ODM_COMP_API,
+				     "PSD wait for ((%d)) times\n", i);
+
+			trx_idle_success = true;
+			break;
+		}
+	}
+
+	if (trx_idle_success) {
+		/*pause all TX queue*/
+		odm_set_bb_reg(dm, 0x520, 0xff0000, 0xff);
+
+		if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+			/*disable CCK block*/
+			odm_set_bb_reg(dm, 0x808, BIT(28), 0);
+			/*disable OFDM RX CCA*/
+			odm_set_bb_reg(dm, 0x838, BIT(1), 1);
+		} else {
+			/*TBD*/
+			/* disable whole CCK block */
+			odm_set_bb_reg(dm, 0x800, BIT(24), 0);
+			/*[ Set IQK Matrix = 0 ] equivalent to [ Turn off CCA]*/
+			odm_set_bb_reg(dm, 0xC14, MASKDWORD, 0x0);
+		}
+
+	} else {
+		return STOP_TRX_FAIL;
+	}
+
+	phydm_release_bb_dbg_port(dm);
+
+	return STOP_TRX_SUCCESS;
+}
+
+static u8 psd_result_cali_tone_8821[7] = {21, 28, 33, 93, 98, 105, 127};
+static u8 psd_result_cali_val_8821[7] = {67, 69, 71, 72, 71, 69, 67};
+
+void phydm_psd(void *dm_void, u32 igi, u16 start_point, u16 stop_point)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct psd_info *dm_psd_table = &dm->dm_psd_table;
+	u32 i = 0, mod_tone_idx;
+	u32 t = 0;
+	u16 fft_max_half_bw;
+	u32 psd_igi_a_reg;
+	u32 psd_igi_b_reg;
+	u16 psd_fc_channel = dm_psd_table->psd_fc_channel;
+	u8 ag_rf_mode_reg = 0;
+	u8 rf_reg18_9_8 = 0;
+	u32 psd_result_tmp = 0;
+	u8 psd_result = 0;
+	u8 psd_result_cali_tone[7] = {0};
+	u8 psd_result_cali_val[7] = {0};
+	u8 noise_table_idx = 0;
+
+	if (dm->support_ic_type == ODM_RTL8821) {
+		odm_move_memory(dm, psd_result_cali_tone,
+				psd_result_cali_tone_8821, 7);
+		odm_move_memory(dm, psd_result_cali_val,
+				psd_result_cali_val_8821, 7);
+	}
+
+	dm_psd_table->psd_in_progress = 1;
+
+	/*[Stop DIG]*/
+	dm->support_ability &= ~(ODM_BB_DIG);
+	dm->support_ability &= ~(ODM_BB_FA_CNT);
+
+	ODM_RT_TRACE(dm, ODM_COMP_API, "PSD Start =>\n");
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		psd_igi_a_reg = 0xc50;
+		psd_igi_b_reg = 0xe50;
+	} else {
+		psd_igi_a_reg = 0xc50;
+		psd_igi_b_reg = 0xc58;
+	}
+
+	/*[back up IGI]*/
+	dm_psd_table->initial_gain_backup =
+		odm_get_bb_reg(dm, psd_igi_a_reg, 0xff);
+	odm_set_bb_reg(dm, psd_igi_a_reg, 0xff,
+		       0x6e); /*IGI target at 0dBm & make it can't CCA*/
+	odm_set_bb_reg(dm, psd_igi_b_reg, 0xff,
+		       0x6e); /*IGI target at 0dBm & make it can't CCA*/
+	ODM_delay_us(10);
+
+	if (phydm_psd_stop_trx(dm) == STOP_TRX_FAIL) {
+		ODM_RT_TRACE(dm, ODM_COMP_API, "STOP_TRX_FAIL\n");
+		return;
+	}
+
+	/*[Set IGI]*/
+	odm_set_bb_reg(dm, psd_igi_a_reg, 0xff, igi);
+	odm_set_bb_reg(dm, psd_igi_b_reg, 0xff, igi);
+
+	/*[Backup RF Reg]*/
+	dm_psd_table->rf_0x18_bkp =
+		odm_get_rf_reg(dm, ODM_RF_PATH_A, 0x18, RFREGOFFSETMASK);
+
+	if (psd_fc_channel > 14) {
+		rf_reg18_9_8 = 1;
+
+		if (psd_fc_channel >= 36 && psd_fc_channel <= 64)
+			ag_rf_mode_reg = 0x1;
+		else if (psd_fc_channel >= 100 && psd_fc_channel <= 140)
+			ag_rf_mode_reg = 0x3;
+		else if (psd_fc_channel > 140)
+			ag_rf_mode_reg = 0x5;
+	}
+
+	/* Set RF fc*/
+	odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x18, 0xff, psd_fc_channel);
+	odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x18, 0x300, rf_reg18_9_8);
+	/*2b'11: 20MHz, 2b'10: 40MHz, 2b'01: 80MHz */
+	odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x18, 0xc00,
+		       dm_psd_table->psd_bw_rf_reg);
+	/* Set RF ag fc mode*/
+	odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x18, 0xf0000, ag_rf_mode_reg);
+
+	ODM_RT_TRACE(dm, ODM_COMP_API, "0xc50=((0x%x))\n",
+		     odm_get_bb_reg(dm, 0xc50, MASKDWORD));
+	ODM_RT_TRACE(dm, ODM_COMP_API, "RF0x18=((0x%x))\n",
+		     odm_get_rf_reg(dm, ODM_RF_PATH_A, 0x18, RFREGOFFSETMASK));
+
+	/*[Stop 3-wires]*/
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		odm_set_bb_reg(dm, 0xc00, 0xf, 0x4); /*	hardware 3-wire off */
+		odm_set_bb_reg(dm, 0xe00, 0xf, 0x4); /*	hardware 3-wire off */
+	} else {
+		odm_set_bb_reg(dm, 0x88c, 0xf00000,
+			       0xf); /* 3 wire Disable    88c[23:20]=0xf */
+	}
+	ODM_delay_us(10);
+
+	if (stop_point > (dm_psd_table->fft_smp_point - 1))
+		stop_point = (dm_psd_table->fft_smp_point - 1);
+
+	if (start_point > (dm_psd_table->fft_smp_point - 1))
+		start_point = (dm_psd_table->fft_smp_point - 1);
+
+	if (start_point > stop_point)
+		stop_point = start_point;
+
+	if (stop_point > 127) /* limit of psd_result[128] */
+		stop_point = 127;
+
+	for (i = start_point; i <= stop_point; i++) {
+		fft_max_half_bw = (dm_psd_table->fft_smp_point) >> 1;
+
+		if (i < fft_max_half_bw)
+			mod_tone_idx = i + fft_max_half_bw;
+		else
+			mod_tone_idx = i - fft_max_half_bw;
+
+		psd_result_tmp = 0;
+		for (t = 0; t < dm_psd_table->sw_avg_time; t++)
+			psd_result_tmp +=
+				phydm_get_psd_data(dm, mod_tone_idx, igi);
+		psd_result =
+			(u8)((psd_result_tmp / dm_psd_table->sw_avg_time)) -
+			dm_psd_table->psd_pwr_common_offset;
+
+		if (dm_psd_table->fft_smp_point == 128 &&
+		    (dm_psd_table->noise_k_en)) {
+			if (i > psd_result_cali_tone[noise_table_idx])
+				noise_table_idx++;
+
+			if (noise_table_idx > 6)
+				noise_table_idx = 6;
+
+			if (psd_result >= psd_result_cali_val[noise_table_idx])
+				psd_result =
+					psd_result -
+					psd_result_cali_val[noise_table_idx];
+			else
+				psd_result = 0;
+
+			dm_psd_table->psd_result[i] = psd_result;
+		}
+
+		ODM_RT_TRACE(dm, ODM_COMP_API, "[%d] N_cali = %d, PSD = %d\n",
+			     mod_tone_idx, psd_result_cali_val[noise_table_idx],
+			     psd_result);
+	}
+
+	/*[Start 3-wires]*/
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		odm_set_bb_reg(dm, 0xc00, 0xf, 0x7); /*	hardware 3-wire on */
+		odm_set_bb_reg(dm, 0xe00, 0xf, 0x7); /*	hardware 3-wire on */
+	} else {
+		odm_set_bb_reg(dm, 0x88c, 0xf00000,
+			       0x0); /* 3 wire enable    88c[23:20]=0x0 */
+	}
+	ODM_delay_us(10);
+
+	/*[Revert Reg]*/
+	odm_set_bb_reg(dm, 0x520, 0xff0000, 0x0); /*start all TX queue*/
+	odm_set_bb_reg(dm, 0x808, BIT(28), 1); /*enable CCK block*/
+	odm_set_bb_reg(dm, 0x838, BIT(1), 0); /*enable OFDM RX CCA*/
+
+	odm_set_bb_reg(dm, psd_igi_a_reg, 0xff,
+		       dm_psd_table->initial_gain_backup);
+	odm_set_bb_reg(dm, psd_igi_b_reg, 0xff,
+		       dm_psd_table->initial_gain_backup);
+
+	odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x18, RFREGOFFSETMASK,
+		       dm_psd_table->rf_0x18_bkp);
+
+	ODM_RT_TRACE(dm, ODM_COMP_API, "PSD finished\n\n");
+
+	dm->support_ability |= ODM_BB_DIG;
+	dm->support_ability |= ODM_BB_FA_CNT;
+	dm_psd_table->psd_in_progress = 0;
+}
+
+void phydm_psd_para_setting(void *dm_void, u8 sw_avg_time, u8 hw_avg_time,
+			    u8 i_q_setting, u16 fft_smp_point, u8 ant_sel,
+			    u8 psd_input, u8 channel, u8 noise_k_en)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct psd_info *dm_psd_table = &dm->dm_psd_table;
+	u8 fft_smp_point_idx = 0;
+
+	dm_psd_table->fft_smp_point = fft_smp_point;
+
+	if (sw_avg_time == 0)
+		sw_avg_time = 1;
+
+	dm_psd_table->sw_avg_time = sw_avg_time;
+	dm_psd_table->psd_fc_channel = channel;
+	dm_psd_table->noise_k_en = noise_k_en;
+
+	if (fft_smp_point == 128)
+		fft_smp_point_idx = 0;
+	else if (fft_smp_point == 256)
+		fft_smp_point_idx = 1;
+	else if (fft_smp_point == 512)
+		fft_smp_point_idx = 2;
+	else if (fft_smp_point == 1024)
+		fft_smp_point_idx = 3;
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		odm_set_bb_reg(dm, 0x910, BIT(11) | BIT(10), i_q_setting);
+		odm_set_bb_reg(dm, 0x910, BIT(13) | BIT(12), hw_avg_time);
+		odm_set_bb_reg(dm, 0x910, BIT(15) | BIT(14), fft_smp_point_idx);
+		odm_set_bb_reg(dm, 0x910, BIT(17) | BIT(16), ant_sel);
+		odm_set_bb_reg(dm, 0x910, BIT(23), psd_input);
+	}
+
+	/*bw = (*dm->band_width); //ODM_BW20M */
+	/*channel = *(dm->channel);*/
+}
+
+void phydm_psd_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct psd_info *dm_psd_table = &dm->dm_psd_table;
+
+	ODM_RT_TRACE(dm, ODM_COMP_API, "PSD para init\n");
+
+	dm_psd_table->psd_in_progress = false;
+
+	if (dm->support_ic_type & ODM_IC_11AC_SERIES) {
+		dm_psd_table->psd_reg = 0x910;
+		dm_psd_table->psd_report_reg = 0xF44;
+
+		if (ODM_IC_11AC_2_SERIES)
+			dm_psd_table->psd_bw_rf_reg =
+				1; /*2b'11: 20MHz, 2b'10: 40MHz, 2b'01: 80MHz */
+		else
+			dm_psd_table->psd_bw_rf_reg =
+				2; /*2b'11: 20MHz, 2b'10: 40MHz, 2b'01: 80MHz */
+
+	} else {
+		dm_psd_table->psd_reg = 0x808;
+		dm_psd_table->psd_report_reg = 0x8B4;
+		dm_psd_table->psd_bw_rf_reg =
+			2; /*2b'11: 20MHz, 2b'10: 40MHz, 2b'01: 80MHz */
+	}
+
+	if (dm->support_ic_type == ODM_RTL8812)
+		dm_psd_table->psd_pwr_common_offset = 0;
+	else if (dm->support_ic_type == ODM_RTL8821)
+		dm_psd_table->psd_pwr_common_offset = 0;
+	else
+		dm_psd_table->psd_pwr_common_offset = 0;
+
+	phydm_psd_para_setting(dm, 1, 2, 3, 128, 0, 0, 7, 0);
+	/*phydm_psd(dm, 0x3c, 0, 127);*/ /* target at -50dBm */
+}
+
+void phydm_psd_debug(void *dm_void, char input[][16], u32 *_used, char *output,
+		     u32 *_out_len, u32 input_num)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	char help[] = "-h";
+	u32 var1[10] = {0};
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+	u8 i;
+
+	if ((strcmp(input[1], help) == 0)) {
+		PHYDM_SNPRINTF(
+			output + used, out_len - used,
+			"{0} {sw_avg} {hw_avg 0:3} {1:I,2:Q,3:IQ} {fft_point: 128*(1:4)} {path_sel 0~3} {0:ADC, 1:RXIQC} {CH} {noise_k}\n");
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "{1} {IGI(hex)} {start_point} {stop_point}\n");
+		return;
+	}
+
+	PHYDM_SSCANF(input[1], DCMD_DECIMAL, &var1[0]);
+
+	if (var1[0] == 0) {
+		for (i = 1; i < 10; i++) {
+			if (input[i + 1])
+				PHYDM_SSCANF(input[i + 1], DCMD_DECIMAL,
+					     &var1[i]);
+		}
+
+		PHYDM_SNPRINTF(
+			output + used, out_len - used,
+			"sw_avg_time=((%d)), hw_avg_time=((%d)), IQ=((%d)), fft=((%d)), path=((%d)), input =((%d)) ch=((%d)), noise_k=((%d))\n",
+			var1[1], var1[2], var1[3], var1[4], var1[5], var1[6],
+			(u8)var1[7], (u8)var1[8]);
+		phydm_psd_para_setting(dm, (u8)var1[1], (u8)var1[2],
+				       (u8)var1[3], (u16)var1[4], (u8)var1[5],
+				       (u8)var1[6], (u8)var1[7], (u8)var1[8]);
+
+	} else if (var1[0] == 1) {
+		PHYDM_SSCANF(input[2], DCMD_HEX, &var1[1]);
+		PHYDM_SSCANF(input[3], DCMD_DECIMAL, &var1[2]);
+		PHYDM_SSCANF(input[4], DCMD_DECIMAL, &var1[3]);
+		PHYDM_SNPRINTF(
+			output + used, out_len - used,
+			"IGI=((0x%x)), start_point=((%d)), stop_point=((%d))\n",
+			var1[1], var1[2], var1[3]);
+		dm->debug_components |= ODM_COMP_API;
+		phydm_psd(dm, var1[1], (u16)var1[2], (u16)var1[3]);
+		dm->debug_components &= (~ODM_COMP_API);
+	}
+}
+
+u8 phydm_get_psd_result_table(void *dm_void, int index)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct psd_info *dm_psd_table = &dm->dm_psd_table;
+	u8 temp_result = 0;
+
+	if (index < 128)
+		temp_result = dm_psd_table->psd_result[index];
+
+	return temp_result;
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_psd.h b/drivers/staging/rtlwifi/phydm/phydm_psd.h
new file mode 100644
index 000000000000..aeb70751d80b
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_psd.h
@@ -0,0 +1,67 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDMPSD_H__
+#define __PHYDMPSD_H__
+
+/*#define PSD_VERSION	"1.0"*/ /*2016.09.22  Dino*/
+#define PSD_VERSION "1.1" /*2016.10.07  Dino, Add Option for PSD Tone index
+			   *Selection
+			   */
+
+#define STOP_TRX_SUCCESS 1
+#define STOP_TRX_FAIL 0
+
+struct psd_info {
+	u8 psd_in_progress;
+	u32 psd_reg;
+	u32 psd_report_reg;
+	u8 psd_pwr_common_offset;
+	u16 sw_avg_time;
+	u16 fft_smp_point;
+	u32 initial_gain_backup;
+	u32 rf_0x18_bkp;
+	u16 psd_fc_channel;
+	u32 psd_bw_rf_reg;
+	u8 psd_result[128];
+	u8 noise_k_en;
+};
+
+u32 phydm_get_psd_data(void *dm_void, u32 psd_tone_idx, u32 igi);
+
+void phydm_psd_debug(void *dm_void, char input[][16], u32 *_used, char *output,
+		     u32 *_out_len, u32 input_num);
+
+void phydm_psd(void *dm_void, u32 igi, u16 start_point, u16 stop_point);
+
+void phydm_psd_para_setting(void *dm_void, u8 sw_avg_time, u8 hw_avg_time,
+			    u8 i_q_setting, u16 fft_smp_point, u8 ant_sel,
+			    u8 psd_input, u8 channel, u8 noise_k_en);
+
+void phydm_psd_init(void *dm_void);
+
+u8 phydm_get_psd_result_table(void *dm_void, int index);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_rainfo.c b/drivers/staging/rtlwifi/phydm/phydm_rainfo.c
new file mode 100644
index 000000000000..8c08c76d4eda
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_rainfo.c
@@ -0,0 +1,1208 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/* ************************************************************
+ * include files
+ * *************************************************************/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+
+void phydm_h2C_debug(void *dm_void, u32 *const dm_value, u32 *_used,
+		     char *output, u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 h2c_parameter[H2C_MAX_LENGTH] = {0};
+	u8 phydm_h2c_id = (u8)dm_value[0];
+	u8 i;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	PHYDM_SNPRINTF(output + used, out_len - used,
+		       "Phydm Send H2C_ID (( 0x%x))\n", phydm_h2c_id);
+	for (i = 0; i < H2C_MAX_LENGTH; i++) {
+		h2c_parameter[i] = (u8)dm_value[i + 1];
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "H2C: Byte[%d] = ((0x%x))\n", i,
+			       h2c_parameter[i]);
+	}
+
+	odm_fill_h2c_cmd(dm, phydm_h2c_id, H2C_MAX_LENGTH, h2c_parameter);
+}
+
+void phydm_RA_debug_PCR(void *dm_void, u32 *const dm_value, u32 *_used,
+			char *output, u32 *_out_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct ra_table *ra_tab = &dm->dm_ra_table;
+	u32 used = *_used;
+	u32 out_len = *_out_len;
+
+	if (dm_value[0] == 100) {
+		PHYDM_SNPRINTF(
+			output + used, out_len - used,
+			"[Get] PCR RA_threshold_offset = (( %s%d ))\n",
+			((ra_tab->RA_threshold_offset == 0) ?
+				 " " :
+				 ((ra_tab->RA_offset_direction) ? "+" : "-")),
+			ra_tab->RA_threshold_offset);
+		/**/
+	} else if (dm_value[0] == 0) {
+		ra_tab->RA_offset_direction = 0;
+		ra_tab->RA_threshold_offset = (u8)dm_value[1];
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "[Set] PCR RA_threshold_offset = (( -%d ))\n",
+			       ra_tab->RA_threshold_offset);
+	} else if (dm_value[0] == 1) {
+		ra_tab->RA_offset_direction = 1;
+		ra_tab->RA_threshold_offset = (u8)dm_value[1];
+		PHYDM_SNPRINTF(output + used, out_len - used,
+			       "[Set] PCR RA_threshold_offset = (( +%d ))\n",
+			       ra_tab->RA_threshold_offset);
+	} else {
+		PHYDM_SNPRINTF(output + used, out_len - used, "[Set] Error\n");
+		/**/
+	}
+}
+
+void odm_c2h_ra_para_report_handler(void *dm_void, u8 *cmd_buf, u8 cmd_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	u8 para_idx = cmd_buf[0]; /*Retry Penalty, NH, NL*/
+	u8 i;
+
+	ODM_RT_TRACE(dm, PHYDM_COMP_RA_DBG,
+		     "[ From FW C2H RA Para ]  cmd_buf[0]= (( %d ))\n",
+		     cmd_buf[0]);
+
+	if (para_idx == RADBG_DEBUG_MONITOR1) {
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE,
+			     "-------------------------------\n");
+		if (dm->support_ic_type & PHYDM_IC_3081_SERIES) {
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+				     "RSSI =", cmd_buf[1]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  0x%x\n",
+				     "rate =", cmd_buf[2] & 0x7f);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+				     "SGI =", (cmd_buf[2] & 0x80) >> 7);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+				     "BW =", cmd_buf[3]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+				     "BW_max =", cmd_buf[4]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  0x%x\n",
+				     "multi_rate0 =", cmd_buf[5]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  0x%x\n",
+				     "multi_rate1 =", cmd_buf[6]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+				     "DISRA =", cmd_buf[7]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+				     "VHT_EN =", cmd_buf[8]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+				     "SGI_support =", cmd_buf[9]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+				     "try_ness =", cmd_buf[10]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  0x%x\n",
+				     "pre_rate =", cmd_buf[11]);
+		} else {
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+				     "RSSI =", cmd_buf[1]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %x\n",
+				     "BW =", cmd_buf[2]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+				     "DISRA =", cmd_buf[3]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+				     "VHT_EN =", cmd_buf[4]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+				     "Hightest rate =", cmd_buf[5]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  0x%x\n",
+				     "Lowest rate =", cmd_buf[6]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  0x%x\n",
+				     "SGI_support =", cmd_buf[7]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+				     "Rate_ID =", cmd_buf[8]);
+			;
+		}
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE,
+			     "-------------------------------\n");
+	} else if (para_idx == RADBG_DEBUG_MONITOR2) {
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE,
+			     "-------------------------------\n");
+		if (dm->support_ic_type & PHYDM_IC_3081_SERIES) {
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+				     "rate_id =", cmd_buf[1]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  0x%x\n",
+				     "highest_rate =", cmd_buf[2]);
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  0x%x\n",
+				     "lowest_rate =", cmd_buf[3]);
+
+			for (i = 4; i <= 11; i++)
+				ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE,
+					     "RAMASK =  0x%x\n", cmd_buf[i]);
+		} else {
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE,
+				     "%5s  %x%x  %x%x  %x%x  %x%x\n",
+				     "RA Mask:", cmd_buf[8], cmd_buf[7],
+				     cmd_buf[6], cmd_buf[5], cmd_buf[4],
+				     cmd_buf[3], cmd_buf[2], cmd_buf[1]);
+		}
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE,
+			     "-------------------------------\n");
+	} else if (para_idx == RADBG_DEBUG_MONITOR3) {
+		for (i = 0; i < (cmd_len - 1); i++)
+			ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE,
+				     "content[%d] = %d\n", i, cmd_buf[1 + i]);
+	} else if (para_idx == RADBG_DEBUG_MONITOR4) {
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  {%d.%d}\n",
+			     "RA version =", cmd_buf[1], cmd_buf[2]);
+	} else if (para_idx == RADBG_DEBUG_MONITOR5) {
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  0x%x\n",
+			     "Current rate =", cmd_buf[1]);
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+			     "Retry ratio =", cmd_buf[2]);
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  %d\n",
+			     "rate down ratio =", cmd_buf[3]);
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  0x%x\n",
+			     "highest rate =", cmd_buf[4]);
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  {0x%x 0x%x}\n",
+			     "Muti-try =", cmd_buf[5], cmd_buf[6]);
+		ODM_RT_TRACE(dm, ODM_FW_DEBUG_TRACE, "%5s  0x%x%x%x%x%x\n",
+			     "RA mask =", cmd_buf[11], cmd_buf[10], cmd_buf[9],
+			     cmd_buf[8], cmd_buf[7]);
+	}
+}
+
+void phydm_ra_dynamic_retry_count(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (!(dm->support_ability & ODM_BB_DYNAMIC_ARFR))
+		return;
+
+	if (dm->pre_b_noisy != dm->noisy_decision) {
+		if (dm->noisy_decision) {
+			ODM_RT_TRACE(dm, ODM_COMP_RATE_ADAPTIVE,
+				     "->Noisy Env. RA fallback value\n");
+			odm_set_mac_reg(dm, 0x430, MASKDWORD, 0x0);
+			odm_set_mac_reg(dm, 0x434, MASKDWORD, 0x04030201);
+		} else {
+			ODM_RT_TRACE(dm, ODM_COMP_RATE_ADAPTIVE,
+				     "->Clean Env. RA fallback value\n");
+			odm_set_mac_reg(dm, 0x430, MASKDWORD, 0x01000000);
+			odm_set_mac_reg(dm, 0x434, MASKDWORD, 0x06050402);
+		}
+		dm->pre_b_noisy = dm->noisy_decision;
+	}
+}
+
+void phydm_ra_dynamic_retry_limit(void *dm_void) {}
+
+void phydm_print_rate(void *dm_void, u8 rate, u32 dbg_component)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 legacy_table[12] = {1, 2, 5, 11, 6, 9, 12, 18, 24, 36, 48, 54};
+	u8 rate_idx = rate & 0x7f; /*remove bit7 SGI*/
+	u8 vht_en = (rate_idx >= ODM_RATEVHTSS1MCS0) ? 1 : 0;
+	u8 b_sgi = (rate & 0x80) >> 7;
+
+	ODM_RT_TRACE(dm, dbg_component, "( %s%s%s%s%d%s%s)\n",
+		     ((rate_idx >= ODM_RATEVHTSS1MCS0) &&
+		      (rate_idx <= ODM_RATEVHTSS1MCS9)) ?
+			     "VHT 1ss  " :
+			     "",
+		     ((rate_idx >= ODM_RATEVHTSS2MCS0) &&
+		      (rate_idx <= ODM_RATEVHTSS2MCS9)) ?
+			     "VHT 2ss " :
+			     "",
+		     ((rate_idx >= ODM_RATEVHTSS3MCS0) &&
+		      (rate_idx <= ODM_RATEVHTSS3MCS9)) ?
+			     "VHT 3ss " :
+			     "",
+		     (rate_idx >= ODM_RATEMCS0) ? "MCS " : "",
+		     (vht_en) ? ((rate_idx - ODM_RATEVHTSS1MCS0) % 10) :
+				((rate_idx >= ODM_RATEMCS0) ?
+					 (rate_idx - ODM_RATEMCS0) :
+					 ((rate_idx <= ODM_RATE54M) ?
+						  legacy_table[rate_idx] :
+						  0)),
+		     (b_sgi) ? "-S" : "  ",
+		     (rate_idx >= ODM_RATEMCS0) ? "" : "M");
+}
+
+void phydm_c2h_ra_report_handler(void *dm_void, u8 *cmd_buf, u8 cmd_len)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct ra_table *ra_tab = &dm->dm_ra_table;
+	u8 macid = cmd_buf[1];
+	u8 rate = cmd_buf[0];
+	u8 rate_idx = rate & 0x7f; /*remove bit7 SGI*/
+	u8 rate_order;
+
+	if (cmd_len >= 4) {
+		if (cmd_buf[3] == 0) {
+			ODM_RT_TRACE(dm, ODM_COMP_RATE_ADAPTIVE,
+				     "TX Init-rate Update[%d]:", macid);
+			/**/
+		} else if (cmd_buf[3] == 0xff) {
+			ODM_RT_TRACE(dm, ODM_COMP_RATE_ADAPTIVE,
+				     "FW Level: Fix rate[%d]:", macid);
+			/**/
+		} else if (cmd_buf[3] == 1) {
+			ODM_RT_TRACE(dm, ODM_COMP_RATE_ADAPTIVE,
+				     "Try Success[%d]:", macid);
+			/**/
+		} else if (cmd_buf[3] == 2) {
+			ODM_RT_TRACE(dm, ODM_COMP_RATE_ADAPTIVE,
+				     "Try Fail & Try Again[%d]:", macid);
+			/**/
+		} else if (cmd_buf[3] == 3) {
+			ODM_RT_TRACE(dm, ODM_COMP_RATE_ADAPTIVE,
+				     "rate Back[%d]:", macid);
+			/**/
+		} else if (cmd_buf[3] == 4) {
+			ODM_RT_TRACE(dm, ODM_COMP_RATE_ADAPTIVE,
+				     "start rate by RSSI[%d]:", macid);
+			/**/
+		} else if (cmd_buf[3] == 5) {
+			ODM_RT_TRACE(dm, ODM_COMP_RATE_ADAPTIVE,
+				     "Try rate[%d]:", macid);
+			/**/
+		}
+	} else {
+		ODM_RT_TRACE(dm, ODM_COMP_RATE_ADAPTIVE, "Tx rate Update[%d]:",
+			     macid);
+		/**/
+	}
+
+	phydm_print_rate(dm, rate, ODM_COMP_RATE_ADAPTIVE);
+
+	ra_tab->link_tx_rate[macid] = rate;
+
+	/*trigger power training*/
+
+	rate_order = phydm_rate_order_compute(dm, rate_idx);
+
+	if ((dm->is_one_entry_only) ||
+	    ((rate_order > ra_tab->highest_client_tx_order) &&
+	     (ra_tab->power_tracking_flag == 1))) {
+		phydm_update_pwr_track(dm, rate_idx);
+		ra_tab->power_tracking_flag = 0;
+	}
+
+	/*trigger dynamic rate ID*/
+}
+
+void odm_rssi_monitor_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct ra_table *ra_tab = &dm->dm_ra_table;
+
+	ra_tab->firstconnect = false;
+}
+
+void odm_ra_post_action_on_assoc(void *dm_void) {}
+
+void phydm_init_ra_info(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (dm->support_ic_type == ODM_RTL8822B) {
+		u32 ret_value;
+
+		ret_value = odm_get_bb_reg(dm, 0x4c8, MASKBYTE2);
+		odm_set_bb_reg(dm, 0x4cc, MASKBYTE3, (ret_value - 1));
+	}
+}
+
+void phydm_modify_RA_PCR_threshold(void *dm_void, u8 RA_offset_direction,
+				   u8 RA_threshold_offset
+
+				   )
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct ra_table *ra_tab = &dm->dm_ra_table;
+
+	ra_tab->RA_offset_direction = RA_offset_direction;
+	ra_tab->RA_threshold_offset = RA_threshold_offset;
+	ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+		     "Set RA_threshold_offset = (( %s%d ))\n",
+		     ((RA_threshold_offset == 0) ?
+			      " " :
+			      ((RA_offset_direction) ? "+" : "-")),
+		     RA_threshold_offset);
+}
+
+static void odm_rssi_monitor_check_mp(void *dm_void) {}
+
+static void odm_rssi_monitor_check_ce(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct ra_table *ra_tab = &dm->dm_ra_table;
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+	struct rtl_mac *mac = rtl_mac(rtlpriv);
+	struct rtl_sta_info *entry;
+	int i;
+	int tmp_entry_min_pwdb = 0xff;
+	unsigned long cur_tx_ok_cnt = 0, cur_rx_ok_cnt = 0;
+	u8 UL_DL_STATE = 0, STBC_TX = 0, tx_bf_en = 0;
+	u8 h2c_parameter[H2C_0X42_LENGTH] = {0};
+	u8 cmdlen = H2C_0X42_LENGTH;
+	u8 macid = 0;
+
+	if (!dm->is_linked)
+		return;
+
+	for (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {
+		entry = (struct rtl_sta_info *)dm->odm_sta_info[i];
+		if (!IS_STA_VALID(entry))
+			continue;
+
+		if (is_multicast_ether_addr(entry->mac_addr) ||
+		    is_broadcast_ether_addr(entry->mac_addr))
+			continue;
+
+		if (entry->rssi_stat.undecorated_smoothed_pwdb == (-1))
+			continue;
+
+		/* calculate min_pwdb */
+		if (entry->rssi_stat.undecorated_smoothed_pwdb <
+		    tmp_entry_min_pwdb)
+			tmp_entry_min_pwdb =
+				entry->rssi_stat.undecorated_smoothed_pwdb;
+
+		/* report RSSI */
+		cur_tx_ok_cnt = rtlpriv->stats.txbytesunicast_inperiod;
+		cur_rx_ok_cnt = rtlpriv->stats.rxbytesunicast_inperiod;
+
+		if (cur_rx_ok_cnt > (cur_tx_ok_cnt * 6))
+			UL_DL_STATE = 1;
+		else
+			UL_DL_STATE = 0;
+
+		if (mac->opmode == NL80211_IFTYPE_AP ||
+		    mac->opmode == NL80211_IFTYPE_ADHOC) {
+			struct ieee80211_sta *sta = container_of(
+				(void *)entry, struct ieee80211_sta, drv_priv);
+			macid = sta->aid + 1;
+		}
+
+		h2c_parameter[0] = macid;
+		h2c_parameter[2] =
+			entry->rssi_stat.undecorated_smoothed_pwdb & 0x7F;
+
+		if (UL_DL_STATE)
+			h2c_parameter[3] |= RAINFO_BE_RX_STATE;
+
+		if (tx_bf_en)
+			h2c_parameter[3] |= RAINFO_BF_STATE;
+		if (STBC_TX)
+			h2c_parameter[3] |= RAINFO_STBC_STATE;
+		if (dm->noisy_decision)
+			h2c_parameter[3] |= RAINFO_NOISY_STATE;
+
+		if (entry->rssi_stat.is_send_rssi == RA_RSSI_STATE_SEND) {
+			h2c_parameter[3] |= RAINFO_INIT_RSSI_RATE_STATE;
+			entry->rssi_stat.is_send_rssi = RA_RSSI_STATE_HOLD;
+		}
+
+		h2c_parameter[4] = (ra_tab->RA_threshold_offset & 0x7f) |
+				   (ra_tab->RA_offset_direction << 7);
+
+		odm_fill_h2c_cmd(dm, ODM_H2C_RSSI_REPORT, cmdlen,
+				 h2c_parameter);
+	}
+
+	if (tmp_entry_min_pwdb != 0xff)
+		dm->rssi_min = tmp_entry_min_pwdb;
+}
+
+static void odm_rssi_monitor_check_ap(void *dm_void) {}
+
+void odm_rssi_monitor_check(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	if (!(dm->support_ability & ODM_BB_RSSI_MONITOR))
+		return;
+
+	switch (dm->support_platform) {
+	case ODM_WIN:
+		odm_rssi_monitor_check_mp(dm);
+		break;
+
+	case ODM_CE:
+		odm_rssi_monitor_check_ce(dm);
+		break;
+
+	case ODM_AP:
+		odm_rssi_monitor_check_ap(dm);
+		break;
+
+	default:
+		break;
+	}
+}
+
+void odm_rate_adaptive_mask_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct odm_rate_adaptive *odm_ra = &dm->rate_adaptive;
+
+	odm_ra->type = dm_type_by_driver;
+	if (odm_ra->type == dm_type_by_driver)
+		dm->is_use_ra_mask = true;
+	else
+		dm->is_use_ra_mask = false;
+
+	odm_ra->ratr_state = DM_RATR_STA_INIT;
+
+	odm_ra->ldpc_thres = 35;
+	odm_ra->is_use_ldpc = false;
+
+	odm_ra->high_rssi_thresh = 50;
+	odm_ra->low_rssi_thresh = 20;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	odm_refresh_rate_adaptive_mask()
+ *
+ * Overview:	Update rate table mask according to rssi
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	05/27/2009	hpfan	Create version 0.
+ *
+ *---------------------------------------------------------------------------
+ */
+void odm_refresh_rate_adaptive_mask(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct ra_table *ra_tab = &dm->dm_ra_table;
+
+	if (!dm->is_linked)
+		return;
+
+	if (!(dm->support_ability & ODM_BB_RA_MASK)) {
+		ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+			     "%s(): Return cos not supported\n", __func__);
+		return;
+	}
+
+	ra_tab->force_update_ra_mask_count++;
+	/* 2011/09/29 MH In HW integration first stage, we provide 4 different
+	 * handle to operate at the same time.
+	 * In the stage2/3, we need to prive universal interface and merge all
+	 * HW dynamic mechanism.
+	 */
+	switch (dm->support_platform) {
+	case ODM_WIN:
+		odm_refresh_rate_adaptive_mask_mp(dm);
+		break;
+
+	case ODM_CE:
+		odm_refresh_rate_adaptive_mask_ce(dm);
+		break;
+
+	case ODM_AP:
+		odm_refresh_rate_adaptive_mask_apadsl(dm);
+		break;
+	}
+}
+
+static u8 phydm_trans_platform_bw(void *dm_void, u8 BW)
+{
+	if (BW == HT_CHANNEL_WIDTH_20)
+		BW = PHYDM_BW_20;
+
+	else if (BW == HT_CHANNEL_WIDTH_20_40)
+		BW = PHYDM_BW_40;
+
+	else if (BW == HT_CHANNEL_WIDTH_80)
+		BW = PHYDM_BW_80;
+
+	return BW;
+}
+
+static u8 phydm_trans_platform_rf_type(void *dm_void, u8 rf_type)
+{
+	if (rf_type == RF_1T2R)
+		rf_type = PHYDM_RF_1T2R;
+
+	else if (rf_type == RF_2T4R)
+		rf_type = PHYDM_RF_2T4R;
+
+	else if (rf_type == RF_2T2R)
+		rf_type = PHYDM_RF_2T2R;
+
+	else if (rf_type == RF_1T1R)
+		rf_type = PHYDM_RF_1T1R;
+
+	else if (rf_type == RF_2T2R_GREEN)
+		rf_type = PHYDM_RF_2T2R_GREEN;
+
+	else if (rf_type == RF_3T3R)
+		rf_type = PHYDM_RF_3T3R;
+
+	else if (rf_type == RF_4T4R)
+		rf_type = PHYDM_RF_4T4R;
+
+	else if (rf_type == RF_2T3R)
+		rf_type = PHYDM_RF_1T2R;
+
+	else if (rf_type == RF_3T4R)
+		rf_type = PHYDM_RF_3T4R;
+
+	return rf_type;
+}
+
+static u32 phydm_trans_platform_wireless_mode(void *dm_void, u32 wireless_mode)
+{
+	return wireless_mode;
+}
+
+u8 phydm_vht_en_mapping(void *dm_void, u32 wireless_mode)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 vht_en_out = 0;
+
+	if ((wireless_mode == PHYDM_WIRELESS_MODE_AC_5G) ||
+	    (wireless_mode == PHYDM_WIRELESS_MODE_AC_24G) ||
+	    (wireless_mode == PHYDM_WIRELESS_MODE_AC_ONLY)) {
+		vht_en_out = 1;
+		/**/
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+		     "wireless_mode= (( 0x%x )), VHT_EN= (( %d ))\n",
+		     wireless_mode, vht_en_out);
+	return vht_en_out;
+}
+
+u8 phydm_rate_id_mapping(void *dm_void, u32 wireless_mode, u8 rf_type, u8 bw)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 rate_id_idx = 0;
+	u8 phydm_BW;
+	u8 phydm_rf_type;
+
+	phydm_BW = phydm_trans_platform_bw(dm, bw);
+	phydm_rf_type = phydm_trans_platform_rf_type(dm, rf_type);
+	wireless_mode = phydm_trans_platform_wireless_mode(dm, wireless_mode);
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_RA_MASK,
+		"wireless_mode= (( 0x%x )), rf_type = (( 0x%x )), BW = (( 0x%x ))\n",
+		wireless_mode, phydm_rf_type, phydm_BW);
+
+	switch (wireless_mode) {
+	case PHYDM_WIRELESS_MODE_N_24G: {
+		if (phydm_BW == PHYDM_BW_40) {
+			if (phydm_rf_type == PHYDM_RF_1T1R)
+				rate_id_idx = PHYDM_BGN_40M_1SS;
+			else if (phydm_rf_type == PHYDM_RF_2T2R)
+				rate_id_idx = PHYDM_BGN_40M_2SS;
+			else
+				rate_id_idx = PHYDM_ARFR5_N_3SS;
+
+		} else {
+			if (phydm_rf_type == PHYDM_RF_1T1R)
+				rate_id_idx = PHYDM_BGN_20M_1SS;
+			else if (phydm_rf_type == PHYDM_RF_2T2R)
+				rate_id_idx = PHYDM_BGN_20M_2SS;
+			else
+				rate_id_idx = PHYDM_ARFR5_N_3SS;
+		}
+	} break;
+
+	case PHYDM_WIRELESS_MODE_N_5G: {
+		if (phydm_rf_type == PHYDM_RF_1T1R)
+			rate_id_idx = PHYDM_GN_N1SS;
+		else if (phydm_rf_type == PHYDM_RF_2T2R)
+			rate_id_idx = PHYDM_GN_N2SS;
+		else
+			rate_id_idx = PHYDM_ARFR5_N_3SS;
+	}
+
+	break;
+
+	case PHYDM_WIRELESS_MODE_G:
+		rate_id_idx = PHYDM_BG;
+		break;
+
+	case PHYDM_WIRELESS_MODE_A:
+		rate_id_idx = PHYDM_G;
+		break;
+
+	case PHYDM_WIRELESS_MODE_B:
+		rate_id_idx = PHYDM_B_20M;
+		break;
+
+	case PHYDM_WIRELESS_MODE_AC_5G:
+	case PHYDM_WIRELESS_MODE_AC_ONLY: {
+		if (phydm_rf_type == PHYDM_RF_1T1R)
+			rate_id_idx = PHYDM_ARFR1_AC_1SS;
+		else if (phydm_rf_type == PHYDM_RF_2T2R)
+			rate_id_idx = PHYDM_ARFR0_AC_2SS;
+		else
+			rate_id_idx = PHYDM_ARFR4_AC_3SS;
+	} break;
+
+	case PHYDM_WIRELESS_MODE_AC_24G: {
+		/*Becareful to set "Lowest rate" while using PHYDM_ARFR4_AC_3SS
+		 *in 2.4G/5G
+		 */
+		if (phydm_BW >= PHYDM_BW_80) {
+			if (phydm_rf_type == PHYDM_RF_1T1R)
+				rate_id_idx = PHYDM_ARFR1_AC_1SS;
+			else if (phydm_rf_type == PHYDM_RF_2T2R)
+				rate_id_idx = PHYDM_ARFR0_AC_2SS;
+			else
+				rate_id_idx = PHYDM_ARFR4_AC_3SS;
+		} else {
+			if (phydm_rf_type == PHYDM_RF_1T1R)
+				rate_id_idx = PHYDM_ARFR2_AC_2G_1SS;
+			else if (phydm_rf_type == PHYDM_RF_2T2R)
+				rate_id_idx = PHYDM_ARFR3_AC_2G_2SS;
+			else
+				rate_id_idx = PHYDM_ARFR4_AC_3SS;
+		}
+	} break;
+
+	default:
+		rate_id_idx = 0;
+		break;
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_RA_MASK, "RA rate ID = (( 0x%x ))\n",
+		     rate_id_idx);
+
+	return rate_id_idx;
+}
+
+void phydm_update_hal_ra_mask(void *dm_void, u32 wireless_mode, u8 rf_type,
+			      u8 BW, u8 mimo_ps_enable, u8 disable_cck_rate,
+			      u32 *ratr_bitmap_msb_in, u32 *ratr_bitmap_lsb_in,
+			      u8 tx_rate_level)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 phydm_rf_type;
+	u8 phydm_BW;
+	u32 ratr_bitmap = *ratr_bitmap_lsb_in,
+	    ratr_bitmap_msb = *ratr_bitmap_msb_in;
+
+	wireless_mode = phydm_trans_platform_wireless_mode(dm, wireless_mode);
+
+	phydm_rf_type = phydm_trans_platform_rf_type(dm, rf_type);
+	phydm_BW = phydm_trans_platform_bw(dm, BW);
+
+	ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+		     "Platfoem original RA Mask = (( 0x %x | %x ))\n",
+		     ratr_bitmap_msb, ratr_bitmap);
+
+	switch (wireless_mode) {
+	case PHYDM_WIRELESS_MODE_B: {
+		ratr_bitmap &= 0x0000000f;
+	} break;
+
+	case PHYDM_WIRELESS_MODE_G: {
+		ratr_bitmap &= 0x00000ff5;
+	} break;
+
+	case PHYDM_WIRELESS_MODE_A: {
+		ratr_bitmap &= 0x00000ff0;
+	} break;
+
+	case PHYDM_WIRELESS_MODE_N_24G:
+	case PHYDM_WIRELESS_MODE_N_5G: {
+		if (mimo_ps_enable)
+			phydm_rf_type = PHYDM_RF_1T1R;
+
+		if (phydm_rf_type == PHYDM_RF_1T1R) {
+			if (phydm_BW == PHYDM_BW_40)
+				ratr_bitmap &= 0x000ff015;
+			else
+				ratr_bitmap &= 0x000ff005;
+		} else if (phydm_rf_type == PHYDM_RF_2T2R ||
+			   phydm_rf_type == PHYDM_RF_2T4R ||
+			   phydm_rf_type == PHYDM_RF_2T3R) {
+			if (phydm_BW == PHYDM_BW_40)
+				ratr_bitmap &= 0x0ffff015;
+			else
+				ratr_bitmap &= 0x0ffff005;
+		} else { /*3T*/
+
+			ratr_bitmap &= 0xfffff015;
+			ratr_bitmap_msb &= 0xf;
+		}
+	} break;
+
+	case PHYDM_WIRELESS_MODE_AC_24G: {
+		if (phydm_rf_type == PHYDM_RF_1T1R) {
+			ratr_bitmap &= 0x003ff015;
+		} else if (phydm_rf_type == PHYDM_RF_2T2R ||
+			   phydm_rf_type == PHYDM_RF_2T4R ||
+			   phydm_rf_type == PHYDM_RF_2T3R) {
+			ratr_bitmap &= 0xfffff015;
+		} else { /*3T*/
+
+			ratr_bitmap &= 0xfffff010;
+			ratr_bitmap_msb &= 0x3ff;
+		}
+
+		if (phydm_BW ==
+		    PHYDM_BW_20) { /* AC 20MHz doesn't support MCS9 */
+			ratr_bitmap &= 0x7fdfffff;
+			ratr_bitmap_msb &= 0x1ff;
+		}
+	} break;
+
+	case PHYDM_WIRELESS_MODE_AC_5G: {
+		if (phydm_rf_type == PHYDM_RF_1T1R) {
+			ratr_bitmap &= 0x003ff010;
+		} else if (phydm_rf_type == PHYDM_RF_2T2R ||
+			   phydm_rf_type == PHYDM_RF_2T4R ||
+			   phydm_rf_type == PHYDM_RF_2T3R) {
+			ratr_bitmap &= 0xfffff010;
+		} else { /*3T*/
+
+			ratr_bitmap &= 0xfffff010;
+			ratr_bitmap_msb &= 0x3ff;
+		}
+
+		if (phydm_BW ==
+		    PHYDM_BW_20) { /* AC 20MHz doesn't support MCS9 */
+			ratr_bitmap &= 0x7fdfffff;
+			ratr_bitmap_msb &= 0x1ff;
+		}
+	} break;
+
+	default:
+		break;
+	}
+
+	if (wireless_mode != PHYDM_WIRELESS_MODE_B) {
+		if (tx_rate_level == 0)
+			ratr_bitmap &= 0xffffffff;
+		else if (tx_rate_level == 1)
+			ratr_bitmap &= 0xfffffff0;
+		else if (tx_rate_level == 2)
+			ratr_bitmap &= 0xffffefe0;
+		else if (tx_rate_level == 3)
+			ratr_bitmap &= 0xffffcfc0;
+		else if (tx_rate_level == 4)
+			ratr_bitmap &= 0xffff8f80;
+		else if (tx_rate_level >= 5)
+			ratr_bitmap &= 0xffff0f00;
+	}
+
+	if (disable_cck_rate)
+		ratr_bitmap &= 0xfffffff0;
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_RA_MASK,
+		"wireless_mode= (( 0x%x )), rf_type = (( 0x%x )), BW = (( 0x%x )), MimoPs_en = (( %d )), tx_rate_level= (( 0x%x ))\n",
+		wireless_mode, phydm_rf_type, phydm_BW, mimo_ps_enable,
+		tx_rate_level);
+
+	*ratr_bitmap_lsb_in = ratr_bitmap;
+	*ratr_bitmap_msb_in = ratr_bitmap_msb;
+	ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+		     "Phydm modified RA Mask = (( 0x %x | %x ))\n",
+		     *ratr_bitmap_msb_in, *ratr_bitmap_lsb_in);
+}
+
+u8 phydm_RA_level_decision(void *dm_void, u32 rssi, u8 ratr_state)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 ra_rate_floor_table[RA_FLOOR_TABLE_SIZE] = {
+		20, 34, 38, 42,
+		46, 50, 100}; /*MCS0 ~ MCS4 , VHT1SS MCS0 ~ MCS4 , G 6M~24M*/
+	u8 new_ratr_state = 0;
+	u8 i;
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_RA_MASK,
+		"curr RA level = ((%d)), Rate_floor_table ori [ %d , %d, %d , %d, %d, %d]\n",
+		ratr_state, ra_rate_floor_table[0], ra_rate_floor_table[1],
+		ra_rate_floor_table[2], ra_rate_floor_table[3],
+		ra_rate_floor_table[4], ra_rate_floor_table[5]);
+
+	for (i = 0; i < RA_FLOOR_TABLE_SIZE; i++) {
+		if (i >= (ratr_state))
+			ra_rate_floor_table[i] += RA_FLOOR_UP_GAP;
+	}
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_RA_MASK,
+		"RSSI = ((%d)), Rate_floor_table_mod [ %d , %d, %d , %d, %d, %d]\n",
+		rssi, ra_rate_floor_table[0], ra_rate_floor_table[1],
+		ra_rate_floor_table[2], ra_rate_floor_table[3],
+		ra_rate_floor_table[4], ra_rate_floor_table[5]);
+
+	for (i = 0; i < RA_FLOOR_TABLE_SIZE; i++) {
+		if (rssi < ra_rate_floor_table[i]) {
+			new_ratr_state = i;
+			break;
+		}
+	}
+
+	return new_ratr_state;
+}
+
+void odm_refresh_rate_adaptive_mask_mp(void *dm_void) {}
+
+void odm_refresh_rate_adaptive_mask_ce(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct ra_table *ra_tab = &dm->dm_ra_table;
+	void *adapter = dm->adapter;
+	u32 i;
+	struct rtl_sta_info *entry;
+	u8 ratr_state_new;
+
+	if (!dm->is_use_ra_mask) {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_RA_MASK,
+			"<---- %s(): driver does not control rate adaptive mask\n",
+			__func__);
+		return;
+	}
+
+	for (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {
+		entry = dm->odm_sta_info[i];
+
+		if (!IS_STA_VALID(entry))
+			continue;
+
+		if (is_multicast_ether_addr(entry->mac_addr))
+			continue;
+		else if (is_broadcast_ether_addr(entry->mac_addr))
+			continue;
+
+		ratr_state_new = phydm_RA_level_decision(
+			dm, entry->rssi_stat.undecorated_smoothed_pwdb,
+			entry->rssi_level);
+
+		if ((entry->rssi_level != ratr_state_new) ||
+		    (ra_tab->force_update_ra_mask_count >=
+		     FORCED_UPDATE_RAMASK_PERIOD)) {
+			ra_tab->force_update_ra_mask_count = 0;
+			ODM_RT_TRACE(
+				dm, ODM_COMP_RA_MASK,
+				"Update Tx RA Level: ((%x)) -> ((%x)),  RSSI = ((%d))\n",
+				entry->rssi_level, ratr_state_new,
+				entry->rssi_stat.undecorated_smoothed_pwdb);
+
+			entry->rssi_level = ratr_state_new;
+			rtl_hal_update_ra_mask(adapter, entry,
+					       entry->rssi_level);
+		} else {
+			ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+				     "Stay in RA level  = (( %d ))\n\n",
+				     ratr_state_new);
+			/**/
+		}
+	}
+}
+
+void odm_refresh_rate_adaptive_mask_apadsl(void *dm_void) {}
+
+void odm_refresh_basic_rate_mask(void *dm_void) {}
+
+u8 phydm_rate_order_compute(void *dm_void, u8 rate_idx)
+{
+	u8 rate_order = 0;
+
+	if (rate_idx >= ODM_RATEVHTSS4MCS0) {
+		rate_idx -= ODM_RATEVHTSS4MCS0;
+		/**/
+	} else if (rate_idx >= ODM_RATEVHTSS3MCS0) {
+		rate_idx -= ODM_RATEVHTSS3MCS0;
+		/**/
+	} else if (rate_idx >= ODM_RATEVHTSS2MCS0) {
+		rate_idx -= ODM_RATEVHTSS2MCS0;
+		/**/
+	} else if (rate_idx >= ODM_RATEVHTSS1MCS0) {
+		rate_idx -= ODM_RATEVHTSS1MCS0;
+		/**/
+	} else if (rate_idx >= ODM_RATEMCS24) {
+		rate_idx -= ODM_RATEMCS24;
+		/**/
+	} else if (rate_idx >= ODM_RATEMCS16) {
+		rate_idx -= ODM_RATEMCS16;
+		/**/
+	} else if (rate_idx >= ODM_RATEMCS8) {
+		rate_idx -= ODM_RATEMCS8;
+		/**/
+	}
+	rate_order = rate_idx;
+
+	return rate_order;
+}
+
+static void phydm_ra_common_info_update(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct ra_table *ra_tab = &dm->dm_ra_table;
+	u16 macid;
+	u8 rate_order_tmp;
+	u8 cnt = 0;
+
+	ra_tab->highest_client_tx_order = 0;
+	ra_tab->power_tracking_flag = 1;
+
+	if (dm->number_linked_client != 0) {
+		for (macid = 0; macid < ODM_ASSOCIATE_ENTRY_NUM; macid++) {
+			rate_order_tmp = phydm_rate_order_compute(
+				dm, ((ra_tab->link_tx_rate[macid]) & 0x7f));
+
+			if (rate_order_tmp >=
+			    (ra_tab->highest_client_tx_order)) {
+				ra_tab->highest_client_tx_order =
+					rate_order_tmp;
+				ra_tab->highest_client_tx_rate_order = macid;
+			}
+
+			cnt++;
+
+			if (cnt == dm->number_linked_client)
+				break;
+		}
+		ODM_RT_TRACE(
+			dm, ODM_COMP_RATE_ADAPTIVE,
+			"MACID[%d], Highest Tx order Update for power traking: %d\n",
+			(ra_tab->highest_client_tx_rate_order),
+			(ra_tab->highest_client_tx_order));
+	}
+}
+
+void phydm_ra_info_watchdog(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	phydm_ra_common_info_update(dm);
+	phydm_ra_dynamic_retry_limit(dm);
+	phydm_ra_dynamic_retry_count(dm);
+	odm_refresh_rate_adaptive_mask(dm);
+	odm_refresh_basic_rate_mask(dm);
+}
+
+void phydm_ra_info_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct ra_table *ra_tab = &dm->dm_ra_table;
+
+	ra_tab->highest_client_tx_rate_order = 0;
+	ra_tab->highest_client_tx_order = 0;
+	ra_tab->RA_threshold_offset = 0;
+	ra_tab->RA_offset_direction = 0;
+}
+
+u8 odm_find_rts_rate(void *dm_void, u8 tx_rate, bool is_erp_protect)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	u8 rts_ini_rate = ODM_RATE6M;
+
+	if (is_erp_protect) { /* use CCK rate as RTS*/
+		rts_ini_rate = ODM_RATE1M;
+	} else {
+		switch (tx_rate) {
+		case ODM_RATEVHTSS3MCS9:
+		case ODM_RATEVHTSS3MCS8:
+		case ODM_RATEVHTSS3MCS7:
+		case ODM_RATEVHTSS3MCS6:
+		case ODM_RATEVHTSS3MCS5:
+		case ODM_RATEVHTSS3MCS4:
+		case ODM_RATEVHTSS3MCS3:
+		case ODM_RATEVHTSS2MCS9:
+		case ODM_RATEVHTSS2MCS8:
+		case ODM_RATEVHTSS2MCS7:
+		case ODM_RATEVHTSS2MCS6:
+		case ODM_RATEVHTSS2MCS5:
+		case ODM_RATEVHTSS2MCS4:
+		case ODM_RATEVHTSS2MCS3:
+		case ODM_RATEVHTSS1MCS9:
+		case ODM_RATEVHTSS1MCS8:
+		case ODM_RATEVHTSS1MCS7:
+		case ODM_RATEVHTSS1MCS6:
+		case ODM_RATEVHTSS1MCS5:
+		case ODM_RATEVHTSS1MCS4:
+		case ODM_RATEVHTSS1MCS3:
+		case ODM_RATEMCS15:
+		case ODM_RATEMCS14:
+		case ODM_RATEMCS13:
+		case ODM_RATEMCS12:
+		case ODM_RATEMCS11:
+		case ODM_RATEMCS7:
+		case ODM_RATEMCS6:
+		case ODM_RATEMCS5:
+		case ODM_RATEMCS4:
+		case ODM_RATEMCS3:
+		case ODM_RATE54M:
+		case ODM_RATE48M:
+		case ODM_RATE36M:
+		case ODM_RATE24M:
+			rts_ini_rate = ODM_RATE24M;
+			break;
+		case ODM_RATEVHTSS3MCS2:
+		case ODM_RATEVHTSS3MCS1:
+		case ODM_RATEVHTSS2MCS2:
+		case ODM_RATEVHTSS2MCS1:
+		case ODM_RATEVHTSS1MCS2:
+		case ODM_RATEVHTSS1MCS1:
+		case ODM_RATEMCS10:
+		case ODM_RATEMCS9:
+		case ODM_RATEMCS2:
+		case ODM_RATEMCS1:
+		case ODM_RATE18M:
+		case ODM_RATE12M:
+			rts_ini_rate = ODM_RATE12M;
+			break;
+		case ODM_RATEVHTSS3MCS0:
+		case ODM_RATEVHTSS2MCS0:
+		case ODM_RATEVHTSS1MCS0:
+		case ODM_RATEMCS8:
+		case ODM_RATEMCS0:
+		case ODM_RATE9M:
+		case ODM_RATE6M:
+			rts_ini_rate = ODM_RATE6M;
+			break;
+		case ODM_RATE11M:
+		case ODM_RATE5_5M:
+		case ODM_RATE2M:
+		case ODM_RATE1M:
+			rts_ini_rate = ODM_RATE1M;
+			break;
+		default:
+			rts_ini_rate = ODM_RATE6M;
+			break;
+		}
+	}
+
+	if (*dm->band_type == 1) {
+		if (rts_ini_rate < ODM_RATE6M)
+			rts_ini_rate = ODM_RATE6M;
+	}
+	return rts_ini_rate;
+}
+
+static void odm_set_ra_dm_arfb_by_noisy(struct phy_dm_struct *dm) {}
+
+void odm_update_noisy_state(void *dm_void, bool is_noisy_state_from_c2h)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	/* JJ ADD 20161014 */
+	if (dm->support_ic_type == ODM_RTL8821 ||
+	    dm->support_ic_type == ODM_RTL8812 ||
+	    dm->support_ic_type == ODM_RTL8723B ||
+	    dm->support_ic_type == ODM_RTL8192E ||
+	    dm->support_ic_type == ODM_RTL8188E ||
+	    dm->support_ic_type == ODM_RTL8723D ||
+	    dm->support_ic_type == ODM_RTL8710B)
+		dm->is_noisy_state = is_noisy_state_from_c2h;
+	odm_set_ra_dm_arfb_by_noisy(dm);
+};
+
+void phydm_update_pwr_track(void *dm_void, u8 rate)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK, "Pwr Track Get rate=0x%x\n",
+		     rate);
+
+	dm->tx_rate = rate;
+}
+
+/* RA_MASK_PHYDMLIZE, will delete it later*/
+
+bool odm_ra_state_check(void *dm_void, s32 rssi, bool is_force_update,
+			u8 *ra_tr_state)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct odm_rate_adaptive *ra = &dm->rate_adaptive;
+	const u8 go_up_gap = 5;
+	u8 high_rssi_thresh_for_ra = ra->high_rssi_thresh;
+	u8 low_rssi_thresh_for_ra = ra->low_rssi_thresh;
+	u8 ratr_state;
+
+	ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+		     "RSSI= (( %d )), Current_RSSI_level = (( %d ))\n", rssi,
+		     *ra_tr_state);
+	ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+		     "[Ori RA RSSI Thresh]  High= (( %d )), Low = (( %d ))\n",
+		     high_rssi_thresh_for_ra, low_rssi_thresh_for_ra);
+	/* threshold Adjustment:
+	 * when RSSI state trends to go up one or two levels, make sure RSSI is
+	 * high enough. Here go_up_gap is added to solve the boundary's level
+	 * alternation issue.
+	 */
+
+	switch (*ra_tr_state) {
+	case DM_RATR_STA_INIT:
+	case DM_RATR_STA_HIGH:
+		break;
+
+	case DM_RATR_STA_MIDDLE:
+		high_rssi_thresh_for_ra += go_up_gap;
+		break;
+
+	case DM_RATR_STA_LOW:
+		high_rssi_thresh_for_ra += go_up_gap;
+		low_rssi_thresh_for_ra += go_up_gap;
+		break;
+
+	default:
+		WARN_ONCE(true, "wrong rssi level setting %d !", *ra_tr_state);
+		break;
+	}
+
+	/* Decide ratr_state by RSSI.*/
+	if (rssi > high_rssi_thresh_for_ra)
+		ratr_state = DM_RATR_STA_HIGH;
+	else if (rssi > low_rssi_thresh_for_ra)
+		ratr_state = DM_RATR_STA_MIDDLE;
+
+	else
+		ratr_state = DM_RATR_STA_LOW;
+	ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+		     "[Mod RA RSSI Thresh]  High= (( %d )), Low = (( %d ))\n",
+		     high_rssi_thresh_for_ra, low_rssi_thresh_for_ra);
+
+	if (*ra_tr_state != ratr_state || is_force_update) {
+		ODM_RT_TRACE(dm, ODM_COMP_RA_MASK,
+			     "[RSSI Level Update] %d->%d\n", *ra_tr_state,
+			     ratr_state);
+		*ra_tr_state = ratr_state;
+		return true;
+	}
+
+	return false;
+}
diff --git a/drivers/staging/rtlwifi/phydm/phydm_rainfo.h b/drivers/staging/rtlwifi/phydm/phydm_rainfo.h
new file mode 100644
index 000000000000..c14ed9bda0af
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_rainfo.h
@@ -0,0 +1,269 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __PHYDMRAINFO_H__
+#define __PHYDMRAINFO_H__
+
+/*#define RAINFO_VERSION	"2.0"*/ /*2014.11.04*/
+/*#define RAINFO_VERSION	"3.0"*/ /*2015.01.13 Dino*/
+/*#define RAINFO_VERSION	"3.1"*/ /*2015.01.14 Dino*/
+/*#define RAINFO_VERSION	"3.3"*/ /*2015.07.29 YuChen*/
+/*#define RAINFO_VERSION	"3.4"*/ /*2015.12.15 Stanley*/
+/*#define RAINFO_VERSION	"4.0"*/ /*2016.03.24 Dino, Add more RA mask
+					  *state and Phydm-lize partial ra mask
+					  *function
+					  */
+/*#define RAINFO_VERSION	"4.1"*/ /*2016.04.20 Dino, Add new function to
+					  *adjust PCR RA threshold
+					  */
+/*#define RAINFO_VERSION	"4.2"*/ /*2016.05.17 Dino, Add H2C debug cmd */
+#define RAINFO_VERSION "4.3" /*2016.07.11 Dino, Fix RA hang in CCK 1M problem*/
+
+#define FORCED_UPDATE_RAMASK_PERIOD 5
+
+#define H2C_0X42_LENGTH 5
+#define H2C_MAX_LENGTH 7
+
+#define RA_FLOOR_UP_GAP 3
+#define RA_FLOOR_TABLE_SIZE 7
+
+#define ACTIVE_TP_THRESHOLD 150
+#define RA_RETRY_DESCEND_NUM 2
+#define RA_RETRY_LIMIT_LOW 4
+#define RA_RETRY_LIMIT_HIGH 32
+
+#define RAINFO_BE_RX_STATE BIT(0) /* 1:RX    */ /* ULDL */
+#define RAINFO_STBC_STATE BIT(1)
+/* #define RAINFO_LDPC_STATE			BIT2 */
+#define RAINFO_NOISY_STATE BIT(2) /* set by Noisy_Detection */
+#define RAINFO_SHURTCUT_STATE BIT(3)
+#define RAINFO_SHURTCUT_FLAG BIT(4)
+#define RAINFO_INIT_RSSI_RATE_STATE BIT(5)
+#define RAINFO_BF_STATE BIT(6)
+#define RAINFO_BE_TX_STATE BIT(7) /* 1:TX */
+
+#define RA_MASK_CCK 0xf
+#define RA_MASK_OFDM 0xff0
+#define RA_MASK_HT1SS 0xff000
+#define RA_MASK_HT2SS 0xff00000
+/*#define	RA_MASK_MCS3SS	*/
+#define RA_MASK_HT4SS 0xff0
+#define RA_MASK_VHT1SS 0x3ff000
+#define RA_MASK_VHT2SS 0xffc00000
+
+#define RA_FIRST_MACID 0
+
+#define ap_init_rate_adaptive_state odm_rate_adaptive_state_ap_init
+
+#define DM_RATR_STA_INIT 0
+#define DM_RATR_STA_HIGH 1
+#define DM_RATR_STA_MIDDLE 2
+#define DM_RATR_STA_LOW 3
+#define DM_RATR_STA_ULTRA_LOW 4
+
+enum phydm_ra_arfr_num {
+	ARFR_0_RATE_ID = 0x9,
+	ARFR_1_RATE_ID = 0xa,
+	ARFR_2_RATE_ID = 0xb,
+	ARFR_3_RATE_ID = 0xc,
+	ARFR_4_RATE_ID = 0xd,
+	ARFR_5_RATE_ID = 0xe
+};
+
+enum phydm_ra_dbg_para {
+	RADBG_PCR_TH_OFFSET = 0,
+	RADBG_RTY_PENALTY = 1,
+	RADBG_N_HIGH = 2,
+	RADBG_N_LOW = 3,
+	RADBG_TRATE_UP_TABLE = 4,
+	RADBG_TRATE_DOWN_TABLE = 5,
+	RADBG_TRYING_NECESSARY = 6,
+	RADBG_TDROPING_NECESSARY = 7,
+	RADBG_RATE_UP_RTY_RATIO = 8,
+	RADBG_RATE_DOWN_RTY_RATIO = 9, /* u8 */
+
+	RADBG_DEBUG_MONITOR1 = 0xc,
+	RADBG_DEBUG_MONITOR2 = 0xd,
+	RADBG_DEBUG_MONITOR3 = 0xe,
+	RADBG_DEBUG_MONITOR4 = 0xf,
+	RADBG_DEBUG_MONITOR5 = 0x10,
+	NUM_RA_PARA
+};
+
+enum phydm_wireless_mode {
+	PHYDM_WIRELESS_MODE_UNKNOWN = 0x00,
+	PHYDM_WIRELESS_MODE_A = 0x01,
+	PHYDM_WIRELESS_MODE_B = 0x02,
+	PHYDM_WIRELESS_MODE_G = 0x04,
+	PHYDM_WIRELESS_MODE_AUTO = 0x08,
+	PHYDM_WIRELESS_MODE_N_24G = 0x10,
+	PHYDM_WIRELESS_MODE_N_5G = 0x20,
+	PHYDM_WIRELESS_MODE_AC_5G = 0x40,
+	PHYDM_WIRELESS_MODE_AC_24G = 0x80,
+	PHYDM_WIRELESS_MODE_AC_ONLY = 0x100,
+	PHYDM_WIRELESS_MODE_MAX = 0x800,
+	PHYDM_WIRELESS_MODE_ALL = 0xFFFF
+};
+
+enum phydm_rateid_idx {
+	PHYDM_BGN_40M_2SS = 0,
+	PHYDM_BGN_40M_1SS = 1,
+	PHYDM_BGN_20M_2SS = 2,
+	PHYDM_BGN_20M_1SS = 3,
+	PHYDM_GN_N2SS = 4,
+	PHYDM_GN_N1SS = 5,
+	PHYDM_BG = 6,
+	PHYDM_G = 7,
+	PHYDM_B_20M = 8,
+	PHYDM_ARFR0_AC_2SS = 9,
+	PHYDM_ARFR1_AC_1SS = 10,
+	PHYDM_ARFR2_AC_2G_1SS = 11,
+	PHYDM_ARFR3_AC_2G_2SS = 12,
+	PHYDM_ARFR4_AC_3SS = 13,
+	PHYDM_ARFR5_N_3SS = 14
+};
+
+enum phydm_rf_type_def {
+	PHYDM_RF_1T1R = 0,
+	PHYDM_RF_1T2R,
+	PHYDM_RF_2T2R,
+	PHYDM_RF_2T2R_GREEN,
+	PHYDM_RF_2T3R,
+	PHYDM_RF_2T4R,
+	PHYDM_RF_3T3R,
+	PHYDM_RF_3T4R,
+	PHYDM_RF_4T4R,
+	PHYDM_RF_MAX_TYPE
+};
+
+enum phydm_bw {
+	PHYDM_BW_20 = 0,
+	PHYDM_BW_40,
+	PHYDM_BW_80,
+	PHYDM_BW_80_80,
+	PHYDM_BW_160,
+	PHYDM_BW_10,
+	PHYDM_BW_5
+};
+
+struct ra_table {
+	u8 firstconnect;
+
+	u8 link_tx_rate[ODM_ASSOCIATE_ENTRY_NUM];
+	u8 highest_client_tx_order;
+	u16 highest_client_tx_rate_order;
+	u8 power_tracking_flag;
+	u8 RA_threshold_offset;
+	u8 RA_offset_direction;
+	u8 force_update_ra_mask_count;
+};
+
+struct odm_rate_adaptive {
+	/* dm_type_by_fw/dm_type_by_driver */
+	u8 type;
+	/* if RSSI > high_rssi_thresh	=> ratr_state is DM_RATR_STA_HIGH */
+	u8 high_rssi_thresh;
+	/* if RSSI <= low_rssi_thresh	=> ratr_state is DM_RATR_STA_LOW */
+	u8 low_rssi_thresh;
+	/* Cur RSSI level, DM_RATR_STA_HIGH/DM_RATR_STA_MIDDLE/DM_RATR_STA_LOW*/
+	u8 ratr_state;
+
+	/* if RSSI > ldpc_thres => switch from LPDC to BCC */
+	u8 ldpc_thres;
+	bool is_lower_rts_rate;
+
+	bool is_use_ldpc;
+};
+
+void phydm_h2C_debug(void *dm_void, u32 *const dm_value, u32 *_used,
+		     char *output, u32 *_out_len);
+
+void phydm_RA_debug_PCR(void *dm_void, u32 *const dm_value, u32 *_used,
+			char *output, u32 *_out_len);
+
+void odm_c2h_ra_para_report_handler(void *dm_void, u8 *cmd_buf, u8 cmd_len);
+
+void odm_ra_para_adjust(void *dm_void);
+
+void phydm_ra_dynamic_retry_count(void *dm_void);
+
+void phydm_ra_dynamic_retry_limit(void *dm_void);
+
+void phydm_ra_dynamic_rate_id_on_assoc(void *dm_void, u8 wireless_mode,
+				       u8 init_rate_id);
+
+void phydm_print_rate(void *dm_void, u8 rate, u32 dbg_component);
+
+void phydm_c2h_ra_report_handler(void *dm_void, u8 *cmd_buf, u8 cmd_len);
+
+u8 phydm_rate_order_compute(void *dm_void, u8 rate_idx);
+
+void phydm_ra_info_watchdog(void *dm_void);
+
+void phydm_ra_info_init(void *dm_void);
+
+void odm_rssi_monitor_init(void *dm_void);
+
+void phydm_modify_RA_PCR_threshold(void *dm_void, u8 RA_offset_direction,
+				   u8 RA_threshold_offset);
+
+void odm_rssi_monitor_check(void *dm_void);
+
+void phydm_init_ra_info(void *dm_void);
+
+u8 phydm_vht_en_mapping(void *dm_void, u32 wireless_mode);
+
+u8 phydm_rate_id_mapping(void *dm_void, u32 wireless_mode, u8 rf_type, u8 bw);
+
+void phydm_update_hal_ra_mask(void *dm_void, u32 wireless_mode, u8 rf_type,
+			      u8 BW, u8 mimo_ps_enable, u8 disable_cck_rate,
+			      u32 *ratr_bitmap_msb_in, u32 *ratr_bitmap_in,
+			      u8 tx_rate_level);
+
+void odm_rate_adaptive_mask_init(void *dm_void);
+
+void odm_refresh_rate_adaptive_mask(void *dm_void);
+
+void odm_refresh_rate_adaptive_mask_mp(void *dm_void);
+
+void odm_refresh_rate_adaptive_mask_ce(void *dm_void);
+
+void odm_refresh_rate_adaptive_mask_apadsl(void *dm_void);
+
+u8 phydm_RA_level_decision(void *dm_void, u32 rssi, u8 ratr_state);
+
+bool odm_ra_state_check(void *dm_void, s32 RSSI, bool is_force_update,
+			u8 *ra_tr_state);
+
+void odm_refresh_basic_rate_mask(void *dm_void);
+void odm_ra_post_action_on_assoc(void *dm);
+
+u8 odm_find_rts_rate(void *dm_void, u8 tx_rate, bool is_erp_protect);
+
+void odm_update_noisy_state(void *dm_void, bool is_noisy_state_from_c2h);
+
+void phydm_update_pwr_track(void *dm_void, u8 rate);
+
+#endif /*#ifndef	__ODMRAINFO_H__*/
diff --git a/drivers/staging/rtlwifi/phydm/phydm_reg.h b/drivers/staging/rtlwifi/phydm/phydm_reg.h
new file mode 100644
index 000000000000..d9d878e4c925
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_reg.h
@@ -0,0 +1,151 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+/* ************************************************************
+ * File Name: odm_reg.h
+ *
+ * Description:
+ *
+ * This file is for general register definition.
+ *
+ *
+ * *************************************************************/
+#ifndef __HAL_ODM_REG_H__
+#define __HAL_ODM_REG_H__
+
+/*
+ * Register Definition
+ */
+
+/* MAC REG */
+#define ODM_BB_RESET 0x002
+#define ODM_DUMMY 0x4fe
+#define RF_T_METER_OLD 0x24
+#define RF_T_METER_NEW 0x42
+
+#define ODM_EDCA_VO_PARAM 0x500
+#define ODM_EDCA_VI_PARAM 0x504
+#define ODM_EDCA_BE_PARAM 0x508
+#define ODM_EDCA_BK_PARAM 0x50C
+#define ODM_TXPAUSE 0x522
+
+/* LTE_COEX */
+#define REG_LTECOEX_CTRL 0x07C0
+#define REG_LTECOEX_WRITE_DATA 0x07C4
+#define REG_LTECOEX_READ_DATA 0x07C8
+#define REG_LTECOEX_PATH_CONTROL 0x70
+
+/* BB REG */
+#define ODM_FPGA_PHY0_PAGE8 0x800
+#define ODM_PSD_SETTING 0x808
+#define ODM_AFE_SETTING 0x818
+#define ODM_TXAGC_B_6_18 0x830
+#define ODM_TXAGC_B_24_54 0x834
+#define ODM_TXAGC_B_MCS32_5 0x838
+#define ODM_TXAGC_B_MCS0_MCS3 0x83c
+#define ODM_TXAGC_B_MCS4_MCS7 0x848
+#define ODM_TXAGC_B_MCS8_MCS11 0x84c
+#define ODM_ANALOG_REGISTER 0x85c
+#define ODM_RF_INTERFACE_OUTPUT 0x860
+#define ODM_TXAGC_B_MCS12_MCS15 0x868
+#define ODM_TXAGC_B_11_A_2_11 0x86c
+#define ODM_AD_DA_LSB_MASK 0x874
+#define ODM_ENABLE_3_WIRE 0x88c
+#define ODM_PSD_REPORT 0x8b4
+#define ODM_R_ANT_SELECT 0x90c
+#define ODM_CCK_ANT_SELECT 0xa07
+#define ODM_CCK_PD_THRESH 0xa0a
+#define ODM_CCK_RF_REG1 0xa11
+#define ODM_CCK_MATCH_FILTER 0xa20
+#define ODM_CCK_RAKE_MAC 0xa2e
+#define ODM_CCK_CNT_RESET 0xa2d
+#define ODM_CCK_TX_DIVERSITY 0xa2f
+#define ODM_CCK_FA_CNT_MSB 0xa5b
+#define ODM_CCK_FA_CNT_LSB 0xa5c
+#define ODM_CCK_NEW_FUNCTION 0xa75
+#define ODM_OFDM_PHY0_PAGE_C 0xc00
+#define ODM_OFDM_RX_ANT 0xc04
+#define ODM_R_A_RXIQI 0xc14
+#define ODM_R_A_AGC_CORE1 0xc50
+#define ODM_R_A_AGC_CORE2 0xc54
+#define ODM_R_B_AGC_CORE1 0xc58
+#define ODM_R_AGC_PAR 0xc70
+#define ODM_R_HTSTF_AGC_PAR 0xc7c
+#define ODM_TX_PWR_TRAINING_A 0xc90
+#define ODM_TX_PWR_TRAINING_B 0xc98
+#define ODM_OFDM_FA_CNT1 0xcf0
+#define ODM_OFDM_PHY0_PAGE_D 0xd00
+#define ODM_OFDM_FA_CNT2 0xda0
+#define ODM_OFDM_FA_CNT3 0xda4
+#define ODM_OFDM_FA_CNT4 0xda8
+#define ODM_TXAGC_A_6_18 0xe00
+#define ODM_TXAGC_A_24_54 0xe04
+#define ODM_TXAGC_A_1_MCS32 0xe08
+#define ODM_TXAGC_A_MCS0_MCS3 0xe10
+#define ODM_TXAGC_A_MCS4_MCS7 0xe14
+#define ODM_TXAGC_A_MCS8_MCS11 0xe18
+#define ODM_TXAGC_A_MCS12_MCS15 0xe1c
+
+/* RF REG */
+#define ODM_GAIN_SETTING 0x00
+#define ODM_CHANNEL 0x18
+#define ODM_RF_T_METER 0x24
+#define ODM_RF_T_METER_92D 0x42
+#define ODM_RF_T_METER_88E 0x42
+#define ODM_RF_T_METER_92E 0x42
+#define ODM_RF_T_METER_8812 0x42
+#define REG_RF_TX_GAIN_OFFSET 0x55
+
+/* ant Detect Reg */
+#define ODM_DPDT 0x300
+
+/* PSD Init */
+#define ODM_PSDREG 0x808
+
+/* 92D path Div */
+#define PATHDIV_REG 0xB30
+#define PATHDIV_TRI 0xBA0
+
+/*
+ * Bitmap Definition
+ */
+
+#define BIT_FA_RESET BIT(0)
+
+#define REG_OFDM_0_XA_TX_IQ_IMBALANCE 0xC80
+#define REG_OFDM_0_ECCA_THRESHOLD 0xC4C
+#define REG_FPGA0_XB_LSSI_READ_BACK 0x8A4
+#define REG_FPGA0_TX_GAIN_STAGE 0x80C
+#define REG_OFDM_0_XA_AGC_CORE1 0xC50
+#define REG_OFDM_0_XB_AGC_CORE1 0xC58
+#define REG_A_TX_SCALE_JAGUAR 0xC1C
+#define REG_B_TX_SCALE_JAGUAR 0xE1C
+
+#define REG_AFE_XTAL_CTRL 0x0024
+#define REG_AFE_PLL_CTRL 0x0028
+#define REG_MAC_PHY_CTRL 0x002C
+
+#define RF_CHNLBW 0x18
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_regdefine11ac.h b/drivers/staging/rtlwifi/phydm/phydm_regdefine11ac.h
new file mode 100644
index 000000000000..28d48415ac99
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_regdefine11ac.h
@@ -0,0 +1,94 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __ODM_REGDEFINE11AC_H__
+#define __ODM_REGDEFINE11AC_H__
+
+/* 2 RF REG LIST */
+
+/* 2 BB REG LIST */
+/* PAGE 8 */
+#define ODM_REG_CCK_RPT_FORMAT_11AC 0x804
+#define ODM_REG_BB_RX_PATH_11AC 0x808
+#define ODM_REG_BB_TX_PATH_11AC 0x80c
+#define ODM_REG_BB_ATC_11AC 0x860
+#define ODM_REG_EDCCA_POWER_CAL 0x8dc
+#define ODM_REG_DBG_RPT_11AC 0x8fc
+/* PAGE 9 */
+#define ODM_REG_EDCCA_DOWN_OPT 0x900
+#define ODM_REG_ACBB_EDCCA_ENHANCE 0x944
+#define odm_adc_trigger_jaguar2 0x95C /*ADC sample mode*/
+#define ODM_REG_OFDM_FA_RST_11AC 0x9A4
+#define ODM_REG_CCX_PERIOD_11AC 0x990
+#define ODM_REG_NHM_TH9_TH10_11AC 0x994
+#define ODM_REG_CLM_11AC 0x994
+#define ODM_REG_NHM_TH3_TO_TH0_11AC 0x998
+#define ODM_REG_NHM_TH7_TO_TH4_11AC 0x99c
+#define ODM_REG_NHM_TH8_11AC 0x9a0
+#define ODM_REG_NHM_9E8_11AC 0x9e8
+#define ODM_REG_CSI_CONTENT_VALUE 0x9b4
+/* PAGE A */
+#define ODM_REG_CCK_CCA_11AC 0xA0A
+#define ODM_REG_CCK_FA_RST_11AC 0xA2C
+#define ODM_REG_CCK_FA_11AC 0xA5C
+/* PAGE B */
+#define ODM_REG_RST_RPT_11AC 0xB58
+/* PAGE C */
+#define ODM_REG_TRMUX_11AC 0xC08
+#define ODM_REG_IGI_A_11AC 0xC50
+/* PAGE E */
+#define ODM_REG_IGI_B_11AC 0xE50
+#define ODM_REG_TRMUX_11AC_B 0xE08
+/* PAGE F */
+#define ODM_REG_CCK_CRC32_CNT_11AC 0xF04
+#define ODM_REG_CCK_CCA_CNT_11AC 0xF08
+#define ODM_REG_VHT_CRC32_CNT_11AC 0xF0c
+#define ODM_REG_HT_CRC32_CNT_11AC 0xF10
+#define ODM_REG_OFDM_CRC32_CNT_11AC 0xF14
+#define ODM_REG_OFDM_FA_11AC 0xF48
+#define ODM_REG_RPT_11AC 0xfa0
+#define ODM_REG_CLM_RESULT_11AC 0xfa4
+#define ODM_REG_NHM_CNT_11AC 0xfa8
+#define ODM_REG_NHM_DUR_READY_11AC 0xfb4
+
+#define ODM_REG_NHM_CNT7_TO_CNT4_11AC 0xfac
+#define ODM_REG_NHM_CNT11_TO_CNT8_11AC 0xfb0
+#define ODM_REG_OFDM_FA_TYPE2_11AC 0xFD0
+/* PAGE 18 */
+#define ODM_REG_IGI_C_11AC 0x1850
+/* PAGE 1A */
+#define ODM_REG_IGI_D_11AC 0x1A50
+
+/* 2 MAC REG LIST */
+#define ODM_REG_RESP_TX_11AC 0x6D8
+
+/* DIG Related */
+#define ODM_BIT_IGI_11AC 0xFFFFFFFF
+#define ODM_BIT_CCK_RPT_FORMAT_11AC BIT(16)
+#define ODM_BIT_BB_RX_PATH_11AC 0xF
+#define ODM_BIT_BB_TX_PATH_11AC 0xF
+#define ODM_BIT_BB_ATC_11AC BIT(14)
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_regdefine11n.h b/drivers/staging/rtlwifi/phydm/phydm_regdefine11n.h
new file mode 100644
index 000000000000..0b6581c50ab3
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_regdefine11n.h
@@ -0,0 +1,213 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __ODM_REGDEFINE11N_H__
+#define __ODM_REGDEFINE11N_H__
+
+/* 2 RF REG LIST */
+#define ODM_REG_RF_MODE_11N 0x00
+#define ODM_REG_RF_0B_11N 0x0B
+#define ODM_REG_CHNBW_11N 0x18
+#define ODM_REG_T_METER_11N 0x24
+#define ODM_REG_RF_25_11N 0x25
+#define ODM_REG_RF_26_11N 0x26
+#define ODM_REG_RF_27_11N 0x27
+#define ODM_REG_RF_2B_11N 0x2B
+#define ODM_REG_RF_2C_11N 0x2C
+#define ODM_REG_RXRF_A3_11N 0x3C
+#define ODM_REG_T_METER_92D_11N 0x42
+#define ODM_REG_T_METER_88E_11N 0x42
+
+/* 2 BB REG LIST */
+/* PAGE 8 */
+#define ODM_REG_BB_CTRL_11N 0x800
+#define ODM_REG_RF_PIN_11N 0x804
+#define ODM_REG_PSD_CTRL_11N 0x808
+#define ODM_REG_TX_ANT_CTRL_11N 0x80C
+#define ODM_REG_BB_PWR_SAV5_11N 0x818
+#define ODM_REG_CCK_RPT_FORMAT_11N 0x824
+#define ODM_REG_CCK_RPT_FORMAT_11N_B 0x82C
+#define ODM_REG_RX_DEFAULT_A_11N 0x858
+#define ODM_REG_RX_DEFAULT_B_11N 0x85A
+#define ODM_REG_BB_PWR_SAV3_11N 0x85C
+#define ODM_REG_ANTSEL_CTRL_11N 0x860
+#define ODM_REG_RX_ANT_CTRL_11N 0x864
+#define ODM_REG_PIN_CTRL_11N 0x870
+#define ODM_REG_BB_PWR_SAV1_11N 0x874
+#define ODM_REG_ANTSEL_PATH_11N 0x878
+#define ODM_REG_BB_3WIRE_11N 0x88C
+#define ODM_REG_SC_CNT_11N 0x8C4
+#define ODM_REG_PSD_DATA_11N 0x8B4
+#define ODM_REG_CCX_PERIOD_11N 0x894
+#define ODM_REG_NHM_TH9_TH10_11N 0x890
+#define ODM_REG_CLM_11N 0x890
+#define ODM_REG_NHM_TH3_TO_TH0_11N 0x898
+#define ODM_REG_NHM_TH7_TO_TH4_11N 0x89c
+#define ODM_REG_NHM_TH8_11N 0xe28
+#define ODM_REG_CLM_READY_11N 0x8b4
+#define ODM_REG_CLM_RESULT_11N 0x8d0
+#define ODM_REG_NHM_CNT_11N 0x8d8
+
+/* For struct acs_info, Jeffery, 2014-12-26 */
+#define ODM_REG_NHM_CNT7_TO_CNT4_11N 0x8dc
+#define ODM_REG_NHM_CNT9_TO_CNT8_11N 0x8d0
+#define ODM_REG_NHM_CNT10_TO_CNT11_11N 0x8d4
+
+/* PAGE 9 */
+#define ODM_REG_BB_CTRL_PAGE9_11N 0x900
+#define ODM_REG_DBG_RPT_11N 0x908
+#define ODM_REG_BB_TX_PATH_11N 0x90c
+#define ODM_REG_ANT_MAPPING1_11N 0x914
+#define ODM_REG_ANT_MAPPING2_11N 0x918
+#define ODM_REG_EDCCA_DOWN_OPT_11N 0x948
+#define ODM_REG_RX_DFIR_MOD_97F 0x948
+
+/* PAGE A */
+#define ODM_REG_CCK_ANTDIV_PARA1_11N 0xA00
+#define ODM_REG_CCK_ANT_SEL_11N 0xA04
+#define ODM_REG_CCK_CCA_11N 0xA0A
+#define ODM_REG_CCK_ANTDIV_PARA2_11N 0xA0C
+#define ODM_REG_CCK_ANTDIV_PARA3_11N 0xA10
+#define ODM_REG_CCK_ANTDIV_PARA4_11N 0xA14
+#define ODM_REG_CCK_FILTER_PARA1_11N 0xA22
+#define ODM_REG_CCK_FILTER_PARA2_11N 0xA23
+#define ODM_REG_CCK_FILTER_PARA3_11N 0xA24
+#define ODM_REG_CCK_FILTER_PARA4_11N 0xA25
+#define ODM_REG_CCK_FILTER_PARA5_11N 0xA26
+#define ODM_REG_CCK_FILTER_PARA6_11N 0xA27
+#define ODM_REG_CCK_FILTER_PARA7_11N 0xA28
+#define ODM_REG_CCK_FILTER_PARA8_11N 0xA29
+#define ODM_REG_CCK_FA_RST_11N 0xA2C
+#define ODM_REG_CCK_FA_MSB_11N 0xA58
+#define ODM_REG_CCK_FA_LSB_11N 0xA5C
+#define ODM_REG_CCK_CCA_CNT_11N 0xA60
+#define ODM_REG_BB_PWR_SAV4_11N 0xA74
+/* PAGE B */
+#define ODM_REG_LNA_SWITCH_11N 0xB2C
+#define ODM_REG_PATH_SWITCH_11N 0xB30
+#define ODM_REG_RSSI_CTRL_11N 0xB38
+#define ODM_REG_CONFIG_ANTA_11N 0xB68
+#define ODM_REG_RSSI_BT_11N 0xB9C
+#define ODM_REG_RXCK_RFMOD 0xBB0
+#define ODM_REG_EDCCA_DCNF_97F 0xBC0
+
+/* PAGE C */
+#define ODM_REG_OFDM_FA_HOLDC_11N 0xC00
+#define ODM_REG_BB_RX_PATH_11N 0xC04
+#define ODM_REG_TRMUX_11N 0xC08
+#define ODM_REG_OFDM_FA_RSTC_11N 0xC0C
+#define ODM_REG_DOWNSAM_FACTOR_11N 0xC10
+#define ODM_REG_RXIQI_MATRIX_11N 0xC14
+#define ODM_REG_TXIQK_MATRIX_LSB1_11N 0xC4C
+#define ODM_REG_IGI_A_11N 0xC50
+#define ODM_REG_ANTDIV_PARA2_11N 0xC54
+#define ODM_REG_IGI_B_11N 0xC58
+#define ODM_REG_ANTDIV_PARA3_11N 0xC5C
+#define ODM_REG_L1SBD_PD_CH_11N 0XC6C
+#define ODM_REG_BB_PWR_SAV2_11N 0xC70
+#define ODM_REG_BB_AGC_SET_2_11N 0xc74
+#define ODM_REG_RX_OFF_11N 0xC7C
+#define ODM_REG_TXIQK_MATRIXA_11N 0xC80
+#define ODM_REG_TXIQK_MATRIXB_11N 0xC88
+#define ODM_REG_TXIQK_MATRIXA_LSB2_11N 0xC94
+#define ODM_REG_TXIQK_MATRIXB_LSB2_11N 0xC9C
+#define ODM_REG_RXIQK_MATRIX_LSB_11N 0xCA0
+#define ODM_REG_ANTDIV_PARA1_11N 0xCA4
+#define ODM_REG_SMALL_BANDWIDTH_11N 0xCE4
+#define ODM_REG_OFDM_FA_TYPE1_11N 0xCF0
+/* PAGE D */
+#define ODM_REG_OFDM_FA_RSTD_11N 0xD00
+#define ODM_REG_BB_RX_ANT_11N 0xD04
+#define ODM_REG_BB_ATC_11N 0xD2C
+#define ODM_REG_OFDM_FA_TYPE2_11N 0xDA0
+#define ODM_REG_OFDM_FA_TYPE3_11N 0xDA4
+#define ODM_REG_OFDM_FA_TYPE4_11N 0xDA8
+#define ODM_REG_RPT_11N 0xDF4
+/* PAGE E */
+#define ODM_REG_TXAGC_A_6_18_11N 0xE00
+#define ODM_REG_TXAGC_A_24_54_11N 0xE04
+#define ODM_REG_TXAGC_A_1_MCS32_11N 0xE08
+#define ODM_REG_TXAGC_A_MCS0_3_11N 0xE10
+#define ODM_REG_TXAGC_A_MCS4_7_11N 0xE14
+#define ODM_REG_TXAGC_A_MCS8_11_11N 0xE18
+#define ODM_REG_TXAGC_A_MCS12_15_11N 0xE1C
+#define ODM_REG_EDCCA_DCNF_11N 0xE24
+#define ODM_REG_TAP_UPD_97F 0xE24
+#define ODM_REG_FPGA0_IQK_11N 0xE28
+#define ODM_REG_PAGE_B1_97F 0xE28
+#define ODM_REG_TXIQK_TONE_A_11N 0xE30
+#define ODM_REG_RXIQK_TONE_A_11N 0xE34
+#define ODM_REG_TXIQK_PI_A_11N 0xE38
+#define ODM_REG_RXIQK_PI_A_11N 0xE3C
+#define ODM_REG_TXIQK_11N 0xE40
+#define ODM_REG_RXIQK_11N 0xE44
+#define ODM_REG_IQK_AGC_PTS_11N 0xE48
+#define ODM_REG_IQK_AGC_RSP_11N 0xE4C
+#define ODM_REG_BLUETOOTH_11N 0xE6C
+#define ODM_REG_RX_WAIT_CCA_11N 0xE70
+#define ODM_REG_TX_CCK_RFON_11N 0xE74
+#define ODM_REG_TX_CCK_BBON_11N 0xE78
+#define ODM_REG_OFDM_RFON_11N 0xE7C
+#define ODM_REG_OFDM_BBON_11N 0xE80
+#define ODM_REG_TX2RX_11N 0xE84
+#define ODM_REG_TX2TX_11N 0xE88
+#define ODM_REG_RX_CCK_11N 0xE8C
+#define ODM_REG_RX_OFDM_11N 0xED0
+#define ODM_REG_RX_WAIT_RIFS_11N 0xED4
+#define ODM_REG_RX2RX_11N 0xED8
+#define ODM_REG_STANDBY_11N 0xEDC
+#define ODM_REG_SLEEP_11N 0xEE0
+#define ODM_REG_PMPD_ANAEN_11N 0xEEC
+/* PAGE F */
+#define ODM_REG_PAGE_F_RST_11N 0xF14
+#define ODM_REG_IGI_C_11N 0xF84
+#define ODM_REG_IGI_D_11N 0xF88
+#define ODM_REG_CCK_CRC32_ERROR_CNT_11N 0xF84
+#define ODM_REG_CCK_CRC32_OK_CNT_11N 0xF88
+#define ODM_REG_HT_CRC32_CNT_11N 0xF90
+#define ODM_REG_OFDM_CRC32_CNT_11N 0xF94
+
+/* 2 MAC REG LIST */
+#define ODM_REG_BB_RST_11N 0x02
+#define ODM_REG_ANTSEL_PIN_11N 0x4C
+#define ODM_REG_EARLY_MODE_11N 0x4D0
+#define ODM_REG_RSSI_MONITOR_11N 0x4FE
+#define ODM_REG_EDCA_VO_11N 0x500
+#define ODM_REG_EDCA_VI_11N 0x504
+#define ODM_REG_EDCA_BE_11N 0x508
+#define ODM_REG_EDCA_BK_11N 0x50C
+#define ODM_REG_TXPAUSE_11N 0x522
+#define ODM_REG_RESP_TX_11N 0x6D8
+#define ODM_REG_ANT_TRAIN_PARA1_11N 0x7b0
+#define ODM_REG_ANT_TRAIN_PARA2_11N 0x7b4
+
+/* DIG Related */
+#define ODM_BIT_IGI_11N 0x0000007F
+#define ODM_BIT_CCK_RPT_FORMAT_11N BIT(9)
+#define ODM_BIT_BB_RX_PATH_11N 0xF
+#define ODM_BIT_BB_TX_PATH_11N 0xF
+#define ODM_BIT_BB_ATC_11N BIT(11)
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/phydm_types.h b/drivers/staging/rtlwifi/phydm/phydm_types.h
new file mode 100644
index 000000000000..a34ebe876528
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/phydm_types.h
@@ -0,0 +1,130 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __ODM_TYPES_H__
+#define __ODM_TYPES_H__
+
+/*Define Different SW team support*/
+#define ODM_AP 0x01 /*BIT0*/
+#define ODM_CE 0x04 /*BIT2*/
+#define ODM_WIN 0x08 /*BIT3*/
+#define ODM_ADSL 0x10 /*BIT4*/
+#define ODM_IOT 0x20 /*BIT5*/
+
+/*Deifne HW endian support*/
+#define ODM_ENDIAN_BIG 0
+#define ODM_ENDIAN_LITTLE 1
+
+#define GET_PDM_ODM(__padapter)                                                \
+	((struct phy_dm_struct *)(&(GET_HAL_DATA(__padapter))->odmpriv))
+
+enum hal_status {
+	HAL_STATUS_SUCCESS,
+	HAL_STATUS_FAILURE,
+};
+
+/*
+ * Declare for ODM spin lock definition temporarily fro compile pass.
+ */
+enum rt_spinlock_type {
+	RT_TX_SPINLOCK = 1,
+	RT_RX_SPINLOCK = 2,
+	RT_RM_SPINLOCK = 3,
+	RT_CAM_SPINLOCK = 4,
+	RT_SCAN_SPINLOCK = 5,
+	RT_LOG_SPINLOCK = 7,
+	RT_BW_SPINLOCK = 8,
+	RT_CHNLOP_SPINLOCK = 9,
+	RT_RF_OPERATE_SPINLOCK = 10,
+	RT_INITIAL_SPINLOCK = 11,
+	RT_RF_STATE_SPINLOCK =
+		12, /* For RF state. Added by Bruce, 2007-10-30. */
+	/* Shall we define Ndis 6.2 SpinLock Here ? */
+	RT_PORT_SPINLOCK = 16,
+	RT_VNIC_SPINLOCK = 17,
+	RT_HVL_SPINLOCK = 18,
+	RT_H2C_SPINLOCK = 20, /* For H2C cmd. Added by tynli. 2009.11.09. */
+
+	rt_bt_data_spinlock = 25,
+
+	RT_WAPI_OPTION_SPINLOCK = 26,
+	RT_WAPI_RX_SPINLOCK = 27,
+
+	/* add for 92D CCK control issue */
+	RT_CCK_PAGEA_SPINLOCK = 28,
+	RT_BUFFER_SPINLOCK = 29,
+	RT_CHANNEL_AND_BANDWIDTH_SPINLOCK = 30,
+	RT_GEN_TEMP_BUF_SPINLOCK = 31,
+	RT_AWB_SPINLOCK = 32,
+	RT_FW_PS_SPINLOCK = 33,
+	RT_HW_TIMER_SPIN_LOCK = 34,
+	RT_MPT_WI_SPINLOCK = 35,
+	RT_P2P_SPIN_LOCK = 36, /* Protect P2P context */
+	RT_DBG_SPIN_LOCK = 37,
+	RT_IQK_SPINLOCK = 38,
+	RT_PENDED_OID_SPINLOCK = 39,
+	RT_CHNLLIST_SPINLOCK = 40,
+	RT_INDIC_SPINLOCK = 41, /* protect indication */
+	RT_RFD_SPINLOCK = 42,
+	RT_SYNC_IO_CNT_SPINLOCK = 43,
+	RT_LAST_SPINLOCK,
+};
+
+#include <asm/byteorder.h>
+
+#if defined(__LITTLE_ENDIAN)
+#define ODM_ENDIAN_TYPE ODM_ENDIAN_LITTLE
+#elif defined(__BIG_ENDIAN)
+#define ODM_ENDIAN_TYPE ODM_ENDIAN_BIG
+#else
+#error
+#endif
+
+#define COND_ELSE 2
+#define COND_ENDIF 3
+
+#define MASKBYTE0 0xff
+#define MASKBYTE1 0xff00
+#define MASKBYTE2 0xff0000
+#define MASKBYTE3 0xff000000
+#define MASKHWORD 0xffff0000
+#define MASKLWORD 0x0000ffff
+#define MASKDWORD 0xffffffff
+#define MASK7BITS 0x7f
+#define MASK12BITS 0xfff
+#define MASKH4BITS 0xf0000000
+#define MASK20BITS 0xfffff
+#define MASKOFDM_D 0xffc00000
+#define MASKCCK 0x3f3f3f3f
+#define RFREGOFFSETMASK 0xfffff
+#define MASKH3BYTES 0xffffff00
+#define MASKL3BYTES 0x00ffffff
+#define MASKBYTE2HIGHNIBBLE 0x00f00000
+#define MASKBYTE3LOWNIBBLE 0x0f000000
+#define MASKL3BYTES 0x00ffffff
+#define RFREGOFFSETMASK 0xfffff
+
+#include "phydm_features.h"
+
+#endif /* __ODM_TYPES_H__ */
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_bb.c b/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_bb.c
new file mode 100644
index 000000000000..4e7946019fcb
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_bb.c
@@ -0,0 +1,1969 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/*Image2HeaderVersion: 3.2*/
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
+
+static bool check_positive(struct phy_dm_struct *dm, const u32 condition1,
+			   const u32 condition2, const u32 condition3,
+			   const u32 condition4)
+{
+	u8 _board_type = ((dm->board_type & BIT(4)) >> 4) << 0 | /* _GLNA*/
+			 ((dm->board_type & BIT(3)) >> 3) << 1 | /* _GPA*/
+			 ((dm->board_type & BIT(7)) >> 7) << 2 | /* _ALNA*/
+			 ((dm->board_type & BIT(6)) >> 6) << 3 | /* _APA */
+			 ((dm->board_type & BIT(2)) >> 2) << 4; /* _BT*/
+
+	u32 cond1 = condition1, cond2 = condition2, cond3 = condition3,
+	    cond4 = condition4;
+
+	u8 cut_version_for_para =
+		(dm->cut_version == ODM_CUT_A) ? 14 : dm->cut_version;
+	u8 pkg_type_for_para = (dm->package_type == 0) ? 14 : dm->package_type;
+
+	u32 driver1 = cut_version_for_para << 24 |
+		      (dm->support_interface & 0xF0) << 16 |
+		      dm->support_platform << 16 | pkg_type_for_para << 12 |
+		      (dm->support_interface & 0x0F) << 8 | _board_type;
+
+	u32 driver2 = (dm->type_glna & 0xFF) << 0 | (dm->type_gpa & 0xFF) << 8 |
+		      (dm->type_alna & 0xFF) << 16 |
+		      (dm->type_apa & 0xFF) << 24;
+
+	u32 driver3 = 0;
+
+	u32 driver4 = (dm->type_glna & 0xFF00) >> 8 | (dm->type_gpa & 0xFF00) |
+		      (dm->type_alna & 0xFF00) << 8 |
+		      (dm->type_apa & 0xFF00) << 16;
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_INIT,
+		"===> %s (cond1, cond2, cond3, cond4) = (0x%X 0x%X 0x%X 0x%X)\n",
+		__func__, cond1, cond2, cond3, cond4);
+	ODM_RT_TRACE(
+		dm, ODM_COMP_INIT,
+		"===> %s (driver1, driver2, driver3, driver4) = (0x%X 0x%X 0x%X 0x%X)\n",
+		__func__, driver1, driver2, driver3, driver4);
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "	(Platform, Interface) = (0x%X, 0x%X)\n",
+		     dm->support_platform, dm->support_interface);
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "	(Board, Package) = (0x%X, 0x%X)\n",
+		     dm->board_type, dm->package_type);
+
+	/*============== value Defined Check ===============*/
+	/*QFN type [15:12] and cut version [27:24] need to do value check*/
+
+	if (((cond1 & 0x0000F000) != 0) &&
+	    ((cond1 & 0x0000F000) != (driver1 & 0x0000F000)))
+		return false;
+	if (((cond1 & 0x0F000000) != 0) &&
+	    ((cond1 & 0x0F000000) != (driver1 & 0x0F000000)))
+		return false;
+
+	/*=============== Bit Defined Check ================*/
+	/* We don't care [31:28] */
+
+	cond1 &= 0x00FF0FFF;
+	driver1 &= 0x00FF0FFF;
+
+	if ((cond1 & driver1) == cond1) {
+		u32 bit_mask = 0;
+
+		if ((cond1 & 0x0F) == 0) /* board_type is DONTCARE*/
+			return true;
+
+		if ((cond1 & BIT(0)) != 0) /*GLNA*/
+			bit_mask |= 0x000000FF;
+		if ((cond1 & BIT(1)) != 0) /*GPA*/
+			bit_mask |= 0x0000FF00;
+		if ((cond1 & BIT(2)) != 0) /*ALNA*/
+			bit_mask |= 0x00FF0000;
+		if ((cond1 & BIT(3)) != 0) /*APA*/
+			bit_mask |= 0xFF000000;
+
+		if (((cond2 & bit_mask) == (driver2 & bit_mask)) &&
+		    ((cond4 & bit_mask) ==
+		     (driver4 &
+		      bit_mask))) /* board_type of each RF path is matched*/
+			return true;
+		else
+			return false;
+	} else {
+		return false;
+	}
+}
+
+/******************************************************************************
+ *                           agc_tab.TXT
+ ******************************************************************************/
+
+static u32 array_mp_8822b_agc_tab[] = {
+	0x8000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x81C,      0xFF000003,
+	0x81C,      0xF5000003, 0x81C,      0xF4020003, 0x81C,      0xF3040003,
+	0x81C,      0xF2060003, 0x81C,      0xF1080003, 0x81C,      0xF00A0003,
+	0x81C,      0xEF0C0003, 0x81C,      0xEE0E0003, 0x81C,      0xED100003,
+	0x81C,      0xEC120003, 0x81C,      0xEB140003, 0x81C,      0xEA160003,
+	0x81C,      0xE9180003, 0x81C,      0xE81A0003, 0x81C,      0xE71C0003,
+	0x81C,      0xE61E0003, 0x81C,      0xE5200003, 0x81C,      0xE4220003,
+	0x81C,      0xE3240003, 0x81C,      0xE2260003, 0x81C,      0xE1280003,
+	0x81C,      0xE02A0003, 0x81C,      0xC32C0003, 0x81C,      0xC22E0003,
+	0x81C,      0xC1300003, 0x81C,      0xC0320003, 0x81C,      0xA4340003,
+	0x81C,      0xA3360003, 0x81C,      0xA2380003, 0x81C,      0xA13A0003,
+	0x81C,      0xA03C0003, 0x81C,      0x823E0003, 0x81C,      0x81400003,
+	0x81C,      0x80420003, 0x81C,      0x64440003, 0x81C,      0x63460003,
+	0x81C,      0x62480003, 0x81C,      0x614A0003, 0x81C,      0x604C0003,
+	0x81C,      0x454E0003, 0x81C,      0x44500003, 0x81C,      0x43520003,
+	0x81C,      0x42540003, 0x81C,      0x41560003, 0x81C,      0x40580003,
+	0x81C,      0x055A0003, 0x81C,      0x045C0003, 0x81C,      0x035E0003,
+	0x81C,      0x02600003, 0x81C,      0x01620003, 0x81C,      0x00640003,
+	0x81C,      0x00660003, 0x81C,      0x00680003, 0x81C,      0x006A0003,
+	0x81C,      0x006C0003, 0x81C,      0x006E0003, 0x81C,      0x00700003,
+	0x81C,      0x00720003, 0x81C,      0x00740003, 0x81C,      0x00760003,
+	0x81C,      0x00780003, 0x81C,      0x007A0003, 0x81C,      0x007C0003,
+	0x81C,      0x007E0003, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x81C,      0xFF000003, 0x81C,      0xF5000003, 0x81C,      0xF4020003,
+	0x81C,      0xF3040003, 0x81C,      0xF2060003, 0x81C,      0xF1080003,
+	0x81C,      0xF00A0003, 0x81C,      0xEF0C0003, 0x81C,      0xEE0E0003,
+	0x81C,      0xED100003, 0x81C,      0xEC120003, 0x81C,      0xEB140003,
+	0x81C,      0xEA160003, 0x81C,      0xE9180003, 0x81C,      0xE81A0003,
+	0x81C,      0xE71C0003, 0x81C,      0xE61E0003, 0x81C,      0xE5200003,
+	0x81C,      0xE4220003, 0x81C,      0xE3240003, 0x81C,      0xE2260003,
+	0x81C,      0xE1280003, 0x81C,      0xE02A0003, 0x81C,      0xC32C0003,
+	0x81C,      0xC22E0003, 0x81C,      0xC1300003, 0x81C,      0xC0320003,
+	0x81C,      0xA4340003, 0x81C,      0xA3360003, 0x81C,      0xA2380003,
+	0x81C,      0xA13A0003, 0x81C,      0xA03C0003, 0x81C,      0x823E0003,
+	0x81C,      0x81400003, 0x81C,      0x80420003, 0x81C,      0x64440003,
+	0x81C,      0x63460003, 0x81C,      0x62480003, 0x81C,      0x614A0003,
+	0x81C,      0x604C0003, 0x81C,      0x454E0003, 0x81C,      0x44500003,
+	0x81C,      0x43520003, 0x81C,      0x42540003, 0x81C,      0x41560003,
+	0x81C,      0x40580003, 0x81C,      0x055A0003, 0x81C,      0x045C0003,
+	0x81C,      0x035E0003, 0x81C,      0x02600003, 0x81C,      0x01620003,
+	0x81C,      0x00640003, 0x81C,      0x00660003, 0x81C,      0x00680003,
+	0x81C,      0x006A0003, 0x81C,      0x006C0003, 0x81C,      0x006E0003,
+	0x81C,      0x00700003, 0x81C,      0x00720003, 0x81C,      0x00740003,
+	0x81C,      0x00760003, 0x81C,      0x00780003, 0x81C,      0x007A0003,
+	0x81C,      0x007C0003, 0x81C,      0x007E0003, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFF000003, 0x81C,      0xF5000003,
+	0x81C,      0xF4020003, 0x81C,      0xF3040003, 0x81C,      0xF2060003,
+	0x81C,      0xF1080003, 0x81C,      0xF00A0003, 0x81C,      0xEF0C0003,
+	0x81C,      0xEE0E0003, 0x81C,      0xED100003, 0x81C,      0xEC120003,
+	0x81C,      0xEB140003, 0x81C,      0xEA160003, 0x81C,      0xE9180003,
+	0x81C,      0xE81A0003, 0x81C,      0xE71C0003, 0x81C,      0xE61E0003,
+	0x81C,      0xE5200003, 0x81C,      0xE4220003, 0x81C,      0xE3240003,
+	0x81C,      0xE2260003, 0x81C,      0xE1280003, 0x81C,      0xE02A0003,
+	0x81C,      0xC32C0003, 0x81C,      0xC22E0003, 0x81C,      0xC1300003,
+	0x81C,      0xC0320003, 0x81C,      0xA4340003, 0x81C,      0xA3360003,
+	0x81C,      0xA2380003, 0x81C,      0xA13A0003, 0x81C,      0xA03C0003,
+	0x81C,      0x823E0003, 0x81C,      0x81400003, 0x81C,      0x80420003,
+	0x81C,      0x64440003, 0x81C,      0x63460003, 0x81C,      0x62480003,
+	0x81C,      0x614A0003, 0x81C,      0x604C0003, 0x81C,      0x454E0003,
+	0x81C,      0x44500003, 0x81C,      0x43520003, 0x81C,      0x42540003,
+	0x81C,      0x41560003, 0x81C,      0x40580003, 0x81C,      0x055A0003,
+	0x81C,      0x045C0003, 0x81C,      0x035E0003, 0x81C,      0x02600003,
+	0x81C,      0x01620003, 0x81C,      0x00640003, 0x81C,      0x00660003,
+	0x81C,      0x00680003, 0x81C,      0x006A0003, 0x81C,      0x006C0003,
+	0x81C,      0x006E0003, 0x81C,      0x00700003, 0x81C,      0x00720003,
+	0x81C,      0x00740003, 0x81C,      0x00760003, 0x81C,      0x00780003,
+	0x81C,      0x007A0003, 0x81C,      0x007C0003, 0x81C,      0x007E0003,
+	0x9000200f, 0x00000000, 0x40000000, 0x00000000, 0x81C,      0xFF000003,
+	0x81C,      0xF5000003, 0x81C,      0xF4020003, 0x81C,      0xF3040003,
+	0x81C,      0xF2060003, 0x81C,      0xF1080003, 0x81C,      0xF00A0003,
+	0x81C,      0xEF0C0003, 0x81C,      0xEE0E0003, 0x81C,      0xED100003,
+	0x81C,      0xEC120003, 0x81C,      0xEB140003, 0x81C,      0xEA160003,
+	0x81C,      0xE9180003, 0x81C,      0xE81A0003, 0x81C,      0xE71C0003,
+	0x81C,      0xE61E0003, 0x81C,      0xE5200003, 0x81C,      0xE4220003,
+	0x81C,      0xE3240003, 0x81C,      0xE2260003, 0x81C,      0xE1280003,
+	0x81C,      0xE02A0003, 0x81C,      0xC32C0003, 0x81C,      0xC22E0003,
+	0x81C,      0xC1300003, 0x81C,      0xC0320003, 0x81C,      0xA4340003,
+	0x81C,      0xA3360003, 0x81C,      0xA2380003, 0x81C,      0xA13A0003,
+	0x81C,      0xA03C0003, 0x81C,      0x823E0003, 0x81C,      0x81400003,
+	0x81C,      0x80420003, 0x81C,      0x64440003, 0x81C,      0x63460003,
+	0x81C,      0x62480003, 0x81C,      0x614A0003, 0x81C,      0x604C0003,
+	0x81C,      0x454E0003, 0x81C,      0x44500003, 0x81C,      0x43520003,
+	0x81C,      0x42540003, 0x81C,      0x41560003, 0x81C,      0x40580003,
+	0x81C,      0x055A0003, 0x81C,      0x045C0003, 0x81C,      0x035E0003,
+	0x81C,      0x02600003, 0x81C,      0x01620003, 0x81C,      0x00640003,
+	0x81C,      0x00660003, 0x81C,      0x00680003, 0x81C,      0x006A0003,
+	0x81C,      0x006C0003, 0x81C,      0x006E0003, 0x81C,      0x00700003,
+	0x81C,      0x00720003, 0x81C,      0x00740003, 0x81C,      0x00760003,
+	0x81C,      0x00780003, 0x81C,      0x007A0003, 0x81C,      0x007C0003,
+	0x81C,      0x007E0003, 0x9000200c, 0x00000000, 0x40000000, 0x00000000,
+	0x81C,      0xFF000003, 0x81C,      0xFD000003, 0x81C,      0xFC020003,
+	0x81C,      0xFB040003, 0x81C,      0xFA060003, 0x81C,      0xF9080003,
+	0x81C,      0xF80A0003, 0x81C,      0xF70C0003, 0x81C,      0xF60E0003,
+	0x81C,      0xF5100003, 0x81C,      0xF4120003, 0x81C,      0xF3140003,
+	0x81C,      0xF2160003, 0x81C,      0xF1180003, 0x81C,      0xF01A0003,
+	0x81C,      0xEF1C0003, 0x81C,      0xEE1E0003, 0x81C,      0xED200003,
+	0x81C,      0xEC220003, 0x81C,      0xEB240003, 0x81C,      0xEA260003,
+	0x81C,      0xE9280003, 0x81C,      0xE82A0003, 0x81C,      0xE72C0003,
+	0x81C,      0xE62E0003, 0x81C,      0xE5300003, 0x81C,      0xC8320003,
+	0x81C,      0xC7340003, 0x81C,      0xC6360003, 0x81C,      0xC5380003,
+	0x81C,      0xC43A0003, 0x81C,      0xC33C0003, 0x81C,      0xC23E0003,
+	0x81C,      0xC1400003, 0x81C,      0xC0420003, 0x81C,      0xA5440003,
+	0x81C,      0xA4460003, 0x81C,      0xA3480003, 0x81C,      0xA24A0003,
+	0x81C,      0xA14C0003, 0x81C,      0x834E0003, 0x81C,      0x82500003,
+	0x81C,      0x81520003, 0x81C,      0x80540003, 0x81C,      0x65560003,
+	0x81C,      0x64580003, 0x81C,      0x635A0003, 0x81C,      0x625C0003,
+	0x81C,      0x435E0003, 0x81C,      0x42600003, 0x81C,      0x41620003,
+	0x81C,      0x40640003, 0x81C,      0x06660003, 0x81C,      0x05680003,
+	0x81C,      0x046A0003, 0x81C,      0x036C0003, 0x81C,      0x026E0003,
+	0x81C,      0x01700003, 0x81C,      0x00720003, 0x81C,      0x00740003,
+	0x81C,      0x00760003, 0x81C,      0x00780003, 0x81C,      0x007A0003,
+	0x81C,      0x007C0003, 0x81C,      0x007E0003, 0x90012100, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFF000003, 0x81C,      0xFE000003,
+	0x81C,      0xFD020003, 0x81C,      0xFC040003, 0x81C,      0xFB060003,
+	0x81C,      0xFA080003, 0x81C,      0xF90A0003, 0x81C,      0xF80C0003,
+	0x81C,      0xF70E0003, 0x81C,      0xF6100003, 0x81C,      0xF5120003,
+	0x81C,      0xF4140003, 0x81C,      0xF3160003, 0x81C,      0xF2180003,
+	0x81C,      0xF11A0003, 0x81C,      0xF01C0003, 0x81C,      0xEF1E0003,
+	0x81C,      0xEE200003, 0x81C,      0xED220003, 0x81C,      0xEC240003,
+	0x81C,      0xEB260003, 0x81C,      0xEA280003, 0x81C,      0xE92A0003,
+	0x81C,      0xE82C0003, 0x81C,      0xE72E0003, 0x81C,      0xE6300003,
+	0x81C,      0xE5320003, 0x81C,      0xC8340003, 0x81C,      0xC7360003,
+	0x81C,      0xC6380003, 0x81C,      0xC53A0003, 0x81C,      0xC43C0003,
+	0x81C,      0xC33E0003, 0x81C,      0xC2400003, 0x81C,      0xC1420003,
+	0x81C,      0xC0440003, 0x81C,      0xA3460003, 0x81C,      0xA2480003,
+	0x81C,      0xA14A0003, 0x81C,      0xA04C0003, 0x81C,      0x824E0003,
+	0x81C,      0x81500003, 0x81C,      0x80520003, 0x81C,      0x64540003,
+	0x81C,      0x63560003, 0x81C,      0x62580003, 0x81C,      0x445A0003,
+	0x81C,      0x435C0003, 0x81C,      0x425E0003, 0x81C,      0x41600003,
+	0x81C,      0x40620003, 0x81C,      0x05640003, 0x81C,      0x04660003,
+	0x81C,      0x03680003, 0x81C,      0x026A0003, 0x81C,      0x016C0003,
+	0x81C,      0x006E0003, 0x81C,      0x00700003, 0x81C,      0x00720003,
+	0x81C,      0x00740003, 0x81C,      0x00760003, 0x81C,      0x00780003,
+	0x81C,      0x007A0003, 0x81C,      0x007C0003, 0x81C,      0x007E0003,
+	0x90001004, 0x00000000, 0x40000000, 0x00000000, 0x81C,      0xFF000003,
+	0x81C,      0xF5000003, 0x81C,      0xF4020003, 0x81C,      0xF3040003,
+	0x81C,      0xF2060003, 0x81C,      0xF1080003, 0x81C,      0xF00A0003,
+	0x81C,      0xEF0C0003, 0x81C,      0xEE0E0003, 0x81C,      0xED100003,
+	0x81C,      0xEC120003, 0x81C,      0xEB140003, 0x81C,      0xEA160003,
+	0x81C,      0xE9180003, 0x81C,      0xE81A0003, 0x81C,      0xE71C0003,
+	0x81C,      0xE61E0003, 0x81C,      0xE5200003, 0x81C,      0xE4220003,
+	0x81C,      0xE3240003, 0x81C,      0xE2260003, 0x81C,      0xE1280003,
+	0x81C,      0xE02A0003, 0x81C,      0xC32C0003, 0x81C,      0xC22E0003,
+	0x81C,      0xC1300003, 0x81C,      0xC0320003, 0x81C,      0xA4340003,
+	0x81C,      0xA3360003, 0x81C,      0xA2380003, 0x81C,      0xA13A0003,
+	0x81C,      0xA03C0003, 0x81C,      0x823E0003, 0x81C,      0x81400003,
+	0x81C,      0x80420003, 0x81C,      0x64440003, 0x81C,      0x63460003,
+	0x81C,      0x62480003, 0x81C,      0x614A0003, 0x81C,      0x604C0003,
+	0x81C,      0x454E0003, 0x81C,      0x44500003, 0x81C,      0x43520003,
+	0x81C,      0x42540003, 0x81C,      0x41560003, 0x81C,      0x40580003,
+	0x81C,      0x055A0003, 0x81C,      0x045C0003, 0x81C,      0x035E0003,
+	0x81C,      0x02600003, 0x81C,      0x01620003, 0x81C,      0x00640003,
+	0x81C,      0x00660003, 0x81C,      0x00680003, 0x81C,      0x006A0003,
+	0x81C,      0x006C0003, 0x81C,      0x006E0003, 0x81C,      0x00700003,
+	0x81C,      0x00720003, 0x81C,      0x00740003, 0x81C,      0x00760003,
+	0x81C,      0x00780003, 0x81C,      0x007A0003, 0x81C,      0x007C0003,
+	0x81C,      0x007E0003, 0x90011000, 0x00000000, 0x40000000, 0x00000000,
+	0x81C,      0xFF000003, 0x81C,      0xFE000003, 0x81C,      0xFD020003,
+	0x81C,      0xFC040003, 0x81C,      0xFB060003, 0x81C,      0xFA080003,
+	0x81C,      0xF90A0003, 0x81C,      0xF80C0003, 0x81C,      0xF70E0003,
+	0x81C,      0xF6100003, 0x81C,      0xF5120003, 0x81C,      0xF4140003,
+	0x81C,      0xF3160003, 0x81C,      0xF2180003, 0x81C,      0xF11A0003,
+	0x81C,      0xF01C0003, 0x81C,      0xEF1E0003, 0x81C,      0xEE200003,
+	0x81C,      0xED220003, 0x81C,      0xEC240003, 0x81C,      0xEB260003,
+	0x81C,      0xEA280003, 0x81C,      0xE92A0003, 0x81C,      0xE82C0003,
+	0x81C,      0xE72E0003, 0x81C,      0xE6300003, 0x81C,      0xE5320003,
+	0x81C,      0xC8340003, 0x81C,      0xC7360003, 0x81C,      0xC6380003,
+	0x81C,      0xC53A0003, 0x81C,      0xC43C0003, 0x81C,      0xC33E0003,
+	0x81C,      0xC2400003, 0x81C,      0xC1420003, 0x81C,      0xC0440003,
+	0x81C,      0xA3460003, 0x81C,      0xA2480003, 0x81C,      0xA14A0003,
+	0x81C,      0xA04C0003, 0x81C,      0x824E0003, 0x81C,      0x81500003,
+	0x81C,      0x80520003, 0x81C,      0x64540003, 0x81C,      0x63560003,
+	0x81C,      0x62580003, 0x81C,      0x445A0003, 0x81C,      0x435C0003,
+	0x81C,      0x425E0003, 0x81C,      0x41600003, 0x81C,      0x40620003,
+	0x81C,      0x05640003, 0x81C,      0x04660003, 0x81C,      0x03680003,
+	0x81C,      0x026A0003, 0x81C,      0x016C0003, 0x81C,      0x006E0003,
+	0x81C,      0x00700003, 0x81C,      0x00720003, 0x81C,      0x00740003,
+	0x81C,      0x00760003, 0x81C,      0x00780003, 0x81C,      0x007A0003,
+	0x81C,      0x007C0003, 0x81C,      0x007E0003, 0x90002100, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFF000003, 0x81C,      0xFD000003,
+	0x81C,      0xFC020003, 0x81C,      0xFB040003, 0x81C,      0xFA060003,
+	0x81C,      0xF9080003, 0x81C,      0xF80A0003, 0x81C,      0xF70C0003,
+	0x81C,      0xF60E0003, 0x81C,      0xF5100003, 0x81C,      0xF4120003,
+	0x81C,      0xF3140003, 0x81C,      0xF2160003, 0x81C,      0xF1180003,
+	0x81C,      0xF01A0003, 0x81C,      0xEF1C0003, 0x81C,      0xEE1E0003,
+	0x81C,      0xED200003, 0x81C,      0xEC220003, 0x81C,      0xEB240003,
+	0x81C,      0xEA260003, 0x81C,      0xE9280003, 0x81C,      0xE82A0003,
+	0x81C,      0xE72C0003, 0x81C,      0xE62E0003, 0x81C,      0xE5300003,
+	0x81C,      0xC8320003, 0x81C,      0xC7340003, 0x81C,      0xC6360003,
+	0x81C,      0xC5380003, 0x81C,      0xC43A0003, 0x81C,      0xC33C0003,
+	0x81C,      0xC23E0003, 0x81C,      0xC1400003, 0x81C,      0xC0420003,
+	0x81C,      0xA5440003, 0x81C,      0xA4460003, 0x81C,      0xA3480003,
+	0x81C,      0xA24A0003, 0x81C,      0xA14C0003, 0x81C,      0x834E0003,
+	0x81C,      0x82500003, 0x81C,      0x81520003, 0x81C,      0x80540003,
+	0x81C,      0x65560003, 0x81C,      0x64580003, 0x81C,      0x635A0003,
+	0x81C,      0x625C0003, 0x81C,      0x435E0003, 0x81C,      0x42600003,
+	0x81C,      0x41620003, 0x81C,      0x40640003, 0x81C,      0x06660003,
+	0x81C,      0x05680003, 0x81C,      0x046A0003, 0x81C,      0x036C0003,
+	0x81C,      0x026E0003, 0x81C,      0x01700003, 0x81C,      0x00720003,
+	0x81C,      0x00740003, 0x81C,      0x00760003, 0x81C,      0x00780003,
+	0x81C,      0x007A0003, 0x81C,      0x007C0003, 0x81C,      0x007E0003,
+	0x90002000, 0x00000000, 0x40000000, 0x00000000, 0x81C,      0xFF000003,
+	0x81C,      0xFD000003, 0x81C,      0xFC020003, 0x81C,      0xFB040003,
+	0x81C,      0xFA060003, 0x81C,      0xF9080003, 0x81C,      0xF80A0003,
+	0x81C,      0xF70C0003, 0x81C,      0xF60E0003, 0x81C,      0xF5100003,
+	0x81C,      0xF4120003, 0x81C,      0xF3140003, 0x81C,      0xF2160003,
+	0x81C,      0xF1180003, 0x81C,      0xF01A0003, 0x81C,      0xEF1C0003,
+	0x81C,      0xEE1E0003, 0x81C,      0xED200003, 0x81C,      0xEC220003,
+	0x81C,      0xEB240003, 0x81C,      0xEA260003, 0x81C,      0xE9280003,
+	0x81C,      0xE82A0003, 0x81C,      0xE72C0003, 0x81C,      0xE62E0003,
+	0x81C,      0xE5300003, 0x81C,      0xC8320003, 0x81C,      0xC7340003,
+	0x81C,      0xC6360003, 0x81C,      0xC5380003, 0x81C,      0xC43A0003,
+	0x81C,      0xC33C0003, 0x81C,      0xC23E0003, 0x81C,      0xC1400003,
+	0x81C,      0xC0420003, 0x81C,      0xA5440003, 0x81C,      0xA4460003,
+	0x81C,      0xA3480003, 0x81C,      0xA24A0003, 0x81C,      0xA14C0003,
+	0x81C,      0x834E0003, 0x81C,      0x82500003, 0x81C,      0x81520003,
+	0x81C,      0x80540003, 0x81C,      0x65560003, 0x81C,      0x64580003,
+	0x81C,      0x635A0003, 0x81C,      0x625C0003, 0x81C,      0x435E0003,
+	0x81C,      0x42600003, 0x81C,      0x41620003, 0x81C,      0x40640003,
+	0x81C,      0x06660003, 0x81C,      0x05680003, 0x81C,      0x046A0003,
+	0x81C,      0x036C0003, 0x81C,      0x026E0003, 0x81C,      0x01700003,
+	0x81C,      0x00720003, 0x81C,      0x00740003, 0x81C,      0x00760003,
+	0x81C,      0x00780003, 0x81C,      0x007A0003, 0x81C,      0x007C0003,
+	0x81C,      0x007E0003, 0xA0000000, 0x00000000, 0x81C,      0xFF000003,
+	0x81C,      0xFE000003, 0x81C,      0xFD020003, 0x81C,      0xFC040003,
+	0x81C,      0xFB060003, 0x81C,      0xFA080003, 0x81C,      0xF90A0003,
+	0x81C,      0xF80C0003, 0x81C,      0xF70E0003, 0x81C,      0xF6100003,
+	0x81C,      0xF5120003, 0x81C,      0xF4140003, 0x81C,      0xF3160003,
+	0x81C,      0xF2180003, 0x81C,      0xF11A0003, 0x81C,      0xF01C0003,
+	0x81C,      0xEF1E0003, 0x81C,      0xEE200003, 0x81C,      0xED220003,
+	0x81C,      0xEC240003, 0x81C,      0xEB260003, 0x81C,      0xEA280003,
+	0x81C,      0xE92A0003, 0x81C,      0xE82C0003, 0x81C,      0xE72E0003,
+	0x81C,      0xE6300003, 0x81C,      0xE5320003, 0x81C,      0xC8340003,
+	0x81C,      0xC7360003, 0x81C,      0xC6380003, 0x81C,      0xC53A0003,
+	0x81C,      0xC43C0003, 0x81C,      0xC33E0003, 0x81C,      0xC2400003,
+	0x81C,      0xC1420003, 0x81C,      0xC0440003, 0x81C,      0xA3460003,
+	0x81C,      0xA2480003, 0x81C,      0xA14A0003, 0x81C,      0xA04C0003,
+	0x81C,      0x824E0003, 0x81C,      0x81500003, 0x81C,      0x80520003,
+	0x81C,      0x64540003, 0x81C,      0x63560003, 0x81C,      0x62580003,
+	0x81C,      0x445A0003, 0x81C,      0x435C0003, 0x81C,      0x425E0003,
+	0x81C,      0x41600003, 0x81C,      0x40620003, 0x81C,      0x05640003,
+	0x81C,      0x04660003, 0x81C,      0x03680003, 0x81C,      0x026A0003,
+	0x81C,      0x016C0003, 0x81C,      0x006E0003, 0x81C,      0x00700003,
+	0x81C,      0x00720003, 0x81C,      0x00740003, 0x81C,      0x00760003,
+	0x81C,      0x00780003, 0x81C,      0x007A0003, 0x81C,      0x007C0003,
+	0x81C,      0x007E0003, 0xB0000000, 0x00000000, 0x8000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x81C,      0xF8000103, 0x81C,      0xF7020103,
+	0x81C,      0xF6040103, 0x81C,      0xF5060103, 0x81C,      0xF4080103,
+	0x81C,      0xF30A0103, 0x81C,      0xF20C0103, 0x81C,      0xF10E0103,
+	0x81C,      0xF0100103, 0x81C,      0xEF120103, 0x81C,      0xEE140103,
+	0x81C,      0xED160103, 0x81C,      0xEC180103, 0x81C,      0xEB1A0103,
+	0x81C,      0xEA1C0103, 0x81C,      0xE91E0103, 0x81C,      0xE8200103,
+	0x81C,      0xE7220103, 0x81C,      0xE6240103, 0x81C,      0xE5260103,
+	0x81C,      0xE4280103, 0x81C,      0xE32A0103, 0x81C,      0xE22C0103,
+	0x81C,      0xC32E0103, 0x81C,      0xC2300103, 0x81C,      0xC1320103,
+	0x81C,      0xA3340103, 0x81C,      0xA2360103, 0x81C,      0xA1380103,
+	0x81C,      0xA03A0103, 0x81C,      0x823C0103, 0x81C,      0x813E0103,
+	0x81C,      0x80400103, 0x81C,      0x64420103, 0x81C,      0x63440103,
+	0x81C,      0x62460103, 0x81C,      0x61480103, 0x81C,      0x434A0103,
+	0x81C,      0x424C0103, 0x81C,      0x414E0103, 0x81C,      0x40500103,
+	0x81C,      0x22520103, 0x81C,      0x21540103, 0x81C,      0x20560103,
+	0x81C,      0x04580103, 0x81C,      0x035A0103, 0x81C,      0x025C0103,
+	0x81C,      0x015E0103, 0x81C,      0x00600103, 0x81C,      0x00620103,
+	0x81C,      0x00640103, 0x81C,      0x00660103, 0x81C,      0x00680103,
+	0x81C,      0x006A0103, 0x81C,      0x006C0103, 0x81C,      0x006E0103,
+	0x81C,      0x00700103, 0x81C,      0x00720103, 0x81C,      0x00740103,
+	0x81C,      0x00760103, 0x81C,      0x00780103, 0x81C,      0x007A0103,
+	0x81C,      0x007C0103, 0x81C,      0x007E0103, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x81C,      0xFA000103, 0x81C,      0xF9020103,
+	0x81C,      0xF8040103, 0x81C,      0xF7060103, 0x81C,      0xF6080103,
+	0x81C,      0xF50A0103, 0x81C,      0xF40C0103, 0x81C,      0xF30E0103,
+	0x81C,      0xF2100103, 0x81C,      0xF1120103, 0x81C,      0xF0140103,
+	0x81C,      0xEF160103, 0x81C,      0xEE180103, 0x81C,      0xED1A0103,
+	0x81C,      0xEC1C0103, 0x81C,      0xEB1E0103, 0x81C,      0xEA200103,
+	0x81C,      0xE9220103, 0x81C,      0xE8240103, 0x81C,      0xE7260103,
+	0x81C,      0xE6280103, 0x81C,      0xE52A0103, 0x81C,      0xC42C0103,
+	0x81C,      0xC32E0103, 0x81C,      0xC2300103, 0x81C,      0xC1320103,
+	0x81C,      0xA4340103, 0x81C,      0xA3360103, 0x81C,      0xA2380103,
+	0x81C,      0xA13A0103, 0x81C,      0x833C0103, 0x81C,      0x823E0103,
+	0x81C,      0x81400103, 0x81C,      0x63420103, 0x81C,      0x62440103,
+	0x81C,      0x61460103, 0x81C,      0x60480103, 0x81C,      0x424A0103,
+	0x81C,      0x414C0103, 0x81C,      0x404E0103, 0x81C,      0x22500103,
+	0x81C,      0x21520103, 0x81C,      0x20540103, 0x81C,      0x03560103,
+	0x81C,      0x02580103, 0x81C,      0x015A0103, 0x81C,      0x005C0103,
+	0x81C,      0x005E0103, 0x81C,      0x00600103, 0x81C,      0x00620103,
+	0x81C,      0x00640103, 0x81C,      0x00660103, 0x81C,      0x00680103,
+	0x81C,      0x006A0103, 0x81C,      0x006C0103, 0x81C,      0x006E0103,
+	0x81C,      0x00700103, 0x81C,      0x00720103, 0x81C,      0x00740103,
+	0x81C,      0x00760103, 0x81C,      0x00780103, 0x81C,      0x007A0103,
+	0x81C,      0x007C0103, 0x81C,      0x007E0103, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xF8000103, 0x81C,      0xF7020103,
+	0x81C,      0xF6040103, 0x81C,      0xF5060103, 0x81C,      0xF4080103,
+	0x81C,      0xF30A0103, 0x81C,      0xF20C0103, 0x81C,      0xF10E0103,
+	0x81C,      0xF0100103, 0x81C,      0xEF120103, 0x81C,      0xEE140103,
+	0x81C,      0xED160103, 0x81C,      0xEC180103, 0x81C,      0xEB1A0103,
+	0x81C,      0xEA1C0103, 0x81C,      0xE91E0103, 0x81C,      0xE8200103,
+	0x81C,      0xE7220103, 0x81C,      0xE6240103, 0x81C,      0xE5260103,
+	0x81C,      0xE4280103, 0x81C,      0xE32A0103, 0x81C,      0xC32C0103,
+	0x81C,      0xC22E0103, 0x81C,      0xC1300103, 0x81C,      0xC0320103,
+	0x81C,      0xA3340103, 0x81C,      0xA2360103, 0x81C,      0xA1380103,
+	0x81C,      0xA03A0103, 0x81C,      0x823C0103, 0x81C,      0x813E0103,
+	0x81C,      0x80400103, 0x81C,      0x63420103, 0x81C,      0x62440103,
+	0x81C,      0x61460103, 0x81C,      0x60480103, 0x81C,      0x424A0103,
+	0x81C,      0x414C0103, 0x81C,      0x404E0103, 0x81C,      0x06500103,
+	0x81C,      0x05520103, 0x81C,      0x04540103, 0x81C,      0x03560103,
+	0x81C,      0x02580103, 0x81C,      0x015A0103, 0x81C,      0x005C0103,
+	0x81C,      0x005E0103, 0x81C,      0x00600103, 0x81C,      0x00620103,
+	0x81C,      0x00640103, 0x81C,      0x00660103, 0x81C,      0x00680103,
+	0x81C,      0x006A0103, 0x81C,      0x006C0103, 0x81C,      0x006E0103,
+	0x81C,      0x00700103, 0x81C,      0x00720103, 0x81C,      0x00740103,
+	0x81C,      0x00760103, 0x81C,      0x00780103, 0x81C,      0x007A0103,
+	0x81C,      0x007C0103, 0x81C,      0x007E0103, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xF8000103, 0x81C,      0xF7020103,
+	0x81C,      0xF6040103, 0x81C,      0xF5060103, 0x81C,      0xF4080103,
+	0x81C,      0xF30A0103, 0x81C,      0xF20C0103, 0x81C,      0xF10E0103,
+	0x81C,      0xF0100103, 0x81C,      0xEF120103, 0x81C,      0xEE140103,
+	0x81C,      0xED160103, 0x81C,      0xEC180103, 0x81C,      0xEB1A0103,
+	0x81C,      0xEA1C0103, 0x81C,      0xE91E0103, 0x81C,      0xE8200103,
+	0x81C,      0xE7220103, 0x81C,      0xE6240103, 0x81C,      0xE5260103,
+	0x81C,      0xE4280103, 0x81C,      0xE32A0103, 0x81C,      0xC32C0103,
+	0x81C,      0xC22E0103, 0x81C,      0xC1300103, 0x81C,      0xC0320103,
+	0x81C,      0xA3340103, 0x81C,      0xA2360103, 0x81C,      0xA1380103,
+	0x81C,      0xA03A0103, 0x81C,      0x823C0103, 0x81C,      0x813E0103,
+	0x81C,      0x80400103, 0x81C,      0x63420103, 0x81C,      0x62440103,
+	0x81C,      0x61460103, 0x81C,      0x60480103, 0x81C,      0x424A0103,
+	0x81C,      0x414C0103, 0x81C,      0x404E0103, 0x81C,      0x22500103,
+	0x81C,      0x21520103, 0x81C,      0x20540103, 0x81C,      0x03560103,
+	0x81C,      0x02580103, 0x81C,      0x015A0103, 0x81C,      0x005C0103,
+	0x81C,      0x005E0103, 0x81C,      0x00600103, 0x81C,      0x00620103,
+	0x81C,      0x00640103, 0x81C,      0x00660103, 0x81C,      0x00680103,
+	0x81C,      0x006A0103, 0x81C,      0x006C0103, 0x81C,      0x006E0103,
+	0x81C,      0x00700103, 0x81C,      0x00720103, 0x81C,      0x00740103,
+	0x81C,      0x00760103, 0x81C,      0x00780103, 0x81C,      0x007A0103,
+	0x81C,      0x007C0103, 0x81C,      0x007E0103, 0x9000200c, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xF8000103, 0x81C,      0xF7020103,
+	0x81C,      0xF6040103, 0x81C,      0xF5060103, 0x81C,      0xF4080103,
+	0x81C,      0xF30A0103, 0x81C,      0xF20C0103, 0x81C,      0xF10E0103,
+	0x81C,      0xF0100103, 0x81C,      0xEF120103, 0x81C,      0xEE140103,
+	0x81C,      0xED160103, 0x81C,      0xEC180103, 0x81C,      0xEB1A0103,
+	0x81C,      0xEA1C0103, 0x81C,      0xE91E0103, 0x81C,      0xE8200103,
+	0x81C,      0xE7220103, 0x81C,      0xE6240103, 0x81C,      0xE5260103,
+	0x81C,      0xE4280103, 0x81C,      0xE32A0103, 0x81C,      0xC32C0103,
+	0x81C,      0xC22E0103, 0x81C,      0xC1300103, 0x81C,      0xC0320103,
+	0x81C,      0xA3340103, 0x81C,      0xA2360103, 0x81C,      0xA1380103,
+	0x81C,      0xA03A0103, 0x81C,      0x823C0103, 0x81C,      0x813E0103,
+	0x81C,      0x80400103, 0x81C,      0x63420103, 0x81C,      0x62440103,
+	0x81C,      0x61460103, 0x81C,      0x60480103, 0x81C,      0x424A0103,
+	0x81C,      0x414C0103, 0x81C,      0x404E0103, 0x81C,      0x22500103,
+	0x81C,      0x21520103, 0x81C,      0x20540103, 0x81C,      0x03560103,
+	0x81C,      0x02580103, 0x81C,      0x015A0103, 0x81C,      0x005C0103,
+	0x81C,      0x005E0103, 0x81C,      0x00600103, 0x81C,      0x00620103,
+	0x81C,      0x00640103, 0x81C,      0x00660103, 0x81C,      0x00680103,
+	0x81C,      0x006A0103, 0x81C,      0x006C0103, 0x81C,      0x006E0103,
+	0x81C,      0x00700103, 0x81C,      0x00720103, 0x81C,      0x00740103,
+	0x81C,      0x00760103, 0x81C,      0x00780103, 0x81C,      0x007A0103,
+	0x81C,      0x007C0103, 0x81C,      0x007E0103, 0x90012100, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFD000103, 0x81C,      0xFC020103,
+	0x81C,      0xFB040103, 0x81C,      0xFA060103, 0x81C,      0xF9080103,
+	0x81C,      0xF80A0103, 0x81C,      0xF70C0103, 0x81C,      0xF60E0103,
+	0x81C,      0xF5100103, 0x81C,      0xF4120103, 0x81C,      0xF3140103,
+	0x81C,      0xF2160103, 0x81C,      0xF1180103, 0x81C,      0xF01A0103,
+	0x81C,      0xEF1C0103, 0x81C,      0xEE1E0103, 0x81C,      0xED200103,
+	0x81C,      0xEC220103, 0x81C,      0xEB240103, 0x81C,      0xEA260103,
+	0x81C,      0xE9280103, 0x81C,      0xE82A0103, 0x81C,      0xE72C0103,
+	0x81C,      0xE62E0103, 0x81C,      0xE5300103, 0x81C,      0xE4320103,
+	0x81C,      0xE3340103, 0x81C,      0xC6360103, 0x81C,      0xC5380103,
+	0x81C,      0xC43A0103, 0x81C,      0xC33C0103, 0x81C,      0xC23E0103,
+	0x81C,      0xA5400103, 0x81C,      0xA4420103, 0x81C,      0xA3440103,
+	0x81C,      0xA2460103, 0x81C,      0xA1480103, 0x81C,      0x834A0103,
+	0x81C,      0x824C0103, 0x81C,      0x814E0103, 0x81C,      0x63500103,
+	0x81C,      0x62520103, 0x81C,      0x61540103, 0x81C,      0x43560103,
+	0x81C,      0x42580103, 0x81C,      0x245A0103, 0x81C,      0x235C0103,
+	0x81C,      0x225E0103, 0x81C,      0x21600103, 0x81C,      0x04620103,
+	0x81C,      0x03640103, 0x81C,      0x02660103, 0x81C,      0x01680103,
+	0x81C,      0x006A0103, 0x81C,      0x006C0103, 0x81C,      0x006E0103,
+	0x81C,      0x00700103, 0x81C,      0x00720103, 0x81C,      0x00740103,
+	0x81C,      0x00760103, 0x81C,      0x00780103, 0x81C,      0x007A0103,
+	0x81C,      0x007C0103, 0x81C,      0x007E0103, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xF8000103, 0x81C,      0xF7020103,
+	0x81C,      0xF6040103, 0x81C,      0xF5060103, 0x81C,      0xF4080103,
+	0x81C,      0xF30A0103, 0x81C,      0xF20C0103, 0x81C,      0xF10E0103,
+	0x81C,      0xF0100103, 0x81C,      0xEF120103, 0x81C,      0xEE140103,
+	0x81C,      0xED160103, 0x81C,      0xEC180103, 0x81C,      0xEB1A0103,
+	0x81C,      0xEA1C0103, 0x81C,      0xE91E0103, 0x81C,      0xE8200103,
+	0x81C,      0xE7220103, 0x81C,      0xE6240103, 0x81C,      0xE5260103,
+	0x81C,      0xE4280103, 0x81C,      0xE32A0103, 0x81C,      0xE22C0103,
+	0x81C,      0xC32E0103, 0x81C,      0xC2300103, 0x81C,      0xC1320103,
+	0x81C,      0xA3340103, 0x81C,      0xA2360103, 0x81C,      0xA1380103,
+	0x81C,      0xA03A0103, 0x81C,      0x823C0103, 0x81C,      0x813E0103,
+	0x81C,      0x80400103, 0x81C,      0x64420103, 0x81C,      0x63440103,
+	0x81C,      0x62460103, 0x81C,      0x61480103, 0x81C,      0x434A0103,
+	0x81C,      0x424C0103, 0x81C,      0x414E0103, 0x81C,      0x40500103,
+	0x81C,      0x22520103, 0x81C,      0x21540103, 0x81C,      0x20560103,
+	0x81C,      0x04580103, 0x81C,      0x035A0103, 0x81C,      0x025C0103,
+	0x81C,      0x015E0103, 0x81C,      0x00600103, 0x81C,      0x00620103,
+	0x81C,      0x00640103, 0x81C,      0x00660103, 0x81C,      0x00680103,
+	0x81C,      0x006A0103, 0x81C,      0x006C0103, 0x81C,      0x006E0103,
+	0x81C,      0x00700103, 0x81C,      0x00720103, 0x81C,      0x00740103,
+	0x81C,      0x00760103, 0x81C,      0x00780103, 0x81C,      0x007A0103,
+	0x81C,      0x007C0103, 0x81C,      0x007E0103, 0x90011000, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFD000103, 0x81C,      0xFC020103,
+	0x81C,      0xFB040103, 0x81C,      0xFA060103, 0x81C,      0xF9080103,
+	0x81C,      0xF80A0103, 0x81C,      0xF70C0103, 0x81C,      0xF60E0103,
+	0x81C,      0xF5100103, 0x81C,      0xF4120103, 0x81C,      0xF3140103,
+	0x81C,      0xF2160103, 0x81C,      0xF1180103, 0x81C,      0xF01A0103,
+	0x81C,      0xEE1C0103, 0x81C,      0xED1E0103, 0x81C,      0xEC200103,
+	0x81C,      0xEB220103, 0x81C,      0xEA240103, 0x81C,      0xE9260103,
+	0x81C,      0xE8280103, 0x81C,      0xE72A0103, 0x81C,      0xE62C0103,
+	0x81C,      0xE52E0103, 0x81C,      0xE4300103, 0x81C,      0xE3320103,
+	0x81C,      0xE2340103, 0x81C,      0xC5360103, 0x81C,      0xC4380103,
+	0x81C,      0xC33A0103, 0x81C,      0xC23C0103, 0x81C,      0xA53E0103,
+	0x81C,      0xA4400103, 0x81C,      0xA3420103, 0x81C,      0xA2440103,
+	0x81C,      0xA1460103, 0x81C,      0x83480103, 0x81C,      0x824A0103,
+	0x81C,      0x814C0103, 0x81C,      0x804E0103, 0x81C,      0x63500103,
+	0x81C,      0x62520103, 0x81C,      0x61540103, 0x81C,      0x43560103,
+	0x81C,      0x42580103, 0x81C,      0x415A0103, 0x81C,      0x405C0103,
+	0x81C,      0x225E0103, 0x81C,      0x21600103, 0x81C,      0x20620103,
+	0x81C,      0x03640103, 0x81C,      0x02660103, 0x81C,      0x01680103,
+	0x81C,      0x006A0103, 0x81C,      0x006C0103, 0x81C,      0x006E0103,
+	0x81C,      0x00700103, 0x81C,      0x00720103, 0x81C,      0x00740103,
+	0x81C,      0x00760103, 0x81C,      0x00780103, 0x81C,      0x007A0103,
+	0x81C,      0x007C0103, 0x81C,      0x007E0103, 0x90002100, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFD000103, 0x81C,      0xFC020103,
+	0x81C,      0xFB040103, 0x81C,      0xFA060103, 0x81C,      0xF9080103,
+	0x81C,      0xF80A0103, 0x81C,      0xF70C0103, 0x81C,      0xF60E0103,
+	0x81C,      0xF5100103, 0x81C,      0xF4120103, 0x81C,      0xF3140103,
+	0x81C,      0xF2160103, 0x81C,      0xF1180103, 0x81C,      0xF01A0103,
+	0x81C,      0xEF1C0103, 0x81C,      0xEE1E0103, 0x81C,      0xED200103,
+	0x81C,      0xEC220103, 0x81C,      0xEB240103, 0x81C,      0xEA260103,
+	0x81C,      0xE9280103, 0x81C,      0xE82A0103, 0x81C,      0xE72C0103,
+	0x81C,      0xE62E0103, 0x81C,      0xE5300103, 0x81C,      0xE4320103,
+	0x81C,      0xE3340103, 0x81C,      0xE2360103, 0x81C,      0xC5380103,
+	0x81C,      0xC43A0103, 0x81C,      0xC33C0103, 0x81C,      0xC23E0103,
+	0x81C,      0xA5400103, 0x81C,      0xA4420103, 0x81C,      0xA3440103,
+	0x81C,      0xA2460103, 0x81C,      0xA1480103, 0x81C,      0x834A0103,
+	0x81C,      0x824C0103, 0x81C,      0x814E0103, 0x81C,      0x64500103,
+	0x81C,      0x63520103, 0x81C,      0x62540103, 0x81C,      0x61560103,
+	0x81C,      0x42580103, 0x81C,      0x415A0103, 0x81C,      0x405C0103,
+	0x81C,      0x065E0103, 0x81C,      0x05600103, 0x81C,      0x04620103,
+	0x81C,      0x03640103, 0x81C,      0x02660103, 0x81C,      0x01680103,
+	0x81C,      0x006A0103, 0x81C,      0x006C0103, 0x81C,      0x006E0103,
+	0x81C,      0x00700103, 0x81C,      0x00720103, 0x81C,      0x00740103,
+	0x81C,      0x00760103, 0x81C,      0x00780103, 0x81C,      0x007A0103,
+	0x81C,      0x007C0103, 0x81C,      0x007E0103, 0x90002000, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFE000103, 0x81C,      0xFD020103,
+	0x81C,      0xFC040103, 0x81C,      0xFB060103, 0x81C,      0xFA080103,
+	0x81C,      0xF90A0103, 0x81C,      0xF80C0103, 0x81C,      0xF70E0103,
+	0x81C,      0xF6100103, 0x81C,      0xF5120103, 0x81C,      0xF4140103,
+	0x81C,      0xF3160103, 0x81C,      0xF2180103, 0x81C,      0xF11A0103,
+	0x81C,      0xF01C0103, 0x81C,      0xEF1E0103, 0x81C,      0xEE200103,
+	0x81C,      0xED220103, 0x81C,      0xEC240103, 0x81C,      0xEB260103,
+	0x81C,      0xEA280103, 0x81C,      0xE92A0103, 0x81C,      0xE82C0103,
+	0x81C,      0xE72E0103, 0x81C,      0xE6300103, 0x81C,      0xE5320103,
+	0x81C,      0xE4340103, 0x81C,      0xE3360103, 0x81C,      0xC6380103,
+	0x81C,      0xC53A0103, 0x81C,      0xC43C0103, 0x81C,      0xC33E0103,
+	0x81C,      0xA5400103, 0x81C,      0xA4420103, 0x81C,      0xA3440103,
+	0x81C,      0xA2460103, 0x81C,      0xA1480103, 0x81C,      0xA04A0103,
+	0x81C,      0x824C0103, 0x81C,      0x814E0103, 0x81C,      0x80500103,
+	0x81C,      0x64520103, 0x81C,      0x63540103, 0x81C,      0x62560103,
+	0x81C,      0x61580103, 0x81C,      0x605A0103, 0x81C,      0x235C0103,
+	0x81C,      0x225E0103, 0x81C,      0x21600103, 0x81C,      0x20620103,
+	0x81C,      0x03640103, 0x81C,      0x02660103, 0x81C,      0x01680103,
+	0x81C,      0x006A0103, 0x81C,      0x006C0103, 0x81C,      0x006E0103,
+	0x81C,      0x00700103, 0x81C,      0x00720103, 0x81C,      0x00740103,
+	0x81C,      0x00760103, 0x81C,      0x00780103, 0x81C,      0x007A0103,
+	0x81C,      0x007C0103, 0x81C,      0x007E0103, 0xA0000000, 0x00000000,
+	0x81C,      0xFE000103, 0x81C,      0xFD020103, 0x81C,      0xFC040103,
+	0x81C,      0xFB060103, 0x81C,      0xFA080103, 0x81C,      0xF90A0103,
+	0x81C,      0xF80C0103, 0x81C,      0xF70E0103, 0x81C,      0xF6100103,
+	0x81C,      0xF5120103, 0x81C,      0xF4140103, 0x81C,      0xF3160103,
+	0x81C,      0xF2180103, 0x81C,      0xF11A0103, 0x81C,      0xF01C0103,
+	0x81C,      0xEF1E0103, 0x81C,      0xEE200103, 0x81C,      0xED220103,
+	0x81C,      0xEC240103, 0x81C,      0xEB260103, 0x81C,      0xEA280103,
+	0x81C,      0xE92A0103, 0x81C,      0xE82C0103, 0x81C,      0xE72E0103,
+	0x81C,      0xE6300103, 0x81C,      0xE5320103, 0x81C,      0xE4340103,
+	0x81C,      0xE3360103, 0x81C,      0xC6380103, 0x81C,      0xC53A0103,
+	0x81C,      0xC43C0103, 0x81C,      0xC33E0103, 0x81C,      0xA5400103,
+	0x81C,      0xA4420103, 0x81C,      0xA3440103, 0x81C,      0xA2460103,
+	0x81C,      0xA1480103, 0x81C,      0xA04A0103, 0x81C,      0x824C0103,
+	0x81C,      0x814E0103, 0x81C,      0x80500103, 0x81C,      0x64520103,
+	0x81C,      0x63540103, 0x81C,      0x62560103, 0x81C,      0x61580103,
+	0x81C,      0x605A0103, 0x81C,      0x235C0103, 0x81C,      0x225E0103,
+	0x81C,      0x21600103, 0x81C,      0x20620103, 0x81C,      0x03640103,
+	0x81C,      0x02660103, 0x81C,      0x01680103, 0x81C,      0x006A0103,
+	0x81C,      0x006C0103, 0x81C,      0x006E0103, 0x81C,      0x00700103,
+	0x81C,      0x00720103, 0x81C,      0x00740103, 0x81C,      0x00760103,
+	0x81C,      0x00780103, 0x81C,      0x007A0103, 0x81C,      0x007C0103,
+	0x81C,      0x007E0103, 0xB0000000, 0x00000000, 0x8000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x81C,      0xF8000203, 0x81C,      0xF7020203,
+	0x81C,      0xF6040203, 0x81C,      0xF5060203, 0x81C,      0xF4080203,
+	0x81C,      0xF30A0203, 0x81C,      0xF20C0203, 0x81C,      0xF10E0203,
+	0x81C,      0xF0100203, 0x81C,      0xEF120203, 0x81C,      0xEE140203,
+	0x81C,      0xED160203, 0x81C,      0xEC180203, 0x81C,      0xEB1A0203,
+	0x81C,      0xEA1C0203, 0x81C,      0xE91E0203, 0x81C,      0xE8200203,
+	0x81C,      0xE7220203, 0x81C,      0xE6240203, 0x81C,      0xE5260203,
+	0x81C,      0xE4280203, 0x81C,      0xE32A0203, 0x81C,      0xC42C0203,
+	0x81C,      0xC32E0203, 0x81C,      0xC2300203, 0x81C,      0xC1320203,
+	0x81C,      0xA3340203, 0x81C,      0xA2360203, 0x81C,      0xA1380203,
+	0x81C,      0xA03A0203, 0x81C,      0x823C0203, 0x81C,      0x813E0203,
+	0x81C,      0x80400203, 0x81C,      0x65420203, 0x81C,      0x64440203,
+	0x81C,      0x63460203, 0x81C,      0x62480203, 0x81C,      0x614A0203,
+	0x81C,      0x424C0203, 0x81C,      0x414E0203, 0x81C,      0x40500203,
+	0x81C,      0x22520203, 0x81C,      0x21540203, 0x81C,      0x20560203,
+	0x81C,      0x04580203, 0x81C,      0x035A0203, 0x81C,      0x025C0203,
+	0x81C,      0x015E0203, 0x81C,      0x00600203, 0x81C,      0x00620203,
+	0x81C,      0x00640203, 0x81C,      0x00660203, 0x81C,      0x00680203,
+	0x81C,      0x006A0203, 0x81C,      0x006C0203, 0x81C,      0x006E0203,
+	0x81C,      0x00700203, 0x81C,      0x00720203, 0x81C,      0x00740203,
+	0x81C,      0x00760203, 0x81C,      0x00780203, 0x81C,      0x007A0203,
+	0x81C,      0x007C0203, 0x81C,      0x007E0203, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x81C,      0xF9000203, 0x81C,      0xF8020203,
+	0x81C,      0xF7040203, 0x81C,      0xF6060203, 0x81C,      0xF5080203,
+	0x81C,      0xF40A0203, 0x81C,      0xF30C0203, 0x81C,      0xF20E0203,
+	0x81C,      0xF1100203, 0x81C,      0xF0120203, 0x81C,      0xEF140203,
+	0x81C,      0xEE160203, 0x81C,      0xED180203, 0x81C,      0xEC1A0203,
+	0x81C,      0xEB1C0203, 0x81C,      0xEA1E0203, 0x81C,      0xE9200203,
+	0x81C,      0xE8220203, 0x81C,      0xE7240203, 0x81C,      0xE6260203,
+	0x81C,      0xE5280203, 0x81C,      0xC42A0203, 0x81C,      0xC32C0203,
+	0x81C,      0xC22E0203, 0x81C,      0xC1300203, 0x81C,      0xC0320203,
+	0x81C,      0xA3340203, 0x81C,      0xA2360203, 0x81C,      0xA1380203,
+	0x81C,      0xA03A0203, 0x81C,      0x823C0203, 0x81C,      0x813E0203,
+	0x81C,      0x80400203, 0x81C,      0x64420203, 0x81C,      0x63440203,
+	0x81C,      0x62460203, 0x81C,      0x61480203, 0x81C,      0x604A0203,
+	0x81C,      0x414C0203, 0x81C,      0x404E0203, 0x81C,      0x22500203,
+	0x81C,      0x21520203, 0x81C,      0x20540203, 0x81C,      0x03560203,
+	0x81C,      0x02580203, 0x81C,      0x015A0203, 0x81C,      0x005C0203,
+	0x81C,      0x005E0203, 0x81C,      0x00600203, 0x81C,      0x00620203,
+	0x81C,      0x00640203, 0x81C,      0x00660203, 0x81C,      0x00680203,
+	0x81C,      0x006A0203, 0x81C,      0x006C0203, 0x81C,      0x006E0203,
+	0x81C,      0x00700203, 0x81C,      0x00720203, 0x81C,      0x00740203,
+	0x81C,      0x00760203, 0x81C,      0x00780203, 0x81C,      0x007A0203,
+	0x81C,      0x007C0203, 0x81C,      0x007E0203, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xF7000203, 0x81C,      0xF6020203,
+	0x81C,      0xF5040203, 0x81C,      0xF4060203, 0x81C,      0xF3080203,
+	0x81C,      0xF20A0203, 0x81C,      0xF10C0203, 0x81C,      0xF00E0203,
+	0x81C,      0xEF100203, 0x81C,      0xEE120203, 0x81C,      0xED140203,
+	0x81C,      0xEC160203, 0x81C,      0xEB180203, 0x81C,      0xEA1A0203,
+	0x81C,      0xE91C0203, 0x81C,      0xE81E0203, 0x81C,      0xE7200203,
+	0x81C,      0xE6220203, 0x81C,      0xE5240203, 0x81C,      0xE4260203,
+	0x81C,      0xE3280203, 0x81C,      0xC42A0203, 0x81C,      0xC32C0203,
+	0x81C,      0xC22E0203, 0x81C,      0xC1300203, 0x81C,      0xC0320203,
+	0x81C,      0xA3340203, 0x81C,      0xA2360203, 0x81C,      0xA1380203,
+	0x81C,      0xA03A0203, 0x81C,      0x823C0203, 0x81C,      0x813E0203,
+	0x81C,      0x80400203, 0x81C,      0x63420203, 0x81C,      0x62440203,
+	0x81C,      0x61460203, 0x81C,      0x60480203, 0x81C,      0x424A0203,
+	0x81C,      0x414C0203, 0x81C,      0x404E0203, 0x81C,      0x06500203,
+	0x81C,      0x05520203, 0x81C,      0x04540203, 0x81C,      0x03560203,
+	0x81C,      0x02580203, 0x81C,      0x015A0203, 0x81C,      0x005C0203,
+	0x81C,      0x005E0203, 0x81C,      0x00600203, 0x81C,      0x00620203,
+	0x81C,      0x00640203, 0x81C,      0x00660203, 0x81C,      0x00680203,
+	0x81C,      0x006A0203, 0x81C,      0x006C0203, 0x81C,      0x006E0203,
+	0x81C,      0x00700203, 0x81C,      0x00720203, 0x81C,      0x00740203,
+	0x81C,      0x00760203, 0x81C,      0x00780203, 0x81C,      0x007A0203,
+	0x81C,      0x007C0203, 0x81C,      0x007E0203, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xF7000203, 0x81C,      0xF6020203,
+	0x81C,      0xF5040203, 0x81C,      0xF4060203, 0x81C,      0xF3080203,
+	0x81C,      0xF20A0203, 0x81C,      0xF10C0203, 0x81C,      0xF00E0203,
+	0x81C,      0xEF100203, 0x81C,      0xEE120203, 0x81C,      0xED140203,
+	0x81C,      0xEC160203, 0x81C,      0xEB180203, 0x81C,      0xEA1A0203,
+	0x81C,      0xE91C0203, 0x81C,      0xE81E0203, 0x81C,      0xE7200203,
+	0x81C,      0xE6220203, 0x81C,      0xE5240203, 0x81C,      0xE4260203,
+	0x81C,      0xE3280203, 0x81C,      0xC42A0203, 0x81C,      0xC32C0203,
+	0x81C,      0xC22E0203, 0x81C,      0xC1300203, 0x81C,      0xC0320203,
+	0x81C,      0xA3340203, 0x81C,      0xA2360203, 0x81C,      0xA1380203,
+	0x81C,      0xA03A0203, 0x81C,      0x823C0203, 0x81C,      0x813E0203,
+	0x81C,      0x80400203, 0x81C,      0x64420203, 0x81C,      0x63440203,
+	0x81C,      0x62460203, 0x81C,      0x61480203, 0x81C,      0x604A0203,
+	0x81C,      0x414C0203, 0x81C,      0x404E0203, 0x81C,      0x22500203,
+	0x81C,      0x21520203, 0x81C,      0x20540203, 0x81C,      0x03560203,
+	0x81C,      0x02580203, 0x81C,      0x015A0203, 0x81C,      0x005C0203,
+	0x81C,      0x005E0203, 0x81C,      0x00600203, 0x81C,      0x00620203,
+	0x81C,      0x00640203, 0x81C,      0x00660203, 0x81C,      0x00680203,
+	0x81C,      0x006A0203, 0x81C,      0x006C0203, 0x81C,      0x006E0203,
+	0x81C,      0x00700203, 0x81C,      0x00720203, 0x81C,      0x00740203,
+	0x81C,      0x00760203, 0x81C,      0x00780203, 0x81C,      0x007A0203,
+	0x81C,      0x007C0203, 0x81C,      0x007E0203, 0x9000200c, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xF7000203, 0x81C,      0xF6020203,
+	0x81C,      0xF5040203, 0x81C,      0xF4060203, 0x81C,      0xF3080203,
+	0x81C,      0xF20A0203, 0x81C,      0xF10C0203, 0x81C,      0xF00E0203,
+	0x81C,      0xEF100203, 0x81C,      0xEE120203, 0x81C,      0xED140203,
+	0x81C,      0xEC160203, 0x81C,      0xEB180203, 0x81C,      0xEA1A0203,
+	0x81C,      0xE91C0203, 0x81C,      0xE81E0203, 0x81C,      0xE7200203,
+	0x81C,      0xE6220203, 0x81C,      0xE5240203, 0x81C,      0xE4260203,
+	0x81C,      0xE3280203, 0x81C,      0xC42A0203, 0x81C,      0xC32C0203,
+	0x81C,      0xC22E0203, 0x81C,      0xC1300203, 0x81C,      0xC0320203,
+	0x81C,      0xA3340203, 0x81C,      0xA2360203, 0x81C,      0xA1380203,
+	0x81C,      0xA03A0203, 0x81C,      0x823C0203, 0x81C,      0x813E0203,
+	0x81C,      0x80400203, 0x81C,      0x64420203, 0x81C,      0x63440203,
+	0x81C,      0x62460203, 0x81C,      0x61480203, 0x81C,      0x604A0203,
+	0x81C,      0x414C0203, 0x81C,      0x404E0203, 0x81C,      0x22500203,
+	0x81C,      0x21520203, 0x81C,      0x20540203, 0x81C,      0x03560203,
+	0x81C,      0x02580203, 0x81C,      0x015A0203, 0x81C,      0x005C0203,
+	0x81C,      0x005E0203, 0x81C,      0x00600203, 0x81C,      0x00620203,
+	0x81C,      0x00640203, 0x81C,      0x00660203, 0x81C,      0x00680203,
+	0x81C,      0x006A0203, 0x81C,      0x006C0203, 0x81C,      0x006E0203,
+	0x81C,      0x00700203, 0x81C,      0x00720203, 0x81C,      0x00740203,
+	0x81C,      0x00760203, 0x81C,      0x00780203, 0x81C,      0x007A0203,
+	0x81C,      0x007C0203, 0x81C,      0x007E0203, 0x90012100, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFB000203, 0x81C,      0xFA020203,
+	0x81C,      0xF9040203, 0x81C,      0xF8060203, 0x81C,      0xF7080203,
+	0x81C,      0xF60A0203, 0x81C,      0xF50C0203, 0x81C,      0xF40E0203,
+	0x81C,      0xF3100203, 0x81C,      0xF2120203, 0x81C,      0xF1140203,
+	0x81C,      0xF0160203, 0x81C,      0xEF180203, 0x81C,      0xEE1A0203,
+	0x81C,      0xED1C0203, 0x81C,      0xEC1E0203, 0x81C,      0xEB200203,
+	0x81C,      0xEA220203, 0x81C,      0xE9240203, 0x81C,      0xE8260203,
+	0x81C,      0xE7280203, 0x81C,      0xE62A0203, 0x81C,      0xE52C0203,
+	0x81C,      0xE42E0203, 0x81C,      0xE3300203, 0x81C,      0xE2320203,
+	0x81C,      0xC6340203, 0x81C,      0xC5360203, 0x81C,      0xC4380203,
+	0x81C,      0xC33A0203, 0x81C,      0xC23C0203, 0x81C,      0xC13E0203,
+	0x81C,      0xC0400203, 0x81C,      0xA3420203, 0x81C,      0xA2440203,
+	0x81C,      0xA1460203, 0x81C,      0xA0480203, 0x81C,      0x824A0203,
+	0x81C,      0x814C0203, 0x81C,      0x804E0203, 0x81C,      0x63500203,
+	0x81C,      0x62520203, 0x81C,      0x61540203, 0x81C,      0x60560203,
+	0x81C,      0x24580203, 0x81C,      0x235A0203, 0x81C,      0x225C0203,
+	0x81C,      0x215E0203, 0x81C,      0x20600203, 0x81C,      0x03620203,
+	0x81C,      0x02640203, 0x81C,      0x01660203, 0x81C,      0x00680203,
+	0x81C,      0x006A0203, 0x81C,      0x006C0203, 0x81C,      0x006E0203,
+	0x81C,      0x00700203, 0x81C,      0x00720203, 0x81C,      0x00740203,
+	0x81C,      0x00760203, 0x81C,      0x00780203, 0x81C,      0x007A0203,
+	0x81C,      0x007C0203, 0x81C,      0x007E0203, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xF8000203, 0x81C,      0xF7020203,
+	0x81C,      0xF6040203, 0x81C,      0xF5060203, 0x81C,      0xF4080203,
+	0x81C,      0xF30A0203, 0x81C,      0xF20C0203, 0x81C,      0xF10E0203,
+	0x81C,      0xF0100203, 0x81C,      0xEF120203, 0x81C,      0xEE140203,
+	0x81C,      0xED160203, 0x81C,      0xEC180203, 0x81C,      0xEB1A0203,
+	0x81C,      0xEA1C0203, 0x81C,      0xE91E0203, 0x81C,      0xE8200203,
+	0x81C,      0xE7220203, 0x81C,      0xE6240203, 0x81C,      0xE5260203,
+	0x81C,      0xE4280203, 0x81C,      0xE32A0203, 0x81C,      0xC42C0203,
+	0x81C,      0xC32E0203, 0x81C,      0xC2300203, 0x81C,      0xC1320203,
+	0x81C,      0xA3340203, 0x81C,      0xA2360203, 0x81C,      0xA1380203,
+	0x81C,      0xA03A0203, 0x81C,      0x823C0203, 0x81C,      0x813E0203,
+	0x81C,      0x80400203, 0x81C,      0x65420203, 0x81C,      0x64440203,
+	0x81C,      0x63460203, 0x81C,      0x62480203, 0x81C,      0x614A0203,
+	0x81C,      0x424C0203, 0x81C,      0x414E0203, 0x81C,      0x40500203,
+	0x81C,      0x22520203, 0x81C,      0x21540203, 0x81C,      0x20560203,
+	0x81C,      0x04580203, 0x81C,      0x035A0203, 0x81C,      0x025C0203,
+	0x81C,      0x015E0203, 0x81C,      0x00600203, 0x81C,      0x00620203,
+	0x81C,      0x00640203, 0x81C,      0x00660203, 0x81C,      0x00680203,
+	0x81C,      0x006A0203, 0x81C,      0x006C0203, 0x81C,      0x006E0203,
+	0x81C,      0x00700203, 0x81C,      0x00720203, 0x81C,      0x00740203,
+	0x81C,      0x00760203, 0x81C,      0x00780203, 0x81C,      0x007A0203,
+	0x81C,      0x007C0203, 0x81C,      0x007E0203, 0x90011000, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFC000203, 0x81C,      0xFB020203,
+	0x81C,      0xFA040203, 0x81C,      0xF9060203, 0x81C,      0xF8080203,
+	0x81C,      0xF70A0203, 0x81C,      0xF60C0203, 0x81C,      0xF50E0203,
+	0x81C,      0xF4100203, 0x81C,      0xF3120203, 0x81C,      0xF2140203,
+	0x81C,      0xF1160203, 0x81C,      0xF0180203, 0x81C,      0xEE1A0203,
+	0x81C,      0xED1C0203, 0x81C,      0xEC1E0203, 0x81C,      0xEB200203,
+	0x81C,      0xEA220203, 0x81C,      0xE9240203, 0x81C,      0xE8260203,
+	0x81C,      0xE7280203, 0x81C,      0xE62A0203, 0x81C,      0xE52C0203,
+	0x81C,      0xE42E0203, 0x81C,      0xE3300203, 0x81C,      0xE2320203,
+	0x81C,      0xC6340203, 0x81C,      0xC5360203, 0x81C,      0xC4380203,
+	0x81C,      0xC33A0203, 0x81C,      0xA63C0203, 0x81C,      0xA53E0203,
+	0x81C,      0xA4400203, 0x81C,      0xA3420203, 0x81C,      0xA2440203,
+	0x81C,      0xA1460203, 0x81C,      0x83480203, 0x81C,      0x824A0203,
+	0x81C,      0x814C0203, 0x81C,      0x804E0203, 0x81C,      0x63500203,
+	0x81C,      0x62520203, 0x81C,      0x61540203, 0x81C,      0x42560203,
+	0x81C,      0x41580203, 0x81C,      0x405A0203, 0x81C,      0x225C0203,
+	0x81C,      0x215E0203, 0x81C,      0x20600203, 0x81C,      0x04620203,
+	0x81C,      0x03640203, 0x81C,      0x02660203, 0x81C,      0x01680203,
+	0x81C,      0x006A0203, 0x81C,      0x006C0203, 0x81C,      0x006E0203,
+	0x81C,      0x00700203, 0x81C,      0x00720203, 0x81C,      0x00740203,
+	0x81C,      0x00760203, 0x81C,      0x00780203, 0x81C,      0x007A0203,
+	0x81C,      0x007C0203, 0x81C,      0x007E0203, 0x90002100, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFC000203, 0x81C,      0xFB020203,
+	0x81C,      0xFA040203, 0x81C,      0xF9060203, 0x81C,      0xF8080203,
+	0x81C,      0xF70A0203, 0x81C,      0xF60C0203, 0x81C,      0xF50E0203,
+	0x81C,      0xF4100203, 0x81C,      0xF3120203, 0x81C,      0xF2140203,
+	0x81C,      0xF1160203, 0x81C,      0xF0180203, 0x81C,      0xEF1A0203,
+	0x81C,      0xEE1C0203, 0x81C,      0xED1E0203, 0x81C,      0xEC200203,
+	0x81C,      0xEB220203, 0x81C,      0xEA240203, 0x81C,      0xE9260203,
+	0x81C,      0xE8280203, 0x81C,      0xE72A0203, 0x81C,      0xE62C0203,
+	0x81C,      0xE52E0203, 0x81C,      0xE4300203, 0x81C,      0xE3320203,
+	0x81C,      0xE2340203, 0x81C,      0xE1360203, 0x81C,      0xC5380203,
+	0x81C,      0xC43A0203, 0x81C,      0xC33C0203, 0x81C,      0xC23E0203,
+	0x81C,      0xC1400203, 0x81C,      0xA3420203, 0x81C,      0xA2440203,
+	0x81C,      0xA1460203, 0x81C,      0xA0480203, 0x81C,      0x834A0203,
+	0x81C,      0x824C0203, 0x81C,      0x814E0203, 0x81C,      0x64500203,
+	0x81C,      0x63520203, 0x81C,      0x62540203, 0x81C,      0x61560203,
+	0x81C,      0x25580203, 0x81C,      0x245A0203, 0x81C,      0x235C0203,
+	0x81C,      0x225E0203, 0x81C,      0x21600203, 0x81C,      0x04620203,
+	0x81C,      0x03640203, 0x81C,      0x02660203, 0x81C,      0x01680203,
+	0x81C,      0x006A0203, 0x81C,      0x006C0203, 0x81C,      0x006E0203,
+	0x81C,      0x00700203, 0x81C,      0x00720203, 0x81C,      0x00740203,
+	0x81C,      0x00760203, 0x81C,      0x00780203, 0x81C,      0x007A0203,
+	0x81C,      0x007C0203, 0x81C,      0x007E0203, 0x90002000, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFC000203, 0x81C,      0xFB020203,
+	0x81C,      0xFA040203, 0x81C,      0xF9060203, 0x81C,      0xF8080203,
+	0x81C,      0xF70A0203, 0x81C,      0xF60C0203, 0x81C,      0xF50E0203,
+	0x81C,      0xF4100203, 0x81C,      0xF3120203, 0x81C,      0xF2140203,
+	0x81C,      0xF1160203, 0x81C,      0xF0180203, 0x81C,      0xEF1A0203,
+	0x81C,      0xEE1C0203, 0x81C,      0xED1E0203, 0x81C,      0xEC200203,
+	0x81C,      0xEB220203, 0x81C,      0xEA240203, 0x81C,      0xE9260203,
+	0x81C,      0xE8280203, 0x81C,      0xE72A0203, 0x81C,      0xE62C0203,
+	0x81C,      0xE52E0203, 0x81C,      0xE4300203, 0x81C,      0xE3320203,
+	0x81C,      0xE2340203, 0x81C,      0xC6360203, 0x81C,      0xC5380203,
+	0x81C,      0xC43A0203, 0x81C,      0xC33C0203, 0x81C,      0xA63E0203,
+	0x81C,      0xA5400203, 0x81C,      0xA4420203, 0x81C,      0xA3440203,
+	0x81C,      0xA2460203, 0x81C,      0xA1480203, 0x81C,      0x834A0203,
+	0x81C,      0x824C0203, 0x81C,      0x814E0203, 0x81C,      0x64500203,
+	0x81C,      0x63520203, 0x81C,      0x62540203, 0x81C,      0x61560203,
+	0x81C,      0x60580203, 0x81C,      0x405A0203, 0x81C,      0x215C0203,
+	0x81C,      0x205E0203, 0x81C,      0x03600203, 0x81C,      0x02620203,
+	0x81C,      0x01640203, 0x81C,      0x00660203, 0x81C,      0x00680203,
+	0x81C,      0x006A0203, 0x81C,      0x006C0203, 0x81C,      0x006E0203,
+	0x81C,      0x00700203, 0x81C,      0x00720203, 0x81C,      0x00740203,
+	0x81C,      0x00760203, 0x81C,      0x00780203, 0x81C,      0x007A0203,
+	0x81C,      0x007C0203, 0x81C,      0x007E0203, 0xA0000000, 0x00000000,
+	0x81C,      0xFD000203, 0x81C,      0xFC020203, 0x81C,      0xFB040203,
+	0x81C,      0xFA060203, 0x81C,      0xF9080203, 0x81C,      0xF80A0203,
+	0x81C,      0xF70C0203, 0x81C,      0xF60E0203, 0x81C,      0xF5100203,
+	0x81C,      0xF4120203, 0x81C,      0xF3140203, 0x81C,      0xF2160203,
+	0x81C,      0xF1180203, 0x81C,      0xF01A0203, 0x81C,      0xEF1C0203,
+	0x81C,      0xEE1E0203, 0x81C,      0xED200203, 0x81C,      0xEC220203,
+	0x81C,      0xEB240203, 0x81C,      0xEA260203, 0x81C,      0xE9280203,
+	0x81C,      0xE82A0203, 0x81C,      0xE72C0203, 0x81C,      0xE62E0203,
+	0x81C,      0xE5300203, 0x81C,      0xE4320203, 0x81C,      0xE3340203,
+	0x81C,      0xC6360203, 0x81C,      0xC5380203, 0x81C,      0xC43A0203,
+	0x81C,      0xC33C0203, 0x81C,      0xA63E0203, 0x81C,      0xA5400203,
+	0x81C,      0xA4420203, 0x81C,      0xA3440203, 0x81C,      0xA2460203,
+	0x81C,      0xA1480203, 0x81C,      0x834A0203, 0x81C,      0x824C0203,
+	0x81C,      0x814E0203, 0x81C,      0x64500203, 0x81C,      0x63520203,
+	0x81C,      0x62540203, 0x81C,      0x61560203, 0x81C,      0x60580203,
+	0x81C,      0x235A0203, 0x81C,      0x225C0203, 0x81C,      0x215E0203,
+	0x81C,      0x20600203, 0x81C,      0x03620203, 0x81C,      0x02640203,
+	0x81C,      0x01660203, 0x81C,      0x00680203, 0x81C,      0x006A0203,
+	0x81C,      0x006C0203, 0x81C,      0x006E0203, 0x81C,      0x00700203,
+	0x81C,      0x00720203, 0x81C,      0x00740203, 0x81C,      0x00760203,
+	0x81C,      0x00780203, 0x81C,      0x007A0203, 0x81C,      0x007C0203,
+	0x81C,      0x007E0203, 0xB0000000, 0x00000000, 0x8000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x81C,      0xF8000303, 0x81C,      0xF7020303,
+	0x81C,      0xF6040303, 0x81C,      0xF5060303, 0x81C,      0xF4080303,
+	0x81C,      0xF30A0303, 0x81C,      0xF20C0303, 0x81C,      0xF10E0303,
+	0x81C,      0xF0100303, 0x81C,      0xEF120303, 0x81C,      0xEE140303,
+	0x81C,      0xED160303, 0x81C,      0xEC180303, 0x81C,      0xEB1A0303,
+	0x81C,      0xEA1C0303, 0x81C,      0xE91E0303, 0x81C,      0xCA200303,
+	0x81C,      0xC9220303, 0x81C,      0xC8240303, 0x81C,      0xC7260303,
+	0x81C,      0xC6280303, 0x81C,      0xC52A0303, 0x81C,      0xC42C0303,
+	0x81C,      0xC32E0303, 0x81C,      0xC2300303, 0x81C,      0xC1320303,
+	0x81C,      0xA3340303, 0x81C,      0xA2360303, 0x81C,      0xA1380303,
+	0x81C,      0xA03A0303, 0x81C,      0x823C0303, 0x81C,      0x813E0303,
+	0x81C,      0x80400303, 0x81C,      0x65420303, 0x81C,      0x64440303,
+	0x81C,      0x63460303, 0x81C,      0x62480303, 0x81C,      0x614A0303,
+	0x81C,      0x424C0303, 0x81C,      0x414E0303, 0x81C,      0x40500303,
+	0x81C,      0x22520303, 0x81C,      0x21540303, 0x81C,      0x20560303,
+	0x81C,      0x04580303, 0x81C,      0x035A0303, 0x81C,      0x025C0303,
+	0x81C,      0x015E0303, 0x81C,      0x00600303, 0x81C,      0x00620303,
+	0x81C,      0x00640303, 0x81C,      0x00660303, 0x81C,      0x00680303,
+	0x81C,      0x006A0303, 0x81C,      0x006C0303, 0x81C,      0x006E0303,
+	0x81C,      0x00700303, 0x81C,      0x00720303, 0x81C,      0x00740303,
+	0x81C,      0x00760303, 0x81C,      0x00780303, 0x81C,      0x007A0303,
+	0x81C,      0x007C0303, 0x81C,      0x007E0303, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x81C,      0xF9000303, 0x81C,      0xF8020303,
+	0x81C,      0xF7040303, 0x81C,      0xF6060303, 0x81C,      0xF5080303,
+	0x81C,      0xF40A0303, 0x81C,      0xF30C0303, 0x81C,      0xF20E0303,
+	0x81C,      0xF1100303, 0x81C,      0xF0120303, 0x81C,      0xEF140303,
+	0x81C,      0xEE160303, 0x81C,      0xED180303, 0x81C,      0xEC1A0303,
+	0x81C,      0xEB1C0303, 0x81C,      0xEA1E0303, 0x81C,      0xC9200303,
+	0x81C,      0xC8220303, 0x81C,      0xC7240303, 0x81C,      0xC6260303,
+	0x81C,      0xC5280303, 0x81C,      0xC42A0303, 0x81C,      0xC32C0303,
+	0x81C,      0xC22E0303, 0x81C,      0xC1300303, 0x81C,      0xC0320303,
+	0x81C,      0xA3340303, 0x81C,      0xA2360303, 0x81C,      0xA1380303,
+	0x81C,      0xA03A0303, 0x81C,      0x823C0303, 0x81C,      0x813E0303,
+	0x81C,      0x80400303, 0x81C,      0x64420303, 0x81C,      0x63440303,
+	0x81C,      0x62460303, 0x81C,      0x61480303, 0x81C,      0x604A0303,
+	0x81C,      0x414C0303, 0x81C,      0x404E0303, 0x81C,      0x22500303,
+	0x81C,      0x21520303, 0x81C,      0x20540303, 0x81C,      0x03560303,
+	0x81C,      0x02580303, 0x81C,      0x015A0303, 0x81C,      0x005C0303,
+	0x81C,      0x005E0303, 0x81C,      0x00600303, 0x81C,      0x00620303,
+	0x81C,      0x00640303, 0x81C,      0x00660303, 0x81C,      0x00680303,
+	0x81C,      0x006A0303, 0x81C,      0x006C0303, 0x81C,      0x006E0303,
+	0x81C,      0x00700303, 0x81C,      0x00720303, 0x81C,      0x00740303,
+	0x81C,      0x00760303, 0x81C,      0x00780303, 0x81C,      0x007A0303,
+	0x81C,      0x007C0303, 0x81C,      0x007E0303, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xF7000303, 0x81C,      0xF6020303,
+	0x81C,      0xF5040303, 0x81C,      0xF4060303, 0x81C,      0xF3080303,
+	0x81C,      0xF20A0303, 0x81C,      0xF10C0303, 0x81C,      0xF00E0303,
+	0x81C,      0xEF100303, 0x81C,      0xEE120303, 0x81C,      0xED140303,
+	0x81C,      0xEC160303, 0x81C,      0xEB180303, 0x81C,      0xEA1A0303,
+	0x81C,      0xE91C0303, 0x81C,      0xCA1E0303, 0x81C,      0xC9200303,
+	0x81C,      0xC8220303, 0x81C,      0xC7240303, 0x81C,      0xC6260303,
+	0x81C,      0xC5280303, 0x81C,      0xC42A0303, 0x81C,      0xC32C0303,
+	0x81C,      0xC22E0303, 0x81C,      0xC1300303, 0x81C,      0xA4320303,
+	0x81C,      0xA3340303, 0x81C,      0xA2360303, 0x81C,      0xA1380303,
+	0x81C,      0xA03A0303, 0x81C,      0x823C0303, 0x81C,      0x813E0303,
+	0x81C,      0x80400303, 0x81C,      0x64420303, 0x81C,      0x63440303,
+	0x81C,      0x62460303, 0x81C,      0x61480303, 0x81C,      0x604A0303,
+	0x81C,      0x414C0303, 0x81C,      0x404E0303, 0x81C,      0x06500303,
+	0x81C,      0x05520303, 0x81C,      0x04540303, 0x81C,      0x03560303,
+	0x81C,      0x02580303, 0x81C,      0x015A0303, 0x81C,      0x005C0303,
+	0x81C,      0x005E0303, 0x81C,      0x00600303, 0x81C,      0x00620303,
+	0x81C,      0x00640303, 0x81C,      0x00660303, 0x81C,      0x00680303,
+	0x81C,      0x006A0303, 0x81C,      0x006C0303, 0x81C,      0x006E0303,
+	0x81C,      0x00700303, 0x81C,      0x00720303, 0x81C,      0x00740303,
+	0x81C,      0x00760303, 0x81C,      0x00780303, 0x81C,      0x007A0303,
+	0x81C,      0x007C0303, 0x81C,      0x007E0303, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xF7000303, 0x81C,      0xF6020303,
+	0x81C,      0xF5040303, 0x81C,      0xF4060303, 0x81C,      0xF3080303,
+	0x81C,      0xF20A0303, 0x81C,      0xF10C0303, 0x81C,      0xF00E0303,
+	0x81C,      0xEF100303, 0x81C,      0xEE120303, 0x81C,      0xED140303,
+	0x81C,      0xEC160303, 0x81C,      0xEB180303, 0x81C,      0xEA1A0303,
+	0x81C,      0xE91C0303, 0x81C,      0xCA1E0303, 0x81C,      0xC9200303,
+	0x81C,      0xC8220303, 0x81C,      0xC7240303, 0x81C,      0xC6260303,
+	0x81C,      0xC5280303, 0x81C,      0xC42A0303, 0x81C,      0xC32C0303,
+	0x81C,      0xC22E0303, 0x81C,      0xC1300303, 0x81C,      0xA4320303,
+	0x81C,      0xA3340303, 0x81C,      0xA2360303, 0x81C,      0xA1380303,
+	0x81C,      0xA03A0303, 0x81C,      0x823C0303, 0x81C,      0x813E0303,
+	0x81C,      0x80400303, 0x81C,      0x64420303, 0x81C,      0x63440303,
+	0x81C,      0x62460303, 0x81C,      0x61480303, 0x81C,      0x604A0303,
+	0x81C,      0x414C0303, 0x81C,      0x404E0303, 0x81C,      0x22500303,
+	0x81C,      0x21520303, 0x81C,      0x20540303, 0x81C,      0x03560303,
+	0x81C,      0x02580303, 0x81C,      0x015A0303, 0x81C,      0x005C0303,
+	0x81C,      0x005E0303, 0x81C,      0x00600303, 0x81C,      0x00620303,
+	0x81C,      0x00640303, 0x81C,      0x00660303, 0x81C,      0x00680303,
+	0x81C,      0x006A0303, 0x81C,      0x006C0303, 0x81C,      0x006E0303,
+	0x81C,      0x00700303, 0x81C,      0x00720303, 0x81C,      0x00740303,
+	0x81C,      0x00760303, 0x81C,      0x00780303, 0x81C,      0x007A0303,
+	0x81C,      0x007C0303, 0x81C,      0x007E0303, 0x9000200c, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xF7000303, 0x81C,      0xF6020303,
+	0x81C,      0xF5040303, 0x81C,      0xF4060303, 0x81C,      0xF3080303,
+	0x81C,      0xF20A0303, 0x81C,      0xF10C0303, 0x81C,      0xF00E0303,
+	0x81C,      0xEF100303, 0x81C,      0xEE120303, 0x81C,      0xED140303,
+	0x81C,      0xEC160303, 0x81C,      0xEB180303, 0x81C,      0xEA1A0303,
+	0x81C,      0xE91C0303, 0x81C,      0xCA1E0303, 0x81C,      0xC9200303,
+	0x81C,      0xC8220303, 0x81C,      0xC7240303, 0x81C,      0xC6260303,
+	0x81C,      0xC5280303, 0x81C,      0xC42A0303, 0x81C,      0xC32C0303,
+	0x81C,      0xC22E0303, 0x81C,      0xC1300303, 0x81C,      0xA4320303,
+	0x81C,      0xA3340303, 0x81C,      0xA2360303, 0x81C,      0xA1380303,
+	0x81C,      0xA03A0303, 0x81C,      0x823C0303, 0x81C,      0x813E0303,
+	0x81C,      0x80400303, 0x81C,      0x64420303, 0x81C,      0x63440303,
+	0x81C,      0x62460303, 0x81C,      0x61480303, 0x81C,      0x604A0303,
+	0x81C,      0x414C0303, 0x81C,      0x404E0303, 0x81C,      0x22500303,
+	0x81C,      0x21520303, 0x81C,      0x20540303, 0x81C,      0x03560303,
+	0x81C,      0x02580303, 0x81C,      0x015A0303, 0x81C,      0x005C0303,
+	0x81C,      0x005E0303, 0x81C,      0x00600303, 0x81C,      0x00620303,
+	0x81C,      0x00640303, 0x81C,      0x00660303, 0x81C,      0x00680303,
+	0x81C,      0x006A0303, 0x81C,      0x006C0303, 0x81C,      0x006E0303,
+	0x81C,      0x00700303, 0x81C,      0x00720303, 0x81C,      0x00740303,
+	0x81C,      0x00760303, 0x81C,      0x00780303, 0x81C,      0x007A0303,
+	0x81C,      0x007C0303, 0x81C,      0x007E0303, 0x90012100, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFB000303, 0x81C,      0xFA020303,
+	0x81C,      0xF9040303, 0x81C,      0xF8060303, 0x81C,      0xF7080303,
+	0x81C,      0xF60A0303, 0x81C,      0xF50C0303, 0x81C,      0xF40E0303,
+	0x81C,      0xF3100303, 0x81C,      0xF2120303, 0x81C,      0xF1140303,
+	0x81C,      0xF0160303, 0x81C,      0xEF180303, 0x81C,      0xEE1A0303,
+	0x81C,      0xED1C0303, 0x81C,      0xEC1E0303, 0x81C,      0xEB200303,
+	0x81C,      0xEA220303, 0x81C,      0xE9240303, 0x81C,      0xE8260303,
+	0x81C,      0xE7280303, 0x81C,      0xE62A0303, 0x81C,      0xE52C0303,
+	0x81C,      0xE42E0303, 0x81C,      0xE3300303, 0x81C,      0xE2320303,
+	0x81C,      0xC6340303, 0x81C,      0xC5360303, 0x81C,      0xC4380303,
+	0x81C,      0xC33A0303, 0x81C,      0xC23C0303, 0x81C,      0xC13E0303,
+	0x81C,      0xA4400303, 0x81C,      0xA3420303, 0x81C,      0xA2440303,
+	0x81C,      0xA1460303, 0x81C,      0x83480303, 0x81C,      0x824A0303,
+	0x81C,      0x814C0303, 0x81C,      0x804E0303, 0x81C,      0x63500303,
+	0x81C,      0x62520303, 0x81C,      0x43540303, 0x81C,      0x42560303,
+	0x81C,      0x41580303, 0x81C,      0x235A0303, 0x81C,      0x225C0303,
+	0x81C,      0x215E0303, 0x81C,      0x20600303, 0x81C,      0x04620303,
+	0x81C,      0x03640303, 0x81C,      0x02660303, 0x81C,      0x01680303,
+	0x81C,      0x006A0303, 0x81C,      0x006C0303, 0x81C,      0x006E0303,
+	0x81C,      0x00700303, 0x81C,      0x00720303, 0x81C,      0x00740303,
+	0x81C,      0x00760303, 0x81C,      0x00780303, 0x81C,      0x007A0303,
+	0x81C,      0x007C0303, 0x81C,      0x007E0303, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xF8000303, 0x81C,      0xF7020303,
+	0x81C,      0xF6040303, 0x81C,      0xF5060303, 0x81C,      0xF4080303,
+	0x81C,      0xF30A0303, 0x81C,      0xF20C0303, 0x81C,      0xF10E0303,
+	0x81C,      0xF0100303, 0x81C,      0xEF120303, 0x81C,      0xEE140303,
+	0x81C,      0xED160303, 0x81C,      0xEC180303, 0x81C,      0xEB1A0303,
+	0x81C,      0xEA1C0303, 0x81C,      0xE91E0303, 0x81C,      0xCA200303,
+	0x81C,      0xC9220303, 0x81C,      0xC8240303, 0x81C,      0xC7260303,
+	0x81C,      0xC6280303, 0x81C,      0xC52A0303, 0x81C,      0xC42C0303,
+	0x81C,      0xC32E0303, 0x81C,      0xC2300303, 0x81C,      0xC1320303,
+	0x81C,      0xA3340303, 0x81C,      0xA2360303, 0x81C,      0xA1380303,
+	0x81C,      0xA03A0303, 0x81C,      0x823C0303, 0x81C,      0x813E0303,
+	0x81C,      0x80400303, 0x81C,      0x65420303, 0x81C,      0x64440303,
+	0x81C,      0x63460303, 0x81C,      0x62480303, 0x81C,      0x614A0303,
+	0x81C,      0x424C0303, 0x81C,      0x414E0303, 0x81C,      0x40500303,
+	0x81C,      0x22520303, 0x81C,      0x21540303, 0x81C,      0x20560303,
+	0x81C,      0x04580303, 0x81C,      0x035A0303, 0x81C,      0x025C0303,
+	0x81C,      0x015E0303, 0x81C,      0x00600303, 0x81C,      0x00620303,
+	0x81C,      0x00640303, 0x81C,      0x00660303, 0x81C,      0x00680303,
+	0x81C,      0x006A0303, 0x81C,      0x006C0303, 0x81C,      0x006E0303,
+	0x81C,      0x00700303, 0x81C,      0x00720303, 0x81C,      0x00740303,
+	0x81C,      0x00760303, 0x81C,      0x00780303, 0x81C,      0x007A0303,
+	0x81C,      0x007C0303, 0x81C,      0x007E0303, 0x90011000, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFB000303, 0x81C,      0xFA020303,
+	0x81C,      0xF9040303, 0x81C,      0xF8060303, 0x81C,      0xF7080303,
+	0x81C,      0xF60A0303, 0x81C,      0xF50C0303, 0x81C,      0xF40E0303,
+	0x81C,      0xF3100303, 0x81C,      0xF2120303, 0x81C,      0xF1140303,
+	0x81C,      0xF0160303, 0x81C,      0xEE180303, 0x81C,      0xED1A0303,
+	0x81C,      0xEC1C0303, 0x81C,      0xEB1E0303, 0x81C,      0xEA200303,
+	0x81C,      0xE9220303, 0x81C,      0xE8240303, 0x81C,      0xE7260303,
+	0x81C,      0xE6280303, 0x81C,      0xE52A0303, 0x81C,      0xE42C0303,
+	0x81C,      0xE32E0303, 0x81C,      0xE2300303, 0x81C,      0xE1320303,
+	0x81C,      0xC6340303, 0x81C,      0xC5360303, 0x81C,      0xC4380303,
+	0x81C,      0xC33A0303, 0x81C,      0xA63C0303, 0x81C,      0xA53E0303,
+	0x81C,      0xA4400303, 0x81C,      0xA3420303, 0x81C,      0xA2440303,
+	0x81C,      0xA1460303, 0x81C,      0x83480303, 0x81C,      0x824A0303,
+	0x81C,      0x814C0303, 0x81C,      0x804E0303, 0x81C,      0x63500303,
+	0x81C,      0x62520303, 0x81C,      0x61540303, 0x81C,      0x42560303,
+	0x81C,      0x41580303, 0x81C,      0x405A0303, 0x81C,      0x225C0303,
+	0x81C,      0x215E0303, 0x81C,      0x20600303, 0x81C,      0x04620303,
+	0x81C,      0x03640303, 0x81C,      0x02660303, 0x81C,      0x01680303,
+	0x81C,      0x006A0303, 0x81C,      0x006C0303, 0x81C,      0x006E0303,
+	0x81C,      0x00700303, 0x81C,      0x00720303, 0x81C,      0x00740303,
+	0x81C,      0x00760303, 0x81C,      0x00780303, 0x81C,      0x007A0303,
+	0x81C,      0x007C0303, 0x81C,      0x007E0303, 0x90002100, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFB000303, 0x81C,      0xFA020303,
+	0x81C,      0xF9040303, 0x81C,      0xF8060303, 0x81C,      0xF7080303,
+	0x81C,      0xF60A0303, 0x81C,      0xF50C0303, 0x81C,      0xF40E0303,
+	0x81C,      0xF3100303, 0x81C,      0xF2120303, 0x81C,      0xF1140303,
+	0x81C,      0xF0160303, 0x81C,      0xEF180303, 0x81C,      0xEE1A0303,
+	0x81C,      0xED1C0303, 0x81C,      0xEC1E0303, 0x81C,      0xEB200303,
+	0x81C,      0xEA220303, 0x81C,      0xE9240303, 0x81C,      0xE8260303,
+	0x81C,      0xE7280303, 0x81C,      0xE62A0303, 0x81C,      0xE52C0303,
+	0x81C,      0xE42E0303, 0x81C,      0xE3300303, 0x81C,      0xE2320303,
+	0x81C,      0xE1340303, 0x81C,      0xC5360303, 0x81C,      0xC4380303,
+	0x81C,      0xC33A0303, 0x81C,      0xC23C0303, 0x81C,      0xC13E0303,
+	0x81C,      0xA4400303, 0x81C,      0xA3420303, 0x81C,      0xA2440303,
+	0x81C,      0xA1460303, 0x81C,      0x83480303, 0x81C,      0x824A0303,
+	0x81C,      0x814C0303, 0x81C,      0x804E0303, 0x81C,      0x64500303,
+	0x81C,      0x63520303, 0x81C,      0x62540303, 0x81C,      0x61560303,
+	0x81C,      0x60580303, 0x81C,      0x235A0303, 0x81C,      0x225C0303,
+	0x81C,      0x215E0303, 0x81C,      0x20600303, 0x81C,      0x04620303,
+	0x81C,      0x03640303, 0x81C,      0x02660303, 0x81C,      0x01680303,
+	0x81C,      0x006A0303, 0x81C,      0x006C0303, 0x81C,      0x006E0303,
+	0x81C,      0x00700303, 0x81C,      0x00720303, 0x81C,      0x00740303,
+	0x81C,      0x00760303, 0x81C,      0x00780303, 0x81C,      0x007A0303,
+	0x81C,      0x007C0303, 0x81C,      0x007E0303, 0x90002000, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFC000303, 0x81C,      0xFB020303,
+	0x81C,      0xFA040303, 0x81C,      0xF9060303, 0x81C,      0xF8080303,
+	0x81C,      0xF70A0303, 0x81C,      0xF60C0303, 0x81C,      0xF50E0303,
+	0x81C,      0xF4100303, 0x81C,      0xF3120303, 0x81C,      0xF2140303,
+	0x81C,      0xF1160303, 0x81C,      0xF0180303, 0x81C,      0xEF1A0303,
+	0x81C,      0xEE1C0303, 0x81C,      0xED1E0303, 0x81C,      0xEC200303,
+	0x81C,      0xEB220303, 0x81C,      0xEA240303, 0x81C,      0xE9260303,
+	0x81C,      0xE8280303, 0x81C,      0xE72A0303, 0x81C,      0xE62C0303,
+	0x81C,      0xE52E0303, 0x81C,      0xE4300303, 0x81C,      0xE3320303,
+	0x81C,      0xE2340303, 0x81C,      0xC6360303, 0x81C,      0xC5380303,
+	0x81C,      0xC43A0303, 0x81C,      0xC33C0303, 0x81C,      0xA63E0303,
+	0x81C,      0xA5400303, 0x81C,      0xA4420303, 0x81C,      0xA3440303,
+	0x81C,      0xA2460303, 0x81C,      0x84480303, 0x81C,      0x834A0303,
+	0x81C,      0x824C0303, 0x81C,      0x814E0303, 0x81C,      0x80500303,
+	0x81C,      0x63520303, 0x81C,      0x62540303, 0x81C,      0x61560303,
+	0x81C,      0x60580303, 0x81C,      0x225A0303, 0x81C,      0x055C0303,
+	0x81C,      0x045E0303, 0x81C,      0x03600303, 0x81C,      0x02620303,
+	0x81C,      0x01640303, 0x81C,      0x00660303, 0x81C,      0x00680303,
+	0x81C,      0x006A0303, 0x81C,      0x006C0303, 0x81C,      0x006E0303,
+	0x81C,      0x00700303, 0x81C,      0x00720303, 0x81C,      0x00740303,
+	0x81C,      0x00760303, 0x81C,      0x00780303, 0x81C,      0x007A0303,
+	0x81C,      0x007C0303, 0x81C,      0x007E0303, 0xA0000000, 0x00000000,
+	0x81C,      0xFC000303, 0x81C,      0xFB020303, 0x81C,      0xFA040303,
+	0x81C,      0xF9060303, 0x81C,      0xF8080303, 0x81C,      0xF70A0303,
+	0x81C,      0xF60C0303, 0x81C,      0xF50E0303, 0x81C,      0xF4100303,
+	0x81C,      0xF3120303, 0x81C,      0xF2140303, 0x81C,      0xF1160303,
+	0x81C,      0xF0180303, 0x81C,      0xEF1A0303, 0x81C,      0xEE1C0303,
+	0x81C,      0xED1E0303, 0x81C,      0xEC200303, 0x81C,      0xEB220303,
+	0x81C,      0xEA240303, 0x81C,      0xE9260303, 0x81C,      0xE8280303,
+	0x81C,      0xE72A0303, 0x81C,      0xE62C0303, 0x81C,      0xE52E0303,
+	0x81C,      0xE4300303, 0x81C,      0xE3320303, 0x81C,      0xE2340303,
+	0x81C,      0xC6360303, 0x81C,      0xC5380303, 0x81C,      0xC43A0303,
+	0x81C,      0xC33C0303, 0x81C,      0xA63E0303, 0x81C,      0xA5400303,
+	0x81C,      0xA4420303, 0x81C,      0xA3440303, 0x81C,      0xA2460303,
+	0x81C,      0x84480303, 0x81C,      0x834A0303, 0x81C,      0x824C0303,
+	0x81C,      0x814E0303, 0x81C,      0x80500303, 0x81C,      0x63520303,
+	0x81C,      0x62540303, 0x81C,      0x61560303, 0x81C,      0x60580303,
+	0x81C,      0x235A0303, 0x81C,      0x225C0303, 0x81C,      0x215E0303,
+	0x81C,      0x20600303, 0x81C,      0x03620303, 0x81C,      0x02640303,
+	0x81C,      0x01660303, 0x81C,      0x00680303, 0x81C,      0x006A0303,
+	0x81C,      0x006C0303, 0x81C,      0x006E0303, 0x81C,      0x00700303,
+	0x81C,      0x00720303, 0x81C,      0x00740303, 0x81C,      0x00760303,
+	0x81C,      0x00780303, 0x81C,      0x007A0303, 0x81C,      0x007C0303,
+	0x81C,      0x007E0303, 0xB0000000, 0x00000000, 0x8000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x81C,      0xFF000403, 0x81C,      0xF5000403,
+	0x81C,      0xF4020403, 0x81C,      0xF3040403, 0x81C,      0xF2060403,
+	0x81C,      0xF1080403, 0x81C,      0xF00A0403, 0x81C,      0xEF0C0403,
+	0x81C,      0xEE0E0403, 0x81C,      0xED100403, 0x81C,      0xEC120403,
+	0x81C,      0xEB140403, 0x81C,      0xEA160403, 0x81C,      0xE9180403,
+	0x81C,      0xE81A0403, 0x81C,      0xE71C0403, 0x81C,      0xE61E0403,
+	0x81C,      0xE5200403, 0x81C,      0xE4220403, 0x81C,      0xE3240403,
+	0x81C,      0xE2260403, 0x81C,      0xE1280403, 0x81C,      0xE02A0403,
+	0x81C,      0xC32C0403, 0x81C,      0xC22E0403, 0x81C,      0xC1300403,
+	0x81C,      0xC0320403, 0x81C,      0xA4340403, 0x81C,      0xA3360403,
+	0x81C,      0xA2380403, 0x81C,      0xA13A0403, 0x81C,      0xA03C0403,
+	0x81C,      0x823E0403, 0x81C,      0x81400403, 0x81C,      0x80420403,
+	0x81C,      0x64440403, 0x81C,      0x63460403, 0x81C,      0x62480403,
+	0x81C,      0x614A0403, 0x81C,      0x604C0403, 0x81C,      0x454E0403,
+	0x81C,      0x44500403, 0x81C,      0x43520403, 0x81C,      0x42540403,
+	0x81C,      0x41560403, 0x81C,      0x40580403, 0x81C,      0x055A0403,
+	0x81C,      0x045C0403, 0x81C,      0x035E0403, 0x81C,      0x02600403,
+	0x81C,      0x01620403, 0x81C,      0x00640403, 0x81C,      0x00660403,
+	0x81C,      0x00680403, 0x81C,      0x006A0403, 0x81C,      0x006C0403,
+	0x81C,      0x006E0403, 0x81C,      0x00700403, 0x81C,      0x00720403,
+	0x81C,      0x00740403, 0x81C,      0x00760403, 0x81C,      0x00780403,
+	0x81C,      0x007A0403, 0x81C,      0x007C0403, 0x81C,      0x007E0403,
+	0x9000100f, 0x05050505, 0x40000000, 0x00000000, 0x81C,      0xFF000403,
+	0x81C,      0xF5000403, 0x81C,      0xF4020403, 0x81C,      0xF3040403,
+	0x81C,      0xF2060403, 0x81C,      0xF1080403, 0x81C,      0xF00A0403,
+	0x81C,      0xEF0C0403, 0x81C,      0xEE0E0403, 0x81C,      0xED100403,
+	0x81C,      0xEC120403, 0x81C,      0xEB140403, 0x81C,      0xEA160403,
+	0x81C,      0xE9180403, 0x81C,      0xE81A0403, 0x81C,      0xE71C0403,
+	0x81C,      0xE61E0403, 0x81C,      0xE5200403, 0x81C,      0xE4220403,
+	0x81C,      0xE3240403, 0x81C,      0xE2260403, 0x81C,      0xE1280403,
+	0x81C,      0xE02A0403, 0x81C,      0xC32C0403, 0x81C,      0xC22E0403,
+	0x81C,      0xC1300403, 0x81C,      0xC0320403, 0x81C,      0xA4340403,
+	0x81C,      0xA3360403, 0x81C,      0xA2380403, 0x81C,      0xA13A0403,
+	0x81C,      0xA03C0403, 0x81C,      0x823E0403, 0x81C,      0x81400403,
+	0x81C,      0x80420403, 0x81C,      0x64440403, 0x81C,      0x63460403,
+	0x81C,      0x62480403, 0x81C,      0x614A0403, 0x81C,      0x604C0403,
+	0x81C,      0x454E0403, 0x81C,      0x44500403, 0x81C,      0x43520403,
+	0x81C,      0x42540403, 0x81C,      0x41560403, 0x81C,      0x40580403,
+	0x81C,      0x055A0403, 0x81C,      0x045C0403, 0x81C,      0x035E0403,
+	0x81C,      0x02600403, 0x81C,      0x01620403, 0x81C,      0x00640403,
+	0x81C,      0x00660403, 0x81C,      0x00680403, 0x81C,      0x006A0403,
+	0x81C,      0x006C0403, 0x81C,      0x006E0403, 0x81C,      0x00700403,
+	0x81C,      0x00720403, 0x81C,      0x00740403, 0x81C,      0x00760403,
+	0x81C,      0x00780403, 0x81C,      0x007A0403, 0x81C,      0x007C0403,
+	0x81C,      0x007E0403, 0x9000100f, 0x00000000, 0x40000000, 0x00000000,
+	0x81C,      0xFF000403, 0x81C,      0xF5000403, 0x81C,      0xF4020403,
+	0x81C,      0xF3040403, 0x81C,      0xF2060403, 0x81C,      0xF1080403,
+	0x81C,      0xF00A0403, 0x81C,      0xEF0C0403, 0x81C,      0xEE0E0403,
+	0x81C,      0xED100403, 0x81C,      0xEC120403, 0x81C,      0xEB140403,
+	0x81C,      0xEA160403, 0x81C,      0xE9180403, 0x81C,      0xE81A0403,
+	0x81C,      0xE71C0403, 0x81C,      0xE61E0403, 0x81C,      0xE5200403,
+	0x81C,      0xE4220403, 0x81C,      0xE3240403, 0x81C,      0xE2260403,
+	0x81C,      0xE1280403, 0x81C,      0xE02A0403, 0x81C,      0xC32C0403,
+	0x81C,      0xC22E0403, 0x81C,      0xC1300403, 0x81C,      0xC0320403,
+	0x81C,      0xA4340403, 0x81C,      0xA3360403, 0x81C,      0xA2380403,
+	0x81C,      0xA13A0403, 0x81C,      0xA03C0403, 0x81C,      0x823E0403,
+	0x81C,      0x81400403, 0x81C,      0x80420403, 0x81C,      0x64440403,
+	0x81C,      0x63460403, 0x81C,      0x62480403, 0x81C,      0x614A0403,
+	0x81C,      0x604C0403, 0x81C,      0x454E0403, 0x81C,      0x44500403,
+	0x81C,      0x43520403, 0x81C,      0x42540403, 0x81C,      0x41560403,
+	0x81C,      0x40580403, 0x81C,      0x055A0403, 0x81C,      0x045C0403,
+	0x81C,      0x035E0403, 0x81C,      0x02600403, 0x81C,      0x01620403,
+	0x81C,      0x00640403, 0x81C,      0x00660403, 0x81C,      0x00680403,
+	0x81C,      0x006A0403, 0x81C,      0x006C0403, 0x81C,      0x006E0403,
+	0x81C,      0x00700403, 0x81C,      0x00720403, 0x81C,      0x00740403,
+	0x81C,      0x00760403, 0x81C,      0x00780403, 0x81C,      0x007A0403,
+	0x81C,      0x007C0403, 0x81C,      0x007E0403, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFF000403, 0x81C,      0xF5000403,
+	0x81C,      0xF4020403, 0x81C,      0xF3040403, 0x81C,      0xF2060403,
+	0x81C,      0xF1080403, 0x81C,      0xF00A0403, 0x81C,      0xEF0C0403,
+	0x81C,      0xEE0E0403, 0x81C,      0xED100403, 0x81C,      0xEC120403,
+	0x81C,      0xEB140403, 0x81C,      0xEA160403, 0x81C,      0xE9180403,
+	0x81C,      0xE81A0403, 0x81C,      0xE71C0403, 0x81C,      0xE61E0403,
+	0x81C,      0xE5200403, 0x81C,      0xE4220403, 0x81C,      0xE3240403,
+	0x81C,      0xE2260403, 0x81C,      0xE1280403, 0x81C,      0xE02A0403,
+	0x81C,      0xC32C0403, 0x81C,      0xC22E0403, 0x81C,      0xC1300403,
+	0x81C,      0xC0320403, 0x81C,      0xA4340403, 0x81C,      0xA3360403,
+	0x81C,      0xA2380403, 0x81C,      0xA13A0403, 0x81C,      0xA03C0403,
+	0x81C,      0x823E0403, 0x81C,      0x81400403, 0x81C,      0x80420403,
+	0x81C,      0x64440403, 0x81C,      0x63460403, 0x81C,      0x62480403,
+	0x81C,      0x614A0403, 0x81C,      0x604C0403, 0x81C,      0x454E0403,
+	0x81C,      0x44500403, 0x81C,      0x43520403, 0x81C,      0x42540403,
+	0x81C,      0x41560403, 0x81C,      0x40580403, 0x81C,      0x055A0403,
+	0x81C,      0x045C0403, 0x81C,      0x035E0403, 0x81C,      0x02600403,
+	0x81C,      0x01620403, 0x81C,      0x00640403, 0x81C,      0x00660403,
+	0x81C,      0x00680403, 0x81C,      0x006A0403, 0x81C,      0x006C0403,
+	0x81C,      0x006E0403, 0x81C,      0x00700403, 0x81C,      0x00720403,
+	0x81C,      0x00740403, 0x81C,      0x00760403, 0x81C,      0x00780403,
+	0x81C,      0x007A0403, 0x81C,      0x007C0403, 0x81C,      0x007E0403,
+	0x9000200c, 0x00000000, 0x40000000, 0x00000000, 0x81C,      0xFF000403,
+	0x81C,      0xFF000403, 0x81C,      0xFF020403, 0x81C,      0xFE040403,
+	0x81C,      0xFD060403, 0x81C,      0xFC080403, 0x81C,      0xFB0A0403,
+	0x81C,      0xFA0C0403, 0x81C,      0xF90E0403, 0x81C,      0xF8100403,
+	0x81C,      0xF7120403, 0x81C,      0xF6140403, 0x81C,      0xF5160403,
+	0x81C,      0xF4180403, 0x81C,      0xF31A0403, 0x81C,      0xF21C0403,
+	0x81C,      0xD51E0403, 0x81C,      0xD4200403, 0x81C,      0xD3220403,
+	0x81C,      0xD2240403, 0x81C,      0xB6260403, 0x81C,      0xB5280403,
+	0x81C,      0xB42A0403, 0x81C,      0xB32C0403, 0x81C,      0xB22E0403,
+	0x81C,      0xB1300403, 0x81C,      0xB0320403, 0x81C,      0xAF340403,
+	0x81C,      0xAE360403, 0x81C,      0xAD380403, 0x81C,      0xAC3A0403,
+	0x81C,      0xAB3C0403, 0x81C,      0xAA3E0403, 0x81C,      0xA9400403,
+	0x81C,      0xA8420403, 0x81C,      0xA7440403, 0x81C,      0xA6460403,
+	0x81C,      0xA5480403, 0x81C,      0xA44A0403, 0x81C,      0xA34C0403,
+	0x81C,      0x854E0403, 0x81C,      0x84500403, 0x81C,      0x83520403,
+	0x81C,      0x82540403, 0x81C,      0x81560403, 0x81C,      0x80580403,
+	0x81C,      0x485A0403, 0x81C,      0x475C0403, 0x81C,      0x465E0403,
+	0x81C,      0x45600403, 0x81C,      0x44620403, 0x81C,      0x0A640403,
+	0x81C,      0x09660403, 0x81C,      0x08680403, 0x81C,      0x076A0403,
+	0x81C,      0x066C0403, 0x81C,      0x056E0403, 0x81C,      0x04700403,
+	0x81C,      0x03720403, 0x81C,      0x02740403, 0x81C,      0x01760403,
+	0x81C,      0x00780403, 0x81C,      0x007A0403, 0x81C,      0x007C0403,
+	0x81C,      0x007E0403, 0x90012100, 0x00000000, 0x40000000, 0x00000000,
+	0x81C,      0xFF000403, 0x81C,      0xFF000403, 0x81C,      0xFF020403,
+	0x81C,      0xFE040403, 0x81C,      0xFD060403, 0x81C,      0xFC080403,
+	0x81C,      0xFB0A0403, 0x81C,      0xFA0C0403, 0x81C,      0xF90E0403,
+	0x81C,      0xF8100403, 0x81C,      0xF7120403, 0x81C,      0xF6140403,
+	0x81C,      0xF5160403, 0x81C,      0xF4180403, 0x81C,      0xF31A0403,
+	0x81C,      0xF21C0403, 0x81C,      0xD51E0403, 0x81C,      0xD4200403,
+	0x81C,      0xD3220403, 0x81C,      0xD2240403, 0x81C,      0xB6260403,
+	0x81C,      0xB5280403, 0x81C,      0xB42A0403, 0x81C,      0xB32C0403,
+	0x81C,      0xB22E0403, 0x81C,      0xB1300403, 0x81C,      0xB0320403,
+	0x81C,      0xAF340403, 0x81C,      0xAE360403, 0x81C,      0xAD380403,
+	0x81C,      0xAC3A0403, 0x81C,      0xAB3C0403, 0x81C,      0xAA3E0403,
+	0x81C,      0xA9400403, 0x81C,      0xA8420403, 0x81C,      0xA7440403,
+	0x81C,      0xA6460403, 0x81C,      0xA5480403, 0x81C,      0xA44A0403,
+	0x81C,      0xA34C0403, 0x81C,      0x854E0403, 0x81C,      0x84500403,
+	0x81C,      0x83520403, 0x81C,      0x82540403, 0x81C,      0x81560403,
+	0x81C,      0x80580403, 0x81C,      0x485A0403, 0x81C,      0x475C0403,
+	0x81C,      0x465E0403, 0x81C,      0x45600403, 0x81C,      0x44620403,
+	0x81C,      0x0A640403, 0x81C,      0x09660403, 0x81C,      0x08680403,
+	0x81C,      0x076A0403, 0x81C,      0x066C0403, 0x81C,      0x056E0403,
+	0x81C,      0x04700403, 0x81C,      0x03720403, 0x81C,      0x02740403,
+	0x81C,      0x01760403, 0x81C,      0x00780403, 0x81C,      0x007A0403,
+	0x81C,      0x007C0403, 0x81C,      0x007E0403, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFF000403, 0x81C,      0xF5000403,
+	0x81C,      0xF4020403, 0x81C,      0xF3040403, 0x81C,      0xF2060403,
+	0x81C,      0xF1080403, 0x81C,      0xF00A0403, 0x81C,      0xEF0C0403,
+	0x81C,      0xEE0E0403, 0x81C,      0xED100403, 0x81C,      0xEC120403,
+	0x81C,      0xEB140403, 0x81C,      0xEA160403, 0x81C,      0xE9180403,
+	0x81C,      0xE81A0403, 0x81C,      0xE71C0403, 0x81C,      0xE61E0403,
+	0x81C,      0xE5200403, 0x81C,      0xE4220403, 0x81C,      0xE3240403,
+	0x81C,      0xE2260403, 0x81C,      0xE1280403, 0x81C,      0xE02A0403,
+	0x81C,      0xC32C0403, 0x81C,      0xC22E0403, 0x81C,      0xC1300403,
+	0x81C,      0xC0320403, 0x81C,      0xA4340403, 0x81C,      0xA3360403,
+	0x81C,      0xA2380403, 0x81C,      0xA13A0403, 0x81C,      0xA03C0403,
+	0x81C,      0x823E0403, 0x81C,      0x81400403, 0x81C,      0x80420403,
+	0x81C,      0x64440403, 0x81C,      0x63460403, 0x81C,      0x62480403,
+	0x81C,      0x614A0403, 0x81C,      0x604C0403, 0x81C,      0x454E0403,
+	0x81C,      0x44500403, 0x81C,      0x43520403, 0x81C,      0x42540403,
+	0x81C,      0x41560403, 0x81C,      0x40580403, 0x81C,      0x055A0403,
+	0x81C,      0x045C0403, 0x81C,      0x035E0403, 0x81C,      0x02600403,
+	0x81C,      0x01620403, 0x81C,      0x00640403, 0x81C,      0x00660403,
+	0x81C,      0x00680403, 0x81C,      0x006A0403, 0x81C,      0x006C0403,
+	0x81C,      0x006E0403, 0x81C,      0x00700403, 0x81C,      0x00720403,
+	0x81C,      0x00740403, 0x81C,      0x00760403, 0x81C,      0x00780403,
+	0x81C,      0x007A0403, 0x81C,      0x007C0403, 0x81C,      0x007E0403,
+	0x90011000, 0x00000000, 0x40000000, 0x00000000, 0x81C,      0xFF000403,
+	0x81C,      0xFF000403, 0x81C,      0xFF020403, 0x81C,      0xFE040403,
+	0x81C,      0xFD060403, 0x81C,      0xFC080403, 0x81C,      0xFB0A0403,
+	0x81C,      0xFA0C0403, 0x81C,      0xF90E0403, 0x81C,      0xF8100403,
+	0x81C,      0xF7120403, 0x81C,      0xF6140403, 0x81C,      0xF5160403,
+	0x81C,      0xF4180403, 0x81C,      0xF31A0403, 0x81C,      0xF21C0403,
+	0x81C,      0xD51E0403, 0x81C,      0xD4200403, 0x81C,      0xD3220403,
+	0x81C,      0xD2240403, 0x81C,      0xB6260403, 0x81C,      0xB5280403,
+	0x81C,      0xB42A0403, 0x81C,      0xB32C0403, 0x81C,      0xB22E0403,
+	0x81C,      0xB1300403, 0x81C,      0xB0320403, 0x81C,      0xAF340403,
+	0x81C,      0xAE360403, 0x81C,      0xAD380403, 0x81C,      0xAC3A0403,
+	0x81C,      0xAB3C0403, 0x81C,      0xAA3E0403, 0x81C,      0xA9400403,
+	0x81C,      0xA8420403, 0x81C,      0xA7440403, 0x81C,      0xA6460403,
+	0x81C,      0xA5480403, 0x81C,      0xA44A0403, 0x81C,      0xA34C0403,
+	0x81C,      0x854E0403, 0x81C,      0x84500403, 0x81C,      0x83520403,
+	0x81C,      0x82540403, 0x81C,      0x81560403, 0x81C,      0x80580403,
+	0x81C,      0x485A0403, 0x81C,      0x475C0403, 0x81C,      0x465E0403,
+	0x81C,      0x45600403, 0x81C,      0x44620403, 0x81C,      0x0A640403,
+	0x81C,      0x09660403, 0x81C,      0x08680403, 0x81C,      0x076A0403,
+	0x81C,      0x066C0403, 0x81C,      0x056E0403, 0x81C,      0x04700403,
+	0x81C,      0x03720403, 0x81C,      0x02740403, 0x81C,      0x01760403,
+	0x81C,      0x00780403, 0x81C,      0x007A0403, 0x81C,      0x007C0403,
+	0x81C,      0x007E0403, 0x90002100, 0x00000000, 0x40000000, 0x00000000,
+	0x81C,      0xFF000403, 0x81C,      0xFF000403, 0x81C,      0xFF020403,
+	0x81C,      0xFE040403, 0x81C,      0xFD060403, 0x81C,      0xFC080403,
+	0x81C,      0xFB0A0403, 0x81C,      0xFA0C0403, 0x81C,      0xF90E0403,
+	0x81C,      0xF8100403, 0x81C,      0xF7120403, 0x81C,      0xF6140403,
+	0x81C,      0xF5160403, 0x81C,      0xF4180403, 0x81C,      0xF31A0403,
+	0x81C,      0xF21C0403, 0x81C,      0xD51E0403, 0x81C,      0xD4200403,
+	0x81C,      0xD3220403, 0x81C,      0xD2240403, 0x81C,      0xB6260403,
+	0x81C,      0xB5280403, 0x81C,      0xB42A0403, 0x81C,      0xB32C0403,
+	0x81C,      0xB22E0403, 0x81C,      0xB1300403, 0x81C,      0xB0320403,
+	0x81C,      0xAF340403, 0x81C,      0xAE360403, 0x81C,      0xAD380403,
+	0x81C,      0xAC3A0403, 0x81C,      0xAB3C0403, 0x81C,      0xAA3E0403,
+	0x81C,      0xA9400403, 0x81C,      0xA8420403, 0x81C,      0xA7440403,
+	0x81C,      0xA6460403, 0x81C,      0xA5480403, 0x81C,      0xA44A0403,
+	0x81C,      0xA34C0403, 0x81C,      0x854E0403, 0x81C,      0x84500403,
+	0x81C,      0x83520403, 0x81C,      0x82540403, 0x81C,      0x81560403,
+	0x81C,      0x80580403, 0x81C,      0x485A0403, 0x81C,      0x475C0403,
+	0x81C,      0x465E0403, 0x81C,      0x45600403, 0x81C,      0x44620403,
+	0x81C,      0x0A640403, 0x81C,      0x09660403, 0x81C,      0x08680403,
+	0x81C,      0x076A0403, 0x81C,      0x066C0403, 0x81C,      0x056E0403,
+	0x81C,      0x04700403, 0x81C,      0x03720403, 0x81C,      0x02740403,
+	0x81C,      0x01760403, 0x81C,      0x00780403, 0x81C,      0x007A0403,
+	0x81C,      0x007C0403, 0x81C,      0x007E0403, 0x90002000, 0x00000000,
+	0x40000000, 0x00000000, 0x81C,      0xFF000403, 0x81C,      0xFF000403,
+	0x81C,      0xFF020403, 0x81C,      0xFE040403, 0x81C,      0xFD060403,
+	0x81C,      0xFC080403, 0x81C,      0xFB0A0403, 0x81C,      0xFA0C0403,
+	0x81C,      0xF90E0403, 0x81C,      0xF8100403, 0x81C,      0xF7120403,
+	0x81C,      0xF6140403, 0x81C,      0xF5160403, 0x81C,      0xF4180403,
+	0x81C,      0xF31A0403, 0x81C,      0xF21C0403, 0x81C,      0xD51E0403,
+	0x81C,      0xD4200403, 0x81C,      0xD3220403, 0x81C,      0xD2240403,
+	0x81C,      0xB6260403, 0x81C,      0xB5280403, 0x81C,      0xB42A0403,
+	0x81C,      0xB32C0403, 0x81C,      0xB22E0403, 0x81C,      0xB1300403,
+	0x81C,      0xB0320403, 0x81C,      0xAF340403, 0x81C,      0xAE360403,
+	0x81C,      0xAD380403, 0x81C,      0xAC3A0403, 0x81C,      0xAB3C0403,
+	0x81C,      0xAA3E0403, 0x81C,      0xA9400403, 0x81C,      0xA8420403,
+	0x81C,      0xA7440403, 0x81C,      0xA6460403, 0x81C,      0xA5480403,
+	0x81C,      0xA44A0403, 0x81C,      0xA34C0403, 0x81C,      0x854E0403,
+	0x81C,      0x84500403, 0x81C,      0x83520403, 0x81C,      0x82540403,
+	0x81C,      0x81560403, 0x81C,      0x80580403, 0x81C,      0x485A0403,
+	0x81C,      0x475C0403, 0x81C,      0x465E0403, 0x81C,      0x45600403,
+	0x81C,      0x44620403, 0x81C,      0x0A640403, 0x81C,      0x09660403,
+	0x81C,      0x08680403, 0x81C,      0x076A0403, 0x81C,      0x066C0403,
+	0x81C,      0x056E0403, 0x81C,      0x04700403, 0x81C,      0x03720403,
+	0x81C,      0x02740403, 0x81C,      0x01760403, 0x81C,      0x00780403,
+	0x81C,      0x007A0403, 0x81C,      0x007C0403, 0x81C,      0x007E0403,
+	0xA0000000, 0x00000000, 0x81C,      0xFF000403, 0x81C,      0xFF000403,
+	0x81C,      0xFF020403, 0x81C,      0xFE040403, 0x81C,      0xFD060403,
+	0x81C,      0xFC080403, 0x81C,      0xFB0A0403, 0x81C,      0xFA0C0403,
+	0x81C,      0xF90E0403, 0x81C,      0xF8100403, 0x81C,      0xF7120403,
+	0x81C,      0xF6140403, 0x81C,      0xF5160403, 0x81C,      0xF4180403,
+	0x81C,      0xF31A0403, 0x81C,      0xF21C0403, 0x81C,      0xD51E0403,
+	0x81C,      0xD4200403, 0x81C,      0xD3220403, 0x81C,      0xD2240403,
+	0x81C,      0xB6260403, 0x81C,      0xB5280403, 0x81C,      0xB42A0403,
+	0x81C,      0xB32C0403, 0x81C,      0xB22E0403, 0x81C,      0xB1300403,
+	0x81C,      0xB0320403, 0x81C,      0xAF340403, 0x81C,      0xAE360403,
+	0x81C,      0xAD380403, 0x81C,      0xAC3A0403, 0x81C,      0xAB3C0403,
+	0x81C,      0xAA3E0403, 0x81C,      0xA9400403, 0x81C,      0xA8420403,
+	0x81C,      0xA7440403, 0x81C,      0xA6460403, 0x81C,      0xA5480403,
+	0x81C,      0xA44A0403, 0x81C,      0xA34C0403, 0x81C,      0x854E0403,
+	0x81C,      0x84500403, 0x81C,      0x83520403, 0x81C,      0x82540403,
+	0x81C,      0x81560403, 0x81C,      0x80580403, 0x81C,      0x485A0403,
+	0x81C,      0x475C0403, 0x81C,      0x465E0403, 0x81C,      0x45600403,
+	0x81C,      0x44620403, 0x81C,      0x0A640403, 0x81C,      0x09660403,
+	0x81C,      0x08680403, 0x81C,      0x076A0403, 0x81C,      0x066C0403,
+	0x81C,      0x056E0403, 0x81C,      0x04700403, 0x81C,      0x03720403,
+	0x81C,      0x02740403, 0x81C,      0x01760403, 0x81C,      0x00780403,
+	0x81C,      0x007A0403, 0x81C,      0x007C0403, 0x81C,      0x007E0403,
+	0xB0000000, 0x00000000, 0xC50,      0x00000022, 0xC50,      0x00000020,
+	0xE50,      0x00000022, 0xE50,      0x00000020,
+
+};
+
+void odm_read_and_config_mp_8822b_agc_tab(struct phy_dm_struct *dm)
+{
+	u32 i = 0;
+	u8 c_cond;
+	bool is_matched = true, is_skipped = false;
+	u32 array_len = sizeof(array_mp_8822b_agc_tab) / sizeof(u32);
+	u32 *array = array_mp_8822b_agc_tab;
+
+	u32 v1 = 0, v2 = 0, pre_v1 = 0, pre_v2 = 0;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "===> %s\n", __func__);
+
+	for (; (i + 1) < array_len; i = i + 2) {
+		v1 = array[i];
+		v2 = array[i + 1];
+
+		if (v1 & BIT(31)) { /* positive condition*/
+			c_cond = (u8)((v1 & (BIT(29) | BIT(28))) >> 28);
+			if (c_cond == COND_ENDIF) { /*end*/
+				is_matched = true;
+				is_skipped = false;
+				ODM_RT_TRACE(dm, ODM_COMP_INIT, "ENDIF\n");
+			} else if (c_cond == COND_ELSE) { /*else*/
+				is_matched = is_skipped ? false : true;
+				ODM_RT_TRACE(dm, ODM_COMP_INIT, "ELSE\n");
+			} else { /*if , else if*/
+				pre_v1 = v1;
+				pre_v2 = v2;
+				ODM_RT_TRACE(dm, ODM_COMP_INIT,
+					     "IF or ELSE IF\n");
+			}
+		} else if (v1 & BIT(30)) { /*negative condition*/
+			if (is_skipped) {
+				is_matched = false;
+				continue;
+			}
+
+			if (check_positive(dm, pre_v1, pre_v2, v1, v2)) {
+				is_matched = true;
+				is_skipped = true;
+			} else {
+				is_matched = false;
+				is_skipped = false;
+			}
+		} else if (is_matched) {
+			odm_config_bb_agc_8822b(dm, v1, MASKDWORD, v2);
+		}
+	}
+}
+
+u32 odm_get_version_mp_8822b_agc_tab(void) { return 67; }
+
+/******************************************************************************
+ *                           phy_reg.TXT
+ ******************************************************************************/
+
+static u32 array_mp_8822b_phy_reg[] = {
+	0x800,  0x9020D010, 0x804,  0x800181A0, 0x808,  0x0E028233,
+	0x80C,  0x10000013, 0x810,  0x21101263, 0x814,  0x020C3D10,
+	0x818,  0x84A10385, 0x81C,  0x1E1E081F, 0x820,  0x0001AAAA,
+	0x824,  0x00030FE0, 0x828,  0x0000CCCC, 0x82C,  0x75CB7010,
+	0x830,  0x79A0EA2A, 0x834,  0x072E6986, 0x838,  0x87766441,
+	0x83C,  0x9194B2B6, 0x840,  0x171740E0, 0x844,  0x4D3D7CDB,
+	0x848,  0x4AD0408B, 0x84C,  0x6AFBF7A5, 0x850,  0x28A74706,
+	0x854,  0x0001520C, 0x858,  0x4060C000, 0x85C,  0x74010160,
+	0x860,  0x68A7C321, 0x864,  0x79F27432, 0x868,  0x8CA7A314,
+	0x86C,  0x778C2878, 0x870,  0x77777777, 0x874,  0x27612C2E,
+	0x878,  0xC0003152, 0x87C,  0x5C8FC000, 0x880,  0x00000000,
+	0x884,  0x00000000, 0x888,  0x00000000, 0x88C,  0x00000000,
+	0x890,  0x00000000, 0x894,  0x00000000, 0x898,  0x00000000,
+	0x89C,  0x00000000, 0x8A0,  0x00000013, 0x8A4,  0x7F7F7F7F,
+	0x8A8,  0x2202033E, 0x8AC,  0xF00F000A, 0x8B0,  0x00000600,
+	0x8B4,  0x000FC080, 0x8B8,  0xEC0057F7, 0x8BC,  0xACB520A3,
+	0x8C0,  0xFFE04020, 0x8C4,  0x47C00000, 0x8C8,  0x000251A5,
+	0x8CC,  0x08108000, 0x8D0,  0x0000B800, 0x8D4,  0x860308A0,
+	0x8D8,  0x21095612, 0x8DC,  0x00000000, 0x8E0,  0x32D16777,
+	0x8E4,  0x4C098935, 0x8E8,  0xFFFFC42C, 0x8EC,  0x99999999,
+	0x8F0,  0x00009999, 0x8F4,  0x00D80FA1, 0x8F8,  0x40000080,
+	0x8FC,  0x00000130, 0x900,  0x00800000, 0x904,  0x00000000,
+	0x908,  0x00000000, 0x90C,  0xD3000000, 0x910,  0x0000FC00,
+	0x914,  0xC6380000, 0x918,  0x1C1028C0, 0x91C,  0x64B11A1C,
+	0x920,  0xE0767233, 0x924,  0x855A2500, 0x928,  0x4AB0E4E4,
+	0x92C,  0xFFFEB200, 0x930,  0xFFFFFFFE, 0x934,  0x001FFFFF,
+	0x938,  0x00008480, 0x93C,  0xE41C0642, 0x940,  0x0E470430,
+	0x944,  0x00000000, 0x948,  0xAC000000, 0x94C,  0x10000083,
+	0x950,  0x32010080, 0x954,  0x84510080, 0x958,  0x00000001,
+	0x95C,  0x04248000, 0x960,  0x00000000, 0x964,  0x00000000,
+	0x968,  0x00000000, 0x96C,  0x00000000, 0x970,  0x00001FFF,
+	0x974,  0x44000FFF, 0x978,  0x00000000, 0x97C,  0x00000000,
+	0x980,  0x00000000, 0x984,  0x00000000, 0x988,  0x00000000,
+	0x98C,  0x23440000, 0x990,  0x27100000, 0x994,  0xFFFF0100,
+	0x998,  0xFFFFFF5C, 0x99C,  0xFFFFFFFF, 0x9A0,  0x000000FF,
+	0x9A4,  0x80000088, 0x9A8,  0x0C2F0000, 0x9AC,  0x01560000,
+	0x9B0,  0x70000000, 0x9B4,  0x00000000, 0x9B8,  0x00000000,
+	0x9BC,  0x00000000, 0x9C0,  0x00000000, 0x9C4,  0x00000000,
+	0x9C8,  0x00000000, 0x9CC,  0x00000000, 0x9D0,  0x00000000,
+	0x9D4,  0x00000000, 0x9D8,  0x00000000, 0x9DC,  0x00000000,
+	0x9E0,  0x00000000, 0x9E4,  0x02000402, 0x9E8,  0x000022D4,
+	0x9EC,  0x00000000, 0x9F0,  0x00010080, 0x9F4,  0x00000000,
+	0x9F8,  0x00000000, 0x9FC,  0xEFFFF7F7, 0xA00,  0x00D047C8,
+	0xA04,  0x81FF800C, 0xA08,  0x8C838300, 0xA0C,  0x2E20100F,
+	0xA10,  0x9500BB78, 0xA14,  0x1114D028, 0xA18,  0x00881117,
+	0xA1C,  0x89140F00, 0xA20,  0x84880000, 0xA24,  0x384F6577,
+	0xA28,  0x00001525, 0xA2C,  0x00920000, 0xA70,  0x101FFF00,
+	0xA74,  0x00000148, 0xA78,  0x00000900, 0xA7C,  0x225B0606,
+	0xA80,  0x218675B2, 0xA84,  0x80208C00, 0xA88,  0x040C0000,
+	0xA8C,  0x12345678, 0xA90,  0xABCDEF00, 0xA94,  0x001B1B89,
+	0xA98,  0x030A0000, 0xA9C,  0x00060000, 0xAA0,  0x00000000,
+	0xAA4,  0x0004000F, 0xAA8,  0x00000200, 0xB00,  0xE1000440,
+	0xB04,  0x00800000, 0xB08,  0xFF02030B, 0xB0C,  0x01EAA406,
+	0xB10,  0x00030690, 0xB14,  0x006000FA, 0xB18,  0x00000002,
+	0xB1C,  0x00000002, 0xB20,  0x4B00001F, 0xB24,  0x4E8E3E40,
+	0xB28,  0x03020100, 0xB2C,  0x07060504, 0xB30,  0x0B0A0908,
+	0xB34,  0x0F0E0D0C, 0xB38,  0x13121110, 0xB3C,  0x0000003A,
+	0xB40,  0x00000000, 0xB44,  0x80000000, 0xB48,  0x3F0000FA,
+	0xB4C,  0x88C80020, 0xB50,  0x00000000, 0xB54,  0x00004241,
+	0xB58,  0xE0008208, 0xB5C,  0x41EFFFF9, 0xB60,  0x00000000,
+	0xB64,  0x00200063, 0xB68,  0x0000003A, 0xB6C,  0x00000102,
+	0xB70,  0x4E6D1870, 0xB74,  0x03020100, 0xB78,  0x07060504,
+	0xB7C,  0x0B0A0908, 0xB80,  0x0F0E0D0C, 0xB84,  0x13121110,
+	0xB88,  0x00000000, 0xB8C,  0x00000000, 0xC00,  0x00000007,
+	0xC04,  0x00000020, 0xC08,  0x60403231, 0xC0C,  0x00012345,
+	0xC10,  0x00000100, 0xC14,  0x01000000, 0xC18,  0x00000000,
+	0xC1C,  0x40040053, 0xC20,  0x40020103, 0xC24,  0x00000000,
+	0xC28,  0x00000000, 0xC2C,  0x00000000, 0xC30,  0x00000000,
+	0xC34,  0x00000000, 0xC38,  0x00000000, 0xC3C,  0x00000000,
+	0xC40,  0x00000000, 0xC44,  0x00000000, 0xC48,  0x00000000,
+	0xC4C,  0x00000000, 0xC50,  0x00000020, 0xC54,  0x00000000,
+	0xC58,  0xD8020402, 0xC5C,  0xDE000120, 0xC68,  0x5979993F,
+	0xC6C,  0x0000122A, 0xC70,  0x99795979, 0xC74,  0x99795979,
+	0xC78,  0x99799979, 0xC7C,  0x99791979, 0xC80,  0x19791979,
+	0xC84,  0x19791979, 0xC88,  0x00000000, 0xC8C,  0x07000000,
+	0xC94,  0x01000100, 0xC98,  0x201C8000, 0xC9C,  0x00000000,
+	0xCA0,  0x0000A555, 0xCA4,  0x08040201, 0xCA8,  0x80402010,
+	0xCAC,  0x00000000, 0xCB0,  0x77777777, 0xCB4,  0x00007777,
+	0xCB8,  0x00000000, 0xCBC,  0x00000000, 0xCC0,  0x00000000,
+	0xCC4,  0x00000000, 0xCC8,  0x00000000, 0xCCC,  0x00000000,
+	0xCD0,  0x00000000, 0xCD4,  0x00000000, 0xCD8,  0x00000000,
+	0xCDC,  0x00000000, 0xCE0,  0x00000000, 0xCE4,  0x00000000,
+	0xCE8,  0x00000000, 0xCEC,  0x00000000, 0xE00,  0x00000007,
+	0xE04,  0x00000020, 0xE08,  0x60403231, 0xE0C,  0x00012345,
+	0xE10,  0x00000100, 0xE14,  0x01000000, 0xE18,  0x00000000,
+	0xE1C,  0x40040053, 0xE20,  0x40020103, 0xE24,  0x00000000,
+	0xE28,  0x00000000, 0xE2C,  0x00000000, 0xE30,  0x00000000,
+	0xE34,  0x00000000, 0xE38,  0x00000000, 0xE3C,  0x00000000,
+	0xE40,  0x00000000, 0xE44,  0x00000000, 0xE48,  0x00000000,
+	0xE4C,  0x00000000, 0xE50,  0x00000020, 0xE54,  0x00000000,
+	0xE58,  0xD8020402, 0xE5C,  0xDE000120, 0xE68,  0x5979993F,
+	0xE6C,  0x0000122A, 0xE70,  0x99795979, 0xE74,  0x99795979,
+	0xE78,  0x99799979, 0xE7C,  0x99791979, 0xE80,  0x19791979,
+	0xE84,  0x19791979, 0xE88,  0x00000000, 0xE8C,  0x07000000,
+	0xE94,  0x01000100, 0xE98,  0x201C8000, 0xE9C,  0x00000000,
+	0xEA0,  0x0000A555, 0xEA4,  0x08040201, 0xEA8,  0x80402010,
+	0xEAC,  0x00000000, 0xEB0,  0x77777777, 0xEB4,  0x00007777,
+	0xEB8,  0x00000000, 0xEBC,  0x00000000, 0xEC0,  0x00000000,
+	0xEC4,  0x00000000, 0xEC8,  0x00000000, 0xECC,  0x00000000,
+	0xED0,  0x00000000, 0xED4,  0x00000000, 0xED8,  0x00000000,
+	0xEDC,  0x00000000, 0xEE0,  0x00000000, 0xEE4,  0x00000000,
+	0xEE8,  0x00000000, 0xEEC,  0x00000000, 0x1900, 0x00000000,
+	0x1904, 0x00238000, 0x1908, 0x00000000, 0x190C, 0x00000000,
+	0x1910, 0x00000000, 0x1914, 0x00000000, 0x1918, 0x00000000,
+	0x191C, 0x00000000, 0x1920, 0x00000000, 0x1924, 0x00000000,
+	0x1928, 0x00000000, 0x192C, 0x00000000, 0x1930, 0x00000000,
+	0x1934, 0x00000000, 0x1938, 0x00000000, 0x193C, 0x00000000,
+	0x1940, 0x00000000, 0x1944, 0x00000000, 0x1948, 0x00000000,
+	0x194C, 0x00000000, 0x1950, 0x00000000, 0x1954, 0x00000000,
+	0x1958, 0x00000000, 0x195C, 0x00000000, 0x1960, 0x00000000,
+	0x1964, 0x00000000, 0x1968, 0x00000000, 0x196C, 0x00000000,
+	0x1970, 0x00000000, 0x1974, 0x00000000, 0x1978, 0x00000000,
+	0x197C, 0x00000000, 0x1980, 0x00000000, 0x1984, 0x03000000,
+	0x1988, 0x21401E88, 0x198C, 0x00004000, 0x1990, 0x00000000,
+	0x1994, 0x00000000, 0x1998, 0x00000053, 0x199C, 0x00000000,
+	0x19A0, 0x00000000, 0x19A4, 0x00000000, 0x19A8, 0x00000000,
+	0x19AC, 0x0E47E47F, 0x19B0, 0x00000000, 0x19B4, 0x0E47E47F,
+	0x19B8, 0x00000000, 0x19BC, 0x00000000, 0x19C0, 0x00000000,
+	0x19C4, 0x00000000, 0x19C8, 0x00000000, 0x19CC, 0x00000000,
+	0x19D0, 0x00000000, 0x19D4, 0xAAAAAAAA, 0x19D8, 0x00000AAA,
+	0x19DC, 0x133E0F37, 0x19E0, 0x00000000, 0x19E4, 0x00000000,
+	0x19E8, 0x00000000, 0x19EC, 0x00000000, 0x19F0, 0x00000000,
+	0x19F4, 0x00000000, 0x19F8, 0x01A00000, 0x19FC, 0x00000000,
+	0x1C00, 0x00000100, 0x1C04, 0x01000000, 0x1C08, 0x00000100,
+	0x1C0C, 0x01000000, 0x1C10, 0x00000100, 0x1C14, 0x01000000,
+	0x1C18, 0x00000100, 0x1C1C, 0x01000000, 0x1C20, 0x00000100,
+	0x1C24, 0x01000000, 0x1C28, 0x00000100, 0x1C2C, 0x01000000,
+	0x1C30, 0x00000100, 0x1C34, 0x01000000, 0x1C38, 0x00000000,
+	0x1C3C, 0x00000000, 0x1C40, 0x000C0100, 0x1C44, 0x000000F3,
+	0x1C48, 0x1A8249A8, 0x1C4C, 0x1461C826, 0x1C50, 0x0001469E,
+	0x1C54, 0x58D158D1, 0x1C58, 0x04490088, 0x1C5C, 0x04004400,
+	0x1C60, 0x00000000, 0x1C64, 0x04004400, 0x1C68, 0x00000100,
+	0x1C6C, 0x01000000, 0x1C70, 0x00000100, 0x1C74, 0x01000000,
+	0x1C78, 0x00000000, 0x1C7C, 0x00000010, 0x1C80, 0x5FFF5FFF,
+	0x1C84, 0x5FFF5FFF, 0x1C88, 0x5FFF5FFF, 0x1C8C, 0x5FFF5FFF,
+	0x1C90, 0x5FFF5FFF, 0x1C94, 0x5FFF5FFF, 0x1C98, 0x5FFF5FFF,
+	0x1C9C, 0x5FFF5FFF, 0x1CA0, 0x00000100, 0x1CA4, 0x01000000,
+	0x1CA8, 0x00000100, 0x1CAC, 0x5FFF5FFF, 0x1CB0, 0x00000100,
+	0x1CB4, 0x01000000, 0x1CB8, 0x00000000, 0x1CBC, 0x00000000,
+	0x1CC0, 0x00000100, 0x1CC4, 0x01000000, 0x1CC8, 0x00000100,
+	0x1CCC, 0x01000000, 0x1CD0, 0x00000100, 0x1CD4, 0x01000000,
+	0x1CD8, 0x00000100, 0x1CDC, 0x01000000, 0x1CE0, 0x00000100,
+	0x1CE4, 0x01000000, 0x1CE8, 0x00000100, 0x1CEC, 0x01000000,
+	0x1CF0, 0x00000100, 0x1CF4, 0x01000000, 0x1CF8, 0x00000000,
+	0x1CFC, 0x00000000, 0xC60,  0x70038040, 0xC60,  0x70038040,
+	0xC60,  0x70146040, 0xC60,  0x70246040, 0xC60,  0x70346040,
+	0xC60,  0x70446040, 0xC60,  0x70532040, 0xC60,  0x70646040,
+	0xC60,  0x70738040, 0xC60,  0x70838040, 0xC60,  0x70938040,
+	0xC60,  0x70A38040, 0xC60,  0x70B36040, 0xC60,  0x70C06040,
+	0xC60,  0x70D06040, 0xC60,  0x70E76040, 0xC60,  0x70F06040,
+	0xE60,  0x70038040, 0xE60,  0x70038040, 0xE60,  0x70146040,
+	0xE60,  0x70246040, 0xE60,  0x70346040, 0xE60,  0x70446040,
+	0xE60,  0x70532040, 0xE60,  0x70646040, 0xE60,  0x70738040,
+	0xE60,  0x70838040, 0xE60,  0x70938040, 0xE60,  0x70A38040,
+	0xE60,  0x70B36040, 0xE60,  0x70C06040, 0xE60,  0x70D06040,
+	0xE60,  0x70E76040, 0xE60,  0x70F06040, 0xC64,  0x00800000,
+	0xC64,  0x08800001, 0xC64,  0x00800002, 0xC64,  0x00800003,
+	0xC64,  0x00800004, 0xC64,  0x00800005, 0xC64,  0x00800006,
+	0xC64,  0x08800007, 0xC64,  0x00004000, 0xE64,  0x00800000,
+	0xE64,  0x08800001, 0xE64,  0x00800002, 0xE64,  0x00800003,
+	0xE64,  0x00800004, 0xE64,  0x00800005, 0xE64,  0x00800006,
+	0xE64,  0x08800007, 0xE64,  0x00004000, 0x1B00, 0xF8000008,
+	0x1B00, 0xF80A7008, 0x1B00, 0xF8015008, 0x1B00, 0xF8000008,
+	0x1B04, 0xE24629D2, 0x1B08, 0x00000080, 0x1B0C, 0x00000000,
+	0x1B10, 0x00010C00, 0x1B14, 0x00000000, 0x1B18, 0x00292903,
+	0x1B1C, 0xA2193C32, 0x1B20, 0x01840008, 0x1B24, 0x01860008,
+	0x1B28, 0x80060300, 0x1B2C, 0x00000003, 0x1B30, 0x20000000,
+	0x1B34, 0x00000800, 0x1B3C, 0x20000000, 0x1BC0, 0x01000000,
+	0x1BCC, 0x00000000, 0x1B00, 0xF800000A, 0x1B1C, 0xA2193C32,
+	0x1B20, 0x01840008, 0x1B24, 0x01860008, 0x1B28, 0x80060300,
+	0x1B2C, 0x00000003, 0x1B30, 0x20000000, 0x1B34, 0x00000800,
+	0x1B3C, 0x20000000, 0x1BC0, 0x01000000, 0x1BCC, 0x00000000,
+	0x1B00, 0xF8000000, 0x1B80, 0x00000007, 0x1B80, 0x090A0005,
+	0x1B80, 0x090A0007, 0x1B80, 0x0FFE0015, 0x1B80, 0x0FFE0017,
+	0x1B80, 0x00220025, 0x1B80, 0x00220027, 0x1B80, 0x00040035,
+	0x1B80, 0x00040037, 0x1B80, 0x05C00045, 0x1B80, 0x05C00047,
+	0x1B80, 0x00070055, 0x1B80, 0x00070057, 0x1B80, 0x64000065,
+	0x1B80, 0x64000067, 0x1B80, 0x00020075, 0x1B80, 0x00020077,
+	0x1B80, 0x00080085, 0x1B80, 0x00080087, 0x1B80, 0x80000095,
+	0x1B80, 0x80000097, 0x1B80, 0x090800A5, 0x1B80, 0x090800A7,
+	0x1B80, 0x0F0200B5, 0x1B80, 0x0F0200B7, 0x1B80, 0x002200C5,
+	0x1B80, 0x002200C7, 0x1B80, 0x000400D5, 0x1B80, 0x000400D7,
+	0x1B80, 0x05C000E5, 0x1B80, 0x05C000E7, 0x1B80, 0x000700F5,
+	0x1B80, 0x000700F7, 0x1B80, 0x64020105, 0x1B80, 0x64020107,
+	0x1B80, 0x00020115, 0x1B80, 0x00020117, 0x1B80, 0x00040125,
+	0x1B80, 0x00040127, 0x1B80, 0x4A000135, 0x1B80, 0x4A000137,
+	0x1B80, 0x4B040145, 0x1B80, 0x4B040147, 0x1B80, 0x85030155,
+	0x1B80, 0x85030157, 0x1B80, 0x40090165, 0x1B80, 0x40090167,
+	0x1B80, 0xE0210175, 0x1B80, 0xE0210177, 0x1B80, 0x4B050185,
+	0x1B80, 0x4B050187, 0x1B80, 0x86030195, 0x1B80, 0x86030197,
+	0x1B80, 0x400B01A5, 0x1B80, 0x400B01A7, 0x1B80, 0xE02101B5,
+	0x1B80, 0xE02101B7, 0x1B80, 0x4B0001C5, 0x1B80, 0x4B0001C7,
+	0x1B80, 0x000701D5, 0x1B80, 0x000701D7, 0x1B80, 0x4C0001E5,
+	0x1B80, 0x4C0001E7, 0x1B80, 0x000401F5, 0x1B80, 0x000401F7,
+	0x1B80, 0x30000205, 0x1B80, 0x30000207, 0x1B80, 0xFE000215,
+	0x1B80, 0xFE000217, 0x1B80, 0xFF000225, 0x1B80, 0xFF000227,
+	0x1B80, 0xE1750235, 0x1B80, 0xE1750237, 0x1B80, 0xF00D0245,
+	0x1B80, 0xF00D0247, 0x1B80, 0xF10D0255, 0x1B80, 0xF10D0257,
+	0x1B80, 0xF20D0265, 0x1B80, 0xF20D0267, 0x1B80, 0xF30D0275,
+	0x1B80, 0xF30D0277, 0x1B80, 0xF40D0285, 0x1B80, 0xF40D0287,
+	0x1B80, 0xF50D0295, 0x1B80, 0xF50D0297, 0x1B80, 0xF60D02A5,
+	0x1B80, 0xF60D02A7, 0x1B80, 0xF70D02B5, 0x1B80, 0xF70D02B7,
+	0x1B80, 0xF80D02C5, 0x1B80, 0xF80D02C7, 0x1B80, 0xF90D02D5,
+	0x1B80, 0xF90D02D7, 0x1B80, 0xFA0D02E5, 0x1B80, 0xFA0D02E7,
+	0x1B80, 0xFB0D02F5, 0x1B80, 0xFB0D02F7, 0x1B80, 0x00010305,
+	0x1B80, 0x00010307, 0x1B80, 0x303D0315, 0x1B80, 0x303D0317,
+	0x1B80, 0x30550325, 0x1B80, 0x30550327, 0x1B80, 0x30A00335,
+	0x1B80, 0x30A00337, 0x1B80, 0x30A30345, 0x1B80, 0x30A30347,
+	0x1B80, 0x30570355, 0x1B80, 0x30570357, 0x1B80, 0x30620365,
+	0x1B80, 0x30620367, 0x1B80, 0x306D0375, 0x1B80, 0x306D0377,
+	0x1B80, 0x30AD0385, 0x1B80, 0x30AD0387, 0x1B80, 0x30A70395,
+	0x1B80, 0x30A70397, 0x1B80, 0x30BB03A5, 0x1B80, 0x30BB03A7,
+	0x1B80, 0x30C603B5, 0x1B80, 0x30C603B7, 0x1B80, 0x30D103C5,
+	0x1B80, 0x30D103C7, 0x1B80, 0xE11403D5, 0x1B80, 0xE11403D7,
+	0x1B80, 0x4D0403E5, 0x1B80, 0x4D0403E7, 0x1B80, 0x208003F5,
+	0x1B80, 0x208003F7, 0x1B80, 0x00000405, 0x1B80, 0x00000407,
+	0x1B80, 0x4D000415, 0x1B80, 0x4D000417, 0x1B80, 0x55070425,
+	0x1B80, 0x55070427, 0x1B80, 0xE10C0435, 0x1B80, 0xE10C0437,
+	0x1B80, 0xE10C0445, 0x1B80, 0xE10C0447, 0x1B80, 0x4D040455,
+	0x1B80, 0x4D040457, 0x1B80, 0x20880465, 0x1B80, 0x20880467,
+	0x1B80, 0x02000475, 0x1B80, 0x02000477, 0x1B80, 0x4D000485,
+	0x1B80, 0x4D000487, 0x1B80, 0x550F0495, 0x1B80, 0x550F0497,
+	0x1B80, 0xE10C04A5, 0x1B80, 0xE10C04A7, 0x1B80, 0x4F0204B5,
+	0x1B80, 0x4F0204B7, 0x1B80, 0x4E0004C5, 0x1B80, 0x4E0004C7,
+	0x1B80, 0x530204D5, 0x1B80, 0x530204D7, 0x1B80, 0x520104E5,
+	0x1B80, 0x520104E7, 0x1B80, 0xE11004F5, 0x1B80, 0xE11004F7,
+	0x1B80, 0x4D080505, 0x1B80, 0x4D080507, 0x1B80, 0x57100515,
+	0x1B80, 0x57100517, 0x1B80, 0x57000525, 0x1B80, 0x57000527,
+	0x1B80, 0x4D000535, 0x1B80, 0x4D000537, 0x1B80, 0x00010545,
+	0x1B80, 0x00010547, 0x1B80, 0xE1140555, 0x1B80, 0xE1140557,
+	0x1B80, 0x00010565, 0x1B80, 0x00010567, 0x1B80, 0x30770575,
+	0x1B80, 0x30770577, 0x1B80, 0x00230585, 0x1B80, 0x00230587,
+	0x1B80, 0xE1680595, 0x1B80, 0xE1680597, 0x1B80, 0x000205A5,
+	0x1B80, 0x000205A7, 0x1B80, 0x54E905B5, 0x1B80, 0x54E905B7,
+	0x1B80, 0x0BA605C5, 0x1B80, 0x0BA605C7, 0x1B80, 0x002305D5,
+	0x1B80, 0x002305D7, 0x1B80, 0xE16805E5, 0x1B80, 0xE16805E7,
+	0x1B80, 0x000205F5, 0x1B80, 0x000205F7, 0x1B80, 0x4D300605,
+	0x1B80, 0x4D300607, 0x1B80, 0x30900615, 0x1B80, 0x30900617,
+	0x1B80, 0x30730625, 0x1B80, 0x30730627, 0x1B80, 0x00220635,
+	0x1B80, 0x00220637, 0x1B80, 0xE1680645, 0x1B80, 0xE1680647,
+	0x1B80, 0x00020655, 0x1B80, 0x00020657, 0x1B80, 0x54E80665,
+	0x1B80, 0x54E80667, 0x1B80, 0x0BA60675, 0x1B80, 0x0BA60677,
+	0x1B80, 0x00220685, 0x1B80, 0x00220687, 0x1B80, 0xE1680695,
+	0x1B80, 0xE1680697, 0x1B80, 0x000206A5, 0x1B80, 0x000206A7,
+	0x1B80, 0x4D3006B5, 0x1B80, 0x4D3006B7, 0x1B80, 0x309006C5,
+	0x1B80, 0x309006C7, 0x1B80, 0x63F106D5, 0x1B80, 0x63F106D7,
+	0x1B80, 0xE11406E5, 0x1B80, 0xE11406E7, 0x1B80, 0xE16806F5,
+	0x1B80, 0xE16806F7, 0x1B80, 0x63F40705, 0x1B80, 0x63F40707,
+	0x1B80, 0xE1140715, 0x1B80, 0xE1140717, 0x1B80, 0xE1680725,
+	0x1B80, 0xE1680727, 0x1B80, 0x0BA80735, 0x1B80, 0x0BA80737,
+	0x1B80, 0x63F80745, 0x1B80, 0x63F80747, 0x1B80, 0xE1140755,
+	0x1B80, 0xE1140757, 0x1B80, 0xE1680765, 0x1B80, 0xE1680767,
+	0x1B80, 0x0BA90775, 0x1B80, 0x0BA90777, 0x1B80, 0x63FC0785,
+	0x1B80, 0x63FC0787, 0x1B80, 0xE1140795, 0x1B80, 0xE1140797,
+	0x1B80, 0xE16807A5, 0x1B80, 0xE16807A7, 0x1B80, 0x63FF07B5,
+	0x1B80, 0x63FF07B7, 0x1B80, 0xE11407C5, 0x1B80, 0xE11407C7,
+	0x1B80, 0xE16807D5, 0x1B80, 0xE16807D7, 0x1B80, 0x630007E5,
+	0x1B80, 0x630007E7, 0x1B80, 0xE11407F5, 0x1B80, 0xE11407F7,
+	0x1B80, 0xE1680805, 0x1B80, 0xE1680807, 0x1B80, 0x63030815,
+	0x1B80, 0x63030817, 0x1B80, 0xE1140825, 0x1B80, 0xE1140827,
+	0x1B80, 0xE1680835, 0x1B80, 0xE1680837, 0x1B80, 0xF4D40845,
+	0x1B80, 0xF4D40847, 0x1B80, 0x63070855, 0x1B80, 0x63070857,
+	0x1B80, 0xE1140865, 0x1B80, 0xE1140867, 0x1B80, 0xE1680875,
+	0x1B80, 0xE1680877, 0x1B80, 0xF5DB0885, 0x1B80, 0xF5DB0887,
+	0x1B80, 0x630B0895, 0x1B80, 0x630B0897, 0x1B80, 0xE11408A5,
+	0x1B80, 0xE11408A7, 0x1B80, 0xE16808B5, 0x1B80, 0xE16808B7,
+	0x1B80, 0x630E08C5, 0x1B80, 0x630E08C7, 0x1B80, 0xE11408D5,
+	0x1B80, 0xE11408D7, 0x1B80, 0xE16808E5, 0x1B80, 0xE16808E7,
+	0x1B80, 0x4D3008F5, 0x1B80, 0x4D3008F7, 0x1B80, 0x55010905,
+	0x1B80, 0x55010907, 0x1B80, 0x57040915, 0x1B80, 0x57040917,
+	0x1B80, 0x57000925, 0x1B80, 0x57000927, 0x1B80, 0x96000935,
+	0x1B80, 0x96000937, 0x1B80, 0x57080945, 0x1B80, 0x57080947,
+	0x1B80, 0x57000955, 0x1B80, 0x57000957, 0x1B80, 0x95000965,
+	0x1B80, 0x95000967, 0x1B80, 0x4D000975, 0x1B80, 0x4D000977,
+	0x1B80, 0x6C070985, 0x1B80, 0x6C070987, 0x1B80, 0x7B200995,
+	0x1B80, 0x7B200997, 0x1B80, 0x7A0009A5, 0x1B80, 0x7A0009A7,
+	0x1B80, 0x790009B5, 0x1B80, 0x790009B7, 0x1B80, 0x7F2009C5,
+	0x1B80, 0x7F2009C7, 0x1B80, 0x7E0009D5, 0x1B80, 0x7E0009D7,
+	0x1B80, 0x7D0009E5, 0x1B80, 0x7D0009E7, 0x1B80, 0x000109F5,
+	0x1B80, 0x000109F7, 0x1B80, 0x62850A05, 0x1B80, 0x62850A07,
+	0x1B80, 0xE1140A15, 0x1B80, 0xE1140A17, 0x1B80, 0x00010A25,
+	0x1B80, 0x00010A27, 0x1B80, 0x5C320A35, 0x1B80, 0x5C320A37,
+	0x1B80, 0xE1640A45, 0x1B80, 0xE1640A47, 0x1B80, 0xE1420A55,
+	0x1B80, 0xE1420A57, 0x1B80, 0x00010A65, 0x1B80, 0x00010A67,
+	0x1B80, 0x5C320A75, 0x1B80, 0x5C320A77, 0x1B80, 0x63F40A85,
+	0x1B80, 0x63F40A87, 0x1B80, 0x62850A95, 0x1B80, 0x62850A97,
+	0x1B80, 0x0BB00AA5, 0x1B80, 0x0BB00AA7, 0x1B80, 0xE1140AB5,
+	0x1B80, 0xE1140AB7, 0x1B80, 0xE1680AC5, 0x1B80, 0xE1680AC7,
+	0x1B80, 0x5C320AD5, 0x1B80, 0x5C320AD7, 0x1B80, 0x63FC0AE5,
+	0x1B80, 0x63FC0AE7, 0x1B80, 0x62850AF5, 0x1B80, 0x62850AF7,
+	0x1B80, 0x0BB10B05, 0x1B80, 0x0BB10B07, 0x1B80, 0xE1140B15,
+	0x1B80, 0xE1140B17, 0x1B80, 0xE1680B25, 0x1B80, 0xE1680B27,
+	0x1B80, 0x63030B35, 0x1B80, 0x63030B37, 0x1B80, 0xE1140B45,
+	0x1B80, 0xE1140B47, 0x1B80, 0xE1680B55, 0x1B80, 0xE1680B57,
+	0x1B80, 0xF7040B65, 0x1B80, 0xF7040B67, 0x1B80, 0x630B0B75,
+	0x1B80, 0x630B0B77, 0x1B80, 0xE1140B85, 0x1B80, 0xE1140B87,
+	0x1B80, 0xE1680B95, 0x1B80, 0xE1680B97, 0x1B80, 0x00010BA5,
+	0x1B80, 0x00010BA7, 0x1B80, 0x30DF0BB5, 0x1B80, 0x30DF0BB7,
+	0x1B80, 0x00230BC5, 0x1B80, 0x00230BC7, 0x1B80, 0xE16D0BD5,
+	0x1B80, 0xE16D0BD7, 0x1B80, 0x00020BE5, 0x1B80, 0x00020BE7,
+	0x1B80, 0x54E90BF5, 0x1B80, 0x54E90BF7, 0x1B80, 0x0BA60C05,
+	0x1B80, 0x0BA60C07, 0x1B80, 0x00230C15, 0x1B80, 0x00230C17,
+	0x1B80, 0xE16D0C25, 0x1B80, 0xE16D0C27, 0x1B80, 0x00020C35,
+	0x1B80, 0x00020C37, 0x1B80, 0x4D100C45, 0x1B80, 0x4D100C47,
+	0x1B80, 0x30900C55, 0x1B80, 0x30900C57, 0x1B80, 0x30D90C65,
+	0x1B80, 0x30D90C67, 0x1B80, 0x00220C75, 0x1B80, 0x00220C77,
+	0x1B80, 0xE16D0C85, 0x1B80, 0xE16D0C87, 0x1B80, 0x00020C95,
+	0x1B80, 0x00020C97, 0x1B80, 0x54E80CA5, 0x1B80, 0x54E80CA7,
+	0x1B80, 0x0BA60CB5, 0x1B80, 0x0BA60CB7, 0x1B80, 0x00220CC5,
+	0x1B80, 0x00220CC7, 0x1B80, 0xE16D0CD5, 0x1B80, 0xE16D0CD7,
+	0x1B80, 0x00020CE5, 0x1B80, 0x00020CE7, 0x1B80, 0x4D100CF5,
+	0x1B80, 0x4D100CF7, 0x1B80, 0x30900D05, 0x1B80, 0x30900D07,
+	0x1B80, 0x5C320D15, 0x1B80, 0x5C320D17, 0x1B80, 0x54F00D25,
+	0x1B80, 0x54F00D27, 0x1B80, 0x67F10D35, 0x1B80, 0x67F10D37,
+	0x1B80, 0xE1420D45, 0x1B80, 0xE1420D47, 0x1B80, 0xE16D0D55,
+	0x1B80, 0xE16D0D57, 0x1B80, 0x67F40D65, 0x1B80, 0x67F40D67,
+	0x1B80, 0xE1420D75, 0x1B80, 0xE1420D77, 0x1B80, 0xE16D0D85,
+	0x1B80, 0xE16D0D87, 0x1B80, 0x5C320D95, 0x1B80, 0x5C320D97,
+	0x1B80, 0x54F10DA5, 0x1B80, 0x54F10DA7, 0x1B80, 0x0BA80DB5,
+	0x1B80, 0x0BA80DB7, 0x1B80, 0x67F80DC5, 0x1B80, 0x67F80DC7,
+	0x1B80, 0xE1420DD5, 0x1B80, 0xE1420DD7, 0x1B80, 0xE16D0DE5,
+	0x1B80, 0xE16D0DE7, 0x1B80, 0x5C320DF5, 0x1B80, 0x5C320DF7,
+	0x1B80, 0x54F10E05, 0x1B80, 0x54F10E07, 0x1B80, 0x0BA90E15,
+	0x1B80, 0x0BA90E17, 0x1B80, 0x67FC0E25, 0x1B80, 0x67FC0E27,
+	0x1B80, 0xE1420E35, 0x1B80, 0xE1420E37, 0x1B80, 0xE16D0E45,
+	0x1B80, 0xE16D0E47, 0x1B80, 0x67FF0E55, 0x1B80, 0x67FF0E57,
+	0x1B80, 0xE1420E65, 0x1B80, 0xE1420E67, 0x1B80, 0xE16D0E75,
+	0x1B80, 0xE16D0E77, 0x1B80, 0x5C320E85, 0x1B80, 0x5C320E87,
+	0x1B80, 0x54F20E95, 0x1B80, 0x54F20E97, 0x1B80, 0x67000EA5,
+	0x1B80, 0x67000EA7, 0x1B80, 0xE1420EB5, 0x1B80, 0xE1420EB7,
+	0x1B80, 0xE16D0EC5, 0x1B80, 0xE16D0EC7, 0x1B80, 0x67030ED5,
+	0x1B80, 0x67030ED7, 0x1B80, 0xE1420EE5, 0x1B80, 0xE1420EE7,
+	0x1B80, 0xE16D0EF5, 0x1B80, 0xE16D0EF7, 0x1B80, 0xF9CC0F05,
+	0x1B80, 0xF9CC0F07, 0x1B80, 0x67070F15, 0x1B80, 0x67070F17,
+	0x1B80, 0xE1420F25, 0x1B80, 0xE1420F27, 0x1B80, 0xE16D0F35,
+	0x1B80, 0xE16D0F37, 0x1B80, 0xFAD30F45, 0x1B80, 0xFAD30F47,
+	0x1B80, 0x5C320F55, 0x1B80, 0x5C320F57, 0x1B80, 0x54F30F65,
+	0x1B80, 0x54F30F67, 0x1B80, 0x670B0F75, 0x1B80, 0x670B0F77,
+	0x1B80, 0xE1420F85, 0x1B80, 0xE1420F87, 0x1B80, 0xE16D0F95,
+	0x1B80, 0xE16D0F97, 0x1B80, 0x670E0FA5, 0x1B80, 0x670E0FA7,
+	0x1B80, 0xE1420FB5, 0x1B80, 0xE1420FB7, 0x1B80, 0xE16D0FC5,
+	0x1B80, 0xE16D0FC7, 0x1B80, 0x4D100FD5, 0x1B80, 0x4D100FD7,
+	0x1B80, 0x30900FE5, 0x1B80, 0x30900FE7, 0x1B80, 0x00010FF5,
+	0x1B80, 0x00010FF7, 0x1B80, 0x7B241005, 0x1B80, 0x7B241007,
+	0x1B80, 0x7A401015, 0x1B80, 0x7A401017, 0x1B80, 0x79001025,
+	0x1B80, 0x79001027, 0x1B80, 0x55031035, 0x1B80, 0x55031037,
+	0x1B80, 0x310C1045, 0x1B80, 0x310C1047, 0x1B80, 0x7B1C1055,
+	0x1B80, 0x7B1C1057, 0x1B80, 0x7A401065, 0x1B80, 0x7A401067,
+	0x1B80, 0x550B1075, 0x1B80, 0x550B1077, 0x1B80, 0x310C1085,
+	0x1B80, 0x310C1087, 0x1B80, 0x7B201095, 0x1B80, 0x7B201097,
+	0x1B80, 0x7A0010A5, 0x1B80, 0x7A0010A7, 0x1B80, 0x551310B5,
+	0x1B80, 0x551310B7, 0x1B80, 0x740110C5, 0x1B80, 0x740110C7,
+	0x1B80, 0x740010D5, 0x1B80, 0x740010D7, 0x1B80, 0x8E0010E5,
+	0x1B80, 0x8E0010E7, 0x1B80, 0x000110F5, 0x1B80, 0x000110F7,
+	0x1B80, 0x57021105, 0x1B80, 0x57021107, 0x1B80, 0x57001115,
+	0x1B80, 0x57001117, 0x1B80, 0x97001125, 0x1B80, 0x97001127,
+	0x1B80, 0x00011135, 0x1B80, 0x00011137, 0x1B80, 0x4F781145,
+	0x1B80, 0x4F781147, 0x1B80, 0x53881155, 0x1B80, 0x53881157,
+	0x1B80, 0xE1221165, 0x1B80, 0xE1221167, 0x1B80, 0x54801175,
+	0x1B80, 0x54801177, 0x1B80, 0x54001185, 0x1B80, 0x54001187,
+	0x1B80, 0xE1221195, 0x1B80, 0xE1221197, 0x1B80, 0x548111A5,
+	0x1B80, 0x548111A7, 0x1B80, 0x540011B5, 0x1B80, 0x540011B7,
+	0x1B80, 0xE12211C5, 0x1B80, 0xE12211C7, 0x1B80, 0x548211D5,
+	0x1B80, 0x548211D7, 0x1B80, 0x540011E5, 0x1B80, 0x540011E7,
+	0x1B80, 0xE12D11F5, 0x1B80, 0xE12D11F7, 0x1B80, 0xBF1D1205,
+	0x1B80, 0xBF1D1207, 0x1B80, 0x301D1215, 0x1B80, 0x301D1217,
+	0x1B80, 0xE1001225, 0x1B80, 0xE1001227, 0x1B80, 0xE1051235,
+	0x1B80, 0xE1051237, 0x1B80, 0xE1091245, 0x1B80, 0xE1091247,
+	0x1B80, 0xE1101255, 0x1B80, 0xE1101257, 0x1B80, 0xE1641265,
+	0x1B80, 0xE1641267, 0x1B80, 0x55131275, 0x1B80, 0x55131277,
+	0x1B80, 0xE10C1285, 0x1B80, 0xE10C1287, 0x1B80, 0x55151295,
+	0x1B80, 0x55151297, 0x1B80, 0xE11012A5, 0x1B80, 0xE11012A7,
+	0x1B80, 0xE16412B5, 0x1B80, 0xE16412B7, 0x1B80, 0x000112C5,
+	0x1B80, 0x000112C7, 0x1B80, 0x54BF12D5, 0x1B80, 0x54BF12D7,
+	0x1B80, 0x54C012E5, 0x1B80, 0x54C012E7, 0x1B80, 0x54A312F5,
+	0x1B80, 0x54A312F7, 0x1B80, 0x54C11305, 0x1B80, 0x54C11307,
+	0x1B80, 0x54A41315, 0x1B80, 0x54A41317, 0x1B80, 0x4C181325,
+	0x1B80, 0x4C181327, 0x1B80, 0xBF071335, 0x1B80, 0xBF071337,
+	0x1B80, 0x54C21345, 0x1B80, 0x54C21347, 0x1B80, 0x54A41355,
+	0x1B80, 0x54A41357, 0x1B80, 0xBF041365, 0x1B80, 0xBF041367,
+	0x1B80, 0x54C11375, 0x1B80, 0x54C11377, 0x1B80, 0x54A31385,
+	0x1B80, 0x54A31387, 0x1B80, 0xBF011395, 0x1B80, 0xBF011397,
+	0x1B80, 0xE17213A5, 0x1B80, 0xE17213A7, 0x1B80, 0x54DF13B5,
+	0x1B80, 0x54DF13B7, 0x1B80, 0x000113C5, 0x1B80, 0x000113C7,
+	0x1B80, 0x54BF13D5, 0x1B80, 0x54BF13D7, 0x1B80, 0x54E513E5,
+	0x1B80, 0x54E513E7, 0x1B80, 0x050A13F5, 0x1B80, 0x050A13F7,
+	0x1B80, 0x54DF1405, 0x1B80, 0x54DF1407, 0x1B80, 0x00011415,
+	0x1B80, 0x00011417, 0x1B80, 0x7F201425, 0x1B80, 0x7F201427,
+	0x1B80, 0x7E001435, 0x1B80, 0x7E001437, 0x1B80, 0x7D001445,
+	0x1B80, 0x7D001447, 0x1B80, 0x55011455, 0x1B80, 0x55011457,
+	0x1B80, 0x5C311465, 0x1B80, 0x5C311467, 0x1B80, 0xE10C1475,
+	0x1B80, 0xE10C1477, 0x1B80, 0xE1101485, 0x1B80, 0xE1101487,
+	0x1B80, 0x54801495, 0x1B80, 0x54801497, 0x1B80, 0x540014A5,
+	0x1B80, 0x540014A7, 0x1B80, 0xE10C14B5, 0x1B80, 0xE10C14B7,
+	0x1B80, 0xE11014C5, 0x1B80, 0xE11014C7, 0x1B80, 0x548114D5,
+	0x1B80, 0x548114D7, 0x1B80, 0x540014E5, 0x1B80, 0x540014E7,
+	0x1B80, 0xE10C14F5, 0x1B80, 0xE10C14F7, 0x1B80, 0xE1101505,
+	0x1B80, 0xE1101507, 0x1B80, 0x54821515, 0x1B80, 0x54821517,
+	0x1B80, 0x54001525, 0x1B80, 0x54001527, 0x1B80, 0xE12D1535,
+	0x1B80, 0xE12D1537, 0x1B80, 0xBFE91545, 0x1B80, 0xBFE91547,
+	0x1B80, 0x301D1555, 0x1B80, 0x301D1557, 0x1B80, 0x00231565,
+	0x1B80, 0x00231567, 0x1B80, 0x7B201575, 0x1B80, 0x7B201577,
+	0x1B80, 0x7A001585, 0x1B80, 0x7A001587, 0x1B80, 0x79001595,
+	0x1B80, 0x79001597, 0x1B80, 0xE16815A5, 0x1B80, 0xE16815A7,
+	0x1B80, 0x000215B5, 0x1B80, 0x000215B7, 0x1B80, 0x000115C5,
+	0x1B80, 0x000115C7, 0x1B80, 0x002215D5, 0x1B80, 0x002215D7,
+	0x1B80, 0x7B2015E5, 0x1B80, 0x7B2015E7, 0x1B80, 0x7A0015F5,
+	0x1B80, 0x7A0015F7, 0x1B80, 0x79001605, 0x1B80, 0x79001607,
+	0x1B80, 0xE1681615, 0x1B80, 0xE1681617, 0x1B80, 0x00021625,
+	0x1B80, 0x00021627, 0x1B80, 0x00011635, 0x1B80, 0x00011637,
+	0x1B80, 0x549F1645, 0x1B80, 0x549F1647, 0x1B80, 0x54FF1655,
+	0x1B80, 0x54FF1657, 0x1B80, 0x54001665, 0x1B80, 0x54001667,
+	0x1B80, 0x00011675, 0x1B80, 0x00011677, 0x1B80, 0x5C311685,
+	0x1B80, 0x5C311687, 0x1B80, 0x07141695, 0x1B80, 0x07141697,
+	0x1B80, 0x540016A5, 0x1B80, 0x540016A7, 0x1B80, 0x5C3216B5,
+	0x1B80, 0x5C3216B7, 0x1B80, 0x000116C5, 0x1B80, 0x000116C7,
+	0x1B80, 0x5C3216D5, 0x1B80, 0x5C3216D7, 0x1B80, 0x071416E5,
+	0x1B80, 0x071416E7, 0x1B80, 0x540016F5, 0x1B80, 0x540016F7,
+	0x1B80, 0x5C311705, 0x1B80, 0x5C311707, 0x1B80, 0x00011715,
+	0x1B80, 0x00011717, 0x1B80, 0x4C981725, 0x1B80, 0x4C981727,
+	0x1B80, 0x4C181735, 0x1B80, 0x4C181737, 0x1B80, 0x00011745,
+	0x1B80, 0x00011747, 0x1B80, 0x5C321755, 0x1B80, 0x5C321757,
+	0x1B80, 0x62841765, 0x1B80, 0x62841767, 0x1B80, 0x66861775,
+	0x1B80, 0x66861777, 0x1B80, 0x6C031785, 0x1B80, 0x6C031787,
+	0x1B80, 0x7B201795, 0x1B80, 0x7B201797, 0x1B80, 0x7A0017A5,
+	0x1B80, 0x7A0017A7, 0x1B80, 0x790017B5, 0x1B80, 0x790017B7,
+	0x1B80, 0x7F2017C5, 0x1B80, 0x7F2017C7, 0x1B80, 0x7E0017D5,
+	0x1B80, 0x7E0017D7, 0x1B80, 0x7D0017E5, 0x1B80, 0x7D0017E7,
+	0x1B80, 0x090117F5, 0x1B80, 0x090117F7, 0x1B80, 0x0C011805,
+	0x1B80, 0x0C011807, 0x1B80, 0x0BA61815, 0x1B80, 0x0BA61817,
+	0x1B80, 0x00011825, 0x1B80, 0x00011827, 0x1B80, 0x00000006,
+	0x1B80, 0x00000002,
+
+};
+
+void odm_read_and_config_mp_8822b_phy_reg(struct phy_dm_struct *dm)
+{
+	u32 i = 0;
+	u8 c_cond;
+	bool is_matched = true, is_skipped = false;
+	u32 array_len = sizeof(array_mp_8822b_phy_reg) / sizeof(u32);
+	u32 *array = array_mp_8822b_phy_reg;
+
+	u32 v1 = 0, v2 = 0, pre_v1 = 0, pre_v2 = 0;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "===> %s\n", __func__);
+
+	for (; (i + 1) < array_len; i = i + 2) {
+		v1 = array[i];
+		v2 = array[i + 1];
+
+		if (v1 & BIT(31)) { /* positive condition*/
+			c_cond = (u8)((v1 & (BIT(29) | BIT(28))) >> 28);
+			if (c_cond == COND_ENDIF) { /*end*/
+				is_matched = true;
+				is_skipped = false;
+				ODM_RT_TRACE(dm, ODM_COMP_INIT, "ENDIF\n");
+			} else if (c_cond == COND_ELSE) { /*else*/
+				is_matched = is_skipped ? false : true;
+				ODM_RT_TRACE(dm, ODM_COMP_INIT, "ELSE\n");
+			} else { /*if , else if*/
+				pre_v1 = v1;
+				pre_v2 = v2;
+				ODM_RT_TRACE(dm, ODM_COMP_INIT,
+					     "IF or ELSE IF\n");
+			}
+		} else if (v1 & BIT(30)) { /*negative condition*/
+			if (is_skipped) {
+				is_matched = false;
+				continue;
+			}
+
+			if (check_positive(dm, pre_v1, pre_v2, v1, v2)) {
+				is_matched = true;
+				is_skipped = true;
+			} else {
+				is_matched = false;
+				is_skipped = false;
+			}
+		} else if (is_matched) {
+			odm_config_bb_phy_8822b(dm, v1, MASKDWORD, v2);
+		}
+	}
+}
+
+u32 odm_get_version_mp_8822b_phy_reg(void) { return 67; }
+
+/******************************************************************************
+ *                           phy_reg_pg.TXT
+ ******************************************************************************/
+
+static u32 array_mp_8822b_phy_reg_pg[] = {
+	0, 0, 0, 0x00000c20, 0xffffffff, 0x32343638,
+	0, 0, 0, 0x00000c24, 0xffffffff, 0x36384042,
+	0, 0, 0, 0x00000c28, 0xffffffff, 0x28303234,
+	0, 0, 0, 0x00000c2c, 0xffffffff, 0x34363840,
+	0, 0, 0, 0x00000c30, 0xffffffff, 0x26283032,
+	0, 0, 1, 0x00000c34, 0xffffffff, 0x34363840,
+	0, 0, 1, 0x00000c38, 0xffffffff, 0x26283032,
+	0, 0, 0, 0x00000c3c, 0xffffffff, 0x34363840,
+	0, 0, 0, 0x00000c40, 0xffffffff, 0x26283032,
+	0, 0, 0, 0x00000c44, 0xffffffff, 0x38402224,
+	0, 0, 1, 0x00000c48, 0xffffffff, 0x30323436,
+	0, 0, 1, 0x00000c4c, 0xffffffff, 0x22242628,
+	0, 1, 0, 0x00000e20, 0xffffffff, 0x32343638,
+	0, 1, 0, 0x00000e24, 0xffffffff, 0x36384042,
+	0, 1, 0, 0x00000e28, 0xffffffff, 0x28303234,
+	0, 1, 0, 0x00000e2c, 0xffffffff, 0x34363840,
+	0, 1, 0, 0x00000e30, 0xffffffff, 0x26283032,
+	0, 1, 1, 0x00000e34, 0xffffffff, 0x34363840,
+	0, 1, 1, 0x00000e38, 0xffffffff, 0x26283032,
+	0, 1, 0, 0x00000e3c, 0xffffffff, 0x34363840,
+	0, 1, 0, 0x00000e40, 0xffffffff, 0x26283032,
+	0, 1, 0, 0x00000e44, 0xffffffff, 0x38402224,
+	0, 1, 1, 0x00000e48, 0xffffffff, 0x30323436,
+	0, 1, 1, 0x00000e4c, 0xffffffff, 0x22242628,
+	1, 0, 0, 0x00000c24, 0xffffffff, 0x34363840,
+	1, 0, 0, 0x00000c28, 0xffffffff, 0x26283032,
+	1, 0, 0, 0x00000c2c, 0xffffffff, 0x32343638,
+	1, 0, 0, 0x00000c30, 0xffffffff, 0x24262830,
+	1, 0, 1, 0x00000c34, 0xffffffff, 0x32343638,
+	1, 0, 1, 0x00000c38, 0xffffffff, 0x24262830,
+	1, 0, 0, 0x00000c3c, 0xffffffff, 0x32343638,
+	1, 0, 0, 0x00000c40, 0xffffffff, 0x24262830,
+	1, 0, 0, 0x00000c44, 0xffffffff, 0x36382022,
+	1, 0, 1, 0x00000c48, 0xffffffff, 0x28303234,
+	1, 0, 1, 0x00000c4c, 0xffffffff, 0x20222426,
+	1, 1, 0, 0x00000e24, 0xffffffff, 0x34363840,
+	1, 1, 0, 0x00000e28, 0xffffffff, 0x26283032,
+	1, 1, 0, 0x00000e2c, 0xffffffff, 0x32343638,
+	1, 1, 0, 0x00000e30, 0xffffffff, 0x24262830,
+	1, 1, 1, 0x00000e34, 0xffffffff, 0x32343638,
+	1, 1, 1, 0x00000e38, 0xffffffff, 0x24262830,
+	1, 1, 0, 0x00000e3c, 0xffffffff, 0x32343638,
+	1, 1, 0, 0x00000e40, 0xffffffff, 0x24262830,
+	1, 1, 0, 0x00000e44, 0xffffffff, 0x36382022,
+	1, 1, 1, 0x00000e48, 0xffffffff, 0x28303234,
+	1, 1, 1, 0x00000e4c, 0xffffffff, 0x20222426,
+};
+
+void odm_read_and_config_mp_8822b_phy_reg_pg(struct phy_dm_struct *dm)
+{
+	u32 i = 0;
+	u32 array_len = sizeof(array_mp_8822b_phy_reg_pg) / sizeof(u32);
+	u32 *array = array_mp_8822b_phy_reg_pg;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "===> %s\n", __func__);
+
+	dm->phy_reg_pg_version = 1;
+	dm->phy_reg_pg_value_type = PHY_REG_PG_EXACT_VALUE;
+
+	for (i = 0; i < array_len; i += 6) {
+		u32 v1 = array[i];
+		u32 v2 = array[i + 1];
+		u32 v3 = array[i + 2];
+		u32 v4 = array[i + 3];
+		u32 v5 = array[i + 4];
+		u32 v6 = array[i + 5];
+
+		odm_config_bb_phy_reg_pg_8822b(dm, v1, v2, v3, v4, v5, v6);
+	}
+}
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_bb.h b/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_bb.h
new file mode 100644
index 000000000000..53431998b47e
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_bb.h
@@ -0,0 +1,54 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/*Image2HeaderVersion: 3.2*/
+#ifndef __INC_MP_BB_HW_IMG_8822B_H
+#define __INC_MP_BB_HW_IMG_8822B_H
+
+/******************************************************************************
+ *                           agc_tab.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_agc_tab(/* tc: Test Chip, mp: mp Chip*/
+					  struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_agc_tab(void);
+
+/******************************************************************************
+ *                           phy_reg.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_phy_reg(/* tc: Test Chip, mp: mp Chip*/
+					  struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_phy_reg(void);
+
+/******************************************************************************
+ *                           phy_reg_pg.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_phy_reg_pg(/* tc: Test Chip, mp: mp Chip*/
+					     struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_phy_reg_pg(void);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_mac.c b/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_mac.c
new file mode 100644
index 000000000000..1a9daed2e609
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_mac.c
@@ -0,0 +1,222 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/*Image2HeaderVersion: 3.2*/
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
+
+static bool check_positive(struct phy_dm_struct *dm, const u32 condition1,
+			   const u32 condition2, const u32 condition3,
+			   const u32 condition4)
+{
+	u8 _board_type = ((dm->board_type & BIT(4)) >> 4) << 0 | /* _GLNA*/
+			 ((dm->board_type & BIT(3)) >> 3) << 1 | /* _GPA*/
+			 ((dm->board_type & BIT(7)) >> 7) << 2 | /* _ALNA*/
+			 ((dm->board_type & BIT(6)) >> 6) << 3 | /* _APA */
+			 ((dm->board_type & BIT(2)) >> 2) << 4; /* _BT*/
+
+	u32 cond1 = condition1, cond2 = condition2, cond3 = condition3,
+	    cond4 = condition4;
+
+	u8 cut_version_for_para =
+		(dm->cut_version == ODM_CUT_A) ? 14 : dm->cut_version;
+	u8 pkg_type_for_para = (dm->package_type == 0) ? 14 : dm->package_type;
+
+	u32 driver1 = cut_version_for_para << 24 |
+		      (dm->support_interface & 0xF0) << 16 |
+		      dm->support_platform << 16 | pkg_type_for_para << 12 |
+		      (dm->support_interface & 0x0F) << 8 | _board_type;
+
+	u32 driver2 = (dm->type_glna & 0xFF) << 0 | (dm->type_gpa & 0xFF) << 8 |
+		      (dm->type_alna & 0xFF) << 16 |
+		      (dm->type_apa & 0xFF) << 24;
+
+	u32 driver3 = 0;
+
+	u32 driver4 = (dm->type_glna & 0xFF00) >> 8 | (dm->type_gpa & 0xFF00) |
+		      (dm->type_alna & 0xFF00) << 8 |
+		      (dm->type_apa & 0xFF00) << 16;
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_INIT,
+		"===> %s (cond1, cond2, cond3, cond4) = (0x%X 0x%X 0x%X 0x%X)\n",
+		__func__, cond1, cond2, cond3, cond4);
+	ODM_RT_TRACE(
+		dm, ODM_COMP_INIT,
+		"===> %s (driver1, driver2, driver3, driver4) = (0x%X 0x%X 0x%X 0x%X)\n",
+		__func__, driver1, driver2, driver3, driver4);
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "	(Platform, Interface) = (0x%X, 0x%X)\n",
+		     dm->support_platform, dm->support_interface);
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "	(Board, Package) = (0x%X, 0x%X)\n",
+		     dm->board_type, dm->package_type);
+
+	/*============== value Defined Check ===============*/
+	/*QFN type [15:12] and cut version [27:24] need to do value check*/
+
+	if (((cond1 & 0x0000F000) != 0) &&
+	    ((cond1 & 0x0000F000) != (driver1 & 0x0000F000)))
+		return false;
+	if (((cond1 & 0x0F000000) != 0) &&
+	    ((cond1 & 0x0F000000) != (driver1 & 0x0F000000)))
+		return false;
+
+	/*=============== Bit Defined Check ================*/
+	/* We don't care [31:28] */
+
+	cond1 &= 0x00FF0FFF;
+	driver1 &= 0x00FF0FFF;
+
+	if ((cond1 & driver1) == cond1) {
+		u32 bit_mask = 0;
+
+		if ((cond1 & 0x0F) == 0) /* board_type is DONTCARE*/
+			return true;
+
+		if ((cond1 & BIT(0)) != 0) /*GLNA*/
+			bit_mask |= 0x000000FF;
+		if ((cond1 & BIT(1)) != 0) /*GPA*/
+			bit_mask |= 0x0000FF00;
+		if ((cond1 & BIT(2)) != 0) /*ALNA*/
+			bit_mask |= 0x00FF0000;
+		if ((cond1 & BIT(3)) != 0) /*APA*/
+			bit_mask |= 0xFF000000;
+
+		if (((cond2 & bit_mask) == (driver2 & bit_mask)) &&
+		    ((cond4 & bit_mask) ==
+		     (driver4 &
+		      bit_mask))) /* board_type of each RF path is matched*/
+			return true;
+		else
+			return false;
+	} else {
+		return false;
+	}
+}
+
+/******************************************************************************
+ *                           mac_reg.TXT
+ ******************************************************************************/
+
+static u32 array_mp_8822b_mac_reg[] = {
+	0x029,  0x000000F9, 0x420,  0x00000080, 0x421,  0x0000000F,
+	0x428,  0x0000000A, 0x429,  0x00000010, 0x430,  0x00000000,
+	0x431,  0x00000000, 0x432,  0x00000000, 0x433,  0x00000001,
+	0x434,  0x00000004, 0x435,  0x00000005, 0x436,  0x00000007,
+	0x437,  0x00000008, 0x43C,  0x00000004, 0x43D,  0x00000005,
+	0x43E,  0x00000007, 0x43F,  0x00000008, 0x440,  0x0000005D,
+	0x441,  0x00000001, 0x442,  0x00000000, 0x444,  0x00000010,
+	0x445,  0x000000F0, 0x446,  0x00000001, 0x447,  0x000000FE,
+	0x448,  0x00000000, 0x449,  0x00000000, 0x44A,  0x00000000,
+	0x44B,  0x00000040, 0x44C,  0x00000010, 0x44D,  0x000000F0,
+	0x44E,  0x0000003F, 0x44F,  0x00000000, 0x450,  0x00000000,
+	0x451,  0x00000000, 0x452,  0x00000000, 0x453,  0x00000040,
+	0x455,  0x00000070, 0x45E,  0x00000004, 0x49C,  0x00000010,
+	0x49D,  0x000000F0, 0x49E,  0x00000000, 0x49F,  0x00000006,
+	0x4A0,  0x000000E0, 0x4A1,  0x00000003, 0x4A2,  0x00000000,
+	0x4A3,  0x00000040, 0x4A4,  0x00000015, 0x4A5,  0x000000F0,
+	0x4A6,  0x00000000, 0x4A7,  0x00000006, 0x4A8,  0x000000E0,
+	0x4A9,  0x00000000, 0x4AA,  0x00000000, 0x4AB,  0x00000000,
+	0x7DA,  0x00000008, 0x1448, 0x00000006, 0x144A, 0x00000006,
+	0x144C, 0x00000006, 0x144E, 0x00000006, 0x4C8,  0x000000FF,
+	0x4C9,  0x00000008, 0x4CA,  0x00000020, 0x4CB,  0x00000020,
+	0x4CC,  0x000000FF, 0x4CD,  0x000000FF, 0x4CE,  0x00000001,
+	0x4CF,  0x00000008, 0x500,  0x00000026, 0x501,  0x000000A2,
+	0x502,  0x0000002F, 0x503,  0x00000000, 0x504,  0x00000028,
+	0x505,  0x000000A3, 0x506,  0x0000005E, 0x507,  0x00000000,
+	0x508,  0x0000002B, 0x509,  0x000000A4, 0x50A,  0x0000005E,
+	0x50B,  0x00000000, 0x50C,  0x0000004F, 0x50D,  0x000000A4,
+	0x50E,  0x00000000, 0x50F,  0x00000000, 0x512,  0x0000001C,
+	0x514,  0x0000000A, 0x516,  0x0000000A, 0x521,  0x0000002F,
+	0x525,  0x0000004F, 0x551,  0x00000010, 0x559,  0x00000002,
+	0x55C,  0x00000050, 0x55D,  0x000000FF, 0x577,  0x0000000B,
+	0x5BE,  0x00000064, 0x605,  0x00000030, 0x608,  0x0000000E,
+	0x609,  0x00000022, 0x60C,  0x00000018, 0x6A0,  0x000000FF,
+	0x6A1,  0x000000FF, 0x6A2,  0x000000FF, 0x6A3,  0x000000FF,
+	0x6A4,  0x000000FF, 0x6A5,  0x000000FF, 0x6DE,  0x00000084,
+	0x620,  0x000000FF, 0x621,  0x000000FF, 0x622,  0x000000FF,
+	0x623,  0x000000FF, 0x624,  0x000000FF, 0x625,  0x000000FF,
+	0x626,  0x000000FF, 0x627,  0x000000FF, 0x638,  0x00000050,
+	0x63C,  0x0000000A, 0x63D,  0x0000000A, 0x63E,  0x0000000E,
+	0x63F,  0x0000000E, 0x640,  0x00000040, 0x642,  0x00000040,
+	0x643,  0x00000000, 0x652,  0x000000C8, 0x66E,  0x00000005,
+	0x718,  0x00000040, 0x7D4,  0x00000098,
+
+};
+
+void odm_read_and_config_mp_8822b_mac_reg(struct phy_dm_struct *dm)
+{
+	u32 i = 0;
+	u8 c_cond;
+	bool is_matched = true, is_skipped = false;
+	u32 array_len = sizeof(array_mp_8822b_mac_reg) / sizeof(u32);
+	u32 *array = array_mp_8822b_mac_reg;
+
+	u32 v1 = 0, v2 = 0, pre_v1 = 0, pre_v2 = 0;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "===> %s\n", __func__);
+
+	for (; (i + 1) < array_len; i = i + 2) {
+		v1 = array[i];
+		v2 = array[i + 1];
+
+		if (v1 & BIT(31)) { /* positive condition*/
+			c_cond = (u8)((v1 & (BIT(29) | BIT(28))) >> 28);
+			if (c_cond == COND_ENDIF) { /*end*/
+				is_matched = true;
+				is_skipped = false;
+				ODM_RT_TRACE(dm, ODM_COMP_INIT, "ENDIF\n");
+			} else if (c_cond == COND_ELSE) { /*else*/
+				is_matched = is_skipped ? false : true;
+				ODM_RT_TRACE(dm, ODM_COMP_INIT, "ELSE\n");
+			} else { /*if , else if*/
+				pre_v1 = v1;
+				pre_v2 = v2;
+				ODM_RT_TRACE(dm, ODM_COMP_INIT,
+					     "IF or ELSE IF\n");
+			}
+		} else if (v1 & BIT(30)) { /*negative condition*/
+			if (is_skipped) {
+				is_matched = false;
+				continue;
+			}
+
+			if (check_positive(dm, pre_v1, pre_v2, v1, v2)) {
+				is_matched = true;
+				is_skipped = true;
+			} else {
+				is_matched = false;
+				is_skipped = false;
+			}
+		} else if (is_matched) {
+			odm_config_mac_8822b(dm, v1, (u8)v2);
+		}
+	}
+}
+
+u32 odm_get_version_mp_8822b_mac_reg(void) { return 67; }
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_mac.h b/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_mac.h
new file mode 100644
index 000000000000..d02fdd7a4a53
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_mac.h
@@ -0,0 +1,38 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/*Image2HeaderVersion: 3.2*/
+#ifndef __INC_MP_MAC_HW_IMG_8822B_H
+#define __INC_MP_MAC_HW_IMG_8822B_H
+
+/******************************************************************************
+ *                           mac_reg.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_mac_reg(/* tc: Test Chip, mp: mp Chip*/
+					  struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_mac_reg(void);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_rf.c b/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_rf.c
new file mode 100644
index 000000000000..84cdc0644207
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_rf.c
@@ -0,0 +1,4744 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/*Image2HeaderVersion: 3.2*/
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
+
+static bool check_positive(struct phy_dm_struct *dm, const u32 condition1,
+			   const u32 condition2, const u32 condition3,
+			   const u32 condition4)
+{
+	u8 _board_type = ((dm->board_type & BIT(4)) >> 4) << 0 | /* _GLNA*/
+			 ((dm->board_type & BIT(3)) >> 3) << 1 | /* _GPA*/
+			 ((dm->board_type & BIT(7)) >> 7) << 2 | /* _ALNA*/
+			 ((dm->board_type & BIT(6)) >> 6) << 3 | /* _APA */
+			 ((dm->board_type & BIT(2)) >> 2) << 4; /* _BT*/
+
+	u32 cond1 = condition1, cond2 = condition2, cond3 = condition3,
+	    cond4 = condition4;
+
+	u8 cut_version_for_para =
+		(dm->cut_version == ODM_CUT_A) ? 14 : dm->cut_version;
+	u8 pkg_type_for_para = (dm->package_type == 0) ? 14 : dm->package_type;
+
+	u32 driver1 = cut_version_for_para << 24 |
+		      (dm->support_interface & 0xF0) << 16 |
+		      dm->support_platform << 16 | pkg_type_for_para << 12 |
+		      (dm->support_interface & 0x0F) << 8 | _board_type;
+
+	u32 driver2 = (dm->type_glna & 0xFF) << 0 | (dm->type_gpa & 0xFF) << 8 |
+		      (dm->type_alna & 0xFF) << 16 |
+		      (dm->type_apa & 0xFF) << 24;
+
+	u32 driver3 = 0;
+
+	u32 driver4 = (dm->type_glna & 0xFF00) >> 8 | (dm->type_gpa & 0xFF00) |
+		      (dm->type_alna & 0xFF00) << 8 |
+		      (dm->type_apa & 0xFF00) << 16;
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_INIT,
+		"===> %s (cond1, cond2, cond3, cond4) = (0x%X 0x%X 0x%X 0x%X)\n",
+		__func__, cond1, cond2, cond3, cond4);
+	ODM_RT_TRACE(
+		dm, ODM_COMP_INIT,
+		"===> %s (driver1, driver2, driver3, driver4) = (0x%X 0x%X 0x%X 0x%X)\n",
+		__func__, driver1, driver2, driver3, driver4);
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "	(Platform, Interface) = (0x%X, 0x%X)\n",
+		     dm->support_platform, dm->support_interface);
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "	(Board, Package) = (0x%X, 0x%X)\n",
+		     dm->board_type, dm->package_type);
+
+	/*============== value Defined Check ===============*/
+	/*QFN type [15:12] and cut version [27:24] need to do value check*/
+
+	if (((cond1 & 0x0000F000) != 0) &&
+	    ((cond1 & 0x0000F000) != (driver1 & 0x0000F000)))
+		return false;
+	if (((cond1 & 0x0F000000) != 0) &&
+	    ((cond1 & 0x0F000000) != (driver1 & 0x0F000000)))
+		return false;
+
+	/*=============== Bit Defined Check ================*/
+	/* We don't care [31:28] */
+
+	cond1 &= 0x00FF0FFF;
+	driver1 &= 0x00FF0FFF;
+
+	if ((cond1 & driver1) == cond1) {
+		u32 bit_mask = 0;
+
+		if ((cond1 & 0x0F) == 0) /* board_type is DONTCARE*/
+			return true;
+
+		if ((cond1 & BIT(0)) != 0) /*GLNA*/
+			bit_mask |= 0x000000FF;
+		if ((cond1 & BIT(1)) != 0) /*GPA*/
+			bit_mask |= 0x0000FF00;
+		if ((cond1 & BIT(2)) != 0) /*ALNA*/
+			bit_mask |= 0x00FF0000;
+		if ((cond1 & BIT(3)) != 0) /*APA*/
+			bit_mask |= 0xFF000000;
+
+		if (((cond2 & bit_mask) == (driver2 & bit_mask)) &&
+		    ((cond4 & bit_mask) ==
+		     (driver4 &
+		      bit_mask))) /* board_type of each RF path is matched*/
+			return true;
+		else
+			return false;
+	} else {
+		return false;
+	}
+}
+
+/******************************************************************************
+ *                           radioa.TXT
+ ******************************************************************************/
+
+static u32 array_mp_8822b_radioa[] = {
+	0x000,      0x00030000, 0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9300200f, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9000100f, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9000200f, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9300200c, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0x93012100, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0x93002100, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0x9000200c, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0x90001004, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0x93002000, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0x90002100, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0x90002000, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0xA0000000, 0x00000000, 0x001,      0x00040029,
+	0xB0000000, 0x00000000, 0x018,      0x00010D24, 0x0EF,      0x00080000,
+	0x033,      0x00000002, 0x03E,      0x0000003F, 0x03F,      0x000C0F4E,
+	0x033,      0x00000001, 0x03E,      0x00000034, 0x03F,      0x0004080E,
+	0x0EF,      0x00080000, 0x0DF,      0x00002449, 0x033,      0x00000024,
+	0x03E,      0x0000003F, 0x03F,      0x00060FDE, 0x0EF,      0x00000000,
+	0x0EF,      0x00080000, 0x033,      0x00000025, 0x03E,      0x00000037,
+	0x03F,      0x0007EFCE, 0x0EF,      0x00000000, 0x0EF,      0x00080000,
+	0x033,      0x00000026, 0x03E,      0x00000037, 0x03F,      0x000DEFCE,
+	0x0EF,      0x00000000, 0x07F,      0x00000000, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x0B0,      0x000FF0F8, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x0B0,      0x000FF0F8, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x0B0,      0x000FF0F8, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x0B0,      0x000FB0F8, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x0B0,      0x000FF0F8, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x0B0,      0x000FF0F8, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x0B0,      0x000FF0F8, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x0B0,      0x000FB0F8, 0x9300200c, 0x00000000,
+	0x40000000, 0x00000000, 0x0B0,      0x000FB0F8, 0x93012100, 0x00000000,
+	0x40000000, 0x00000000, 0x0B0,      0x000FB0F8, 0x93002100, 0x00000000,
+	0x40000000, 0x00000000, 0x0B0,      0x000FB0F8, 0x93011000, 0x00000000,
+	0x40000000, 0x00000000, 0x0B0,      0x000FF0F8, 0x9000200c, 0x00000000,
+	0x40000000, 0x00000000, 0x0B0,      0x000FB0F8, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x0B0,      0x000FF0F8, 0x93002000, 0x00000000,
+	0x40000000, 0x00000000, 0x0B0,      0x000FB0F8, 0x93001000, 0x00000000,
+	0x40000000, 0x00000000, 0x0B0,      0x000FF0F8, 0x90002100, 0x00000000,
+	0x40000000, 0x00000000, 0x0B0,      0x000FB0F8, 0x90002000, 0x00000000,
+	0x40000000, 0x00000000, 0x0B0,      0x000FB0F8, 0xA0000000, 0x00000000,
+	0x0B0,      0x000FF0F8, 0xB0000000, 0x00000000, 0x0B1,      0x0007DBE4,
+	0x0B2,      0x000225D1, 0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x0B3,      0x000FC760, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x0B3,      0x000FC760, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x0B3,      0x000FC760, 0x9300200f, 0x00000000, 0x40000000, 0x00000000,
+	0x0B3,      0x000FC760, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x0B3,      0x000FC760, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x0B3,      0x000FC760, 0x9000100f, 0x00000000, 0x40000000, 0x00000000,
+	0x0B3,      0x000FC760, 0x9000200f, 0x00000000, 0x40000000, 0x00000000,
+	0x0B3,      0x000FC760, 0x9300200c, 0x00000000, 0x40000000, 0x00000000,
+	0x0B3,      0x000FC760, 0x93012100, 0x00000000, 0x40000000, 0x00000000,
+	0x0B3,      0x000FC760, 0x93002100, 0x00000000, 0x40000000, 0x00000000,
+	0x0B3,      0x0007C330, 0xA0000000, 0x00000000, 0x0B3,      0x000FC760,
+	0xB0000000, 0x00000000, 0x0B4,      0x00099DD0, 0x0B5,      0x000400FC,
+	0x0B6,      0x000187F0, 0x0B7,      0x00030018, 0x0B8,      0x00080800,
+	0x0B9,      0x00000000, 0x0BA,      0x00008000, 0x0BB,      0x00000000,
+	0x0BC,      0x00040030, 0x0BD,      0x00000000, 0x0BE,      0x00000000,
+	0x0BF,      0x00000000, 0x0C0,      0x00000000, 0x0C1,      0x00000000,
+	0x0C2,      0x00000000, 0x0C3,      0x00000000, 0x0C4,      0x00002402,
+	0x0C5,      0x00000009, 0x0C6,      0x00040299, 0x0C7,      0x00055555,
+	0x0C8,      0x0000C16C, 0x0C9,      0x0001C140, 0x0CA,      0x00000000,
+	0x0CB,      0x00000000, 0x0CC,      0x00000000, 0x0CD,      0x00000000,
+	0x0CE,      0x00090C00, 0x0CF,      0x0006D200, 0x0DF,      0x00000009,
+	0x018,      0x00010524, 0x089,      0x00000207, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x08A,      0x000FF186, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x08A,      0x000FE186, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x08A,      0x000FF186, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x08A,      0x000FF186, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x08A,      0x000FF186, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x08A,      0x000FE186, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x08A,      0x000FF186, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x08A,      0x000FF186, 0x9300200c, 0x00000000,
+	0x40000000, 0x00000000, 0x08A,      0x000FF186, 0x93012100, 0x00000000,
+	0x40000000, 0x00000000, 0x08A,      0x000FF186, 0x93002100, 0x00000000,
+	0x40000000, 0x00000000, 0x08A,      0x000FE186, 0xA0000000, 0x00000000,
+	0x08A,      0x000FF186, 0xB0000000, 0x00000000, 0x08B,      0x00061E3C,
+	0x08C,      0x000112C7, 0x08D,      0x000F4988, 0x08E,      0x00064D40,
+	0x0EF,      0x00020000, 0x033,      0x00000007, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03E,      0x00004080, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9300200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x93012100, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004000, 0x93002100, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004000, 0x93011000, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004000, 0x9000200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0xA0000000, 0x00000000,
+	0x03E,      0x00004000, 0xB0000000, 0x00000000, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9300200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x93012100, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x93002100, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000DFF86, 0x93011000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9000200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x93002000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C0006, 0x93001000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0xA0000000, 0x00000000,
+	0x03F,      0x000C3186, 0xB0000000, 0x00000000, 0x033,      0x00000006,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x03E,      0x00004080,
+	0x9300100f, 0x05050505, 0x40000000, 0x00000000, 0x03E,      0x00004080,
+	0x9300100f, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004080,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004080,
+	0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x03E,      0x00004080,
+	0x9000100f, 0x05050505, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0xA0000000, 0x00000000, 0x03E,      0x00004080, 0xB0000000, 0x00000000,
+	0x03F,      0x000C3186, 0x033,      0x00000005, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03E,      0x000040C8, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03E,      0x000040C8, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x000040C8, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x000040C8, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03E,      0x000040C8, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03E,      0x00004084, 0xA0000000, 0x00000000,
+	0x03E,      0x000040C8, 0xB0000000, 0x00000000, 0x03F,      0x000C3186,
+	0x033,      0x00000004, 0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x03E,      0x00004190, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x03E,      0x00004190, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x03E,      0x00004190, 0x9300200f, 0x00000000, 0x40000000, 0x00000000,
+	0x03E,      0x00004190, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x03E,      0x00004190, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x03E,      0x00004108, 0xA0000000, 0x00000000, 0x03E,      0x00004190,
+	0xB0000000, 0x00000000, 0x03F,      0x000C3186, 0x033,      0x00000003,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x03E,      0x00004998,
+	0x9300100f, 0x05050505, 0x40000000, 0x00000000, 0x03E,      0x00004998,
+	0x9300100f, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004998,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004998,
+	0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x03E,      0x00004998,
+	0x9000100f, 0x05050505, 0x40000000, 0x00000000, 0x03E,      0x0000490C,
+	0xA0000000, 0x00000000, 0x03E,      0x00004998, 0xB0000000, 0x00000000,
+	0x03F,      0x000C3186, 0x033,      0x00000002, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03E,      0x00005840, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03E,      0x00005840, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00005840, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00005840, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03E,      0x00005840, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03E,      0x00005E00, 0xA0000000, 0x00000000,
+	0x03E,      0x00005840, 0xB0000000, 0x00000000, 0x03F,      0x000C3186,
+	0x033,      0x00000001, 0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x03E,      0x000058C2, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x03E,      0x000058C2, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x03E,      0x000058C2, 0x9300200f, 0x00000000, 0x40000000, 0x00000000,
+	0x03E,      0x000058C2, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x03E,      0x000058C2, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x03E,      0x00005862, 0xA0000000, 0x00000000, 0x03E,      0x000058C2,
+	0xB0000000, 0x00000000, 0x03F,      0x000C3186, 0x033,      0x00000000,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x03E,      0x00005930,
+	0x9300100f, 0x05050505, 0x40000000, 0x00000000, 0x03E,      0x00005930,
+	0x9300100f, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00005930,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00005930,
+	0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x03E,      0x00005930,
+	0x9000100f, 0x05050505, 0x40000000, 0x00000000, 0x03E,      0x00005948,
+	0xA0000000, 0x00000000, 0x03E,      0x00005930, 0xB0000000, 0x00000000,
+	0x03F,      0x000C3186, 0x033,      0x0000000F, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03E,      0x00004080, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03E,      0x00004080, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9300200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x93012100, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004000, 0x93002100, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004000, 0x93011000, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004000, 0x9000200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0xA0000000, 0x00000000,
+	0x03E,      0x00004000, 0xB0000000, 0x00000000, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9300200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x93012100, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000DFF86, 0x93002100, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000DFF86, 0x93011000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9000200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x93002000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C0006, 0x93001000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0xA0000000, 0x00000000,
+	0x03F,      0x000C3186, 0xB0000000, 0x00000000, 0x033,      0x0000000E,
+	0x03E,      0x00004080, 0x03F,      0x000C3186, 0x033,      0x0000000D,
+	0x03E,      0x000040C8, 0x03F,      0x000C3186, 0x033,      0x0000000C,
+	0x03E,      0x00004190, 0x03F,      0x000C3186, 0x033,      0x0000000B,
+	0x03E,      0x00004998, 0x03F,      0x000C3186, 0x033,      0x0000000A,
+	0x03E,      0x00005840, 0x03F,      0x000C3186, 0x033,      0x00000009,
+	0x03E,      0x000058C2, 0x03F,      0x000C3186, 0x033,      0x00000008,
+	0x03E,      0x00005930, 0x03F,      0x000C3186, 0x033,      0x00000017,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x9300100f, 0x05050505, 0x40000000, 0x00000000, 0x03E,      0x00004080,
+	0x9300100f, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x9000100f, 0x05050505, 0x40000000, 0x00000000, 0x03E,      0x00004080,
+	0x9000100f, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x9000200f, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x9300200c, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x93012100, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004000,
+	0x93002100, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004000,
+	0x93011000, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004000,
+	0x9000200c, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x90001004, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0xA0000000, 0x00000000, 0x03E,      0x00004000, 0xB0000000, 0x00000000,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9300100f, 0x05050505, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9300100f, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9000100f, 0x05050505, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9000100f, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9000200f, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9300200c, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x93012100, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x93002100, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x93011000, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9000200c, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x90001004, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x93002000, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C0006,
+	0x93001000, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0xA0000000, 0x00000000, 0x03F,      0x000C3186, 0xB0000000, 0x00000000,
+	0x033,      0x00000016, 0x03E,      0x00004080, 0x03F,      0x000C3186,
+	0x033,      0x00000015, 0x03E,      0x000040C8, 0x03F,      0x000C3186,
+	0x033,      0x00000014, 0x03E,      0x00004190, 0x03F,      0x000C3186,
+	0x033,      0x00000013, 0x03E,      0x00004998, 0x03F,      0x000C3186,
+	0x033,      0x00000012, 0x03E,      0x00005840, 0x03F,      0x000C3186,
+	0x033,      0x00000011, 0x03E,      0x000058C2, 0x03F,      0x000C3186,
+	0x033,      0x00000010, 0x03E,      0x00005930, 0x03F,      0x000C3186,
+	0x0EF,      0x00000000, 0x0EF,      0x00004000, 0x033,      0x00000000,
+	0x03F,      0x0000000A, 0x033,      0x00000001, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9300200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x93012100, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000005, 0x93002100, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000006, 0x93011000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000005, 0x9000200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x93002000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x93001000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000005, 0x90002100, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x90002000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0xA0000000, 0x00000000,
+	0x03F,      0x00000005, 0xB0000000, 0x00000000, 0x033,      0x00000002,
+	0x03F,      0x00000000, 0x0EF,      0x00000000, 0x018,      0x00000401,
+	0x084,      0x00001209, 0x086,      0x000001A0, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0xA0000000, 0x00000000,
+	0x087,      0x000E8180, 0xB0000000, 0x00000000, 0x088,      0x00070020,
+	0x0DE,      0x00000010, 0x0EF,      0x00008000, 0x033,      0x0000000F,
+	0x03F,      0x0000003C, 0x033,      0x0000000E, 0x03F,      0x00000038,
+	0x033,      0x0000000D, 0x03F,      0x00000030, 0x033,      0x0000000C,
+	0x03F,      0x00000028, 0x033,      0x0000000B, 0x03F,      0x00000020,
+	0x033,      0x0000000A, 0x03F,      0x00000018, 0x033,      0x00000009,
+	0x03F,      0x00000010, 0x033,      0x00000008, 0x03F,      0x00000008,
+	0x033,      0x00000007, 0x03F,      0x0000003C, 0x033,      0x00000006,
+	0x03F,      0x00000038, 0x033,      0x00000005, 0x03F,      0x00000030,
+	0x033,      0x00000004, 0x03F,      0x00000028, 0x033,      0x00000003,
+	0x03F,      0x00000020, 0x033,      0x00000002, 0x03F,      0x00000018,
+	0x033,      0x00000001, 0x03F,      0x00000010, 0x033,      0x00000000,
+	0x03F,      0x00000008, 0x0EF,      0x00000000, 0x0B8,      0x00080A00,
+	0x0B0,      0x000FF0FA, 0x0FE,      0x00000000, 0x0CA,      0x00080000,
+	0x0C9,      0x0001C141, 0x0FE,      0x00000000, 0x0B0,      0x000FF0F8,
+	0x018,      0x00018D24, 0xFFE,      0x00000000, 0xFFE,      0x00000000,
+	0xFFE,      0x00000000, 0xFFE,      0x00000000, 0x018,      0x00010D24,
+	0x01B,      0x00075A40, 0x0EE,      0x00000002, 0x033,      0x00000000,
+	0x03F,      0x00000004, 0x033,      0x00000001, 0x03F,      0x00000004,
+	0x033,      0x00000002, 0x03F,      0x00000004, 0x033,      0x00000003,
+	0x03F,      0x00000004, 0x033,      0x00000004, 0x03F,      0x00000004,
+	0x033,      0x00000005, 0x03F,      0x00000006, 0x033,      0x00000006,
+	0x03F,      0x00000002, 0x033,      0x00000007, 0x03F,      0x00000000,
+	0x0EE,      0x00000000, 0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x061,      0x0005D4A0, 0x062,      0x0000D203, 0x063,      0x00000062,
+	0x9300100f, 0x05050505, 0x40000000, 0x00000000, 0x061,      0x0005D4A0,
+	0x062,      0x0000D203, 0x063,      0x00000062, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x061,      0x0005D4A0, 0x062,      0x0000D203,
+	0x063,      0x00000062, 0x9300200f, 0x00000000, 0x40000000, 0x00000000,
+	0x061,      0x0005D2A1, 0x062,      0x0000D3A2, 0x063,      0x00000062,
+	0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x061,      0x0005D4A0,
+	0x062,      0x0000D203, 0x063,      0x00000062, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x061,      0x0005D4A0, 0x062,      0x0000D203,
+	0x063,      0x00000062, 0x9000100f, 0x00000000, 0x40000000, 0x00000000,
+	0x061,      0x0005D4A0, 0x062,      0x0000D203, 0x063,      0x00000062,
+	0x9000200f, 0x00000000, 0x40000000, 0x00000000, 0x061,      0x0005D2A1,
+	0x062,      0x0000D3A2, 0x063,      0x00000062, 0x9300200c, 0x00000000,
+	0x40000000, 0x00000000, 0x061,      0x0005D2A1, 0x062,      0x0000D3A2,
+	0x063,      0x00000062, 0x93012100, 0x00000000, 0x40000000, 0x00000000,
+	0x061,      0x0005D301, 0x062,      0x0000D303, 0x063,      0x00000002,
+	0x93002100, 0x00000000, 0x40000000, 0x00000000, 0x061,      0x0005D301,
+	0x062,      0x0000D303, 0x063,      0x00000002, 0x93011000, 0x00000000,
+	0x40000000, 0x00000000, 0x061,      0x0005D3D1, 0x062,      0x0000D3A2,
+	0x063,      0x00000002, 0x9000200c, 0x00000000, 0x40000000, 0x00000000,
+	0x061,      0x0005D2A1, 0x062,      0x0000D3A2, 0x063,      0x00000062,
+	0x90001004, 0x00000000, 0x40000000, 0x00000000, 0x061,      0x0005D3D1,
+	0x062,      0x0000D3A2, 0x063,      0x00000002, 0x93002000, 0x00000000,
+	0x40000000, 0x00000000, 0x061,      0x0005D301, 0x062,      0x0000D303,
+	0x063,      0x00000002, 0x93001000, 0x00000000, 0x40000000, 0x00000000,
+	0x061,      0x0005D3D1, 0x062,      0x0000D3A2, 0x063,      0x00000002,
+	0x90002100, 0x00000000, 0x40000000, 0x00000000, 0x061,      0x0005D301,
+	0x062,      0x0000D303, 0x063,      0x00000002, 0x90002000, 0x00000000,
+	0x40000000, 0x00000000, 0x061,      0x0005D301, 0x062,      0x0000D303,
+	0x063,      0x00000002, 0xA0000000, 0x00000000, 0x061,      0x0005D3D0,
+	0x062,      0x0000D303, 0x063,      0x00000002, 0xB0000000, 0x00000000,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x0EF,      0x00000200,
+	0x030,      0x000004A3, 0x030,      0x000014A3, 0x030,      0x000024A3,
+	0x030,      0x000034A3, 0x030,      0x000044A3, 0x030,      0x000054A3,
+	0x030,      0x000064A3, 0x030,      0x000074A3, 0x030,      0x000084A3,
+	0x030,      0x000094A3, 0x030,      0x0000A4A3, 0x030,      0x0000B4A3,
+	0x0EF,      0x00000000, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x0EF,      0x00000200, 0x030,      0x000004A3, 0x030,      0x000014A3,
+	0x030,      0x000024A3, 0x030,      0x000034A3, 0x030,      0x000044A3,
+	0x030,      0x000054A3, 0x030,      0x000064A3, 0x030,      0x000074A3,
+	0x030,      0x000084A3, 0x030,      0x000094A3, 0x030,      0x0000A4A3,
+	0x030,      0x0000B4A3, 0x0EF,      0x00000000, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000200, 0x030,      0x000004A3,
+	0x030,      0x000014A3, 0x030,      0x000024A3, 0x030,      0x000034A3,
+	0x030,      0x000044A3, 0x030,      0x000054A3, 0x030,      0x000064A3,
+	0x030,      0x000074A3, 0x030,      0x000084A3, 0x030,      0x000094A3,
+	0x030,      0x0000A4A3, 0x030,      0x0000B4A3, 0x0EF,      0x00000000,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x0EF,      0x00000200,
+	0x030,      0x000002A6, 0x030,      0x000012A6, 0x030,      0x000022A6,
+	0x030,      0x000032A6, 0x030,      0x000042A6, 0x030,      0x000052A6,
+	0x030,      0x000062A6, 0x030,      0x000072A6, 0x030,      0x000082A6,
+	0x030,      0x000092A6, 0x030,      0x0000A2A6, 0x030,      0x0000B2A6,
+	0x0EF,      0x00000000, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x0EF,      0x00000200, 0x030,      0x000004A0, 0x030,      0x000014A0,
+	0x030,      0x000024A0, 0x030,      0x000034A0, 0x030,      0x000044A0,
+	0x030,      0x000054A0, 0x030,      0x000064A0, 0x030,      0x000074A0,
+	0x030,      0x000084A0, 0x030,      0x000094A0, 0x030,      0x0000A4A0,
+	0x030,      0x0000B4A0, 0x0EF,      0x00000000, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x0EF,      0x00000200, 0x030,      0x000004A0,
+	0x030,      0x000014A0, 0x030,      0x000024A0, 0x030,      0x000034A0,
+	0x030,      0x000044A0, 0x030,      0x000054A0, 0x030,      0x000064A0,
+	0x030,      0x000074A0, 0x030,      0x000084A0, 0x030,      0x000094A0,
+	0x030,      0x0000A4A0, 0x030,      0x0000B4A0, 0x0EF,      0x00000000,
+	0x9000100f, 0x00000000, 0x40000000, 0x00000000, 0x0EF,      0x00000200,
+	0x030,      0x000004A0, 0x030,      0x000014A0, 0x030,      0x000024A0,
+	0x030,      0x000034A0, 0x030,      0x000044A0, 0x030,      0x000054A0,
+	0x030,      0x000064A0, 0x030,      0x000074A0, 0x030,      0x000084A0,
+	0x030,      0x000094A0, 0x030,      0x0000A4A0, 0x030,      0x0000B4A0,
+	0x0EF,      0x00000000, 0x9000200f, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000200, 0x030,      0x000002A1, 0x030,      0x000012A1,
+	0x030,      0x000022A1, 0x030,      0x000032A1, 0x030,      0x000042A1,
+	0x030,      0x000052A1, 0x030,      0x000062A1, 0x030,      0x000072A1,
+	0x030,      0x000082A1, 0x030,      0x000092A1, 0x030,      0x0000A2A1,
+	0x030,      0x0000B2A1, 0x0EF,      0x00000000, 0x9300200c, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000200, 0x030,      0x000002A6,
+	0x030,      0x000012A6, 0x030,      0x000022A6, 0x030,      0x000032A6,
+	0x030,      0x000042A6, 0x030,      0x000052A6, 0x030,      0x000062A6,
+	0x030,      0x000072A6, 0x030,      0x000082A6, 0x030,      0x000092A6,
+	0x030,      0x0000A2A6, 0x030,      0x0000B2A6, 0x0EF,      0x00000000,
+	0x93012100, 0x00000000, 0x40000000, 0x00000000, 0x0EF,      0x00000200,
+	0x030,      0x00000384, 0x030,      0x00001384, 0x030,      0x00002384,
+	0x030,      0x00003384, 0x030,      0x00004425, 0x030,      0x00005425,
+	0x030,      0x00006425, 0x030,      0x00007425, 0x030,      0x000083A4,
+	0x030,      0x000093A4, 0x030,      0x0000A3A4, 0x030,      0x0000B3A4,
+	0x0EF,      0x00000000, 0x93002100, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000200, 0x030,      0x000003A3, 0x030,      0x000013A3,
+	0x030,      0x000023A3, 0x030,      0x000033A3, 0x030,      0x00004355,
+	0x030,      0x00005355, 0x030,      0x00006355, 0x030,      0x00007355,
+	0x030,      0x00008314, 0x030,      0x00009314, 0x030,      0x0000A314,
+	0x030,      0x0000B314, 0x0EF,      0x00000000, 0x93011000, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000200, 0x030,      0x000003A1,
+	0x030,      0x000013A1, 0x030,      0x000023A1, 0x030,      0x000033A1,
+	0x030,      0x000043A3, 0x030,      0x000053A3, 0x030,      0x000063A3,
+	0x030,      0x000073A3, 0x030,      0x000083A5, 0x030,      0x000093A5,
+	0x030,      0x0000A3A5, 0x030,      0x0000B3A5, 0x0EF,      0x00000000,
+	0x9000200c, 0x00000000, 0x40000000, 0x00000000, 0x0EF,      0x00000200,
+	0x030,      0x000002A1, 0x030,      0x000012A1, 0x030,      0x000022A1,
+	0x030,      0x000032A1, 0x030,      0x000042A1, 0x030,      0x000052A1,
+	0x030,      0x000062A1, 0x030,      0x000072A1, 0x030,      0x000082A1,
+	0x030,      0x000092A1, 0x030,      0x0000A2A1, 0x030,      0x0000B2A1,
+	0x0EF,      0x00000000, 0x90001004, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000200, 0x030,      0x00000463, 0x030,      0x00001463,
+	0x030,      0x00002463, 0x030,      0x00003463, 0x030,      0x00004545,
+	0x030,      0x00005545, 0x030,      0x00006545, 0x030,      0x00007545,
+	0x030,      0x00008565, 0x030,      0x00009565, 0x030,      0x0000A565,
+	0x030,      0x0000B565, 0x0EF,      0x00000000, 0x93002000, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000200, 0x030,      0x00000303,
+	0x030,      0x00001303, 0x030,      0x00002303, 0x030,      0x00003303,
+	0x030,      0x000043A4, 0x030,      0x000053A4, 0x030,      0x000063A4,
+	0x030,      0x000073A4, 0x030,      0x00008365, 0x030,      0x00009365,
+	0x030,      0x0000A365, 0x030,      0x0000B365, 0x0EF,      0x00000000,
+	0x93001000, 0x00000000, 0x40000000, 0x00000000, 0x0EF,      0x00000200,
+	0x030,      0x000003A2, 0x030,      0x000013A2, 0x030,      0x000023A2,
+	0x030,      0x000033A2, 0x030,      0x00004343, 0x030,      0x00005343,
+	0x030,      0x00006343, 0x030,      0x00007343, 0x030,      0x00008364,
+	0x030,      0x00009364, 0x030,      0x0000A364, 0x030,      0x0000B364,
+	0x0EF,      0x00000000, 0x90002100, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000200, 0x030,      0x000003A0, 0x030,      0x000013A0,
+	0x030,      0x000023A0, 0x030,      0x000033A0, 0x030,      0x00004430,
+	0x030,      0x00005430, 0x030,      0x00006430, 0x030,      0x00007430,
+	0x030,      0x00008372, 0x030,      0x00009372, 0x030,      0x0000A372,
+	0x030,      0x0000B372, 0x0EF,      0x00000000, 0x90002000, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000200, 0x030,      0x000003A0,
+	0x030,      0x000013A0, 0x030,      0x000023A0, 0x030,      0x000033A0,
+	0x030,      0x000043A1, 0x030,      0x000053A1, 0x030,      0x000063A1,
+	0x030,      0x000073A1, 0x030,      0x000083A2, 0x030,      0x000093A2,
+	0x030,      0x0000A3A2, 0x030,      0x0000B3A2, 0x0EF,      0x00000000,
+	0xA0000000, 0x00000000, 0x0EF,      0x00000200, 0x030,      0x000003D0,
+	0x030,      0x000013D0, 0x030,      0x000023D0, 0x030,      0x000033D0,
+	0x030,      0x000043D0, 0x030,      0x000053D0, 0x030,      0x000063D0,
+	0x030,      0x000073D0, 0x030,      0x000083D0, 0x030,      0x000093D0,
+	0x030,      0x0000A3D0, 0x030,      0x0000B3D0, 0x0EF,      0x00000000,
+	0xB0000000, 0x00000000, 0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x00000203, 0x030,      0x00001203,
+	0x030,      0x00002203, 0x030,      0x00003203, 0x030,      0x00004203,
+	0x030,      0x00005203, 0x030,      0x00006203, 0x030,      0x00007203,
+	0x030,      0x00008203, 0x030,      0x00009203, 0x030,      0x0000A203,
+	0x030,      0x0000B203, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x00000203, 0x030,      0x00001203,
+	0x030,      0x00002203, 0x030,      0x00003203, 0x030,      0x00004203,
+	0x030,      0x00005203, 0x030,      0x00006203, 0x030,      0x00007203,
+	0x030,      0x00008203, 0x030,      0x00009203, 0x030,      0x0000A203,
+	0x030,      0x0000B203, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x00000203, 0x030,      0x00001203,
+	0x030,      0x00002203, 0x030,      0x00003203, 0x030,      0x00004203,
+	0x030,      0x00005203, 0x030,      0x00006203, 0x030,      0x00007203,
+	0x030,      0x00008203, 0x030,      0x00009203, 0x030,      0x0000A203,
+	0x030,      0x0000B203, 0x9300200f, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x000003A2, 0x030,      0x000013A2,
+	0x030,      0x000023A2, 0x030,      0x000033A2, 0x030,      0x000043A2,
+	0x030,      0x000053A2, 0x030,      0x000063A2, 0x030,      0x000073A2,
+	0x030,      0x000083A2, 0x030,      0x000093A2, 0x030,      0x0000A3A2,
+	0x030,      0x0000B3A2, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x00000203, 0x030,      0x00001203,
+	0x030,      0x00002203, 0x030,      0x00003203, 0x030,      0x00004203,
+	0x030,      0x00005203, 0x030,      0x00006203, 0x030,      0x00007203,
+	0x030,      0x00008203, 0x030,      0x00009203, 0x030,      0x0000A203,
+	0x030,      0x0000B203, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x00000203, 0x030,      0x00001203,
+	0x030,      0x00002203, 0x030,      0x00003203, 0x030,      0x00004203,
+	0x030,      0x00005203, 0x030,      0x00006203, 0x030,      0x00007203,
+	0x030,      0x00008203, 0x030,      0x00009203, 0x030,      0x0000A203,
+	0x030,      0x0000B203, 0x9000100f, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x00000203, 0x030,      0x00001203,
+	0x030,      0x00002203, 0x030,      0x00003203, 0x030,      0x00004203,
+	0x030,      0x00005203, 0x030,      0x00006203, 0x030,      0x00007203,
+	0x030,      0x00008203, 0x030,      0x00009203, 0x030,      0x0000A203,
+	0x030,      0x0000B203, 0x9000200f, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x000003A2, 0x030,      0x000013A2,
+	0x030,      0x000023A2, 0x030,      0x000033A2, 0x030,      0x000043A2,
+	0x030,      0x000053A2, 0x030,      0x000063A2, 0x030,      0x000073A2,
+	0x030,      0x000083A2, 0x030,      0x000093A2, 0x030,      0x0000A3A2,
+	0x030,      0x0000B3A2, 0x9300200c, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x000003A2, 0x030,      0x000013A2,
+	0x030,      0x000023A2, 0x030,      0x000033A2, 0x030,      0x000043A2,
+	0x030,      0x000053A2, 0x030,      0x000063A2, 0x030,      0x000073A2,
+	0x030,      0x000083A2, 0x030,      0x000093A2, 0x030,      0x0000A3A2,
+	0x030,      0x0000B3A2, 0x93012100, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x000003A3, 0x030,      0x000013A3,
+	0x030,      0x000023A3, 0x030,      0x000033A3, 0x030,      0x000043A3,
+	0x030,      0x000053A3, 0x030,      0x000063A3, 0x030,      0x000073A3,
+	0x030,      0x000083A3, 0x030,      0x000093A3, 0x030,      0x0000A3A3,
+	0x030,      0x0000B3A3, 0x93002100, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x000003A2, 0x030,      0x000013A2,
+	0x030,      0x000023A2, 0x030,      0x000033A2, 0x030,      0x000043A2,
+	0x030,      0x000053A2, 0x030,      0x000063A2, 0x030,      0x000073A2,
+	0x030,      0x000083A2, 0x030,      0x000093A2, 0x030,      0x0000A3A2,
+	0x030,      0x0000B3A2, 0x93011000, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x000003A2, 0x030,      0x000013A2,
+	0x030,      0x000023A2, 0x030,      0x000033A2, 0x030,      0x000043A2,
+	0x030,      0x000053A2, 0x030,      0x000063A2, 0x030,      0x000073A2,
+	0x030,      0x000083A2, 0x030,      0x000093A2, 0x030,      0x0000A3A2,
+	0x030,      0x0000B3A2, 0x9000200c, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x000003A2, 0x030,      0x000013A2,
+	0x030,      0x000023A2, 0x030,      0x000033A2, 0x030,      0x000043A2,
+	0x030,      0x000053A2, 0x030,      0x000063A2, 0x030,      0x000073A2,
+	0x030,      0x000083A2, 0x030,      0x000093A2, 0x030,      0x0000A3A2,
+	0x030,      0x0000B3A2, 0x90001004, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x000003A2, 0x030,      0x000013A2,
+	0x030,      0x000023A2, 0x030,      0x000033A2, 0x030,      0x000043A2,
+	0x030,      0x000053A2, 0x030,      0x000063A2, 0x030,      0x000073A2,
+	0x030,      0x000083A2, 0x030,      0x000093A2, 0x030,      0x0000A3A2,
+	0x030,      0x0000B3A2, 0x93002000, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x000003A2, 0x030,      0x000013A2,
+	0x030,      0x000023A2, 0x030,      0x000033A2, 0x030,      0x000043A2,
+	0x030,      0x000053A2, 0x030,      0x000063A2, 0x030,      0x000073A2,
+	0x030,      0x000083A2, 0x030,      0x000093A2, 0x030,      0x0000A3A2,
+	0x030,      0x0000B3A2, 0x93001000, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x000003A2, 0x030,      0x000013A2,
+	0x030,      0x000023A2, 0x030,      0x000033A2, 0x030,      0x000043A2,
+	0x030,      0x000053A2, 0x030,      0x000063A2, 0x030,      0x000073A2,
+	0x030,      0x000083A2, 0x030,      0x000093A2, 0x030,      0x0000A3A2,
+	0x030,      0x0000B3A2, 0x90002100, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x000003A2, 0x030,      0x000013A2,
+	0x030,      0x000023A2, 0x030,      0x000033A2, 0x030,      0x000043A2,
+	0x030,      0x000053A2, 0x030,      0x000063A2, 0x030,      0x000073A2,
+	0x030,      0x000083A2, 0x030,      0x000093A2, 0x030,      0x0000A3A2,
+	0x030,      0x0000B3A2, 0x90002000, 0x00000000, 0x40000000, 0x00000000,
+	0x0EF,      0x00000080, 0x030,      0x000003A2, 0x030,      0x000013A2,
+	0x030,      0x000023A2, 0x030,      0x000033A2, 0x030,      0x000043A2,
+	0x030,      0x000053A2, 0x030,      0x000063A2, 0x030,      0x000073A2,
+	0x030,      0x000083A2, 0x030,      0x000093A2, 0x030,      0x0000A3A2,
+	0x030,      0x0000B3A2, 0xA0000000, 0x00000000, 0x0EF,      0x00000080,
+	0x030,      0x000003A2, 0x030,      0x000013A2, 0x030,      0x000023A2,
+	0x030,      0x000033A2, 0x030,      0x000043A2, 0x030,      0x000053A2,
+	0x030,      0x000063A2, 0x030,      0x000073A2, 0x030,      0x000083A2,
+	0x030,      0x000093A2, 0x030,      0x0000A3A2, 0x030,      0x0000B3A2,
+	0xB0000000, 0x00000000, 0x0EF,      0x00000000, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000645,
+	0x030,      0x00001333, 0x030,      0x00002011, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000645,
+	0x030,      0x00001333, 0x030,      0x00002011, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000645,
+	0x030,      0x00001333, 0x030,      0x00002011, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000645,
+	0x030,      0x00001333, 0x030,      0x00002011, 0x030,      0x00004777,
+	0x030,      0x00005777, 0x030,      0x00006777, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000645,
+	0x030,      0x00001333, 0x030,      0x00002011, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000645,
+	0x030,      0x00001333, 0x030,      0x00002011, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000645,
+	0x030,      0x00001333, 0x030,      0x00002011, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000645,
+	0x030,      0x00001333, 0x030,      0x00002011, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0x9300200c, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000645,
+	0x030,      0x00001333, 0x030,      0x00002011, 0x030,      0x00004777,
+	0x030,      0x00005777, 0x030,      0x00006777, 0x93012100, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000660,
+	0x030,      0x00001443, 0x030,      0x00002221, 0x030,      0x00004777,
+	0x030,      0x00005777, 0x030,      0x00006777, 0x93002100, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000776,
+	0x030,      0x00001455, 0x030,      0x00002325, 0x030,      0x00004777,
+	0x030,      0x00005777, 0x030,      0x00006777, 0x93011000, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000764,
+	0x030,      0x00001632, 0x030,      0x00002421, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0x9000200c, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000645,
+	0x030,      0x00001333, 0x030,      0x00002011, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000764,
+	0x030,      0x00001632, 0x030,      0x00002421, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0x93002000, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000777,
+	0x030,      0x00001442, 0x030,      0x00002222, 0x030,      0x00004777,
+	0x030,      0x00005777, 0x030,      0x00006777, 0x93001000, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000764,
+	0x030,      0x00001632, 0x030,      0x00002421, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0x90002100, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000775,
+	0x030,      0x00001343, 0x030,      0x00002210, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0x90002000, 0x00000000,
+	0x40000000, 0x00000000, 0x0EF,      0x00000040, 0x030,      0x00000775,
+	0x030,      0x00001422, 0x030,      0x00002210, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0xA0000000, 0x00000000,
+	0x0EF,      0x00000040, 0x030,      0x00000764, 0x030,      0x00001632,
+	0x030,      0x00002421, 0x030,      0x00004000, 0x030,      0x00005000,
+	0x030,      0x00006000, 0xB0000000, 0x00000000, 0x0EF,      0x00000000,
+	0x0EF,      0x00000800, 0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x00000007, 0x033,      0x00000021,
+	0x03F,      0x0000000A, 0x033,      0x00000022, 0x03F,      0x0000000D,
+	0x033,      0x00000023, 0x03F,      0x0000002A, 0x033,      0x00000024,
+	0x03F,      0x0000002D, 0x033,      0x00000025, 0x03F,      0x00000030,
+	0x033,      0x00000026, 0x03F,      0x0000006D, 0x033,      0x00000027,
+	0x03F,      0x00000070, 0x033,      0x00000028, 0x03F,      0x000000ED,
+	0x033,      0x00000029, 0x03F,      0x000000F0, 0x033,      0x0000002A,
+	0x03F,      0x000000F3, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x00000007, 0x033,      0x00000021,
+	0x03F,      0x0000000A, 0x033,      0x00000022, 0x03F,      0x0000000D,
+	0x033,      0x00000023, 0x03F,      0x0000002A, 0x033,      0x00000024,
+	0x03F,      0x0000002D, 0x033,      0x00000025, 0x03F,      0x00000030,
+	0x033,      0x00000026, 0x03F,      0x0000006D, 0x033,      0x00000027,
+	0x03F,      0x00000070, 0x033,      0x00000028, 0x03F,      0x000000ED,
+	0x033,      0x00000029, 0x03F,      0x000000F0, 0x033,      0x0000002A,
+	0x03F,      0x000000F3, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x00000007, 0x033,      0x00000021,
+	0x03F,      0x0000000A, 0x033,      0x00000022, 0x03F,      0x0000000D,
+	0x033,      0x00000023, 0x03F,      0x0000002A, 0x033,      0x00000024,
+	0x03F,      0x0000002D, 0x033,      0x00000025, 0x03F,      0x00000030,
+	0x033,      0x00000026, 0x03F,      0x0000006D, 0x033,      0x00000027,
+	0x03F,      0x00000070, 0x033,      0x00000028, 0x03F,      0x000000ED,
+	0x033,      0x00000029, 0x03F,      0x000000F0, 0x033,      0x0000002A,
+	0x03F,      0x000000F3, 0x9300200f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x00000005, 0x033,      0x00000021,
+	0x03F,      0x00000008, 0x033,      0x00000022, 0x03F,      0x0000000B,
+	0x033,      0x00000023, 0x03F,      0x0000000E, 0x033,      0x00000024,
+	0x03F,      0x0000002B, 0x033,      0x00000025, 0x03F,      0x00000068,
+	0x033,      0x00000026, 0x03F,      0x0000006B, 0x033,      0x00000027,
+	0x03F,      0x0000006E, 0x033,      0x00000028, 0x03F,      0x00000071,
+	0x033,      0x00000029, 0x03F,      0x00000074, 0x033,      0x0000002A,
+	0x03F,      0x00000077, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x00000007, 0x033,      0x00000021,
+	0x03F,      0x0000000A, 0x033,      0x00000022, 0x03F,      0x0000000D,
+	0x033,      0x00000023, 0x03F,      0x0000002A, 0x033,      0x00000024,
+	0x03F,      0x0000002D, 0x033,      0x00000025, 0x03F,      0x00000030,
+	0x033,      0x00000026, 0x03F,      0x0000006D, 0x033,      0x00000027,
+	0x03F,      0x00000070, 0x033,      0x00000028, 0x03F,      0x000000ED,
+	0x033,      0x00000029, 0x03F,      0x000000F0, 0x033,      0x0000002A,
+	0x03F,      0x000000F3, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x00000007, 0x033,      0x00000021,
+	0x03F,      0x0000000A, 0x033,      0x00000022, 0x03F,      0x0000000D,
+	0x033,      0x00000023, 0x03F,      0x0000002A, 0x033,      0x00000024,
+	0x03F,      0x0000002D, 0x033,      0x00000025, 0x03F,      0x00000030,
+	0x033,      0x00000026, 0x03F,      0x0000006D, 0x033,      0x00000027,
+	0x03F,      0x00000070, 0x033,      0x00000028, 0x03F,      0x000000ED,
+	0x033,      0x00000029, 0x03F,      0x000000F0, 0x033,      0x0000002A,
+	0x03F,      0x000000F3, 0x9000100f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x00000007, 0x033,      0x00000021,
+	0x03F,      0x0000000A, 0x033,      0x00000022, 0x03F,      0x0000000D,
+	0x033,      0x00000023, 0x03F,      0x0000002A, 0x033,      0x00000024,
+	0x03F,      0x0000002D, 0x033,      0x00000025, 0x03F,      0x00000030,
+	0x033,      0x00000026, 0x03F,      0x0000006D, 0x033,      0x00000027,
+	0x03F,      0x00000070, 0x033,      0x00000028, 0x03F,      0x000000ED,
+	0x033,      0x00000029, 0x03F,      0x000000F0, 0x033,      0x0000002A,
+	0x03F,      0x000000F3, 0x9000200f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x00000005, 0x033,      0x00000021,
+	0x03F,      0x00000008, 0x033,      0x00000022, 0x03F,      0x0000000B,
+	0x033,      0x00000023, 0x03F,      0x0000000E, 0x033,      0x00000024,
+	0x03F,      0x0000002B, 0x033,      0x00000025, 0x03F,      0x00000068,
+	0x033,      0x00000026, 0x03F,      0x0000006B, 0x033,      0x00000027,
+	0x03F,      0x0000006E, 0x033,      0x00000028, 0x03F,      0x00000071,
+	0x033,      0x00000029, 0x03F,      0x00000074, 0x033,      0x0000002A,
+	0x03F,      0x00000077, 0x9300200c, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x00000005, 0x033,      0x00000021,
+	0x03F,      0x00000008, 0x033,      0x00000022, 0x03F,      0x0000000B,
+	0x033,      0x00000023, 0x03F,      0x0000000E, 0x033,      0x00000024,
+	0x03F,      0x0000002B, 0x033,      0x00000025, 0x03F,      0x00000068,
+	0x033,      0x00000026, 0x03F,      0x0000006B, 0x033,      0x00000027,
+	0x03F,      0x0000006E, 0x033,      0x00000028, 0x03F,      0x00000071,
+	0x033,      0x00000029, 0x03F,      0x00000074, 0x033,      0x0000002A,
+	0x03F,      0x00000077, 0x93012100, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x00000C0C, 0x033,      0x00000021,
+	0x03F,      0x00000C29, 0x033,      0x00000022, 0x03F,      0x00000C2C,
+	0x033,      0x00000023, 0x03F,      0x00000C69, 0x033,      0x00000024,
+	0x03F,      0x00000CA8, 0x033,      0x00000025, 0x03F,      0x00000CE8,
+	0x033,      0x00000026, 0x03F,      0x00000CEB, 0x033,      0x00000027,
+	0x03F,      0x00000CEE, 0x033,      0x00000028, 0x03F,      0x00000CF1,
+	0x033,      0x00000029, 0x03F,      0x00000CF4, 0x033,      0x0000002A,
+	0x03F,      0x00000CF7, 0x93002100, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x0000042B, 0x033,      0x00000021,
+	0x03F,      0x0000082A, 0x033,      0x00000022, 0x03F,      0x00000849,
+	0x033,      0x00000023, 0x03F,      0x0000084C, 0x033,      0x00000024,
+	0x03F,      0x00000C4C, 0x033,      0x00000025, 0x03F,      0x00000CA9,
+	0x033,      0x00000026, 0x03F,      0x00000CEA, 0x033,      0x00000027,
+	0x03F,      0x00000CED, 0x033,      0x00000028, 0x03F,      0x00000CF0,
+	0x033,      0x00000029, 0x03F,      0x00000CF3, 0x033,      0x0000002A,
+	0x03F,      0x00000CF6, 0x93011000, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x00000C09, 0x033,      0x00000021,
+	0x03F,      0x00000C0C, 0x033,      0x00000022, 0x03F,      0x00000C0F,
+	0x033,      0x00000023, 0x03F,      0x00000C2C, 0x033,      0x00000024,
+	0x03F,      0x00000C2F, 0x033,      0x00000025, 0x03F,      0x00000C8A,
+	0x033,      0x00000026, 0x03F,      0x00000C8D, 0x033,      0x00000027,
+	0x03F,      0x00000C90, 0x033,      0x00000028, 0x03F,      0x00000CD0,
+	0x033,      0x00000029, 0x03F,      0x00000CF2, 0x033,      0x0000002A,
+	0x03F,      0x00000CF5, 0x9000200c, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x00000005, 0x033,      0x00000021,
+	0x03F,      0x00000008, 0x033,      0x00000022, 0x03F,      0x0000000B,
+	0x033,      0x00000023, 0x03F,      0x0000000E, 0x033,      0x00000024,
+	0x03F,      0x0000002B, 0x033,      0x00000025, 0x03F,      0x00000068,
+	0x033,      0x00000026, 0x03F,      0x0000006B, 0x033,      0x00000027,
+	0x03F,      0x0000006E, 0x033,      0x00000028, 0x03F,      0x00000071,
+	0x033,      0x00000029, 0x03F,      0x00000074, 0x033,      0x0000002A,
+	0x03F,      0x00000077, 0x90001004, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x00000C09, 0x033,      0x00000021,
+	0x03F,      0x00000C0C, 0x033,      0x00000022, 0x03F,      0x00000C0F,
+	0x033,      0x00000023, 0x03F,      0x00000C2C, 0x033,      0x00000024,
+	0x03F,      0x00000C2F, 0x033,      0x00000025, 0x03F,      0x00000C8A,
+	0x033,      0x00000026, 0x03F,      0x00000C8D, 0x033,      0x00000027,
+	0x03F,      0x00000C90, 0x033,      0x00000028, 0x03F,      0x00000CD0,
+	0x033,      0x00000029, 0x03F,      0x00000CF2, 0x033,      0x0000002A,
+	0x03F,      0x00000CF5, 0x93002000, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x00000429, 0x033,      0x00000021,
+	0x03F,      0x00000828, 0x033,      0x00000022, 0x03F,      0x00000847,
+	0x033,      0x00000023, 0x03F,      0x0000084A, 0x033,      0x00000024,
+	0x03F,      0x00000C4B, 0x033,      0x00000025, 0x03F,      0x00000C8A,
+	0x033,      0x00000026, 0x03F,      0x00000CEA, 0x033,      0x00000027,
+	0x03F,      0x00000CED, 0x033,      0x00000028, 0x03F,      0x00000CF0,
+	0x033,      0x00000029, 0x03F,      0x00000CF3, 0x033,      0x0000002A,
+	0x03F,      0x00000CF6, 0x93001000, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x00000C09, 0x033,      0x00000021,
+	0x03F,      0x00000C0C, 0x033,      0x00000022, 0x03F,      0x00000C0F,
+	0x033,      0x00000023, 0x03F,      0x00000C2C, 0x033,      0x00000024,
+	0x03F,      0x00000C2F, 0x033,      0x00000025, 0x03F,      0x00000C8A,
+	0x033,      0x00000026, 0x03F,      0x00000C8D, 0x033,      0x00000027,
+	0x03F,      0x00000C90, 0x033,      0x00000028, 0x03F,      0x00000CD0,
+	0x033,      0x00000029, 0x03F,      0x00000CF2, 0x033,      0x0000002A,
+	0x03F,      0x00000CF5, 0x90002100, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x0000042B, 0x033,      0x00000021,
+	0x03F,      0x0000082A, 0x033,      0x00000022, 0x03F,      0x00000849,
+	0x033,      0x00000023, 0x03F,      0x0000084C, 0x033,      0x00000024,
+	0x03F,      0x00000C4C, 0x033,      0x00000025, 0x03F,      0x00000C8A,
+	0x033,      0x00000026, 0x03F,      0x00000C8D, 0x033,      0x00000027,
+	0x03F,      0x00000CEB, 0x033,      0x00000028, 0x03F,      0x00000CEE,
+	0x033,      0x00000029, 0x03F,      0x00000CF1, 0x033,      0x0000002A,
+	0x03F,      0x00000CF4, 0x90002000, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000020, 0x03F,      0x0000042B, 0x033,      0x00000021,
+	0x03F,      0x0000082A, 0x033,      0x00000022, 0x03F,      0x00000849,
+	0x033,      0x00000023, 0x03F,      0x0000084C, 0x033,      0x00000024,
+	0x03F,      0x00000C4C, 0x033,      0x00000025, 0x03F,      0x00000C8A,
+	0x033,      0x00000026, 0x03F,      0x00000C8D, 0x033,      0x00000027,
+	0x03F,      0x00000CEB, 0x033,      0x00000028, 0x03F,      0x00000CEE,
+	0x033,      0x00000029, 0x03F,      0x00000CF1, 0x033,      0x0000002A,
+	0x03F,      0x00000CF4, 0xA0000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000C09, 0x033,      0x00000021, 0x03F,      0x00000C0C,
+	0x033,      0x00000022, 0x03F,      0x00000C0F, 0x033,      0x00000023,
+	0x03F,      0x00000C2C, 0x033,      0x00000024, 0x03F,      0x00000C2F,
+	0x033,      0x00000025, 0x03F,      0x00000C8A, 0x033,      0x00000026,
+	0x03F,      0x00000C8D, 0x033,      0x00000027, 0x03F,      0x00000C90,
+	0x033,      0x00000028, 0x03F,      0x00000CD0, 0x033,      0x00000029,
+	0x03F,      0x00000CF2, 0x033,      0x0000002A, 0x03F,      0x00000CF5,
+	0xB0000000, 0x00000000, 0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x00000007, 0x033,      0x00000061,
+	0x03F,      0x0000000A, 0x033,      0x00000062, 0x03F,      0x0000000D,
+	0x033,      0x00000063, 0x03F,      0x0000002A, 0x033,      0x00000064,
+	0x03F,      0x0000002D, 0x033,      0x00000065, 0x03F,      0x00000030,
+	0x033,      0x00000066, 0x03F,      0x0000006D, 0x033,      0x00000067,
+	0x03F,      0x00000070, 0x033,      0x00000068, 0x03F,      0x000000ED,
+	0x033,      0x00000069, 0x03F,      0x000000F0, 0x033,      0x0000006A,
+	0x03F,      0x000000F3, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x00000007, 0x033,      0x00000061,
+	0x03F,      0x0000000A, 0x033,      0x00000062, 0x03F,      0x0000000D,
+	0x033,      0x00000063, 0x03F,      0x0000002A, 0x033,      0x00000064,
+	0x03F,      0x0000002D, 0x033,      0x00000065, 0x03F,      0x00000030,
+	0x033,      0x00000066, 0x03F,      0x0000006D, 0x033,      0x00000067,
+	0x03F,      0x00000070, 0x033,      0x00000068, 0x03F,      0x000000ED,
+	0x033,      0x00000069, 0x03F,      0x000000F0, 0x033,      0x0000006A,
+	0x03F,      0x000000F3, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x00000007, 0x033,      0x00000061,
+	0x03F,      0x0000000A, 0x033,      0x00000062, 0x03F,      0x0000000D,
+	0x033,      0x00000063, 0x03F,      0x0000002A, 0x033,      0x00000064,
+	0x03F,      0x0000002D, 0x033,      0x00000065, 0x03F,      0x00000030,
+	0x033,      0x00000066, 0x03F,      0x0000006D, 0x033,      0x00000067,
+	0x03F,      0x00000070, 0x033,      0x00000068, 0x03F,      0x000000ED,
+	0x033,      0x00000069, 0x03F,      0x000000F0, 0x033,      0x0000006A,
+	0x03F,      0x000000F3, 0x9300200f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x00000005, 0x033,      0x00000061,
+	0x03F,      0x00000008, 0x033,      0x00000062, 0x03F,      0x0000000B,
+	0x033,      0x00000063, 0x03F,      0x0000000E, 0x033,      0x00000064,
+	0x03F,      0x0000002B, 0x033,      0x00000065, 0x03F,      0x00000068,
+	0x033,      0x00000066, 0x03F,      0x0000006B, 0x033,      0x00000067,
+	0x03F,      0x0000006E, 0x033,      0x00000068, 0x03F,      0x00000071,
+	0x033,      0x00000069, 0x03F,      0x00000074, 0x033,      0x0000006A,
+	0x03F,      0x00000077, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x00000007, 0x033,      0x00000061,
+	0x03F,      0x0000000A, 0x033,      0x00000062, 0x03F,      0x0000000D,
+	0x033,      0x00000063, 0x03F,      0x0000002A, 0x033,      0x00000064,
+	0x03F,      0x0000002D, 0x033,      0x00000065, 0x03F,      0x00000030,
+	0x033,      0x00000066, 0x03F,      0x0000006D, 0x033,      0x00000067,
+	0x03F,      0x00000070, 0x033,      0x00000068, 0x03F,      0x000000ED,
+	0x033,      0x00000069, 0x03F,      0x000000F0, 0x033,      0x0000006A,
+	0x03F,      0x000000F3, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x00000007, 0x033,      0x00000061,
+	0x03F,      0x0000000A, 0x033,      0x00000062, 0x03F,      0x0000000D,
+	0x033,      0x00000063, 0x03F,      0x0000002A, 0x033,      0x00000064,
+	0x03F,      0x0000002D, 0x033,      0x00000065, 0x03F,      0x00000030,
+	0x033,      0x00000066, 0x03F,      0x0000006D, 0x033,      0x00000067,
+	0x03F,      0x00000070, 0x033,      0x00000068, 0x03F,      0x000000ED,
+	0x033,      0x00000069, 0x03F,      0x000000F0, 0x033,      0x0000006A,
+	0x03F,      0x000000F3, 0x9000100f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x00000007, 0x033,      0x00000061,
+	0x03F,      0x0000000A, 0x033,      0x00000062, 0x03F,      0x0000000D,
+	0x033,      0x00000063, 0x03F,      0x0000002A, 0x033,      0x00000064,
+	0x03F,      0x0000002D, 0x033,      0x00000065, 0x03F,      0x00000030,
+	0x033,      0x00000066, 0x03F,      0x0000006D, 0x033,      0x00000067,
+	0x03F,      0x00000070, 0x033,      0x00000068, 0x03F,      0x000000ED,
+	0x033,      0x00000069, 0x03F,      0x000000F0, 0x033,      0x0000006A,
+	0x03F,      0x000000F3, 0x9000200f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x00000005, 0x033,      0x00000061,
+	0x03F,      0x00000008, 0x033,      0x00000062, 0x03F,      0x0000000B,
+	0x033,      0x00000063, 0x03F,      0x0000000E, 0x033,      0x00000064,
+	0x03F,      0x0000002B, 0x033,      0x00000065, 0x03F,      0x00000068,
+	0x033,      0x00000066, 0x03F,      0x0000006B, 0x033,      0x00000067,
+	0x03F,      0x0000006E, 0x033,      0x00000068, 0x03F,      0x00000071,
+	0x033,      0x00000069, 0x03F,      0x00000074, 0x033,      0x0000006A,
+	0x03F,      0x00000077, 0x9300200c, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x00000005, 0x033,      0x00000061,
+	0x03F,      0x00000008, 0x033,      0x00000062, 0x03F,      0x0000000B,
+	0x033,      0x00000063, 0x03F,      0x0000000E, 0x033,      0x00000064,
+	0x03F,      0x0000002B, 0x033,      0x00000065, 0x03F,      0x00000068,
+	0x033,      0x00000066, 0x03F,      0x0000006B, 0x033,      0x00000067,
+	0x03F,      0x0000006E, 0x033,      0x00000068, 0x03F,      0x00000071,
+	0x033,      0x00000069, 0x03F,      0x00000074, 0x033,      0x0000006A,
+	0x03F,      0x00000077, 0x93012100, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x0000080B, 0x033,      0x00000061,
+	0x03F,      0x0000080E, 0x033,      0x00000062, 0x03F,      0x00000848,
+	0x033,      0x00000063, 0x03F,      0x00000869, 0x033,      0x00000064,
+	0x03F,      0x000008A9, 0x033,      0x00000065, 0x03F,      0x00000CE8,
+	0x033,      0x00000066, 0x03F,      0x00000CEB, 0x033,      0x00000067,
+	0x03F,      0x00000CEE, 0x033,      0x00000068, 0x03F,      0x00000CF1,
+	0x033,      0x00000069, 0x03F,      0x00000CF4, 0x033,      0x0000006A,
+	0x03F,      0x00000CF7, 0x93002100, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x0000042B, 0x033,      0x00000061,
+	0x03F,      0x0000082A, 0x033,      0x00000062, 0x03F,      0x00000849,
+	0x033,      0x00000063, 0x03F,      0x0000084C, 0x033,      0x00000064,
+	0x03F,      0x00000C4C, 0x033,      0x00000065, 0x03F,      0x00000CA9,
+	0x033,      0x00000066, 0x03F,      0x00000CEA, 0x033,      0x00000067,
+	0x03F,      0x00000CED, 0x033,      0x00000068, 0x03F,      0x00000CF0,
+	0x033,      0x00000069, 0x03F,      0x00000CF3, 0x033,      0x0000006A,
+	0x03F,      0x00000CF6, 0x93011000, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x00000C0A, 0x033,      0x00000061,
+	0x03F,      0x00000C0D, 0x033,      0x00000062, 0x03F,      0x00000C2A,
+	0x033,      0x00000063, 0x03F,      0x00000C2D, 0x033,      0x00000064,
+	0x03F,      0x00000C6A, 0x033,      0x00000065, 0x03F,      0x00000CAA,
+	0x033,      0x00000066, 0x03F,      0x00000CAD, 0x033,      0x00000067,
+	0x03F,      0x00000CB0, 0x033,      0x00000068, 0x03F,      0x00000CF1,
+	0x033,      0x00000069, 0x03F,      0x00000CF4, 0x033,      0x0000006A,
+	0x03F,      0x00000CF7, 0x9000200c, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x00000005, 0x033,      0x00000061,
+	0x03F,      0x00000008, 0x033,      0x00000062, 0x03F,      0x0000000B,
+	0x033,      0x00000063, 0x03F,      0x0000000E, 0x033,      0x00000064,
+	0x03F,      0x0000002B, 0x033,      0x00000065, 0x03F,      0x00000068,
+	0x033,      0x00000066, 0x03F,      0x0000006B, 0x033,      0x00000067,
+	0x03F,      0x0000006E, 0x033,      0x00000068, 0x03F,      0x00000071,
+	0x033,      0x00000069, 0x03F,      0x00000074, 0x033,      0x0000006A,
+	0x03F,      0x00000077, 0x90001004, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x00000C0A, 0x033,      0x00000061,
+	0x03F,      0x00000C0D, 0x033,      0x00000062, 0x03F,      0x00000C2A,
+	0x033,      0x00000063, 0x03F,      0x00000C2D, 0x033,      0x00000064,
+	0x03F,      0x00000C6A, 0x033,      0x00000065, 0x03F,      0x00000CAA,
+	0x033,      0x00000066, 0x03F,      0x00000CAD, 0x033,      0x00000067,
+	0x03F,      0x00000CB0, 0x033,      0x00000068, 0x03F,      0x00000CF1,
+	0x033,      0x00000069, 0x03F,      0x00000CF4, 0x033,      0x0000006A,
+	0x03F,      0x00000CF7, 0x93002000, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x00000429, 0x033,      0x00000061,
+	0x03F,      0x00000828, 0x033,      0x00000062, 0x03F,      0x00000847,
+	0x033,      0x00000063, 0x03F,      0x0000084A, 0x033,      0x00000064,
+	0x03F,      0x00000C4B, 0x033,      0x00000065, 0x03F,      0x00000C8A,
+	0x033,      0x00000066, 0x03F,      0x00000CEA, 0x033,      0x00000067,
+	0x03F,      0x00000CED, 0x033,      0x00000068, 0x03F,      0x00000CF0,
+	0x033,      0x00000069, 0x03F,      0x00000CF3, 0x033,      0x0000006A,
+	0x03F,      0x00000CF6, 0x93001000, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x00000C0A, 0x033,      0x00000061,
+	0x03F,      0x00000C0D, 0x033,      0x00000062, 0x03F,      0x00000C2A,
+	0x033,      0x00000063, 0x03F,      0x00000C2D, 0x033,      0x00000064,
+	0x03F,      0x00000C6A, 0x033,      0x00000065, 0x03F,      0x00000CAA,
+	0x033,      0x00000066, 0x03F,      0x00000CAD, 0x033,      0x00000067,
+	0x03F,      0x00000CB0, 0x033,      0x00000068, 0x03F,      0x00000CF1,
+	0x033,      0x00000069, 0x03F,      0x00000CF4, 0x033,      0x0000006A,
+	0x03F,      0x00000CF7, 0x90002100, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x0000042C, 0x033,      0x00000061,
+	0x03F,      0x0000082B, 0x033,      0x00000062, 0x03F,      0x0000084A,
+	0x033,      0x00000063, 0x03F,      0x0000084D, 0x033,      0x00000064,
+	0x03F,      0x00000C4D, 0x033,      0x00000065, 0x03F,      0x00000C8B,
+	0x033,      0x00000066, 0x03F,      0x00000C8E, 0x033,      0x00000067,
+	0x03F,      0x00000CEC, 0x033,      0x00000068, 0x03F,      0x00000CEF,
+	0x033,      0x00000069, 0x03F,      0x00000CF2, 0x033,      0x0000006A,
+	0x03F,      0x00000CF5, 0x90002000, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000060, 0x03F,      0x0000042C, 0x033,      0x00000061,
+	0x03F,      0x0000082B, 0x033,      0x00000062, 0x03F,      0x0000084A,
+	0x033,      0x00000063, 0x03F,      0x0000084D, 0x033,      0x00000064,
+	0x03F,      0x00000C4D, 0x033,      0x00000065, 0x03F,      0x00000C8B,
+	0x033,      0x00000066, 0x03F,      0x00000C8E, 0x033,      0x00000067,
+	0x03F,      0x00000CEC, 0x033,      0x00000068, 0x03F,      0x00000CEF,
+	0x033,      0x00000069, 0x03F,      0x00000CF2, 0x033,      0x0000006A,
+	0x03F,      0x00000CF5, 0xA0000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000C0A, 0x033,      0x00000061, 0x03F,      0x00000C0D,
+	0x033,      0x00000062, 0x03F,      0x00000C2A, 0x033,      0x00000063,
+	0x03F,      0x00000C2D, 0x033,      0x00000064, 0x03F,      0x00000C6A,
+	0x033,      0x00000065, 0x03F,      0x00000CAA, 0x033,      0x00000066,
+	0x03F,      0x00000CAD, 0x033,      0x00000067, 0x03F,      0x00000CB0,
+	0x033,      0x00000068, 0x03F,      0x00000CF1, 0x033,      0x00000069,
+	0x03F,      0x00000CF4, 0x033,      0x0000006A, 0x03F,      0x00000CF7,
+	0xB0000000, 0x00000000, 0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x00000007, 0x033,      0x000000A1,
+	0x03F,      0x0000000A, 0x033,      0x000000A2, 0x03F,      0x0000000D,
+	0x033,      0x000000A3, 0x03F,      0x0000002A, 0x033,      0x000000A4,
+	0x03F,      0x0000002D, 0x033,      0x000000A5, 0x03F,      0x00000030,
+	0x033,      0x000000A6, 0x03F,      0x0000006D, 0x033,      0x000000A7,
+	0x03F,      0x00000070, 0x033,      0x000000A8, 0x03F,      0x000000ED,
+	0x033,      0x000000A9, 0x03F,      0x000000F0, 0x033,      0x000000AA,
+	0x03F,      0x000000F3, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x00000007, 0x033,      0x000000A1,
+	0x03F,      0x0000000A, 0x033,      0x000000A2, 0x03F,      0x0000000D,
+	0x033,      0x000000A3, 0x03F,      0x0000002A, 0x033,      0x000000A4,
+	0x03F,      0x0000002D, 0x033,      0x000000A5, 0x03F,      0x00000030,
+	0x033,      0x000000A6, 0x03F,      0x0000006D, 0x033,      0x000000A7,
+	0x03F,      0x00000070, 0x033,      0x000000A8, 0x03F,      0x000000ED,
+	0x033,      0x000000A9, 0x03F,      0x000000F0, 0x033,      0x000000AA,
+	0x03F,      0x000000F3, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x00000007, 0x033,      0x000000A1,
+	0x03F,      0x0000000A, 0x033,      0x000000A2, 0x03F,      0x0000000D,
+	0x033,      0x000000A3, 0x03F,      0x0000002A, 0x033,      0x000000A4,
+	0x03F,      0x0000002D, 0x033,      0x000000A5, 0x03F,      0x00000030,
+	0x033,      0x000000A6, 0x03F,      0x0000006D, 0x033,      0x000000A7,
+	0x03F,      0x00000070, 0x033,      0x000000A8, 0x03F,      0x000000ED,
+	0x033,      0x000000A9, 0x03F,      0x000000F0, 0x033,      0x000000AA,
+	0x03F,      0x000000F3, 0x9300200f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x00000005, 0x033,      0x000000A1,
+	0x03F,      0x00000008, 0x033,      0x000000A2, 0x03F,      0x0000000B,
+	0x033,      0x000000A3, 0x03F,      0x0000000E, 0x033,      0x000000A4,
+	0x03F,      0x00000047, 0x033,      0x000000A5, 0x03F,      0x0000004A,
+	0x033,      0x000000A6, 0x03F,      0x0000004D, 0x033,      0x000000A7,
+	0x03F,      0x00000050, 0x033,      0x000000A8, 0x03F,      0x00000053,
+	0x033,      0x000000A9, 0x03F,      0x00000056, 0x033,      0x000000AA,
+	0x03F,      0x00000094, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x00000007, 0x033,      0x000000A1,
+	0x03F,      0x0000000A, 0x033,      0x000000A2, 0x03F,      0x0000000D,
+	0x033,      0x000000A3, 0x03F,      0x0000002A, 0x033,      0x000000A4,
+	0x03F,      0x0000002D, 0x033,      0x000000A5, 0x03F,      0x00000030,
+	0x033,      0x000000A6, 0x03F,      0x0000006D, 0x033,      0x000000A7,
+	0x03F,      0x00000070, 0x033,      0x000000A8, 0x03F,      0x000000ED,
+	0x033,      0x000000A9, 0x03F,      0x000000F0, 0x033,      0x000000AA,
+	0x03F,      0x000000F3, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x00000007, 0x033,      0x000000A1,
+	0x03F,      0x0000000A, 0x033,      0x000000A2, 0x03F,      0x0000000D,
+	0x033,      0x000000A3, 0x03F,      0x0000002A, 0x033,      0x000000A4,
+	0x03F,      0x0000002D, 0x033,      0x000000A5, 0x03F,      0x00000030,
+	0x033,      0x000000A6, 0x03F,      0x0000006D, 0x033,      0x000000A7,
+	0x03F,      0x00000070, 0x033,      0x000000A8, 0x03F,      0x000000ED,
+	0x033,      0x000000A9, 0x03F,      0x000000F0, 0x033,      0x000000AA,
+	0x03F,      0x000000F3, 0x9000100f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x00000007, 0x033,      0x000000A1,
+	0x03F,      0x0000000A, 0x033,      0x000000A2, 0x03F,      0x0000000D,
+	0x033,      0x000000A3, 0x03F,      0x0000002A, 0x033,      0x000000A4,
+	0x03F,      0x0000002D, 0x033,      0x000000A5, 0x03F,      0x00000030,
+	0x033,      0x000000A6, 0x03F,      0x0000006D, 0x033,      0x000000A7,
+	0x03F,      0x00000070, 0x033,      0x000000A8, 0x03F,      0x000000ED,
+	0x033,      0x000000A9, 0x03F,      0x000000F0, 0x033,      0x000000AA,
+	0x03F,      0x000000F3, 0x9000200f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x00000005, 0x033,      0x000000A1,
+	0x03F,      0x00000008, 0x033,      0x000000A2, 0x03F,      0x0000000B,
+	0x033,      0x000000A3, 0x03F,      0x0000000E, 0x033,      0x000000A4,
+	0x03F,      0x00000047, 0x033,      0x000000A5, 0x03F,      0x0000004A,
+	0x033,      0x000000A6, 0x03F,      0x0000004D, 0x033,      0x000000A7,
+	0x03F,      0x00000050, 0x033,      0x000000A8, 0x03F,      0x00000053,
+	0x033,      0x000000A9, 0x03F,      0x00000056, 0x033,      0x000000AA,
+	0x03F,      0x00000094, 0x9300200c, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x00000005, 0x033,      0x000000A1,
+	0x03F,      0x00000008, 0x033,      0x000000A2, 0x03F,      0x0000000B,
+	0x033,      0x000000A3, 0x03F,      0x0000000E, 0x033,      0x000000A4,
+	0x03F,      0x00000047, 0x033,      0x000000A5, 0x03F,      0x0000004A,
+	0x033,      0x000000A6, 0x03F,      0x0000004D, 0x033,      0x000000A7,
+	0x03F,      0x00000050, 0x033,      0x000000A8, 0x03F,      0x00000053,
+	0x033,      0x000000A9, 0x03F,      0x00000056, 0x033,      0x000000AA,
+	0x03F,      0x00000094, 0x93012100, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x00000C0A, 0x033,      0x000000A1,
+	0x03F,      0x00000C0D, 0x033,      0x000000A2, 0x03F,      0x00000C2A,
+	0x033,      0x000000A3, 0x03F,      0x00000C2D, 0x033,      0x000000A4,
+	0x03F,      0x00000C6A, 0x033,      0x000000A5, 0x03F,      0x00000CE8,
+	0x033,      0x000000A6, 0x03F,      0x00000CEB, 0x033,      0x000000A7,
+	0x03F,      0x00000CEE, 0x033,      0x000000A8, 0x03F,      0x00000CF1,
+	0x033,      0x000000A9, 0x03F,      0x00000CF4, 0x033,      0x000000AA,
+	0x03F,      0x00000CF7, 0x93002100, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x0000042A, 0x033,      0x000000A1,
+	0x03F,      0x00000829, 0x033,      0x000000A2, 0x03F,      0x00000848,
+	0x033,      0x000000A3, 0x03F,      0x0000084B, 0x033,      0x000000A4,
+	0x03F,      0x00000C4C, 0x033,      0x000000A5, 0x03F,      0x00000CA9,
+	0x033,      0x000000A6, 0x03F,      0x00000CEA, 0x033,      0x000000A7,
+	0x03F,      0x00000CED, 0x033,      0x000000A8, 0x03F,      0x00000CF0,
+	0x033,      0x000000A9, 0x03F,      0x00000CF3, 0x033,      0x000000AA,
+	0x03F,      0x00000CF6, 0x93011000, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x00000C09, 0x033,      0x000000A1,
+	0x03F,      0x00000C0C, 0x033,      0x000000A2, 0x03F,      0x00000C0F,
+	0x033,      0x000000A3, 0x03F,      0x00000C2C, 0x033,      0x000000A4,
+	0x03F,      0x00000C2F, 0x033,      0x000000A5, 0x03F,      0x00000C8A,
+	0x033,      0x000000A6, 0x03F,      0x00000C8D, 0x033,      0x000000A7,
+	0x03F,      0x00000C90, 0x033,      0x000000A8, 0x03F,      0x00000CEF,
+	0x033,      0x000000A9, 0x03F,      0x00000CF2, 0x033,      0x000000AA,
+	0x03F,      0x00000CF5, 0x9000200c, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x00000005, 0x033,      0x000000A1,
+	0x03F,      0x00000008, 0x033,      0x000000A2, 0x03F,      0x0000000B,
+	0x033,      0x000000A3, 0x03F,      0x0000000E, 0x033,      0x000000A4,
+	0x03F,      0x00000047, 0x033,      0x000000A5, 0x03F,      0x0000004A,
+	0x033,      0x000000A6, 0x03F,      0x0000004D, 0x033,      0x000000A7,
+	0x03F,      0x00000050, 0x033,      0x000000A8, 0x03F,      0x00000053,
+	0x033,      0x000000A9, 0x03F,      0x00000056, 0x033,      0x000000AA,
+	0x03F,      0x00000094, 0x90001004, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x00000C09, 0x033,      0x000000A1,
+	0x03F,      0x00000C0C, 0x033,      0x000000A2, 0x03F,      0x00000C0F,
+	0x033,      0x000000A3, 0x03F,      0x00000C2C, 0x033,      0x000000A4,
+	0x03F,      0x00000C2F, 0x033,      0x000000A5, 0x03F,      0x00000C8A,
+	0x033,      0x000000A6, 0x03F,      0x00000C8D, 0x033,      0x000000A7,
+	0x03F,      0x00000C90, 0x033,      0x000000A8, 0x03F,      0x00000CEF,
+	0x033,      0x000000A9, 0x03F,      0x00000CF2, 0x033,      0x000000AA,
+	0x03F,      0x00000CF5, 0x93002000, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x00000429, 0x033,      0x000000A1,
+	0x03F,      0x00000828, 0x033,      0x000000A2, 0x03F,      0x00000847,
+	0x033,      0x000000A3, 0x03F,      0x0000084A, 0x033,      0x000000A4,
+	0x03F,      0x00000C4B, 0x033,      0x000000A5, 0x03F,      0x00000C8A,
+	0x033,      0x000000A6, 0x03F,      0x00000CEA, 0x033,      0x000000A7,
+	0x03F,      0x00000CED, 0x033,      0x000000A8, 0x03F,      0x00000CF0,
+	0x033,      0x000000A9, 0x03F,      0x00000CF3, 0x033,      0x000000AA,
+	0x03F,      0x00000CF6, 0x93001000, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x00000C09, 0x033,      0x000000A1,
+	0x03F,      0x00000C0C, 0x033,      0x000000A2, 0x03F,      0x00000C0F,
+	0x033,      0x000000A3, 0x03F,      0x00000C2C, 0x033,      0x000000A4,
+	0x03F,      0x00000C2F, 0x033,      0x000000A5, 0x03F,      0x00000C8A,
+	0x033,      0x000000A6, 0x03F,      0x00000C8D, 0x033,      0x000000A7,
+	0x03F,      0x00000C90, 0x033,      0x000000A8, 0x03F,      0x00000CEF,
+	0x033,      0x000000A9, 0x03F,      0x00000CF2, 0x033,      0x000000AA,
+	0x03F,      0x00000CF5, 0x90002100, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x0000042A, 0x033,      0x000000A1,
+	0x03F,      0x00000829, 0x033,      0x000000A2, 0x03F,      0x00000848,
+	0x033,      0x000000A3, 0x03F,      0x0000084B, 0x033,      0x000000A4,
+	0x03F,      0x00000C4C, 0x033,      0x000000A5, 0x03F,      0x00000C8A,
+	0x033,      0x000000A6, 0x03F,      0x00000C8D, 0x033,      0x000000A7,
+	0x03F,      0x00000CEB, 0x033,      0x000000A8, 0x03F,      0x00000CEE,
+	0x033,      0x000000A9, 0x03F,      0x00000CF1, 0x033,      0x000000AA,
+	0x03F,      0x00000CF4, 0x90002000, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x000000A0, 0x03F,      0x0000042A, 0x033,      0x000000A1,
+	0x03F,      0x00000829, 0x033,      0x000000A2, 0x03F,      0x00000848,
+	0x033,      0x000000A3, 0x03F,      0x0000084B, 0x033,      0x000000A4,
+	0x03F,      0x00000C4C, 0x033,      0x000000A5, 0x03F,      0x00000C8A,
+	0x033,      0x000000A6, 0x03F,      0x00000C8D, 0x033,      0x000000A7,
+	0x03F,      0x00000CEB, 0x033,      0x000000A8, 0x03F,      0x00000CEE,
+	0x033,      0x000000A9, 0x03F,      0x00000CF1, 0x033,      0x000000AA,
+	0x03F,      0x00000CF4, 0xA0000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000C09, 0x033,      0x000000A1, 0x03F,      0x00000C0C,
+	0x033,      0x000000A2, 0x03F,      0x00000C0F, 0x033,      0x000000A3,
+	0x03F,      0x00000C2C, 0x033,      0x000000A4, 0x03F,      0x00000C2F,
+	0x033,      0x000000A5, 0x03F,      0x00000C8A, 0x033,      0x000000A6,
+	0x03F,      0x00000C8D, 0x033,      0x000000A7, 0x03F,      0x00000C90,
+	0x033,      0x000000A8, 0x03F,      0x00000CEF, 0x033,      0x000000A9,
+	0x03F,      0x00000CF2, 0x033,      0x000000AA, 0x03F,      0x00000CF5,
+	0xB0000000, 0x00000000, 0x0EF,      0x00000000, 0x0EF,      0x00000400,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x0000047C, 0x033,      0x00000001, 0x03F,      0x0000047C,
+	0x033,      0x00000002, 0x03F,      0x0000047C, 0x033,      0x00000003,
+	0x03F,      0x0000047C, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x033,      0x00000000, 0x03F,      0x0000047C, 0x033,      0x00000001,
+	0x03F,      0x0000047C, 0x033,      0x00000002, 0x03F,      0x0000047C,
+	0x033,      0x00000003, 0x03F,      0x0000047C, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x0000047C,
+	0x033,      0x00000001, 0x03F,      0x0000047C, 0x033,      0x00000002,
+	0x03F,      0x0000047C, 0x033,      0x00000003, 0x03F,      0x0000047C,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x0000047C, 0x033,      0x00000001, 0x03F,      0x0000047C,
+	0x033,      0x00000002, 0x03F,      0x0000047C, 0x033,      0x00000003,
+	0x03F,      0x0000047C, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x033,      0x00000000, 0x03F,      0x0000047C, 0x033,      0x00000001,
+	0x03F,      0x0000047C, 0x033,      0x00000002, 0x03F,      0x0000047C,
+	0x033,      0x00000003, 0x03F,      0x0000047C, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x0000047C,
+	0x033,      0x00000001, 0x03F,      0x0000047C, 0x033,      0x00000002,
+	0x03F,      0x0000047C, 0x033,      0x00000003, 0x03F,      0x0000047C,
+	0x9000100f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x0000047C, 0x033,      0x00000001, 0x03F,      0x0000047C,
+	0x033,      0x00000002, 0x03F,      0x0000047C, 0x033,      0x00000003,
+	0x03F,      0x0000047C, 0x9000200f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000000, 0x03F,      0x0000047C, 0x033,      0x00000001,
+	0x03F,      0x0000047C, 0x033,      0x00000002, 0x03F,      0x0000047C,
+	0x033,      0x00000003, 0x03F,      0x0000047C, 0xA0000000, 0x00000000,
+	0x033,      0x00000000, 0x03F,      0x000004BB, 0x033,      0x00000001,
+	0x03F,      0x000004BB, 0x033,      0x00000002, 0x03F,      0x000004BB,
+	0x033,      0x00000003, 0x03F,      0x000004BB, 0xB0000000, 0x00000000,
+	0x0EF,      0x00000000, 0x0EF,      0x00000100, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x00001726,
+	0x033,      0x00000001, 0x03F,      0x00001726, 0x033,      0x00000002,
+	0x03F,      0x00001726, 0x033,      0x00000003, 0x03F,      0x00001726,
+	0x9300100f, 0x05050505, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x00001726, 0x033,      0x00000001, 0x03F,      0x00001726,
+	0x033,      0x00000002, 0x03F,      0x00001726, 0x033,      0x00000003,
+	0x03F,      0x00001726, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000000, 0x03F,      0x00001726, 0x033,      0x00000001,
+	0x03F,      0x00001726, 0x033,      0x00000002, 0x03F,      0x00001726,
+	0x033,      0x00000003, 0x03F,      0x00001726, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x00001726,
+	0x033,      0x00000001, 0x03F,      0x00001726, 0x033,      0x00000002,
+	0x03F,      0x00001726, 0x033,      0x00000003, 0x03F,      0x00001726,
+	0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x00001726, 0x033,      0x00000001, 0x03F,      0x00001726,
+	0x033,      0x00000002, 0x03F,      0x00001726, 0x033,      0x00000003,
+	0x03F,      0x00001726, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x033,      0x00000000, 0x03F,      0x00001726, 0x033,      0x00000001,
+	0x03F,      0x00001726, 0x033,      0x00000002, 0x03F,      0x00001726,
+	0x033,      0x00000003, 0x03F,      0x00001726, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x00001726,
+	0x033,      0x00000001, 0x03F,      0x00001726, 0x033,      0x00000002,
+	0x03F,      0x00001726, 0x033,      0x00000003, 0x03F,      0x00001726,
+	0x9000200f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x00001726, 0x033,      0x00000001, 0x03F,      0x00001726,
+	0x033,      0x00000002, 0x03F,      0x00001726, 0x033,      0x00000003,
+	0x03F,      0x00001726, 0xA0000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x00000F34, 0x033,      0x00000001, 0x03F,      0x00000F34,
+	0x033,      0x00000002, 0x03F,      0x00000F34, 0x033,      0x00000003,
+	0x03F,      0x00000F34, 0xB0000000, 0x00000000, 0x0EF,      0x00000000,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x081,      0x0000F400,
+	0x087,      0x00016040, 0x051,      0x00000808, 0x052,      0x00098002,
+	0x053,      0x0000FA47, 0x054,      0x00058032, 0x056,      0x00051000,
+	0x057,      0x0000CE0A, 0x058,      0x00082030, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x081,      0x0000F400, 0x087,      0x00016040,
+	0x051,      0x00000808, 0x052,      0x00098002, 0x053,      0x0000FA47,
+	0x054,      0x00058032, 0x056,      0x00051000, 0x057,      0x0000CE0A,
+	0x058,      0x00082030, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x081,      0x0000F400, 0x087,      0x00016040, 0x051,      0x00000808,
+	0x052,      0x00098002, 0x053,      0x0000FA47, 0x054,      0x00058032,
+	0x056,      0x00051000, 0x057,      0x0000CE0A, 0x058,      0x00082030,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x081,      0x0000F400,
+	0x087,      0x00016040, 0x051,      0x00000808, 0x052,      0x00098002,
+	0x053,      0x0000FA47, 0x054,      0x00058032, 0x056,      0x00051000,
+	0x057,      0x0000CE0A, 0x058,      0x00082030, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x081,      0x0000F400, 0x087,      0x00016040,
+	0x051,      0x00000808, 0x052,      0x00098002, 0x053,      0x0000FA47,
+	0x054,      0x00058032, 0x056,      0x00051000, 0x057,      0x0000CE0A,
+	0x058,      0x00082030, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x081,      0x0000F400, 0x087,      0x00016040, 0x051,      0x00000808,
+	0x052,      0x00098002, 0x053,      0x0000FA47, 0x054,      0x00058032,
+	0x056,      0x00051000, 0x057,      0x0000CE0A, 0x058,      0x00082030,
+	0x9000100f, 0x00000000, 0x40000000, 0x00000000, 0x081,      0x0000F400,
+	0x087,      0x00016040, 0x051,      0x00000808, 0x052,      0x00098002,
+	0x053,      0x0000FA47, 0x054,      0x00058032, 0x056,      0x00051000,
+	0x057,      0x0000CE0A, 0x058,      0x00082030, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x081,      0x0000F400, 0x087,      0x00016040,
+	0x051,      0x00000808, 0x052,      0x00098002, 0x053,      0x0000FA47,
+	0x054,      0x00058032, 0x056,      0x00051000, 0x057,      0x0000CE0A,
+	0x058,      0x00082030, 0xA0000000, 0x00000000, 0x081,      0x0000F000,
+	0x087,      0x00016040, 0x051,      0x00000C00, 0x052,      0x0007C241,
+	0x053,      0x0001C069, 0x054,      0x00078032, 0x057,      0x0000CE0A,
+	0x058,      0x00058750, 0xB0000000, 0x00000000, 0x0EF,      0x00000800,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x00000003, 0x033,      0x00000001, 0x03F,      0x00000006,
+	0x033,      0x00000002, 0x03F,      0x00000009, 0x033,      0x00000003,
+	0x03F,      0x00000026, 0x033,      0x00000004, 0x03F,      0x00000029,
+	0x033,      0x00000005, 0x03F,      0x0000002C, 0x033,      0x00000006,
+	0x03F,      0x0000002F, 0x033,      0x00000007, 0x03F,      0x00000033,
+	0x033,      0x00000008, 0x03F,      0x00000036, 0x033,      0x00000009,
+	0x03F,      0x00000039, 0x033,      0x0000000A, 0x03F,      0x0000003C,
+	0x9300100f, 0x05050505, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x00000003, 0x033,      0x00000001, 0x03F,      0x00000006,
+	0x033,      0x00000002, 0x03F,      0x00000009, 0x033,      0x00000003,
+	0x03F,      0x00000026, 0x033,      0x00000004, 0x03F,      0x00000029,
+	0x033,      0x00000005, 0x03F,      0x0000002C, 0x033,      0x00000006,
+	0x03F,      0x0000002F, 0x033,      0x00000007, 0x03F,      0x00000033,
+	0x033,      0x00000008, 0x03F,      0x00000036, 0x033,      0x00000009,
+	0x03F,      0x00000039, 0x033,      0x0000000A, 0x03F,      0x0000003C,
+	0x9300100f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x00000003, 0x033,      0x00000001, 0x03F,      0x00000006,
+	0x033,      0x00000002, 0x03F,      0x00000009, 0x033,      0x00000003,
+	0x03F,      0x00000026, 0x033,      0x00000004, 0x03F,      0x00000029,
+	0x033,      0x00000005, 0x03F,      0x0000002C, 0x033,      0x00000006,
+	0x03F,      0x0000002F, 0x033,      0x00000007, 0x03F,      0x00000033,
+	0x033,      0x00000008, 0x03F,      0x00000036, 0x033,      0x00000009,
+	0x03F,      0x00000039, 0x033,      0x0000000A, 0x03F,      0x0000003C,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x00000003, 0x033,      0x00000001, 0x03F,      0x00000006,
+	0x033,      0x00000002, 0x03F,      0x00000009, 0x033,      0x00000003,
+	0x03F,      0x00000026, 0x033,      0x00000004, 0x03F,      0x00000029,
+	0x033,      0x00000005, 0x03F,      0x0000002C, 0x033,      0x00000006,
+	0x03F,      0x0000002F, 0x033,      0x00000007, 0x03F,      0x00000033,
+	0x033,      0x00000008, 0x03F,      0x00000036, 0x033,      0x00000009,
+	0x03F,      0x00000039, 0x033,      0x0000000A, 0x03F,      0x0000003C,
+	0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x00000003, 0x033,      0x00000001, 0x03F,      0x00000006,
+	0x033,      0x00000002, 0x03F,      0x00000009, 0x033,      0x00000003,
+	0x03F,      0x00000026, 0x033,      0x00000004, 0x03F,      0x00000029,
+	0x033,      0x00000005, 0x03F,      0x0000002C, 0x033,      0x00000006,
+	0x03F,      0x0000002F, 0x033,      0x00000007, 0x03F,      0x00000033,
+	0x033,      0x00000008, 0x03F,      0x00000036, 0x033,      0x00000009,
+	0x03F,      0x00000039, 0x033,      0x0000000A, 0x03F,      0x0000003C,
+	0x9000100f, 0x05050505, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x00000003, 0x033,      0x00000001, 0x03F,      0x00000006,
+	0x033,      0x00000002, 0x03F,      0x00000009, 0x033,      0x00000003,
+	0x03F,      0x00000026, 0x033,      0x00000004, 0x03F,      0x00000029,
+	0x033,      0x00000005, 0x03F,      0x0000002C, 0x033,      0x00000006,
+	0x03F,      0x0000002F, 0x033,      0x00000007, 0x03F,      0x00000033,
+	0x033,      0x00000008, 0x03F,      0x00000036, 0x033,      0x00000009,
+	0x03F,      0x00000039, 0x033,      0x0000000A, 0x03F,      0x0000003C,
+	0x9000100f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x00000003, 0x033,      0x00000001, 0x03F,      0x00000006,
+	0x033,      0x00000002, 0x03F,      0x00000009, 0x033,      0x00000003,
+	0x03F,      0x00000026, 0x033,      0x00000004, 0x03F,      0x00000029,
+	0x033,      0x00000005, 0x03F,      0x0000002C, 0x033,      0x00000006,
+	0x03F,      0x0000002F, 0x033,      0x00000007, 0x03F,      0x00000033,
+	0x033,      0x00000008, 0x03F,      0x00000036, 0x033,      0x00000009,
+	0x03F,      0x00000039, 0x033,      0x0000000A, 0x03F,      0x0000003C,
+	0x9000200f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x00000003, 0x033,      0x00000001, 0x03F,      0x00000006,
+	0x033,      0x00000002, 0x03F,      0x00000009, 0x033,      0x00000003,
+	0x03F,      0x00000026, 0x033,      0x00000004, 0x03F,      0x00000029,
+	0x033,      0x00000005, 0x03F,      0x0000002C, 0x033,      0x00000006,
+	0x03F,      0x0000002F, 0x033,      0x00000007, 0x03F,      0x00000033,
+	0x033,      0x00000008, 0x03F,      0x00000036, 0x033,      0x00000009,
+	0x03F,      0x00000039, 0x033,      0x0000000A, 0x03F,      0x0000003C,
+	0xA0000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x0005142C,
+	0x033,      0x00000001, 0x03F,      0x0005144B, 0x033,      0x00000002,
+	0x03F,      0x0005144E, 0x033,      0x00000003, 0x03F,      0x00051C69,
+	0x033,      0x00000004, 0x03F,      0x00051C6C, 0x033,      0x00000005,
+	0x03F,      0x00051C6F, 0x033,      0x00000006, 0x03F,      0x00051CEB,
+	0x033,      0x00000007, 0x03F,      0x00051CEE, 0x033,      0x00000008,
+	0x03F,      0x00051CF1, 0x033,      0x00000009, 0x03F,      0x00051CF4,
+	0x033,      0x0000000A, 0x03F,      0x00051CF7, 0xB0000000, 0x00000000,
+	0x0EF,      0x00000000, 0x0EF,      0x00000010, 0x033,      0x00000000,
+	0x008,      0x0009C060, 0x033,      0x00000001, 0x008,      0x0009C060,
+	0x0EF,      0x00000000, 0x033,      0x000000A2, 0x0EF,      0x00080000,
+	0x03E,      0x0000593F, 0x03F,      0x000C0F4F, 0x0EF,      0x00000000,
+	0x033,      0x000000A3, 0x0EF,      0x00080000, 0x03E,      0x00005934,
+	0x03F,      0x0005AFCF, 0x0EF,      0x00000000,
+
+};
+
+void odm_read_and_config_mp_8822b_radioa(struct phy_dm_struct *dm)
+{
+	u32 i = 0;
+	u8 c_cond;
+	bool is_matched = true, is_skipped = false;
+	u32 array_len = sizeof(array_mp_8822b_radioa) / sizeof(u32);
+	u32 *array = array_mp_8822b_radioa;
+
+	u32 v1 = 0, v2 = 0, pre_v1 = 0, pre_v2 = 0;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "===> %s\n", __func__);
+
+	for (; (i + 1) < array_len; i = i + 2) {
+		v1 = array[i];
+		v2 = array[i + 1];
+
+		if (v1 & BIT(31)) { /* positive condition*/
+			c_cond = (u8)((v1 & (BIT(29) | BIT(28))) >> 28);
+			if (c_cond == COND_ENDIF) { /*end*/
+				is_matched = true;
+				is_skipped = false;
+				ODM_RT_TRACE(dm, ODM_COMP_INIT, "ENDIF\n");
+			} else if (c_cond == COND_ELSE) { /*else*/
+				is_matched = is_skipped ? false : true;
+				ODM_RT_TRACE(dm, ODM_COMP_INIT, "ELSE\n");
+			} else { /*if , else if*/
+				pre_v1 = v1;
+				pre_v2 = v2;
+				ODM_RT_TRACE(dm, ODM_COMP_INIT,
+					     "IF or ELSE IF\n");
+			}
+		} else if (v1 & BIT(30)) { /*negative condition*/
+			if (is_skipped) {
+				is_matched = false;
+				continue;
+			}
+
+			if (check_positive(dm, pre_v1, pre_v2, v1, v2)) {
+				is_matched = true;
+				is_skipped = true;
+			} else {
+				is_matched = false;
+				is_skipped = false;
+			}
+		} else if (is_matched) {
+			odm_config_rf_radio_a_8822b(dm, v1, v2);
+		}
+	}
+}
+
+u32 odm_get_version_mp_8822b_radioa(void) { return 67; }
+
+/******************************************************************************
+ *                           radiob.TXT
+ ******************************************************************************/
+
+static u32 array_mp_8822b_radiob[] = {
+	0x000,      0x00030000, 0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9300200f, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9000100f, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9000200f, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x0004002D, 0x9300200c, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0x93012100, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0x93002100, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0x9000200c, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0x90001004, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0x93002000, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0x90002100, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0x90002000, 0x00000000, 0x40000000, 0x00000000,
+	0x001,      0x00040029, 0xA0000000, 0x00000000, 0x001,      0x00040029,
+	0xB0000000, 0x00000000, 0x018,      0x00010D24, 0x0EF,      0x00080000,
+	0x033,      0x00000002, 0x03E,      0x0000003F, 0x03F,      0x000C0F4E,
+	0x033,      0x00000001, 0x03E,      0x00000034, 0x03F,      0x0004080E,
+	0x0EF,      0x00080000, 0x0DF,      0x00002449, 0x033,      0x00000024,
+	0x03E,      0x0000003F, 0x03F,      0x00060FDE, 0x0EF,      0x00000000,
+	0x0EF,      0x00080000, 0x033,      0x00000025, 0x03E,      0x00000037,
+	0x03F,      0x0007EFCE, 0x0EF,      0x00000000, 0x0EF,      0x00080000,
+	0x033,      0x00000026, 0x03E,      0x00000037, 0x03F,      0x000DEFCE,
+	0x0EF,      0x00000000, 0x0DF,      0x00000009, 0x018,      0x00010524,
+	0x089,      0x00000207, 0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x08A,      0x000FF186, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x08A,      0x000FE186, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x08A,      0x000FF186, 0x9300200f, 0x00000000, 0x40000000, 0x00000000,
+	0x08A,      0x000FF186, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x08A,      0x000FF186, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x08A,      0x000FE186, 0xA0000000, 0x00000000, 0x08A,      0x000FF186,
+	0xB0000000, 0x00000000, 0x08B,      0x00061E3C, 0x08C,      0x000112C7,
+	0x08D,      0x000F4988, 0x08E,      0x00064D40, 0x0EF,      0x00020000,
+	0x033,      0x00000007, 0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x03E,      0x00004040, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x03E,      0x00004080, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x03E,      0x00004040, 0x9300200f, 0x00000000, 0x40000000, 0x00000000,
+	0x03E,      0x00004040, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x03E,      0x00004040, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x03E,      0x00004080, 0x9000100f, 0x00000000, 0x40000000, 0x00000000,
+	0x03E,      0x00004040, 0x9000200f, 0x00000000, 0x40000000, 0x00000000,
+	0x03E,      0x00004040, 0x9300200c, 0x00000000, 0x40000000, 0x00000000,
+	0x03E,      0x00004040, 0x93012100, 0x00000000, 0x40000000, 0x00000000,
+	0x03E,      0x00004000, 0x93002100, 0x00000000, 0x40000000, 0x00000000,
+	0x03E,      0x00004000, 0x93011000, 0x00000000, 0x40000000, 0x00000000,
+	0x03E,      0x00004000, 0x9000200c, 0x00000000, 0x40000000, 0x00000000,
+	0x03E,      0x00004040, 0x90001004, 0x00000000, 0x40000000, 0x00000000,
+	0x03E,      0x00004040, 0x93002000, 0x00000000, 0x40000000, 0x00000000,
+	0x03E,      0x00004000, 0xA0000000, 0x00000000, 0x03E,      0x00004000,
+	0xB0000000, 0x00000000, 0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x03F,      0x000C3186, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x03F,      0x000C3186, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x03F,      0x000C3186, 0x9300200f, 0x00000000, 0x40000000, 0x00000000,
+	0x03F,      0x000C3186, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x03F,      0x000C3186, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x03F,      0x000C3186, 0x9000100f, 0x00000000, 0x40000000, 0x00000000,
+	0x03F,      0x000C3186, 0x9000200f, 0x00000000, 0x40000000, 0x00000000,
+	0x03F,      0x000C3186, 0x9300200c, 0x00000000, 0x40000000, 0x00000000,
+	0x03F,      0x000C3186, 0x93012100, 0x00000000, 0x40000000, 0x00000000,
+	0x03F,      0x000C3186, 0x93002100, 0x00000000, 0x40000000, 0x00000000,
+	0x03F,      0x000C0006, 0x93011000, 0x00000000, 0x40000000, 0x00000000,
+	0x03F,      0x000C3186, 0x9000200c, 0x00000000, 0x40000000, 0x00000000,
+	0x03F,      0x000C3186, 0x90001004, 0x00000000, 0x40000000, 0x00000000,
+	0x03F,      0x000C3186, 0x93002000, 0x00000000, 0x40000000, 0x00000000,
+	0x03F,      0x000C0006, 0x93001000, 0x00000000, 0x40000000, 0x00000000,
+	0x03F,      0x000C3186, 0xA0000000, 0x00000000, 0x03F,      0x000C3186,
+	0xB0000000, 0x00000000, 0x033,      0x00000006, 0x03E,      0x00004080,
+	0x03F,      0x000C3186, 0x033,      0x00000005, 0x03E,      0x000040C8,
+	0x03F,      0x000C3186, 0x033,      0x00000004, 0x03E,      0x00004190,
+	0x03F,      0x000C3186, 0x033,      0x00000003, 0x03E,      0x00004998,
+	0x03F,      0x000C3186, 0x033,      0x00000002, 0x03E,      0x00005840,
+	0x03F,      0x000C3186, 0x033,      0x00000001, 0x03E,      0x000058C2,
+	0x03F,      0x000C3186, 0x033,      0x00000000, 0x03E,      0x00005930,
+	0x03F,      0x000C3186, 0x033,      0x0000000F, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03E,      0x00004080, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03E,      0x00004080, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x9300200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x93012100, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004000, 0x93002100, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004000, 0x93011000, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004000, 0x9000200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004040, 0x93002000, 0x00000000,
+	0x40000000, 0x00000000, 0x03E,      0x00004000, 0xA0000000, 0x00000000,
+	0x03E,      0x00004000, 0xB0000000, 0x00000000, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9300200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x93012100, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x93002100, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x93011000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x9000200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0x93002000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C0006, 0x93001000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x000C3186, 0xA0000000, 0x00000000,
+	0x03F,      0x000C3186, 0xB0000000, 0x00000000, 0x033,      0x0000000E,
+	0x03E,      0x00004080, 0x03F,      0x000C3186, 0x033,      0x0000000D,
+	0x03E,      0x000040C8, 0x03F,      0x000C3186, 0x033,      0x0000000C,
+	0x03E,      0x00004190, 0x03F,      0x000C3186, 0x033,      0x0000000B,
+	0x03E,      0x00004998, 0x03F,      0x000C3186, 0x033,      0x0000000A,
+	0x03E,      0x00005840, 0x03F,      0x000C3186, 0x033,      0x00000009,
+	0x03E,      0x000058C2, 0x03F,      0x000C3186, 0x033,      0x00000008,
+	0x03E,      0x00005930, 0x03F,      0x000C3186, 0x033,      0x00000017,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x9300100f, 0x05050505, 0x40000000, 0x00000000, 0x03E,      0x00004080,
+	0x9300100f, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x9000100f, 0x05050505, 0x40000000, 0x00000000, 0x03E,      0x00004080,
+	0x9000100f, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x9000200f, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x9300200c, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x93012100, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004000,
+	0x93002100, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004000,
+	0x93011000, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004000,
+	0x9000200c, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x90001004, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004040,
+	0x93002000, 0x00000000, 0x40000000, 0x00000000, 0x03E,      0x00004000,
+	0xA0000000, 0x00000000, 0x03E,      0x00004000, 0xB0000000, 0x00000000,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9300100f, 0x05050505, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9300100f, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9000100f, 0x05050505, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9000100f, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9000200f, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9300200c, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x93012100, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x93002100, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000DFF86,
+	0x93011000, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x9000200c, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x90001004, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0x93002000, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C0006,
+	0x93001000, 0x00000000, 0x40000000, 0x00000000, 0x03F,      0x000C3186,
+	0xA0000000, 0x00000000, 0x03F,      0x000C3186, 0xB0000000, 0x00000000,
+	0x033,      0x00000016, 0x03E,      0x00004080, 0x03F,      0x000C3186,
+	0x033,      0x00000015, 0x03E,      0x000040C8, 0x03F,      0x000C3186,
+	0x033,      0x00000014, 0x03E,      0x00004190, 0x03F,      0x000C3186,
+	0x033,      0x00000013, 0x03E,      0x00004998, 0x03F,      0x000C3186,
+	0x033,      0x00000012, 0x03E,      0x00005840, 0x03F,      0x000C3186,
+	0x033,      0x00000011, 0x03E,      0x000058C2, 0x03F,      0x000C3186,
+	0x033,      0x00000010, 0x03E,      0x00005930, 0x03F,      0x000C3186,
+	0x0EF,      0x00000000, 0x0EF,      0x00004000, 0x033,      0x00000000,
+	0x03F,      0x0000000A, 0x033,      0x00000001, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x9300200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x93012100, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000002, 0x93002100, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x93011000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000005, 0x9000200c, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x93002000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x93001000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000005, 0x90002100, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0x90002000, 0x00000000,
+	0x40000000, 0x00000000, 0x03F,      0x00000000, 0xA0000000, 0x00000000,
+	0x03F,      0x00000005, 0xB0000000, 0x00000000, 0x033,      0x00000002,
+	0x03F,      0x00000000, 0x0EF,      0x00000000, 0x018,      0x00000401,
+	0x084,      0x00001209, 0x086,      0x000001A0, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x087,      0x00068080, 0xA0000000, 0x00000000,
+	0x087,      0x000E8180, 0xB0000000, 0x00000000, 0x088,      0x00070020,
+	0x0DE,      0x00000010, 0x0EF,      0x00008000, 0x033,      0x0000000F,
+	0x03F,      0x0000003C, 0x033,      0x0000000E, 0x03F,      0x00000038,
+	0x033,      0x0000000D, 0x03F,      0x00000030, 0x033,      0x0000000C,
+	0x03F,      0x00000028, 0x033,      0x0000000B, 0x03F,      0x00000020,
+	0x033,      0x0000000A, 0x03F,      0x00000018, 0x033,      0x00000009,
+	0x03F,      0x00000010, 0x033,      0x00000008, 0x03F,      0x00000008,
+	0x033,      0x00000007, 0x03F,      0x0000003C, 0x033,      0x00000006,
+	0x03F,      0x00000038, 0x033,      0x00000005, 0x03F,      0x00000030,
+	0x033,      0x00000004, 0x03F,      0x00000028, 0x033,      0x00000003,
+	0x03F,      0x00000020, 0x033,      0x00000002, 0x03F,      0x00000018,
+	0x033,      0x00000001, 0x03F,      0x00000010, 0x033,      0x00000000,
+	0x03F,      0x00000008, 0x0EF,      0x00000000, 0x018,      0x00018D24,
+	0xFFE,      0x00000000, 0xFFE,      0x00000000, 0xFFE,      0x00000000,
+	0xFFE,      0x00000000, 0x018,      0x00010D24, 0x01B,      0x00075A40,
+	0x0EE,      0x00000002, 0x033,      0x00000000, 0x03F,      0x00000004,
+	0x033,      0x00000001, 0x03F,      0x00000004, 0x033,      0x00000002,
+	0x03F,      0x00000004, 0x033,      0x00000003, 0x03F,      0x00000004,
+	0x033,      0x00000004, 0x03F,      0x00000004, 0x033,      0x00000005,
+	0x03F,      0x00000006, 0x033,      0x00000006, 0x03F,      0x00000002,
+	0x033,      0x00000007, 0x03F,      0x00000000, 0x0EE,      0x00000000,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x061,      0x0005D4A0,
+	0x062,      0x0000D203, 0x063,      0x00000062, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x061,      0x0005D4A0, 0x062,      0x0000D203,
+	0x063,      0x00000062, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x061,      0x0005D4A0, 0x062,      0x0000D203, 0x063,      0x00000062,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x061,      0x0005D2A1,
+	0x062,      0x0000D3A2, 0x063,      0x00000062, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x061,      0x0005D4A0, 0x062,      0x0000D203,
+	0x063,      0x00000062, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x061,      0x0005D4A0, 0x062,      0x0000D203, 0x063,      0x00000062,
+	0x9000100f, 0x00000000, 0x40000000, 0x00000000, 0x061,      0x0005D4A0,
+	0x062,      0x0000D203, 0x063,      0x00000062, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x061,      0x0005D2A1, 0x062,      0x0000D3A2,
+	0x063,      0x00000062, 0x9300200c, 0x00000000, 0x40000000, 0x00000000,
+	0x061,      0x0005D2A1, 0x062,      0x0000D3A2, 0x063,      0x00000062,
+	0x93012100, 0x00000000, 0x40000000, 0x00000000, 0x061,      0x0005D2A1,
+	0x062,      0x0000D3A2, 0x063,      0x00000002, 0x93002100, 0x00000000,
+	0x40000000, 0x00000000, 0x061,      0x0005D2A1, 0x062,      0x0000D3A2,
+	0x063,      0x00000002, 0x93011000, 0x00000000, 0x40000000, 0x00000000,
+	0x061,      0x0005D3D1, 0x062,      0x0000D3A2, 0x063,      0x00000002,
+	0x9000200c, 0x00000000, 0x40000000, 0x00000000, 0x061,      0x0005D2A1,
+	0x062,      0x0000D3A2, 0x063,      0x00000062, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x061,      0x0005D3D1, 0x062,      0x0000D3A2,
+	0x063,      0x00000002, 0x93002000, 0x00000000, 0x40000000, 0x00000000,
+	0x061,      0x0005D2A1, 0x062,      0x0000D3A2, 0x063,      0x00000002,
+	0x93001000, 0x00000000, 0x40000000, 0x00000000, 0x061,      0x0005D3D1,
+	0x062,      0x0000D3A2, 0x063,      0x00000002, 0x90002100, 0x00000000,
+	0x40000000, 0x00000000, 0x061,      0x0005D2A1, 0x062,      0x0000D3A2,
+	0x063,      0x00000002, 0x90002000, 0x00000000, 0x40000000, 0x00000000,
+	0x061,      0x0005D2A1, 0x062,      0x0000D3A2, 0x063,      0x00000002,
+	0xA0000000, 0x00000000, 0x061,      0x0005D3D0, 0x062,      0x0000D303,
+	0x063,      0x00000002, 0xB0000000, 0x00000000, 0x0EF,      0x00000200,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x030,      0x000004A3,
+	0x030,      0x000014A3, 0x030,      0x000024A3, 0x030,      0x000034A3,
+	0x030,      0x000044A3, 0x030,      0x000054A3, 0x030,      0x000064A3,
+	0x030,      0x000074A3, 0x030,      0x000084A3, 0x030,      0x000094A3,
+	0x030,      0x0000A4A3, 0x030,      0x0000B4A3, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x030,      0x000004A3, 0x030,      0x000014A3,
+	0x030,      0x000024A3, 0x030,      0x000034A3, 0x030,      0x000044A3,
+	0x030,      0x000054A3, 0x030,      0x000064A3, 0x030,      0x000074A3,
+	0x030,      0x000084A3, 0x030,      0x000094A3, 0x030,      0x0000A4A3,
+	0x030,      0x0000B4A3, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x030,      0x000004A3, 0x030,      0x000014A3, 0x030,      0x000024A3,
+	0x030,      0x000034A3, 0x030,      0x000044A3, 0x030,      0x000054A3,
+	0x030,      0x000064A3, 0x030,      0x000074A3, 0x030,      0x000084A3,
+	0x030,      0x000094A3, 0x030,      0x0000A4A3, 0x030,      0x0000B4A3,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x030,      0x000002A6,
+	0x030,      0x000012A6, 0x030,      0x000022A6, 0x030,      0x000032A6,
+	0x030,      0x000042A6, 0x030,      0x000052A6, 0x030,      0x000062A6,
+	0x030,      0x000072A6, 0x030,      0x000082A6, 0x030,      0x000092A6,
+	0x030,      0x0000A2A6, 0x030,      0x0000B2A6, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x030,      0x000004A0, 0x030,      0x000014A0,
+	0x030,      0x000024A0, 0x030,      0x000034A0, 0x030,      0x000044A0,
+	0x030,      0x000054A0, 0x030,      0x000064A0, 0x030,      0x000074A0,
+	0x030,      0x000084A0, 0x030,      0x000094A0, 0x030,      0x0000A4A0,
+	0x030,      0x0000B4A0, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x030,      0x000004A0, 0x030,      0x000014A0, 0x030,      0x000024A0,
+	0x030,      0x000034A0, 0x030,      0x000044A0, 0x030,      0x000054A0,
+	0x030,      0x000064A0, 0x030,      0x000074A0, 0x030,      0x000084A0,
+	0x030,      0x000094A0, 0x030,      0x0000A4A0, 0x030,      0x0000B4A0,
+	0x9000100f, 0x00000000, 0x40000000, 0x00000000, 0x030,      0x000004A0,
+	0x030,      0x000014A0, 0x030,      0x000024A0, 0x030,      0x000034A0,
+	0x030,      0x000044A0, 0x030,      0x000054A0, 0x030,      0x000064A0,
+	0x030,      0x000074A0, 0x030,      0x000084A0, 0x030,      0x000094A0,
+	0x030,      0x0000A4A0, 0x030,      0x0000B4A0, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x030,      0x000002A1, 0x030,      0x000012A1,
+	0x030,      0x000022A1, 0x030,      0x000032A1, 0x030,      0x000042A1,
+	0x030,      0x000052A1, 0x030,      0x000062A1, 0x030,      0x000072A1,
+	0x030,      0x000082A1, 0x030,      0x000092A1, 0x030,      0x0000A2A1,
+	0x030,      0x0000B2A1, 0x9300200c, 0x00000000, 0x40000000, 0x00000000,
+	0x030,      0x000002A6, 0x030,      0x000012A6, 0x030,      0x000022A6,
+	0x030,      0x000032A6, 0x030,      0x000042A6, 0x030,      0x000052A6,
+	0x030,      0x000062A6, 0x030,      0x000072A6, 0x030,      0x000082A6,
+	0x030,      0x000092A6, 0x030,      0x0000A2A6, 0x030,      0x0000B2A6,
+	0x93012100, 0x00000000, 0x40000000, 0x00000000, 0x030,      0x000002F4,
+	0x030,      0x000012F4, 0x030,      0x000022F4, 0x030,      0x000032F4,
+	0x030,      0x00004365, 0x030,      0x00005365, 0x030,      0x00006365,
+	0x030,      0x00007365, 0x030,      0x000082A4, 0x030,      0x000092A4,
+	0x030,      0x0000A2A4, 0x030,      0x0000B2A4, 0x93002100, 0x00000000,
+	0x40000000, 0x00000000, 0x030,      0x000004A4, 0x030,      0x000014A4,
+	0x030,      0x000024A4, 0x030,      0x000034A4, 0x030,      0x000043A4,
+	0x030,      0x000053A4, 0x030,      0x000063A4, 0x030,      0x000073A4,
+	0x030,      0x000083A5, 0x030,      0x000093A5, 0x030,      0x0000A3A5,
+	0x030,      0x0000B3A5, 0x93011000, 0x00000000, 0x40000000, 0x00000000,
+	0x030,      0x000003A1, 0x030,      0x000013A1, 0x030,      0x000023A1,
+	0x030,      0x000033A1, 0x030,      0x000043A4, 0x030,      0x000053A4,
+	0x030,      0x000063A4, 0x030,      0x000073A4, 0x030,      0x000083A6,
+	0x030,      0x000093A6, 0x030,      0x0000A3A6, 0x030,      0x0000B3A6,
+	0x9000200c, 0x00000000, 0x40000000, 0x00000000, 0x030,      0x000002A1,
+	0x030,      0x000012A1, 0x030,      0x000022A1, 0x030,      0x000032A1,
+	0x030,      0x000042A1, 0x030,      0x000052A1, 0x030,      0x000062A1,
+	0x030,      0x000072A1, 0x030,      0x000082A1, 0x030,      0x000092A1,
+	0x030,      0x0000A2A1, 0x030,      0x0000B2A1, 0x90001004, 0x00000000,
+	0x40000000, 0x00000000, 0x030,      0x00000382, 0x030,      0x00001382,
+	0x030,      0x00002382, 0x030,      0x00003382, 0x030,      0x00004445,
+	0x030,      0x00005445, 0x030,      0x00006445, 0x030,      0x00007445,
+	0x030,      0x00008425, 0x030,      0x00009425, 0x030,      0x0000A425,
+	0x030,      0x0000B425, 0x93002000, 0x00000000, 0x40000000, 0x00000000,
+	0x030,      0x00000303, 0x030,      0x00001303, 0x030,      0x00002303,
+	0x030,      0x00003303, 0x030,      0x000043A4, 0x030,      0x000053A4,
+	0x030,      0x000063A4, 0x030,      0x000073A4, 0x030,      0x00008365,
+	0x030,      0x00009365, 0x030,      0x0000A365, 0x030,      0x0000B365,
+	0x93001000, 0x00000000, 0x40000000, 0x00000000, 0x030,      0x000003A1,
+	0x030,      0x000013A1, 0x030,      0x000023A1, 0x030,      0x000033A1,
+	0x030,      0x00004364, 0x030,      0x00005364, 0x030,      0x00006364,
+	0x030,      0x00007364, 0x030,      0x00008564, 0x030,      0x00009564,
+	0x030,      0x0000A564, 0x030,      0x0000B564, 0x90002100, 0x00000000,
+	0x40000000, 0x00000000, 0x030,      0x000004A1, 0x030,      0x000014A1,
+	0x030,      0x000024A1, 0x030,      0x000034A1, 0x030,      0x000043A1,
+	0x030,      0x000053A1, 0x030,      0x000063A1, 0x030,      0x000073A1,
+	0x030,      0x000083A1, 0x030,      0x000093A1, 0x030,      0x0000A3A1,
+	0x030,      0x0000B3A1, 0x90002000, 0x00000000, 0x40000000, 0x00000000,
+	0x030,      0x000004A0, 0x030,      0x000014A0, 0x030,      0x000024A0,
+	0x030,      0x000034A0, 0x030,      0x000043A1, 0x030,      0x000053A1,
+	0x030,      0x000063A1, 0x030,      0x000073A1, 0x030,      0x000083A2,
+	0x030,      0x000093A2, 0x030,      0x0000A3A2, 0x030,      0x0000B3A2,
+	0xA0000000, 0x00000000, 0x030,      0x000002D0, 0x030,      0x000012D0,
+	0x030,      0x000022D0, 0x030,      0x000032D0, 0x030,      0x000042D0,
+	0x030,      0x000052D0, 0x030,      0x000062D0, 0x030,      0x000072D0,
+	0x030,      0x000082D0, 0x030,      0x000092D0, 0x030,      0x0000A2D0,
+	0x030,      0x0000B2D0, 0xB0000000, 0x00000000, 0x0EF,      0x00000000,
+	0x0EF,      0x00000080, 0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x030,      0x00000203, 0x030,      0x00001203, 0x030,      0x00002203,
+	0x030,      0x00003203, 0x030,      0x00004203, 0x030,      0x00005203,
+	0x030,      0x00006203, 0x030,      0x00007203, 0x030,      0x00008203,
+	0x030,      0x00009203, 0x030,      0x0000A203, 0x030,      0x0000B203,
+	0x9300100f, 0x05050505, 0x40000000, 0x00000000, 0x030,      0x00000203,
+	0x030,      0x00001203, 0x030,      0x00002203, 0x030,      0x00003203,
+	0x030,      0x00004203, 0x030,      0x00005203, 0x030,      0x00006203,
+	0x030,      0x00007203, 0x030,      0x00008203, 0x030,      0x00009203,
+	0x030,      0x0000A203, 0x030,      0x0000B203, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x030,      0x00000203, 0x030,      0x00001203,
+	0x030,      0x00002203, 0x030,      0x00003203, 0x030,      0x00004203,
+	0x030,      0x00005203, 0x030,      0x00006203, 0x030,      0x00007203,
+	0x030,      0x00008203, 0x030,      0x00009203, 0x030,      0x0000A203,
+	0x030,      0x0000B203, 0x9300200f, 0x00000000, 0x40000000, 0x00000000,
+	0x030,      0x000003A2, 0x030,      0x000013A2, 0x030,      0x000023A2,
+	0x030,      0x000033A2, 0x030,      0x000043A2, 0x030,      0x000053A2,
+	0x030,      0x000063A2, 0x030,      0x000073A2, 0x030,      0x000083A2,
+	0x030,      0x000093A2, 0x030,      0x0000A3A2, 0x030,      0x0000B3A2,
+	0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x030,      0x00000203,
+	0x030,      0x00001203, 0x030,      0x00002203, 0x030,      0x00003203,
+	0x030,      0x00004203, 0x030,      0x00005203, 0x030,      0x00006203,
+	0x030,      0x00007203, 0x030,      0x00008203, 0x030,      0x00009203,
+	0x030,      0x0000A203, 0x030,      0x0000B203, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x030,      0x00000203, 0x030,      0x00001203,
+	0x030,      0x00002203, 0x030,      0x00003203, 0x030,      0x00004203,
+	0x030,      0x00005203, 0x030,      0x00006203, 0x030,      0x00007203,
+	0x030,      0x00008203, 0x030,      0x00009203, 0x030,      0x0000A203,
+	0x030,      0x0000B203, 0x9000100f, 0x00000000, 0x40000000, 0x00000000,
+	0x030,      0x00000203, 0x030,      0x00001203, 0x030,      0x00002203,
+	0x030,      0x00003203, 0x030,      0x00004203, 0x030,      0x00005203,
+	0x030,      0x00006203, 0x030,      0x00007203, 0x030,      0x00008203,
+	0x030,      0x00009203, 0x030,      0x0000A203, 0x030,      0x0000B203,
+	0x9000200f, 0x00000000, 0x40000000, 0x00000000, 0x030,      0x000003A2,
+	0x030,      0x000013A2, 0x030,      0x000023A2, 0x030,      0x000033A2,
+	0x030,      0x000043A2, 0x030,      0x000053A2, 0x030,      0x000063A2,
+	0x030,      0x000073A2, 0x030,      0x000083A2, 0x030,      0x000093A2,
+	0x030,      0x0000A3A2, 0x030,      0x0000B3A2, 0x9300200c, 0x00000000,
+	0x40000000, 0x00000000, 0x030,      0x000003A2, 0x030,      0x000013A2,
+	0x030,      0x000023A2, 0x030,      0x000033A2, 0x030,      0x000043A2,
+	0x030,      0x000053A2, 0x030,      0x000063A2, 0x030,      0x000073A2,
+	0x030,      0x000083A2, 0x030,      0x000093A2, 0x030,      0x0000A3A2,
+	0x030,      0x0000B3A2, 0x93012100, 0x00000000, 0x40000000, 0x00000000,
+	0x030,      0x000003A3, 0x030,      0x000013A3, 0x030,      0x000023A3,
+	0x030,      0x000033A3, 0x030,      0x000043A4, 0x030,      0x000053A4,
+	0x030,      0x000063A4, 0x030,      0x000073A4, 0x030,      0x000083A3,
+	0x030,      0x000093A3, 0x030,      0x0000A3A3, 0x030,      0x0000B3A3,
+	0x93002100, 0x00000000, 0x40000000, 0x00000000, 0x030,      0x000003A2,
+	0x030,      0x000013A2, 0x030,      0x000023A2, 0x030,      0x000033A2,
+	0x030,      0x000043A2, 0x030,      0x000053A2, 0x030,      0x000063A2,
+	0x030,      0x000073A2, 0x030,      0x000083A2, 0x030,      0x000093A2,
+	0x030,      0x0000A3A2, 0x030,      0x0000B3A2, 0x93011000, 0x00000000,
+	0x40000000, 0x00000000, 0x030,      0x000003A2, 0x030,      0x000013A2,
+	0x030,      0x000023A2, 0x030,      0x000033A2, 0x030,      0x000043A2,
+	0x030,      0x000053A2, 0x030,      0x000063A2, 0x030,      0x000073A2,
+	0x030,      0x000083A2, 0x030,      0x000093A2, 0x030,      0x0000A3A2,
+	0x030,      0x0000B3A2, 0x9000200c, 0x00000000, 0x40000000, 0x00000000,
+	0x030,      0x000003A2, 0x030,      0x000013A2, 0x030,      0x000023A2,
+	0x030,      0x000033A2, 0x030,      0x000043A2, 0x030,      0x000053A2,
+	0x030,      0x000063A2, 0x030,      0x000073A2, 0x030,      0x000083A2,
+	0x030,      0x000093A2, 0x030,      0x0000A3A2, 0x030,      0x0000B3A2,
+	0x90001004, 0x00000000, 0x40000000, 0x00000000, 0x030,      0x000003A2,
+	0x030,      0x000013A2, 0x030,      0x000023A2, 0x030,      0x000033A2,
+	0x030,      0x000043A2, 0x030,      0x000053A2, 0x030,      0x000063A2,
+	0x030,      0x000073A2, 0x030,      0x000083A2, 0x030,      0x000093A2,
+	0x030,      0x0000A3A2, 0x030,      0x0000B3A2, 0x93002000, 0x00000000,
+	0x40000000, 0x00000000, 0x030,      0x000003A2, 0x030,      0x000013A2,
+	0x030,      0x000023A2, 0x030,      0x000033A2, 0x030,      0x000043A2,
+	0x030,      0x000053A2, 0x030,      0x000063A2, 0x030,      0x000073A2,
+	0x030,      0x000083A2, 0x030,      0x000093A2, 0x030,      0x0000A3A2,
+	0x030,      0x0000B3A2, 0x93001000, 0x00000000, 0x40000000, 0x00000000,
+	0x030,      0x000003A2, 0x030,      0x000013A2, 0x030,      0x000023A2,
+	0x030,      0x000033A2, 0x030,      0x000043A2, 0x030,      0x000053A2,
+	0x030,      0x000063A2, 0x030,      0x000073A2, 0x030,      0x000083A2,
+	0x030,      0x000093A2, 0x030,      0x0000A3A2, 0x030,      0x0000B3A2,
+	0x90002100, 0x00000000, 0x40000000, 0x00000000, 0x030,      0x000003A2,
+	0x030,      0x000013A2, 0x030,      0x000023A2, 0x030,      0x000033A2,
+	0x030,      0x000043A2, 0x030,      0x000053A2, 0x030,      0x000063A2,
+	0x030,      0x000073A2, 0x030,      0x000083A2, 0x030,      0x000093A2,
+	0x030,      0x0000A3A2, 0x030,      0x0000B3A2, 0x90002000, 0x00000000,
+	0x40000000, 0x00000000, 0x030,      0x000003A2, 0x030,      0x000013A2,
+	0x030,      0x000023A2, 0x030,      0x000033A2, 0x030,      0x000043A2,
+	0x030,      0x000053A2, 0x030,      0x000063A2, 0x030,      0x000073A2,
+	0x030,      0x000083A2, 0x030,      0x000093A2, 0x030,      0x0000A3A2,
+	0x030,      0x0000B3A2, 0xA0000000, 0x00000000, 0x030,      0x000003A2,
+	0x030,      0x000013A2, 0x030,      0x000023A2, 0x030,      0x000033A2,
+	0x030,      0x000043A2, 0x030,      0x000053A2, 0x030,      0x000063A2,
+	0x030,      0x000073A2, 0x030,      0x000083A2, 0x030,      0x000093A2,
+	0x030,      0x0000A3A2, 0x030,      0x0000B3A2, 0xB0000000, 0x00000000,
+	0x0EF,      0x00000000, 0x0EF,      0x00000040, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x030,      0x00000645, 0x030,      0x00001333,
+	0x030,      0x00002011, 0x030,      0x00004000, 0x030,      0x00005000,
+	0x030,      0x00006000, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x030,      0x00000645, 0x030,      0x00001333, 0x030,      0x00002011,
+	0x030,      0x00004000, 0x030,      0x00005000, 0x030,      0x00006000,
+	0x9300100f, 0x00000000, 0x40000000, 0x00000000, 0x030,      0x00000645,
+	0x030,      0x00001333, 0x030,      0x00002011, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x030,      0x00000645, 0x030,      0x00001333,
+	0x030,      0x00002011, 0x030,      0x00004777, 0x030,      0x00005777,
+	0x030,      0x00006777, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x030,      0x00000645, 0x030,      0x00001333, 0x030,      0x00002011,
+	0x030,      0x00004000, 0x030,      0x00005000, 0x030,      0x00006000,
+	0x9000100f, 0x05050505, 0x40000000, 0x00000000, 0x030,      0x00000645,
+	0x030,      0x00001333, 0x030,      0x00002011, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x030,      0x00000645, 0x030,      0x00001333,
+	0x030,      0x00002011, 0x030,      0x00004000, 0x030,      0x00005000,
+	0x030,      0x00006000, 0x9000200f, 0x00000000, 0x40000000, 0x00000000,
+	0x030,      0x00000645, 0x030,      0x00001333, 0x030,      0x00002011,
+	0x030,      0x00004000, 0x030,      0x00005000, 0x030,      0x00006000,
+	0x9300200c, 0x00000000, 0x40000000, 0x00000000, 0x030,      0x00000645,
+	0x030,      0x00001333, 0x030,      0x00002011, 0x030,      0x00004777,
+	0x030,      0x00005777, 0x030,      0x00006777, 0x93012100, 0x00000000,
+	0x40000000, 0x00000000, 0x030,      0x00000660, 0x030,      0x00001341,
+	0x030,      0x00002220, 0x030,      0x00004777, 0x030,      0x00005777,
+	0x030,      0x00006777, 0x93002100, 0x00000000, 0x40000000, 0x00000000,
+	0x030,      0x00000764, 0x030,      0x00001452, 0x030,      0x00002220,
+	0x030,      0x00004777, 0x030,      0x00005777, 0x030,      0x00006777,
+	0x93011000, 0x00000000, 0x40000000, 0x00000000, 0x030,      0x00000764,
+	0x030,      0x00001632, 0x030,      0x00002421, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0x9000200c, 0x00000000,
+	0x40000000, 0x00000000, 0x030,      0x00000645, 0x030,      0x00001333,
+	0x030,      0x00002011, 0x030,      0x00004000, 0x030,      0x00005000,
+	0x030,      0x00006000, 0x90001004, 0x00000000, 0x40000000, 0x00000000,
+	0x030,      0x00000764, 0x030,      0x00001632, 0x030,      0x00002421,
+	0x030,      0x00004000, 0x030,      0x00005000, 0x030,      0x00006000,
+	0x93002000, 0x00000000, 0x40000000, 0x00000000, 0x030,      0x00000777,
+	0x030,      0x00001442, 0x030,      0x00002222, 0x030,      0x00004777,
+	0x030,      0x00005777, 0x030,      0x00006777, 0x93001000, 0x00000000,
+	0x40000000, 0x00000000, 0x030,      0x00000764, 0x030,      0x00001632,
+	0x030,      0x00002421, 0x030,      0x00004000, 0x030,      0x00005000,
+	0x030,      0x00006000, 0x90002100, 0x00000000, 0x40000000, 0x00000000,
+	0x030,      0x00000775, 0x030,      0x00001222, 0x030,      0x00002210,
+	0x030,      0x00004000, 0x030,      0x00005000, 0x030,      0x00006000,
+	0x90002000, 0x00000000, 0x40000000, 0x00000000, 0x030,      0x00000775,
+	0x030,      0x00001422, 0x030,      0x00002210, 0x030,      0x00004000,
+	0x030,      0x00005000, 0x030,      0x00006000, 0xA0000000, 0x00000000,
+	0x030,      0x00000764, 0x030,      0x00001632, 0x030,      0x00002421,
+	0x030,      0x00004000, 0x030,      0x00005000, 0x030,      0x00006000,
+	0xB0000000, 0x00000000, 0x0EF,      0x00000000, 0x0EF,      0x00000800,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000007, 0x033,      0x00000021, 0x03F,      0x0000000A,
+	0x033,      0x00000022, 0x03F,      0x0000000D, 0x033,      0x00000023,
+	0x03F,      0x0000002A, 0x033,      0x00000024, 0x03F,      0x0000002D,
+	0x033,      0x00000025, 0x03F,      0x00000030, 0x033,      0x00000026,
+	0x03F,      0x0000006D, 0x033,      0x00000027, 0x03F,      0x00000070,
+	0x033,      0x00000028, 0x03F,      0x000000ED, 0x033,      0x00000029,
+	0x03F,      0x000000F0, 0x033,      0x0000002A, 0x03F,      0x000000F3,
+	0x9300100f, 0x05050505, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000007, 0x033,      0x00000021, 0x03F,      0x0000000A,
+	0x033,      0x00000022, 0x03F,      0x0000000D, 0x033,      0x00000023,
+	0x03F,      0x0000002A, 0x033,      0x00000024, 0x03F,      0x0000002D,
+	0x033,      0x00000025, 0x03F,      0x00000030, 0x033,      0x00000026,
+	0x03F,      0x0000006D, 0x033,      0x00000027, 0x03F,      0x00000070,
+	0x033,      0x00000028, 0x03F,      0x000000ED, 0x033,      0x00000029,
+	0x03F,      0x000000F0, 0x033,      0x0000002A, 0x03F,      0x000000F3,
+	0x9300100f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000007, 0x033,      0x00000021, 0x03F,      0x0000000A,
+	0x033,      0x00000022, 0x03F,      0x0000000D, 0x033,      0x00000023,
+	0x03F,      0x0000002A, 0x033,      0x00000024, 0x03F,      0x0000002D,
+	0x033,      0x00000025, 0x03F,      0x00000030, 0x033,      0x00000026,
+	0x03F,      0x0000006D, 0x033,      0x00000027, 0x03F,      0x00000070,
+	0x033,      0x00000028, 0x03F,      0x000000ED, 0x033,      0x00000029,
+	0x03F,      0x000000F0, 0x033,      0x0000002A, 0x03F,      0x000000F3,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000005, 0x033,      0x00000021, 0x03F,      0x00000008,
+	0x033,      0x00000022, 0x03F,      0x0000000B, 0x033,      0x00000023,
+	0x03F,      0x0000000E, 0x033,      0x00000024, 0x03F,      0x0000002B,
+	0x033,      0x00000025, 0x03F,      0x00000068, 0x033,      0x00000026,
+	0x03F,      0x0000006B, 0x033,      0x00000027, 0x03F,      0x0000006E,
+	0x033,      0x00000028, 0x03F,      0x00000071, 0x033,      0x00000029,
+	0x03F,      0x00000074, 0x033,      0x0000002A, 0x03F,      0x00000077,
+	0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000007, 0x033,      0x00000021, 0x03F,      0x0000000A,
+	0x033,      0x00000022, 0x03F,      0x0000000D, 0x033,      0x00000023,
+	0x03F,      0x0000002A, 0x033,      0x00000024, 0x03F,      0x0000002D,
+	0x033,      0x00000025, 0x03F,      0x00000030, 0x033,      0x00000026,
+	0x03F,      0x0000006D, 0x033,      0x00000027, 0x03F,      0x00000070,
+	0x033,      0x00000028, 0x03F,      0x000000ED, 0x033,      0x00000029,
+	0x03F,      0x000000F0, 0x033,      0x0000002A, 0x03F,      0x000000F3,
+	0x9000100f, 0x05050505, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000007, 0x033,      0x00000021, 0x03F,      0x0000000A,
+	0x033,      0x00000022, 0x03F,      0x0000000D, 0x033,      0x00000023,
+	0x03F,      0x0000002A, 0x033,      0x00000024, 0x03F,      0x0000002D,
+	0x033,      0x00000025, 0x03F,      0x00000030, 0x033,      0x00000026,
+	0x03F,      0x0000006D, 0x033,      0x00000027, 0x03F,      0x00000070,
+	0x033,      0x00000028, 0x03F,      0x000000ED, 0x033,      0x00000029,
+	0x03F,      0x000000F0, 0x033,      0x0000002A, 0x03F,      0x000000F3,
+	0x9000100f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000007, 0x033,      0x00000021, 0x03F,      0x0000000A,
+	0x033,      0x00000022, 0x03F,      0x0000000D, 0x033,      0x00000023,
+	0x03F,      0x0000002A, 0x033,      0x00000024, 0x03F,      0x0000002D,
+	0x033,      0x00000025, 0x03F,      0x00000030, 0x033,      0x00000026,
+	0x03F,      0x0000006D, 0x033,      0x00000027, 0x03F,      0x00000070,
+	0x033,      0x00000028, 0x03F,      0x000000ED, 0x033,      0x00000029,
+	0x03F,      0x000000F0, 0x033,      0x0000002A, 0x03F,      0x000000F3,
+	0x9000200f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000005, 0x033,      0x00000021, 0x03F,      0x00000008,
+	0x033,      0x00000022, 0x03F,      0x0000000B, 0x033,      0x00000023,
+	0x03F,      0x0000000E, 0x033,      0x00000024, 0x03F,      0x0000002B,
+	0x033,      0x00000025, 0x03F,      0x00000068, 0x033,      0x00000026,
+	0x03F,      0x0000006B, 0x033,      0x00000027, 0x03F,      0x0000006E,
+	0x033,      0x00000028, 0x03F,      0x00000071, 0x033,      0x00000029,
+	0x03F,      0x00000074, 0x033,      0x0000002A, 0x03F,      0x00000077,
+	0x9300200c, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000005, 0x033,      0x00000021, 0x03F,      0x00000008,
+	0x033,      0x00000022, 0x03F,      0x0000000B, 0x033,      0x00000023,
+	0x03F,      0x0000000E, 0x033,      0x00000024, 0x03F,      0x0000002B,
+	0x033,      0x00000025, 0x03F,      0x00000068, 0x033,      0x00000026,
+	0x03F,      0x0000006B, 0x033,      0x00000027, 0x03F,      0x0000006E,
+	0x033,      0x00000028, 0x03F,      0x00000071, 0x033,      0x00000029,
+	0x03F,      0x00000074, 0x033,      0x0000002A, 0x03F,      0x00000077,
+	0x93012100, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000828, 0x033,      0x00000021, 0x03F,      0x0000082B,
+	0x033,      0x00000022, 0x03F,      0x00000868, 0x033,      0x00000023,
+	0x03F,      0x00000889, 0x033,      0x00000024, 0x03F,      0x000008AA,
+	0x033,      0x00000025, 0x03F,      0x00000CE8, 0x033,      0x00000026,
+	0x03F,      0x00000CEB, 0x033,      0x00000027, 0x03F,      0x00000CEE,
+	0x033,      0x00000028, 0x03F,      0x00000CF1, 0x033,      0x00000029,
+	0x03F,      0x00000CF4, 0x033,      0x0000002A, 0x03F,      0x00000CF7,
+	0x93002100, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x0000042A, 0x033,      0x00000021, 0x03F,      0x00000829,
+	0x033,      0x00000022, 0x03F,      0x00000848, 0x033,      0x00000023,
+	0x03F,      0x0000084B, 0x033,      0x00000024, 0x03F,      0x00000C4C,
+	0x033,      0x00000025, 0x03F,      0x00000C8B, 0x033,      0x00000026,
+	0x03F,      0x00000CEA, 0x033,      0x00000027, 0x03F,      0x00000CED,
+	0x033,      0x00000028, 0x03F,      0x00000CF0, 0x033,      0x00000029,
+	0x03F,      0x00000CF3, 0x033,      0x0000002A, 0x03F,      0x00000CF6,
+	0x93011000, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000C09, 0x033,      0x00000021, 0x03F,      0x00000C0C,
+	0x033,      0x00000022, 0x03F,      0x00000C0F, 0x033,      0x00000023,
+	0x03F,      0x00000C2C, 0x033,      0x00000024, 0x03F,      0x00000C2F,
+	0x033,      0x00000025, 0x03F,      0x00000C8A, 0x033,      0x00000026,
+	0x03F,      0x00000C8D, 0x033,      0x00000027, 0x03F,      0x00000C90,
+	0x033,      0x00000028, 0x03F,      0x00000CD0, 0x033,      0x00000029,
+	0x03F,      0x00000CF2, 0x033,      0x0000002A, 0x03F,      0x00000CF5,
+	0x9000200c, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000005, 0x033,      0x00000021, 0x03F,      0x00000008,
+	0x033,      0x00000022, 0x03F,      0x0000000B, 0x033,      0x00000023,
+	0x03F,      0x0000000E, 0x033,      0x00000024, 0x03F,      0x0000002B,
+	0x033,      0x00000025, 0x03F,      0x00000068, 0x033,      0x00000026,
+	0x03F,      0x0000006B, 0x033,      0x00000027, 0x03F,      0x0000006E,
+	0x033,      0x00000028, 0x03F,      0x00000071, 0x033,      0x00000029,
+	0x03F,      0x00000074, 0x033,      0x0000002A, 0x03F,      0x00000077,
+	0x90001004, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000C09, 0x033,      0x00000021, 0x03F,      0x00000C0C,
+	0x033,      0x00000022, 0x03F,      0x00000C0F, 0x033,      0x00000023,
+	0x03F,      0x00000C2C, 0x033,      0x00000024, 0x03F,      0x00000C2F,
+	0x033,      0x00000025, 0x03F,      0x00000C8A, 0x033,      0x00000026,
+	0x03F,      0x00000C8D, 0x033,      0x00000027, 0x03F,      0x00000C90,
+	0x033,      0x00000028, 0x03F,      0x00000CD0, 0x033,      0x00000029,
+	0x03F,      0x00000CF2, 0x033,      0x0000002A, 0x03F,      0x00000CF5,
+	0x93002000, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000429, 0x033,      0x00000021, 0x03F,      0x00000828,
+	0x033,      0x00000022, 0x03F,      0x00000847, 0x033,      0x00000023,
+	0x03F,      0x0000084A, 0x033,      0x00000024, 0x03F,      0x00000C4B,
+	0x033,      0x00000025, 0x03F,      0x00000C8A, 0x033,      0x00000026,
+	0x03F,      0x00000CEA, 0x033,      0x00000027, 0x03F,      0x00000CED,
+	0x033,      0x00000028, 0x03F,      0x00000CF0, 0x033,      0x00000029,
+	0x03F,      0x00000CF3, 0x033,      0x0000002A, 0x03F,      0x00000CF6,
+	0x93001000, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x00000C09, 0x033,      0x00000021, 0x03F,      0x00000C0C,
+	0x033,      0x00000022, 0x03F,      0x00000C0F, 0x033,      0x00000023,
+	0x03F,      0x00000C2C, 0x033,      0x00000024, 0x03F,      0x00000C2F,
+	0x033,      0x00000025, 0x03F,      0x00000C8A, 0x033,      0x00000026,
+	0x03F,      0x00000C8D, 0x033,      0x00000027, 0x03F,      0x00000C90,
+	0x033,      0x00000028, 0x03F,      0x00000CD0, 0x033,      0x00000029,
+	0x03F,      0x00000CF2, 0x033,      0x0000002A, 0x03F,      0x00000CF5,
+	0x90002100, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x0000042B, 0x033,      0x00000021, 0x03F,      0x0000082A,
+	0x033,      0x00000022, 0x03F,      0x00000849, 0x033,      0x00000023,
+	0x03F,      0x0000084C, 0x033,      0x00000024, 0x03F,      0x00000C4C,
+	0x033,      0x00000025, 0x03F,      0x00000C8A, 0x033,      0x00000026,
+	0x03F,      0x00000C8D, 0x033,      0x00000027, 0x03F,      0x00000CEB,
+	0x033,      0x00000028, 0x03F,      0x00000CEE, 0x033,      0x00000029,
+	0x03F,      0x00000CF1, 0x033,      0x0000002A, 0x03F,      0x00000CF4,
+	0x90002000, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000020,
+	0x03F,      0x0000042B, 0x033,      0x00000021, 0x03F,      0x0000082A,
+	0x033,      0x00000022, 0x03F,      0x00000849, 0x033,      0x00000023,
+	0x03F,      0x0000084C, 0x033,      0x00000024, 0x03F,      0x00000C4C,
+	0x033,      0x00000025, 0x03F,      0x00000C8A, 0x033,      0x00000026,
+	0x03F,      0x00000C8D, 0x033,      0x00000027, 0x03F,      0x00000CEB,
+	0x033,      0x00000028, 0x03F,      0x00000CEE, 0x033,      0x00000029,
+	0x03F,      0x00000CF1, 0x033,      0x0000002A, 0x03F,      0x00000CF4,
+	0xA0000000, 0x00000000, 0x033,      0x00000020, 0x03F,      0x00000C09,
+	0x033,      0x00000021, 0x03F,      0x00000C0C, 0x033,      0x00000022,
+	0x03F,      0x00000C0F, 0x033,      0x00000023, 0x03F,      0x00000C2C,
+	0x033,      0x00000024, 0x03F,      0x00000C2F, 0x033,      0x00000025,
+	0x03F,      0x00000C8A, 0x033,      0x00000026, 0x03F,      0x00000C8D,
+	0x033,      0x00000027, 0x03F,      0x00000C90, 0x033,      0x00000028,
+	0x03F,      0x00000CD0, 0x033,      0x00000029, 0x03F,      0x00000CF2,
+	0x033,      0x0000002A, 0x03F,      0x00000CF5, 0xB0000000, 0x00000000,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000007, 0x033,      0x00000061, 0x03F,      0x0000000A,
+	0x033,      0x00000062, 0x03F,      0x0000000D, 0x033,      0x00000063,
+	0x03F,      0x0000002A, 0x033,      0x00000064, 0x03F,      0x0000002D,
+	0x033,      0x00000065, 0x03F,      0x00000030, 0x033,      0x00000066,
+	0x03F,      0x0000006D, 0x033,      0x00000067, 0x03F,      0x00000070,
+	0x033,      0x00000068, 0x03F,      0x000000ED, 0x033,      0x00000069,
+	0x03F,      0x000000F0, 0x033,      0x0000006A, 0x03F,      0x000000F3,
+	0x9300100f, 0x05050505, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000007, 0x033,      0x00000061, 0x03F,      0x0000000A,
+	0x033,      0x00000062, 0x03F,      0x0000000D, 0x033,      0x00000063,
+	0x03F,      0x0000002A, 0x033,      0x00000064, 0x03F,      0x0000002D,
+	0x033,      0x00000065, 0x03F,      0x00000030, 0x033,      0x00000066,
+	0x03F,      0x0000006D, 0x033,      0x00000067, 0x03F,      0x00000070,
+	0x033,      0x00000068, 0x03F,      0x000000ED, 0x033,      0x00000069,
+	0x03F,      0x000000F0, 0x033,      0x0000006A, 0x03F,      0x000000F3,
+	0x9300100f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000007, 0x033,      0x00000061, 0x03F,      0x0000000A,
+	0x033,      0x00000062, 0x03F,      0x0000000D, 0x033,      0x00000063,
+	0x03F,      0x0000002A, 0x033,      0x00000064, 0x03F,      0x0000002D,
+	0x033,      0x00000065, 0x03F,      0x00000030, 0x033,      0x00000066,
+	0x03F,      0x0000006D, 0x033,      0x00000067, 0x03F,      0x00000070,
+	0x033,      0x00000068, 0x03F,      0x000000ED, 0x033,      0x00000069,
+	0x03F,      0x000000F0, 0x033,      0x0000006A, 0x03F,      0x000000F3,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000005, 0x033,      0x00000061, 0x03F,      0x00000008,
+	0x033,      0x00000062, 0x03F,      0x0000000B, 0x033,      0x00000063,
+	0x03F,      0x0000000E, 0x033,      0x00000064, 0x03F,      0x0000002B,
+	0x033,      0x00000065, 0x03F,      0x00000068, 0x033,      0x00000066,
+	0x03F,      0x0000006B, 0x033,      0x00000067, 0x03F,      0x0000006E,
+	0x033,      0x00000068, 0x03F,      0x00000071, 0x033,      0x00000069,
+	0x03F,      0x00000074, 0x033,      0x0000006A, 0x03F,      0x00000077,
+	0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000007, 0x033,      0x00000061, 0x03F,      0x0000000A,
+	0x033,      0x00000062, 0x03F,      0x0000000D, 0x033,      0x00000063,
+	0x03F,      0x0000002A, 0x033,      0x00000064, 0x03F,      0x0000002D,
+	0x033,      0x00000065, 0x03F,      0x00000030, 0x033,      0x00000066,
+	0x03F,      0x0000006D, 0x033,      0x00000067, 0x03F,      0x00000070,
+	0x033,      0x00000068, 0x03F,      0x000000ED, 0x033,      0x00000069,
+	0x03F,      0x000000F0, 0x033,      0x0000006A, 0x03F,      0x000000F3,
+	0x9000100f, 0x05050505, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000007, 0x033,      0x00000061, 0x03F,      0x0000000A,
+	0x033,      0x00000062, 0x03F,      0x0000000D, 0x033,      0x00000063,
+	0x03F,      0x0000002A, 0x033,      0x00000064, 0x03F,      0x0000002D,
+	0x033,      0x00000065, 0x03F,      0x00000030, 0x033,      0x00000066,
+	0x03F,      0x0000006D, 0x033,      0x00000067, 0x03F,      0x00000070,
+	0x033,      0x00000068, 0x03F,      0x000000ED, 0x033,      0x00000069,
+	0x03F,      0x000000F0, 0x033,      0x0000006A, 0x03F,      0x000000F3,
+	0x9000100f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000007, 0x033,      0x00000061, 0x03F,      0x0000000A,
+	0x033,      0x00000062, 0x03F,      0x0000000D, 0x033,      0x00000063,
+	0x03F,      0x0000002A, 0x033,      0x00000064, 0x03F,      0x0000002D,
+	0x033,      0x00000065, 0x03F,      0x00000030, 0x033,      0x00000066,
+	0x03F,      0x0000006D, 0x033,      0x00000067, 0x03F,      0x00000070,
+	0x033,      0x00000068, 0x03F,      0x000000ED, 0x033,      0x00000069,
+	0x03F,      0x000000F0, 0x033,      0x0000006A, 0x03F,      0x000000F3,
+	0x9000200f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000005, 0x033,      0x00000061, 0x03F,      0x00000008,
+	0x033,      0x00000062, 0x03F,      0x0000000B, 0x033,      0x00000063,
+	0x03F,      0x0000000E, 0x033,      0x00000064, 0x03F,      0x0000002B,
+	0x033,      0x00000065, 0x03F,      0x00000068, 0x033,      0x00000066,
+	0x03F,      0x0000006B, 0x033,      0x00000067, 0x03F,      0x0000006E,
+	0x033,      0x00000068, 0x03F,      0x00000071, 0x033,      0x00000069,
+	0x03F,      0x00000074, 0x033,      0x0000006A, 0x03F,      0x00000077,
+	0x9300200c, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000005, 0x033,      0x00000061, 0x03F,      0x00000008,
+	0x033,      0x00000062, 0x03F,      0x0000000B, 0x033,      0x00000063,
+	0x03F,      0x0000000E, 0x033,      0x00000064, 0x03F,      0x0000002B,
+	0x033,      0x00000065, 0x03F,      0x00000068, 0x033,      0x00000066,
+	0x03F,      0x0000006B, 0x033,      0x00000067, 0x03F,      0x0000006E,
+	0x033,      0x00000068, 0x03F,      0x00000071, 0x033,      0x00000069,
+	0x03F,      0x00000074, 0x033,      0x0000006A, 0x03F,      0x00000077,
+	0x93012100, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000842, 0x033,      0x00000061, 0x03F,      0x00000845,
+	0x033,      0x00000062, 0x03F,      0x00000866, 0x033,      0x00000063,
+	0x03F,      0x000008A6, 0x033,      0x00000064, 0x03F,      0x000008C8,
+	0x033,      0x00000065, 0x03F,      0x00000CE8, 0x033,      0x00000066,
+	0x03F,      0x00000CEB, 0x033,      0x00000067, 0x03F,      0x00000CEE,
+	0x033,      0x00000068, 0x03F,      0x00000CF1, 0x033,      0x00000069,
+	0x03F,      0x00000CF4, 0x033,      0x0000006A, 0x03F,      0x00000CF7,
+	0x93002100, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x0000042A, 0x033,      0x00000061, 0x03F,      0x00000829,
+	0x033,      0x00000062, 0x03F,      0x00000848, 0x033,      0x00000063,
+	0x03F,      0x0000084B, 0x033,      0x00000064, 0x03F,      0x00000C69,
+	0x033,      0x00000065, 0x03F,      0x00000CA9, 0x033,      0x00000066,
+	0x03F,      0x00000CEA, 0x033,      0x00000067, 0x03F,      0x00000CED,
+	0x033,      0x00000068, 0x03F,      0x00000CF0, 0x033,      0x00000069,
+	0x03F,      0x00000CF3, 0x033,      0x0000006A, 0x03F,      0x00000CF6,
+	0x93011000, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000C0A, 0x033,      0x00000061, 0x03F,      0x00000C0D,
+	0x033,      0x00000062, 0x03F,      0x00000C2A, 0x033,      0x00000063,
+	0x03F,      0x00000C2D, 0x033,      0x00000064, 0x03F,      0x00000C6A,
+	0x033,      0x00000065, 0x03F,      0x00000CAA, 0x033,      0x00000066,
+	0x03F,      0x00000CAD, 0x033,      0x00000067, 0x03F,      0x00000CB0,
+	0x033,      0x00000068, 0x03F,      0x00000CF1, 0x033,      0x00000069,
+	0x03F,      0x00000CF4, 0x033,      0x0000006A, 0x03F,      0x00000CF7,
+	0x9000200c, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000005, 0x033,      0x00000061, 0x03F,      0x00000008,
+	0x033,      0x00000062, 0x03F,      0x0000000B, 0x033,      0x00000063,
+	0x03F,      0x0000000E, 0x033,      0x00000064, 0x03F,      0x0000002B,
+	0x033,      0x00000065, 0x03F,      0x00000068, 0x033,      0x00000066,
+	0x03F,      0x0000006B, 0x033,      0x00000067, 0x03F,      0x0000006E,
+	0x033,      0x00000068, 0x03F,      0x00000071, 0x033,      0x00000069,
+	0x03F,      0x00000074, 0x033,      0x0000006A, 0x03F,      0x00000077,
+	0x90001004, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000C0A, 0x033,      0x00000061, 0x03F,      0x00000C0D,
+	0x033,      0x00000062, 0x03F,      0x00000C2A, 0x033,      0x00000063,
+	0x03F,      0x00000C2D, 0x033,      0x00000064, 0x03F,      0x00000C6A,
+	0x033,      0x00000065, 0x03F,      0x00000CAA, 0x033,      0x00000066,
+	0x03F,      0x00000CAD, 0x033,      0x00000067, 0x03F,      0x00000CB0,
+	0x033,      0x00000068, 0x03F,      0x00000CF1, 0x033,      0x00000069,
+	0x03F,      0x00000CF4, 0x033,      0x0000006A, 0x03F,      0x00000CF7,
+	0x93002000, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000429, 0x033,      0x00000061, 0x03F,      0x00000828,
+	0x033,      0x00000062, 0x03F,      0x00000847, 0x033,      0x00000063,
+	0x03F,      0x0000084A, 0x033,      0x00000064, 0x03F,      0x00000C4B,
+	0x033,      0x00000065, 0x03F,      0x00000C8A, 0x033,      0x00000066,
+	0x03F,      0x00000CEA, 0x033,      0x00000067, 0x03F,      0x00000CED,
+	0x033,      0x00000068, 0x03F,      0x00000CF0, 0x033,      0x00000069,
+	0x03F,      0x00000CF3, 0x033,      0x0000006A, 0x03F,      0x00000CF6,
+	0x93001000, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x00000C0A, 0x033,      0x00000061, 0x03F,      0x00000C0D,
+	0x033,      0x00000062, 0x03F,      0x00000C2A, 0x033,      0x00000063,
+	0x03F,      0x00000C2D, 0x033,      0x00000064, 0x03F,      0x00000C6A,
+	0x033,      0x00000065, 0x03F,      0x00000CAA, 0x033,      0x00000066,
+	0x03F,      0x00000CAD, 0x033,      0x00000067, 0x03F,      0x00000CB0,
+	0x033,      0x00000068, 0x03F,      0x00000CF1, 0x033,      0x00000069,
+	0x03F,      0x00000CF4, 0x033,      0x0000006A, 0x03F,      0x00000CF7,
+	0x90002100, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x0000042C, 0x033,      0x00000061, 0x03F,      0x0000082B,
+	0x033,      0x00000062, 0x03F,      0x0000084A, 0x033,      0x00000063,
+	0x03F,      0x0000084D, 0x033,      0x00000064, 0x03F,      0x00000C4E,
+	0x033,      0x00000065, 0x03F,      0x00000C8C, 0x033,      0x00000066,
+	0x03F,      0x00000C8F, 0x033,      0x00000067, 0x03F,      0x00000CEC,
+	0x033,      0x00000068, 0x03F,      0x00000CEF, 0x033,      0x00000069,
+	0x03F,      0x00000CF2, 0x033,      0x0000006A, 0x03F,      0x00000CF5,
+	0x90002000, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000060,
+	0x03F,      0x0000042C, 0x033,      0x00000061, 0x03F,      0x0000082B,
+	0x033,      0x00000062, 0x03F,      0x0000084A, 0x033,      0x00000063,
+	0x03F,      0x0000084D, 0x033,      0x00000064, 0x03F,      0x00000C4E,
+	0x033,      0x00000065, 0x03F,      0x00000C8C, 0x033,      0x00000066,
+	0x03F,      0x00000C8F, 0x033,      0x00000067, 0x03F,      0x00000CEC,
+	0x033,      0x00000068, 0x03F,      0x00000CEF, 0x033,      0x00000069,
+	0x03F,      0x00000CF2, 0x033,      0x0000006A, 0x03F,      0x00000CF5,
+	0xA0000000, 0x00000000, 0x033,      0x00000060, 0x03F,      0x00000C0A,
+	0x033,      0x00000061, 0x03F,      0x00000C0D, 0x033,      0x00000062,
+	0x03F,      0x00000C2A, 0x033,      0x00000063, 0x03F,      0x00000C2D,
+	0x033,      0x00000064, 0x03F,      0x00000C6A, 0x033,      0x00000065,
+	0x03F,      0x00000CAA, 0x033,      0x00000066, 0x03F,      0x00000CAD,
+	0x033,      0x00000067, 0x03F,      0x00000CB0, 0x033,      0x00000068,
+	0x03F,      0x00000CF1, 0x033,      0x00000069, 0x03F,      0x00000CF4,
+	0x033,      0x0000006A, 0x03F,      0x00000CF7, 0xB0000000, 0x00000000,
+	0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000007, 0x033,      0x000000A1, 0x03F,      0x0000000A,
+	0x033,      0x000000A2, 0x03F,      0x0000000D, 0x033,      0x000000A3,
+	0x03F,      0x0000002A, 0x033,      0x000000A4, 0x03F,      0x0000002D,
+	0x033,      0x000000A5, 0x03F,      0x00000030, 0x033,      0x000000A6,
+	0x03F,      0x0000006D, 0x033,      0x000000A7, 0x03F,      0x00000070,
+	0x033,      0x000000A8, 0x03F,      0x000000ED, 0x033,      0x000000A9,
+	0x03F,      0x000000F0, 0x033,      0x000000AA, 0x03F,      0x000000F3,
+	0x9300100f, 0x05050505, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000007, 0x033,      0x000000A1, 0x03F,      0x0000000A,
+	0x033,      0x000000A2, 0x03F,      0x0000000D, 0x033,      0x000000A3,
+	0x03F,      0x0000002A, 0x033,      0x000000A4, 0x03F,      0x0000002D,
+	0x033,      0x000000A5, 0x03F,      0x00000030, 0x033,      0x000000A6,
+	0x03F,      0x0000006D, 0x033,      0x000000A7, 0x03F,      0x00000070,
+	0x033,      0x000000A8, 0x03F,      0x000000ED, 0x033,      0x000000A9,
+	0x03F,      0x000000F0, 0x033,      0x000000AA, 0x03F,      0x000000F3,
+	0x9300100f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000007, 0x033,      0x000000A1, 0x03F,      0x0000000A,
+	0x033,      0x000000A2, 0x03F,      0x0000000D, 0x033,      0x000000A3,
+	0x03F,      0x0000002A, 0x033,      0x000000A4, 0x03F,      0x0000002D,
+	0x033,      0x000000A5, 0x03F,      0x00000030, 0x033,      0x000000A6,
+	0x03F,      0x0000006D, 0x033,      0x000000A7, 0x03F,      0x00000070,
+	0x033,      0x000000A8, 0x03F,      0x000000ED, 0x033,      0x000000A9,
+	0x03F,      0x000000F0, 0x033,      0x000000AA, 0x03F,      0x000000F3,
+	0x9300200f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000005, 0x033,      0x000000A1, 0x03F,      0x00000008,
+	0x033,      0x000000A2, 0x03F,      0x0000000B, 0x033,      0x000000A3,
+	0x03F,      0x0000000E, 0x033,      0x000000A4, 0x03F,      0x00000047,
+	0x033,      0x000000A5, 0x03F,      0x0000004A, 0x033,      0x000000A6,
+	0x03F,      0x0000004D, 0x033,      0x000000A7, 0x03F,      0x00000050,
+	0x033,      0x000000A8, 0x03F,      0x00000053, 0x033,      0x000000A9,
+	0x03F,      0x00000056, 0x033,      0x000000AA, 0x03F,      0x00000094,
+	0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000007, 0x033,      0x000000A1, 0x03F,      0x0000000A,
+	0x033,      0x000000A2, 0x03F,      0x0000000D, 0x033,      0x000000A3,
+	0x03F,      0x0000002A, 0x033,      0x000000A4, 0x03F,      0x0000002D,
+	0x033,      0x000000A5, 0x03F,      0x00000030, 0x033,      0x000000A6,
+	0x03F,      0x0000006D, 0x033,      0x000000A7, 0x03F,      0x00000070,
+	0x033,      0x000000A8, 0x03F,      0x000000ED, 0x033,      0x000000A9,
+	0x03F,      0x000000F0, 0x033,      0x000000AA, 0x03F,      0x000000F3,
+	0x9000100f, 0x05050505, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000007, 0x033,      0x000000A1, 0x03F,      0x0000000A,
+	0x033,      0x000000A2, 0x03F,      0x0000000D, 0x033,      0x000000A3,
+	0x03F,      0x0000002A, 0x033,      0x000000A4, 0x03F,      0x0000002D,
+	0x033,      0x000000A5, 0x03F,      0x00000030, 0x033,      0x000000A6,
+	0x03F,      0x0000006D, 0x033,      0x000000A7, 0x03F,      0x00000070,
+	0x033,      0x000000A8, 0x03F,      0x000000ED, 0x033,      0x000000A9,
+	0x03F,      0x000000F0, 0x033,      0x000000AA, 0x03F,      0x000000F3,
+	0x9000100f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000007, 0x033,      0x000000A1, 0x03F,      0x0000000A,
+	0x033,      0x000000A2, 0x03F,      0x0000000D, 0x033,      0x000000A3,
+	0x03F,      0x0000002A, 0x033,      0x000000A4, 0x03F,      0x0000002D,
+	0x033,      0x000000A5, 0x03F,      0x00000030, 0x033,      0x000000A6,
+	0x03F,      0x0000006D, 0x033,      0x000000A7, 0x03F,      0x00000070,
+	0x033,      0x000000A8, 0x03F,      0x000000ED, 0x033,      0x000000A9,
+	0x03F,      0x000000F0, 0x033,      0x000000AA, 0x03F,      0x000000F3,
+	0x9000200f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000005, 0x033,      0x000000A1, 0x03F,      0x00000008,
+	0x033,      0x000000A2, 0x03F,      0x0000000B, 0x033,      0x000000A3,
+	0x03F,      0x0000000E, 0x033,      0x000000A4, 0x03F,      0x00000047,
+	0x033,      0x000000A5, 0x03F,      0x0000004A, 0x033,      0x000000A6,
+	0x03F,      0x0000004D, 0x033,      0x000000A7, 0x03F,      0x00000050,
+	0x033,      0x000000A8, 0x03F,      0x00000053, 0x033,      0x000000A9,
+	0x03F,      0x00000056, 0x033,      0x000000AA, 0x03F,      0x00000094,
+	0x9300200c, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000005, 0x033,      0x000000A1, 0x03F,      0x00000008,
+	0x033,      0x000000A2, 0x03F,      0x0000000B, 0x033,      0x000000A3,
+	0x03F,      0x0000000E, 0x033,      0x000000A4, 0x03F,      0x00000047,
+	0x033,      0x000000A5, 0x03F,      0x0000004A, 0x033,      0x000000A6,
+	0x03F,      0x0000004D, 0x033,      0x000000A7, 0x03F,      0x00000050,
+	0x033,      0x000000A8, 0x03F,      0x00000053, 0x033,      0x000000A9,
+	0x03F,      0x00000056, 0x033,      0x000000AA, 0x03F,      0x00000094,
+	0x93012100, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000826, 0x033,      0x000000A1, 0x03F,      0x00000829,
+	0x033,      0x000000A2, 0x03F,      0x0000082C, 0x033,      0x000000A3,
+	0x03F,      0x0000082F, 0x033,      0x000000A4, 0x03F,      0x0000086C,
+	0x033,      0x000000A5, 0x03F,      0x00000CE8, 0x033,      0x000000A6,
+	0x03F,      0x00000CEB, 0x033,      0x000000A7, 0x03F,      0x00000CEE,
+	0x033,      0x000000A8, 0x03F,      0x00000CF1, 0x033,      0x000000A9,
+	0x03F,      0x00000CF4, 0x033,      0x000000AA, 0x03F,      0x00000CF7,
+	0x93002100, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x0000042A, 0x033,      0x000000A1, 0x03F,      0x00000829,
+	0x033,      0x000000A2, 0x03F,      0x00000848, 0x033,      0x000000A3,
+	0x03F,      0x0000084B, 0x033,      0x000000A4, 0x03F,      0x00000C4C,
+	0x033,      0x000000A5, 0x03F,      0x00000CA9, 0x033,      0x000000A6,
+	0x03F,      0x00000CEA, 0x033,      0x000000A7, 0x03F,      0x00000CED,
+	0x033,      0x000000A8, 0x03F,      0x00000CF0, 0x033,      0x000000A9,
+	0x03F,      0x00000CF3, 0x033,      0x000000AA, 0x03F,      0x00000CF6,
+	0x93011000, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000C09, 0x033,      0x000000A1, 0x03F,      0x00000C0C,
+	0x033,      0x000000A2, 0x03F,      0x00000C0F, 0x033,      0x000000A3,
+	0x03F,      0x00000C2C, 0x033,      0x000000A4, 0x03F,      0x00000C2F,
+	0x033,      0x000000A5, 0x03F,      0x00000C8A, 0x033,      0x000000A6,
+	0x03F,      0x00000C8D, 0x033,      0x000000A7, 0x03F,      0x00000C90,
+	0x033,      0x000000A8, 0x03F,      0x00000CEF, 0x033,      0x000000A9,
+	0x03F,      0x00000CF2, 0x033,      0x000000AA, 0x03F,      0x00000CF5,
+	0x9000200c, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000005, 0x033,      0x000000A1, 0x03F,      0x00000008,
+	0x033,      0x000000A2, 0x03F,      0x0000000B, 0x033,      0x000000A3,
+	0x03F,      0x0000000E, 0x033,      0x000000A4, 0x03F,      0x00000047,
+	0x033,      0x000000A5, 0x03F,      0x0000004A, 0x033,      0x000000A6,
+	0x03F,      0x0000004D, 0x033,      0x000000A7, 0x03F,      0x00000050,
+	0x033,      0x000000A8, 0x03F,      0x00000053, 0x033,      0x000000A9,
+	0x03F,      0x00000056, 0x033,      0x000000AA, 0x03F,      0x00000094,
+	0x90001004, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000C09, 0x033,      0x000000A1, 0x03F,      0x00000C0C,
+	0x033,      0x000000A2, 0x03F,      0x00000C0F, 0x033,      0x000000A3,
+	0x03F,      0x00000C2C, 0x033,      0x000000A4, 0x03F,      0x00000C2F,
+	0x033,      0x000000A5, 0x03F,      0x00000C8A, 0x033,      0x000000A6,
+	0x03F,      0x00000C8D, 0x033,      0x000000A7, 0x03F,      0x00000C90,
+	0x033,      0x000000A8, 0x03F,      0x00000CEF, 0x033,      0x000000A9,
+	0x03F,      0x00000CF2, 0x033,      0x000000AA, 0x03F,      0x00000CF5,
+	0x93002000, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000429, 0x033,      0x000000A1, 0x03F,      0x00000828,
+	0x033,      0x000000A2, 0x03F,      0x00000847, 0x033,      0x000000A3,
+	0x03F,      0x0000084A, 0x033,      0x000000A4, 0x03F,      0x00000C4B,
+	0x033,      0x000000A5, 0x03F,      0x00000C8A, 0x033,      0x000000A6,
+	0x03F,      0x00000CEA, 0x033,      0x000000A7, 0x03F,      0x00000CED,
+	0x033,      0x000000A8, 0x03F,      0x00000CF0, 0x033,      0x000000A9,
+	0x03F,      0x00000CF3, 0x033,      0x000000AA, 0x03F,      0x00000CF6,
+	0x93001000, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x00000C09, 0x033,      0x000000A1, 0x03F,      0x00000C0C,
+	0x033,      0x000000A2, 0x03F,      0x00000C0F, 0x033,      0x000000A3,
+	0x03F,      0x00000C2C, 0x033,      0x000000A4, 0x03F,      0x00000C2F,
+	0x033,      0x000000A5, 0x03F,      0x00000C8A, 0x033,      0x000000A6,
+	0x03F,      0x00000C8D, 0x033,      0x000000A7, 0x03F,      0x00000C90,
+	0x033,      0x000000A8, 0x03F,      0x00000CEF, 0x033,      0x000000A9,
+	0x03F,      0x00000CF2, 0x033,      0x000000AA, 0x03F,      0x00000CF5,
+	0x90002100, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x0000042A, 0x033,      0x000000A1, 0x03F,      0x00000829,
+	0x033,      0x000000A2, 0x03F,      0x00000848, 0x033,      0x000000A3,
+	0x03F,      0x0000084B, 0x033,      0x000000A4, 0x03F,      0x00000C4C,
+	0x033,      0x000000A5, 0x03F,      0x00000C8A, 0x033,      0x000000A6,
+	0x03F,      0x00000C8D, 0x033,      0x000000A7, 0x03F,      0x00000CEC,
+	0x033,      0x000000A8, 0x03F,      0x00000CEF, 0x033,      0x000000A9,
+	0x03F,      0x00000CF2, 0x033,      0x000000AA, 0x03F,      0x00000CF5,
+	0x90002000, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x000000A0,
+	0x03F,      0x0000042A, 0x033,      0x000000A1, 0x03F,      0x00000829,
+	0x033,      0x000000A2, 0x03F,      0x00000848, 0x033,      0x000000A3,
+	0x03F,      0x0000084B, 0x033,      0x000000A4, 0x03F,      0x00000C4C,
+	0x033,      0x000000A5, 0x03F,      0x00000C8A, 0x033,      0x000000A6,
+	0x03F,      0x00000C8D, 0x033,      0x000000A7, 0x03F,      0x00000CEC,
+	0x033,      0x000000A8, 0x03F,      0x00000CEF, 0x033,      0x000000A9,
+	0x03F,      0x00000CF2, 0x033,      0x000000AA, 0x03F,      0x00000CF5,
+	0xA0000000, 0x00000000, 0x033,      0x000000A0, 0x03F,      0x00000C09,
+	0x033,      0x000000A1, 0x03F,      0x00000C0C, 0x033,      0x000000A2,
+	0x03F,      0x00000C0F, 0x033,      0x000000A3, 0x03F,      0x00000C2C,
+	0x033,      0x000000A4, 0x03F,      0x00000C2F, 0x033,      0x000000A5,
+	0x03F,      0x00000C8A, 0x033,      0x000000A6, 0x03F,      0x00000C8D,
+	0x033,      0x000000A7, 0x03F,      0x00000C90, 0x033,      0x000000A8,
+	0x03F,      0x00000CEF, 0x033,      0x000000A9, 0x03F,      0x00000CF2,
+	0x033,      0x000000AA, 0x03F,      0x00000CF5, 0xB0000000, 0x00000000,
+	0x0EF,      0x00000000, 0x0EF,      0x00000400, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x0000265A,
+	0x033,      0x00000001, 0x03F,      0x0000265A, 0x033,      0x00000002,
+	0x03F,      0x0000265A, 0x033,      0x00000003, 0x03F,      0x0000265A,
+	0x9300100f, 0x05050505, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x0000265A, 0x033,      0x00000001, 0x03F,      0x0000265A,
+	0x033,      0x00000002, 0x03F,      0x0000265A, 0x033,      0x00000003,
+	0x03F,      0x0000265A, 0x9300100f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000000, 0x03F,      0x0000265A, 0x033,      0x00000001,
+	0x03F,      0x0000265A, 0x033,      0x00000002, 0x03F,      0x0000265A,
+	0x033,      0x00000003, 0x03F,      0x0000265A, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x0000265A,
+	0x033,      0x00000001, 0x03F,      0x0000265A, 0x033,      0x00000002,
+	0x03F,      0x0000265A, 0x033,      0x00000003, 0x03F,      0x0000265A,
+	0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x0000265A, 0x033,      0x00000001, 0x03F,      0x0000265A,
+	0x033,      0x00000002, 0x03F,      0x0000265A, 0x033,      0x00000003,
+	0x03F,      0x0000265A, 0x9000100f, 0x05050505, 0x40000000, 0x00000000,
+	0x033,      0x00000000, 0x03F,      0x0000265A, 0x033,      0x00000001,
+	0x03F,      0x0000265A, 0x033,      0x00000002, 0x03F,      0x0000265A,
+	0x033,      0x00000003, 0x03F,      0x0000265A, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x0000265A,
+	0x033,      0x00000001, 0x03F,      0x0000265A, 0x033,      0x00000002,
+	0x03F,      0x0000265A, 0x033,      0x00000003, 0x03F,      0x0000265A,
+	0x9000200f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x0000265A, 0x033,      0x00000001, 0x03F,      0x0000265A,
+	0x033,      0x00000002, 0x03F,      0x0000265A, 0x033,      0x00000003,
+	0x03F,      0x0000265A, 0xA0000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x000004BB, 0x033,      0x00000001, 0x03F,      0x000004BB,
+	0x033,      0x00000002, 0x03F,      0x000004BB, 0x033,      0x00000003,
+	0x03F,      0x000004BB, 0xB0000000, 0x00000000, 0x0EF,      0x00000000,
+	0x0EF,      0x00000100, 0x8300100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x033,      0x00000000, 0x03F,      0x00000745, 0x033,      0x00000001,
+	0x03F,      0x00000745, 0x033,      0x00000002, 0x03F,      0x00000745,
+	0x033,      0x00000003, 0x03F,      0x00000745, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x00000745,
+	0x033,      0x00000001, 0x03F,      0x00000745, 0x033,      0x00000002,
+	0x03F,      0x00000745, 0x033,      0x00000003, 0x03F,      0x00000745,
+	0x9300100f, 0x00000000, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x00000745, 0x033,      0x00000001, 0x03F,      0x00000745,
+	0x033,      0x00000002, 0x03F,      0x00000745, 0x033,      0x00000003,
+	0x03F,      0x00000745, 0x9300200f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000000, 0x03F,      0x00000745, 0x033,      0x00000001,
+	0x03F,      0x00000745, 0x033,      0x00000002, 0x03F,      0x00000745,
+	0x033,      0x00000003, 0x03F,      0x00000745, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x00000745,
+	0x033,      0x00000001, 0x03F,      0x00000745, 0x033,      0x00000002,
+	0x03F,      0x00000745, 0x033,      0x00000003, 0x03F,      0x00000745,
+	0x9000100f, 0x05050505, 0x40000000, 0x00000000, 0x033,      0x00000000,
+	0x03F,      0x00000745, 0x033,      0x00000001, 0x03F,      0x00000745,
+	0x033,      0x00000002, 0x03F,      0x00000745, 0x033,      0x00000003,
+	0x03F,      0x00000745, 0x9000100f, 0x00000000, 0x40000000, 0x00000000,
+	0x033,      0x00000000, 0x03F,      0x00000745, 0x033,      0x00000001,
+	0x03F,      0x00000745, 0x033,      0x00000002, 0x03F,      0x00000745,
+	0x033,      0x00000003, 0x03F,      0x00000745, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x00000745,
+	0x033,      0x00000001, 0x03F,      0x00000745, 0x033,      0x00000002,
+	0x03F,      0x00000745, 0x033,      0x00000003, 0x03F,      0x00000745,
+	0xA0000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x00000F34,
+	0x033,      0x00000001, 0x03F,      0x00000F34, 0x033,      0x00000002,
+	0x03F,      0x00000F34, 0x033,      0x00000003, 0x03F,      0x00000F34,
+	0xB0000000, 0x00000000, 0x0EF,      0x00000000, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x081,      0x0000F400, 0x087,      0x00016040,
+	0x051,      0x00000808, 0x052,      0x00098002, 0x053,      0x0000FA47,
+	0x054,      0x00058032, 0x056,      0x00051000, 0x057,      0x0000CE0A,
+	0x058,      0x00082030, 0x9300100f, 0x05050505, 0x40000000, 0x00000000,
+	0x081,      0x0000F400, 0x087,      0x00016040, 0x051,      0x00000808,
+	0x052,      0x00098002, 0x053,      0x0000FA47, 0x054,      0x00058032,
+	0x056,      0x00051000, 0x057,      0x0000CE0A, 0x058,      0x00082030,
+	0x9300100f, 0x00000000, 0x40000000, 0x00000000, 0x081,      0x0000F400,
+	0x087,      0x00016040, 0x051,      0x00000808, 0x052,      0x00098002,
+	0x053,      0x0000FA47, 0x054,      0x00058032, 0x056,      0x00051000,
+	0x057,      0x0000CE0A, 0x058,      0x00082030, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x081,      0x0000F400, 0x087,      0x00016040,
+	0x051,      0x00000808, 0x052,      0x00098002, 0x053,      0x0000FA47,
+	0x054,      0x00058032, 0x056,      0x00051000, 0x057,      0x0000CE0A,
+	0x058,      0x00082030, 0x9000100f, 0x0a0a0a0a, 0x40000000, 0x00000000,
+	0x081,      0x0000F400, 0x087,      0x00016040, 0x051,      0x00000808,
+	0x052,      0x00098002, 0x053,      0x0000FA47, 0x054,      0x00058032,
+	0x056,      0x00051000, 0x057,      0x0000CE0A, 0x058,      0x00082030,
+	0x9000100f, 0x05050505, 0x40000000, 0x00000000, 0x081,      0x0000F400,
+	0x087,      0x00016040, 0x051,      0x00000808, 0x052,      0x00098002,
+	0x053,      0x0000FA47, 0x054,      0x00058032, 0x056,      0x00051000,
+	0x057,      0x0000CE0A, 0x058,      0x00082030, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x081,      0x0000F400, 0x087,      0x00016040,
+	0x051,      0x00000808, 0x052,      0x00098002, 0x053,      0x0000FA47,
+	0x054,      0x00058032, 0x056,      0x00051000, 0x057,      0x0000CE0A,
+	0x058,      0x00082030, 0x9000200f, 0x00000000, 0x40000000, 0x00000000,
+	0x081,      0x0000F400, 0x087,      0x00016040, 0x051,      0x00000808,
+	0x052,      0x00098002, 0x053,      0x0000FA47, 0x054,      0x00058032,
+	0x056,      0x00051000, 0x057,      0x0000CE0A, 0x058,      0x00082030,
+	0xA0000000, 0x00000000, 0x081,      0x0000F000, 0x087,      0x00016040,
+	0x051,      0x00000C00, 0x052,      0x0007C241, 0x053,      0x0001C069,
+	0x054,      0x00078032, 0x057,      0x0000CE0A, 0x058,      0x00058750,
+	0xB0000000, 0x00000000, 0x0EF,      0x00000800, 0x8300100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x00000003,
+	0x033,      0x00000001, 0x03F,      0x00000006, 0x033,      0x00000002,
+	0x03F,      0x00000009, 0x033,      0x00000003, 0x03F,      0x00000026,
+	0x033,      0x00000004, 0x03F,      0x00000029, 0x033,      0x00000005,
+	0x03F,      0x0000002C, 0x033,      0x00000006, 0x03F,      0x0000002F,
+	0x033,      0x00000007, 0x03F,      0x00000033, 0x033,      0x00000008,
+	0x03F,      0x00000036, 0x033,      0x00000009, 0x03F,      0x00000039,
+	0x033,      0x0000000A, 0x03F,      0x0000003C, 0x9300100f, 0x05050505,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x00000003,
+	0x033,      0x00000001, 0x03F,      0x00000006, 0x033,      0x00000002,
+	0x03F,      0x00000009, 0x033,      0x00000003, 0x03F,      0x00000026,
+	0x033,      0x00000004, 0x03F,      0x00000029, 0x033,      0x00000005,
+	0x03F,      0x0000002C, 0x033,      0x00000006, 0x03F,      0x0000002F,
+	0x033,      0x00000007, 0x03F,      0x00000033, 0x033,      0x00000008,
+	0x03F,      0x00000036, 0x033,      0x00000009, 0x03F,      0x00000039,
+	0x033,      0x0000000A, 0x03F,      0x0000003C, 0x9300100f, 0x00000000,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x00000003,
+	0x033,      0x00000001, 0x03F,      0x00000006, 0x033,      0x00000002,
+	0x03F,      0x00000009, 0x033,      0x00000003, 0x03F,      0x00000026,
+	0x033,      0x00000004, 0x03F,      0x00000029, 0x033,      0x00000005,
+	0x03F,      0x0000002C, 0x033,      0x00000006, 0x03F,      0x0000002F,
+	0x033,      0x00000007, 0x03F,      0x00000033, 0x033,      0x00000008,
+	0x03F,      0x00000036, 0x033,      0x00000009, 0x03F,      0x00000039,
+	0x033,      0x0000000A, 0x03F,      0x0000003C, 0x9300200f, 0x00000000,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x00000003,
+	0x033,      0x00000001, 0x03F,      0x00000006, 0x033,      0x00000002,
+	0x03F,      0x00000009, 0x033,      0x00000003, 0x03F,      0x00000026,
+	0x033,      0x00000004, 0x03F,      0x00000029, 0x033,      0x00000005,
+	0x03F,      0x0000002C, 0x033,      0x00000006, 0x03F,      0x0000002F,
+	0x033,      0x00000007, 0x03F,      0x00000033, 0x033,      0x00000008,
+	0x03F,      0x00000036, 0x033,      0x00000009, 0x03F,      0x00000039,
+	0x033,      0x0000000A, 0x03F,      0x0000003C, 0x9000100f, 0x0a0a0a0a,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x00000003,
+	0x033,      0x00000001, 0x03F,      0x00000006, 0x033,      0x00000002,
+	0x03F,      0x00000009, 0x033,      0x00000003, 0x03F,      0x00000026,
+	0x033,      0x00000004, 0x03F,      0x00000029, 0x033,      0x00000005,
+	0x03F,      0x0000002C, 0x033,      0x00000006, 0x03F,      0x0000002F,
+	0x033,      0x00000007, 0x03F,      0x00000033, 0x033,      0x00000008,
+	0x03F,      0x00000036, 0x033,      0x00000009, 0x03F,      0x00000039,
+	0x033,      0x0000000A, 0x03F,      0x0000003C, 0x9000100f, 0x05050505,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x00000003,
+	0x033,      0x00000001, 0x03F,      0x00000006, 0x033,      0x00000002,
+	0x03F,      0x00000009, 0x033,      0x00000003, 0x03F,      0x00000026,
+	0x033,      0x00000004, 0x03F,      0x00000029, 0x033,      0x00000005,
+	0x03F,      0x0000002C, 0x033,      0x00000006, 0x03F,      0x0000002F,
+	0x033,      0x00000007, 0x03F,      0x00000033, 0x033,      0x00000008,
+	0x03F,      0x00000036, 0x033,      0x00000009, 0x03F,      0x00000039,
+	0x033,      0x0000000A, 0x03F,      0x0000003C, 0x9000100f, 0x00000000,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x00000003,
+	0x033,      0x00000001, 0x03F,      0x00000006, 0x033,      0x00000002,
+	0x03F,      0x00000009, 0x033,      0x00000003, 0x03F,      0x00000026,
+	0x033,      0x00000004, 0x03F,      0x00000029, 0x033,      0x00000005,
+	0x03F,      0x0000002C, 0x033,      0x00000006, 0x03F,      0x0000002F,
+	0x033,      0x00000007, 0x03F,      0x00000033, 0x033,      0x00000008,
+	0x03F,      0x00000036, 0x033,      0x00000009, 0x03F,      0x00000039,
+	0x033,      0x0000000A, 0x03F,      0x0000003C, 0x9000200f, 0x00000000,
+	0x40000000, 0x00000000, 0x033,      0x00000000, 0x03F,      0x00000003,
+	0x033,      0x00000001, 0x03F,      0x00000006, 0x033,      0x00000002,
+	0x03F,      0x00000009, 0x033,      0x00000003, 0x03F,      0x00000026,
+	0x033,      0x00000004, 0x03F,      0x00000029, 0x033,      0x00000005,
+	0x03F,      0x0000002C, 0x033,      0x00000006, 0x03F,      0x0000002F,
+	0x033,      0x00000007, 0x03F,      0x00000033, 0x033,      0x00000008,
+	0x03F,      0x00000036, 0x033,      0x00000009, 0x03F,      0x00000039,
+	0x033,      0x0000000A, 0x03F,      0x0000003C, 0xA0000000, 0x00000000,
+	0x033,      0x00000000, 0x03F,      0x0005142C, 0x033,      0x00000001,
+	0x03F,      0x0005142F, 0x033,      0x00000002, 0x03F,      0x00051432,
+	0x033,      0x00000003, 0x03F,      0x00051C87, 0x033,      0x00000004,
+	0x03F,      0x00051C8A, 0x033,      0x00000005, 0x03F,      0x00051C8D,
+	0x033,      0x00000006, 0x03F,      0x00051CEB, 0x033,      0x00000007,
+	0x03F,      0x00051CEE, 0x033,      0x00000008, 0x03F,      0x00051CF1,
+	0x033,      0x00000009, 0x03F,      0x00051CF4, 0x033,      0x0000000A,
+	0x03F,      0x00051CF7, 0xB0000000, 0x00000000, 0x0EF,      0x00000000,
+	0x0EF,      0x00000010, 0x033,      0x00000000, 0x008,      0x0009C060,
+	0x033,      0x00000001, 0x008,      0x0009C060, 0x0EF,      0x00000000,
+	0x033,      0x000000A2, 0x0EF,      0x00080000, 0x03E,      0x0000593F,
+	0x03F,      0x000C0F4F, 0x0EF,      0x00000000, 0x033,      0x000000A3,
+	0x0EF,      0x00080000, 0x03E,      0x00005934, 0x03F,      0x0005AFCF,
+	0x0EF,      0x00000000,
+
+};
+
+void odm_read_and_config_mp_8822b_radiob(struct phy_dm_struct *dm)
+{
+	u32 i = 0;
+	u8 c_cond;
+	bool is_matched = true, is_skipped = false;
+	u32 array_len = sizeof(array_mp_8822b_radiob) / sizeof(u32);
+	u32 *array = array_mp_8822b_radiob;
+
+	u32 v1 = 0, v2 = 0, pre_v1 = 0, pre_v2 = 0;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "===> %s\n", __func__);
+
+	for (; (i + 1) < array_len; i = i + 2) {
+		v1 = array[i];
+		v2 = array[i + 1];
+
+		if (v1 & BIT(31)) { /* positive condition*/
+			c_cond = (u8)((v1 & (BIT(29) | BIT(28))) >> 28);
+			if (c_cond == COND_ENDIF) { /*end*/
+				is_matched = true;
+				is_skipped = false;
+				ODM_RT_TRACE(dm, ODM_COMP_INIT, "ENDIF\n");
+			} else if (c_cond == COND_ELSE) { /*else*/
+				is_matched = is_skipped ? false : true;
+				ODM_RT_TRACE(dm, ODM_COMP_INIT, "ELSE\n");
+			} else { /*if , else if*/
+				pre_v1 = v1;
+				pre_v2 = v2;
+				ODM_RT_TRACE(dm, ODM_COMP_INIT,
+					     "IF or ELSE IF\n");
+			}
+		} else if (v1 & BIT(30)) { /*negative condition*/
+			if (is_skipped) {
+				is_matched = false;
+				continue;
+			}
+
+			if (check_positive(dm, pre_v1, pre_v2, v1, v2)) {
+				is_matched = true;
+				is_skipped = true;
+			} else {
+				is_matched = false;
+				is_skipped = false;
+			}
+		} else if (is_matched) {
+			odm_config_rf_radio_b_8822b(dm, v1, v2);
+		}
+	}
+}
+
+u32 odm_get_version_mp_8822b_radiob(void) { return 67; }
+
+/******************************************************************************
+ *                           txpowertrack.TXT
+ ******************************************************************************/
+
+static u8 delta_swing_index_mp_5gb_n_txpwrtrack_8822b[][DELTA_SWINGIDX_SIZE] = {
+	{0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 10,
+	 11, 11, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 15, 15, 15},
+	{0, 1,  1,  2,  2,  3,  3,  4,  5,  5,  6,  7,  7,  8,  8,
+	 9, 10, 10, 11, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14, 14},
+	{0, 1,  2,  2,  3,  3,  4,  4,  5,  6,  6,  7,  7,  8,  9,
+	 9, 10, 10, 11, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14, 14},
+};
+
+static u8 delta_swing_index_mp_5gb_p_txpwrtrack_8822b[][DELTA_SWINGIDX_SIZE] = {
+	{0,  1,  2,  2,  3,  4,  5,  6,  7,  8,  8,  9,  10, 11, 11,
+	 12, 13, 14, 15, 15, 16, 17, 18, 18, 19, 19, 19, 19, 19, 19},
+	{0,  1,  2,  2,  3,  4,  5,  6,  6,  7,  8,  8,  9,  9,  10,
+	 11, 12, 12, 13, 14, 15, 16, 17, 17, 18, 18, 18, 18, 18, 18},
+	{0,  1,  2,  2,  3,  4,  5,  5,  6,  6,  7,  8,  8,  9,  10,
+	 10, 11, 12, 13, 14, 15, 15, 16, 16, 17, 17, 17, 17, 17, 17},
+};
+
+static u8 delta_swing_index_mp_5ga_n_txpwrtrack_8822b[][DELTA_SWINGIDX_SIZE] = {
+	{0,  1,  2,  2,  3,  3,  4,  5,  6,  7,  8,  8,  9,  9,  10,
+	 11, 11, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 15, 15, 15},
+	{0,  1,  2,  2,  3,  4,  5,  5,  6,  6,  7,  7,  8,  8,  9,
+	 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14, 14},
+	{0, 1,  2,  2,  3,  4,  4,  5,  6,  6,  7,  7,  8,  8,  9,
+	 9, 10, 10, 11, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14, 14},
+};
+
+static u8 delta_swing_index_mp_5ga_p_txpwrtrack_8822b[][DELTA_SWINGIDX_SIZE] = {
+	{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  9,  9,  10, 11,
+	 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 20, 20, 20, 20},
+	{0,  1,  2,  2,  3,  4,  4,  5,  6,  6,  7,  7,  8,  9,  9,
+	 10, 11, 11, 12, 13, 14, 15, 16, 16, 17, 17, 18, 18, 18, 18},
+	{0,  1,  2,  3,  3,  4,  5,  5,  6,  6,  7,  8,  8,  9,  10,
+	 11, 12, 12, 13, 14, 15, 15, 16, 17, 17, 18, 18, 18, 18, 18},
+};
+
+static u8 delta_swing_index_mp_2gb_n_txpwrtrack_8822b[] = {
+	0,  1,  2,  3,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2gb_p_txpwrtrack_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  7,  8,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2ga_n_txpwrtrack_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2ga_p_txpwrtrack_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2g_cck_b_n_txpwrtrack_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17};
+
+static u8 delta_swing_index_mp_2g_cck_b_p_txpwrtrack_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2g_cck_a_n_txpwrtrack_8822b[] = {
+	0,  1,  2,  3,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2g_cck_a_p_txpwrtrack_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+void odm_read_and_config_mp_8822b_txpowertrack(struct phy_dm_struct *dm)
+{
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT, "===> ODM_ReadAndConfig_MP_mp_8822b\n");
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_p,
+			delta_swing_index_mp_2ga_p_txpwrtrack_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_n,
+			delta_swing_index_mp_2ga_n_txpwrtrack_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_p,
+			delta_swing_index_mp_2gb_p_txpwrtrack_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_n,
+			delta_swing_index_mp_2gb_n_txpwrtrack_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_p,
+			delta_swing_index_mp_2g_cck_a_p_txpwrtrack_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_n,
+			delta_swing_index_mp_2g_cck_a_n_txpwrtrack_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_p,
+			delta_swing_index_mp_2g_cck_b_p_txpwrtrack_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_n,
+			delta_swing_index_mp_2g_cck_b_n_txpwrtrack_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_p,
+			delta_swing_index_mp_5ga_p_txpwrtrack_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_n,
+			delta_swing_index_mp_5ga_n_txpwrtrack_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_p,
+			delta_swing_index_mp_5gb_p_txpwrtrack_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_n,
+			delta_swing_index_mp_5gb_n_txpwrtrack_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+}
+
+/******************************************************************************
+ *                           txpowertrack_type0.TXT
+ ******************************************************************************/
+
+static u8 delta_swing_index_mp_5gb_n_txpwrtrack_type0_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  8,
+		 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 14, 14},
+		{0, 1, 1,  2,  2,  3,  3,  4,  5,  5,  6,  7,  7,  8,  8,
+		 9, 9, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15},
+};
+
+static u8 delta_swing_index_mp_5gb_p_txpwrtrack_type0_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 9, 10, 10, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+		{0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 9, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 15},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 10, 10, 11, 12, 13, 14, 14, 15, 15, 15, 16, 16},
+};
+
+static u8 delta_swing_index_mp_5ga_n_txpwrtrack_type0_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14},
+		{0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 14},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 14, 14},
+};
+
+static u8 delta_swing_index_mp_5ga_p_txpwrtrack_type0_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 9, 10, 10, 11, 12, 13, 13, 14, 14, 15, 15, 15},
+		{0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 9, 10, 10, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 15},
+};
+
+static u8 delta_swing_index_mp_2gb_n_txpwrtrack_type0_8822b[] = {
+	0,  1,  2,  3,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2gb_p_txpwrtrack_type0_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  7,  8,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2ga_n_txpwrtrack_type0_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2ga_p_txpwrtrack_type0_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type0_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17};
+
+static u8 delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type0_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type0_8822b[] = {
+	0,  1,  2,  3,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type0_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+void odm_read_and_config_mp_8822b_txpowertrack_type0(struct phy_dm_struct *dm)
+{
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT, "===> ODM_ReadAndConfig_MP_mp_8822b\n");
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_p,
+			delta_swing_index_mp_2ga_p_txpwrtrack_type0_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_n,
+			delta_swing_index_mp_2ga_n_txpwrtrack_type0_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_p,
+			delta_swing_index_mp_2gb_p_txpwrtrack_type0_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_n,
+			delta_swing_index_mp_2gb_n_txpwrtrack_type0_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_p,
+			delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type0_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_n,
+			delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type0_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_p,
+			delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type0_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_n,
+			delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type0_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_p,
+			delta_swing_index_mp_5ga_p_txpwrtrack_type0_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_n,
+			delta_swing_index_mp_5ga_n_txpwrtrack_type0_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_p,
+			delta_swing_index_mp_5gb_p_txpwrtrack_type0_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_n,
+			delta_swing_index_mp_5gb_n_txpwrtrack_type0_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+}
+
+/******************************************************************************
+ *                           txpowertrack_type1.TXT
+ ******************************************************************************/
+
+static u8 delta_swing_index_mp_5gb_n_txpwrtrack_type1_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 10,
+		 11, 11, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 15, 15, 15},
+		{0, 1,  1,  2,  2,  3,  3,  4,  5,  5,  6,  7,  7,  8,  8,
+		 9, 10, 10, 11, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14, 14},
+		{0, 1,  2,  2,  3,  3,  4,  4,  5,  6,  6,  7,  7,  8,  9,
+		 9, 10, 10, 11, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14, 14},
+};
+
+static u8 delta_swing_index_mp_5gb_p_txpwrtrack_type1_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  4,  5,  6,  7,  8,  8,  9,  10, 11, 11,
+		 12, 13, 14, 15, 15, 16, 17, 18, 18, 19, 19, 19, 19, 19, 19},
+		{0,  1,  2,  2,  3,  4,  5,  6,  6,  7,  8,  8,  9,  9,  10,
+		 11, 12, 12, 13, 14, 15, 16, 17, 17, 18, 18, 18, 18, 18, 18},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  6,  7,  8,  8,  9,  10,
+		 10, 11, 12, 13, 14, 15, 15, 16, 16, 17, 17, 17, 17, 17, 17},
+};
+
+static u8 delta_swing_index_mp_5ga_n_txpwrtrack_type1_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  3,  4,  5,  6,  7,  8,  8,  9,  9,  10,
+		 11, 11, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 15, 15, 15},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  6,  7,  7,  8,  8,  9,
+		 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14, 14},
+		{0, 1,  2,  2,  3,  4,  4,  5,  6,  6,  7,  7,  8,  8,  9,
+		 9, 10, 10, 11, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14, 14},
+};
+
+static u8 delta_swing_index_mp_5ga_p_txpwrtrack_type1_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  9,  9,  10, 11,
+		 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 20, 20, 20, 20},
+		{0,  1,  2,  2,  3,  4,  4,  5,  6,  6,  7,  7,  8,  9,  9,
+		 10, 11, 11, 12, 13, 14, 15, 16, 16, 17, 17, 18, 18, 18, 18},
+		{0,  1,  2,  3,  3,  4,  5,  5,  6,  6,  7,  8,  8,  9,  10,
+		 11, 12, 12, 13, 14, 15, 15, 16, 17, 17, 18, 18, 18, 18, 18},
+};
+
+static u8 delta_swing_index_mp_2gb_n_txpwrtrack_type1_8822b[] = {
+	0,  1,  2,  3,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2gb_p_txpwrtrack_type1_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  7,  8,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2ga_n_txpwrtrack_type1_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2ga_p_txpwrtrack_type1_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type1_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17};
+
+static u8 delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type1_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type1_8822b[] = {
+	0,  1,  2,  3,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type1_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+void odm_read_and_config_mp_8822b_txpowertrack_type1(struct phy_dm_struct *dm)
+{
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT, "===> ODM_ReadAndConfig_MP_mp_8822b\n");
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_p,
+			delta_swing_index_mp_2ga_p_txpwrtrack_type1_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_n,
+			delta_swing_index_mp_2ga_n_txpwrtrack_type1_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_p,
+			delta_swing_index_mp_2gb_p_txpwrtrack_type1_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_n,
+			delta_swing_index_mp_2gb_n_txpwrtrack_type1_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_p,
+			delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type1_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_n,
+			delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type1_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_p,
+			delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type1_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_n,
+			delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type1_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_p,
+			delta_swing_index_mp_5ga_p_txpwrtrack_type1_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_n,
+			delta_swing_index_mp_5ga_n_txpwrtrack_type1_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_p,
+			delta_swing_index_mp_5gb_p_txpwrtrack_type1_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_n,
+			delta_swing_index_mp_5gb_n_txpwrtrack_type1_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+}
+
+/******************************************************************************
+ *                           txpowertrack_type2.TXT
+ ******************************************************************************/
+
+static u8 delta_swing_index_mp_5gb_n_txpwrtrack_type2_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9,  10, 11,
+		 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9,  10, 11,
+		 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9,  10, 11,
+		 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22},
+};
+
+static u8 delta_swing_index_mp_5gb_p_txpwrtrack_type2_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  9,  9,  10, 11,
+		 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 23},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  9,  9,  10, 11,
+		 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 23},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  9,  9,  10, 11,
+		 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 23},
+};
+
+static u8 delta_swing_index_mp_5ga_n_txpwrtrack_type2_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9,  10, 11,
+		 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9,  10, 11,
+		 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9,  10, 11,
+		 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22},
+};
+
+static u8 delta_swing_index_mp_5ga_p_txpwrtrack_type2_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  9,  9,  10, 11,
+		 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 23},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  9,  9,  10, 11,
+		 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 23},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  9,  9,  10, 11,
+		 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 23},
+};
+
+static u8 delta_swing_index_mp_2gb_n_txpwrtrack_type2_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2gb_p_txpwrtrack_type2_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+static u8 delta_swing_index_mp_2ga_n_txpwrtrack_type2_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2ga_p_txpwrtrack_type2_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+static u8 delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type2_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type2_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+static u8 delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type2_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type2_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+void odm_read_and_config_mp_8822b_txpowertrack_type2(struct phy_dm_struct *dm)
+{
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT, "===> ODM_ReadAndConfig_MP_mp_8822b\n");
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_p,
+			delta_swing_index_mp_2ga_p_txpwrtrack_type2_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_n,
+			delta_swing_index_mp_2ga_n_txpwrtrack_type2_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_p,
+			delta_swing_index_mp_2gb_p_txpwrtrack_type2_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_n,
+			delta_swing_index_mp_2gb_n_txpwrtrack_type2_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_p,
+			delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type2_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_n,
+			delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type2_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_p,
+			delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type2_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_n,
+			delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type2_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_p,
+			delta_swing_index_mp_5ga_p_txpwrtrack_type2_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_n,
+			delta_swing_index_mp_5ga_n_txpwrtrack_type2_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_p,
+			delta_swing_index_mp_5gb_p_txpwrtrack_type2_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_n,
+			delta_swing_index_mp_5gb_n_txpwrtrack_type2_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+}
+
+/******************************************************************************
+ *                           txpowertrack_type3_type5.TXT
+ ******************************************************************************/
+
+static u8 delta_swing_index_mp_5gb_n_txpwrtrack_type3_type5_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+		 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+		 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+		 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+};
+
+static u8 delta_swing_index_mp_5gb_p_txpwrtrack_type3_type5_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1,  2,  2,  3,  3,  4,  5,  5,  6,  6,  7,  7,  8,
+		 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 17},
+		{0, 1, 1,  2,  2,  3,  3,  4,  5,  5,  6,  6,  7,  7,  8,
+		 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 17},
+		{0, 1, 1,  2,  2,  3,  3,  4,  5,  5,  6,  6,  7,  7,  8,
+		 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 17},
+};
+
+static u8 delta_swing_index_mp_5ga_n_txpwrtrack_type3_type5_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+		 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+		 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+		 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+};
+
+static u8 delta_swing_index_mp_5ga_p_txpwrtrack_type3_type5_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1,  2,  2,  3,  3,  4,  5,  5,  6,  6,  7,  7,  8,
+		 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 17},
+		{0, 1, 1,  2,  2,  3,  3,  4,  5,  5,  6,  6,  7,  7,  8,
+		 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 17},
+		{0, 1, 1,  2,  2,  3,  3,  4,  5,  5,  6,  6,  7,  7,  8,
+		 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 17},
+};
+
+static u8 delta_swing_index_mp_2gb_n_txpwrtrack_type3_type5_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2gb_p_txpwrtrack_type3_type5_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+static u8 delta_swing_index_mp_2ga_n_txpwrtrack_type3_type5_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2ga_p_txpwrtrack_type3_type5_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+static u8 delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type3_type5_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type3_type5_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+static u8 delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type3_type5_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type3_type5_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+void odm_read_and_config_mp_8822b_txpowertrack_type3_type5(
+	struct phy_dm_struct *dm)
+{
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT, "===> ODM_ReadAndConfig_MP_mp_8822b\n");
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_p,
+			delta_swing_index_mp_2ga_p_txpwrtrack_type3_type5_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_n,
+			delta_swing_index_mp_2ga_n_txpwrtrack_type3_type5_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_p,
+			delta_swing_index_mp_2gb_p_txpwrtrack_type3_type5_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_n,
+			delta_swing_index_mp_2gb_n_txpwrtrack_type3_type5_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(
+		dm, cali_info->delta_swing_table_idx_2g_cck_a_p,
+		delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type3_type5_8822b,
+		DELTA_SWINGIDX_SIZE);
+	odm_move_memory(
+		dm, cali_info->delta_swing_table_idx_2g_cck_a_n,
+		delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type3_type5_8822b,
+		DELTA_SWINGIDX_SIZE);
+	odm_move_memory(
+		dm, cali_info->delta_swing_table_idx_2g_cck_b_p,
+		delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type3_type5_8822b,
+		DELTA_SWINGIDX_SIZE);
+	odm_move_memory(
+		dm, cali_info->delta_swing_table_idx_2g_cck_b_n,
+		delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type3_type5_8822b,
+		DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_p,
+			delta_swing_index_mp_5ga_p_txpwrtrack_type3_type5_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_n,
+			delta_swing_index_mp_5ga_n_txpwrtrack_type3_type5_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_p,
+			delta_swing_index_mp_5gb_p_txpwrtrack_type3_type5_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_n,
+			delta_swing_index_mp_5gb_n_txpwrtrack_type3_type5_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+}
+
+/******************************************************************************
+ *                           txpowertrack_type4.TXT
+ ******************************************************************************/
+
+static u8 delta_swing_index_mp_5gb_n_txpwrtrack_type4_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9,  10, 11,
+		 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9,  10, 11,
+		 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9,  10, 11,
+		 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22},
+};
+
+static u8 delta_swing_index_mp_5gb_p_txpwrtrack_type4_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  9,  9,  10, 11,
+		 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 23},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  9,  9,  10, 11,
+		 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 23},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  9,  9,  10, 11,
+		 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 23},
+};
+
+static u8 delta_swing_index_mp_5ga_n_txpwrtrack_type4_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9,  10, 11,
+		 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9,  10, 11,
+		 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  8,  9,  10, 11,
+		 11, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22},
+};
+
+static u8 delta_swing_index_mp_5ga_p_txpwrtrack_type4_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  9,  9,  10, 11,
+		 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 23},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  9,  9,  10, 11,
+		 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 23},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  7,  8,  9,  9,  10, 11,
+		 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 23},
+};
+
+static u8 delta_swing_index_mp_2gb_n_txpwrtrack_type4_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2gb_p_txpwrtrack_type4_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+static u8 delta_swing_index_mp_2ga_n_txpwrtrack_type4_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2ga_p_txpwrtrack_type4_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+static u8 delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type4_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type4_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+static u8 delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type4_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type4_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+void odm_read_and_config_mp_8822b_txpowertrack_type4(struct phy_dm_struct *dm)
+{
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT, "===> ODM_ReadAndConfig_MP_mp_8822b\n");
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_p,
+			delta_swing_index_mp_2ga_p_txpwrtrack_type4_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_n,
+			delta_swing_index_mp_2ga_n_txpwrtrack_type4_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_p,
+			delta_swing_index_mp_2gb_p_txpwrtrack_type4_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_n,
+			delta_swing_index_mp_2gb_n_txpwrtrack_type4_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_p,
+			delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type4_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_n,
+			delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type4_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_p,
+			delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type4_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_n,
+			delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type4_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_p,
+			delta_swing_index_mp_5ga_p_txpwrtrack_type4_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_n,
+			delta_swing_index_mp_5ga_n_txpwrtrack_type4_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_p,
+			delta_swing_index_mp_5gb_p_txpwrtrack_type4_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_n,
+			delta_swing_index_mp_5gb_n_txpwrtrack_type4_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+}
+
+/******************************************************************************
+ *                           txpowertrack_type6.TXT
+ ******************************************************************************/
+
+static u8 delta_swing_index_mp_5gb_n_txpwrtrack_type6_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 10,
+		 11, 11, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 15, 15, 15},
+		{0,  1,  2,  3,  4,  5,  5,  6,  7,  7,  8,  9,  9,  10, 10,
+		 11, 12, 12, 13, 14, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16},
+		{0,  1,  2,  3,  4,  4,  5,  5,  6,  7,  8,  9,  10, 11, 12,
+		 12, 13, 13, 14, 15, 15, 16, 16, 17, 17, 17, 17, 17, 17, 17},
+};
+
+static u8 delta_swing_index_mp_5gb_p_txpwrtrack_type6_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  4,  5,  6,  7,  8,  8,  9,  10, 11, 11,
+		 12, 13, 14, 15, 15, 16, 17, 18, 18, 19, 19, 19, 19, 19, 19},
+		{0,  1,  2,  2,  3,  4,  5,  6,  7,  8,  9,  9,  11, 11, 12,
+		 13, 14, 15, 16, 17, 18, 19, 20, 20, 21, 21, 21, 21, 21, 21},
+		{0,  1,  2,  3,  4,  5,  6,  6,  7,  7,  8,  9,  10, 11, 12,
+		 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 20, 20, 21, 21, 21},
+};
+
+static u8 delta_swing_index_mp_5ga_n_txpwrtrack_type6_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  3,  4,  5,  6,  7,  8,  9,  10, 10, 11,
+		 12, 12, 13, 14, 14, 15, 15, 16, 16, 16, 17, 17, 17, 17, 17},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  6,  7,  8,  9,  9,  10,
+		 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15, 15, 15, 15},
+		{0,  1,  2,  2,  3,  4,  4,  5,  6,  6,  7,  8,  9,  9,  10,
+		 11, 12, 12, 13, 14, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16},
+};
+
+static u8 delta_swing_index_mp_5ga_p_txpwrtrack_type6_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  4,  5,  6,  7,  8,  9,  10, 10, 11, 12,
+		 13, 14, 15, 15, 16, 17, 18, 19, 20, 20, 21, 21, 21, 21, 21},
+		{0,  1,  2,  2,  3,  4,  4,  5,  7,  7,  8,  9,  10, 11, 11,
+		 12, 13, 13, 14, 15, 16, 17, 18, 18, 19, 19, 20, 20, 21, 21},
+		{0,  1,  2,  3,  3,  4,  5,  5,  6,  7,  8,  9,  10, 11, 12,
+		 13, 14, 14, 15, 16, 17, 17, 18, 19, 19, 20, 20, 20, 20, 20},
+};
+
+static u8 delta_swing_index_mp_2gb_n_txpwrtrack_type6_8822b[] = {
+	0,  1,  2,  3,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2gb_p_txpwrtrack_type6_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  7,  8,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2ga_n_txpwrtrack_type6_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2ga_p_txpwrtrack_type6_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type6_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17};
+
+static u8 delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type6_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type6_8822b[] = {
+	0,  1,  2,  3,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type6_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+void odm_read_and_config_mp_8822b_txpowertrack_type6(struct phy_dm_struct *dm)
+{
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT, "===> ODM_ReadAndConfig_MP_mp_8822b\n");
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_p,
+			delta_swing_index_mp_2ga_p_txpwrtrack_type6_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_n,
+			delta_swing_index_mp_2ga_n_txpwrtrack_type6_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_p,
+			delta_swing_index_mp_2gb_p_txpwrtrack_type6_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_n,
+			delta_swing_index_mp_2gb_n_txpwrtrack_type6_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_p,
+			delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type6_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_n,
+			delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type6_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_p,
+			delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type6_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_n,
+			delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type6_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_p,
+			delta_swing_index_mp_5ga_p_txpwrtrack_type6_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_n,
+			delta_swing_index_mp_5ga_n_txpwrtrack_type6_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_p,
+			delta_swing_index_mp_5gb_p_txpwrtrack_type6_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_n,
+			delta_swing_index_mp_5gb_n_txpwrtrack_type6_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+}
+
+/******************************************************************************
+ *                           txpowertrack_type7.TXT
+ ******************************************************************************/
+
+static u8 delta_swing_index_mp_5gb_n_txpwrtrack_type7_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 10,
+		 11, 11, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 15, 15, 15},
+		{0,  1,  2,  3,  4,  5,  5,  6,  7,  7,  8,  9,  9,  10, 10,
+		 11, 12, 12, 13, 14, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16},
+		{0,  1,  2,  3,  4,  4,  5,  5,  6,  7,  8,  9,  10, 11, 12,
+		 12, 13, 13, 14, 15, 15, 16, 16, 17, 17, 17, 17, 17, 17, 17},
+};
+
+static u8 delta_swing_index_mp_5gb_p_txpwrtrack_type7_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  4,  5,  6,  7,  8,  8,  9,  10, 11, 11,
+		 12, 13, 14, 15, 15, 16, 17, 18, 18, 19, 19, 19, 19, 19, 19},
+		{0,  1,  2,  2,  3,  4,  5,  6,  7,  8,  9,  9,  11, 11, 12,
+		 13, 14, 15, 16, 17, 18, 19, 20, 20, 21, 21, 21, 21, 21, 21},
+		{0,  1,  2,  3,  4,  5,  6,  6,  7,  7,  8,  9,  10, 11, 12,
+		 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 20, 20, 21, 21, 21},
+};
+
+static u8 delta_swing_index_mp_5ga_n_txpwrtrack_type7_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  3,  4,  5,  6,  7,  8,  9,  10, 10, 11,
+		 12, 12, 13, 14, 14, 15, 15, 16, 16, 16, 17, 17, 17, 17, 17},
+		{0,  1,  2,  2,  3,  4,  5,  5,  6,  6,  7,  8,  9,  9,  10,
+		 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15, 15, 15, 15},
+		{0,  1,  2,  2,  3,  4,  4,  5,  6,  6,  7,  8,  9,  9,  10,
+		 11, 12, 12, 13, 14, 14, 15, 15, 16, 16, 16, 16, 16, 16, 16},
+};
+
+static u8 delta_swing_index_mp_5ga_p_txpwrtrack_type7_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0,  1,  2,  2,  3,  4,  5,  6,  7,  8,  9,  10, 10, 11, 12,
+		 13, 14, 15, 15, 16, 17, 18, 19, 20, 20, 21, 21, 21, 21, 21},
+		{0,  1,  2,  2,  3,  4,  4,  5,  7,  7,  8,  9,  10, 11, 11,
+		 12, 13, 13, 14, 15, 16, 17, 18, 18, 19, 19, 20, 20, 21, 21},
+		{0,  1,  2,  3,  3,  4,  5,  5,  6,  7,  8,  9,  10, 11, 12,
+		 13, 14, 14, 15, 16, 17, 17, 18, 19, 19, 20, 20, 20, 20, 20},
+};
+
+static u8 delta_swing_index_mp_2gb_n_txpwrtrack_type7_8822b[] = {
+	0,  1,  2,  3,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2gb_p_txpwrtrack_type7_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  7,  8,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2ga_n_txpwrtrack_type7_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2ga_p_txpwrtrack_type7_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type7_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17};
+
+static u8 delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type7_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type7_8822b[] = {
+	0,  1,  2,  3,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type7_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+void odm_read_and_config_mp_8822b_txpowertrack_type7(struct phy_dm_struct *dm)
+{
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT, "===> ODM_ReadAndConfig_MP_mp_8822b\n");
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_p,
+			delta_swing_index_mp_2ga_p_txpwrtrack_type7_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_n,
+			delta_swing_index_mp_2ga_n_txpwrtrack_type7_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_p,
+			delta_swing_index_mp_2gb_p_txpwrtrack_type7_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_n,
+			delta_swing_index_mp_2gb_n_txpwrtrack_type7_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_p,
+			delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type7_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_n,
+			delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type7_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_p,
+			delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type7_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_n,
+			delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type7_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_p,
+			delta_swing_index_mp_5ga_p_txpwrtrack_type7_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_n,
+			delta_swing_index_mp_5ga_n_txpwrtrack_type7_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_p,
+			delta_swing_index_mp_5gb_p_txpwrtrack_type7_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_n,
+			delta_swing_index_mp_5gb_n_txpwrtrack_type7_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+}
+
+/******************************************************************************
+ *                           txpowertrack_type8.TXT
+ ******************************************************************************/
+
+static u8 delta_swing_index_mp_5gb_n_txpwrtrack_type8_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+		 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+		 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+		 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+};
+
+static u8 delta_swing_index_mp_5gb_p_txpwrtrack_type8_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1,  2,  2,  3,  3,  4,  5,  5,  6,  6,  7,  7,  8,
+		 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 17},
+		{0, 1, 1,  2,  2,  3,  3,  4,  5,  5,  6,  6,  7,  7,  8,
+		 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 17},
+		{0, 1, 1,  2,  2,  3,  3,  4,  5,  5,  6,  6,  7,  7,  8,
+		 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 17},
+};
+
+static u8 delta_swing_index_mp_5ga_n_txpwrtrack_type8_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+		 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+		 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+		 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+};
+
+static u8 delta_swing_index_mp_5ga_p_txpwrtrack_type8_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1,  2,  2,  3,  3,  4,  5,  5,  6,  6,  7,  7,  8,
+		 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 17},
+		{0, 1, 1,  2,  2,  3,  3,  4,  5,  5,  6,  6,  7,  7,  8,
+		 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 17},
+		{0, 1, 1,  2,  2,  3,  3,  4,  5,  5,  6,  6,  7,  7,  8,
+		 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 17},
+};
+
+static u8 delta_swing_index_mp_2gb_n_txpwrtrack_type8_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2gb_p_txpwrtrack_type8_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+static u8 delta_swing_index_mp_2ga_n_txpwrtrack_type8_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2ga_p_txpwrtrack_type8_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+static u8 delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type8_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type8_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+static u8 delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type8_8822b[] = {
+	0, 1, 1, 1, 2, 2, 3, 3, 3, 4,  4,  5,  5,  5,  6,
+	6, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12};
+
+static u8 delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type8_8822b[] = {
+	0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  7,  7,  8,
+	8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15};
+
+void odm_read_and_config_mp_8822b_txpowertrack_type8(struct phy_dm_struct *dm)
+{
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT, "===> ODM_ReadAndConfig_MP_mp_8822b\n");
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_p,
+			delta_swing_index_mp_2ga_p_txpwrtrack_type8_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_n,
+			delta_swing_index_mp_2ga_n_txpwrtrack_type8_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_p,
+			delta_swing_index_mp_2gb_p_txpwrtrack_type8_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_n,
+			delta_swing_index_mp_2gb_n_txpwrtrack_type8_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_p,
+			delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type8_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_n,
+			delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type8_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_p,
+			delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type8_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_n,
+			delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type8_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_p,
+			delta_swing_index_mp_5ga_p_txpwrtrack_type8_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_n,
+			delta_swing_index_mp_5ga_n_txpwrtrack_type8_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_p,
+			delta_swing_index_mp_5gb_p_txpwrtrack_type8_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_n,
+			delta_swing_index_mp_5gb_n_txpwrtrack_type8_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+}
+
+/******************************************************************************
+ *                           txpowertrack_type9.TXT
+ ******************************************************************************/
+
+static u8 delta_swing_index_mp_5gb_n_txpwrtrack_type9_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  8,
+		 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 14, 14},
+		{0, 1, 1,  2,  2,  3,  3,  4,  5,  5,  6,  7,  7,  8,  8,
+		 9, 9, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15},
+};
+
+static u8 delta_swing_index_mp_5gb_p_txpwrtrack_type9_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 9, 10, 10, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+		{0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 9, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 15},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 10, 10, 11, 12, 13, 14, 14, 15, 15, 15, 16, 16},
+};
+
+static u8 delta_swing_index_mp_5ga_n_txpwrtrack_type9_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14},
+		{0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 14},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 14, 14},
+};
+
+static u8 delta_swing_index_mp_5ga_p_txpwrtrack_type9_8822b
+	[][DELTA_SWINGIDX_SIZE] = {
+		{0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 9, 10, 10, 11, 12, 13, 13, 14, 14, 15, 15, 15},
+		{0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 8, 9, 9, 10, 10, 11, 12, 12, 13, 13, 14, 14, 15, 15},
+		{0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
+		 8, 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 15},
+};
+
+static u8 delta_swing_index_mp_2gb_n_txpwrtrack_type9_8822b[] = {
+	0,  1,  2,  3,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2gb_p_txpwrtrack_type9_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  7,  8,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2ga_n_txpwrtrack_type9_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2ga_p_txpwrtrack_type9_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type9_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17};
+
+static u8 delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type9_8822b[] = {
+	0,  1,  1,  2,  3,  4,  4,  5,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+static u8 delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type9_8822b[] = {
+	0,  1,  2,  3,  3,  4,  4,  5,  6,  7,  8,  9,  10, 11, 12,
+	13, 13, 14, 15, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18};
+
+static u8 delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type9_8822b[] = {
+	0,  1,  2,  3,  3,  4,  5,  6,  6,  7,  8,  9,  9,  10, 11,
+	12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 22, 22};
+
+void odm_read_and_config_mp_8822b_txpowertrack_type9(struct phy_dm_struct *dm)
+{
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT, "===> ODM_ReadAndConfig_MP_mp_8822b\n");
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_p,
+			delta_swing_index_mp_2ga_p_txpwrtrack_type9_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2ga_n,
+			delta_swing_index_mp_2ga_n_txpwrtrack_type9_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_p,
+			delta_swing_index_mp_2gb_p_txpwrtrack_type9_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2gb_n,
+			delta_swing_index_mp_2gb_n_txpwrtrack_type9_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_p,
+			delta_swing_index_mp_2g_cck_a_p_txpwrtrack_type9_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_a_n,
+			delta_swing_index_mp_2g_cck_a_n_txpwrtrack_type9_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_p,
+			delta_swing_index_mp_2g_cck_b_p_txpwrtrack_type9_8822b,
+			DELTA_SWINGIDX_SIZE);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_2g_cck_b_n,
+			delta_swing_index_mp_2g_cck_b_n_txpwrtrack_type9_8822b,
+			DELTA_SWINGIDX_SIZE);
+
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_p,
+			delta_swing_index_mp_5ga_p_txpwrtrack_type9_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5ga_n,
+			delta_swing_index_mp_5ga_n_txpwrtrack_type9_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_p,
+			delta_swing_index_mp_5gb_p_txpwrtrack_type9_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+	odm_move_memory(dm, cali_info->delta_swing_table_idx_5gb_n,
+			delta_swing_index_mp_5gb_n_txpwrtrack_type9_8822b,
+			DELTA_SWINGIDX_SIZE * 3);
+}
+
+/******************************************************************************
+ *                           txpwr_lmt.TXT
+ ******************************************************************************/
+
+static const char *const array_mp_8822b_txpwr_lmt[] = {
+	"FCC",  "2.4G", "20M",  "CCK",  "1T",   "01",   "32",   "ETSI", "2.4G",
+	"20M",  "CCK",  "1T",   "01",   "28",   "MKK",  "2.4G", "20M",  "CCK",
+	"1T",   "01",   "30",   "FCC",  "2.4G", "20M",  "CCK",  "1T",   "02",
+	"32",   "ETSI", "2.4G", "20M",  "CCK",  "1T",   "02",   "28",   "MKK",
+	"2.4G", "20M",  "CCK",  "1T",   "02",   "30",   "FCC",  "2.4G", "20M",
+	"CCK",  "1T",   "03",   "32",   "ETSI", "2.4G", "20M",  "CCK",  "1T",
+	"03",   "28",   "MKK",  "2.4G", "20M",  "CCK",  "1T",   "03",   "30",
+	"FCC",  "2.4G", "20M",  "CCK",  "1T",   "04",   "32",   "ETSI", "2.4G",
+	"20M",  "CCK",  "1T",   "04",   "28",   "MKK",  "2.4G", "20M",  "CCK",
+	"1T",   "04",   "30",   "FCC",  "2.4G", "20M",  "CCK",  "1T",   "05",
+	"32",   "ETSI", "2.4G", "20M",  "CCK",  "1T",   "05",   "28",   "MKK",
+	"2.4G", "20M",  "CCK",  "1T",   "05",   "30",   "FCC",  "2.4G", "20M",
+	"CCK",  "1T",   "06",   "32",   "ETSI", "2.4G", "20M",  "CCK",  "1T",
+	"06",   "28",   "MKK",  "2.4G", "20M",  "CCK",  "1T",   "06",   "30",
+	"FCC",  "2.4G", "20M",  "CCK",  "1T",   "07",   "32",   "ETSI", "2.4G",
+	"20M",  "CCK",  "1T",   "07",   "28",   "MKK",  "2.4G", "20M",  "CCK",
+	"1T",   "07",   "30",   "FCC",  "2.4G", "20M",  "CCK",  "1T",   "08",
+	"32",   "ETSI", "2.4G", "20M",  "CCK",  "1T",   "08",   "28",   "MKK",
+	"2.4G", "20M",  "CCK",  "1T",   "08",   "30",   "FCC",  "2.4G", "20M",
+	"CCK",  "1T",   "09",   "32",   "ETSI", "2.4G", "20M",  "CCK",  "1T",
+	"09",   "28",   "MKK",  "2.4G", "20M",  "CCK",  "1T",   "09",   "30",
+	"FCC",  "2.4G", "20M",  "CCK",  "1T",   "10",   "32",   "ETSI", "2.4G",
+	"20M",  "CCK",  "1T",   "10",   "28",   "MKK",  "2.4G", "20M",  "CCK",
+	"1T",   "10",   "30",   "FCC",  "2.4G", "20M",  "CCK",  "1T",   "11",
+	"32",   "ETSI", "2.4G", "20M",  "CCK",  "1T",   "11",   "28",   "MKK",
+	"2.4G", "20M",  "CCK",  "1T",   "11",   "30",   "FCC",  "2.4G", "20M",
+	"CCK",  "1T",   "12",   "26",   "ETSI", "2.4G", "20M",  "CCK",  "1T",
+	"12",   "28",   "MKK",  "2.4G", "20M",  "CCK",  "1T",   "12",   "30",
+	"FCC",  "2.4G", "20M",  "CCK",  "1T",   "13",   "20",   "ETSI", "2.4G",
+	"20M",  "CCK",  "1T",   "13",   "28",   "MKK",  "2.4G", "20M",  "CCK",
+	"1T",   "13",   "28",   "FCC",  "2.4G", "20M",  "CCK",  "1T",   "14",
+	"63",   "ETSI", "2.4G", "20M",  "CCK",  "1T",   "14",   "63",   "MKK",
+	"2.4G", "20M",  "CCK",  "1T",   "14",   "32",   "FCC",  "2.4G", "20M",
+	"OFDM", "1T",   "01",   "26",   "ETSI", "2.4G", "20M",  "OFDM", "1T",
+	"01",   "30",   "MKK",  "2.4G", "20M",  "OFDM", "1T",   "01",   "34",
+	"FCC",  "2.4G", "20M",  "OFDM", "1T",   "02",   "30",   "ETSI", "2.4G",
+	"20M",  "OFDM", "1T",   "02",   "30",   "MKK",  "2.4G", "20M",  "OFDM",
+	"1T",   "02",   "34",   "FCC",  "2.4G", "20M",  "OFDM", "1T",   "03",
+	"32",   "ETSI", "2.4G", "20M",  "OFDM", "1T",   "03",   "30",   "MKK",
+	"2.4G", "20M",  "OFDM", "1T",   "03",   "34",   "FCC",  "2.4G", "20M",
+	"OFDM", "1T",   "04",   "34",   "ETSI", "2.4G", "20M",  "OFDM", "1T",
+	"04",   "30",   "MKK",  "2.4G", "20M",  "OFDM", "1T",   "04",   "34",
+	"FCC",  "2.4G", "20M",  "OFDM", "1T",   "05",   "34",   "ETSI", "2.4G",
+	"20M",  "OFDM", "1T",   "05",   "30",   "MKK",  "2.4G", "20M",  "OFDM",
+	"1T",   "05",   "34",   "FCC",  "2.4G", "20M",  "OFDM", "1T",   "06",
+	"34",   "ETSI", "2.4G", "20M",  "OFDM", "1T",   "06",   "30",   "MKK",
+	"2.4G", "20M",  "OFDM", "1T",   "06",   "34",   "FCC",  "2.4G", "20M",
+	"OFDM", "1T",   "07",   "34",   "ETSI", "2.4G", "20M",  "OFDM", "1T",
+	"07",   "30",   "MKK",  "2.4G", "20M",  "OFDM", "1T",   "07",   "34",
+	"FCC",  "2.4G", "20M",  "OFDM", "1T",   "08",   "34",   "ETSI", "2.4G",
+	"20M",  "OFDM", "1T",   "08",   "30",   "MKK",  "2.4G", "20M",  "OFDM",
+	"1T",   "08",   "34",   "FCC",  "2.4G", "20M",  "OFDM", "1T",   "09",
+	"32",   "ETSI", "2.4G", "20M",  "OFDM", "1T",   "09",   "30",   "MKK",
+	"2.4G", "20M",  "OFDM", "1T",   "09",   "34",   "FCC",  "2.4G", "20M",
+	"OFDM", "1T",   "10",   "30",   "ETSI", "2.4G", "20M",  "OFDM", "1T",
+	"10",   "30",   "MKK",  "2.4G", "20M",  "OFDM", "1T",   "10",   "34",
+	"FCC",  "2.4G", "20M",  "OFDM", "1T",   "11",   "28",   "ETSI", "2.4G",
+	"20M",  "OFDM", "1T",   "11",   "30",   "MKK",  "2.4G", "20M",  "OFDM",
+	"1T",   "11",   "34",   "FCC",  "2.4G", "20M",  "OFDM", "1T",   "12",
+	"22",   "ETSI", "2.4G", "20M",  "OFDM", "1T",   "12",   "30",   "MKK",
+	"2.4G", "20M",  "OFDM", "1T",   "12",   "34",   "FCC",  "2.4G", "20M",
+	"OFDM", "1T",   "13",   "14",   "ETSI", "2.4G", "20M",  "OFDM", "1T",
+	"13",   "30",   "MKK",  "2.4G", "20M",  "OFDM", "1T",   "13",   "34",
+	"FCC",  "2.4G", "20M",  "OFDM", "1T",   "14",   "63",   "ETSI", "2.4G",
+	"20M",  "OFDM", "1T",   "14",   "63",   "MKK",  "2.4G", "20M",  "OFDM",
+	"1T",   "14",   "63",   "FCC",  "2.4G", "20M",  "HT",   "1T",   "01",
+	"26",   "ETSI", "2.4G", "20M",  "HT",   "1T",   "01",   "30",   "MKK",
+	"2.4G", "20M",  "HT",   "1T",   "01",   "34",   "FCC",  "2.4G", "20M",
+	"HT",   "1T",   "02",   "30",   "ETSI", "2.4G", "20M",  "HT",   "1T",
+	"02",   "30",   "MKK",  "2.4G", "20M",  "HT",   "1T",   "02",   "34",
+	"FCC",  "2.4G", "20M",  "HT",   "1T",   "03",   "32",   "ETSI", "2.4G",
+	"20M",  "HT",   "1T",   "03",   "30",   "MKK",  "2.4G", "20M",  "HT",
+	"1T",   "03",   "34",   "FCC",  "2.4G", "20M",  "HT",   "1T",   "04",
+	"34",   "ETSI", "2.4G", "20M",  "HT",   "1T",   "04",   "30",   "MKK",
+	"2.4G", "20M",  "HT",   "1T",   "04",   "34",   "FCC",  "2.4G", "20M",
+	"HT",   "1T",   "05",   "34",   "ETSI", "2.4G", "20M",  "HT",   "1T",
+	"05",   "30",   "MKK",  "2.4G", "20M",  "HT",   "1T",   "05",   "34",
+	"FCC",  "2.4G", "20M",  "HT",   "1T",   "06",   "34",   "ETSI", "2.4G",
+	"20M",  "HT",   "1T",   "06",   "30",   "MKK",  "2.4G", "20M",  "HT",
+	"1T",   "06",   "34",   "FCC",  "2.4G", "20M",  "HT",   "1T",   "07",
+	"34",   "ETSI", "2.4G", "20M",  "HT",   "1T",   "07",   "30",   "MKK",
+	"2.4G", "20M",  "HT",   "1T",   "07",   "34",   "FCC",  "2.4G", "20M",
+	"HT",   "1T",   "08",   "34",   "ETSI", "2.4G", "20M",  "HT",   "1T",
+	"08",   "30",   "MKK",  "2.4G", "20M",  "HT",   "1T",   "08",   "34",
+	"FCC",  "2.4G", "20M",  "HT",   "1T",   "09",   "32",   "ETSI", "2.4G",
+	"20M",  "HT",   "1T",   "09",   "30",   "MKK",  "2.4G", "20M",  "HT",
+	"1T",   "09",   "34",   "FCC",  "2.4G", "20M",  "HT",   "1T",   "10",
+	"30",   "ETSI", "2.4G", "20M",  "HT",   "1T",   "10",   "30",   "MKK",
+	"2.4G", "20M",  "HT",   "1T",   "10",   "34",   "FCC",  "2.4G", "20M",
+	"HT",   "1T",   "11",   "26",   "ETSI", "2.4G", "20M",  "HT",   "1T",
+	"11",   "30",   "MKK",  "2.4G", "20M",  "HT",   "1T",   "11",   "34",
+	"FCC",  "2.4G", "20M",  "HT",   "1T",   "12",   "20",   "ETSI", "2.4G",
+	"20M",  "HT",   "1T",   "12",   "30",   "MKK",  "2.4G", "20M",  "HT",
+	"1T",   "12",   "34",   "FCC",  "2.4G", "20M",  "HT",   "1T",   "13",
+	"14",   "ETSI", "2.4G", "20M",  "HT",   "1T",   "13",   "30",   "MKK",
+	"2.4G", "20M",  "HT",   "1T",   "13",   "34",   "FCC",  "2.4G", "20M",
+	"HT",   "1T",   "14",   "63",   "ETSI", "2.4G", "20M",  "HT",   "1T",
+	"14",   "63",   "MKK",  "2.4G", "20M",  "HT",   "1T",   "14",   "63",
+	"FCC",  "2.4G", "20M",  "HT",   "2T",   "01",   "26",   "ETSI", "2.4G",
+	"20M",  "HT",   "2T",   "01",   "18",   "MKK",  "2.4G", "20M",  "HT",
+	"2T",   "01",   "30",   "FCC",  "2.4G", "20M",  "HT",   "2T",   "02",
+	"28",   "ETSI", "2.4G", "20M",  "HT",   "2T",   "02",   "18",   "MKK",
+	"2.4G", "20M",  "HT",   "2T",   "02",   "30",   "FCC",  "2.4G", "20M",
+	"HT",   "2T",   "03",   "30",   "ETSI", "2.4G", "20M",  "HT",   "2T",
+	"03",   "18",   "MKK",  "2.4G", "20M",  "HT",   "2T",   "03",   "30",
+	"FCC",  "2.4G", "20M",  "HT",   "2T",   "04",   "30",   "ETSI", "2.4G",
+	"20M",  "HT",   "2T",   "04",   "18",   "MKK",  "2.4G", "20M",  "HT",
+	"2T",   "04",   "30",   "FCC",  "2.4G", "20M",  "HT",   "2T",   "05",
+	"32",   "ETSI", "2.4G", "20M",  "HT",   "2T",   "05",   "18",   "MKK",
+	"2.4G", "20M",  "HT",   "2T",   "05",   "30",   "FCC",  "2.4G", "20M",
+	"HT",   "2T",   "06",   "32",   "ETSI", "2.4G", "20M",  "HT",   "2T",
+	"06",   "18",   "MKK",  "2.4G", "20M",  "HT",   "2T",   "06",   "30",
+	"FCC",  "2.4G", "20M",  "HT",   "2T",   "07",   "32",   "ETSI", "2.4G",
+	"20M",  "HT",   "2T",   "07",   "18",   "MKK",  "2.4G", "20M",  "HT",
+	"2T",   "07",   "30",   "FCC",  "2.4G", "20M",  "HT",   "2T",   "08",
+	"30",   "ETSI", "2.4G", "20M",  "HT",   "2T",   "08",   "18",   "MKK",
+	"2.4G", "20M",  "HT",   "2T",   "08",   "30",   "FCC",  "2.4G", "20M",
+	"HT",   "2T",   "09",   "30",   "ETSI", "2.4G", "20M",  "HT",   "2T",
+	"09",   "18",   "MKK",  "2.4G", "20M",  "HT",   "2T",   "09",   "30",
+	"FCC",  "2.4G", "20M",  "HT",   "2T",   "10",   "28",   "ETSI", "2.4G",
+	"20M",  "HT",   "2T",   "10",   "18",   "MKK",  "2.4G", "20M",  "HT",
+	"2T",   "10",   "30",   "FCC",  "2.4G", "20M",  "HT",   "2T",   "11",
+	"26",   "ETSI", "2.4G", "20M",  "HT",   "2T",   "11",   "18",   "MKK",
+	"2.4G", "20M",  "HT",   "2T",   "11",   "30",   "FCC",  "2.4G", "20M",
+	"HT",   "2T",   "12",   "20",   "ETSI", "2.4G", "20M",  "HT",   "2T",
+	"12",   "18",   "MKK",  "2.4G", "20M",  "HT",   "2T",   "12",   "30",
+	"FCC",  "2.4G", "20M",  "HT",   "2T",   "13",   "14",   "ETSI", "2.4G",
+	"20M",  "HT",   "2T",   "13",   "18",   "MKK",  "2.4G", "20M",  "HT",
+	"2T",   "13",   "30",   "FCC",  "2.4G", "20M",  "HT",   "2T",   "14",
+	"63",   "ETSI", "2.4G", "20M",  "HT",   "2T",   "14",   "63",   "MKK",
+	"2.4G", "20M",  "HT",   "2T",   "14",   "63",   "FCC",  "2.4G", "40M",
+	"HT",   "1T",   "01",   "63",   "ETSI", "2.4G", "40M",  "HT",   "1T",
+	"01",   "63",   "MKK",  "2.4G", "40M",  "HT",   "1T",   "01",   "63",
+	"FCC",  "2.4G", "40M",  "HT",   "1T",   "02",   "63",   "ETSI", "2.4G",
+	"40M",  "HT",   "1T",   "02",   "63",   "MKK",  "2.4G", "40M",  "HT",
+	"1T",   "02",   "63",   "FCC",  "2.4G", "40M",  "HT",   "1T",   "03",
+	"26",   "ETSI", "2.4G", "40M",  "HT",   "1T",   "03",   "30",   "MKK",
+	"2.4G", "40M",  "HT",   "1T",   "03",   "34",   "FCC",  "2.4G", "40M",
+	"HT",   "1T",   "04",   "26",   "ETSI", "2.4G", "40M",  "HT",   "1T",
+	"04",   "30",   "MKK",  "2.4G", "40M",  "HT",   "1T",   "04",   "34",
+	"FCC",  "2.4G", "40M",  "HT",   "1T",   "05",   "30",   "ETSI", "2.4G",
+	"40M",  "HT",   "1T",   "05",   "30",   "MKK",  "2.4G", "40M",  "HT",
+	"1T",   "05",   "34",   "FCC",  "2.4G", "40M",  "HT",   "1T",   "06",
+	"32",   "ETSI", "2.4G", "40M",  "HT",   "1T",   "06",   "30",   "MKK",
+	"2.4G", "40M",  "HT",   "1T",   "06",   "34",   "FCC",  "2.4G", "40M",
+	"HT",   "1T",   "07",   "30",   "ETSI", "2.4G", "40M",  "HT",   "1T",
+	"07",   "30",   "MKK",  "2.4G", "40M",  "HT",   "1T",   "07",   "34",
+	"FCC",  "2.4G", "40M",  "HT",   "1T",   "08",   "26",   "ETSI", "2.4G",
+	"40M",  "HT",   "1T",   "08",   "30",   "MKK",  "2.4G", "40M",  "HT",
+	"1T",   "08",   "34",   "FCC",  "2.4G", "40M",  "HT",   "1T",   "09",
+	"26",   "ETSI", "2.4G", "40M",  "HT",   "1T",   "09",   "30",   "MKK",
+	"2.4G", "40M",  "HT",   "1T",   "09",   "34",   "FCC",  "2.4G", "40M",
+	"HT",   "1T",   "10",   "20",   "ETSI", "2.4G", "40M",  "HT",   "1T",
+	"10",   "30",   "MKK",  "2.4G", "40M",  "HT",   "1T",   "10",   "34",
+	"FCC",  "2.4G", "40M",  "HT",   "1T",   "11",   "14",   "ETSI", "2.4G",
+	"40M",  "HT",   "1T",   "11",   "30",   "MKK",  "2.4G", "40M",  "HT",
+	"1T",   "11",   "34",   "FCC",  "2.4G", "40M",  "HT",   "1T",   "12",
+	"63",   "ETSI", "2.4G", "40M",  "HT",   "1T",   "12",   "63",   "MKK",
+	"2.4G", "40M",  "HT",   "1T",   "12",   "63",   "FCC",  "2.4G", "40M",
+	"HT",   "1T",   "13",   "63",   "ETSI", "2.4G", "40M",  "HT",   "1T",
+	"13",   "63",   "MKK",  "2.4G", "40M",  "HT",   "1T",   "13",   "63",
+	"FCC",  "2.4G", "40M",  "HT",   "1T",   "14",   "63",   "ETSI", "2.4G",
+	"40M",  "HT",   "1T",   "14",   "63",   "MKK",  "2.4G", "40M",  "HT",
+	"1T",   "14",   "63",   "FCC",  "2.4G", "40M",  "HT",   "2T",   "01",
+	"63",   "ETSI", "2.4G", "40M",  "HT",   "2T",   "01",   "63",   "MKK",
+	"2.4G", "40M",  "HT",   "2T",   "01",   "63",   "FCC",  "2.4G", "40M",
+	"HT",   "2T",   "02",   "63",   "ETSI", "2.4G", "40M",  "HT",   "2T",
+	"02",   "63",   "MKK",  "2.4G", "40M",  "HT",   "2T",   "02",   "63",
+	"FCC",  "2.4G", "40M",  "HT",   "2T",   "03",   "24",   "ETSI", "2.4G",
+	"40M",  "HT",   "2T",   "03",   "18",   "MKK",  "2.4G", "40M",  "HT",
+	"2T",   "03",   "30",   "FCC",  "2.4G", "40M",  "HT",   "2T",   "04",
+	"24",   "ETSI", "2.4G", "40M",  "HT",   "2T",   "04",   "18",   "MKK",
+	"2.4G", "40M",  "HT",   "2T",   "04",   "30",   "FCC",  "2.4G", "40M",
+	"HT",   "2T",   "05",   "26",   "ETSI", "2.4G", "40M",  "HT",   "2T",
+	"05",   "18",   "MKK",  "2.4G", "40M",  "HT",   "2T",   "05",   "30",
+	"FCC",  "2.4G", "40M",  "HT",   "2T",   "06",   "28",   "ETSI", "2.4G",
+	"40M",  "HT",   "2T",   "06",   "18",   "MKK",  "2.4G", "40M",  "HT",
+	"2T",   "06",   "30",   "FCC",  "2.4G", "40M",  "HT",   "2T",   "07",
+	"26",   "ETSI", "2.4G", "40M",  "HT",   "2T",   "07",   "18",   "MKK",
+	"2.4G", "40M",  "HT",   "2T",   "07",   "30",   "FCC",  "2.4G", "40M",
+	"HT",   "2T",   "08",   "26",   "ETSI", "2.4G", "40M",  "HT",   "2T",
+	"08",   "18",   "MKK",  "2.4G", "40M",  "HT",   "2T",   "08",   "30",
+	"FCC",  "2.4G", "40M",  "HT",   "2T",   "09",   "26",   "ETSI", "2.4G",
+	"40M",  "HT",   "2T",   "09",   "18",   "MKK",  "2.4G", "40M",  "HT",
+	"2T",   "09",   "30",   "FCC",  "2.4G", "40M",  "HT",   "2T",   "10",
+	"20",   "ETSI", "2.4G", "40M",  "HT",   "2T",   "10",   "18",   "MKK",
+	"2.4G", "40M",  "HT",   "2T",   "10",   "30",   "FCC",  "2.4G", "40M",
+	"HT",   "2T",   "11",   "14",   "ETSI", "2.4G", "40M",  "HT",   "2T",
+	"11",   "18",   "MKK",  "2.4G", "40M",  "HT",   "2T",   "11",   "30",
+	"FCC",  "2.4G", "40M",  "HT",   "2T",   "12",   "63",   "ETSI", "2.4G",
+	"40M",  "HT",   "2T",   "12",   "63",   "MKK",  "2.4G", "40M",  "HT",
+	"2T",   "12",   "63",   "FCC",  "2.4G", "40M",  "HT",   "2T",   "13",
+	"63",   "ETSI", "2.4G", "40M",  "HT",   "2T",   "13",   "63",   "MKK",
+	"2.4G", "40M",  "HT",   "2T",   "13",   "63",   "FCC",  "2.4G", "40M",
+	"HT",   "2T",   "14",   "63",   "ETSI", "2.4G", "40M",  "HT",   "2T",
+	"14",   "63",   "MKK",  "2.4G", "40M",  "HT",   "2T",   "14",   "63",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "36",   "30",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "36",   "32",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "36",   "30",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "40",
+	"32",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "40",   "32",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "40",   "30",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "44",   "32",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"44",   "32",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "44",   "30",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "48",   "32",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "48",   "32",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "48",   "30",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "52",
+	"32",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "52",   "32",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "52",   "28",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "56",   "32",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"56",   "32",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "56",   "28",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "60",   "32",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "60",   "32",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "60",   "28",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "64",
+	"28",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "64",   "32",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "64",   "28",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "100",  "26",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"100",  "32",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "100",  "32",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "104",  "32",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "104",  "32",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "104",  "32",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "108",
+	"32",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "108",  "32",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "108",  "32",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "112",  "32",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"112",  "32",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "112",  "32",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "116",  "32",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "116",  "32",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "116",  "32",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "120",
+	"32",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "120",  "32",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "120",  "32",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "124",  "32",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"124",  "32",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "124",  "32",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "128",  "32",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "128",  "32",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "128",  "32",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "132",
+	"32",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "132",  "32",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "132",  "32",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "136",  "32",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"136",  "32",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "136",  "32",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "140",  "28",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "140",  "32",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "140",  "32",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "144",
+	"28",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "144",  "32",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "144",  "63",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "149",  "32",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"149",  "63",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "149",  "63",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "153",  "32",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "153",  "63",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "153",  "63",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "157",
+	"32",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "157",  "63",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "157",  "63",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "161",  "32",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"161",  "63",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "161",  "63",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "165",  "32",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "165",  "63",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "165",  "63",   "FCC",  "5G",   "20M",  "HT",   "1T",   "36",
+	"30",   "ETSI", "5G",   "20M",  "HT",   "1T",   "36",   "32",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "36",   "28",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "40",   "32",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"40",   "32",   "MKK",  "5G",   "20M",  "HT",   "1T",   "40",   "28",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "44",   "32",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "44",   "32",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "44",   "28",   "FCC",  "5G",   "20M",  "HT",   "1T",   "48",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "1T",   "48",   "32",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "48",   "28",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "52",   "32",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"52",   "32",   "MKK",  "5G",   "20M",  "HT",   "1T",   "52",   "28",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "56",   "32",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "56",   "32",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "56",   "28",   "FCC",  "5G",   "20M",  "HT",   "1T",   "60",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "1T",   "60",   "32",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "60",   "28",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "64",   "28",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"64",   "32",   "MKK",  "5G",   "20M",  "HT",   "1T",   "64",   "28",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "100",  "26",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "100",  "32",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "100",  "32",   "FCC",  "5G",   "20M",  "HT",   "1T",   "104",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "1T",   "104",  "32",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "104",  "32",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "108",  "32",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"108",  "32",   "MKK",  "5G",   "20M",  "HT",   "1T",   "108",  "32",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "112",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "112",  "32",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "112",  "32",   "FCC",  "5G",   "20M",  "HT",   "1T",   "116",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "1T",   "116",  "32",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "116",  "32",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "120",  "32",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"120",  "32",   "MKK",  "5G",   "20M",  "HT",   "1T",   "120",  "32",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "124",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "124",  "32",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "124",  "32",   "FCC",  "5G",   "20M",  "HT",   "1T",   "128",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "1T",   "128",  "32",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "128",  "32",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "132",  "32",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"132",  "32",   "MKK",  "5G",   "20M",  "HT",   "1T",   "132",  "32",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "136",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "136",  "32",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "136",  "32",   "FCC",  "5G",   "20M",  "HT",   "1T",   "140",
+	"26",   "ETSI", "5G",   "20M",  "HT",   "1T",   "140",  "32",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "140",  "32",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "144",  "26",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"144",  "63",   "MKK",  "5G",   "20M",  "HT",   "1T",   "144",  "63",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "149",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "149",  "63",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "149",  "63",   "FCC",  "5G",   "20M",  "HT",   "1T",   "153",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "1T",   "153",  "63",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "153",  "63",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "157",  "32",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"157",  "63",   "MKK",  "5G",   "20M",  "HT",   "1T",   "157",  "63",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "161",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "161",  "63",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "161",  "63",   "FCC",  "5G",   "20M",  "HT",   "1T",   "165",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "1T",   "165",  "63",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "165",  "63",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "36",   "28",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"36",   "20",   "MKK",  "5G",   "20M",  "HT",   "2T",   "36",   "22",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "40",   "30",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "40",   "20",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "40",   "22",   "FCC",  "5G",   "20M",  "HT",   "2T",   "44",
+	"30",   "ETSI", "5G",   "20M",  "HT",   "2T",   "44",   "20",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "44",   "22",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "48",   "30",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"48",   "20",   "MKK",  "5G",   "20M",  "HT",   "2T",   "48",   "22",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "52",   "30",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "52",   "20",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "52",   "22",   "FCC",  "5G",   "20M",  "HT",   "2T",   "56",
+	"30",   "ETSI", "5G",   "20M",  "HT",   "2T",   "56",   "20",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "56",   "22",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "60",   "30",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"60",   "20",   "MKK",  "5G",   "20M",  "HT",   "2T",   "60",   "22",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "64",   "28",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "64",   "20",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "64",   "22",   "FCC",  "5G",   "20M",  "HT",   "2T",   "100",
+	"26",   "ETSI", "5G",   "20M",  "HT",   "2T",   "100",  "20",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "100",  "30",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "104",  "30",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"104",  "20",   "MKK",  "5G",   "20M",  "HT",   "2T",   "104",  "30",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "108",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "108",  "20",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "108",  "30",   "FCC",  "5G",   "20M",  "HT",   "2T",   "112",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "2T",   "112",  "20",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "112",  "30",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "116",  "32",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"116",  "20",   "MKK",  "5G",   "20M",  "HT",   "2T",   "116",  "30",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "120",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "120",  "20",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "120",  "30",   "FCC",  "5G",   "20M",  "HT",   "2T",   "124",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "2T",   "124",  "20",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "124",  "30",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "128",  "32",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"128",  "20",   "MKK",  "5G",   "20M",  "HT",   "2T",   "128",  "30",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "132",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "132",  "20",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "132",  "30",   "FCC",  "5G",   "20M",  "HT",   "2T",   "136",
+	"30",   "ETSI", "5G",   "20M",  "HT",   "2T",   "136",  "20",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "136",  "30",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "140",  "26",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"140",  "20",   "MKK",  "5G",   "20M",  "HT",   "2T",   "140",  "30",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "144",  "26",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "144",  "63",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "144",  "63",   "FCC",  "5G",   "20M",  "HT",   "2T",   "149",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "2T",   "149",  "63",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "149",  "63",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "153",  "32",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"153",  "63",   "MKK",  "5G",   "20M",  "HT",   "2T",   "153",  "63",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "157",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "157",  "63",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "157",  "63",   "FCC",  "5G",   "20M",  "HT",   "2T",   "161",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "2T",   "161",  "63",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "161",  "63",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "165",  "32",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"165",  "63",   "MKK",  "5G",   "20M",  "HT",   "2T",   "165",  "63",
+	"FCC",  "5G",   "40M",  "HT",   "1T",   "38",   "22",   "ETSI", "5G",
+	"40M",  "HT",   "1T",   "38",   "30",   "MKK",  "5G",   "40M",  "HT",
+	"1T",   "38",   "30",   "FCC",  "5G",   "40M",  "HT",   "1T",   "46",
+	"30",   "ETSI", "5G",   "40M",  "HT",   "1T",   "46",   "30",   "MKK",
+	"5G",   "40M",  "HT",   "1T",   "46",   "30",   "FCC",  "5G",   "40M",
+	"HT",   "1T",   "54",   "30",   "ETSI", "5G",   "40M",  "HT",   "1T",
+	"54",   "30",   "MKK",  "5G",   "40M",  "HT",   "1T",   "54",   "30",
+	"FCC",  "5G",   "40M",  "HT",   "1T",   "62",   "24",   "ETSI", "5G",
+	"40M",  "HT",   "1T",   "62",   "30",   "MKK",  "5G",   "40M",  "HT",
+	"1T",   "62",   "30",   "FCC",  "5G",   "40M",  "HT",   "1T",   "102",
+	"24",   "ETSI", "5G",   "40M",  "HT",   "1T",   "102",  "30",   "MKK",
+	"5G",   "40M",  "HT",   "1T",   "102",  "30",   "FCC",  "5G",   "40M",
+	"HT",   "1T",   "110",  "30",   "ETSI", "5G",   "40M",  "HT",   "1T",
+	"110",  "30",   "MKK",  "5G",   "40M",  "HT",   "1T",   "110",  "30",
+	"FCC",  "5G",   "40M",  "HT",   "1T",   "118",  "30",   "ETSI", "5G",
+	"40M",  "HT",   "1T",   "118",  "30",   "MKK",  "5G",   "40M",  "HT",
+	"1T",   "118",  "30",   "FCC",  "5G",   "40M",  "HT",   "1T",   "126",
+	"30",   "ETSI", "5G",   "40M",  "HT",   "1T",   "126",  "30",   "MKK",
+	"5G",   "40M",  "HT",   "1T",   "126",  "30",   "FCC",  "5G",   "40M",
+	"HT",   "1T",   "134",  "30",   "ETSI", "5G",   "40M",  "HT",   "1T",
+	"134",  "30",   "MKK",  "5G",   "40M",  "HT",   "1T",   "134",  "30",
+	"FCC",  "5G",   "40M",  "HT",   "1T",   "142",  "30",   "ETSI", "5G",
+	"40M",  "HT",   "1T",   "142",  "63",   "MKK",  "5G",   "40M",  "HT",
+	"1T",   "142",  "63",   "FCC",  "5G",   "40M",  "HT",   "1T",   "151",
+	"30",   "ETSI", "5G",   "40M",  "HT",   "1T",   "151",  "63",   "MKK",
+	"5G",   "40M",  "HT",   "1T",   "151",  "63",   "FCC",  "5G",   "40M",
+	"HT",   "1T",   "159",  "30",   "ETSI", "5G",   "40M",  "HT",   "1T",
+	"159",  "63",   "MKK",  "5G",   "40M",  "HT",   "1T",   "159",  "63",
+	"FCC",  "5G",   "40M",  "HT",   "2T",   "38",   "20",   "ETSI", "5G",
+	"40M",  "HT",   "2T",   "38",   "20",   "MKK",  "5G",   "40M",  "HT",
+	"2T",   "38",   "22",   "FCC",  "5G",   "40M",  "HT",   "2T",   "46",
+	"30",   "ETSI", "5G",   "40M",  "HT",   "2T",   "46",   "20",   "MKK",
+	"5G",   "40M",  "HT",   "2T",   "46",   "22",   "FCC",  "5G",   "40M",
+	"HT",   "2T",   "54",   "30",   "ETSI", "5G",   "40M",  "HT",   "2T",
+	"54",   "20",   "MKK",  "5G",   "40M",  "HT",   "2T",   "54",   "22",
+	"FCC",  "5G",   "40M",  "HT",   "2T",   "62",   "22",   "ETSI", "5G",
+	"40M",  "HT",   "2T",   "62",   "20",   "MKK",  "5G",   "40M",  "HT",
+	"2T",   "62",   "22",   "FCC",  "5G",   "40M",  "HT",   "2T",   "102",
+	"22",   "ETSI", "5G",   "40M",  "HT",   "2T",   "102",  "20",   "MKK",
+	"5G",   "40M",  "HT",   "2T",   "102",  "30",   "FCC",  "5G",   "40M",
+	"HT",   "2T",   "110",  "30",   "ETSI", "5G",   "40M",  "HT",   "2T",
+	"110",  "20",   "MKK",  "5G",   "40M",  "HT",   "2T",   "110",  "30",
+	"FCC",  "5G",   "40M",  "HT",   "2T",   "118",  "30",   "ETSI", "5G",
+	"40M",  "HT",   "2T",   "118",  "20",   "MKK",  "5G",   "40M",  "HT",
+	"2T",   "118",  "30",   "FCC",  "5G",   "40M",  "HT",   "2T",   "126",
+	"30",   "ETSI", "5G",   "40M",  "HT",   "2T",   "126",  "20",   "MKK",
+	"5G",   "40M",  "HT",   "2T",   "126",  "30",   "FCC",  "5G",   "40M",
+	"HT",   "2T",   "134",  "30",   "ETSI", "5G",   "40M",  "HT",   "2T",
+	"134",  "20",   "MKK",  "5G",   "40M",  "HT",   "2T",   "134",  "30",
+	"FCC",  "5G",   "40M",  "HT",   "2T",   "142",  "30",   "ETSI", "5G",
+	"40M",  "HT",   "2T",   "142",  "63",   "MKK",  "5G",   "40M",  "HT",
+	"2T",   "142",  "63",   "FCC",  "5G",   "40M",  "HT",   "2T",   "151",
+	"30",   "ETSI", "5G",   "40M",  "HT",   "2T",   "151",  "63",   "MKK",
+	"5G",   "40M",  "HT",   "2T",   "151",  "63",   "FCC",  "5G",   "40M",
+	"HT",   "2T",   "159",  "30",   "ETSI", "5G",   "40M",  "HT",   "2T",
+	"159",  "63",   "MKK",  "5G",   "40M",  "HT",   "2T",   "159",  "63",
+	"FCC",  "5G",   "80M",  "VHT",  "1T",   "42",   "20",   "ETSI", "5G",
+	"80M",  "VHT",  "1T",   "42",   "30",   "MKK",  "5G",   "80M",  "VHT",
+	"1T",   "42",   "28",   "FCC",  "5G",   "80M",  "VHT",  "1T",   "58",
+	"20",   "ETSI", "5G",   "80M",  "VHT",  "1T",   "58",   "30",   "MKK",
+	"5G",   "80M",  "VHT",  "1T",   "58",   "28",   "FCC",  "5G",   "80M",
+	"VHT",  "1T",   "106",  "20",   "ETSI", "5G",   "80M",  "VHT",  "1T",
+	"106",  "30",   "MKK",  "5G",   "80M",  "VHT",  "1T",   "106",  "30",
+	"FCC",  "5G",   "80M",  "VHT",  "1T",   "122",  "30",   "ETSI", "5G",
+	"80M",  "VHT",  "1T",   "122",  "30",   "MKK",  "5G",   "80M",  "VHT",
+	"1T",   "122",  "30",   "FCC",  "5G",   "80M",  "VHT",  "1T",   "138",
+	"30",   "ETSI", "5G",   "80M",  "VHT",  "1T",   "138",  "63",   "MKK",
+	"5G",   "80M",  "VHT",  "1T",   "138",  "63",   "FCC",  "5G",   "80M",
+	"VHT",  "1T",   "155",  "30",   "ETSI", "5G",   "80M",  "VHT",  "1T",
+	"155",  "63",   "MKK",  "5G",   "80M",  "VHT",  "1T",   "155",  "63",
+	"FCC",  "5G",   "80M",  "VHT",  "2T",   "42",   "18",   "ETSI", "5G",
+	"80M",  "VHT",  "2T",   "42",   "20",   "MKK",  "5G",   "80M",  "VHT",
+	"2T",   "42",   "22",   "FCC",  "5G",   "80M",  "VHT",  "2T",   "58",
+	"18",   "ETSI", "5G",   "80M",  "VHT",  "2T",   "58",   "20",   "MKK",
+	"5G",   "80M",  "VHT",  "2T",   "58",   "22",   "FCC",  "5G",   "80M",
+	"VHT",  "2T",   "106",  "20",   "ETSI", "5G",   "80M",  "VHT",  "2T",
+	"106",  "20",   "MKK",  "5G",   "80M",  "VHT",  "2T",   "106",  "30",
+	"FCC",  "5G",   "80M",  "VHT",  "2T",   "122",  "30",   "ETSI", "5G",
+	"80M",  "VHT",  "2T",   "122",  "20",   "MKK",  "5G",   "80M",  "VHT",
+	"2T",   "122",  "30",   "FCC",  "5G",   "80M",  "VHT",  "2T",   "138",
+	"30",   "ETSI", "5G",   "80M",  "VHT",  "2T",   "138",  "63",   "MKK",
+	"5G",   "80M",  "VHT",  "2T",   "138",  "63",   "FCC",  "5G",   "80M",
+	"VHT",  "2T",   "155",  "30",   "ETSI", "5G",   "80M",  "VHT",  "2T",
+	"155",  "63",   "MKK",  "5G",   "80M",  "VHT",  "2T",   "155",  "63"};
+
+void odm_read_and_config_mp_8822b_txpwr_lmt(struct phy_dm_struct *dm)
+{
+	u32 i = 0;
+	u32 array_len = sizeof(array_mp_8822b_txpwr_lmt) / sizeof(u8 *);
+	u8 **array = (u8 **)array_mp_8822b_txpwr_lmt;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "===> %s\n", __func__);
+
+	for (i = 0; i < array_len; i += 7) {
+		u8 *regulation = array[i];
+		u8 *band = array[i + 1];
+		u8 *bandwidth = array[i + 2];
+		u8 *rate = array[i + 3];
+		u8 *rf_path = array[i + 4];
+		u8 *chnl = array[i + 5];
+		u8 *val = array[i + 6];
+
+		odm_config_bb_txpwr_lmt_8822b(dm, regulation, band, bandwidth,
+					      rate, rf_path, chnl, val);
+	}
+}
+
+/******************************************************************************
+*                           txpwr_lmt_type5.TXT
+******************************************************************************/
+
+static const char *const array_mp_8822b_txpwr_lmt_type5[] = {
+	"FCC",  "2.4G", "20M",  "CCK",  "1T",   "01",   "32",   "ETSI", "2.4G",
+	"20M",  "CCK",  "1T",   "01",   "28",   "MKK",  "2.4G", "20M",  "CCK",
+	"1T",   "01",   "30",   "FCC",  "2.4G", "20M",  "CCK",  "1T",   "02",
+	"32",   "ETSI", "2.4G", "20M",  "CCK",  "1T",   "02",   "28",   "MKK",
+	"2.4G", "20M",  "CCK",  "1T",   "02",   "30",   "FCC",  "2.4G", "20M",
+	"CCK",  "1T",   "03",   "32",   "ETSI", "2.4G", "20M",  "CCK",  "1T",
+	"03",   "28",   "MKK",  "2.4G", "20M",  "CCK",  "1T",   "03",   "30",
+	"FCC",  "2.4G", "20M",  "CCK",  "1T",   "04",   "32",   "ETSI", "2.4G",
+	"20M",  "CCK",  "1T",   "04",   "28",   "MKK",  "2.4G", "20M",  "CCK",
+	"1T",   "04",   "30",   "FCC",  "2.4G", "20M",  "CCK",  "1T",   "05",
+	"32",   "ETSI", "2.4G", "20M",  "CCK",  "1T",   "05",   "28",   "MKK",
+	"2.4G", "20M",  "CCK",  "1T",   "05",   "30",   "FCC",  "2.4G", "20M",
+	"CCK",  "1T",   "06",   "32",   "ETSI", "2.4G", "20M",  "CCK",  "1T",
+	"06",   "28",   "MKK",  "2.4G", "20M",  "CCK",  "1T",   "06",   "30",
+	"FCC",  "2.4G", "20M",  "CCK",  "1T",   "07",   "32",   "ETSI", "2.4G",
+	"20M",  "CCK",  "1T",   "07",   "28",   "MKK",  "2.4G", "20M",  "CCK",
+	"1T",   "07",   "30",   "FCC",  "2.4G", "20M",  "CCK",  "1T",   "08",
+	"32",   "ETSI", "2.4G", "20M",  "CCK",  "1T",   "08",   "28",   "MKK",
+	"2.4G", "20M",  "CCK",  "1T",   "08",   "30",   "FCC",  "2.4G", "20M",
+	"CCK",  "1T",   "09",   "32",   "ETSI", "2.4G", "20M",  "CCK",  "1T",
+	"09",   "28",   "MKK",  "2.4G", "20M",  "CCK",  "1T",   "09",   "30",
+	"FCC",  "2.4G", "20M",  "CCK",  "1T",   "10",   "32",   "ETSI", "2.4G",
+	"20M",  "CCK",  "1T",   "10",   "28",   "MKK",  "2.4G", "20M",  "CCK",
+	"1T",   "10",   "30",   "FCC",  "2.4G", "20M",  "CCK",  "1T",   "11",
+	"32",   "ETSI", "2.4G", "20M",  "CCK",  "1T",   "11",   "28",   "MKK",
+	"2.4G", "20M",  "CCK",  "1T",   "11",   "30",   "FCC",  "2.4G", "20M",
+	"CCK",  "1T",   "12",   "26",   "ETSI", "2.4G", "20M",  "CCK",  "1T",
+	"12",   "28",   "MKK",  "2.4G", "20M",  "CCK",  "1T",   "12",   "30",
+	"FCC",  "2.4G", "20M",  "CCK",  "1T",   "13",   "20",   "ETSI", "2.4G",
+	"20M",  "CCK",  "1T",   "13",   "28",   "MKK",  "2.4G", "20M",  "CCK",
+	"1T",   "13",   "28",   "FCC",  "2.4G", "20M",  "CCK",  "1T",   "14",
+	"63",   "ETSI", "2.4G", "20M",  "CCK",  "1T",   "14",   "63",   "MKK",
+	"2.4G", "20M",  "CCK",  "1T",   "14",   "32",   "FCC",  "2.4G", "20M",
+	"OFDM", "1T",   "01",   "26",   "ETSI", "2.4G", "20M",  "OFDM", "1T",
+	"01",   "30",   "MKK",  "2.4G", "20M",  "OFDM", "1T",   "01",   "34",
+	"FCC",  "2.4G", "20M",  "OFDM", "1T",   "02",   "30",   "ETSI", "2.4G",
+	"20M",  "OFDM", "1T",   "02",   "30",   "MKK",  "2.4G", "20M",  "OFDM",
+	"1T",   "02",   "34",   "FCC",  "2.4G", "20M",  "OFDM", "1T",   "03",
+	"32",   "ETSI", "2.4G", "20M",  "OFDM", "1T",   "03",   "30",   "MKK",
+	"2.4G", "20M",  "OFDM", "1T",   "03",   "34",   "FCC",  "2.4G", "20M",
+	"OFDM", "1T",   "04",   "34",   "ETSI", "2.4G", "20M",  "OFDM", "1T",
+	"04",   "30",   "MKK",  "2.4G", "20M",  "OFDM", "1T",   "04",   "34",
+	"FCC",  "2.4G", "20M",  "OFDM", "1T",   "05",   "34",   "ETSI", "2.4G",
+	"20M",  "OFDM", "1T",   "05",   "30",   "MKK",  "2.4G", "20M",  "OFDM",
+	"1T",   "05",   "34",   "FCC",  "2.4G", "20M",  "OFDM", "1T",   "06",
+	"34",   "ETSI", "2.4G", "20M",  "OFDM", "1T",   "06",   "30",   "MKK",
+	"2.4G", "20M",  "OFDM", "1T",   "06",   "34",   "FCC",  "2.4G", "20M",
+	"OFDM", "1T",   "07",   "34",   "ETSI", "2.4G", "20M",  "OFDM", "1T",
+	"07",   "30",   "MKK",  "2.4G", "20M",  "OFDM", "1T",   "07",   "34",
+	"FCC",  "2.4G", "20M",  "OFDM", "1T",   "08",   "34",   "ETSI", "2.4G",
+	"20M",  "OFDM", "1T",   "08",   "30",   "MKK",  "2.4G", "20M",  "OFDM",
+	"1T",   "08",   "34",   "FCC",  "2.4G", "20M",  "OFDM", "1T",   "09",
+	"32",   "ETSI", "2.4G", "20M",  "OFDM", "1T",   "09",   "30",   "MKK",
+	"2.4G", "20M",  "OFDM", "1T",   "09",   "34",   "FCC",  "2.4G", "20M",
+	"OFDM", "1T",   "10",   "30",   "ETSI", "2.4G", "20M",  "OFDM", "1T",
+	"10",   "30",   "MKK",  "2.4G", "20M",  "OFDM", "1T",   "10",   "34",
+	"FCC",  "2.4G", "20M",  "OFDM", "1T",   "11",   "28",   "ETSI", "2.4G",
+	"20M",  "OFDM", "1T",   "11",   "30",   "MKK",  "2.4G", "20M",  "OFDM",
+	"1T",   "11",   "34",   "FCC",  "2.4G", "20M",  "OFDM", "1T",   "12",
+	"22",   "ETSI", "2.4G", "20M",  "OFDM", "1T",   "12",   "30",   "MKK",
+	"2.4G", "20M",  "OFDM", "1T",   "12",   "34",   "FCC",  "2.4G", "20M",
+	"OFDM", "1T",   "13",   "14",   "ETSI", "2.4G", "20M",  "OFDM", "1T",
+	"13",   "30",   "MKK",  "2.4G", "20M",  "OFDM", "1T",   "13",   "34",
+	"FCC",  "2.4G", "20M",  "OFDM", "1T",   "14",   "63",   "ETSI", "2.4G",
+	"20M",  "OFDM", "1T",   "14",   "63",   "MKK",  "2.4G", "20M",  "OFDM",
+	"1T",   "14",   "63",   "FCC",  "2.4G", "20M",  "HT",   "1T",   "01",
+	"26",   "ETSI", "2.4G", "20M",  "HT",   "1T",   "01",   "30",   "MKK",
+	"2.4G", "20M",  "HT",   "1T",   "01",   "34",   "FCC",  "2.4G", "20M",
+	"HT",   "1T",   "02",   "30",   "ETSI", "2.4G", "20M",  "HT",   "1T",
+	"02",   "30",   "MKK",  "2.4G", "20M",  "HT",   "1T",   "02",   "34",
+	"FCC",  "2.4G", "20M",  "HT",   "1T",   "03",   "32",   "ETSI", "2.4G",
+	"20M",  "HT",   "1T",   "03",   "30",   "MKK",  "2.4G", "20M",  "HT",
+	"1T",   "03",   "34",   "FCC",  "2.4G", "20M",  "HT",   "1T",   "04",
+	"34",   "ETSI", "2.4G", "20M",  "HT",   "1T",   "04",   "30",   "MKK",
+	"2.4G", "20M",  "HT",   "1T",   "04",   "34",   "FCC",  "2.4G", "20M",
+	"HT",   "1T",   "05",   "34",   "ETSI", "2.4G", "20M",  "HT",   "1T",
+	"05",   "30",   "MKK",  "2.4G", "20M",  "HT",   "1T",   "05",   "34",
+	"FCC",  "2.4G", "20M",  "HT",   "1T",   "06",   "34",   "ETSI", "2.4G",
+	"20M",  "HT",   "1T",   "06",   "30",   "MKK",  "2.4G", "20M",  "HT",
+	"1T",   "06",   "34",   "FCC",  "2.4G", "20M",  "HT",   "1T",   "07",
+	"34",   "ETSI", "2.4G", "20M",  "HT",   "1T",   "07",   "30",   "MKK",
+	"2.4G", "20M",  "HT",   "1T",   "07",   "34",   "FCC",  "2.4G", "20M",
+	"HT",   "1T",   "08",   "34",   "ETSI", "2.4G", "20M",  "HT",   "1T",
+	"08",   "30",   "MKK",  "2.4G", "20M",  "HT",   "1T",   "08",   "34",
+	"FCC",  "2.4G", "20M",  "HT",   "1T",   "09",   "32",   "ETSI", "2.4G",
+	"20M",  "HT",   "1T",   "09",   "30",   "MKK",  "2.4G", "20M",  "HT",
+	"1T",   "09",   "34",   "FCC",  "2.4G", "20M",  "HT",   "1T",   "10",
+	"30",   "ETSI", "2.4G", "20M",  "HT",   "1T",   "10",   "30",   "MKK",
+	"2.4G", "20M",  "HT",   "1T",   "10",   "34",   "FCC",  "2.4G", "20M",
+	"HT",   "1T",   "11",   "26",   "ETSI", "2.4G", "20M",  "HT",   "1T",
+	"11",   "30",   "MKK",  "2.4G", "20M",  "HT",   "1T",   "11",   "34",
+	"FCC",  "2.4G", "20M",  "HT",   "1T",   "12",   "20",   "ETSI", "2.4G",
+	"20M",  "HT",   "1T",   "12",   "30",   "MKK",  "2.4G", "20M",  "HT",
+	"1T",   "12",   "34",   "FCC",  "2.4G", "20M",  "HT",   "1T",   "13",
+	"14",   "ETSI", "2.4G", "20M",  "HT",   "1T",   "13",   "30",   "MKK",
+	"2.4G", "20M",  "HT",   "1T",   "13",   "34",   "FCC",  "2.4G", "20M",
+	"HT",   "1T",   "14",   "63",   "ETSI", "2.4G", "20M",  "HT",   "1T",
+	"14",   "63",   "MKK",  "2.4G", "20M",  "HT",   "1T",   "14",   "63",
+	"FCC",  "2.4G", "20M",  "HT",   "2T",   "01",   "26",   "ETSI", "2.4G",
+	"20M",  "HT",   "2T",   "01",   "18",   "MKK",  "2.4G", "20M",  "HT",
+	"2T",   "01",   "30",   "FCC",  "2.4G", "20M",  "HT",   "2T",   "02",
+	"28",   "ETSI", "2.4G", "20M",  "HT",   "2T",   "02",   "18",   "MKK",
+	"2.4G", "20M",  "HT",   "2T",   "02",   "30",   "FCC",  "2.4G", "20M",
+	"HT",   "2T",   "03",   "30",   "ETSI", "2.4G", "20M",  "HT",   "2T",
+	"03",   "18",   "MKK",  "2.4G", "20M",  "HT",   "2T",   "03",   "30",
+	"FCC",  "2.4G", "20M",  "HT",   "2T",   "04",   "30",   "ETSI", "2.4G",
+	"20M",  "HT",   "2T",   "04",   "18",   "MKK",  "2.4G", "20M",  "HT",
+	"2T",   "04",   "30",   "FCC",  "2.4G", "20M",  "HT",   "2T",   "05",
+	"32",   "ETSI", "2.4G", "20M",  "HT",   "2T",   "05",   "18",   "MKK",
+	"2.4G", "20M",  "HT",   "2T",   "05",   "30",   "FCC",  "2.4G", "20M",
+	"HT",   "2T",   "06",   "32",   "ETSI", "2.4G", "20M",  "HT",   "2T",
+	"06",   "18",   "MKK",  "2.4G", "20M",  "HT",   "2T",   "06",   "30",
+	"FCC",  "2.4G", "20M",  "HT",   "2T",   "07",   "32",   "ETSI", "2.4G",
+	"20M",  "HT",   "2T",   "07",   "18",   "MKK",  "2.4G", "20M",  "HT",
+	"2T",   "07",   "30",   "FCC",  "2.4G", "20M",  "HT",   "2T",   "08",
+	"30",   "ETSI", "2.4G", "20M",  "HT",   "2T",   "08",   "18",   "MKK",
+	"2.4G", "20M",  "HT",   "2T",   "08",   "30",   "FCC",  "2.4G", "20M",
+	"HT",   "2T",   "09",   "30",   "ETSI", "2.4G", "20M",  "HT",   "2T",
+	"09",   "18",   "MKK",  "2.4G", "20M",  "HT",   "2T",   "09",   "30",
+	"FCC",  "2.4G", "20M",  "HT",   "2T",   "10",   "28",   "ETSI", "2.4G",
+	"20M",  "HT",   "2T",   "10",   "18",   "MKK",  "2.4G", "20M",  "HT",
+	"2T",   "10",   "30",   "FCC",  "2.4G", "20M",  "HT",   "2T",   "11",
+	"26",   "ETSI", "2.4G", "20M",  "HT",   "2T",   "11",   "18",   "MKK",
+	"2.4G", "20M",  "HT",   "2T",   "11",   "30",   "FCC",  "2.4G", "20M",
+	"HT",   "2T",   "12",   "20",   "ETSI", "2.4G", "20M",  "HT",   "2T",
+	"12",   "18",   "MKK",  "2.4G", "20M",  "HT",   "2T",   "12",   "30",
+	"FCC",  "2.4G", "20M",  "HT",   "2T",   "13",   "14",   "ETSI", "2.4G",
+	"20M",  "HT",   "2T",   "13",   "18",   "MKK",  "2.4G", "20M",  "HT",
+	"2T",   "13",   "30",   "FCC",  "2.4G", "20M",  "HT",   "2T",   "14",
+	"63",   "ETSI", "2.4G", "20M",  "HT",   "2T",   "14",   "63",   "MKK",
+	"2.4G", "20M",  "HT",   "2T",   "14",   "63",   "FCC",  "2.4G", "40M",
+	"HT",   "1T",   "01",   "63",   "ETSI", "2.4G", "40M",  "HT",   "1T",
+	"01",   "63",   "MKK",  "2.4G", "40M",  "HT",   "1T",   "01",   "63",
+	"FCC",  "2.4G", "40M",  "HT",   "1T",   "02",   "63",   "ETSI", "2.4G",
+	"40M",  "HT",   "1T",   "02",   "63",   "MKK",  "2.4G", "40M",  "HT",
+	"1T",   "02",   "63",   "FCC",  "2.4G", "40M",  "HT",   "1T",   "03",
+	"26",   "ETSI", "2.4G", "40M",  "HT",   "1T",   "03",   "30",   "MKK",
+	"2.4G", "40M",  "HT",   "1T",   "03",   "34",   "FCC",  "2.4G", "40M",
+	"HT",   "1T",   "04",   "26",   "ETSI", "2.4G", "40M",  "HT",   "1T",
+	"04",   "30",   "MKK",  "2.4G", "40M",  "HT",   "1T",   "04",   "34",
+	"FCC",  "2.4G", "40M",  "HT",   "1T",   "05",   "30",   "ETSI", "2.4G",
+	"40M",  "HT",   "1T",   "05",   "30",   "MKK",  "2.4G", "40M",  "HT",
+	"1T",   "05",   "34",   "FCC",  "2.4G", "40M",  "HT",   "1T",   "06",
+	"32",   "ETSI", "2.4G", "40M",  "HT",   "1T",   "06",   "30",   "MKK",
+	"2.4G", "40M",  "HT",   "1T",   "06",   "34",   "FCC",  "2.4G", "40M",
+	"HT",   "1T",   "07",   "30",   "ETSI", "2.4G", "40M",  "HT",   "1T",
+	"07",   "30",   "MKK",  "2.4G", "40M",  "HT",   "1T",   "07",   "34",
+	"FCC",  "2.4G", "40M",  "HT",   "1T",   "08",   "26",   "ETSI", "2.4G",
+	"40M",  "HT",   "1T",   "08",   "30",   "MKK",  "2.4G", "40M",  "HT",
+	"1T",   "08",   "34",   "FCC",  "2.4G", "40M",  "HT",   "1T",   "09",
+	"26",   "ETSI", "2.4G", "40M",  "HT",   "1T",   "09",   "30",   "MKK",
+	"2.4G", "40M",  "HT",   "1T",   "09",   "34",   "FCC",  "2.4G", "40M",
+	"HT",   "1T",   "10",   "20",   "ETSI", "2.4G", "40M",  "HT",   "1T",
+	"10",   "30",   "MKK",  "2.4G", "40M",  "HT",   "1T",   "10",   "34",
+	"FCC",  "2.4G", "40M",  "HT",   "1T",   "11",   "14",   "ETSI", "2.4G",
+	"40M",  "HT",   "1T",   "11",   "30",   "MKK",  "2.4G", "40M",  "HT",
+	"1T",   "11",   "34",   "FCC",  "2.4G", "40M",  "HT",   "1T",   "12",
+	"63",   "ETSI", "2.4G", "40M",  "HT",   "1T",   "12",   "63",   "MKK",
+	"2.4G", "40M",  "HT",   "1T",   "12",   "63",   "FCC",  "2.4G", "40M",
+	"HT",   "1T",   "13",   "63",   "ETSI", "2.4G", "40M",  "HT",   "1T",
+	"13",   "63",   "MKK",  "2.4G", "40M",  "HT",   "1T",   "13",   "63",
+	"FCC",  "2.4G", "40M",  "HT",   "1T",   "14",   "63",   "ETSI", "2.4G",
+	"40M",  "HT",   "1T",   "14",   "63",   "MKK",  "2.4G", "40M",  "HT",
+	"1T",   "14",   "63",   "FCC",  "2.4G", "40M",  "HT",   "2T",   "01",
+	"63",   "ETSI", "2.4G", "40M",  "HT",   "2T",   "01",   "63",   "MKK",
+	"2.4G", "40M",  "HT",   "2T",   "01",   "63",   "FCC",  "2.4G", "40M",
+	"HT",   "2T",   "02",   "63",   "ETSI", "2.4G", "40M",  "HT",   "2T",
+	"02",   "63",   "MKK",  "2.4G", "40M",  "HT",   "2T",   "02",   "63",
+	"FCC",  "2.4G", "40M",  "HT",   "2T",   "03",   "24",   "ETSI", "2.4G",
+	"40M",  "HT",   "2T",   "03",   "18",   "MKK",  "2.4G", "40M",  "HT",
+	"2T",   "03",   "30",   "FCC",  "2.4G", "40M",  "HT",   "2T",   "04",
+	"24",   "ETSI", "2.4G", "40M",  "HT",   "2T",   "04",   "18",   "MKK",
+	"2.4G", "40M",  "HT",   "2T",   "04",   "30",   "FCC",  "2.4G", "40M",
+	"HT",   "2T",   "05",   "26",   "ETSI", "2.4G", "40M",  "HT",   "2T",
+	"05",   "18",   "MKK",  "2.4G", "40M",  "HT",   "2T",   "05",   "30",
+	"FCC",  "2.4G", "40M",  "HT",   "2T",   "06",   "28",   "ETSI", "2.4G",
+	"40M",  "HT",   "2T",   "06",   "18",   "MKK",  "2.4G", "40M",  "HT",
+	"2T",   "06",   "30",   "FCC",  "2.4G", "40M",  "HT",   "2T",   "07",
+	"26",   "ETSI", "2.4G", "40M",  "HT",   "2T",   "07",   "18",   "MKK",
+	"2.4G", "40M",  "HT",   "2T",   "07",   "30",   "FCC",  "2.4G", "40M",
+	"HT",   "2T",   "08",   "26",   "ETSI", "2.4G", "40M",  "HT",   "2T",
+	"08",   "18",   "MKK",  "2.4G", "40M",  "HT",   "2T",   "08",   "30",
+	"FCC",  "2.4G", "40M",  "HT",   "2T",   "09",   "26",   "ETSI", "2.4G",
+	"40M",  "HT",   "2T",   "09",   "18",   "MKK",  "2.4G", "40M",  "HT",
+	"2T",   "09",   "30",   "FCC",  "2.4G", "40M",  "HT",   "2T",   "10",
+	"20",   "ETSI", "2.4G", "40M",  "HT",   "2T",   "10",   "18",   "MKK",
+	"2.4G", "40M",  "HT",   "2T",   "10",   "30",   "FCC",  "2.4G", "40M",
+	"HT",   "2T",   "11",   "14",   "ETSI", "2.4G", "40M",  "HT",   "2T",
+	"11",   "18",   "MKK",  "2.4G", "40M",  "HT",   "2T",   "11",   "30",
+	"FCC",  "2.4G", "40M",  "HT",   "2T",   "12",   "63",   "ETSI", "2.4G",
+	"40M",  "HT",   "2T",   "12",   "63",   "MKK",  "2.4G", "40M",  "HT",
+	"2T",   "12",   "63",   "FCC",  "2.4G", "40M",  "HT",   "2T",   "13",
+	"63",   "ETSI", "2.4G", "40M",  "HT",   "2T",   "13",   "63",   "MKK",
+	"2.4G", "40M",  "HT",   "2T",   "13",   "63",   "FCC",  "2.4G", "40M",
+	"HT",   "2T",   "14",   "63",   "ETSI", "2.4G", "40M",  "HT",   "2T",
+	"14",   "63",   "MKK",  "2.4G", "40M",  "HT",   "2T",   "14",   "63",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "36",   "30",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "36",   "32",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "36",   "30",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "40",
+	"32",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "40",   "32",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "40",   "30",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "44",   "32",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"44",   "32",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "44",   "30",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "48",   "32",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "48",   "32",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "48",   "30",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "52",
+	"32",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "52",   "32",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "52",   "28",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "56",   "32",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"56",   "32",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "56",   "28",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "60",   "32",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "60",   "32",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "60",   "28",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "64",
+	"28",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "64",   "32",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "64",   "28",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "100",  "26",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"100",  "32",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "100",  "32",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "104",  "32",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "104",  "32",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "104",  "32",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "108",
+	"32",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "108",  "32",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "108",  "32",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "112",  "32",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"112",  "32",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "112",  "32",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "116",  "32",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "116",  "32",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "116",  "32",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "120",
+	"32",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "120",  "32",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "120",  "32",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "124",  "32",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"124",  "32",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "124",  "32",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "128",  "32",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "128",  "32",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "128",  "32",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "132",
+	"32",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "132",  "32",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "132",  "32",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "136",  "32",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"136",  "32",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "136",  "32",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "140",  "28",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "140",  "32",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "140",  "32",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "144",
+	"28",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "144",  "32",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "144",  "63",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "149",  "32",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"149",  "63",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "149",  "63",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "153",  "32",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "153",  "63",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "153",  "63",   "FCC",  "5G",   "20M",  "OFDM", "1T",   "157",
+	"32",   "ETSI", "5G",   "20M",  "OFDM", "1T",   "157",  "63",   "MKK",
+	"5G",   "20M",  "OFDM", "1T",   "157",  "63",   "FCC",  "5G",   "20M",
+	"OFDM", "1T",   "161",  "32",   "ETSI", "5G",   "20M",  "OFDM", "1T",
+	"161",  "63",   "MKK",  "5G",   "20M",  "OFDM", "1T",   "161",  "63",
+	"FCC",  "5G",   "20M",  "OFDM", "1T",   "165",  "32",   "ETSI", "5G",
+	"20M",  "OFDM", "1T",   "165",  "63",   "MKK",  "5G",   "20M",  "OFDM",
+	"1T",   "165",  "63",   "FCC",  "5G",   "20M",  "HT",   "1T",   "36",
+	"30",   "ETSI", "5G",   "20M",  "HT",   "1T",   "36",   "32",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "36",   "28",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "40",   "32",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"40",   "32",   "MKK",  "5G",   "20M",  "HT",   "1T",   "40",   "28",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "44",   "32",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "44",   "32",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "44",   "28",   "FCC",  "5G",   "20M",  "HT",   "1T",   "48",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "1T",   "48",   "32",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "48",   "28",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "52",   "32",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"52",   "32",   "MKK",  "5G",   "20M",  "HT",   "1T",   "52",   "28",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "56",   "32",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "56",   "32",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "56",   "28",   "FCC",  "5G",   "20M",  "HT",   "1T",   "60",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "1T",   "60",   "32",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "60",   "28",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "64",   "28",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"64",   "32",   "MKK",  "5G",   "20M",  "HT",   "1T",   "64",   "28",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "100",  "26",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "100",  "32",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "100",  "32",   "FCC",  "5G",   "20M",  "HT",   "1T",   "104",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "1T",   "104",  "32",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "104",  "32",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "108",  "32",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"108",  "32",   "MKK",  "5G",   "20M",  "HT",   "1T",   "108",  "32",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "112",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "112",  "32",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "112",  "32",   "FCC",  "5G",   "20M",  "HT",   "1T",   "116",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "1T",   "116",  "32",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "116",  "32",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "120",  "32",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"120",  "32",   "MKK",  "5G",   "20M",  "HT",   "1T",   "120",  "32",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "124",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "124",  "32",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "124",  "32",   "FCC",  "5G",   "20M",  "HT",   "1T",   "128",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "1T",   "128",  "32",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "128",  "32",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "132",  "32",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"132",  "32",   "MKK",  "5G",   "20M",  "HT",   "1T",   "132",  "32",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "136",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "136",  "32",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "136",  "32",   "FCC",  "5G",   "20M",  "HT",   "1T",   "140",
+	"26",   "ETSI", "5G",   "20M",  "HT",   "1T",   "140",  "32",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "140",  "32",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "144",  "26",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"144",  "63",   "MKK",  "5G",   "20M",  "HT",   "1T",   "144",  "63",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "149",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "149",  "63",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "149",  "63",   "FCC",  "5G",   "20M",  "HT",   "1T",   "153",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "1T",   "153",  "63",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "153",  "63",   "FCC",  "5G",   "20M",
+	"HT",   "1T",   "157",  "32",   "ETSI", "5G",   "20M",  "HT",   "1T",
+	"157",  "63",   "MKK",  "5G",   "20M",  "HT",   "1T",   "157",  "63",
+	"FCC",  "5G",   "20M",  "HT",   "1T",   "161",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "1T",   "161",  "63",   "MKK",  "5G",   "20M",  "HT",
+	"1T",   "161",  "63",   "FCC",  "5G",   "20M",  "HT",   "1T",   "165",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "1T",   "165",  "63",   "MKK",
+	"5G",   "20M",  "HT",   "1T",   "165",  "63",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "36",   "28",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"36",   "20",   "MKK",  "5G",   "20M",  "HT",   "2T",   "36",   "22",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "40",   "30",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "40",   "20",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "40",   "22",   "FCC",  "5G",   "20M",  "HT",   "2T",   "44",
+	"30",   "ETSI", "5G",   "20M",  "HT",   "2T",   "44",   "20",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "44",   "22",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "48",   "30",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"48",   "20",   "MKK",  "5G",   "20M",  "HT",   "2T",   "48",   "22",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "52",   "30",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "52",   "20",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "52",   "22",   "FCC",  "5G",   "20M",  "HT",   "2T",   "56",
+	"30",   "ETSI", "5G",   "20M",  "HT",   "2T",   "56",   "20",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "56",   "22",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "60",   "30",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"60",   "20",   "MKK",  "5G",   "20M",  "HT",   "2T",   "60",   "22",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "64",   "28",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "64",   "20",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "64",   "22",   "FCC",  "5G",   "20M",  "HT",   "2T",   "100",
+	"26",   "ETSI", "5G",   "20M",  "HT",   "2T",   "100",  "20",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "100",  "30",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "104",  "30",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"104",  "20",   "MKK",  "5G",   "20M",  "HT",   "2T",   "104",  "30",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "108",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "108",  "20",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "108",  "30",   "FCC",  "5G",   "20M",  "HT",   "2T",   "112",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "2T",   "112",  "20",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "112",  "30",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "116",  "32",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"116",  "20",   "MKK",  "5G",   "20M",  "HT",   "2T",   "116",  "30",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "120",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "120",  "20",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "120",  "30",   "FCC",  "5G",   "20M",  "HT",   "2T",   "124",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "2T",   "124",  "20",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "124",  "30",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "128",  "32",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"128",  "20",   "MKK",  "5G",   "20M",  "HT",   "2T",   "128",  "30",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "132",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "132",  "20",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "132",  "30",   "FCC",  "5G",   "20M",  "HT",   "2T",   "136",
+	"30",   "ETSI", "5G",   "20M",  "HT",   "2T",   "136",  "20",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "136",  "30",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "140",  "26",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"140",  "20",   "MKK",  "5G",   "20M",  "HT",   "2T",   "140",  "30",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "144",  "26",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "144",  "63",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "144",  "63",   "FCC",  "5G",   "20M",  "HT",   "2T",   "149",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "2T",   "149",  "63",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "149",  "63",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "153",  "32",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"153",  "63",   "MKK",  "5G",   "20M",  "HT",   "2T",   "153",  "63",
+	"FCC",  "5G",   "20M",  "HT",   "2T",   "157",  "32",   "ETSI", "5G",
+	"20M",  "HT",   "2T",   "157",  "63",   "MKK",  "5G",   "20M",  "HT",
+	"2T",   "157",  "63",   "FCC",  "5G",   "20M",  "HT",   "2T",   "161",
+	"32",   "ETSI", "5G",   "20M",  "HT",   "2T",   "161",  "63",   "MKK",
+	"5G",   "20M",  "HT",   "2T",   "161",  "63",   "FCC",  "5G",   "20M",
+	"HT",   "2T",   "165",  "32",   "ETSI", "5G",   "20M",  "HT",   "2T",
+	"165",  "63",   "MKK",  "5G",   "20M",  "HT",   "2T",   "165",  "63",
+	"FCC",  "5G",   "40M",  "HT",   "1T",   "38",   "22",   "ETSI", "5G",
+	"40M",  "HT",   "1T",   "38",   "30",   "MKK",  "5G",   "40M",  "HT",
+	"1T",   "38",   "30",   "FCC",  "5G",   "40M",  "HT",   "1T",   "46",
+	"30",   "ETSI", "5G",   "40M",  "HT",   "1T",   "46",   "30",   "MKK",
+	"5G",   "40M",  "HT",   "1T",   "46",   "30",   "FCC",  "5G",   "40M",
+	"HT",   "1T",   "54",   "30",   "ETSI", "5G",   "40M",  "HT",   "1T",
+	"54",   "30",   "MKK",  "5G",   "40M",  "HT",   "1T",   "54",   "30",
+	"FCC",  "5G",   "40M",  "HT",   "1T",   "62",   "24",   "ETSI", "5G",
+	"40M",  "HT",   "1T",   "62",   "30",   "MKK",  "5G",   "40M",  "HT",
+	"1T",   "62",   "30",   "FCC",  "5G",   "40M",  "HT",   "1T",   "102",
+	"24",   "ETSI", "5G",   "40M",  "HT",   "1T",   "102",  "30",   "MKK",
+	"5G",   "40M",  "HT",   "1T",   "102",  "30",   "FCC",  "5G",   "40M",
+	"HT",   "1T",   "110",  "30",   "ETSI", "5G",   "40M",  "HT",   "1T",
+	"110",  "30",   "MKK",  "5G",   "40M",  "HT",   "1T",   "110",  "30",
+	"FCC",  "5G",   "40M",  "HT",   "1T",   "118",  "30",   "ETSI", "5G",
+	"40M",  "HT",   "1T",   "118",  "30",   "MKK",  "5G",   "40M",  "HT",
+	"1T",   "118",  "30",   "FCC",  "5G",   "40M",  "HT",   "1T",   "126",
+	"30",   "ETSI", "5G",   "40M",  "HT",   "1T",   "126",  "30",   "MKK",
+	"5G",   "40M",  "HT",   "1T",   "126",  "30",   "FCC",  "5G",   "40M",
+	"HT",   "1T",   "134",  "30",   "ETSI", "5G",   "40M",  "HT",   "1T",
+	"134",  "30",   "MKK",  "5G",   "40M",  "HT",   "1T",   "134",  "30",
+	"FCC",  "5G",   "40M",  "HT",   "1T",   "142",  "30",   "ETSI", "5G",
+	"40M",  "HT",   "1T",   "142",  "63",   "MKK",  "5G",   "40M",  "HT",
+	"1T",   "142",  "63",   "FCC",  "5G",   "40M",  "HT",   "1T",   "151",
+	"30",   "ETSI", "5G",   "40M",  "HT",   "1T",   "151",  "63",   "MKK",
+	"5G",   "40M",  "HT",   "1T",   "151",  "63",   "FCC",  "5G",   "40M",
+	"HT",   "1T",   "159",  "30",   "ETSI", "5G",   "40M",  "HT",   "1T",
+	"159",  "63",   "MKK",  "5G",   "40M",  "HT",   "1T",   "159",  "63",
+	"FCC",  "5G",   "40M",  "HT",   "2T",   "38",   "20",   "ETSI", "5G",
+	"40M",  "HT",   "2T",   "38",   "20",   "MKK",  "5G",   "40M",  "HT",
+	"2T",   "38",   "22",   "FCC",  "5G",   "40M",  "HT",   "2T",   "46",
+	"30",   "ETSI", "5G",   "40M",  "HT",   "2T",   "46",   "20",   "MKK",
+	"5G",   "40M",  "HT",   "2T",   "46",   "22",   "FCC",  "5G",   "40M",
+	"HT",   "2T",   "54",   "30",   "ETSI", "5G",   "40M",  "HT",   "2T",
+	"54",   "20",   "MKK",  "5G",   "40M",  "HT",   "2T",   "54",   "22",
+	"FCC",  "5G",   "40M",  "HT",   "2T",   "62",   "22",   "ETSI", "5G",
+	"40M",  "HT",   "2T",   "62",   "20",   "MKK",  "5G",   "40M",  "HT",
+	"2T",   "62",   "22",   "FCC",  "5G",   "40M",  "HT",   "2T",   "102",
+	"22",   "ETSI", "5G",   "40M",  "HT",   "2T",   "102",  "20",   "MKK",
+	"5G",   "40M",  "HT",   "2T",   "102",  "30",   "FCC",  "5G",   "40M",
+	"HT",   "2T",   "110",  "30",   "ETSI", "5G",   "40M",  "HT",   "2T",
+	"110",  "20",   "MKK",  "5G",   "40M",  "HT",   "2T",   "110",  "30",
+	"FCC",  "5G",   "40M",  "HT",   "2T",   "118",  "30",   "ETSI", "5G",
+	"40M",  "HT",   "2T",   "118",  "20",   "MKK",  "5G",   "40M",  "HT",
+	"2T",   "118",  "30",   "FCC",  "5G",   "40M",  "HT",   "2T",   "126",
+	"30",   "ETSI", "5G",   "40M",  "HT",   "2T",   "126",  "20",   "MKK",
+	"5G",   "40M",  "HT",   "2T",   "126",  "30",   "FCC",  "5G",   "40M",
+	"HT",   "2T",   "134",  "30",   "ETSI", "5G",   "40M",  "HT",   "2T",
+	"134",  "20",   "MKK",  "5G",   "40M",  "HT",   "2T",   "134",  "30",
+	"FCC",  "5G",   "40M",  "HT",   "2T",   "142",  "30",   "ETSI", "5G",
+	"40M",  "HT",   "2T",   "142",  "63",   "MKK",  "5G",   "40M",  "HT",
+	"2T",   "142",  "63",   "FCC",  "5G",   "40M",  "HT",   "2T",   "151",
+	"30",   "ETSI", "5G",   "40M",  "HT",   "2T",   "151",  "63",   "MKK",
+	"5G",   "40M",  "HT",   "2T",   "151",  "63",   "FCC",  "5G",   "40M",
+	"HT",   "2T",   "159",  "30",   "ETSI", "5G",   "40M",  "HT",   "2T",
+	"159",  "63",   "MKK",  "5G",   "40M",  "HT",   "2T",   "159",  "63",
+	"FCC",  "5G",   "80M",  "VHT",  "1T",   "42",   "20",   "ETSI", "5G",
+	"80M",  "VHT",  "1T",   "42",   "30",   "MKK",  "5G",   "80M",  "VHT",
+	"1T",   "42",   "28",   "FCC",  "5G",   "80M",  "VHT",  "1T",   "58",
+	"20",   "ETSI", "5G",   "80M",  "VHT",  "1T",   "58",   "30",   "MKK",
+	"5G",   "80M",  "VHT",  "1T",   "58",   "28",   "FCC",  "5G",   "80M",
+	"VHT",  "1T",   "106",  "20",   "ETSI", "5G",   "80M",  "VHT",  "1T",
+	"106",  "30",   "MKK",  "5G",   "80M",  "VHT",  "1T",   "106",  "30",
+	"FCC",  "5G",   "80M",  "VHT",  "1T",   "122",  "30",   "ETSI", "5G",
+	"80M",  "VHT",  "1T",   "122",  "30",   "MKK",  "5G",   "80M",  "VHT",
+	"1T",   "122",  "30",   "FCC",  "5G",   "80M",  "VHT",  "1T",   "138",
+	"30",   "ETSI", "5G",   "80M",  "VHT",  "1T",   "138",  "63",   "MKK",
+	"5G",   "80M",  "VHT",  "1T",   "138",  "63",   "FCC",  "5G",   "80M",
+	"VHT",  "1T",   "155",  "30",   "ETSI", "5G",   "80M",  "VHT",  "1T",
+	"155",  "63",   "MKK",  "5G",   "80M",  "VHT",  "1T",   "155",  "63",
+	"FCC",  "5G",   "80M",  "VHT",  "2T",   "42",   "18",   "ETSI", "5G",
+	"80M",  "VHT",  "2T",   "42",   "20",   "MKK",  "5G",   "80M",  "VHT",
+	"2T",   "42",   "22",   "FCC",  "5G",   "80M",  "VHT",  "2T",   "58",
+	"18",   "ETSI", "5G",   "80M",  "VHT",  "2T",   "58",   "20",   "MKK",
+	"5G",   "80M",  "VHT",  "2T",   "58",   "22",   "FCC",  "5G",   "80M",
+	"VHT",  "2T",   "106",  "20",   "ETSI", "5G",   "80M",  "VHT",  "2T",
+	"106",  "20",   "MKK",  "5G",   "80M",  "VHT",  "2T",   "106",  "30",
+	"FCC",  "5G",   "80M",  "VHT",  "2T",   "122",  "30",   "ETSI", "5G",
+	"80M",  "VHT",  "2T",   "122",  "20",   "MKK",  "5G",   "80M",  "VHT",
+	"2T",   "122",  "30",   "FCC",  "5G",   "80M",  "VHT",  "2T",   "138",
+	"30",   "ETSI", "5G",   "80M",  "VHT",  "2T",   "138",  "63",   "MKK",
+	"5G",   "80M",  "VHT",  "2T",   "138",  "63",   "FCC",  "5G",   "80M",
+	"VHT",  "2T",   "155",  "30",   "ETSI", "5G",   "80M",  "VHT",  "2T",
+	"155",  "63",   "MKK",  "5G",   "80M",  "VHT",  "2T",   "155",  "63"};
+
+void odm_read_and_config_mp_8822b_txpwr_lmt_type5(struct phy_dm_struct *dm)
+{
+	u32 i = 0;
+	u32 array_len = sizeof(array_mp_8822b_txpwr_lmt_type5) / sizeof(u8 *);
+	u8 **array = (u8 **)array_mp_8822b_txpwr_lmt_type5;
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT,
+		     "===> odm_read_and_config_mp_8822b_txpwr_lmt_type5\n");
+
+	for (i = 0; i < array_len; i += 7) {
+		u8 *regulation = array[i];
+		u8 *band = array[i + 1];
+		u8 *bandwidth = array[i + 2];
+		u8 *rate = array[i + 3];
+		u8 *rf_path = array[i + 4];
+		u8 *chnl = array[i + 5];
+		u8 *val = array[i + 6];
+
+		odm_config_bb_txpwr_lmt_8822b(dm, regulation, band, bandwidth,
+					      rate, rf_path, chnl, val);
+	}
+}
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_rf.h b/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_rf.h
new file mode 100644
index 000000000000..1340fa9f369b
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/halhwimg8822b_rf.h
@@ -0,0 +1,129 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+/*Image2HeaderVersion: 3.2*/
+#ifndef __INC_MP_RF_HW_IMG_8822B_H
+#define __INC_MP_RF_HW_IMG_8822B_H
+
+/******************************************************************************
+ *                           radioa.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_radioa(struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_radioa(void);
+
+/******************************************************************************
+ *                           radiob.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_radiob(struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_radiob(void);
+
+/******************************************************************************
+ *                           txpowertrack.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_txpowertrack(struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_txpowertrack(void);
+
+/******************************************************************************
+ *                           txpowertrack_type0.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_txpowertrack_type0(struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_txpowertrack_type0(void);
+
+/******************************************************************************
+ *                           txpowertrack_type1.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_txpowertrack_type1(struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_txpowertrack_type1(void);
+
+/******************************************************************************
+ *                           txpowertrack_type2.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_txpowertrack_type2(struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_txpowertrack_type2(void);
+
+/******************************************************************************
+ *                           txpowertrack_type3_type5.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_txpowertrack_type3_type5(
+	struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_txpowertrack_type3_type5(void);
+
+/******************************************************************************
+ *                           txpowertrack_type4.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_txpowertrack_type4(struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_txpowertrack_type4(void);
+
+/******************************************************************************
+ *                           txpowertrack_type6.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_txpowertrack_type6(struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_txpowertrack_type6(void);
+
+/******************************************************************************
+ *                           txpowertrack_type7.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_txpowertrack_type7(struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_txpowertrack_type7(void);
+
+/******************************************************************************
+ *                           txpowertrack_type8.TXT
+ *****************************************************************************/
+
+void odm_read_and_config_mp_8822b_txpowertrack_type8(struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_txpowertrack_type8(void);
+
+/******************************************************************************
+ *                           txpowertrack_type9.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_txpowertrack_type9(struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_txpowertrack_type9(void);
+
+/******************************************************************************
+ *                           txpwr_lmt.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_txpwr_lmt(struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_txpwr_lmt(void);
+
+/******************************************************************************
+ *                           txpwr_lmt_type5.TXT
+ ******************************************************************************/
+
+void odm_read_and_config_mp_8822b_txpwr_lmt_type5(struct phy_dm_struct *dm);
+u32 odm_get_version_mp_8822b_txpwr_lmt_type5(void);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/halphyrf_8822b.c b/drivers/staging/rtlwifi/phydm/rtl8822b/halphyrf_8822b.c
new file mode 100644
index 000000000000..ae3e2278fefd
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/halphyrf_8822b.c
@@ -0,0 +1,351 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
+
+static bool
+get_mix_mode_tx_agc_bb_swing_offset_8822b(void *dm_void,
+					  enum pwrtrack_method method,
+					  u8 rf_path, u8 tx_power_index_offest)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+
+	u8 bb_swing_upper_bound = cali_info->default_ofdm_index + 10;
+	u8 bb_swing_lower_bound = 0;
+
+	s8 tx_agc_index = 0;
+	u8 tx_bb_swing_index = cali_info->default_ofdm_index;
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_TX_PWR_TRACK,
+		"Path_%d cali_info->absolute_ofdm_swing_idx[rf_path]=%d, tx_power_index_offest=%d\n",
+		rf_path, cali_info->absolute_ofdm_swing_idx[rf_path],
+		tx_power_index_offest);
+
+	if (tx_power_index_offest > 0XF)
+		tx_power_index_offest = 0XF;
+
+	if (cali_info->absolute_ofdm_swing_idx[rf_path] >= 0 &&
+	    cali_info->absolute_ofdm_swing_idx[rf_path] <=
+		    tx_power_index_offest) {
+		tx_agc_index = cali_info->absolute_ofdm_swing_idx[rf_path];
+		tx_bb_swing_index = cali_info->default_ofdm_index;
+	} else if (cali_info->absolute_ofdm_swing_idx[rf_path] >
+		   tx_power_index_offest) {
+		tx_agc_index = tx_power_index_offest;
+		cali_info->remnant_ofdm_swing_idx[rf_path] =
+			cali_info->absolute_ofdm_swing_idx[rf_path] -
+			tx_power_index_offest;
+		tx_bb_swing_index = cali_info->default_ofdm_index +
+				    cali_info->remnant_ofdm_swing_idx[rf_path];
+
+		if (tx_bb_swing_index > bb_swing_upper_bound)
+			tx_bb_swing_index = bb_swing_upper_bound;
+	} else {
+		tx_agc_index = 0;
+
+		if (cali_info->default_ofdm_index >
+		    (cali_info->absolute_ofdm_swing_idx[rf_path] * (-1)))
+			tx_bb_swing_index =
+				cali_info->default_ofdm_index +
+				cali_info->absolute_ofdm_swing_idx[rf_path];
+		else
+			tx_bb_swing_index = bb_swing_lower_bound;
+
+		if (tx_bb_swing_index < bb_swing_lower_bound)
+			tx_bb_swing_index = bb_swing_lower_bound;
+	}
+
+	cali_info->absolute_ofdm_swing_idx[rf_path] = tx_agc_index;
+	cali_info->bb_swing_idx_ofdm[rf_path] = tx_bb_swing_index;
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_TX_PWR_TRACK,
+		"MixMode Offset Path_%d   cali_info->absolute_ofdm_swing_idx[rf_path]=%d   cali_info->bb_swing_idx_ofdm[rf_path]=%d   tx_power_index_offest=%d\n",
+		rf_path, cali_info->absolute_ofdm_swing_idx[rf_path],
+		cali_info->bb_swing_idx_ofdm[rf_path], tx_power_index_offest);
+
+	return true;
+}
+
+void odm_tx_pwr_track_set_pwr8822b(void *dm_void, enum pwrtrack_method method,
+				   u8 rf_path, u8 channel_mapped_index)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+	u8 tx_power_index_offest = 0;
+	u8 tx_power_index = 0;
+
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+	struct rtl_phy *rtlphy = &rtlpriv->phy;
+	u8 channel = rtlphy->current_channel;
+	u8 band_width = rtlphy->current_chan_bw;
+	u8 tx_rate = 0xFF;
+
+	if (!dm->mp_mode) {
+		u16 rate = *dm->forced_data_rate;
+
+		if (!rate) /*auto rate*/
+			tx_rate = dm->tx_rate;
+		else /*force rate*/
+			tx_rate = (u8)rate;
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK, "Call:%s tx_rate=0x%X\n",
+		     __func__, tx_rate);
+
+	ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+		     "pRF->default_ofdm_index=%d   pRF->default_cck_index=%d\n",
+		     cali_info->default_ofdm_index,
+		     cali_info->default_cck_index);
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_TX_PWR_TRACK,
+		"pRF->absolute_ofdm_swing_idx=%d   pRF->remnant_ofdm_swing_idx=%d   pRF->absolute_cck_swing_idx=%d   pRF->remnant_cck_swing_idx=%d   rf_path=%d\n",
+		cali_info->absolute_ofdm_swing_idx[rf_path],
+		cali_info->remnant_ofdm_swing_idx[rf_path],
+		cali_info->absolute_cck_swing_idx[rf_path],
+		cali_info->remnant_cck_swing_idx, rf_path);
+
+	if (dm->number_linked_client != 0)
+		tx_power_index = odm_get_tx_power_index(
+			dm, (enum odm_rf_radio_path)rf_path, tx_rate,
+			band_width, channel);
+
+	if (tx_power_index >= 63)
+		tx_power_index = 63;
+
+	tx_power_index_offest = 63 - tx_power_index;
+
+	ODM_RT_TRACE(dm, ODM_COMP_TX_PWR_TRACK,
+		     "tx_power_index=%d tx_power_index_offest=%d rf_path=%d\n",
+		     tx_power_index, tx_power_index_offest, rf_path);
+
+	if (method ==
+	    BBSWING) { /*use for mp driver clean power tracking status*/
+		switch (rf_path) {
+		case ODM_RF_PATH_A:
+			odm_set_bb_reg(
+				dm, 0xC94, (BIT(29) | BIT(28) | BIT(27) |
+					    BIT(26) | BIT(25)),
+				cali_info->absolute_ofdm_swing_idx[rf_path]);
+			odm_set_bb_reg(
+				dm, REG_A_TX_SCALE_JAGUAR, 0xFFE00000,
+				tx_scaling_table_jaguar
+					[cali_info
+						 ->bb_swing_idx_ofdm[rf_path]]);
+			break;
+		case ODM_RF_PATH_B:
+			odm_set_bb_reg(
+				dm, 0xE94, (BIT(29) | BIT(28) | BIT(27) |
+					    BIT(26) | BIT(25)),
+				cali_info->absolute_ofdm_swing_idx[rf_path]);
+			odm_set_bb_reg(
+				dm, REG_B_TX_SCALE_JAGUAR, 0xFFE00000,
+				tx_scaling_table_jaguar
+					[cali_info
+						 ->bb_swing_idx_ofdm[rf_path]]);
+			break;
+
+		default:
+			break;
+		}
+	} else if (method == MIX_MODE) {
+		switch (rf_path) {
+		case ODM_RF_PATH_A:
+			get_mix_mode_tx_agc_bb_swing_offset_8822b(
+				dm, method, rf_path, tx_power_index_offest);
+			odm_set_bb_reg(
+				dm, 0xC94, (BIT(29) | BIT(28) | BIT(27) |
+					    BIT(26) | BIT(25)),
+				cali_info->absolute_ofdm_swing_idx[rf_path]);
+			odm_set_bb_reg(
+				dm, REG_A_TX_SCALE_JAGUAR, 0xFFE00000,
+				tx_scaling_table_jaguar
+					[cali_info
+						 ->bb_swing_idx_ofdm[rf_path]]);
+
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"TXAGC(0xC94)=0x%x BBSwing(0xc1c)=0x%x BBSwingIndex=%d rf_path=%d\n",
+				odm_get_bb_reg(dm, 0xC94,
+					       (BIT(29) | BIT(28) | BIT(27) |
+						BIT(26) | BIT(25))),
+				odm_get_bb_reg(dm, 0xc1c, 0xFFE00000),
+				cali_info->bb_swing_idx_ofdm[rf_path], rf_path);
+			break;
+
+		case ODM_RF_PATH_B:
+			get_mix_mode_tx_agc_bb_swing_offset_8822b(
+				dm, method, rf_path, tx_power_index_offest);
+			odm_set_bb_reg(
+				dm, 0xE94, (BIT(29) | BIT(28) | BIT(27) |
+					    BIT(26) | BIT(25)),
+				cali_info->absolute_ofdm_swing_idx[rf_path]);
+			odm_set_bb_reg(
+				dm, REG_B_TX_SCALE_JAGUAR, 0xFFE00000,
+				tx_scaling_table_jaguar
+					[cali_info
+						 ->bb_swing_idx_ofdm[rf_path]]);
+
+			ODM_RT_TRACE(
+				dm, ODM_COMP_TX_PWR_TRACK,
+				"TXAGC(0xE94)=0x%x BBSwing(0xe1c)=0x%x BBSwingIndex=%d rf_path=%d\n",
+				odm_get_bb_reg(dm, 0xE94,
+					       (BIT(29) | BIT(28) | BIT(27) |
+						BIT(26) | BIT(25))),
+				odm_get_bb_reg(dm, 0xe1c, 0xFFE00000),
+				cali_info->bb_swing_idx_ofdm[rf_path], rf_path);
+			break;
+
+		default:
+			break;
+		}
+	}
+}
+
+void get_delta_swing_table_8822b(void *dm_void, u8 **temperature_up_a,
+				 u8 **temperature_down_a, u8 **temperature_up_b,
+				 u8 **temperature_down_b)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dm_rf_calibration_struct *cali_info = &dm->rf_calibrate_info;
+
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)dm->adapter;
+	struct rtl_phy *rtlphy = &rtlpriv->phy;
+	u8 channel = rtlphy->current_channel;
+
+	*temperature_up_a = cali_info->delta_swing_table_idx_2ga_p;
+	*temperature_down_a = cali_info->delta_swing_table_idx_2ga_n;
+	*temperature_up_b = cali_info->delta_swing_table_idx_2gb_p;
+	*temperature_down_b = cali_info->delta_swing_table_idx_2gb_n;
+
+	if (channel >= 36 && channel <= 64) {
+		*temperature_up_a = cali_info->delta_swing_table_idx_5ga_p[0];
+		*temperature_down_a = cali_info->delta_swing_table_idx_5ga_n[0];
+		*temperature_up_b = cali_info->delta_swing_table_idx_5gb_p[0];
+		*temperature_down_b = cali_info->delta_swing_table_idx_5gb_n[0];
+	} else if (channel >= 100 && channel <= 144) {
+		*temperature_up_a = cali_info->delta_swing_table_idx_5ga_p[1];
+		*temperature_down_a = cali_info->delta_swing_table_idx_5ga_n[1];
+		*temperature_up_b = cali_info->delta_swing_table_idx_5gb_p[1];
+		*temperature_down_b = cali_info->delta_swing_table_idx_5gb_n[1];
+	} else if (channel >= 149 && channel <= 177) {
+		*temperature_up_a = cali_info->delta_swing_table_idx_5ga_p[2];
+		*temperature_down_a = cali_info->delta_swing_table_idx_5ga_n[2];
+		*temperature_up_b = cali_info->delta_swing_table_idx_5gb_p[2];
+		*temperature_down_b = cali_info->delta_swing_table_idx_5gb_n[2];
+	}
+}
+
+static void _phy_lc_calibrate_8822b(struct phy_dm_struct *dm)
+{
+	u32 lc_cal = 0, cnt = 0;
+
+	/*backup RF0x18*/
+	lc_cal = odm_get_rf_reg(dm, ODM_RF_PATH_A, RF_CHNLBW, RFREGOFFSETMASK);
+
+	/*Start LCK*/
+	odm_set_rf_reg(dm, ODM_RF_PATH_A, RF_CHNLBW, RFREGOFFSETMASK,
+		       lc_cal | 0x08000);
+
+	ODM_delay_ms(100);
+
+	for (cnt = 0; cnt < 100; cnt++) {
+		if (odm_get_rf_reg(dm, ODM_RF_PATH_A, RF_CHNLBW, 0x8000) != 0x1)
+			break;
+		ODM_delay_ms(10);
+	}
+
+	/*Recover channel number*/
+	odm_set_rf_reg(dm, ODM_RF_PATH_A, RF_CHNLBW, RFREGOFFSETMASK, lc_cal);
+}
+
+void phy_lc_calibrate_8822b(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	bool is_start_cont_tx = false, is_single_tone = false,
+	     is_carrier_suppression = false;
+	u64 start_time;
+	u64 progressing_time;
+
+	if (is_start_cont_tx || is_single_tone || is_carrier_suppression) {
+		ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+			     "[LCK]continues TX ing !!! LCK return\n");
+		return;
+	}
+
+	start_time = odm_get_current_time(dm);
+	_phy_lc_calibrate_8822b(dm);
+	progressing_time = odm_get_progressing_time(dm, start_time);
+	ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+		     "[LCK]LCK progressing_time = %lld\n", progressing_time);
+}
+
+void configure_txpower_track_8822b(struct txpwrtrack_cfg *config)
+{
+	config->swing_table_size_cck = TXSCALE_TABLE_SIZE;
+	config->swing_table_size_ofdm = TXSCALE_TABLE_SIZE;
+	config->threshold_iqk = IQK_THRESHOLD;
+	config->threshold_dpk = DPK_THRESHOLD;
+	config->average_thermal_num = AVG_THERMAL_NUM_8822B;
+	config->rf_path_count = MAX_PATH_NUM_8822B;
+	config->thermal_reg_addr = RF_T_METER_8822B;
+
+	config->odm_tx_pwr_track_set_pwr = odm_tx_pwr_track_set_pwr8822b;
+	config->do_iqk = do_iqk_8822b;
+	config->phy_lc_calibrate = phy_lc_calibrate_8822b;
+
+	config->get_delta_swing_table = get_delta_swing_table_8822b;
+}
+
+void phy_set_rf_path_switch_8822b(struct phy_dm_struct *dm, bool is_main)
+{
+	/*BY SY Request */
+	odm_set_bb_reg(dm, 0x4C, (BIT(24) | BIT(23)), 0x2);
+	odm_set_bb_reg(dm, 0x974, 0xff, 0xff);
+
+	/*odm_set_bb_reg(dm, 0x1991, 0x3, 0x0);*/
+	odm_set_bb_reg(dm, 0x1990, (BIT(9) | BIT(8)), 0x0);
+
+	/*odm_set_bb_reg(dm, 0xCBE, 0x8, 0x0);*/
+	odm_set_bb_reg(dm, 0xCBC, BIT(19), 0x0);
+
+	odm_set_bb_reg(dm, 0xCB4, 0xff, 0x77);
+
+	odm_set_bb_reg(dm, 0x70, MASKBYTE3, 0x0e);
+	odm_set_bb_reg(dm, 0x1704, MASKDWORD, 0x0000ff00);
+	odm_set_bb_reg(dm, 0x1700, MASKDWORD, 0xc00f0038);
+
+	if (is_main) {
+		/*odm_set_bb_reg(dm, 0xCBD, 0x3, 0x2);		WiFi */
+		odm_set_bb_reg(dm, 0xCBC, (BIT(9) | BIT(8)), 0x2); /*WiFi */
+	} else {
+		/*odm_set_bb_reg(dm, 0xCBD, 0x3, 0x1);	 BT*/
+		odm_set_bb_reg(dm, 0xCBC, (BIT(9) | BIT(8)), 0x1); /*BT*/
+	}
+}
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/halphyrf_8822b.h b/drivers/staging/rtlwifi/phydm/rtl8822b/halphyrf_8822b.h
new file mode 100644
index 000000000000..4f3bfe316ee9
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/halphyrf_8822b.h
@@ -0,0 +1,45 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __HAL_PHY_RF_8822B_H__
+#define __HAL_PHY_RF_8822B_H__
+
+#define AVG_THERMAL_NUM_8822B 4
+#define RF_T_METER_8822B 0x42
+
+void configure_txpower_track_8822b(struct txpwrtrack_cfg *config);
+
+void odm_tx_pwr_track_set_pwr8822b(void *dm_void, enum pwrtrack_method method,
+				   u8 rf_path, u8 channel_mapped_index);
+
+void get_delta_swing_table_8822b(void *dm_void, u8 **temperature_up_a,
+				 u8 **temperature_down_a, u8 **temperature_up_b,
+				 u8 **temperature_down_b);
+
+void phy_lc_calibrate_8822b(void *dm_void);
+
+void phy_set_rf_path_switch_8822b(struct phy_dm_struct *dm, bool is_main);
+
+#endif /* #ifndef __HAL_PHY_RF_8822B_H__ */
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_hal_api8822b.c b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_hal_api8822b.c
new file mode 100644
index 000000000000..26d1022e851c
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_hal_api8822b.c
@@ -0,0 +1,1815 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
+
+/* ======================================================================== */
+/* These following functions can be used for PHY DM only*/
+
+static u32 reg82c_8822b;
+static u32 reg838_8822b;
+static u32 reg830_8822b;
+static u32 reg83c_8822b;
+static u32 rega20_8822b;
+static u32 rega24_8822b;
+static u32 rega28_8822b;
+static enum odm_bw bw_8822b;
+static u8 central_ch_8822b;
+
+static u32 cca_ifem_ccut[12][4] = {
+	/*20M*/
+	{0x75D97010, 0x75D97010, 0x75D97010, 0x75D97010}, /*Reg82C*/
+	{0x00000000, 0x79a0ea2c, 0x00000000, 0x00000000}, /*Reg830*/
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Reg838*/
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Reg83C*/
+	/*40M*/
+	{0x75D97010, 0x75D97010, 0x75D97010, 0x75D97010}, /*Reg82C*/
+	{0x00000000, 0x79a0ea2c, 0x00000000, 0x79a0ea28}, /*Reg830*/
+	{0x87765541, 0x87766341, 0x87765541, 0x87766341}, /*Reg838*/
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Reg83C*/
+	/*80M*/
+	{0x75C97010, 0x75C97010, 0x75C97010, 0x75C97010}, /*Reg82C*/
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Reg830*/
+	{0x00000000, 0x87746641, 0x00000000, 0x87746641}, /*Reg838*/
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000},
+}; /*Reg83C*/
+static u32 cca_efem_ccut[12][4] = {
+	/*20M*/
+	{0x75A76010, 0x75A76010, 0x75A76010, 0x75A75010}, /*Reg82C*/
+	{0x00000000, 0x79a0ea2c, 0x00000000, 0x00000000}, /*Reg830*/
+	{0x87766651, 0x87766431, 0x87766451, 0x87766431}, /*Reg838*/
+	{0x9194b2b9, 0x9194b2b9, 0x9194b2b9, 0x9194b2b9}, /*Reg83C*/
+	/*40M*/
+	{0x75A85010, 0x75A75010, 0x75A85010, 0x75A75010}, /*Reg82C*/
+	{0x00000000, 0x79a0ea2c, 0x00000000, 0x00000000}, /*Reg830*/
+	{0x87766431, 0x87766431, 0x87766431, 0x87766431}, /*Reg838*/
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Reg83C*/
+	/*80M*/
+	{0x76BA7010, 0x75BA7010, 0x76BA7010, 0x75BA7010}, /*Reg82C*/
+	{0x79a0ea28, 0x00000000, 0x79a0ea28, 0x00000000}, /*Reg830*/
+	{0x87766431, 0x87766431, 0x87766431, 0x87766431}, /*Reg838*/
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000},
+}; /*Reg83C*/
+static u32 cca_ifem_ccut_rfetype5[12][4] = {
+	/*20M*/
+	{0x75D97010, 0x75D97010, 0x75D97010, 0x75D97010}, /*Reg82C*/
+	{0x00000000, 0x79a0ea2c, 0x00000000, 0x00000000}, /*Reg830*/
+	{0x00000000, 0x00000000, 0x87766461, 0x87766461}, /*Reg838*/
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Reg83C*/
+	/*40M*/
+	{0x75D97010, 0x75D97010, 0x75D97010, 0x75D97010}, /*Reg82C*/
+	{0x00000000, 0x79a0ea2c, 0x00000000, 0x79a0ea28}, /*Reg830*/
+	{0x87765541, 0x87766341, 0x87765541, 0x87766341}, /*Reg838*/
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Reg83C*/
+	/*80M*/
+	{0x75C97010, 0x75C97010, 0x75C97010, 0x75C97010}, /*Reg82C*/
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Reg830*/
+	{0x00000000, 0x76666641, 0x00000000, 0x76666641}, /*Reg838*/
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000},
+}; /*Reg83C*/
+static u32 cca_ifem_ccut_rfetype3[12][4] = {
+	/*20M*/
+	{0x75D97010, 0x75D97010, 0x75D97010, 0x75D97010}, /*Reg82C*/
+	{0x00000000, 0x79a0ea2c, 0x00000000, 0x00000000}, /*Reg830*/
+	{0x00000000, 0x00000000, 0x87766461, 0x87766461}, /*Reg838*/
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Reg83C*/
+	/*40M*/
+	{0x75D97010, 0x75D97010, 0x75D97010, 0x75D97010}, /*Reg82C*/
+	{0x00000000, 0x79a0ea2c, 0x00000000, 0x79a0ea28}, /*Reg830*/
+	{0x87765541, 0x87766341, 0x87765541, 0x87766341}, /*Reg838*/
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Reg83C*/
+	/*80M*/
+	{0x75C97010, 0x75C97010, 0x75C97010, 0x75C97010}, /*Reg82C*/
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Reg830*/
+	{0x00000000, 0x76666641, 0x00000000, 0x76666641}, /*Reg838*/
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000},
+}; /*Reg83C*/
+
+static inline u32 phydm_check_bit_mask(u32 bit_mask, u32 data_original,
+				       u32 data)
+{
+	u8 bit_shift;
+
+	if (bit_mask != 0xfffff) {
+		for (bit_shift = 0; bit_shift <= 19; bit_shift++) {
+			if (((bit_mask >> bit_shift) & 0x1) == 1)
+				break;
+		}
+		return ((data_original) & (~bit_mask)) | (data << bit_shift);
+	}
+	return data;
+}
+
+static bool phydm_rfe_8822b(struct phy_dm_struct *dm, u8 channel)
+{
+	if (dm->rfe_type == 4) {
+		/* Default setting is in PHY parameters */
+
+		if (channel <= 14) {
+			/* signal source */
+			odm_set_bb_reg(dm, 0xcb0, (MASKBYTE2 | MASKLWORD),
+				       0x745774);
+			odm_set_bb_reg(dm, 0xeb0, (MASKBYTE2 | MASKLWORD),
+				       0x745774);
+			odm_set_bb_reg(dm, 0xcb4, MASKBYTE1, 0x57);
+			odm_set_bb_reg(dm, 0xeb4, MASKBYTE1, 0x57);
+
+			/* inverse or not */
+			odm_set_bb_reg(dm, 0xcbc, (BIT(5) | BIT(4) | BIT(3) |
+						   BIT(2) | BIT(1) | BIT(0)),
+				       0x8);
+			odm_set_bb_reg(dm, 0xcbc, (BIT(11) | BIT(10)), 0x2);
+			odm_set_bb_reg(dm, 0xebc, (BIT(5) | BIT(4) | BIT(3) |
+						   BIT(2) | BIT(1) | BIT(0)),
+				       0x8);
+			odm_set_bb_reg(dm, 0xebc, (BIT(11) | BIT(10)), 0x2);
+
+			/* antenna switch table */
+			if ((dm->rx_ant_status == (ODM_RF_A | ODM_RF_B)) ||
+			    (dm->tx_ant_status == (ODM_RF_A | ODM_RF_B))) {
+				/* 2TX or 2RX */
+				odm_set_bb_reg(dm, 0xca0, MASKLWORD, 0xf050);
+				odm_set_bb_reg(dm, 0xea0, MASKLWORD, 0xf050);
+			} else if (dm->rx_ant_status == dm->tx_ant_status) {
+				/* TXA+RXA or TXB+RXB */
+				odm_set_bb_reg(dm, 0xca0, MASKLWORD, 0xf055);
+				odm_set_bb_reg(dm, 0xea0, MASKLWORD, 0xf055);
+			} else {
+				/* TXB+RXA or TXA+RXB */
+				odm_set_bb_reg(dm, 0xca0, MASKLWORD, 0xf550);
+				odm_set_bb_reg(dm, 0xea0, MASKLWORD, 0xf550);
+			}
+
+		} else if (channel > 35) {
+			/* signal source */
+			odm_set_bb_reg(dm, 0xcb0, (MASKBYTE2 | MASKLWORD),
+				       0x477547);
+			odm_set_bb_reg(dm, 0xeb0, (MASKBYTE2 | MASKLWORD),
+				       0x477547);
+			odm_set_bb_reg(dm, 0xcb4, MASKBYTE1, 0x75);
+			odm_set_bb_reg(dm, 0xeb4, MASKBYTE1, 0x75);
+
+			/* inverse or not */
+			odm_set_bb_reg(dm, 0xcbc, (BIT(5) | BIT(4) | BIT(3) |
+						   BIT(2) | BIT(1) | BIT(0)),
+				       0x0);
+			odm_set_bb_reg(dm, 0xcbc, (BIT(11) | BIT(10)), 0x0);
+			odm_set_bb_reg(dm, 0xebc, (BIT(5) | BIT(4) | BIT(3) |
+						   BIT(2) | BIT(1) | BIT(0)),
+				       0x0);
+			odm_set_bb_reg(dm, 0xebc, (BIT(11) | BIT(10)), 0x0);
+
+			/* antenna switch table */
+			if ((dm->rx_ant_status == (ODM_RF_A | ODM_RF_B)) ||
+			    (dm->tx_ant_status == (ODM_RF_A | ODM_RF_B))) {
+				/* 2TX or 2RX */
+				odm_set_bb_reg(dm, 0xca0, MASKLWORD, 0xa501);
+				odm_set_bb_reg(dm, 0xea0, MASKLWORD, 0xa501);
+			} else if (dm->rx_ant_status == dm->tx_ant_status) {
+				/* TXA+RXA or TXB+RXB */
+				odm_set_bb_reg(dm, 0xca0, MASKLWORD, 0xa500);
+				odm_set_bb_reg(dm, 0xea0, MASKLWORD, 0xa500);
+			} else {
+				/* TXB+RXA or TXA+RXB */
+				odm_set_bb_reg(dm, 0xca0, MASKLWORD, 0xa005);
+				odm_set_bb_reg(dm, 0xea0, MASKLWORD, 0xa005);
+			}
+		} else {
+			return false;
+		}
+
+	} else if ((dm->rfe_type == 1) || (dm->rfe_type == 2) ||
+		   (dm->rfe_type == 7) || (dm->rfe_type == 9)) {
+		/* eFem */
+		if (((dm->cut_version == ODM_CUT_A) ||
+		     (dm->cut_version == ODM_CUT_B)) &&
+		    (dm->rfe_type < 2)) {
+			if (channel <= 14) {
+				/* signal source */
+				odm_set_bb_reg(dm, 0xcb0,
+					       (MASKBYTE2 | MASKLWORD),
+					       0x704570);
+				odm_set_bb_reg(dm, 0xeb0,
+					       (MASKBYTE2 | MASKLWORD),
+					       0x704570);
+				odm_set_bb_reg(dm, 0xcb4, MASKBYTE1, 0x45);
+				odm_set_bb_reg(dm, 0xeb4, MASKBYTE1, 0x45);
+			} else if (channel > 35) {
+				odm_set_bb_reg(dm, 0xcb0,
+					       (MASKBYTE2 | MASKLWORD),
+					       0x174517);
+				odm_set_bb_reg(dm, 0xeb0,
+					       (MASKBYTE2 | MASKLWORD),
+					       0x174517);
+				odm_set_bb_reg(dm, 0xcb4, MASKBYTE1, 0x45);
+				odm_set_bb_reg(dm, 0xeb4, MASKBYTE1, 0x45);
+			} else {
+				return false;
+			}
+
+			/* delay 400ns for PAPE */
+			odm_set_bb_reg(dm, 0x810,
+				       MASKBYTE3 | BIT(20) | BIT(21) | BIT(22) |
+					       BIT(23),
+				       0x211);
+
+			/* antenna switch table */
+			odm_set_bb_reg(dm, 0xca0, MASKLWORD, 0xa555);
+			odm_set_bb_reg(dm, 0xea0, MASKLWORD, 0xa555);
+
+			/* inverse or not */
+			odm_set_bb_reg(dm, 0xcbc, (BIT(5) | BIT(4) | BIT(3) |
+						   BIT(2) | BIT(1) | BIT(0)),
+				       0x0);
+			odm_set_bb_reg(dm, 0xcbc, (BIT(11) | BIT(10)), 0x0);
+			odm_set_bb_reg(dm, 0xebc, (BIT(5) | BIT(4) | BIT(3) |
+						   BIT(2) | BIT(1) | BIT(0)),
+				       0x0);
+			odm_set_bb_reg(dm, 0xebc, (BIT(11) | BIT(10)), 0x0);
+
+			ODM_RT_TRACE(
+				dm, ODM_PHY_CONFIG,
+				"%s: Using old RFE control pin setting for A-cut and B-cut\n",
+				__func__);
+		} else {
+			if (channel <= 14) {
+				/* signal source */
+				odm_set_bb_reg(dm, 0xcb0,
+					       (MASKBYTE2 | MASKLWORD),
+					       0x705770);
+				odm_set_bb_reg(dm, 0xeb0,
+					       (MASKBYTE2 | MASKLWORD),
+					       0x705770);
+				odm_set_bb_reg(dm, 0xcb4, MASKBYTE1, 0x57);
+				odm_set_bb_reg(dm, 0xeb4, MASKBYTE1, 0x57);
+				odm_set_bb_reg(dm, 0xcb8, BIT(4), 0);
+				odm_set_bb_reg(dm, 0xeb8, BIT(4), 0);
+			} else if (channel > 35) {
+				/* signal source */
+				odm_set_bb_reg(dm, 0xcb0,
+					       (MASKBYTE2 | MASKLWORD),
+					       0x177517);
+				odm_set_bb_reg(dm, 0xeb0,
+					       (MASKBYTE2 | MASKLWORD),
+					       0x177517);
+				odm_set_bb_reg(dm, 0xcb4, MASKBYTE1, 0x75);
+				odm_set_bb_reg(dm, 0xeb4, MASKBYTE1, 0x75);
+				odm_set_bb_reg(dm, 0xcb8, BIT(5), 0);
+				odm_set_bb_reg(dm, 0xeb8, BIT(5), 0);
+			} else {
+				return false;
+			}
+
+			/* inverse or not */
+			odm_set_bb_reg(dm, 0xcbc, (BIT(5) | BIT(4) | BIT(3) |
+						   BIT(2) | BIT(1) | BIT(0)),
+				       0x0);
+			odm_set_bb_reg(dm, 0xcbc, (BIT(11) | BIT(10)), 0x0);
+			odm_set_bb_reg(dm, 0xebc, (BIT(5) | BIT(4) | BIT(3) |
+						   BIT(2) | BIT(1) | BIT(0)),
+				       0x0);
+			odm_set_bb_reg(dm, 0xebc, (BIT(11) | BIT(10)), 0x0);
+
+			/* antenna switch table */
+			if ((dm->rx_ant_status == (ODM_RF_A | ODM_RF_B)) ||
+			    (dm->tx_ant_status == (ODM_RF_A | ODM_RF_B))) {
+				/* 2TX or 2RX */
+				odm_set_bb_reg(dm, 0xca0, MASKLWORD, 0xa501);
+				odm_set_bb_reg(dm, 0xea0, MASKLWORD, 0xa501);
+			} else if (dm->rx_ant_status == dm->tx_ant_status) {
+				/* TXA+RXA or TXB+RXB */
+				odm_set_bb_reg(dm, 0xca0, MASKLWORD, 0xa500);
+				odm_set_bb_reg(dm, 0xea0, MASKLWORD, 0xa500);
+			} else {
+				/* TXB+RXA or TXA+RXB */
+				odm_set_bb_reg(dm, 0xca0, MASKLWORD, 0xa005);
+				odm_set_bb_reg(dm, 0xea0, MASKLWORD, 0xa005);
+			}
+		}
+	} else if ((dm->rfe_type == 0) || (dm->rfe_type == 3) ||
+		   (dm->rfe_type == 5) || (dm->rfe_type == 6) ||
+		   (dm->rfe_type == 8) || (dm->rfe_type == 10)) {
+		/* iFEM */
+		if (channel <= 14) {
+			/* signal source */
+
+			odm_set_bb_reg(dm, 0xcb0, (MASKBYTE2 | MASKLWORD),
+				       0x745774);
+			odm_set_bb_reg(dm, 0xeb0, (MASKBYTE2 | MASKLWORD),
+				       0x745774);
+			odm_set_bb_reg(dm, 0xcb4, MASKBYTE1, 0x57);
+			odm_set_bb_reg(dm, 0xeb4, MASKBYTE1, 0x57);
+
+		} else if (channel > 35) {
+			/* signal source */
+
+			odm_set_bb_reg(dm, 0xcb0, (MASKBYTE2 | MASKLWORD),
+				       0x477547);
+			odm_set_bb_reg(dm, 0xeb0, (MASKBYTE2 | MASKLWORD),
+				       0x477547);
+			odm_set_bb_reg(dm, 0xcb4, MASKBYTE1, 0x75);
+			odm_set_bb_reg(dm, 0xeb4, MASKBYTE1, 0x75);
+
+		} else {
+			return false;
+		}
+
+		/* inverse or not */
+		odm_set_bb_reg(dm, 0xcbc, (BIT(5) | BIT(4) | BIT(3) | BIT(2) |
+					   BIT(1) | BIT(0)),
+			       0x0);
+		odm_set_bb_reg(dm, 0xcbc, (BIT(11) | BIT(10)), 0x0);
+		odm_set_bb_reg(dm, 0xebc, (BIT(5) | BIT(4) | BIT(3) | BIT(2) |
+					   BIT(1) | BIT(0)),
+			       0x0);
+		odm_set_bb_reg(dm, 0xebc, (BIT(11) | BIT(10)), 0x0);
+
+		/* antenna switch table */
+		if (channel <= 14) {
+			if ((dm->rx_ant_status == (ODM_RF_A | ODM_RF_B)) ||
+			    (dm->tx_ant_status == (ODM_RF_A | ODM_RF_B))) {
+				/* 2TX or 2RX */
+				odm_set_bb_reg(dm, 0xca0, MASKLWORD, 0xa501);
+				odm_set_bb_reg(dm, 0xea0, MASKLWORD, 0xa501);
+			} else if (dm->rx_ant_status == dm->tx_ant_status) {
+				/* TXA+RXA or TXB+RXB */
+				odm_set_bb_reg(dm, 0xca0, MASKLWORD, 0xa500);
+				odm_set_bb_reg(dm, 0xea0, MASKLWORD, 0xa500);
+			} else {
+				/* TXB+RXA or TXA+RXB */
+				odm_set_bb_reg(dm, 0xca0, MASKLWORD, 0xa005);
+				odm_set_bb_reg(dm, 0xea0, MASKLWORD, 0xa005);
+			}
+		} else if (channel > 35) {
+			odm_set_bb_reg(dm, 0xca0, MASKLWORD, 0xa5a5);
+			odm_set_bb_reg(dm, 0xea0, MASKLWORD, 0xa5a5);
+		}
+	}
+
+	/* chip top mux */
+	odm_set_bb_reg(dm, 0x64, BIT(29) | BIT(28), 0x3);
+	odm_set_bb_reg(dm, 0x4c, BIT(26) | BIT(25), 0x0);
+	odm_set_bb_reg(dm, 0x40, BIT(2), 0x1);
+
+	/* from s0 or s1 */
+	odm_set_bb_reg(dm, 0x1990,
+		       (BIT(5) | BIT(4) | BIT(3) | BIT(2) | BIT(1) | BIT(0)),
+		       0x30);
+	odm_set_bb_reg(dm, 0x1990, (BIT(11) | BIT(10)), 0x3);
+
+	/* input or output */
+	odm_set_bb_reg(dm, 0x974,
+		       (BIT(5) | BIT(4) | BIT(3) | BIT(2) | BIT(1) | BIT(0)),
+		       0x3f);
+	odm_set_bb_reg(dm, 0x974, (BIT(11) | BIT(10)), 0x3);
+
+	ODM_RT_TRACE(
+		dm, ODM_PHY_CONFIG,
+		"%s: Update RFE control pin setting (ch%d, tx_path 0x%x, rx_path 0x%x)\n",
+		__func__, channel, dm->tx_ant_status, dm->rx_ant_status);
+
+	return true;
+}
+
+static void phydm_ccapar_by_rfe_8822b(struct phy_dm_struct *dm)
+{
+	u32 cca_ifem[12][4], cca_efem[12][4];
+	u8 row, col;
+	u32 reg82c, reg830, reg838, reg83c;
+
+	if (dm->cut_version == ODM_CUT_A)
+		return;
+	{
+		odm_move_memory(dm, cca_efem, cca_efem_ccut, 48 * 4);
+		if (dm->rfe_type == 5)
+			odm_move_memory(dm, cca_ifem, cca_ifem_ccut_rfetype5,
+					48 * 4);
+		else if (dm->rfe_type == 3)
+			odm_move_memory(dm, cca_ifem, cca_ifem_ccut_rfetype3,
+					48 * 4);
+		else
+			odm_move_memory(dm, cca_ifem, cca_ifem_ccut, 48 * 4);
+
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s: Update CCA parameters for Ccut\n", __func__);
+	}
+
+	if (bw_8822b == ODM_BW20M)
+		row = 0;
+	else if (bw_8822b == ODM_BW40M)
+		row = 4;
+	else
+		row = 8;
+
+	if (central_ch_8822b <= 14) {
+		if ((dm->rx_ant_status == ODM_RF_A) ||
+		    (dm->rx_ant_status == ODM_RF_B))
+			col = 0;
+		else
+			col = 1;
+	} else {
+		if ((dm->rx_ant_status == ODM_RF_A) ||
+		    (dm->rx_ant_status == ODM_RF_B))
+			col = 2;
+		else
+			col = 3;
+	}
+
+	if ((dm->rfe_type == 1) || (dm->rfe_type == 4) || (dm->rfe_type == 6) ||
+	    (dm->rfe_type == 7)) {
+		/*eFEM => RFE type 1 & RFE type 4 & RFE type 6 & RFE type 7*/
+		reg82c = (cca_efem[row][col] != 0) ? cca_efem[row][col] :
+						     reg82c_8822b;
+		reg830 = (cca_efem[row + 1][col] != 0) ?
+				 cca_efem[row + 1][col] :
+				 reg830_8822b;
+		reg838 = (cca_efem[row + 2][col] != 0) ?
+				 cca_efem[row + 2][col] :
+				 reg838_8822b;
+		reg83c = (cca_efem[row + 3][col] != 0) ?
+				 cca_efem[row + 3][col] :
+				 reg83c_8822b;
+	} else if ((dm->rfe_type == 2) || (dm->rfe_type == 9)) {
+		/*5G eFEM, 2G iFEM => RFE type 2, 5G eFEM => RFE type 9 */
+		if (central_ch_8822b <= 14) {
+			reg82c = (cca_ifem[row][col] != 0) ?
+					 cca_ifem[row][col] :
+					 reg82c_8822b;
+			reg830 = (cca_ifem[row + 1][col] != 0) ?
+					 cca_ifem[row + 1][col] :
+					 reg830_8822b;
+			reg838 = (cca_ifem[row + 2][col] != 0) ?
+					 cca_ifem[row + 2][col] :
+					 reg838_8822b;
+			reg83c = (cca_ifem[row + 3][col] != 0) ?
+					 cca_ifem[row + 3][col] :
+					 reg83c_8822b;
+		} else {
+			reg82c = (cca_efem[row][col] != 0) ?
+					 cca_efem[row][col] :
+					 reg82c_8822b;
+			reg830 = (cca_efem[row + 1][col] != 0) ?
+					 cca_efem[row + 1][col] :
+					 reg830_8822b;
+			reg838 = (cca_efem[row + 2][col] != 0) ?
+					 cca_efem[row + 2][col] :
+					 reg838_8822b;
+			reg83c = (cca_efem[row + 3][col] != 0) ?
+					 cca_efem[row + 3][col] :
+					 reg83c_8822b;
+		}
+	} else {
+		/* iFEM =>RFE type 3 & RFE type 5 & RFE type 0 & RFE type 8 &
+		 * RFE type 10
+		 */
+		reg82c = (cca_ifem[row][col] != 0) ? cca_ifem[row][col] :
+						     reg82c_8822b;
+		reg830 = (cca_ifem[row + 1][col] != 0) ?
+				 cca_ifem[row + 1][col] :
+				 reg830_8822b;
+		reg838 = (cca_ifem[row + 2][col] != 0) ?
+				 cca_ifem[row + 2][col] :
+				 reg838_8822b;
+		reg83c = (cca_ifem[row + 3][col] != 0) ?
+				 cca_ifem[row + 3][col] :
+				 reg83c_8822b;
+	}
+
+	odm_set_bb_reg(dm, 0x82c, MASKDWORD, reg82c);
+	odm_set_bb_reg(dm, 0x830, MASKDWORD, reg830);
+	odm_set_bb_reg(dm, 0x838, MASKDWORD, reg838);
+	odm_set_bb_reg(dm, 0x83c, MASKDWORD, reg83c);
+	ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+		     "%s: (Pkt%d, Intf%d, RFE%d), row = %d, col = %d\n",
+		     __func__, dm->package_type, dm->support_interface,
+		     dm->rfe_type, row, col);
+}
+
+static void phydm_ccapar_by_bw_8822b(struct phy_dm_struct *dm,
+				     enum odm_bw bandwidth)
+{
+	u32 reg82c;
+
+	if (dm->cut_version != ODM_CUT_A)
+		return;
+
+	/* A-cut */
+	reg82c = odm_get_bb_reg(dm, 0x82c, MASKDWORD);
+
+	if (bandwidth == ODM_BW20M) {
+		/* 82c[15:12] = 4 */
+		/* 82c[27:24] = 6 */
+
+		reg82c &= (~(0x0f00f000));
+		reg82c |= ((0x4) << 12);
+		reg82c |= ((0x6) << 24);
+	} else if (bandwidth == ODM_BW40M) {
+		/* 82c[19:16] = 9 */
+		/* 82c[27:24] = 6 */
+
+		reg82c &= (~(0x0f0f0000));
+		reg82c |= ((0x9) << 16);
+		reg82c |= ((0x6) << 24);
+	} else if (bandwidth == ODM_BW80M) {
+		/* 82c[15:12] 7 */
+		/* 82c[19:16] b */
+		/* 82c[23:20] d */
+		/* 82c[27:24] 3 */
+
+		reg82c &= (~(0x0ffff000));
+		reg82c |= ((0xdb7) << 12);
+		reg82c |= ((0x3) << 24);
+	}
+
+	odm_set_bb_reg(dm, 0x82c, MASKDWORD, reg82c);
+	ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+		     "%s(): Update CCA parameters for Acut\n", __func__);
+}
+
+static void phydm_ccapar_by_rxpath_8822b(struct phy_dm_struct *dm)
+{
+	if (dm->cut_version != ODM_CUT_A)
+		return;
+
+	if ((dm->rx_ant_status == ODM_RF_A) ||
+	    (dm->rx_ant_status == ODM_RF_B)) {
+		/* 838[7:4] = 8 */
+		/* 838[11:8] = 7 */
+		/* 838[15:12] = 6 */
+		/* 838[19:16] = 7 */
+		/* 838[23:20] = 7 */
+		/* 838[27:24] = 7 */
+		odm_set_bb_reg(dm, 0x838, 0x0ffffff0, 0x777678);
+	} else {
+		/* 838[7:4] = 3 */
+		/* 838[11:8] = 3 */
+		/* 838[15:12] = 6 */
+		/* 838[19:16] = 6 */
+		/* 838[23:20] = 7 */
+		/* 838[27:24] = 7 */
+		odm_set_bb_reg(dm, 0x838, 0x0ffffff0, 0x776633);
+	}
+	ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+		     "%s(): Update CCA parameters for Acut\n", __func__);
+}
+
+static void phydm_rxdfirpar_by_bw_8822b(struct phy_dm_struct *dm,
+					enum odm_bw bandwidth)
+{
+	if (bandwidth == ODM_BW40M) {
+		/* RX DFIR for BW40 */
+		odm_set_bb_reg(dm, 0x948, BIT(29) | BIT(28), 0x1);
+		odm_set_bb_reg(dm, 0x94c, BIT(29) | BIT(28), 0x0);
+		odm_set_bb_reg(dm, 0xc20, BIT(31), 0x0);
+		odm_set_bb_reg(dm, 0xe20, BIT(31), 0x0);
+	} else if (bandwidth == ODM_BW80M) {
+		/* RX DFIR for BW80 */
+		odm_set_bb_reg(dm, 0x948, BIT(29) | BIT(28), 0x2);
+		odm_set_bb_reg(dm, 0x94c, BIT(29) | BIT(28), 0x1);
+		odm_set_bb_reg(dm, 0xc20, BIT(31), 0x0);
+		odm_set_bb_reg(dm, 0xe20, BIT(31), 0x0);
+	} else {
+		/* RX DFIR for BW20, BW10 and BW5*/
+		odm_set_bb_reg(dm, 0x948, BIT(29) | BIT(28), 0x2);
+		odm_set_bb_reg(dm, 0x94c, BIT(29) | BIT(28), 0x2);
+		odm_set_bb_reg(dm, 0xc20, BIT(31), 0x1);
+		odm_set_bb_reg(dm, 0xe20, BIT(31), 0x1);
+	}
+}
+
+bool phydm_write_txagc_1byte_8822b(struct phy_dm_struct *dm, u32 power_index,
+				   enum odm_rf_radio_path path, u8 hw_rate)
+{
+	u32 offset_txagc[2] = {0x1d00, 0x1d80};
+	u8 rate_idx = (hw_rate & 0xfc), i;
+	u8 rate_offset = (hw_rate & 0x3);
+	u32 txagc_content = 0x0;
+
+	/* For debug command only!!!! */
+
+	/* Error handling */
+	if ((path > ODM_RF_PATH_B) || (hw_rate > 0x53)) {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): unsupported path (%d)\n", __func__, path);
+		return false;
+	}
+
+	/* For HW limitation, We can't write TXAGC once a byte. */
+	for (i = 0; i < 4; i++) {
+		if (i != rate_offset)
+			txagc_content =
+				txagc_content | (config_phydm_read_txagc_8822b(
+							 dm, path, rate_idx + i)
+						 << (i << 3));
+		else
+			txagc_content = txagc_content |
+					((power_index & 0x3f) << (i << 3));
+	}
+	odm_set_bb_reg(dm, (offset_txagc[path] + rate_idx), MASKDWORD,
+		       txagc_content);
+
+	ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+		     "%s(): path-%d rate index 0x%x (0x%x) = 0x%x\n", __func__,
+		     path, hw_rate, (offset_txagc[path] + hw_rate),
+		     power_index);
+	return true;
+}
+
+void phydm_init_hw_info_by_rfe_type_8822b(struct phy_dm_struct *dm)
+{
+	u16 mask_path_a = 0x0303;
+	u16 mask_path_b = 0x0c0c;
+	/*u16	mask_path_c = 0x3030;*/
+	/*u16	mask_path_d = 0xc0c0;*/
+
+	dm->is_init_hw_info_by_rfe = false;
+
+	if ((dm->rfe_type == 1) || (dm->rfe_type == 6) || (dm->rfe_type == 7)) {
+		odm_cmn_info_init(dm, ODM_CMNINFO_BOARD_TYPE,
+				  (ODM_BOARD_EXT_LNA | ODM_BOARD_EXT_LNA_5G |
+				   ODM_BOARD_EXT_PA | ODM_BOARD_EXT_PA_5G));
+
+		if (dm->rfe_type == 6) {
+			odm_cmn_info_init(
+				dm, ODM_CMNINFO_GPA,
+				(TYPE_GPA1 & (mask_path_a | mask_path_b)));
+			odm_cmn_info_init(
+				dm, ODM_CMNINFO_APA,
+				(TYPE_APA1 & (mask_path_a | mask_path_b)));
+			odm_cmn_info_init(
+				dm, ODM_CMNINFO_GLNA,
+				(TYPE_GLNA1 & (mask_path_a | mask_path_b)));
+			odm_cmn_info_init(
+				dm, ODM_CMNINFO_ALNA,
+				(TYPE_ALNA1 & (mask_path_a | mask_path_b)));
+		} else if (dm->rfe_type == 7) {
+			odm_cmn_info_init(
+				dm, ODM_CMNINFO_GPA,
+				(TYPE_GPA2 & (mask_path_a | mask_path_b)));
+			odm_cmn_info_init(
+				dm, ODM_CMNINFO_APA,
+				(TYPE_APA2 & (mask_path_a | mask_path_b)));
+			odm_cmn_info_init(
+				dm, ODM_CMNINFO_GLNA,
+				(TYPE_GLNA2 & (mask_path_a | mask_path_b)));
+			odm_cmn_info_init(
+				dm, ODM_CMNINFO_ALNA,
+				(TYPE_ALNA2 & (mask_path_a | mask_path_b)));
+		} else {
+			odm_cmn_info_init(
+				dm, ODM_CMNINFO_GPA,
+				(TYPE_GPA0 & (mask_path_a | mask_path_b)));
+			odm_cmn_info_init(
+				dm, ODM_CMNINFO_APA,
+				(TYPE_APA0 & (mask_path_a | mask_path_b)));
+			odm_cmn_info_init(
+				dm, ODM_CMNINFO_GLNA,
+				(TYPE_GLNA0 & (mask_path_a | mask_path_b)));
+			odm_cmn_info_init(
+				dm, ODM_CMNINFO_ALNA,
+				(TYPE_ALNA0 & (mask_path_a | mask_path_b)));
+		}
+
+		odm_cmn_info_init(dm, ODM_CMNINFO_PACKAGE_TYPE, 1);
+
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_LNA, true);
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_LNA, true);
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_PA, true);
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_PA, true);
+	} else if (dm->rfe_type == 2) {
+		odm_cmn_info_init(dm, ODM_CMNINFO_BOARD_TYPE,
+				  (ODM_BOARD_EXT_LNA_5G | ODM_BOARD_EXT_PA_5G));
+		odm_cmn_info_init(dm, ODM_CMNINFO_APA,
+				  (TYPE_APA0 & (mask_path_a | mask_path_b)));
+		odm_cmn_info_init(dm, ODM_CMNINFO_ALNA,
+				  (TYPE_ALNA0 & (mask_path_a | mask_path_b)));
+
+		odm_cmn_info_init(dm, ODM_CMNINFO_PACKAGE_TYPE, 2);
+
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_LNA, false);
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_LNA, true);
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_PA, false);
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_PA, true);
+	} else if (dm->rfe_type == 9) {
+		odm_cmn_info_init(dm, ODM_CMNINFO_BOARD_TYPE,
+				  (ODM_BOARD_EXT_LNA_5G));
+		odm_cmn_info_init(dm, ODM_CMNINFO_ALNA,
+				  (TYPE_ALNA0 & (mask_path_a | mask_path_b)));
+
+		odm_cmn_info_init(dm, ODM_CMNINFO_PACKAGE_TYPE, 1);
+
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_LNA, false);
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_LNA, true);
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_PA, false);
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_PA, false);
+	} else if ((dm->rfe_type == 3) || (dm->rfe_type == 5)) {
+		/* RFE type 3: 8822BS\8822BU TFBGA iFEM */
+		/* RFE type 5: 8822BE TFBGA iFEM */
+		odm_cmn_info_init(dm, ODM_CMNINFO_BOARD_TYPE, 0);
+
+		odm_cmn_info_init(dm, ODM_CMNINFO_PACKAGE_TYPE, 2);
+
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_LNA, false);
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_LNA, false);
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_PA, false);
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_PA, false);
+	} else if (dm->rfe_type == 4) {
+		odm_cmn_info_init(dm, ODM_CMNINFO_BOARD_TYPE,
+				  (ODM_BOARD_EXT_LNA | ODM_BOARD_EXT_LNA_5G |
+				   ODM_BOARD_EXT_PA | ODM_BOARD_EXT_PA_5G));
+		odm_cmn_info_init(dm, ODM_CMNINFO_GPA,
+				  (TYPE_GPA0 & (mask_path_a | mask_path_b)));
+		odm_cmn_info_init(dm, ODM_CMNINFO_APA,
+				  (TYPE_APA0 & (mask_path_a | mask_path_b)));
+		odm_cmn_info_init(dm, ODM_CMNINFO_GLNA,
+				  (TYPE_GLNA0 & (mask_path_a | mask_path_b)));
+		odm_cmn_info_init(dm, ODM_CMNINFO_ALNA,
+				  (TYPE_ALNA0 & (mask_path_a | mask_path_b)));
+
+		odm_cmn_info_init(dm, ODM_CMNINFO_PACKAGE_TYPE, 2);
+
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_LNA, true);
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_LNA, true);
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_PA, true);
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_PA, true);
+	} else if (dm->rfe_type == 8) {
+		/* RFE type 8: TFBGA iFEM AP */
+		odm_cmn_info_init(dm, ODM_CMNINFO_BOARD_TYPE, 0);
+
+		odm_cmn_info_init(dm, ODM_CMNINFO_PACKAGE_TYPE, 2);
+
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_LNA, false);
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_LNA, false);
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_PA, false);
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_PA, false);
+	} else {
+		/* RFE Type 0 & 9 & 10: QFN iFEM */
+		odm_cmn_info_init(dm, ODM_CMNINFO_BOARD_TYPE, 0);
+
+		odm_cmn_info_init(dm, ODM_CMNINFO_PACKAGE_TYPE, 1);
+
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_LNA, false);
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_LNA, false);
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_PA, false);
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_PA, false);
+	}
+
+	dm->is_init_hw_info_by_rfe = true;
+
+	ODM_RT_TRACE(
+		dm, ODM_PHY_CONFIG,
+		"%s(): RFE type (%d), Board type (0x%x), Package type (%d)\n",
+		__func__, dm->rfe_type, dm->board_type, dm->package_type);
+	ODM_RT_TRACE(
+		dm, ODM_PHY_CONFIG,
+		"%s(): 5G ePA (%d), 5G eLNA (%d), 2G ePA (%d), 2G eLNA (%d)\n",
+		__func__, dm->ext_pa_5g, dm->ext_lna_5g, dm->ext_pa,
+		dm->ext_lna);
+	ODM_RT_TRACE(
+		dm, ODM_PHY_CONFIG,
+		"%s(): 5G PA type (%d), 5G LNA type (%d), 2G PA type (%d), 2G LNA type (%d)\n",
+		__func__, dm->type_apa, dm->type_alna, dm->type_gpa,
+		dm->type_glna);
+}
+
+s32 phydm_get_condition_number_8822B(struct phy_dm_struct *dm)
+{
+	s32 ret_val;
+
+	odm_set_bb_reg(dm, 0x1988, BIT(22), 0x1);
+	ret_val =
+		(s32)odm_get_bb_reg(dm, 0xf84, (BIT(17) | BIT(16) | MASKLWORD));
+
+	if (bw_8822b == 0) {
+		ret_val = ret_val << (8 - 4);
+		ret_val = ret_val / 234;
+	} else if (bw_8822b == 1) {
+		ret_val = ret_val << (7 - 4);
+		ret_val = ret_val / 108;
+	} else if (bw_8822b == 2) {
+		ret_val = ret_val << (6 - 4);
+		ret_val = ret_val / 52;
+	}
+
+	return ret_val;
+}
+
+/* ======================================================================== */
+
+/* ======================================================================== */
+/* These following functions can be used by driver*/
+
+u32 config_phydm_read_rf_reg_8822b(struct phy_dm_struct *dm,
+				   enum odm_rf_radio_path rf_path, u32 reg_addr,
+				   u32 bit_mask)
+{
+	u32 readback_value, direct_addr;
+	u32 offset_read_rf[2] = {0x2800, 0x2c00};
+	u32 power_RF[2] = {0x1c, 0xec};
+
+	/* Error handling.*/
+	if (rf_path > ODM_RF_PATH_B) {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): unsupported path (%d)\n", __func__,
+			     rf_path);
+		return INVALID_RF_DATA;
+	}
+
+	/*  Error handling. Check if RF power is enable or not */
+	/*  0xffffffff means RF power is disable */
+	if (odm_get_mac_reg(dm, power_RF[rf_path], MASKBYTE3) != 0x7) {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): Read fail, RF is disabled\n", __func__);
+		return INVALID_RF_DATA;
+	}
+
+	/* Calculate offset */
+	reg_addr &= 0xff;
+	direct_addr = offset_read_rf[rf_path] + (reg_addr << 2);
+
+	/* RF register only has 20bits */
+	bit_mask &= RFREGOFFSETMASK;
+
+	/* Read RF register directly */
+	readback_value = odm_get_bb_reg(dm, direct_addr, bit_mask);
+	ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+		     "%s(): RF-%d 0x%x = 0x%x, bit mask = 0x%x\n", __func__,
+		     rf_path, reg_addr, readback_value, bit_mask);
+	return readback_value;
+}
+
+bool config_phydm_write_rf_reg_8822b(struct phy_dm_struct *dm,
+				     enum odm_rf_radio_path rf_path,
+				     u32 reg_addr, u32 bit_mask, u32 data)
+{
+	u32 data_and_addr = 0, data_original = 0;
+	u32 offset_write_rf[2] = {0xc90, 0xe90};
+	u32 power_RF[2] = {0x1c, 0xec};
+
+	/* Error handling.*/
+	if (rf_path > ODM_RF_PATH_B) {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): unsupported path (%d)\n", __func__,
+			     rf_path);
+		return false;
+	}
+
+	/* Read RF register content first */
+	reg_addr &= 0xff;
+	bit_mask = bit_mask & RFREGOFFSETMASK;
+
+	if (bit_mask != RFREGOFFSETMASK) {
+		data_original = config_phydm_read_rf_reg_8822b(
+			dm, rf_path, reg_addr, RFREGOFFSETMASK);
+
+		/* Error handling. RF is disabled */
+		if (!config_phydm_read_rf_check_8822b(data_original)) {
+			ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+				     "%s(): Write fail, RF is disable\n",
+				     __func__);
+			return false;
+		}
+
+		/* check bit mask */
+		data = phydm_check_bit_mask(bit_mask, data_original, data);
+	} else if (odm_get_mac_reg(dm, power_RF[rf_path], MASKBYTE3) != 0x7) {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): Write fail, RF is disabled\n", __func__);
+		return false;
+	}
+
+	/* Put write addr in [27:20]  and write data in [19:00] */
+	data_and_addr = ((reg_addr << 20) | (data & 0x000fffff)) & 0x0fffffff;
+
+	/* Write operation */
+	odm_set_bb_reg(dm, offset_write_rf[rf_path], MASKDWORD, data_and_addr);
+	ODM_RT_TRACE(
+		dm, ODM_PHY_CONFIG,
+		"%s(): RF-%d 0x%x = 0x%x (original: 0x%x), bit mask = 0x%x\n",
+		__func__, rf_path, reg_addr, data, data_original, bit_mask);
+	return true;
+}
+
+bool config_phydm_write_txagc_8822b(struct phy_dm_struct *dm, u32 power_index,
+				    enum odm_rf_radio_path path, u8 hw_rate)
+{
+	u32 offset_txagc[2] = {0x1d00, 0x1d80};
+	u8 rate_idx = (hw_rate & 0xfc);
+
+	/* Input need to be HW rate index, not driver rate index!!!! */
+
+	if (dm->is_disable_phy_api) {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): disable PHY API for debug!!\n", __func__);
+		return true;
+	}
+
+	/* Error handling */
+	if ((path > ODM_RF_PATH_B) || (hw_rate > 0x53)) {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): unsupported path (%d)\n", __func__, path);
+		return false;
+	}
+
+	/* driver need to construct a 4-byte power index */
+	odm_set_bb_reg(dm, (offset_txagc[path] + rate_idx), MASKDWORD,
+		       power_index);
+
+	ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+		     "%s(): path-%d rate index 0x%x (0x%x) = 0x%x\n", __func__,
+		     path, hw_rate, (offset_txagc[path] + hw_rate),
+		     power_index);
+	return true;
+}
+
+u8 config_phydm_read_txagc_8822b(struct phy_dm_struct *dm,
+				 enum odm_rf_radio_path path, u8 hw_rate)
+{
+	u8 read_back_data;
+
+	/* Input need to be HW rate index, not driver rate index!!!! */
+
+	/* Error handling */
+	if ((path > ODM_RF_PATH_B) || (hw_rate > 0x53)) {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): unsupported path (%d)\n", __func__, path);
+		return INVALID_TXAGC_DATA;
+	}
+
+	/* Disable TX AGC report */
+	odm_set_bb_reg(dm, 0x1998, BIT(16), 0x0); /* need to check */
+
+	/* Set data rate index (bit0~6) and path index (bit7) */
+	odm_set_bb_reg(dm, 0x1998, MASKBYTE0, (hw_rate | (path << 7)));
+
+	/* Enable TXAGC report */
+	odm_set_bb_reg(dm, 0x1998, BIT(16), 0x1);
+
+	/* Read TX AGC report */
+	read_back_data = (u8)odm_get_bb_reg(dm, 0xd30, 0x7f0000);
+
+	/* Driver have to disable TXAGC report after reading TXAGC
+	 * (ref. user guide v11)
+	 */
+	odm_set_bb_reg(dm, 0x1998, BIT(16), 0x0);
+
+	ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+		     "%s(): path-%d rate index 0x%x = 0x%x\n", __func__, path,
+		     hw_rate, read_back_data);
+	return read_back_data;
+}
+
+bool config_phydm_switch_band_8822b(struct phy_dm_struct *dm, u8 central_ch)
+{
+	u32 rf_reg18;
+	bool rf_reg_status = true;
+
+	ODM_RT_TRACE(dm, ODM_PHY_CONFIG, "%s()======================>\n",
+		     __func__);
+
+	if (dm->is_disable_phy_api) {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): disable PHY API for debug!!\n", __func__);
+		return true;
+	}
+
+	rf_reg18 = config_phydm_read_rf_reg_8822b(dm, ODM_RF_PATH_A, 0x18,
+						  RFREGOFFSETMASK);
+	rf_reg_status =
+		rf_reg_status & config_phydm_read_rf_check_8822b(rf_reg18);
+
+	if (central_ch <= 14) {
+		/* 2.4G */
+
+		/* Enable CCK block */
+		odm_set_bb_reg(dm, 0x808, BIT(28), 0x1);
+
+		/* Disable MAC CCK check */
+		odm_set_bb_reg(dm, 0x454, BIT(7), 0x0);
+
+		/* Disable BB CCK check */
+		odm_set_bb_reg(dm, 0xa80, BIT(18), 0x0);
+
+		/*CCA Mask*/
+		odm_set_bb_reg(dm, 0x814, 0x0000FC00, 15); /*default value*/
+
+		/* RF band */
+		rf_reg18 = (rf_reg18 & (~(BIT(16) | BIT(9) | BIT(8))));
+
+		/* RxHP dynamic control */
+		if ((dm->rfe_type == 2) || (dm->rfe_type == 3) ||
+		    (dm->rfe_type == 5)) {
+			odm_set_bb_reg(dm, 0x8cc, MASKDWORD, 0x08108492);
+			odm_set_bb_reg(dm, 0x8d8, MASKDWORD, 0x29095612);
+		}
+
+	} else if (central_ch > 35) {
+		/* 5G */
+
+		/* Enable BB CCK check */
+		odm_set_bb_reg(dm, 0xa80, BIT(18), 0x1);
+
+		/* Enable CCK check */
+		odm_set_bb_reg(dm, 0x454, BIT(7), 0x1);
+
+		/* Disable CCK block */
+		odm_set_bb_reg(dm, 0x808, BIT(28), 0x0);
+
+		/*CCA Mask*/
+		odm_set_bb_reg(dm, 0x814, 0x0000FC00, 15); /*default value*/
+
+		/* RF band */
+		rf_reg18 = (rf_reg18 & (~(BIT(16) | BIT(9) | BIT(8))));
+		rf_reg18 = (rf_reg18 | BIT(8) | BIT(16));
+
+		/* RxHP dynamic control */
+		if ((dm->rfe_type == 2) || (dm->rfe_type == 3) ||
+		    (dm->rfe_type == 5)) {
+			odm_set_bb_reg(dm, 0x8cc, MASKDWORD, 0x08100000);
+			odm_set_bb_reg(dm, 0x8d8, MASKDWORD, 0x21095612);
+		}
+
+	} else {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): Fail to switch band (ch: %d)\n", __func__,
+			     central_ch);
+		return false;
+	}
+
+	rf_reg_status = rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0x18,
+						RFREGOFFSETMASK, rf_reg18);
+
+	if (dm->rf_type > ODM_1T1R)
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_B, 0x18,
+						RFREGOFFSETMASK, rf_reg18);
+
+	if (!phydm_rfe_8822b(dm, central_ch))
+		return false;
+
+	if (!rf_reg_status) {
+		ODM_RT_TRACE(
+			dm, ODM_PHY_CONFIG,
+			"%s(): Fail to switch band (ch: %d), because writing RF register is fail\n",
+			__func__, central_ch);
+		return false;
+	}
+
+	ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+		     "%s(): Success to switch band (ch: %d)\n", __func__,
+		     central_ch);
+	return true;
+}
+
+bool config_phydm_switch_channel_8822b(struct phy_dm_struct *dm, u8 central_ch)
+{
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+	u32 rf_reg18 = 0, rf_reg_b8 = 0, rf_reg_be = 0xff;
+	bool rf_reg_status = true;
+	u8 low_band[15] = {0x7, 0x6, 0x6, 0x5, 0x0, 0x0, 0x7, 0xff,
+			   0x6, 0x5, 0x0, 0x0, 0x7, 0x6, 0x6};
+	u8 middle_band[23] = {0x6, 0x5, 0x0, 0x0, 0x7, 0x6, 0x6, 0xff,
+			      0x0, 0x0, 0x7, 0x6, 0x6, 0x5, 0x0, 0xff,
+			      0x7, 0x6, 0x6, 0x5, 0x0, 0x0, 0x7};
+	u8 high_band[15] = {0x5, 0x5, 0x0, 0x7, 0x7, 0x6, 0x5, 0xff,
+			    0x0, 0x7, 0x7, 0x6, 0x5, 0x5, 0x0};
+
+	ODM_RT_TRACE(dm, ODM_PHY_CONFIG, "%s()====================>\n",
+		     __func__);
+
+	if (dm->is_disable_phy_api) {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): disable PHY API for debug!!\n", __func__);
+		return true;
+	}
+
+	central_ch_8822b = central_ch;
+	rf_reg18 = config_phydm_read_rf_reg_8822b(dm, ODM_RF_PATH_A, 0x18,
+						  RFREGOFFSETMASK);
+	rf_reg_status =
+		rf_reg_status & config_phydm_read_rf_check_8822b(rf_reg18);
+	rf_reg18 = (rf_reg18 & (~(BIT(18) | BIT(17) | MASKBYTE0)));
+
+	if (dm->cut_version == ODM_CUT_A) {
+		rf_reg_b8 = config_phydm_read_rf_reg_8822b(
+			dm, ODM_RF_PATH_A, 0xb8, RFREGOFFSETMASK);
+		rf_reg_status = rf_reg_status &
+				config_phydm_read_rf_check_8822b(rf_reg_b8);
+	}
+
+	/* Switch band and channel */
+	if (central_ch <= 14) {
+		/* 2.4G */
+
+		/* 1. RF band and channel*/
+		rf_reg18 = (rf_reg18 | central_ch);
+
+		/* 2. AGC table selection */
+		odm_set_bb_reg(dm, 0x958, 0x1f, 0x0);
+		dig_tab->agc_table_idx = 0x0;
+
+		/* 3. Set central frequency for clock offset tracking */
+		odm_set_bb_reg(dm, 0x860, 0x1ffe0000, 0x96a);
+
+		/* Fix A-cut LCK fail issue @ 5285MHz~5375MHz, 0xb8[19]=0x0 */
+		if (dm->cut_version == ODM_CUT_A)
+			rf_reg_b8 = rf_reg_b8 | BIT(19);
+
+		/* CCK TX filter parameters */
+		if (central_ch == 14) {
+			odm_set_bb_reg(dm, 0xa20, MASKHWORD, 0x8488);
+			odm_set_bb_reg(dm, 0xa24, MASKDWORD, 0x00006577);
+			odm_set_bb_reg(dm, 0xa28, MASKLWORD, 0x0000);
+		} else {
+			odm_set_bb_reg(dm, 0xa20, MASKHWORD,
+				       (rega20_8822b >> 16));
+			odm_set_bb_reg(dm, 0xa24, MASKDWORD, rega24_8822b);
+			odm_set_bb_reg(dm, 0xa28, MASKLWORD,
+				       (rega28_8822b & MASKLWORD));
+		}
+
+	} else if (central_ch > 35) {
+		/* 5G */
+
+		/* 1. RF band and channel*/
+		rf_reg18 = (rf_reg18 | central_ch);
+
+		/* 2. AGC table selection */
+		if ((central_ch >= 36) && (central_ch <= 64)) {
+			odm_set_bb_reg(dm, 0x958, 0x1f, 0x1);
+			dig_tab->agc_table_idx = 0x1;
+		} else if ((central_ch >= 100) && (central_ch <= 144)) {
+			odm_set_bb_reg(dm, 0x958, 0x1f, 0x2);
+			dig_tab->agc_table_idx = 0x2;
+		} else if (central_ch >= 149) {
+			odm_set_bb_reg(dm, 0x958, 0x1f, 0x3);
+			dig_tab->agc_table_idx = 0x3;
+		} else {
+			ODM_RT_TRACE(
+				dm, ODM_PHY_CONFIG,
+				"%s(): Fail to switch channel (AGC) (ch: %d)\n",
+				__func__, central_ch);
+			return false;
+		}
+
+		/* 3. Set central frequency for clock offset tracking */
+		if ((central_ch >= 36) && (central_ch <= 48)) {
+			odm_set_bb_reg(dm, 0x860, 0x1ffe0000, 0x494);
+		} else if ((central_ch >= 52) && (central_ch <= 64)) {
+			odm_set_bb_reg(dm, 0x860, 0x1ffe0000, 0x453);
+		} else if ((central_ch >= 100) && (central_ch <= 116)) {
+			odm_set_bb_reg(dm, 0x860, 0x1ffe0000, 0x452);
+		} else if ((central_ch >= 118) && (central_ch <= 177)) {
+			odm_set_bb_reg(dm, 0x860, 0x1ffe0000, 0x412);
+		} else {
+			ODM_RT_TRACE(
+				dm, ODM_PHY_CONFIG,
+				"%s(): Fail to switch channel (fc_area) (ch: %d)\n",
+				__func__, central_ch);
+			return false;
+		}
+
+		/* Fix A-cut LCK fail issue @ 5285MHz~5375MHz, 0xb8[19]=0x0 */
+		if (dm->cut_version == ODM_CUT_A) {
+			if ((central_ch >= 57) && (central_ch <= 75))
+				rf_reg_b8 = rf_reg_b8 & (~BIT(19));
+			else
+				rf_reg_b8 = rf_reg_b8 | BIT(19);
+		}
+	} else {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): Fail to switch channel (ch: %d)\n",
+			     __func__, central_ch);
+		return false;
+	}
+
+	/* Modify IGI for MP driver to aviod PCIE interference */
+	if (dm->mp_mode && ((dm->rfe_type == 3) || (dm->rfe_type == 5))) {
+		if (central_ch == 14)
+			odm_write_dig(dm, 0x26);
+		else
+			odm_write_dig(dm, 0x20);
+	}
+
+	/* Modify the setting of register 0xBE to reduce phase noise */
+	if (central_ch <= 14)
+		rf_reg_be = 0x0;
+	else if ((central_ch >= 36) && (central_ch <= 64))
+		rf_reg_be = low_band[(central_ch - 36) >> 1];
+	else if ((central_ch >= 100) && (central_ch <= 144))
+		rf_reg_be = middle_band[(central_ch - 100) >> 1];
+	else if ((central_ch >= 149) && (central_ch <= 177))
+		rf_reg_be = high_band[(central_ch - 149) >> 1];
+	else
+		rf_reg_be = 0xff;
+
+	if (rf_reg_be != 0xff) {
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0xbe,
+						(BIT(17) | BIT(16) | BIT(15)),
+						rf_reg_be);
+	} else {
+		ODM_RT_TRACE(
+			dm, ODM_PHY_CONFIG,
+			"%s(): Fail to switch channel (ch: %d, Phase noise)\n",
+			__func__, central_ch);
+		return false;
+	}
+
+	/* Fix channel 144 issue, ask by RFSI Alvin*/
+	/* 00 when freq < 5400;  01 when 5400<=freq<=5720; 10 when freq > 5720;
+	 * 2G don't care
+	 */
+	/* need to set 0xdf[18]=1 before writing RF18 when channel 144 */
+	if (central_ch == 144) {
+		rf_reg_status = rf_reg_status &
+				config_phydm_write_rf_reg_8822b(
+					dm, ODM_RF_PATH_A, 0xdf, BIT(18), 0x1);
+		rf_reg18 = (rf_reg18 | BIT(17));
+	} else {
+		rf_reg_status = rf_reg_status &
+				config_phydm_write_rf_reg_8822b(
+					dm, ODM_RF_PATH_A, 0xdf, BIT(18), 0x0);
+
+		if (central_ch > 144)
+			rf_reg18 = (rf_reg18 | BIT(18));
+		else if (central_ch >= 80)
+			rf_reg18 = (rf_reg18 | BIT(17));
+	}
+
+	rf_reg_status = rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0x18,
+						RFREGOFFSETMASK, rf_reg18);
+
+	if (dm->cut_version == ODM_CUT_A)
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0xb8,
+						RFREGOFFSETMASK, rf_reg_b8);
+
+	if (dm->rf_type > ODM_1T1R) {
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_B, 0x18,
+						RFREGOFFSETMASK, rf_reg18);
+
+		if (dm->cut_version == ODM_CUT_A)
+			rf_reg_status = rf_reg_status &
+					config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_B, 0xb8,
+						RFREGOFFSETMASK, rf_reg_b8);
+	}
+
+	if (!rf_reg_status) {
+		ODM_RT_TRACE(
+			dm, ODM_PHY_CONFIG,
+			"%s(): Fail to switch channel (ch: %d), because writing RF register is fail\n",
+			__func__, central_ch);
+		return false;
+	}
+
+	phydm_ccapar_by_rfe_8822b(dm);
+	ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+		     "%s(): Success to switch channel (ch: %d)\n", __func__,
+		     central_ch);
+	return true;
+}
+
+bool config_phydm_switch_bandwidth_8822b(struct phy_dm_struct *dm,
+					 u8 primary_ch_idx,
+					 enum odm_bw bandwidth)
+{
+	u32 rf_reg18;
+	bool rf_reg_status = true;
+	u8 IGI = 0;
+
+	ODM_RT_TRACE(dm, ODM_PHY_CONFIG, "%s()===================>\n",
+		     __func__);
+
+	if (dm->is_disable_phy_api) {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): disable PHY API for debug!!\n", __func__);
+		return true;
+	}
+
+	/* Error handling */
+	if ((bandwidth >= ODM_BW_MAX) ||
+	    ((bandwidth == ODM_BW40M) && (primary_ch_idx > 2)) ||
+	    ((bandwidth == ODM_BW80M) && (primary_ch_idx > 4))) {
+		ODM_RT_TRACE(
+			dm, ODM_PHY_CONFIG,
+			"%s(): Fail to switch bandwidth (bw: %d, primary ch: %d)\n",
+			__func__, bandwidth, primary_ch_idx);
+		return false;
+	}
+
+	bw_8822b = bandwidth;
+	rf_reg18 = config_phydm_read_rf_reg_8822b(dm, ODM_RF_PATH_A, 0x18,
+						  RFREGOFFSETMASK);
+	rf_reg_status =
+		rf_reg_status & config_phydm_read_rf_check_8822b(rf_reg18);
+
+	/* Switch bandwidth */
+	switch (bandwidth) {
+	case ODM_BW20M: {
+		/* Small BW([7:6]) = 0, primary channel ([5:2]) = 0,
+		 * rf mode([1:0]) = 20M
+		 */
+		odm_set_bb_reg(dm, 0x8ac, MASKBYTE0, ODM_BW20M);
+
+		/* ADC clock = 160M clock for BW20 */
+		odm_set_bb_reg(dm, 0x8ac, (BIT(9) | BIT(8)), 0x0);
+		odm_set_bb_reg(dm, 0x8ac, BIT(16), 0x1);
+
+		/* DAC clock = 160M clock for BW20 */
+		odm_set_bb_reg(dm, 0x8ac, (BIT(21) | BIT(20)), 0x0);
+		odm_set_bb_reg(dm, 0x8ac, BIT(28), 0x1);
+
+		/* ADC buffer clock */
+		odm_set_bb_reg(dm, 0x8c4, BIT(30), 0x1);
+
+		/* RF bandwidth */
+		rf_reg18 = (rf_reg18 | BIT(11) | BIT(10));
+
+		break;
+	}
+	case ODM_BW40M: {
+		/* Small BW([7:6]) = 0, primary channel ([5:2]) = sub-channel,
+		 * rf mode([1:0]) = 40M
+		 */
+		odm_set_bb_reg(dm, 0x8ac, MASKBYTE0,
+			       (((primary_ch_idx & 0xf) << 2) | ODM_BW40M));
+
+		/* CCK primary channel */
+		if (primary_ch_idx == 1)
+			odm_set_bb_reg(dm, 0xa00, BIT(4), primary_ch_idx);
+		else
+			odm_set_bb_reg(dm, 0xa00, BIT(4), 0);
+
+		/* ADC clock = 160M clock for BW40 */
+		odm_set_bb_reg(dm, 0x8ac, (BIT(11) | BIT(10)), 0x0);
+		odm_set_bb_reg(dm, 0x8ac, BIT(17), 0x1);
+
+		/* DAC clock = 160M clock for BW20 */
+		odm_set_bb_reg(dm, 0x8ac, (BIT(23) | BIT(22)), 0x0);
+		odm_set_bb_reg(dm, 0x8ac, BIT(29), 0x1);
+
+		/* ADC buffer clock */
+		odm_set_bb_reg(dm, 0x8c4, BIT(30), 0x1);
+
+		/* RF bandwidth */
+		rf_reg18 = (rf_reg18 & (~(BIT(11) | BIT(10))));
+		rf_reg18 = (rf_reg18 | BIT(11));
+
+		break;
+	}
+	case ODM_BW80M: {
+		/* Small BW([7:6]) = 0, primary channel ([5:2]) = sub-channel,
+		 * rf mode([1:0]) = 80M
+		 */
+		odm_set_bb_reg(dm, 0x8ac, MASKBYTE0,
+			       (((primary_ch_idx & 0xf) << 2) | ODM_BW80M));
+
+		/* ADC clock = 160M clock for BW80 */
+		odm_set_bb_reg(dm, 0x8ac, (BIT(13) | BIT(12)), 0x0);
+		odm_set_bb_reg(dm, 0x8ac, BIT(18), 0x1);
+
+		/* DAC clock = 160M clock for BW20 */
+		odm_set_bb_reg(dm, 0x8ac, (BIT(25) | BIT(24)), 0x0);
+		odm_set_bb_reg(dm, 0x8ac, BIT(30), 0x1);
+
+		/* ADC buffer clock */
+		odm_set_bb_reg(dm, 0x8c4, BIT(30), 0x1);
+
+		/* RF bandwidth */
+		rf_reg18 = (rf_reg18 & (~(BIT(11) | BIT(10))));
+		rf_reg18 = (rf_reg18 | BIT(10));
+
+		break;
+	}
+	case ODM_BW5M: {
+		/* Small BW([7:6]) = 1, primary channel ([5:2]) = 0,
+		 * rf mode([1:0]) = 20M
+		 */
+		odm_set_bb_reg(dm, 0x8ac, MASKBYTE0, (BIT(6) | ODM_BW20M));
+
+		/* ADC clock = 40M clock */
+		odm_set_bb_reg(dm, 0x8ac, (BIT(9) | BIT(8)), 0x2);
+		odm_set_bb_reg(dm, 0x8ac, BIT(16), 0x0);
+
+		/* DAC clock = 160M clock for BW20 */
+		odm_set_bb_reg(dm, 0x8ac, (BIT(21) | BIT(20)), 0x2);
+		odm_set_bb_reg(dm, 0x8ac, BIT(28), 0x0);
+
+		/* ADC buffer clock */
+		odm_set_bb_reg(dm, 0x8c4, BIT(30), 0x0);
+		odm_set_bb_reg(dm, 0x8c8, BIT(31), 0x1);
+
+		/* RF bandwidth */
+		rf_reg18 = (rf_reg18 | BIT(11) | BIT(10));
+
+		break;
+	}
+	case ODM_BW10M: {
+		/* Small BW([7:6]) = 1, primary channel ([5:2]) = 0,
+		 * rf mode([1:0]) = 20M
+		 */
+		odm_set_bb_reg(dm, 0x8ac, MASKBYTE0, (BIT(7) | ODM_BW20M));
+
+		/* ADC clock = 80M clock */
+		odm_set_bb_reg(dm, 0x8ac, (BIT(9) | BIT(8)), 0x3);
+		odm_set_bb_reg(dm, 0x8ac, BIT(16), 0x0);
+
+		/* DAC clock = 160M clock for BW20 */
+		odm_set_bb_reg(dm, 0x8ac, (BIT(21) | BIT(20)), 0x3);
+		odm_set_bb_reg(dm, 0x8ac, BIT(28), 0x0);
+
+		/* ADC buffer clock */
+		odm_set_bb_reg(dm, 0x8c4, BIT(30), 0x0);
+		odm_set_bb_reg(dm, 0x8c8, BIT(31), 0x1);
+
+		/* RF bandwidth */
+		rf_reg18 = (rf_reg18 | BIT(11) | BIT(10));
+
+		break;
+	}
+	default:
+		ODM_RT_TRACE(
+			dm, ODM_PHY_CONFIG,
+			"%s(): Fail to switch bandwidth (bw: %d, primary ch: %d)\n",
+			__func__, bandwidth, primary_ch_idx);
+	}
+
+	/* Write RF register */
+	rf_reg_status = rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0x18,
+						RFREGOFFSETMASK, rf_reg18);
+
+	if (dm->rf_type > ODM_1T1R)
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_B, 0x18,
+						RFREGOFFSETMASK, rf_reg18);
+
+	if (!rf_reg_status) {
+		ODM_RT_TRACE(
+			dm, ODM_PHY_CONFIG,
+			"%s(): Fail to switch bandwidth (bw: %d, primary ch: %d), because writing RF register is fail\n",
+			__func__, bandwidth, primary_ch_idx);
+		return false;
+	}
+
+	/* Modify RX DFIR parameters */
+	phydm_rxdfirpar_by_bw_8822b(dm, bandwidth);
+
+	/* Modify CCA parameters */
+	phydm_ccapar_by_bw_8822b(dm, bandwidth);
+	phydm_ccapar_by_rfe_8822b(dm);
+
+	/* Toggle RX path to avoid RX dead zone issue */
+	odm_set_bb_reg(dm, 0x808, MASKBYTE0, 0x0);
+	odm_set_bb_reg(dm, 0x808, MASKBYTE0,
+		       (dm->rx_ant_status | (dm->rx_ant_status << 4)));
+
+	/* Toggle IGI to let RF enter RX mode */
+	IGI = (u8)odm_get_bb_reg(dm, ODM_REG(IGI_A, dm), ODM_BIT(IGI, dm));
+	odm_set_bb_reg(dm, ODM_REG(IGI_A, dm), ODM_BIT(IGI, dm), IGI - 2);
+	odm_set_bb_reg(dm, ODM_REG(IGI_B, dm), ODM_BIT(IGI, dm), IGI - 2);
+	odm_set_bb_reg(dm, ODM_REG(IGI_A, dm), ODM_BIT(IGI, dm), IGI);
+	odm_set_bb_reg(dm, ODM_REG(IGI_B, dm), ODM_BIT(IGI, dm), IGI);
+
+	ODM_RT_TRACE(
+		dm, ODM_PHY_CONFIG,
+		"%s(): Success to switch bandwidth (bw: %d, primary ch: %d)\n",
+		__func__, bandwidth, primary_ch_idx);
+	return true;
+}
+
+bool config_phydm_switch_channel_bw_8822b(struct phy_dm_struct *dm,
+					  u8 central_ch, u8 primary_ch_idx,
+					  enum odm_bw bandwidth)
+{
+	/* Switch band */
+	if (!config_phydm_switch_band_8822b(dm, central_ch))
+		return false;
+
+	/* Switch channel */
+	if (!config_phydm_switch_channel_8822b(dm, central_ch))
+		return false;
+
+	/* Switch bandwidth */
+	if (!config_phydm_switch_bandwidth_8822b(dm, primary_ch_idx, bandwidth))
+		return false;
+
+	return true;
+}
+
+bool config_phydm_trx_mode_8822b(struct phy_dm_struct *dm,
+				 enum odm_rf_path tx_path,
+				 enum odm_rf_path rx_path, bool is_tx2_path)
+{
+	bool rf_reg_status = true;
+	u8 IGI;
+	u32 rf_reg33 = 0;
+	u16 counter = 0;
+
+	ODM_RT_TRACE(dm, ODM_PHY_CONFIG, "%s()=====================>\n",
+		     __func__);
+
+	if (dm->is_disable_phy_api) {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): disable PHY API for debug!!\n", __func__);
+		return true;
+	}
+
+	if ((tx_path & (~(ODM_RF_A | ODM_RF_B))) != 0) {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): Wrong TX setting (TX: 0x%x)\n", __func__,
+			     tx_path);
+		return false;
+	}
+
+	if ((rx_path & (~(ODM_RF_A | ODM_RF_B))) != 0) {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): Wrong RX setting (RX: 0x%x)\n", __func__,
+			     rx_path);
+		return false;
+	}
+
+	/* RF mode of path-A and path-B */
+	/* Cannot shut down path-A, beacause synthesizer will be shut down when
+	 * path-A is in shut down mode
+	 */
+	if ((tx_path | rx_path) & ODM_RF_A)
+		odm_set_bb_reg(dm, 0xc08, MASKLWORD, 0x3231);
+	else
+		odm_set_bb_reg(dm, 0xc08, MASKLWORD, 0x1111);
+
+	if ((tx_path | rx_path) & ODM_RF_B)
+		odm_set_bb_reg(dm, 0xe08, MASKLWORD, 0x3231);
+	else
+		odm_set_bb_reg(dm, 0xe08, MASKLWORD, 0x1111);
+
+	/* Set TX antenna by Nsts */
+	odm_set_bb_reg(dm, 0x93c, (BIT(19) | BIT(18)), 0x3);
+	odm_set_bb_reg(dm, 0x80c, (BIT(29) | BIT(28)), 0x1);
+
+	/* Control CCK TX path by 0xa07[7] */
+	odm_set_bb_reg(dm, 0x80c, BIT(30), 0x1);
+
+	/* TX logic map and TX path en for Nsts = 1, and CCK TX path*/
+	if (tx_path & ODM_RF_A) {
+		odm_set_bb_reg(dm, 0x93c, 0xfff00000, 0x001);
+		odm_set_bb_reg(dm, 0xa04, 0xf0000000, 0x8);
+	} else if (tx_path & ODM_RF_B) {
+		odm_set_bb_reg(dm, 0x93c, 0xfff00000, 0x002);
+		odm_set_bb_reg(dm, 0xa04, 0xf0000000, 0x4);
+	}
+
+	/* TX logic map and TX path en for Nsts = 2*/
+	if ((tx_path == ODM_RF_A) || (tx_path == ODM_RF_B))
+		odm_set_bb_reg(dm, 0x940, 0xfff0, 0x01);
+	else
+		odm_set_bb_reg(dm, 0x940, 0xfff0, 0x43);
+
+	/* TX path enable */
+	odm_set_bb_reg(dm, 0x80c, MASKBYTE0, ((tx_path << 4) | tx_path));
+
+	/* Tx2path for 1ss */
+	if (!((tx_path == ODM_RF_A) || (tx_path == ODM_RF_B))) {
+		if (is_tx2_path || dm->mp_mode) {
+			/* 2Tx for OFDM */
+			odm_set_bb_reg(dm, 0x93c, 0xfff00000, 0x043);
+
+			/* 2Tx for CCK */
+			odm_set_bb_reg(dm, 0xa04, 0xf0000000, 0xc);
+		}
+	}
+
+	/* Always disable MRC for CCK CCA */
+	odm_set_bb_reg(dm, 0xa2c, BIT(22), 0x0);
+
+	/* Always disable MRC for CCK barker */
+	odm_set_bb_reg(dm, 0xa2c, BIT(18), 0x0);
+
+	/* CCK RX 1st and 2nd path setting*/
+	if (rx_path & ODM_RF_A)
+		odm_set_bb_reg(dm, 0xa04, 0x0f000000, 0x0);
+	else if (rx_path & ODM_RF_B)
+		odm_set_bb_reg(dm, 0xa04, 0x0f000000, 0x5);
+
+	/* RX path enable */
+	odm_set_bb_reg(dm, 0x808, MASKBYTE0, ((rx_path << 4) | rx_path));
+
+	if ((rx_path == ODM_RF_A) || (rx_path == ODM_RF_B)) {
+		/* 1R */
+
+		/* Disable MRC for CCA */
+		/* odm_set_bb_reg(dm, 0xa2c, BIT22, 0x0); */
+
+		/* Disable MRC for barker */
+		/* odm_set_bb_reg(dm, 0xa2c, BIT18, 0x0); */
+
+		/* Disable CCK antenna diversity */
+		/* odm_set_bb_reg(dm, 0xa00, BIT15, 0x0); */
+
+		/* Disable Antenna weighting */
+		odm_set_bb_reg(dm, 0x1904, BIT(16), 0x0);
+		odm_set_bb_reg(dm, 0x800, BIT(28), 0x0);
+		odm_set_bb_reg(dm, 0x850, BIT(23), 0x0);
+	} else {
+		/* 2R */
+
+		/* Enable MRC for CCA */
+		/* odm_set_bb_reg(dm, 0xa2c, BIT22, 0x1); */
+
+		/* Enable MRC for barker */
+		/* odm_set_bb_reg(dm, 0xa2c, BIT18, 0x1); */
+
+		/* Disable CCK antenna diversity */
+		/* odm_set_bb_reg(dm, 0xa00, BIT15, 0x0); */
+
+		/* Enable Antenna weighting */
+		odm_set_bb_reg(dm, 0x1904, BIT(16), 0x1);
+		odm_set_bb_reg(dm, 0x800, BIT(28), 0x1);
+		odm_set_bb_reg(dm, 0x850, BIT(23), 0x1);
+	}
+
+	/* Update TXRX antenna status for PHYDM */
+	dm->tx_ant_status = (tx_path & 0x3);
+	dm->rx_ant_status = (rx_path & 0x3);
+
+	/* MP driver need to support path-B TX\RX */
+
+	while (1) {
+		counter++;
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0xef,
+						RFREGOFFSETMASK, 0x80000);
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0x33,
+						RFREGOFFSETMASK, 0x00001);
+
+		ODM_delay_us(2);
+		rf_reg33 = config_phydm_read_rf_reg_8822b(
+			dm, ODM_RF_PATH_A, 0x33, RFREGOFFSETMASK);
+
+		if ((rf_reg33 == 0x00001) &&
+		    (config_phydm_read_rf_check_8822b(rf_reg33)))
+			break;
+		else if (counter == 100) {
+			ODM_RT_TRACE(
+				dm, ODM_PHY_CONFIG,
+				"%s(): Fail to set TRx mode setting, because writing RF mode table is fail\n",
+				__func__);
+			return false;
+		}
+	}
+
+	if ((dm->mp_mode) || *dm->antenna_test || (dm->normal_rx_path)) {
+		/* 0xef 0x80000  0x33 0x00001  0x3e 0x00034  0x3f 0x4080e
+		 * 0xef 0x00000    suggested by Lucas
+		 */
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0xef,
+						RFREGOFFSETMASK, 0x80000);
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0x33,
+						RFREGOFFSETMASK, 0x00001);
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0x3e,
+						RFREGOFFSETMASK, 0x00034);
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0x3f,
+						RFREGOFFSETMASK, 0x4080e);
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0xef,
+						RFREGOFFSETMASK, 0x00000);
+		ODM_RT_TRACE(
+			dm, ODM_PHY_CONFIG,
+			"%s(): MP mode or Antenna test mode!! support path-B TX and RX\n",
+			__func__);
+	} else {
+		/* 0xef 0x80000  0x33 0x00001  0x3e 0x00034  0x3f 0x4080c
+		 * 0xef 0x00000
+		 */
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0xef,
+						RFREGOFFSETMASK, 0x80000);
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0x33,
+						RFREGOFFSETMASK, 0x00001);
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0x3e,
+						RFREGOFFSETMASK, 0x00034);
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0x3f,
+						RFREGOFFSETMASK, 0x4080c);
+		rf_reg_status =
+			rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0xef,
+						RFREGOFFSETMASK, 0x00000);
+		ODM_RT_TRACE(
+			dm, ODM_PHY_CONFIG,
+			"%s(): Normal mode!! Do not support path-B TX and RX\n",
+			__func__);
+	}
+
+	rf_reg_status = rf_reg_status & config_phydm_write_rf_reg_8822b(
+						dm, ODM_RF_PATH_A, 0xef,
+						RFREGOFFSETMASK, 0x00000);
+
+	if (!rf_reg_status) {
+		ODM_RT_TRACE(
+			dm, ODM_PHY_CONFIG,
+			"%s(): Fail to set TRx mode setting (TX: 0x%x, RX: 0x%x), because writing RF register is fail\n",
+			__func__, tx_path, rx_path);
+		return false;
+	}
+
+	/* Toggle IGI to let RF enter RX mode,
+	 * because BB doesn't send 3-wire command when RX path is enable
+	 */
+	IGI = (u8)odm_get_bb_reg(dm, ODM_REG(IGI_A, dm), ODM_BIT(IGI, dm));
+	odm_write_dig(dm, IGI - 2);
+	odm_write_dig(dm, IGI);
+
+	/* Modify CCA parameters */
+	phydm_ccapar_by_rxpath_8822b(dm);
+	phydm_ccapar_by_rfe_8822b(dm);
+	phydm_rfe_8822b(dm, central_ch_8822b);
+
+	ODM_RT_TRACE(
+		dm, ODM_PHY_CONFIG,
+		"%s(): Success to set TRx mode setting (TX: 0x%x, RX: 0x%x)\n",
+		__func__, tx_path, rx_path);
+	return true;
+}
+
+bool config_phydm_parameter_init(struct phy_dm_struct *dm,
+				 enum odm_parameter_init type)
+{
+	if (type == ODM_PRE_SETTING) {
+		odm_set_bb_reg(dm, 0x808, (BIT(28) | BIT(29)), 0x0);
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): Pre setting: disable OFDM and CCK block\n",
+			     __func__);
+	} else if (type == ODM_POST_SETTING) {
+		odm_set_bb_reg(dm, 0x808, (BIT(28) | BIT(29)), 0x3);
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG,
+			     "%s(): Post setting: enable OFDM and CCK block\n",
+			     __func__);
+		reg82c_8822b = odm_get_bb_reg(dm, 0x82c, MASKDWORD);
+		reg838_8822b = odm_get_bb_reg(dm, 0x838, MASKDWORD);
+		reg830_8822b = odm_get_bb_reg(dm, 0x830, MASKDWORD);
+		reg83c_8822b = odm_get_bb_reg(dm, 0x83c, MASKDWORD);
+		rega20_8822b = odm_get_bb_reg(dm, 0xa20, MASKDWORD);
+		rega24_8822b = odm_get_bb_reg(dm, 0xa24, MASKDWORD);
+		rega28_8822b = odm_get_bb_reg(dm, 0xa28, MASKDWORD);
+	} else {
+		ODM_RT_TRACE(dm, ODM_PHY_CONFIG, "%s(): Wrong type!!\n",
+			     __func__);
+		return false;
+	}
+
+	return true;
+}
+
+/* ======================================================================== */
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_hal_api8822b.h b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_hal_api8822b.h
new file mode 100644
index 000000000000..279ef06298e2
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_hal_api8822b.h
@@ -0,0 +1,84 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __INC_PHYDM_API_H_8822B__
+#define __INC_PHYDM_API_H_8822B__
+
+/*2016.08.01 (HW user guide version: R27, SW user guide version: R05,
+ *            Modification: R31)
+ */
+#define PHY_CONFIG_VERSION_8822B "27.5.31"
+
+#define INVALID_RF_DATA 0xffffffff
+#define INVALID_TXAGC_DATA 0xff
+
+#define config_phydm_read_rf_check_8822b(data) (data != INVALID_RF_DATA)
+#define config_phydm_read_txagc_check_8822b(data) (data != INVALID_TXAGC_DATA)
+
+u32 config_phydm_read_rf_reg_8822b(struct phy_dm_struct *dm,
+				   enum odm_rf_radio_path rf_path, u32 reg_addr,
+				   u32 bit_mask);
+
+bool config_phydm_write_rf_reg_8822b(struct phy_dm_struct *dm,
+				     enum odm_rf_radio_path rf_path,
+				     u32 reg_addr, u32 bit_mask, u32 data);
+
+bool config_phydm_write_txagc_8822b(struct phy_dm_struct *dm, u32 power_index,
+				    enum odm_rf_radio_path path, u8 hw_rate);
+
+u8 config_phydm_read_txagc_8822b(struct phy_dm_struct *dm,
+				 enum odm_rf_radio_path path, u8 hw_rate);
+
+bool config_phydm_switch_band_8822b(struct phy_dm_struct *dm, u8 central_ch);
+
+bool config_phydm_switch_channel_8822b(struct phy_dm_struct *dm, u8 central_ch);
+
+bool config_phydm_switch_bandwidth_8822b(struct phy_dm_struct *dm,
+					 u8 primary_ch_idx,
+					 enum odm_bw bandwidth);
+
+bool config_phydm_switch_channel_bw_8822b(struct phy_dm_struct *dm,
+					  u8 central_ch, u8 primary_ch_idx,
+					  enum odm_bw bandwidth);
+
+bool config_phydm_trx_mode_8822b(struct phy_dm_struct *dm,
+				 enum odm_rf_path tx_path,
+				 enum odm_rf_path rx_path, bool is_tx2_path);
+
+bool config_phydm_parameter_init(struct phy_dm_struct *dm,
+				 enum odm_parameter_init type);
+
+/* ======================================================================== */
+/* These following functions can be used for PHY DM only*/
+
+bool phydm_write_txagc_1byte_8822b(struct phy_dm_struct *dm, u32 power_index,
+				   enum odm_rf_radio_path path, u8 hw_rate);
+
+void phydm_init_hw_info_by_rfe_type_8822b(struct phy_dm_struct *dm);
+
+s32 phydm_get_condition_number_8822B(struct phy_dm_struct *dm);
+
+/* ======================================================================== */
+
+#endif /*  __INC_PHYDM_API_H_8822B__ */
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_iqk_8822b.c b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_iqk_8822b.c
new file mode 100644
index 000000000000..d320311213cc
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_iqk_8822b.c
@@ -0,0 +1,1410 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
+
+/*---------------------------Define Local Constant---------------------------*/
+
+static bool _iqk_rx_iqk_by_path_8822b(void *, u8);
+
+static inline void phydm_set_iqk_info(struct phy_dm_struct *dm,
+				      struct dm_iqk_info *iqk_info, u8 status)
+{
+	bool KFAIL = true;
+
+	while (1) {
+		KFAIL = _iqk_rx_iqk_by_path_8822b(dm, ODM_RF_PATH_A);
+		if (status == 0)
+			ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+				     "[IQK]S0RXK KFail = 0x%x\n", KFAIL);
+		else if (status == 1)
+			ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+				     "[IQK]S1RXK KFail = 0x%x\n", KFAIL);
+		if (iqk_info->rxiqk_step == 5) {
+			dm->rf_calibrate_info.iqk_step++;
+			iqk_info->rxiqk_step = 1;
+			if (KFAIL && status == 0)
+				ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+					     "[IQK]S0RXK fail code: %d!!!\n",
+					     iqk_info->rxiqk_fail_code
+						     [0][ODM_RF_PATH_A]);
+			else if (KFAIL && status == 1)
+				ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+					     "[IQK]S1RXK fail code: %d!!!\n",
+					     iqk_info->rxiqk_fail_code
+						     [0][ODM_RF_PATH_A]);
+			break;
+		}
+	}
+
+	iqk_info->kcount++;
+}
+
+static inline void phydm_init_iqk_information(struct dm_iqk_info *iqk_info)
+{
+	u8 i, j, k, m;
+
+	for (i = 0; i < 2; i++) {
+		iqk_info->iqk_channel[i] = 0x0;
+
+		for (j = 0; j < SS_8822B; j++) {
+			iqk_info->lok_idac[i][j] = 0x0;
+			iqk_info->rxiqk_agc[i][j] = 0x0;
+			iqk_info->bypass_iqk[i][j] = 0x0;
+
+			for (k = 0; k < 2; k++) {
+				iqk_info->iqk_fail_report[i][j][k] = true;
+				for (m = 0; m < 8; m++) {
+					iqk_info->iqk_cfir_real[i][j][k][m] =
+						0x0;
+					iqk_info->iqk_cfir_imag[i][j][k][m] =
+						0x0;
+				}
+			}
+
+			for (k = 0; k < 3; k++)
+				iqk_info->retry_count[i][j][k] = 0x0;
+		}
+	}
+}
+
+static inline void phydm_backup_iqk_information(struct dm_iqk_info *iqk_info)
+{
+	u8 i, j, k;
+
+	iqk_info->iqk_channel[1] = iqk_info->iqk_channel[0];
+	for (i = 0; i < 2; i++) {
+		iqk_info->lok_idac[1][i] = iqk_info->lok_idac[0][i];
+		iqk_info->rxiqk_agc[1][i] = iqk_info->rxiqk_agc[0][i];
+		iqk_info->bypass_iqk[1][i] = iqk_info->bypass_iqk[0][i];
+		iqk_info->rxiqk_fail_code[1][i] =
+			iqk_info->rxiqk_fail_code[0][i];
+		for (j = 0; j < 2; j++) {
+			iqk_info->iqk_fail_report[1][i][j] =
+				iqk_info->iqk_fail_report[0][i][j];
+			for (k = 0; k < 8; k++) {
+				iqk_info->iqk_cfir_real[1][i][j][k] =
+					iqk_info->iqk_cfir_real[0][i][j][k];
+				iqk_info->iqk_cfir_imag[1][i][j][k] =
+					iqk_info->iqk_cfir_imag[0][i][j][k];
+			}
+		}
+	}
+
+	for (i = 0; i < 4; i++) {
+		iqk_info->rxiqk_fail_code[0][i] = 0x0;
+		iqk_info->rxiqk_agc[0][i] = 0x0;
+		for (j = 0; j < 2; j++) {
+			iqk_info->iqk_fail_report[0][i][j] = true;
+			iqk_info->gs_retry_count[0][i][j] = 0x0;
+		}
+		for (j = 0; j < 3; j++)
+			iqk_info->retry_count[0][i][j] = 0x0;
+	}
+}
+
+static inline void phydm_set_iqk_cfir(struct phy_dm_struct *dm,
+				      struct dm_iqk_info *iqk_info, u8 path)
+{
+	u8 idx, i;
+	u32 tmp;
+
+	for (idx = 0; idx < 2; idx++) {
+		odm_set_bb_reg(dm, 0x1b00, MASKDWORD, 0xf8000008 | path << 1);
+
+		if (idx == 0)
+			odm_set_bb_reg(dm, 0x1b0c, BIT(13) | BIT(12), 0x3);
+		else
+			odm_set_bb_reg(dm, 0x1b0c, BIT(13) | BIT(12), 0x1);
+
+		odm_set_bb_reg(dm, 0x1bd4,
+			       BIT(20) | BIT(19) | BIT(18) | BIT(17) | BIT(16),
+			       0x10);
+
+		for (i = 0; i < 8; i++) {
+			odm_set_bb_reg(dm, 0x1bd8, MASKDWORD,
+				       0xe0000001 + (i * 4));
+			tmp = odm_get_bb_reg(dm, 0x1bfc, MASKDWORD);
+			iqk_info->iqk_cfir_real[0][path][idx][i] =
+				(tmp & 0x0fff0000) >> 16;
+			iqk_info->iqk_cfir_imag[0][path][idx][i] = tmp & 0xfff;
+		}
+	}
+}
+
+static inline void phydm_get_read_counter(struct phy_dm_struct *dm)
+{
+	u32 counter = 0x0;
+
+	while (1) {
+		if (((odm_read_4byte(dm, 0x1bf0) >> 24) == 0x7f) ||
+		    (counter > 300))
+			break;
+
+		counter++;
+		ODM_delay_ms(1);
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION, "[IQK]counter = %d\n", counter);
+}
+
+/*---------------------------Define Local Constant---------------------------*/
+
+void do_iqk_8822b(void *dm_void, u8 delta_thermal_index, u8 thermal_value,
+		  u8 threshold)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	odm_reset_iqk_result(dm);
+
+	dm->rf_calibrate_info.thermal_value_iqk = thermal_value;
+
+	phy_iq_calibrate_8822b(dm, true);
+}
+
+static void _iqk_fill_iqk_report_8822b(void *dm_void, u8 channel)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dm_iqk_info *iqk_info = &dm->IQK_info;
+	u32 tmp1 = 0x0, tmp2 = 0x0, tmp3 = 0x0;
+	u8 i;
+
+	for (i = 0; i < SS_8822B; i++) {
+		tmp1 = tmp1 +
+		       ((iqk_info->iqk_fail_report[channel][i][TX_IQK] & 0x1)
+			<< i);
+		tmp2 = tmp2 +
+		       ((iqk_info->iqk_fail_report[channel][i][RX_IQK] & 0x1)
+			<< (i + 4));
+		tmp3 = tmp3 + ((iqk_info->rxiqk_fail_code[channel][i] & 0x3)
+			       << (i * 2 + 8));
+	}
+	odm_write_4byte(dm, 0x1b00, 0xf8000008);
+	odm_set_bb_reg(dm, 0x1bf0, 0x0000ffff, tmp1 | tmp2 | tmp3);
+
+	for (i = 0; i < 2; i++)
+		odm_write_4byte(
+			dm, 0x1be8 + (i * 4),
+			(iqk_info->rxiqk_agc[channel][(i * 2) + 1] << 16) |
+				iqk_info->rxiqk_agc[channel][i * 2]);
+}
+
+static void _iqk_backup_mac_bb_8822b(struct phy_dm_struct *dm, u32 *MAC_backup,
+				     u32 *BB_backup, u32 *backup_mac_reg,
+				     u32 *backup_bb_reg)
+{
+	u32 i;
+
+	for (i = 0; i < MAC_REG_NUM_8822B; i++)
+		MAC_backup[i] = odm_read_4byte(dm, backup_mac_reg[i]);
+
+	for (i = 0; i < BB_REG_NUM_8822B; i++)
+		BB_backup[i] = odm_read_4byte(dm, backup_bb_reg[i]);
+}
+
+static void _iqk_backup_rf_8822b(struct phy_dm_struct *dm, u32 RF_backup[][2],
+				 u32 *backup_rf_reg)
+{
+	u32 i;
+
+	for (i = 0; i < RF_REG_NUM_8822B; i++) {
+		RF_backup[i][ODM_RF_PATH_A] = odm_get_rf_reg(
+			dm, ODM_RF_PATH_A, backup_rf_reg[i], RFREGOFFSETMASK);
+		RF_backup[i][ODM_RF_PATH_B] = odm_get_rf_reg(
+			dm, ODM_RF_PATH_B, backup_rf_reg[i], RFREGOFFSETMASK);
+	}
+}
+
+static void _iqk_agc_bnd_int_8822b(struct phy_dm_struct *dm)
+{
+	/*initialize RX AGC bnd, it must do after bbreset*/
+	odm_write_4byte(dm, 0x1b00, 0xf8000008);
+	odm_write_4byte(dm, 0x1b00, 0xf80a7008);
+	odm_write_4byte(dm, 0x1b00, 0xf8015008);
+	odm_write_4byte(dm, 0x1b00, 0xf8000008);
+}
+
+static void _iqk_bb_reset_8822b(struct phy_dm_struct *dm)
+{
+	bool cca_ing = false;
+	u32 count = 0;
+
+	odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x0, RFREGOFFSETMASK, 0x10000);
+	odm_set_rf_reg(dm, ODM_RF_PATH_B, 0x0, RFREGOFFSETMASK, 0x10000);
+
+	while (1) {
+		odm_write_4byte(dm, 0x8fc, 0x0);
+		odm_set_bb_reg(dm, 0x198c, 0x7, 0x7);
+		cca_ing = (bool)odm_get_bb_reg(dm, 0xfa0, BIT(3));
+
+		if (count > 30)
+			cca_ing = false;
+
+		if (cca_ing) {
+			ODM_delay_ms(1);
+			count++;
+		} else {
+			odm_write_1byte(dm, 0x808, 0x0); /*RX ant off*/
+			odm_set_bb_reg(dm, 0xa04,
+				       BIT(27) | BIT(26) | BIT(25) | BIT(24),
+				       0x0); /*CCK RX path off*/
+
+			/*BBreset*/
+			odm_set_bb_reg(dm, 0x0, BIT(16), 0x0);
+			odm_set_bb_reg(dm, 0x0, BIT(16), 0x1);
+
+			if (odm_get_bb_reg(dm, 0x660, BIT(16)))
+				odm_write_4byte(dm, 0x6b4, 0x89000006);
+			break;
+		}
+	}
+}
+
+static void _iqk_afe_setting_8822b(struct phy_dm_struct *dm, bool do_iqk)
+{
+	if (do_iqk) {
+		odm_write_4byte(dm, 0xc60, 0x50000000);
+		odm_write_4byte(dm, 0xc60, 0x70070040);
+		odm_write_4byte(dm, 0xe60, 0x50000000);
+		odm_write_4byte(dm, 0xe60, 0x70070040);
+
+		odm_write_4byte(dm, 0xc58, 0xd8000402);
+		odm_write_4byte(dm, 0xc5c, 0xd1000120);
+		odm_write_4byte(dm, 0xc6c, 0x00000a15);
+		odm_write_4byte(dm, 0xe58, 0xd8000402);
+		odm_write_4byte(dm, 0xe5c, 0xd1000120);
+		odm_write_4byte(dm, 0xe6c, 0x00000a15);
+		_iqk_bb_reset_8822b(dm);
+	} else {
+		odm_write_4byte(dm, 0xc60, 0x50000000);
+		odm_write_4byte(dm, 0xc60, 0x70038040);
+		odm_write_4byte(dm, 0xe60, 0x50000000);
+		odm_write_4byte(dm, 0xe60, 0x70038040);
+
+		odm_write_4byte(dm, 0xc58, 0xd8020402);
+		odm_write_4byte(dm, 0xc5c, 0xde000120);
+		odm_write_4byte(dm, 0xc6c, 0x0000122a);
+		odm_write_4byte(dm, 0xe58, 0xd8020402);
+		odm_write_4byte(dm, 0xe5c, 0xde000120);
+		odm_write_4byte(dm, 0xe6c, 0x0000122a);
+	}
+}
+
+static void _iqk_restore_mac_bb_8822b(struct phy_dm_struct *dm, u32 *MAC_backup,
+				      u32 *BB_backup, u32 *backup_mac_reg,
+				      u32 *backup_bb_reg)
+{
+	u32 i;
+
+	for (i = 0; i < MAC_REG_NUM_8822B; i++)
+		odm_write_4byte(dm, backup_mac_reg[i], MAC_backup[i]);
+	for (i = 0; i < BB_REG_NUM_8822B; i++)
+		odm_write_4byte(dm, backup_bb_reg[i], BB_backup[i]);
+}
+
+static void _iqk_restore_rf_8822b(struct phy_dm_struct *dm, u32 *backup_rf_reg,
+				  u32 RF_backup[][2])
+{
+	u32 i;
+
+	odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xef, RFREGOFFSETMASK, 0x0);
+	odm_set_rf_reg(dm, ODM_RF_PATH_B, 0xef, RFREGOFFSETMASK, 0x0);
+	/*0xdf[4]=0*/
+	odm_set_rf_reg(dm, ODM_RF_PATH_A, 0xdf, RFREGOFFSETMASK,
+		       RF_backup[0][ODM_RF_PATH_A] & (~BIT(4)));
+	odm_set_rf_reg(dm, ODM_RF_PATH_B, 0xdf, RFREGOFFSETMASK,
+		       RF_backup[0][ODM_RF_PATH_B] & (~BIT(4)));
+
+	for (i = 1; i < RF_REG_NUM_8822B; i++) {
+		odm_set_rf_reg(dm, ODM_RF_PATH_A, backup_rf_reg[i],
+			       RFREGOFFSETMASK, RF_backup[i][ODM_RF_PATH_A]);
+		odm_set_rf_reg(dm, ODM_RF_PATH_B, backup_rf_reg[i],
+			       RFREGOFFSETMASK, RF_backup[i][ODM_RF_PATH_B]);
+	}
+}
+
+static void _iqk_backup_iqk_8822b(struct phy_dm_struct *dm, u8 step)
+{
+	struct dm_iqk_info *iqk_info = &dm->IQK_info;
+	u8 path;
+	u16 iqk_apply[2] = {0xc94, 0xe94};
+
+	if (step == 0x0) {
+		phydm_backup_iqk_information(iqk_info);
+	} else {
+		iqk_info->iqk_channel[0] = iqk_info->rf_reg18;
+		for (path = 0; path < 2; path++) {
+			iqk_info->lok_idac[0][path] =
+				odm_get_rf_reg(dm, (enum odm_rf_radio_path)path,
+					       0x58, RFREGOFFSETMASK);
+			iqk_info->bypass_iqk[0][path] =
+				odm_get_bb_reg(dm, iqk_apply[path], MASKDWORD);
+
+			phydm_set_iqk_cfir(dm, iqk_info, path);
+			odm_set_bb_reg(dm, 0x1bd8, MASKDWORD, 0x0);
+			odm_set_bb_reg(dm, 0x1b0c, BIT(13) | BIT(12), 0x0);
+		}
+	}
+}
+
+static void _iqk_reload_iqk_setting_8822b(
+	struct phy_dm_struct *dm, u8 channel,
+	u8 reload_idx /*1: reload TX, 2: reload LO, TX, RX*/
+	)
+{
+	struct dm_iqk_info *iqk_info = &dm->IQK_info;
+	u8 i, path, idx;
+	u16 iqk_apply[2] = {0xc94, 0xe94};
+
+	for (path = 0; path < 2; path++) {
+		if (reload_idx == 2) {
+			odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0xdf,
+				       BIT(4), 0x1);
+			odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x58,
+				       RFREGOFFSETMASK,
+				       iqk_info->lok_idac[channel][path]);
+		}
+
+		for (idx = 0; idx < reload_idx; idx++) {
+			odm_set_bb_reg(dm, 0x1b00, MASKDWORD,
+				       0xf8000008 | path << 1);
+			odm_set_bb_reg(dm, 0x1b2c, MASKDWORD, 0x7);
+			odm_set_bb_reg(dm, 0x1b38, MASKDWORD, 0x20000000);
+			odm_set_bb_reg(dm, 0x1b3c, MASKDWORD, 0x20000000);
+			odm_set_bb_reg(dm, 0x1bcc, MASKDWORD, 0x00000000);
+
+			if (idx == 0)
+				odm_set_bb_reg(dm, 0x1b0c, BIT(13) | BIT(12),
+					       0x3);
+			else
+				odm_set_bb_reg(dm, 0x1b0c, BIT(13) | BIT(12),
+					       0x1);
+
+			odm_set_bb_reg(dm, 0x1bd4, BIT(20) | BIT(19) | BIT(18) |
+							   BIT(17) | BIT(16),
+				       0x10);
+
+			for (i = 0; i < 8; i++) {
+				odm_write_4byte(
+					dm, 0x1bd8,
+					((0xc0000000 >> idx) + 0x3) + (i * 4) +
+						(iqk_info->iqk_cfir_real
+							 [channel][path][idx][i]
+						 << 9));
+				odm_write_4byte(
+					dm, 0x1bd8,
+					((0xc0000000 >> idx) + 0x1) + (i * 4) +
+						(iqk_info->iqk_cfir_imag
+							 [channel][path][idx][i]
+						 << 9));
+			}
+		}
+		odm_set_bb_reg(dm, iqk_apply[path], MASKDWORD,
+			       iqk_info->bypass_iqk[channel][path]);
+
+		odm_set_bb_reg(dm, 0x1bd8, MASKDWORD, 0x0);
+		odm_set_bb_reg(dm, 0x1b0c, BIT(13) | BIT(12), 0x0);
+	}
+}
+
+static bool _iqk_reload_iqk_8822b(struct phy_dm_struct *dm, bool reset)
+{
+	struct dm_iqk_info *iqk_info = &dm->IQK_info;
+	u8 i;
+	bool reload = false;
+
+	if (reset) {
+		for (i = 0; i < 2; i++)
+			iqk_info->iqk_channel[i] = 0x0;
+	} else {
+		iqk_info->rf_reg18 = odm_get_rf_reg(dm, ODM_RF_PATH_A, 0x18,
+						    RFREGOFFSETMASK);
+
+		for (i = 0; i < 2; i++) {
+			if (iqk_info->rf_reg18 == iqk_info->iqk_channel[i]) {
+				_iqk_reload_iqk_setting_8822b(dm, i, 2);
+				_iqk_fill_iqk_report_8822b(dm, i);
+				ODM_RT_TRACE(
+					dm, ODM_COMP_CALIBRATION,
+					"[IQK]reload IQK result before!!!!\n");
+				reload = true;
+			}
+		}
+	}
+	return reload;
+}
+
+static void _iqk_rfe_setting_8822b(struct phy_dm_struct *dm, bool ext_pa_on)
+{
+	if (ext_pa_on) {
+		/*RFE setting*/
+		odm_write_4byte(dm, 0xcb0, 0x77777777);
+		odm_write_4byte(dm, 0xcb4, 0x00007777);
+		odm_write_4byte(dm, 0xcbc, 0x0000083B);
+		odm_write_4byte(dm, 0xeb0, 0x77777777);
+		odm_write_4byte(dm, 0xeb4, 0x00007777);
+		odm_write_4byte(dm, 0xebc, 0x0000083B);
+		ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+			     "[IQK]external PA on!!!!\n");
+	} else {
+		/*RFE setting*/
+		odm_write_4byte(dm, 0xcb0, 0x77777777);
+		odm_write_4byte(dm, 0xcb4, 0x00007777);
+		odm_write_4byte(dm, 0xcbc, 0x00000100);
+		odm_write_4byte(dm, 0xeb0, 0x77777777);
+		odm_write_4byte(dm, 0xeb4, 0x00007777);
+		odm_write_4byte(dm, 0xebc, 0x00000100);
+	}
+}
+
+static void _iqk_rf_setting_8822b(struct phy_dm_struct *dm)
+{
+	u8 path;
+	u32 tmp;
+
+	odm_write_4byte(dm, 0x1b00, 0xf8000008);
+	odm_write_4byte(dm, 0x1bb8, 0x00000000);
+
+	for (path = 0; path < 2; path++) {
+		/*0xdf:B11 = 1,B4 = 0, B1 = 1*/
+		tmp = odm_get_rf_reg(dm, (enum odm_rf_radio_path)path, 0xdf,
+				     RFREGOFFSETMASK);
+		tmp = (tmp & (~BIT(4))) | BIT(1) | BIT(11);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0xdf,
+			       RFREGOFFSETMASK, tmp);
+
+		/*release 0x56 TXBB*/
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x65,
+			       RFREGOFFSETMASK, 0x09000);
+
+		if (*dm->band_type == ODM_BAND_5G) {
+			odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0xef,
+				       BIT(19), 0x1);
+			odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x33,
+				       RFREGOFFSETMASK, 0x00026);
+			odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x3e,
+				       RFREGOFFSETMASK, 0x00037);
+			odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x3f,
+				       RFREGOFFSETMASK, 0xdefce);
+			odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0xef,
+				       BIT(19), 0x0);
+		} else {
+			odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0xef,
+				       BIT(19), 0x1);
+			odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x33,
+				       RFREGOFFSETMASK, 0x00026);
+			odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x3e,
+				       RFREGOFFSETMASK, 0x00037);
+			odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x3f,
+				       RFREGOFFSETMASK, 0x5efce);
+			odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0xef,
+				       BIT(19), 0x0);
+		}
+	}
+}
+
+static void _iqk_configure_macbb_8822b(struct phy_dm_struct *dm)
+{
+	/*MACBB register setting*/
+	odm_write_1byte(dm, 0x522, 0x7f);
+	odm_set_bb_reg(dm, 0x550, BIT(11) | BIT(3), 0x0);
+	odm_set_bb_reg(dm, 0x90c, BIT(15),
+		       0x1); /*0x90c[15]=1: dac_buf reset selection*/
+	odm_set_bb_reg(dm, 0x9a4, BIT(31),
+		       0x0); /*0x9a4[31]=0: Select da clock*/
+	/*0xc94[0]=1, 0xe94[0]=1: let tx through iqk*/
+	odm_set_bb_reg(dm, 0xc94, BIT(0), 0x1);
+	odm_set_bb_reg(dm, 0xe94, BIT(0), 0x1);
+	/* 3-wire off*/
+	odm_write_4byte(dm, 0xc00, 0x00000004);
+	odm_write_4byte(dm, 0xe00, 0x00000004);
+}
+
+static void _iqk_lok_setting_8822b(struct phy_dm_struct *dm, u8 path)
+{
+	odm_write_4byte(dm, 0x1b00, 0xf8000008 | path << 1);
+	odm_write_4byte(dm, 0x1bcc, 0x9);
+	odm_write_1byte(dm, 0x1b23, 0x00);
+
+	switch (*dm->band_type) {
+	case ODM_BAND_2_4G:
+		odm_write_1byte(dm, 0x1b2b, 0x00);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x56,
+			       RFREGOFFSETMASK, 0x50df2);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x8f,
+			       RFREGOFFSETMASK, 0xadc00);
+		/* WE_LUT_TX_LOK*/
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0xef, BIT(4),
+			       0x1);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x33,
+			       BIT(1) | BIT(0), 0x0);
+		break;
+	case ODM_BAND_5G:
+		odm_write_1byte(dm, 0x1b2b, 0x80);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x56,
+			       RFREGOFFSETMASK, 0x5086c);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x8f,
+			       RFREGOFFSETMASK, 0xa9c00);
+		/* WE_LUT_TX_LOK*/
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0xef, BIT(4),
+			       0x1);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x33,
+			       BIT(1) | BIT(0), 0x1);
+		break;
+	}
+}
+
+static void _iqk_txk_setting_8822b(struct phy_dm_struct *dm, u8 path)
+{
+	odm_write_4byte(dm, 0x1b00, 0xf8000008 | path << 1);
+	odm_write_4byte(dm, 0x1bcc, 0x9);
+	odm_write_4byte(dm, 0x1b20, 0x01440008);
+
+	if (path == 0x0)
+		odm_write_4byte(dm, 0x1b00, 0xf800000a);
+	else
+		odm_write_4byte(dm, 0x1b00, 0xf8000008);
+	odm_write_4byte(dm, 0x1bcc, 0x3f);
+
+	switch (*dm->band_type) {
+	case ODM_BAND_2_4G:
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x56,
+			       RFREGOFFSETMASK, 0x50df2);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x8f,
+			       RFREGOFFSETMASK, 0xadc00);
+		odm_write_1byte(dm, 0x1b2b, 0x00);
+		break;
+	case ODM_BAND_5G:
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x56,
+			       RFREGOFFSETMASK, 0x500ef);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x8f,
+			       RFREGOFFSETMASK, 0xa9c00);
+		odm_write_1byte(dm, 0x1b2b, 0x80);
+		break;
+	}
+}
+
+static void _iqk_rxk1_setting_8822b(struct phy_dm_struct *dm, u8 path)
+{
+	odm_write_4byte(dm, 0x1b00, 0xf8000008 | path << 1);
+
+	switch (*dm->band_type) {
+	case ODM_BAND_2_4G:
+		odm_write_1byte(dm, 0x1bcc, 0x9);
+		odm_write_1byte(dm, 0x1b2b, 0x00);
+		odm_write_4byte(dm, 0x1b20, 0x01450008);
+		odm_write_4byte(dm, 0x1b24, 0x01460c88);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x56,
+			       RFREGOFFSETMASK, 0x510e0);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x8f,
+			       RFREGOFFSETMASK, 0xacc00);
+		break;
+	case ODM_BAND_5G:
+		odm_write_1byte(dm, 0x1bcc, 0x09);
+		odm_write_1byte(dm, 0x1b2b, 0x80);
+		odm_write_4byte(dm, 0x1b20, 0x00850008);
+		odm_write_4byte(dm, 0x1b24, 0x00460048);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x56,
+			       RFREGOFFSETMASK, 0x510e0);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x8f,
+			       RFREGOFFSETMASK, 0xadc00);
+		break;
+	}
+}
+
+static void _iqk_rxk2_setting_8822b(struct phy_dm_struct *dm, u8 path,
+				    bool is_gs)
+{
+	struct dm_iqk_info *iqk_info = &dm->IQK_info;
+
+	odm_write_4byte(dm, 0x1b00, 0xf8000008 | path << 1);
+
+	switch (*dm->band_type) {
+	case ODM_BAND_2_4G:
+		if (is_gs)
+			iqk_info->tmp1bcc = 0x12;
+		odm_write_1byte(dm, 0x1bcc, iqk_info->tmp1bcc);
+		odm_write_1byte(dm, 0x1b2b, 0x00);
+		odm_write_4byte(dm, 0x1b20, 0x01450008);
+		odm_write_4byte(dm, 0x1b24, 0x01460848);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x56,
+			       RFREGOFFSETMASK, 0x510e0);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x8f,
+			       RFREGOFFSETMASK, 0xa9c00);
+		break;
+	case ODM_BAND_5G:
+		if (is_gs) {
+			if (path == ODM_RF_PATH_A)
+				iqk_info->tmp1bcc = 0x12;
+			else
+				iqk_info->tmp1bcc = 0x09;
+		}
+		odm_write_1byte(dm, 0x1bcc, iqk_info->tmp1bcc);
+		odm_write_1byte(dm, 0x1b2b, 0x80);
+		odm_write_4byte(dm, 0x1b20, 0x00850008);
+		odm_write_4byte(dm, 0x1b24, 0x00460848);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x56,
+			       RFREGOFFSETMASK, 0x51060);
+		odm_set_rf_reg(dm, (enum odm_rf_radio_path)path, 0x8f,
+			       RFREGOFFSETMASK, 0xa9c00);
+		break;
+	}
+}
+
+static bool _iqk_check_cal_8822b(struct phy_dm_struct *dm, u32 IQK_CMD)
+{
+	bool notready = true, fail = true;
+	u32 delay_count = 0x0;
+
+	while (notready) {
+		if (odm_read_4byte(dm, 0x1b00) == (IQK_CMD & 0xffffff0f)) {
+			fail = (bool)odm_get_bb_reg(dm, 0x1b08, BIT(26));
+			notready = false;
+		} else {
+			ODM_delay_ms(1);
+			delay_count++;
+		}
+
+		if (delay_count >= 50) {
+			fail = true;
+			ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+				     "[IQK]IQK timeout!!!\n");
+			break;
+		}
+	}
+	ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION, "[IQK]delay count = 0x%x!!!\n",
+		     delay_count);
+	return fail;
+}
+
+static bool _iqk_rx_iqk_gain_search_fail_8822b(struct phy_dm_struct *dm,
+					       u8 path, u8 step)
+{
+	struct dm_iqk_info *iqk_info = &dm->IQK_info;
+	bool fail = true;
+	u32 IQK_CMD = 0x0, rf_reg0, tmp, bb_idx;
+	u8 IQMUX[4] = {0x9, 0x12, 0x1b, 0x24};
+	u8 idx;
+
+	for (idx = 0; idx < 4; idx++)
+		if (iqk_info->tmp1bcc == IQMUX[idx])
+			break;
+
+	odm_write_4byte(dm, 0x1b00, 0xf8000008 | path << 1);
+	odm_write_4byte(dm, 0x1bcc, iqk_info->tmp1bcc);
+
+	if (step == RXIQK1)
+		ODM_RT_TRACE(
+			dm, ODM_COMP_CALIBRATION,
+			"[IQK]============ S%d RXIQK GainSearch ============\n",
+			path);
+
+	if (step == RXIQK1)
+		IQK_CMD = 0xf8000208 | (1 << (path + 4));
+	else
+		IQK_CMD = 0xf8000308 | (1 << (path + 4));
+
+	ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION, "[IQK]S%d GS%d_Trigger = 0x%x\n",
+		     path, step, IQK_CMD);
+
+	odm_write_4byte(dm, 0x1b00, IQK_CMD);
+	odm_write_4byte(dm, 0x1b00, IQK_CMD + 0x1);
+	ODM_delay_ms(GS_delay_8822B);
+	fail = _iqk_check_cal_8822b(dm, IQK_CMD);
+
+	if (step == RXIQK2) {
+		rf_reg0 = odm_get_rf_reg(dm, (enum odm_rf_radio_path)path, 0x0,
+					 RFREGOFFSETMASK);
+		odm_write_4byte(dm, 0x1b00, 0xf8000008 | path << 1);
+		ODM_RT_TRACE(
+			dm, ODM_COMP_CALIBRATION,
+			"[IQK]S%d ==> RF0x0 = 0x%x, tmp1bcc = 0x%x, idx = %d, 0x1b3c = 0x%x\n",
+			path, rf_reg0, iqk_info->tmp1bcc, idx,
+			odm_read_4byte(dm, 0x1b3c));
+		tmp = (rf_reg0 & 0x1fe0) >> 5;
+		iqk_info->lna_idx = tmp >> 5;
+		bb_idx = tmp & 0x1f;
+		if (bb_idx == 0x1) {
+			if (iqk_info->lna_idx != 0x0)
+				iqk_info->lna_idx--;
+			else if (idx != 3)
+				idx++;
+			else
+				iqk_info->isbnd = true;
+			fail = true;
+		} else if (bb_idx == 0xa) {
+			if (idx != 0)
+				idx--;
+			else if (iqk_info->lna_idx != 0x7)
+				iqk_info->lna_idx++;
+			else
+				iqk_info->isbnd = true;
+			fail = true;
+		} else {
+			fail = false;
+		}
+
+		if (iqk_info->isbnd)
+			fail = false;
+
+		iqk_info->tmp1bcc = IQMUX[idx];
+
+		if (fail) {
+			odm_write_4byte(dm, 0x1b00, 0xf8000008 | path << 1);
+			odm_write_4byte(
+				dm, 0x1b24,
+				(odm_read_4byte(dm, 0x1b24) & 0xffffe3ff) |
+					(iqk_info->lna_idx << 10));
+		}
+	}
+
+	return fail;
+}
+
+static bool _lok_one_shot_8822b(void *dm_void, u8 path)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dm_iqk_info *iqk_info = &dm->IQK_info;
+	u8 delay_count = 0;
+	bool LOK_notready = false;
+	u32 LOK_temp = 0;
+	u32 IQK_CMD = 0x0;
+
+	ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+		     "[IQK]==========S%d LOK ==========\n", path);
+
+	IQK_CMD = 0xf8000008 | (1 << (4 + path));
+
+	ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION, "[IQK]LOK_Trigger = 0x%x\n",
+		     IQK_CMD);
+
+	odm_write_4byte(dm, 0x1b00, IQK_CMD);
+	odm_write_4byte(dm, 0x1b00, IQK_CMD + 1);
+	/*LOK: CMD ID = 0	{0xf8000018, 0xf8000028}*/
+	/*LOK: CMD ID = 0	{0xf8000019, 0xf8000029}*/
+	ODM_delay_ms(LOK_delay_8822B);
+
+	delay_count = 0;
+	LOK_notready = true;
+
+	while (LOK_notready) {
+		if (odm_read_4byte(dm, 0x1b00) == (IQK_CMD & 0xffffff0f))
+			LOK_notready = false;
+		else
+			LOK_notready = true;
+
+		if (LOK_notready) {
+			ODM_delay_ms(1);
+			delay_count++;
+		}
+
+		if (delay_count >= 50) {
+			ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+				     "[IQK]S%d LOK timeout!!!\n", path);
+			break;
+		}
+	}
+
+	ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+		     "[IQK]S%d ==> delay_count = 0x%x\n", path, delay_count);
+	if (ODM_COMP_CALIBRATION) {
+		if (!LOK_notready) {
+			LOK_temp =
+				odm_get_rf_reg(dm, (enum odm_rf_radio_path)path,
+					       0x58, RFREGOFFSETMASK);
+			ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+				     "[IQK]0x58 = 0x%x\n", LOK_temp);
+		} else {
+			ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+				     "[IQK]==>S%d LOK Fail!!!\n", path);
+		}
+	}
+	iqk_info->lok_fail[path] = LOK_notready;
+	return LOK_notready;
+}
+
+static bool _iqk_one_shot_8822b(void *dm_void, u8 path, u8 idx)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dm_iqk_info *iqk_info = &dm->IQK_info;
+	u8 delay_count = 0;
+	bool notready = true, fail = true;
+	u32 IQK_CMD = 0x0;
+	u16 iqk_apply[2] = {0xc94, 0xe94};
+
+	if (idx == TXIQK)
+		ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+			     "[IQK]============ S%d WBTXIQK ============\n",
+			     path);
+	else if (idx == RXIQK1)
+		ODM_RT_TRACE(
+			dm, ODM_COMP_CALIBRATION,
+			"[IQK]============ S%d WBRXIQK STEP1============\n",
+			path);
+	else
+		ODM_RT_TRACE(
+			dm, ODM_COMP_CALIBRATION,
+			"[IQK]============ S%d WBRXIQK STEP2============\n",
+			path);
+
+	if (idx == TXIQK) {
+		IQK_CMD = 0xf8000008 | ((*dm->band_width + 4) << 8) |
+			  (1 << (path + 4));
+		ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+			     "[IQK]TXK_Trigger = 0x%x\n", IQK_CMD);
+		/*{0xf8000418, 0xf800042a} ==> 20 WBTXK (CMD = 4)*/
+		/*{0xf8000518, 0xf800052a} ==> 40 WBTXK (CMD = 5)*/
+		/*{0xf8000618, 0xf800062a} ==> 80 WBTXK (CMD = 6)*/
+	} else if (idx == RXIQK1) {
+		if (*dm->band_width == 2)
+			IQK_CMD = 0xf8000808 | (1 << (path + 4));
+		else
+			IQK_CMD = 0xf8000708 | (1 << (path + 4));
+		ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+			     "[IQK]RXK1_Trigger = 0x%x\n", IQK_CMD);
+		/*{0xf8000718, 0xf800072a} ==> 20 WBTXK (CMD = 7)*/
+		/*{0xf8000718, 0xf800072a} ==> 40 WBTXK (CMD = 7)*/
+		/*{0xf8000818, 0xf800082a} ==> 80 WBTXK (CMD = 8)*/
+	} else if (idx == RXIQK2) {
+		IQK_CMD = 0xf8000008 | ((*dm->band_width + 9) << 8) |
+			  (1 << (path + 4));
+		ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+			     "[IQK]RXK2_Trigger = 0x%x\n", IQK_CMD);
+		/*{0xf8000918, 0xf800092a} ==> 20 WBRXK (CMD = 9)*/
+		/*{0xf8000a18, 0xf8000a2a} ==> 40 WBRXK (CMD = 10)*/
+		/*{0xf8000b18, 0xf8000b2a} ==> 80 WBRXK (CMD = 11)*/
+		odm_write_4byte(dm, 0x1b00, 0xf8000008 | path << 1);
+		odm_write_4byte(dm, 0x1b24,
+				(odm_read_4byte(dm, 0x1b24) & 0xffffe3ff) |
+					((iqk_info->lna_idx & 0x7) << 10));
+	}
+	odm_write_4byte(dm, 0x1b00, IQK_CMD);
+	odm_write_4byte(dm, 0x1b00, IQK_CMD + 0x1);
+	ODM_delay_ms(WBIQK_delay_8822B);
+
+	while (notready) {
+		if (odm_read_4byte(dm, 0x1b00) == (IQK_CMD & 0xffffff0f))
+			notready = false;
+		else
+			notready = true;
+
+		if (notready) {
+			ODM_delay_ms(1);
+			delay_count++;
+		} else {
+			fail = (bool)odm_get_bb_reg(dm, 0x1b08, BIT(26));
+			break;
+		}
+
+		if (delay_count >= 50) {
+			ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+				     "[IQK]S%d IQK timeout!!!\n", path);
+			break;
+		}
+	}
+
+	if (dm->debug_components & ODM_COMP_CALIBRATION) {
+		odm_write_4byte(dm, 0x1b00, 0xf8000008 | path << 1);
+		ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+			     "[IQK]S%d ==> 0x1b00 = 0x%x, 0x1b08 = 0x%x\n",
+			     path, odm_read_4byte(dm, 0x1b00),
+			     odm_read_4byte(dm, 0x1b08));
+		ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+			     "[IQK]S%d ==> delay_count = 0x%x\n", path,
+			     delay_count);
+		if (idx != TXIQK)
+			ODM_RT_TRACE(
+				dm, ODM_COMP_CALIBRATION,
+				"[IQK]S%d ==> RF0x0 = 0x%x, RF0x56 = 0x%x\n",
+				path,
+				odm_get_rf_reg(dm, (enum odm_rf_radio_path)path,
+					       0x0, RFREGOFFSETMASK),
+				odm_get_rf_reg(dm, (enum odm_rf_radio_path)path,
+					       0x56, RFREGOFFSETMASK));
+	}
+
+	odm_write_4byte(dm, 0x1b00, 0xf8000008 | path << 1);
+
+	if (idx == TXIQK)
+		if (fail)
+			odm_set_bb_reg(dm, iqk_apply[path], BIT(0), 0x0);
+
+	if (idx == RXIQK2) {
+		iqk_info->rxiqk_agc[0][path] =
+			(u16)(((odm_get_rf_reg(dm, (enum odm_rf_radio_path)path,
+					       0x0, RFREGOFFSETMASK) >>
+				5) &
+			       0xff) |
+			      (iqk_info->tmp1bcc << 8));
+
+		odm_write_4byte(dm, 0x1b38, 0x20000000);
+
+		if (!fail)
+			odm_set_bb_reg(dm, iqk_apply[path], (BIT(11) | BIT(10)),
+				       0x1);
+		else
+			odm_set_bb_reg(dm, iqk_apply[path], (BIT(11) | BIT(10)),
+				       0x0);
+	}
+
+	if (idx == TXIQK)
+		iqk_info->iqk_fail_report[0][path][TXIQK] = fail;
+	else
+		iqk_info->iqk_fail_report[0][path][RXIQK] = fail;
+
+	return fail;
+}
+
+static bool _iqk_rx_iqk_by_path_8822b(void *dm_void, u8 path)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dm_iqk_info *iqk_info = &dm->IQK_info;
+	bool KFAIL = true, gonext;
+
+	switch (iqk_info->rxiqk_step) {
+	case 1: /*gain search_RXK1*/
+		_iqk_rxk1_setting_8822b(dm, path);
+		gonext = false;
+		while (1) {
+			KFAIL = _iqk_rx_iqk_gain_search_fail_8822b(dm, path,
+								   RXIQK1);
+			if (KFAIL &&
+			    (iqk_info->gs_retry_count[0][path][GSRXK1] < 2))
+				iqk_info->gs_retry_count[0][path][GSRXK1]++;
+			else if (KFAIL) {
+				iqk_info->rxiqk_fail_code[0][path] = 0;
+				iqk_info->rxiqk_step = 5;
+				gonext = true;
+			} else {
+				iqk_info->rxiqk_step++;
+				gonext = true;
+			}
+			if (gonext)
+				break;
+		}
+		break;
+	case 2: /*gain search_RXK2*/
+		_iqk_rxk2_setting_8822b(dm, path, true);
+		iqk_info->isbnd = false;
+		while (1) {
+			KFAIL = _iqk_rx_iqk_gain_search_fail_8822b(dm, path,
+								   RXIQK2);
+			if (KFAIL &&
+			    (iqk_info->gs_retry_count[0][path][GSRXK2] <
+			     rxiqk_gs_limit)) {
+				iqk_info->gs_retry_count[0][path][GSRXK2]++;
+			} else {
+				iqk_info->rxiqk_step++;
+				break;
+			}
+		}
+		break;
+	case 3: /*RXK1*/
+		_iqk_rxk1_setting_8822b(dm, path);
+		gonext = false;
+		while (1) {
+			KFAIL = _iqk_one_shot_8822b(dm, path, RXIQK1);
+			if (KFAIL &&
+			    (iqk_info->retry_count[0][path][RXIQK1] < 2))
+				iqk_info->retry_count[0][path][RXIQK1]++;
+			else if (KFAIL) {
+				iqk_info->rxiqk_fail_code[0][path] = 1;
+				iqk_info->rxiqk_step = 5;
+				gonext = true;
+			} else {
+				iqk_info->rxiqk_step++;
+				gonext = true;
+			}
+			if (gonext)
+				break;
+		}
+		break;
+	case 4: /*RXK2*/
+		_iqk_rxk2_setting_8822b(dm, path, false);
+		gonext = false;
+		while (1) {
+			KFAIL = _iqk_one_shot_8822b(dm, path, RXIQK2);
+			if (KFAIL &&
+			    (iqk_info->retry_count[0][path][RXIQK2] < 2))
+				iqk_info->retry_count[0][path][RXIQK2]++;
+			else if (KFAIL) {
+				iqk_info->rxiqk_fail_code[0][path] = 2;
+				iqk_info->rxiqk_step = 5;
+				gonext = true;
+			} else {
+				iqk_info->rxiqk_step++;
+				gonext = true;
+			}
+			if (gonext)
+				break;
+		}
+		break;
+	}
+	return KFAIL;
+}
+
+static void _iqk_iqk_by_path_8822b(void *dm_void, bool segment_iqk)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dm_iqk_info *iqk_info = &dm->IQK_info;
+	bool KFAIL = true;
+	u8 i, kcount_limit;
+
+	if (*dm->band_width == 2)
+		kcount_limit = kcount_limit_80m;
+	else
+		kcount_limit = kcount_limit_others;
+
+	while (1) {
+		switch (dm->rf_calibrate_info.iqk_step) {
+		case 1: /*S0 LOK*/
+			_iqk_lok_setting_8822b(dm, ODM_RF_PATH_A);
+			_lok_one_shot_8822b(dm, ODM_RF_PATH_A);
+			dm->rf_calibrate_info.iqk_step++;
+			break;
+		case 2: /*S1 LOK*/
+			_iqk_lok_setting_8822b(dm, ODM_RF_PATH_B);
+			_lok_one_shot_8822b(dm, ODM_RF_PATH_B);
+			dm->rf_calibrate_info.iqk_step++;
+			break;
+		case 3: /*S0 TXIQK*/
+			_iqk_txk_setting_8822b(dm, ODM_RF_PATH_A);
+			KFAIL = _iqk_one_shot_8822b(dm, ODM_RF_PATH_A, TXIQK);
+			iqk_info->kcount++;
+			ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+				     "[IQK]S0TXK KFail = 0x%x\n", KFAIL);
+
+			if (KFAIL &&
+			    (iqk_info->retry_count[0][ODM_RF_PATH_A][TXIQK] <
+			     3))
+				iqk_info->retry_count[0][ODM_RF_PATH_A]
+						     [TXIQK]++;
+			else
+				dm->rf_calibrate_info.iqk_step++;
+			break;
+		case 4: /*S1 TXIQK*/
+			_iqk_txk_setting_8822b(dm, ODM_RF_PATH_B);
+			KFAIL = _iqk_one_shot_8822b(dm, ODM_RF_PATH_B, TXIQK);
+			iqk_info->kcount++;
+			ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+				     "[IQK]S1TXK KFail = 0x%x\n", KFAIL);
+			if (KFAIL &&
+			    iqk_info->retry_count[0][ODM_RF_PATH_B][TXIQK] < 3)
+				iqk_info->retry_count[0][ODM_RF_PATH_B]
+						     [TXIQK]++;
+			else
+				dm->rf_calibrate_info.iqk_step++;
+			break;
+		case 5: /*S0 RXIQK*/
+			phydm_set_iqk_info(dm, iqk_info, 0);
+			break;
+		case 6: /*S1 RXIQK*/
+			phydm_set_iqk_info(dm, iqk_info, 1);
+			break;
+		}
+
+		if (dm->rf_calibrate_info.iqk_step == 7) {
+			ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+				     "[IQK]==========LOK summary ==========\n");
+			ODM_RT_TRACE(
+				dm, ODM_COMP_CALIBRATION,
+				"[IQK]PathA_LOK_notready = %d, PathB_LOK1_notready = %d\n",
+				iqk_info->lok_fail[ODM_RF_PATH_A],
+				iqk_info->lok_fail[ODM_RF_PATH_B]);
+			ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+				     "[IQK]==========IQK summary ==========\n");
+			ODM_RT_TRACE(
+				dm, ODM_COMP_CALIBRATION,
+				"[IQK]PathA_TXIQK_fail = %d, PathB_TXIQK_fail = %d\n",
+				iqk_info->iqk_fail_report[0][ODM_RF_PATH_A]
+							 [TXIQK],
+				iqk_info->iqk_fail_report[0][ODM_RF_PATH_B]
+							 [TXIQK]);
+			ODM_RT_TRACE(
+				dm, ODM_COMP_CALIBRATION,
+				"[IQK]PathA_RXIQK_fail = %d, PathB_RXIQK_fail = %d\n",
+				iqk_info->iqk_fail_report[0][ODM_RF_PATH_A]
+							 [RXIQK],
+				iqk_info->iqk_fail_report[0][ODM_RF_PATH_B]
+							 [RXIQK]);
+			ODM_RT_TRACE(
+				dm, ODM_COMP_CALIBRATION,
+				"[IQK]PathA_TXIQK_retry = %d, PathB_TXIQK_retry = %d\n",
+				iqk_info->retry_count[0][ODM_RF_PATH_A][TXIQK],
+				iqk_info->retry_count[0][ODM_RF_PATH_B][TXIQK]);
+			ODM_RT_TRACE(
+				dm, ODM_COMP_CALIBRATION,
+				"[IQK]PathA_RXK1_retry = %d, PathA_RXK2_retry = %d, PathB_RXK1_retry = %d, PathB_RXK2_retry = %d\n",
+				iqk_info->retry_count[0][ODM_RF_PATH_A][RXIQK1],
+				iqk_info->retry_count[0][ODM_RF_PATH_A][RXIQK2],
+				iqk_info->retry_count[0][ODM_RF_PATH_B][RXIQK1],
+				iqk_info->retry_count[0][ODM_RF_PATH_B]
+						     [RXIQK2]);
+			ODM_RT_TRACE(
+				dm, ODM_COMP_CALIBRATION,
+				"[IQK]PathA_GS1_retry = %d, PathA_GS2_retry = %d, PathB_GS1_retry = %d, PathB_GS2_retry = %d\n",
+				iqk_info->gs_retry_count[0][ODM_RF_PATH_A]
+							[GSRXK1],
+				iqk_info->gs_retry_count[0][ODM_RF_PATH_A]
+							[GSRXK2],
+				iqk_info->gs_retry_count[0][ODM_RF_PATH_B]
+							[GSRXK1],
+				iqk_info->gs_retry_count[0][ODM_RF_PATH_B]
+							[GSRXK2]);
+			for (i = 0; i < 2; i++) {
+				odm_write_4byte(dm, 0x1b00,
+						0xf8000008 | i << 1);
+				odm_write_4byte(dm, 0x1b2c, 0x7);
+				odm_write_4byte(dm, 0x1bcc, 0x0);
+			}
+			break;
+		}
+
+		if (segment_iqk && (iqk_info->kcount == kcount_limit))
+			break;
+	}
+}
+
+static void _iqk_start_iqk_8822b(struct phy_dm_struct *dm, bool segment_iqk)
+{
+	u32 tmp;
+
+	/*GNT_WL = 1*/
+	tmp = odm_get_rf_reg(dm, ODM_RF_PATH_A, 0x1, RFREGOFFSETMASK);
+	tmp = tmp | BIT(5) | BIT(0);
+	odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x1, RFREGOFFSETMASK, tmp);
+
+	tmp = odm_get_rf_reg(dm, ODM_RF_PATH_B, 0x1, RFREGOFFSETMASK);
+	tmp = tmp | BIT(5) | BIT(0);
+	odm_set_rf_reg(dm, ODM_RF_PATH_B, 0x1, RFREGOFFSETMASK, tmp);
+
+	_iqk_iqk_by_path_8822b(dm, segment_iqk);
+}
+
+static void _iq_calibrate_8822b_init(void *dm_void)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+	struct dm_iqk_info *iqk_info = &dm->IQK_info;
+	u8 i, j;
+
+	if (iqk_info->iqk_times == 0) {
+		ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+			     "[IQK]=====>PHY_IQCalibrate_8822B_Init\n");
+
+		for (i = 0; i < SS_8822B; i++) {
+			for (j = 0; j < 2; j++) {
+				iqk_info->lok_fail[i] = true;
+				iqk_info->iqk_fail[j][i] = true;
+				iqk_info->iqc_matrix[j][i] = 0x20000000;
+			}
+		}
+
+		phydm_init_iqk_information(iqk_info);
+	}
+}
+
+static void _phy_iq_calibrate_8822b(struct phy_dm_struct *dm, bool reset)
+{
+	u32 MAC_backup[MAC_REG_NUM_8822B], BB_backup[BB_REG_NUM_8822B],
+		RF_backup[RF_REG_NUM_8822B][SS_8822B];
+	u32 backup_mac_reg[MAC_REG_NUM_8822B] = {0x520, 0x550};
+	u32 backup_bb_reg[BB_REG_NUM_8822B] = {
+		0x808, 0x90c, 0xc00, 0xcb0,  0xcb4, 0xcbc, 0xe00,
+		0xeb0, 0xeb4, 0xebc, 0x1990, 0x9a4, 0xa04};
+	u32 backup_rf_reg[RF_REG_NUM_8822B] = {0xdf, 0x8f, 0x65, 0x0, 0x1};
+	bool segment_iqk = false, is_mp = false;
+
+	struct dm_iqk_info *iqk_info = &dm->IQK_info;
+
+	if (dm->mp_mode)
+		is_mp = true;
+	else if (dm->is_linked)
+		segment_iqk = true;
+
+	if (!is_mp)
+		if (_iqk_reload_iqk_8822b(dm, reset))
+			return;
+
+	ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+		     "[IQK]==========IQK strat!!!!!==========\n");
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_CALIBRATION,
+		"[IQK]band_type = %s, band_width = %d, ExtPA2G = %d, ext_pa_5g = %d\n",
+		(*dm->band_type == ODM_BAND_5G) ? "5G" : "2G", *dm->band_width,
+		dm->ext_pa, dm->ext_pa_5g);
+	ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+		     "[IQK]Interface = %d, cut_version = %x\n",
+		     dm->support_interface, dm->cut_version);
+
+	iqk_info->iqk_times++;
+
+	iqk_info->kcount = 0;
+	dm->rf_calibrate_info.iqk_total_progressing_time = 0;
+	dm->rf_calibrate_info.iqk_step = 1;
+	iqk_info->rxiqk_step = 1;
+
+	_iqk_backup_iqk_8822b(dm, 0);
+	_iqk_backup_mac_bb_8822b(dm, MAC_backup, BB_backup, backup_mac_reg,
+				 backup_bb_reg);
+	_iqk_backup_rf_8822b(dm, RF_backup, backup_rf_reg);
+
+	while (1) {
+		if (!is_mp)
+			dm->rf_calibrate_info.iqk_start_time =
+				odm_get_current_time(dm);
+
+		_iqk_configure_macbb_8822b(dm);
+		_iqk_afe_setting_8822b(dm, true);
+		_iqk_rfe_setting_8822b(dm, false);
+		_iqk_agc_bnd_int_8822b(dm);
+		_iqk_rf_setting_8822b(dm);
+
+		_iqk_start_iqk_8822b(dm, segment_iqk);
+
+		_iqk_afe_setting_8822b(dm, false);
+		_iqk_restore_mac_bb_8822b(dm, MAC_backup, BB_backup,
+					  backup_mac_reg, backup_bb_reg);
+		_iqk_restore_rf_8822b(dm, backup_rf_reg, RF_backup);
+
+		if (!is_mp) {
+			dm->rf_calibrate_info.iqk_progressing_time =
+				odm_get_progressing_time(
+					dm,
+					dm->rf_calibrate_info.iqk_start_time);
+			dm->rf_calibrate_info.iqk_total_progressing_time +=
+				odm_get_progressing_time(
+					dm,
+					dm->rf_calibrate_info.iqk_start_time);
+			ODM_RT_TRACE(
+				dm, ODM_COMP_CALIBRATION,
+				"[IQK]IQK progressing_time = %lld ms\n",
+				dm->rf_calibrate_info.iqk_progressing_time);
+		}
+
+		if (dm->rf_calibrate_info.iqk_step == 7)
+			break;
+
+		iqk_info->kcount = 0;
+		ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION, "[IQK]delay 50ms!!!\n");
+		ODM_delay_ms(50);
+	};
+
+	_iqk_backup_iqk_8822b(dm, 1);
+	_iqk_fill_iqk_report_8822b(dm, 0);
+
+	if (!is_mp)
+		ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+			     "[IQK]Total IQK progressing_time = %lld ms\n",
+			     dm->rf_calibrate_info.iqk_total_progressing_time);
+
+	ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+		     "[IQK]==========IQK end!!!!!==========\n");
+}
+
+static void _phy_iq_calibrate_by_fw_8822b(void *dm_void, u8 clear) {}
+
+/*IQK version:v3.3, NCTL v0.6*/
+/*1.The new gainsearch method for RXIQK*/
+/*2.The new format of IQK report register: 0x1be8/0x1bec*/
+/*3. add the option of segment IQK*/
+void phy_iq_calibrate_8822b(void *dm_void, bool clear)
+{
+	struct phy_dm_struct *dm = (struct phy_dm_struct *)dm_void;
+
+	dm->iqk_fw_offload = 0;
+
+	/*FW IQK*/
+	if (dm->iqk_fw_offload) {
+		if (!dm->rf_calibrate_info.is_iqk_in_progress) {
+			odm_acquire_spin_lock(dm, RT_IQK_SPINLOCK);
+			dm->rf_calibrate_info.is_iqk_in_progress = true;
+			odm_release_spin_lock(dm, RT_IQK_SPINLOCK);
+
+			dm->rf_calibrate_info.iqk_start_time =
+				odm_get_current_time(dm);
+
+			odm_write_4byte(dm, 0x1b00, 0xf8000008);
+			odm_set_bb_reg(dm, 0x1bf0, 0xff000000, 0xff);
+			ODM_RT_TRACE(dm, ODM_COMP_CALIBRATION,
+				     "[IQK]0x1bf0 = 0x%x\n",
+				     odm_read_4byte(dm, 0x1bf0));
+
+			_phy_iq_calibrate_by_fw_8822b(dm, clear);
+			phydm_get_read_counter(dm);
+
+			dm->rf_calibrate_info.iqk_progressing_time =
+				odm_get_progressing_time(
+					dm,
+					dm->rf_calibrate_info.iqk_start_time);
+
+			ODM_RT_TRACE(
+				dm, ODM_COMP_CALIBRATION,
+				"[IQK]IQK progressing_time = %lld ms\n",
+				dm->rf_calibrate_info.iqk_progressing_time);
+
+			odm_acquire_spin_lock(dm, RT_IQK_SPINLOCK);
+			dm->rf_calibrate_info.is_iqk_in_progress = false;
+			odm_release_spin_lock(dm, RT_IQK_SPINLOCK);
+		} else {
+			ODM_RT_TRACE(
+				dm, ODM_COMP_CALIBRATION,
+				"== Return the IQK CMD, because the IQK in Progress ==\n");
+		}
+
+	} else {
+		_iq_calibrate_8822b_init(dm_void);
+
+		if (!dm->rf_calibrate_info.is_iqk_in_progress) {
+			odm_acquire_spin_lock(dm, RT_IQK_SPINLOCK);
+			dm->rf_calibrate_info.is_iqk_in_progress = true;
+			odm_release_spin_lock(dm, RT_IQK_SPINLOCK);
+			if (dm->mp_mode)
+				dm->rf_calibrate_info.iqk_start_time =
+					odm_get_current_time(dm);
+
+			_phy_iq_calibrate_8822b(dm, clear);
+			if (dm->mp_mode) {
+				dm->rf_calibrate_info.iqk_progressing_time =
+					odm_get_progressing_time(
+						dm, dm->rf_calibrate_info
+							    .iqk_start_time);
+				ODM_RT_TRACE(
+					dm, ODM_COMP_CALIBRATION,
+					"[IQK]IQK progressing_time = %lld ms\n",
+					dm->rf_calibrate_info
+						.iqk_progressing_time);
+			}
+			odm_acquire_spin_lock(dm, RT_IQK_SPINLOCK);
+			dm->rf_calibrate_info.is_iqk_in_progress = false;
+			odm_release_spin_lock(dm, RT_IQK_SPINLOCK);
+		} else {
+			ODM_RT_TRACE(
+				dm, ODM_COMP_CALIBRATION,
+				"[IQK]== Return the IQK CMD, because the IQK in Progress ==\n");
+		}
+	}
+}
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_iqk_8822b.h b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_iqk_8822b.h
new file mode 100644
index 000000000000..ea19deb512d5
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_iqk_8822b.h
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __PHYDM_IQK_8822B_H__
+#define __PHYDM_IQK_8822B_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+#define MAC_REG_NUM_8822B 2
+#define BB_REG_NUM_8822B 13
+#define RF_REG_NUM_8822B 5
+
+#define LOK_delay_8822B 2
+#define GS_delay_8822B 2
+#define WBIQK_delay_8822B 2
+
+#define TXIQK 0
+#define RXIQK 1
+#define SS_8822B 2
+
+/*------------------------End Define Parameters-------------------------------*/
+
+void do_iqk_8822b(void *dm_void, u8 delta_thermal_index, u8 thermal_value,
+		  u8 threshold);
+
+void phy_iq_calibrate_8822b(void *dm_void, bool clear);
+
+#endif /* #ifndef __PHYDM_IQK_8822B_H__*/
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_regconfig8822b.c b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_regconfig8822b.c
new file mode 100644
index 000000000000..644fca822c61
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_regconfig8822b.c
@@ -0,0 +1,168 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
+
+void odm_config_rf_reg_8822b(struct phy_dm_struct *dm, u32 addr, u32 data,
+			     enum odm_rf_radio_path RF_PATH, u32 reg_addr)
+{
+	if (addr == 0xffe) {
+		ODM_sleep_ms(50);
+	} else if (addr == 0xfe) {
+		ODM_delay_us(100);
+	} else {
+		odm_set_rf_reg(dm, RF_PATH, reg_addr, RFREGOFFSETMASK, data);
+
+		/* Add 1us delay between BB/RF register setting. */
+		ODM_delay_us(1);
+	}
+}
+
+void odm_config_rf_radio_a_8822b(struct phy_dm_struct *dm, u32 addr, u32 data)
+{
+	u32 content = 0x1000; /* RF_Content: radioa_txt */
+	u32 maskfor_phy_set = (u32)(content & 0xE000);
+
+	odm_config_rf_reg_8822b(dm, addr, data, ODM_RF_PATH_A,
+				addr | maskfor_phy_set);
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_INIT,
+		"===> odm_config_rf_with_header_file: [RadioA] %08X %08X\n",
+		addr, data);
+}
+
+void odm_config_rf_radio_b_8822b(struct phy_dm_struct *dm, u32 addr, u32 data)
+{
+	u32 content = 0x1001; /* RF_Content: radiob_txt */
+	u32 maskfor_phy_set = (u32)(content & 0xE000);
+
+	odm_config_rf_reg_8822b(dm, addr, data, ODM_RF_PATH_B,
+				addr | maskfor_phy_set);
+
+	ODM_RT_TRACE(
+		dm, ODM_COMP_INIT,
+		"===> odm_config_rf_with_header_file: [RadioB] %08X %08X\n",
+		addr, data);
+}
+
+void odm_config_mac_8822b(struct phy_dm_struct *dm, u32 addr, u8 data)
+{
+	odm_write_1byte(dm, addr, data);
+	ODM_RT_TRACE(
+		dm, ODM_COMP_INIT,
+		"===> odm_config_mac_with_header_file: [MAC_REG] %08X %08X\n",
+		addr, data);
+}
+
+void odm_update_agc_big_jump_lmt_8822b(struct phy_dm_struct *dm, u32 addr,
+				       u32 data)
+{
+	struct dig_thres *dig_tab = &dm->dm_dig_table;
+	u8 rf_gain_idx = (u8)((data & 0xFF000000) >> 24);
+	u8 bb_gain_idx = (u8)((data & 0x00ff0000) >> 16);
+	u8 agc_table_idx = (u8)((data & 0x00000f00) >> 8);
+	static bool is_limit;
+
+	if (addr != 0x81c)
+		return;
+
+	if (bb_gain_idx > 0x3c) {
+		if ((rf_gain_idx == dig_tab->rf_gain_idx) && !is_limit) {
+			is_limit = true;
+			dig_tab->big_jump_lmt[agc_table_idx] = bb_gain_idx - 2;
+			ODM_RT_TRACE(
+				dm, ODM_COMP_DIG,
+				"===> [AGC_TAB] big_jump_lmt [%d] = 0x%x\n",
+				agc_table_idx,
+				dig_tab->big_jump_lmt[agc_table_idx]);
+		}
+	} else {
+		is_limit = false;
+	}
+
+	dig_tab->rf_gain_idx = rf_gain_idx;
+}
+
+void odm_config_bb_agc_8822b(struct phy_dm_struct *dm, u32 addr, u32 bitmask,
+			     u32 data)
+{
+	odm_update_agc_big_jump_lmt_8822b(dm, addr, data);
+
+	odm_set_bb_reg(dm, addr, bitmask, data);
+
+	/* Add 1us delay between BB/RF register setting. */
+	ODM_delay_us(1);
+
+	ODM_RT_TRACE(dm, ODM_COMP_INIT, "===> %s: [AGC_TAB] %08X %08X\n",
+		     __func__, addr, data);
+}
+
+void odm_config_bb_phy_reg_pg_8822b(struct phy_dm_struct *dm, u32 band,
+				    u32 rf_path, u32 tx_num, u32 addr,
+				    u32 bitmask, u32 data)
+{
+	if (addr == 0xfe || addr == 0xffe) {
+		ODM_sleep_ms(50);
+	} else {
+		phy_store_tx_power_by_rate(dm->adapter, band, rf_path, tx_num,
+					   addr, bitmask, data);
+	}
+	ODM_RT_TRACE(dm, ODM_COMP_INIT, "===> %s: [PHY_REG] %08X %08X %08X\n",
+		     __func__, addr, bitmask, data);
+}
+
+void odm_config_bb_phy_8822b(struct phy_dm_struct *dm, u32 addr, u32 bitmask,
+			     u32 data)
+{
+	if (addr == 0xfe)
+		ODM_sleep_ms(50);
+	else if (addr == 0xfd)
+		ODM_delay_ms(5);
+	else if (addr == 0xfc)
+		ODM_delay_ms(1);
+	else if (addr == 0xfb)
+		ODM_delay_us(50);
+	else if (addr == 0xfa)
+		ODM_delay_us(5);
+	else if (addr == 0xf9)
+		ODM_delay_us(1);
+	else
+		odm_set_bb_reg(dm, addr, bitmask, data);
+
+	/* Add 1us delay between BB/RF register setting. */
+	ODM_delay_us(1);
+	ODM_RT_TRACE(dm, ODM_COMP_INIT, "===> %s: [PHY_REG] %08X %08X\n",
+		     __func__, addr, data);
+}
+
+void odm_config_bb_txpwr_lmt_8822b(struct phy_dm_struct *dm, u8 *regulation,
+				   u8 *band, u8 *bandwidth, u8 *rate_section,
+				   u8 *rf_path, u8 *channel, u8 *power_limit)
+{
+	phy_set_tx_power_limit(dm, regulation, band, bandwidth, rate_section,
+			       rf_path, channel, power_limit);
+}
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_regconfig8822b.h b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_regconfig8822b.h
new file mode 100644
index 000000000000..4817cf6b1ed9
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_regconfig8822b.h
@@ -0,0 +1,54 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __INC_ODM_REGCONFIG_H_8822B
+#define __INC_ODM_REGCONFIG_H_8822B
+
+void odm_config_rf_reg_8822b(struct phy_dm_struct *dm, u32 addr, u32 data,
+			     enum odm_rf_radio_path RF_PATH, u32 reg_addr);
+
+void odm_config_rf_radio_a_8822b(struct phy_dm_struct *dm, u32 addr, u32 data);
+
+void odm_config_rf_radio_b_8822b(struct phy_dm_struct *dm, u32 addr, u32 data);
+
+void odm_config_mac_8822b(struct phy_dm_struct *dm, u32 addr, u8 data);
+
+void odm_update_agc_big_jump_lmt_8822b(struct phy_dm_struct *dm, u32 addr,
+				       u32 data);
+
+void odm_config_bb_agc_8822b(struct phy_dm_struct *dm, u32 addr, u32 bitmask,
+			     u32 data);
+
+void odm_config_bb_phy_reg_pg_8822b(struct phy_dm_struct *dm, u32 band,
+				    u32 rf_path, u32 tx_num, u32 addr,
+				    u32 bitmask, u32 data);
+
+void odm_config_bb_phy_8822b(struct phy_dm_struct *dm, u32 addr, u32 bitmask,
+			     u32 data);
+
+void odm_config_bb_txpwr_lmt_8822b(struct phy_dm_struct *dm, u8 *regulation,
+				   u8 *band, u8 *bandwidth, u8 *rate_section,
+				   u8 *rf_path, u8 *channel, u8 *power_limit);
+
+#endif /* RTL8822B_SUPPORT == 1*/
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_rtl8822b.c b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_rtl8822b.c
new file mode 100644
index 000000000000..59adabda09de
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_rtl8822b.c
@@ -0,0 +1,225 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
+
+static void phydm_dynamic_switch_htstf_mumimo_8822b(struct phy_dm_struct *dm)
+{
+	/*if rssi > 40dBm, enable HT-STF gain controller,
+	 *otherwise, if rssi < 40dBm, disable the controller
+	 */
+	/*add by Chun-Hung Ho 20160711 */
+	if (dm->rssi_min >= 40)
+		odm_set_bb_reg(dm, 0x8d8, BIT(17), 0x1);
+	else if (dm->rssi_min < 35)
+		odm_set_bb_reg(dm, 0x8d8, BIT(17), 0x0);
+
+	ODM_RT_TRACE(dm, ODM_COMP_COMMON, "%s, rssi_min = %d\n", __func__,
+		     dm->rssi_min);
+}
+
+static void _set_tx_a_cali_value(struct phy_dm_struct *dm, u8 rf_path,
+				 u8 offset, u8 tx_a_bias_offset)
+{
+	u32 modi_tx_a_value = 0;
+	u8 tmp1_byte = 0;
+	bool is_minus = false;
+	u8 comp_value = 0;
+
+	switch (offset) {
+	case 0x0:
+		odm_set_rf_reg(dm, rf_path, 0x18, 0xFFFFF, 0X10124);
+		break;
+	case 0x1:
+		odm_set_rf_reg(dm, rf_path, 0x18, 0xFFFFF, 0X10524);
+		break;
+	case 0x2:
+		odm_set_rf_reg(dm, rf_path, 0x18, 0xFFFFF, 0X10924);
+		break;
+	case 0x3:
+		odm_set_rf_reg(dm, rf_path, 0x18, 0xFFFFF, 0X10D24);
+		break;
+	case 0x4:
+		odm_set_rf_reg(dm, rf_path, 0x18, 0xFFFFF, 0X30164);
+		break;
+	case 0x5:
+		odm_set_rf_reg(dm, rf_path, 0x18, 0xFFFFF, 0X30564);
+		break;
+	case 0x6:
+		odm_set_rf_reg(dm, rf_path, 0x18, 0xFFFFF, 0X30964);
+		break;
+	case 0x7:
+		odm_set_rf_reg(dm, rf_path, 0x18, 0xFFFFF, 0X30D64);
+		break;
+	case 0x8:
+		odm_set_rf_reg(dm, rf_path, 0x18, 0xFFFFF, 0X50195);
+		break;
+	case 0x9:
+		odm_set_rf_reg(dm, rf_path, 0x18, 0xFFFFF, 0X50595);
+		break;
+	case 0xa:
+		odm_set_rf_reg(dm, rf_path, 0x18, 0xFFFFF, 0X50995);
+		break;
+	case 0xb:
+		odm_set_rf_reg(dm, rf_path, 0x18, 0xFFFFF, 0X50D95);
+		break;
+	default:
+		ODM_RT_TRACE(dm, ODM_COMP_COMMON,
+			     "Invalid TxA band offset...\n");
+		return;
+	}
+
+	/* Get TxA value */
+	modi_tx_a_value = odm_get_rf_reg(dm, rf_path, 0x61, 0xFFFFF);
+	tmp1_byte = (u8)modi_tx_a_value & (BIT(3) | BIT(2) | BIT(1) | BIT(0));
+
+	/* check how much need to calibration */
+	switch (tx_a_bias_offset) {
+	case 0xF6:
+		is_minus = true;
+		comp_value = 3;
+		break;
+
+	case 0xF4:
+		is_minus = true;
+		comp_value = 2;
+		break;
+
+	case 0xF2:
+		is_minus = true;
+		comp_value = 1;
+		break;
+
+	case 0xF3:
+		is_minus = false;
+		comp_value = 1;
+		break;
+
+	case 0xF5:
+		is_minus = false;
+		comp_value = 2;
+		break;
+
+	case 0xF7:
+		is_minus = false;
+		comp_value = 3;
+		break;
+
+	case 0xF9:
+		is_minus = false;
+		comp_value = 4;
+		break;
+
+	/* do nothing case */
+	case 0xF0:
+	default:
+		ODM_RT_TRACE(dm, ODM_COMP_COMMON,
+			     "No need to do TxA bias current calibration\n");
+		return;
+	}
+
+	/* calc correct value to calibrate */
+	if (is_minus) {
+		if (tmp1_byte >= comp_value) {
+			tmp1_byte -= comp_value;
+			/*modi_tx_a_value += tmp1_byte;*/
+		} else {
+			tmp1_byte = 0;
+		}
+	} else {
+		tmp1_byte += comp_value;
+		if (tmp1_byte >= 7)
+			tmp1_byte = 7;
+	}
+
+	/* Write back to RF reg */
+	odm_set_rf_reg(dm, rf_path, 0x30, 0xFFFF,
+		       (offset << 12 | (modi_tx_a_value & 0xFF0) | tmp1_byte));
+}
+
+static void _txa_bias_cali_4_each_path(struct phy_dm_struct *dm, u8 rf_path,
+				       u8 efuse_value)
+{
+	/* switch on set TxA bias */
+	odm_set_rf_reg(dm, rf_path, 0xEF, 0xFFFFF, 0x200);
+
+	/* Set 12 sets of TxA value */
+	_set_tx_a_cali_value(dm, rf_path, 0x0, efuse_value);
+	_set_tx_a_cali_value(dm, rf_path, 0x1, efuse_value);
+	_set_tx_a_cali_value(dm, rf_path, 0x2, efuse_value);
+	_set_tx_a_cali_value(dm, rf_path, 0x3, efuse_value);
+	_set_tx_a_cali_value(dm, rf_path, 0x4, efuse_value);
+	_set_tx_a_cali_value(dm, rf_path, 0x5, efuse_value);
+	_set_tx_a_cali_value(dm, rf_path, 0x6, efuse_value);
+	_set_tx_a_cali_value(dm, rf_path, 0x7, efuse_value);
+	_set_tx_a_cali_value(dm, rf_path, 0x8, efuse_value);
+	_set_tx_a_cali_value(dm, rf_path, 0x9, efuse_value);
+	_set_tx_a_cali_value(dm, rf_path, 0xa, efuse_value);
+	_set_tx_a_cali_value(dm, rf_path, 0xb, efuse_value);
+
+	/* switch off set TxA bias */
+	odm_set_rf_reg(dm, rf_path, 0xEF, 0xFFFFF, 0x0);
+}
+
+/*
+ * for 8822B PCIE D-cut patch only
+ * Normal driver and MP driver need this patch
+ */
+
+void phydm_txcurrentcalibration(struct phy_dm_struct *dm)
+{
+	u8 efuse0x3D8, efuse0x3D7;
+	u32 orig_rf0x18_path_a = 0, orig_rf0x18_path_b = 0;
+
+	/* save original 0x18 value */
+	orig_rf0x18_path_a = odm_get_rf_reg(dm, ODM_RF_PATH_A, 0x18, 0xFFFFF);
+	orig_rf0x18_path_b = odm_get_rf_reg(dm, ODM_RF_PATH_B, 0x18, 0xFFFFF);
+
+	/* define efuse content */
+	efuse0x3D8 = dm->efuse0x3d8;
+	efuse0x3D7 = dm->efuse0x3d7;
+
+	/* check efuse content to judge whether need to calibration or not */
+	if (efuse0x3D7 == 0xFF) {
+		ODM_RT_TRACE(
+			dm, ODM_COMP_COMMON,
+			"efuse content 0x3D7 == 0xFF, No need to do TxA cali\n");
+		return;
+	}
+
+	/* write RF register for calibration */
+	_txa_bias_cali_4_each_path(dm, ODM_RF_PATH_A, efuse0x3D7);
+	_txa_bias_cali_4_each_path(dm, ODM_RF_PATH_B, efuse0x3D8);
+
+	/* restore original 0x18 value */
+	odm_set_rf_reg(dm, ODM_RF_PATH_A, 0x18, 0xFFFFF, orig_rf0x18_path_a);
+	odm_set_rf_reg(dm, ODM_RF_PATH_B, 0x18, 0xFFFFF, orig_rf0x18_path_b);
+}
+
+void phydm_hwsetting_8822b(struct phy_dm_struct *dm)
+{
+	phydm_dynamic_switch_htstf_mumimo_8822b(dm);
+}
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_rtl8822b.h b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_rtl8822b.h
new file mode 100644
index 000000000000..af91a6f958ed
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/phydm_rtl8822b.h
@@ -0,0 +1,30 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __ODM_RTL8822B_H__
+#define __ODM_RTL8822B_H__
+
+void phydm_hwsetting_8822b(struct phy_dm_struct *dm);
+
+#endif /* #define __ODM_RTL8822B_H__ */
diff --git a/drivers/staging/rtlwifi/phydm/rtl8822b/version_rtl8822b.h b/drivers/staging/rtlwifi/phydm/rtl8822b/version_rtl8822b.h
new file mode 100644
index 000000000000..ad0d32fce0a9
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl8822b/version_rtl8822b.h
@@ -0,0 +1,34 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+/*RTL8822B PHY Parameters*/
+/*
+ * [Caution]
+ * Since 01/Aug/2015, the commit rules will be simplified.
+ * You do not need to fill up the version.h anymore,
+ * only the maintenance supervisor fills it before formal release.
+ */
+#define RELEASE_DATE_8822B 20161103
+#define COMMIT_BY_8822B "BB_JOE"
+#define RELEASE_VERSION_8822B 67
diff --git a/drivers/staging/rtlwifi/phydm/rtl_phydm.c b/drivers/staging/rtlwifi/phydm/rtl_phydm.c
new file mode 100644
index 000000000000..85e490d3601f
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl_phydm.c
@@ -0,0 +1,874 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "mp_precomp.h"
+#include "phydm_precomp.h"
+#include <linux/module.h>
+
+static int _rtl_phydm_init_com_info(struct rtl_priv *rtlpriv,
+				    enum odm_ic_type ic_type,
+				    struct rtl_phydm_params *params)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_phy *rtlphy = &rtlpriv->phy;
+	struct rtl_mac *mac = rtl_mac(rtlpriv);
+	struct rtl_ps_ctl *ppsc = rtl_psc(rtlpriv);
+	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
+	u8 odm_board_type = ODM_BOARD_DEFAULT;
+	u32 support_ability;
+	int i;
+
+	dm->adapter = (void *)rtlpriv;
+
+	odm_cmn_info_init(dm, ODM_CMNINFO_PLATFORM, ODM_CE);
+
+	odm_cmn_info_init(dm, ODM_CMNINFO_IC_TYPE, ic_type);
+
+	odm_cmn_info_init(dm, ODM_CMNINFO_INTERFACE, ODM_ITRF_PCIE);
+
+	odm_cmn_info_init(dm, ODM_CMNINFO_MP_TEST_CHIP, params->mp_chip);
+
+	odm_cmn_info_init(dm, ODM_CMNINFO_PATCH_ID, rtlhal->oem_id);
+
+	odm_cmn_info_init(dm, ODM_CMNINFO_BWIFI_TEST, 1);
+
+	if (rtlphy->rf_type == RF_1T1R)
+		odm_cmn_info_init(dm, ODM_CMNINFO_RF_TYPE, ODM_1T1R);
+	else if (rtlphy->rf_type == RF_1T2R)
+		odm_cmn_info_init(dm, ODM_CMNINFO_RF_TYPE, ODM_1T2R);
+	else if (rtlphy->rf_type == RF_2T2R)
+		odm_cmn_info_init(dm, ODM_CMNINFO_RF_TYPE, ODM_2T2R);
+	else if (rtlphy->rf_type == RF_2T2R_GREEN)
+		odm_cmn_info_init(dm, ODM_CMNINFO_RF_TYPE, ODM_2T2R_GREEN);
+	else if (rtlphy->rf_type == RF_2T3R)
+		odm_cmn_info_init(dm, ODM_CMNINFO_RF_TYPE, ODM_2T3R);
+	else if (rtlphy->rf_type == RF_2T4R)
+		odm_cmn_info_init(dm, ODM_CMNINFO_RF_TYPE, ODM_2T4R);
+	else if (rtlphy->rf_type == RF_3T3R)
+		odm_cmn_info_init(dm, ODM_CMNINFO_RF_TYPE, ODM_3T3R);
+	else if (rtlphy->rf_type == RF_3T4R)
+		odm_cmn_info_init(dm, ODM_CMNINFO_RF_TYPE, ODM_3T4R);
+	else if (rtlphy->rf_type == RF_4T4R)
+		odm_cmn_info_init(dm, ODM_CMNINFO_RF_TYPE, ODM_4T4R);
+	else
+		odm_cmn_info_init(dm, ODM_CMNINFO_RF_TYPE, ODM_XTXR);
+
+	/* 1 ======= BoardType: ODM_CMNINFO_BOARD_TYPE ======= */
+	if (rtlhal->external_lna_2g != 0) {
+		odm_board_type |= ODM_BOARD_EXT_LNA;
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_LNA, 1);
+	}
+	if (rtlhal->external_lna_5g != 0) {
+		odm_board_type |= ODM_BOARD_EXT_LNA_5G;
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_LNA, 1);
+	}
+	if (rtlhal->external_pa_2g != 0) {
+		odm_board_type |= ODM_BOARD_EXT_PA;
+		odm_cmn_info_init(dm, ODM_CMNINFO_EXT_PA, 1);
+	}
+	if (rtlhal->external_pa_5g != 0) {
+		odm_board_type |= ODM_BOARD_EXT_PA_5G;
+		odm_cmn_info_init(dm, ODM_CMNINFO_5G_EXT_PA, 1);
+	}
+	if (rtlpriv->cfg->ops->get_btc_status())
+		odm_board_type |= ODM_BOARD_BT;
+
+	odm_cmn_info_init(dm, ODM_CMNINFO_BOARD_TYPE, odm_board_type);
+	/* 1 ============== End of BoardType ============== */
+
+	odm_cmn_info_init(dm, ODM_CMNINFO_GPA, rtlhal->type_gpa);
+	odm_cmn_info_init(dm, ODM_CMNINFO_APA, rtlhal->type_apa);
+	odm_cmn_info_init(dm, ODM_CMNINFO_GLNA, rtlhal->type_glna);
+	odm_cmn_info_init(dm, ODM_CMNINFO_ALNA, rtlhal->type_alna);
+
+	odm_cmn_info_init(dm, ODM_CMNINFO_RFE_TYPE, rtlhal->rfe_type);
+
+	odm_cmn_info_init(dm, ODM_CMNINFO_EXT_TRSW, 0);
+
+	/*Add by YuChen for kfree init*/
+	odm_cmn_info_init(dm, ODM_CMNINFO_REGRFKFREEENABLE, 2);
+	odm_cmn_info_init(dm, ODM_CMNINFO_RFKFREEENABLE, 0);
+
+	/*Antenna diversity relative parameters*/
+	odm_cmn_info_hook(dm, ODM_CMNINFO_ANT_DIV,
+			  &rtlefuse->antenna_div_cfg);
+	odm_cmn_info_init(dm, ODM_CMNINFO_RF_ANTENNA_TYPE,
+			  rtlefuse->antenna_div_type);
+	odm_cmn_info_init(dm, ODM_CMNINFO_BE_FIX_TX_ANT, 0);
+	odm_cmn_info_init(dm, ODM_CMNINFO_WITH_EXT_ANTENNA_SWITCH, 0);
+
+	/* (8822B) efuse 0x3D7 & 0x3D8 for TX PA bias */
+	odm_cmn_info_init(dm, ODM_CMNINFO_EFUSE0X3D7, params->efuse0x3d7);
+	odm_cmn_info_init(dm, ODM_CMNINFO_EFUSE0X3D8, params->efuse0x3d8);
+
+	/*Add by YuChen for adaptivity init*/
+	odm_cmn_info_hook(dm, ODM_CMNINFO_ADAPTIVITY,
+			  &rtlpriv->phydm.adaptivity_en);
+	phydm_adaptivity_info_init(dm, PHYDM_ADAPINFO_CARRIER_SENSE_ENABLE,
+				   false);
+	phydm_adaptivity_info_init(dm, PHYDM_ADAPINFO_DCBACKOFF, 0);
+	phydm_adaptivity_info_init(dm, PHYDM_ADAPINFO_DYNAMICLINKADAPTIVITY,
+				   false);
+	phydm_adaptivity_info_init(dm, PHYDM_ADAPINFO_TH_L2H_INI, 0);
+	phydm_adaptivity_info_init(dm, PHYDM_ADAPINFO_TH_EDCCA_HL_DIFF, 0);
+
+	odm_cmn_info_init(dm, ODM_CMNINFO_IQKFWOFFLOAD, 0);
+
+	/* Pointer reference */
+	odm_cmn_info_hook(dm, ODM_CMNINFO_TX_UNI,
+			  &rtlpriv->stats.txbytesunicast);
+	odm_cmn_info_hook(dm, ODM_CMNINFO_RX_UNI,
+			  &rtlpriv->stats.rxbytesunicast);
+	odm_cmn_info_hook(dm, ODM_CMNINFO_BAND, &rtlhal->current_bandtype);
+	odm_cmn_info_hook(dm, ODM_CMNINFO_FORCED_RATE,
+			  &rtlpriv->phydm.forced_data_rate);
+	odm_cmn_info_hook(dm, ODM_CMNINFO_FORCED_IGI_LB,
+			  &rtlpriv->phydm.forced_igi_lb);
+
+	odm_cmn_info_hook(dm, ODM_CMNINFO_SEC_CHNL_OFFSET,
+			  &mac->cur_40_prime_sc);
+	odm_cmn_info_hook(dm, ODM_CMNINFO_BW, &rtlphy->current_chan_bw);
+	odm_cmn_info_hook(dm, ODM_CMNINFO_CHNL, &rtlphy->current_channel);
+
+	odm_cmn_info_hook(dm, ODM_CMNINFO_SCAN, &mac->act_scanning);
+	odm_cmn_info_hook(dm, ODM_CMNINFO_POWER_SAVING,
+			  &ppsc->dot11_psmode); /* may add new boolean flag */
+	/*Add by Yuchen for phydm beamforming*/
+	odm_cmn_info_hook(dm, ODM_CMNINFO_TX_TP,
+			  &rtlpriv->stats.txbytesunicast_inperiod_tp);
+	odm_cmn_info_hook(dm, ODM_CMNINFO_RX_TP,
+			  &rtlpriv->stats.rxbytesunicast_inperiod_tp);
+	odm_cmn_info_hook(dm, ODM_CMNINFO_ANT_TEST,
+			  &rtlpriv->phydm.antenna_test);
+	for (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
+		odm_cmn_info_ptr_array_hook(dm, ODM_CMNINFO_STA_STATUS, i,
+					    NULL);
+
+	phydm_init_debug_setting(dm);
+
+	odm_cmn_info_init(dm, ODM_CMNINFO_FAB_VER, params->fab_ver);
+	odm_cmn_info_init(dm, ODM_CMNINFO_CUT_VER, params->cut_ver);
+
+	/* after ifup, ability is updated again */
+	support_ability = ODM_RF_CALIBRATION | ODM_RF_TX_PWR_TRACK;
+	odm_cmn_info_update(dm, ODM_CMNINFO_ABILITY, support_ability);
+
+	return 0;
+}
+
+static int rtl_phydm_init_priv(struct rtl_priv *rtlpriv,
+			       struct rtl_phydm_params *params)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	enum odm_ic_type ic;
+
+	if (IS_HARDWARE_TYPE_8822B(rtlpriv))
+		ic = ODM_RTL8822B;
+	else
+		return 0;
+
+	rtlpriv->phydm.internal =
+		kzalloc(sizeof(struct phy_dm_struct), GFP_KERNEL);
+
+	_rtl_phydm_init_com_info(rtlpriv, ic, params);
+
+	odm_init_all_timers(dm);
+
+	return 1;
+}
+
+static int rtl_phydm_deinit_priv(struct rtl_priv *rtlpriv)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+
+	odm_cancel_all_timers(dm);
+
+	kfree(rtlpriv->phydm.internal);
+	rtlpriv->phydm.internal = NULL;
+
+	return 0;
+}
+
+static bool rtl_phydm_load_txpower_by_rate(struct rtl_priv *rtlpriv)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	enum hal_status status;
+
+	status = odm_config_bb_with_header_file(dm, CONFIG_BB_PHY_REG_PG);
+	if (status != HAL_STATUS_SUCCESS)
+		return false;
+
+	return true;
+}
+
+static bool rtl_phydm_load_txpower_limit(struct rtl_priv *rtlpriv)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	enum hal_status status;
+
+	if (IS_HARDWARE_TYPE_8822B(rtlpriv)) {
+		odm_read_and_config_mp_8822b_txpwr_lmt(dm);
+	} else {
+		status = odm_config_rf_with_header_file(dm, CONFIG_RF_TXPWR_LMT,
+							0);
+		if (status != HAL_STATUS_SUCCESS)
+			return false;
+	}
+
+	return true;
+}
+
+static int rtl_phydm_init_dm(struct rtl_priv *rtlpriv)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	u32 support_ability = 0;
+
+	/* clang-format off */
+	support_ability = 0
+			| ODM_BB_DIG
+			| ODM_BB_RA_MASK
+			| ODM_BB_DYNAMIC_TXPWR
+			| ODM_BB_FA_CNT
+			| ODM_BB_RSSI_MONITOR
+			| ODM_BB_CCK_PD
+	/*		| ODM_BB_PWR_SAVE*/
+			| ODM_BB_CFO_TRACKING
+			| ODM_MAC_EDCA_TURBO
+			| ODM_RF_TX_PWR_TRACK
+			| ODM_RF_CALIBRATION
+			| ODM_BB_NHM_CNT
+	/*		| ODM_BB_PWR_TRAIN*/
+			;
+	/* clang-format on */
+
+	odm_cmn_info_update(dm, ODM_CMNINFO_ABILITY, support_ability);
+
+	odm_dm_init(dm);
+
+	return 0;
+}
+
+static int rtl_phydm_deinit_dm(struct rtl_priv *rtlpriv)
+{
+	return 0;
+}
+
+static int rtl_phydm_reset_dm(struct rtl_priv *rtlpriv)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+
+	odm_dm_reset(dm);
+
+	return 0;
+}
+
+static bool rtl_phydm_parameter_init(struct rtl_priv *rtlpriv, bool post)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+
+	if (IS_HARDWARE_TYPE_8822B(rtlpriv))
+		return config_phydm_parameter_init(dm, post ? ODM_POST_SETTING :
+							      ODM_PRE_SETTING);
+
+	return false;
+}
+
+static bool rtl_phydm_phy_bb_config(struct rtl_priv *rtlpriv)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	enum hal_status status;
+
+	status = odm_config_bb_with_header_file(dm, CONFIG_BB_PHY_REG);
+	if (status != HAL_STATUS_SUCCESS)
+		return false;
+
+	status = odm_config_bb_with_header_file(dm, CONFIG_BB_AGC_TAB);
+	if (status != HAL_STATUS_SUCCESS)
+		return false;
+
+	return true;
+}
+
+static bool rtl_phydm_phy_rf_config(struct rtl_priv *rtlpriv)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	struct rtl_phy *rtlphy = &rtlpriv->phy;
+	enum hal_status status;
+	enum odm_rf_radio_path rfpath;
+
+	for (rfpath = 0; rfpath < rtlphy->num_total_rfpath; rfpath++) {
+		status = odm_config_rf_with_header_file(dm, CONFIG_RF_RADIO,
+							rfpath);
+		if (status != HAL_STATUS_SUCCESS)
+			return false;
+	}
+
+	status = odm_config_rf_with_tx_pwr_track_header_file(dm);
+	if (status != HAL_STATUS_SUCCESS)
+		return false;
+
+	return true;
+}
+
+static bool rtl_phydm_phy_mac_config(struct rtl_priv *rtlpriv)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	enum hal_status status;
+
+	status = odm_config_mac_with_header_file(dm);
+	if (status != HAL_STATUS_SUCCESS)
+		return false;
+
+	return true;
+}
+
+static bool rtl_phydm_trx_mode(struct rtl_priv *rtlpriv,
+			       enum radio_mask tx_path, enum radio_mask rx_path,
+			       bool is_tx2_path)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+
+	if (IS_HARDWARE_TYPE_8822B(rtlpriv))
+		return config_phydm_trx_mode_8822b(dm,
+						   (enum odm_rf_path)tx_path,
+						   (enum odm_rf_path)rx_path,
+						   is_tx2_path);
+
+	return false;
+}
+
+static bool rtl_phydm_watchdog(struct rtl_priv *rtlpriv)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	struct rtl_mac *mac = rtl_mac(rtlpriv);
+	struct rtl_ps_ctl *ppsc = rtl_psc(rtlpriv);
+	bool fw_current_inpsmode = false;
+	bool fw_ps_awake = true;
+	u8 is_linked = false;
+	u8 bsta_state = false;
+	u8 is_bt_enabled = false;
+
+	/* check whether do watchdog */
+	rtlpriv->cfg->ops->get_hw_reg(rtlpriv->hw, HW_VAR_FW_PSMODE_STATUS,
+				      (u8 *)(&fw_current_inpsmode));
+	rtlpriv->cfg->ops->get_hw_reg(rtlpriv->hw, HW_VAR_FWLPS_RF_ON,
+				      (u8 *)(&fw_ps_awake));
+	if (ppsc->p2p_ps_info.p2p_ps_mode)
+		fw_ps_awake = false;
+
+	if ((ppsc->rfpwr_state == ERFON) &&
+	    ((!fw_current_inpsmode) && fw_ps_awake) &&
+	    (!ppsc->rfchange_inprogress))
+		;
+	else
+		return false;
+
+	/* update common info before doing watchdog */
+	if (mac->link_state >= MAC80211_LINKED) {
+		is_linked = true;
+		if (mac->vif && mac->vif->type == NL80211_IFTYPE_STATION)
+			bsta_state = true;
+	}
+
+	if (rtlpriv->cfg->ops->get_btc_status())
+		is_bt_enabled = !rtlpriv->btcoexist.btc_ops->btc_is_bt_disabled(
+			rtlpriv);
+
+	odm_cmn_info_update(dm, ODM_CMNINFO_LINK, is_linked);
+	odm_cmn_info_update(dm, ODM_CMNINFO_STATION_STATE, bsta_state);
+	odm_cmn_info_update(dm, ODM_CMNINFO_BT_ENABLED, is_bt_enabled);
+
+	/* do watchdog */
+	odm_dm_watchdog(dm);
+
+	return true;
+}
+
+static bool rtl_phydm_switch_band(struct rtl_priv *rtlpriv, u8 central_ch)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+
+	if (IS_HARDWARE_TYPE_8822B(rtlpriv))
+		return config_phydm_switch_band_8822b(dm, central_ch);
+
+	return false;
+}
+
+static bool rtl_phydm_switch_channel(struct rtl_priv *rtlpriv, u8 central_ch)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+
+	if (IS_HARDWARE_TYPE_8822B(rtlpriv))
+		return config_phydm_switch_channel_8822b(dm, central_ch);
+
+	return false;
+}
+
+static bool rtl_phydm_switch_bandwidth(struct rtl_priv *rtlpriv,
+				       u8 primary_ch_idx,
+				       enum ht_channel_width bandwidth)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	enum odm_bw odm_bw = (enum odm_bw)bandwidth;
+
+	if (IS_HARDWARE_TYPE_8822B(rtlpriv))
+		return config_phydm_switch_bandwidth_8822b(dm, primary_ch_idx,
+							   odm_bw);
+
+	return false;
+}
+
+static bool rtl_phydm_iq_calibrate(struct rtl_priv *rtlpriv)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+
+	if (IS_HARDWARE_TYPE_8822B(rtlpriv))
+		phy_iq_calibrate_8822b(dm, false);
+	else
+		return false;
+
+	return true;
+}
+
+static bool rtl_phydm_clear_txpowertracking_state(struct rtl_priv *rtlpriv)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+
+	odm_clear_txpowertracking_state(dm);
+
+	return true;
+}
+
+static bool rtl_phydm_pause_dig(struct rtl_priv *rtlpriv, bool pause)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+
+	if (pause)
+		odm_pause_dig(dm, PHYDM_PAUSE, PHYDM_PAUSE_LEVEL_0, 0x1e);
+	else /* resume */
+		odm_pause_dig(dm, PHYDM_RESUME, PHYDM_PAUSE_LEVEL_0, 0xff);
+
+	return true;
+}
+
+static u32 rtl_phydm_read_rf_reg(struct rtl_priv *rtlpriv,
+				 enum radio_path rfpath, u32 addr, u32 mask)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	enum odm_rf_radio_path odm_rfpath = (enum odm_rf_radio_path)rfpath;
+
+	if (IS_HARDWARE_TYPE_8822B(rtlpriv))
+		return config_phydm_read_rf_reg_8822b(dm, odm_rfpath, addr,
+						      mask);
+
+	return -1;
+}
+
+static bool rtl_phydm_write_rf_reg(struct rtl_priv *rtlpriv,
+				   enum radio_path rfpath, u32 addr, u32 mask,
+				   u32 data)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	enum odm_rf_radio_path odm_rfpath = (enum odm_rf_radio_path)rfpath;
+
+	if (IS_HARDWARE_TYPE_8822B(rtlpriv))
+		return config_phydm_write_rf_reg_8822b(dm, odm_rfpath, addr,
+						       mask, data);
+
+	return false;
+}
+
+static u8 rtl_phydm_read_txagc(struct rtl_priv *rtlpriv, enum radio_path rfpath,
+			       u8 hw_rate)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	enum odm_rf_radio_path odm_rfpath = (enum odm_rf_radio_path)rfpath;
+
+	if (IS_HARDWARE_TYPE_8822B(rtlpriv))
+		return config_phydm_read_txagc_8822b(dm, odm_rfpath, hw_rate);
+
+	return -1;
+}
+
+static bool rtl_phydm_write_txagc(struct rtl_priv *rtlpriv, u32 power_index,
+				  enum radio_path rfpath, u8 hw_rate)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	enum odm_rf_radio_path odm_rfpath = (enum odm_rf_radio_path)rfpath;
+
+	if (IS_HARDWARE_TYPE_8822B(rtlpriv))
+		return config_phydm_write_txagc_8822b(dm, power_index,
+						      odm_rfpath, hw_rate);
+
+	return false;
+}
+
+static bool rtl_phydm_c2h_content_parsing(struct rtl_priv *rtlpriv, u8 cmd_id,
+					  u8 cmd_len, u8 *content)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+
+	if (phydm_c2H_content_parsing(dm, cmd_id, cmd_len, content))
+		return true;
+
+	return false;
+}
+
+static bool rtl_phydm_query_phy_status(struct rtl_priv *rtlpriv, u8 *phystrpt,
+				       struct ieee80211_hdr *hdr,
+				       struct rtl_stats *pstatus)
+{
+	/* NOTE: phystrpt may be NULL, and need to fill default value */
+
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
+	struct rtl_mac *mac = rtl_mac(rtlpriv);
+	struct dm_per_pkt_info pktinfo; /* input of pydm */
+	struct dm_phy_status_info phy_info; /* output of phydm */
+	__le16 fc = hdr->frame_control;
+
+	/* fill driver pstatus */
+	ether_addr_copy(pstatus->psaddr, ieee80211_get_SA(hdr));
+
+	/* fill pktinfo */
+	memset(&pktinfo, 0, sizeof(pktinfo));
+
+	pktinfo.data_rate = pstatus->rate;
+
+	if (rtlpriv->mac80211.opmode == NL80211_IFTYPE_STATION) {
+		pktinfo.station_id = 0;
+	} else {
+		/* TODO: use rtl_find_sta() to find ID */
+		pktinfo.station_id = 0xFF;
+	}
+
+	pktinfo.is_packet_match_bssid =
+		(!ieee80211_is_ctl(fc) &&
+		 (ether_addr_equal(mac->bssid,
+				   ieee80211_has_tods(fc) ?
+					   hdr->addr1 :
+					   ieee80211_has_fromds(fc) ?
+					   hdr->addr2 :
+					   hdr->addr3)) &&
+		 (!pstatus->hwerror) && (!pstatus->crc) && (!pstatus->icv));
+	pktinfo.is_packet_to_self =
+		pktinfo.is_packet_match_bssid &&
+		(ether_addr_equal(hdr->addr1, rtlefuse->dev_addr));
+	pktinfo.is_to_self = (!pstatus->icv) && (!pstatus->crc) &&
+			     (ether_addr_equal(hdr->addr1, rtlefuse->dev_addr));
+	pktinfo.is_packet_beacon = (ieee80211_is_beacon(fc) ? true : false);
+
+	/* query phy status */
+	if (phystrpt)
+		odm_phy_status_query(dm, &phy_info, phystrpt, &pktinfo);
+	else
+		memset(&phy_info, 0, sizeof(phy_info));
+
+	/* copy phy_info from phydm to driver */
+	pstatus->rx_pwdb_all = phy_info.rx_pwdb_all;
+	pstatus->bt_rx_rssi_percentage = phy_info.bt_rx_rssi_percentage;
+	pstatus->recvsignalpower = phy_info.recv_signal_power;
+	pstatus->signalquality = phy_info.signal_quality;
+	pstatus->rx_mimo_signalquality[0] = phy_info.rx_mimo_signal_quality[0];
+	pstatus->rx_mimo_signalquality[1] = phy_info.rx_mimo_signal_quality[1];
+	pstatus->rx_packet_bw =
+		phy_info.band_width; /* HT_CHANNEL_WIDTH_20 <- ODM_BW20M */
+
+	/* fill driver pstatus */
+	pstatus->packet_matchbssid = pktinfo.is_packet_match_bssid;
+	pstatus->packet_toself = pktinfo.is_packet_to_self;
+	pstatus->packet_beacon = pktinfo.is_packet_beacon;
+
+	return true;
+}
+
+static u8 rtl_phydm_rate_id_mapping(struct rtl_priv *rtlpriv,
+				    enum wireless_mode wireless_mode,
+				    enum rf_type rf_type,
+				    enum ht_channel_width bw)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+
+	return phydm_rate_id_mapping(dm, wireless_mode, rf_type, bw);
+}
+
+static bool rtl_phydm_get_ra_bitmap(struct rtl_priv *rtlpriv,
+				    enum wireless_mode wireless_mode,
+				    enum rf_type rf_type,
+				    enum ht_channel_width bw,
+				    u8 tx_rate_level, /* 0~6 */
+				    u32 *tx_bitmap_msb,
+				    u32 *tx_bitmap_lsb)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	const u8 mimo_ps_enable = 0;
+	const u8 disable_cck_rate = 0;
+
+	phydm_update_hal_ra_mask(dm, wireless_mode, rf_type, bw, mimo_ps_enable,
+				 disable_cck_rate, tx_bitmap_msb, tx_bitmap_lsb,
+				 tx_rate_level);
+
+	return true;
+}
+
+static u8 _rtl_phydm_get_macid(struct rtl_priv *rtlpriv,
+			       struct ieee80211_sta *sta)
+{
+	struct rtl_mac *mac = rtl_mac(rtlpriv);
+
+	if (mac->opmode == NL80211_IFTYPE_STATION ||
+	    mac->opmode == NL80211_IFTYPE_MESH_POINT) {
+		return 0;
+	} else if (mac->opmode == NL80211_IFTYPE_AP ||
+		   mac->opmode == NL80211_IFTYPE_ADHOC)
+		return sta->aid + 1;
+
+	return 0;
+}
+
+static bool rtl_phydm_add_sta(struct rtl_priv *rtlpriv,
+			      struct ieee80211_sta *sta)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	struct rtl_sta_info *sta_entry = (struct rtl_sta_info *)sta->drv_priv;
+	u8 mac_id = _rtl_phydm_get_macid(rtlpriv, sta);
+
+	odm_cmn_info_ptr_array_hook(dm, ODM_CMNINFO_STA_STATUS, mac_id,
+				    sta_entry);
+
+	return true;
+}
+
+static bool rtl_phydm_del_sta(struct rtl_priv *rtlpriv,
+			      struct ieee80211_sta *sta)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	u8 mac_id = _rtl_phydm_get_macid(rtlpriv, sta);
+
+	odm_cmn_info_ptr_array_hook(dm, ODM_CMNINFO_STA_STATUS, mac_id, NULL);
+
+	return true;
+}
+
+static u32 rtl_phydm_get_version(struct rtl_priv *rtlpriv)
+{
+	u32 ver = 0;
+
+	if (IS_HARDWARE_TYPE_8822B(rtlpriv))
+		ver = RELEASE_VERSION_8822B;
+
+	return ver;
+}
+
+static bool rtl_phydm_modify_ra_pcr_threshold(struct rtl_priv *rtlpriv,
+					      u8 ra_offset_direction,
+					      u8 ra_threshold_offset)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+
+	phydm_modify_RA_PCR_threshold(dm, ra_offset_direction,
+				      ra_threshold_offset);
+
+	return true;
+}
+
+static u32 rtl_phydm_query_counter(struct rtl_priv *rtlpriv,
+				   const char *info_type)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+	static const struct query_entry {
+		const char *query_name;
+		enum phydm_info_query query_id;
+	} query_table[] = {
+#define QUERY_ENTRY(name)	{#name, name}
+		QUERY_ENTRY(PHYDM_INFO_FA_OFDM),
+		QUERY_ENTRY(PHYDM_INFO_FA_CCK),
+		QUERY_ENTRY(PHYDM_INFO_CCA_OFDM),
+		QUERY_ENTRY(PHYDM_INFO_CCA_CCK),
+		QUERY_ENTRY(PHYDM_INFO_CRC32_OK_CCK),
+		QUERY_ENTRY(PHYDM_INFO_CRC32_OK_LEGACY),
+		QUERY_ENTRY(PHYDM_INFO_CRC32_OK_HT),
+		QUERY_ENTRY(PHYDM_INFO_CRC32_OK_VHT),
+		QUERY_ENTRY(PHYDM_INFO_CRC32_ERROR_CCK),
+		QUERY_ENTRY(PHYDM_INFO_CRC32_ERROR_LEGACY),
+		QUERY_ENTRY(PHYDM_INFO_CRC32_ERROR_HT),
+		QUERY_ENTRY(PHYDM_INFO_CRC32_ERROR_VHT),
+	};
+#define QUERY_TABLE_SIZE	ARRAY_SIZE(query_table)
+
+	int i;
+	const struct query_entry *entry;
+
+	if (!strcmp(info_type, "IQK_TOTAL"))
+		return dm->n_iqk_cnt;
+
+	if (!strcmp(info_type, "IQK_OK"))
+		return dm->n_iqk_ok_cnt;
+
+	if (!strcmp(info_type, "IQK_FAIL"))
+		return dm->n_iqk_fail_cnt;
+
+	for (i = 0; i < QUERY_TABLE_SIZE; i++) {
+		entry = &query_table[i];
+
+		if (!strcmp(info_type, entry->query_name))
+			return phydm_cmn_info_query(dm, entry->query_id);
+	}
+
+	pr_err("Unrecognized info_type:%s!!!!:\n", info_type);
+
+	return 0xDEADDEAD;
+}
+
+static bool rtl_phydm_debug_cmd(struct rtl_priv *rtlpriv, char *in, u32 in_len,
+				char *out, u32 out_len)
+{
+	struct phy_dm_struct *dm = rtlpriv_to_phydm(rtlpriv);
+
+	phydm_cmd(dm, in, in_len, 1, out, out_len);
+
+	return true;
+}
+
+static struct rtl_phydm_ops rtl_phydm_operation = {
+	/* init/deinit priv */
+	.phydm_init_priv = rtl_phydm_init_priv,
+	.phydm_deinit_priv = rtl_phydm_deinit_priv,
+	.phydm_load_txpower_by_rate = rtl_phydm_load_txpower_by_rate,
+	.phydm_load_txpower_limit = rtl_phydm_load_txpower_limit,
+
+	/* init hw */
+	.phydm_init_dm = rtl_phydm_init_dm,
+	.phydm_deinit_dm = rtl_phydm_deinit_dm,
+	.phydm_reset_dm = rtl_phydm_reset_dm,
+	.phydm_parameter_init = rtl_phydm_parameter_init,
+	.phydm_phy_bb_config = rtl_phydm_phy_bb_config,
+	.phydm_phy_rf_config = rtl_phydm_phy_rf_config,
+	.phydm_phy_mac_config = rtl_phydm_phy_mac_config,
+	.phydm_trx_mode = rtl_phydm_trx_mode,
+
+	/* watchdog */
+	.phydm_watchdog = rtl_phydm_watchdog,
+
+	/* channel */
+	.phydm_switch_band = rtl_phydm_switch_band,
+	.phydm_switch_channel = rtl_phydm_switch_channel,
+	.phydm_switch_bandwidth = rtl_phydm_switch_bandwidth,
+	.phydm_iq_calibrate = rtl_phydm_iq_calibrate,
+	.phydm_clear_txpowertracking_state =
+		rtl_phydm_clear_txpowertracking_state,
+	.phydm_pause_dig = rtl_phydm_pause_dig,
+
+	/* read/write reg */
+	.phydm_read_rf_reg = rtl_phydm_read_rf_reg,
+	.phydm_write_rf_reg = rtl_phydm_write_rf_reg,
+	.phydm_read_txagc = rtl_phydm_read_txagc,
+	.phydm_write_txagc = rtl_phydm_write_txagc,
+
+	/* RX */
+	.phydm_c2h_content_parsing = rtl_phydm_c2h_content_parsing,
+	.phydm_query_phy_status = rtl_phydm_query_phy_status,
+
+	/* TX */
+	.phydm_rate_id_mapping = rtl_phydm_rate_id_mapping,
+	.phydm_get_ra_bitmap = rtl_phydm_get_ra_bitmap,
+
+	/* STA */
+	.phydm_add_sta = rtl_phydm_add_sta,
+	.phydm_del_sta = rtl_phydm_del_sta,
+
+	/* BTC */
+	.phydm_get_version = rtl_phydm_get_version,
+	.phydm_modify_ra_pcr_threshold = rtl_phydm_modify_ra_pcr_threshold,
+	.phydm_query_counter = rtl_phydm_query_counter,
+
+	/* debug */
+	.phydm_debug_cmd = rtl_phydm_debug_cmd,
+};
+
+struct rtl_phydm_ops *rtl_phydm_get_ops_pointer(void)
+{
+	return &rtl_phydm_operation;
+}
+EXPORT_SYMBOL(rtl_phydm_get_ops_pointer);
+
+/* ********************************************************
+ * Define phydm callout function in below
+ * ********************************************************
+ */
+
+u8 phy_get_tx_power_index(void *adapter, u8 rf_path, u8 rate,
+			  enum ht_channel_width bandwidth, u8 channel)
+{
+	/* rate: DESC_RATE1M */
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)adapter;
+
+	return rtlpriv->cfg->ops->get_txpower_index(rtlpriv->hw, rf_path, rate,
+						    bandwidth, channel);
+}
+
+void phy_set_tx_power_index_by_rs(void *adapter, u8 ch, u8 path, u8 rs)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)adapter;
+
+	return rtlpriv->cfg->ops->set_tx_power_index_by_rs(rtlpriv->hw, ch,
+							   path, rs);
+}
+
+void phy_store_tx_power_by_rate(void *adapter, u32 band, u32 rfpath, u32 txnum,
+				u32 regaddr, u32 bitmask, u32 data)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)adapter;
+
+	rtlpriv->cfg->ops->store_tx_power_by_rate(
+		rtlpriv->hw, band, rfpath, txnum, regaddr, bitmask, data);
+}
+
+void phy_set_tx_power_limit(void *dm, u8 *regulation, u8 *band, u8 *bandwidth,
+			    u8 *rate_section, u8 *rf_path, u8 *channel,
+			    u8 *power_limit)
+{
+	struct rtl_priv *rtlpriv =
+		(struct rtl_priv *)((struct phy_dm_struct *)dm)->adapter;
+
+	rtlpriv->cfg->ops->phy_set_txpower_limit(rtlpriv->hw, regulation, band,
+						 bandwidth, rate_section,
+						 rf_path, channel, power_limit);
+}
+
+void rtl_hal_update_ra_mask(void *adapter, struct rtl_sta_info *psta,
+			    u8 rssi_level)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)adapter;
+	struct ieee80211_sta *sta =
+		container_of((void *)psta, struct ieee80211_sta, drv_priv);
+
+	rtlpriv->cfg->ops->update_rate_tbl(rtlpriv->hw, sta, rssi_level, false);
+}
+
+MODULE_AUTHOR("Realtek WlanFAE	<wlanfae@realtek.com>");
+MODULE_AUTHOR("Larry Finger	<Larry.FInger@lwfinger.net>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Realtek 802.11n PCI wireless core");
diff --git a/drivers/staging/rtlwifi/phydm/rtl_phydm.h b/drivers/staging/rtlwifi/phydm/rtl_phydm.h
new file mode 100644
index 000000000000..483d2418699b
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/rtl_phydm.h
@@ -0,0 +1,45 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __RTL_PHYDM_H__
+#define __RTL_PHYDM_H__
+
+struct rtl_phydm_ops *rtl_phydm_get_ops_pointer(void);
+
+#define rtlpriv_to_phydm(priv)                                                 \
+	((struct phy_dm_struct *)((priv)->phydm.internal))
+
+u8 phy_get_tx_power_index(void *adapter, u8 rf_path, u8 rate,
+			  enum ht_channel_width bandwidth, u8 channel);
+void phy_set_tx_power_index_by_rs(void *adapter, u8 ch, u8 path, u8 rs);
+void phy_store_tx_power_by_rate(void *adapter, u32 band, u32 rfpath, u32 txnum,
+				u32 regaddr, u32 bitmask, u32 data);
+void phy_set_tx_power_limit(void *dm, u8 *regulation, u8 *band, u8 *bandwidth,
+			    u8 *rate_section, u8 *rf_path, u8 *channel,
+			    u8 *power_limit);
+
+void rtl_hal_update_ra_mask(void *adapter, struct rtl_sta_info *psta,
+			    u8 rssi_level);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/txbf/halcomtxbf.h b/drivers/staging/rtlwifi/phydm/txbf/halcomtxbf.h
new file mode 100644
index 000000000000..6cacca12d792
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/txbf/halcomtxbf.h
@@ -0,0 +1,67 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __HAL_COM_TXBF_H__
+#define __HAL_COM_TXBF_H__
+
+enum txbf_set_type {
+	TXBF_SET_SOUNDING_ENTER,
+	TXBF_SET_SOUNDING_LEAVE,
+	TXBF_SET_SOUNDING_RATE,
+	TXBF_SET_SOUNDING_STATUS,
+	TXBF_SET_SOUNDING_FW_NDPA,
+	TXBF_SET_SOUNDING_CLK,
+	TXBF_SET_TX_PATH_RESET,
+	TXBF_SET_GET_TX_RATE
+};
+
+enum txbf_get_type {
+	TXBF_GET_EXPLICIT_BEAMFORMEE,
+	TXBF_GET_EXPLICIT_BEAMFORMER,
+	TXBF_GET_MU_MIMO_STA,
+	TXBF_GET_MU_MIMO_AP
+};
+
+/* 2 HAL TXBF related */
+struct _HAL_TXBF_INFO {
+	u8 txbf_idx;
+	u8 ndpa_idx;
+	u8 BW;
+	u8 rate;
+
+	struct timer_list txbf_fw_ndpa_timer;
+};
+
+#define hal_com_txbf_beamform_init(dm_void) NULL
+#define hal_com_txbf_config_gtab(dm_void) NULL
+#define hal_com_txbf_enter_work_item_callback(_adapter) NULL
+#define hal_com_txbf_leave_work_item_callback(_adapter) NULL
+#define hal_com_txbf_fw_ndpa_work_item_callback(_adapter) NULL
+#define hal_com_txbf_clk_work_item_callback(_adapter) NULL
+#define hal_com_txbf_rate_work_item_callback(_adapter) NULL
+#define hal_com_txbf_fw_ndpa_timer_callback(_adapter) NULL
+#define hal_com_txbf_status_work_item_callback(_adapter) NULL
+#define hal_com_txbf_get(_adapter, _get_type, _pout_buf)
+
+#endif /*  #ifndef __HAL_COM_TXBF_H__ */
diff --git a/drivers/staging/rtlwifi/phydm/txbf/haltxbf8822b.h b/drivers/staging/rtlwifi/phydm/txbf/haltxbf8822b.h
new file mode 100644
index 000000000000..5c92c4326f7e
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/txbf/haltxbf8822b.h
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __HAL_TXBF_8822B_H__
+#define __HAL_TXBF_8822B_H__
+
+#define hal_txbf_8822b_enter(dm_void, idx)
+#define hal_txbf_8822b_leave(dm_void, idx)
+#define hal_txbf_8822b_status(dm_void, idx)
+#define hal_txbf_8822b_fw_txbf(dm_void, idx)
+#define hal_txbf_8822b_config_gtab(dm_void)
+
+void phydm_8822btxbf_rfmode(void *dm_void, u8 su_bfee_cnt, u8 mu_bfee_cnt);
+
+void phydm_8822b_sutxbfer_workaroud(void *dm_void, bool enable_su_bfer, u8 nc,
+				    u8 nr, u8 ng, u8 CB, u8 BW, bool is_vht);
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/txbf/haltxbfinterface.h b/drivers/staging/rtlwifi/phydm/txbf/haltxbfinterface.h
new file mode 100644
index 000000000000..82aeac1ff3e0
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/txbf/haltxbfinterface.h
@@ -0,0 +1,38 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __HAL_TXBF_INTERFACE_H__
+#define __HAL_TXBF_INTERFACE_H__
+
+#define beamforming_get_ndpa_frame(dm, _pdu_os)
+#define beamforming_get_report_frame(adapter, precv_frame) RT_STATUS_FAILURE
+#define send_fw_ht_ndpa_packet(dm_void, RA, BW)
+#define send_sw_ht_ndpa_packet(dm_void, RA, BW)
+#define send_fw_vht_ndpa_packet(dm_void, RA, AID, BW)
+#define send_sw_vht_ndpa_packet(dm_void, RA, AID, BW)
+#define send_sw_vht_gid_mgnt_frame(dm_void, RA, idx)
+#define send_sw_vht_bf_report_poll(dm_void, RA, is_final_poll)
+#define send_sw_vht_mu_ndpa_packet(dm_void, BW)
+
+#endif
diff --git a/drivers/staging/rtlwifi/phydm/txbf/haltxbfjaguar.h b/drivers/staging/rtlwifi/phydm/txbf/haltxbfjaguar.h
new file mode 100644
index 000000000000..c5ddd9cb9cd5
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/txbf/haltxbfjaguar.h
@@ -0,0 +1,36 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __HAL_TXBF_JAGUAR_H__
+#define __HAL_TXBF_JAGUAR_H__
+
+#define hal_txbf_8812a_set_ndpa_rate(dm_void, BW, rate)
+#define hal_txbf_jaguar_enter(dm_void, idx)
+#define hal_txbf_jaguar_leave(dm_void, idx)
+#define hal_txbf_jaguar_status(dm_void, idx)
+#define hal_txbf_jaguar_fw_txbf(dm_void, idx)
+#define hal_txbf_jaguar_patch(dm_void, operation)
+#define hal_txbf_jaguar_clk_8812a(dm_void)
+
+#endif /*  #ifndef __HAL_TXBF_JAGUAR_H__ */
diff --git a/drivers/staging/rtlwifi/phydm/txbf/phydm_hal_txbf_api.h b/drivers/staging/rtlwifi/phydm/txbf/phydm_hal_txbf_api.h
new file mode 100644
index 000000000000..41358fce2875
--- /dev/null
+++ b/drivers/staging/rtlwifi/phydm/txbf/phydm_hal_txbf_api.h
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __PHYDM_HAL_TXBF_API_H__
+#define __PHYDM_HAL_TXBF_API_H__
+
+#define tx_bf_nr(a, b) ((a > b) ? (b) : (a))
+
+u8 beamforming_get_htndp_tx_rate(void *dm_void, u8 comp_steering_num_of_bfer);
+
+u8 beamforming_get_vht_ndp_tx_rate(void *dm_void, u8 comp_steering_num_of_bfer);
+
+u8 phydm_get_beamforming_sounding_info(void *dm_void, u16 *troughput,
+				       u8 total_bfee_num, u8 *tx_rate);
+
+u8 phydm_get_ndpa_rate(void *dm_void);
+
+u8 phydm_get_mu_bfee_snding_decision(void *dm_void, u16 throughput);
+
+#endif
-- 
2.19.1

