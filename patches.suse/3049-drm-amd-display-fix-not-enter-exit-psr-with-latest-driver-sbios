From: Charlene Liu <charlene.liu@amd.com>
Date: Wed, 16 Aug 2017 20:25:42 -0400
Subject: drm/amd/display: fix not enter/exit PSR with latest driver/SBIOS
Git-commit: b05dee52efdcb6286a28be4dddeb450b58591c6d
Patch-mainline: v4.15-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Signed-off-by: Charlene Liu <charlene.liu@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Acked-by: Harry Wentland <Harry.Wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/amd/display/dc/core/dc_link.c   |    2 +-
 drivers/gpu/drm/amd/display/dc/dce/dce_clocks.c |    3 ++-
 drivers/gpu/drm/amd/display/dc/dce/dce_dmcu.c   |    5 ++++-
 3 files changed, 7 insertions(+), 3 deletions(-)

--- a/drivers/gpu/drm/amd/display/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
@@ -1975,7 +1975,7 @@ bool dc_link_setup_psr(struct dc_link *l
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 		/*skip power down the single pipe since it blocks the cstate*/
 		if (ASIC_REV_IS_RAVEN(link->ctx->asic_id.hw_internal_rev))
-			psr_context->psr_level.bits.SKIP_SINGLE_OTG_DISABLE = true;
+			psr_context->psr_level.bits.SKIP_SINGLE_OTG_DISABLE = false;
 #endif
 
 		/* SMU will perform additional powerdown sequence.
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_clocks.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_clocks.c
@@ -417,9 +417,10 @@ static int dce112_set_clock(
 
 	bp->funcs->set_dce_clock(bp, &dce_clk_params);
 
-	if (abm->funcs->is_dmcu_initialized(abm))
+	if (abm->funcs->is_dmcu_initialized(abm) && clk_dce->dfs_bypass_disp_clk != actual_clock)
 		dmcu->funcs->set_psr_wait_loop(dmcu,
 				actual_clock / 1000 / 7);
+	clk_dce->dfs_bypass_disp_clk = actual_clock;
 	return actual_clock;
 }
 
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_dmcu.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_dmcu.c
@@ -260,6 +260,8 @@ static void dce_psr_wait_loop(
 {
 	struct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);
 	union dce_dmcu_psr_config_data_wait_loop_reg1 masterCmdData1;
+	if (cached_wait_loop_number == wait_loop_number)
+		return;
 
 	/* waitDMCUReadyForCmd */
 	REG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 1, 10000);
@@ -500,7 +502,7 @@ static void dcn10_psr_wait_loop(
 {
 	struct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);
 	union dce_dmcu_psr_config_data_wait_loop_reg1 masterCmdData1;
-
+	if (wait_loop_number != 0) {
 	/* waitDMCUReadyForCmd */
 	REG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 1, 10000);
 
@@ -514,6 +516,7 @@ static void dcn10_psr_wait_loop(
 
 	/* notifyDMCUMsg */
 	REG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);
+	}
 }
 
 static void dcn10_get_psr_wait_loop(unsigned int *psr_wait_loop_number)
