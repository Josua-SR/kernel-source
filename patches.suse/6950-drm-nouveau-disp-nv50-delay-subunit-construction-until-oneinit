From: Ben Skeggs <bskeggs@redhat.com>
Date: Tue, 8 May 2018 20:39:46 +1000
Subject: drm/nouveau/disp/nv50-: delay subunit construction until oneinit
Git-commit: 3b9ba66ab0e027e6d7a2b9b62cbb5cd547421ebd
Patch-mainline: v4.18-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

We should be reading registers to determine which subunits are really
present on a given board, and this needs to be done after DEVINIT.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c |    6 ++
 drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c |   66 ++++++++++++++----------
 drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.h |    4 +
 drivers/gpu/drm/nouveau/nvkm/engine/disp/priv.h |    1 
 4 files changed, 51 insertions(+), 26 deletions(-)

--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -376,6 +376,12 @@ nvkm_disp_oneinit(struct nvkm_engine *en
 	if (ret)
 		return ret;
 
+	if (disp->func->oneinit) {
+		ret = disp->func->oneinit(disp);
+		if (ret)
+			return ret;
+	}
+
 	i = 0;
 	list_for_each_entry(head, &disp->head, head)
 		i = max(i, head->id + 1);
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -59,9 +59,44 @@ nv50_disp_dtor_(struct nvkm_disp *base)
 	return disp;
 }
 
+static int
+nv50_disp_oneinit_(struct nvkm_disp *base)
+{
+	struct nv50_disp *disp = nv50_disp(base);
+	const struct nv50_disp_func *func = disp->func;
+	int ret, i;
+
+	for (i = 0; func->head.new && i < disp->head.nr; i++) {
+		ret = func->head.new(&disp->base, i);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; func->dac.new && i < func->dac.nr; i++) {
+		ret = func->dac.new(&disp->base, i);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; func->pior.new && i < func->pior.nr; i++) {
+		ret = func->pior.new(&disp->base, i);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; func->sor.new && i < func->sor.nr; i++) {
+		ret = func->sor.new(&disp->base, i);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
 static const struct nvkm_disp_func
 nv50_disp_ = {
 	.dtor = nv50_disp_dtor_,
+	.oneinit = nv50_disp_oneinit_,
 	.intr = nv50_disp_intr_,
 	.root = nv50_disp_root_,
 };
@@ -71,7 +106,7 @@ nv50_disp_new_(const struct nv50_disp_fu
 	       int index, int heads, struct nvkm_disp **pdisp)
 {
 	struct nv50_disp *disp;
-	int ret, i;
+	int ret;
 
 	if (!(disp = kzalloc(sizeof(*disp), GFP_KERNEL)))
 		return -ENOMEM;
@@ -85,33 +120,12 @@ nv50_disp_new_(const struct nv50_disp_fu
 	disp->wq = create_singlethread_workqueue("nvkm-disp");
 	if (!disp->wq)
 		return -ENOMEM;
-	INIT_WORK(&disp->supervisor, func->super);
-
-	for (i = 0; func->head.new && i < heads; i++) {
-		ret = func->head.new(&disp->base, i);
-		if (ret)
-			return ret;
-	}
-
-	for (i = 0; func->dac.new && i < func->dac.nr; i++) {
-		ret = func->dac.new(&disp->base, i);
-		if (ret)
-			return ret;
-	}
-
-	for (i = 0; func->pior.new && i < func->pior.nr; i++) {
-		ret = func->pior.new(&disp->base, i);
-		if (ret)
-			return ret;
-	}
 
-	for (i = 0; func->sor.new && i < func->sor.nr; i++) {
-		ret = func->sor.new(&disp->base, i);
-		if (ret)
-			return ret;
-	}
+	INIT_WORK(&disp->supervisor, func->super);
+	disp->head.nr = heads;
 
-	return nvkm_event_init(func->uevent, 1, 1 + (heads * 4), &disp->uevent);
+	return nvkm_event_init(func->uevent, 1, ARRAY_SIZE(disp->chan),
+			       &disp->uevent);
 }
 
 static u32
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.h
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.h
@@ -15,6 +15,10 @@ struct nv50_disp {
 	struct nvkm_event uevent;
 
 	struct {
+		int nr;
+	} head;
+
+	struct {
 		u32 lvdsconf;
 	} sor;
 
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/priv.h
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/priv.h
@@ -11,6 +11,7 @@ void nvkm_disp_vblank(struct nvkm_disp *
 
 struct nvkm_disp_func {
 	void *(*dtor)(struct nvkm_disp *);
+	int (*oneinit)(struct nvkm_disp *);
 	void (*intr)(struct nvkm_disp *);
 
 	const struct nvkm_disp_oclass *(*root)(struct nvkm_disp *);
