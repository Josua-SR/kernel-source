From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Tue, 13 Feb 2018 14:00:48 +0200
Subject: drm: omapdrm: venc: Allocate the venc private data structure
 dynamically
Git-commit: 663ac57b285d0176cacb85899b7f79d83f825353
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

The venc private data structure is currently stored as a global
variable. While no platform with multiple VENC encoders currently exists
nor is planned, this doesn't comply with the kernel device model and
should thus be fixed.

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/omapdrm/dss/venc.c |  440 +++++++++++++++++++------------------
 1 file changed, 237 insertions(+), 203 deletions(-)

--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -319,7 +319,7 @@ static enum venc_videomode venc_get_vide
 	return VENC_MODE_UNKNOWN;
 }
 
-static struct {
+struct venc_device {
 	struct platform_device *pdev;
 	void __iomem *base;
 	struct mutex venc_lock;
@@ -337,81 +337,87 @@ static struct {
 	bool requires_tv_dac_clk;
 
 	struct omap_dss_device output;
-} venc;
+};
+
+#define dssdev_to_venc(dssdev) container_of(dssdev, struct venc_device, output)
 
-static inline void venc_write_reg(int idx, u32 val)
+static inline void venc_write_reg(struct venc_device *venc, int idx, u32 val)
 {
-	__raw_writel(val, venc.base + idx);
+	__raw_writel(val, venc->base + idx);
 }
 
-static inline u32 venc_read_reg(int idx)
+static inline u32 venc_read_reg(struct venc_device *venc, int idx)
 {
-	u32 l = __raw_readl(venc.base + idx);
+	u32 l = __raw_readl(venc->base + idx);
 	return l;
 }
 
-static void venc_write_config(const struct venc_config *config)
+static void venc_write_config(struct venc_device *venc,
+			      const struct venc_config *config)
 {
 	DSSDBG("write venc conf\n");
 
-	venc_write_reg(VENC_LLEN, config->llen);
-	venc_write_reg(VENC_FLENS, config->flens);
-	venc_write_reg(VENC_CC_CARR_WSS_CARR, config->cc_carr_wss_carr);
-	venc_write_reg(VENC_C_PHASE, config->c_phase);
-	venc_write_reg(VENC_GAIN_U, config->gain_u);
-	venc_write_reg(VENC_GAIN_V, config->gain_v);
-	venc_write_reg(VENC_GAIN_Y, config->gain_y);
-	venc_write_reg(VENC_BLACK_LEVEL, config->black_level);
-	venc_write_reg(VENC_BLANK_LEVEL, config->blank_level);
-	venc_write_reg(VENC_M_CONTROL, config->m_control);
-	venc_write_reg(VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |
-			venc.wss_data);
-	venc_write_reg(VENC_S_CARR, config->s_carr);
-	venc_write_reg(VENC_L21__WC_CTL, config->l21__wc_ctl);
-	venc_write_reg(VENC_SAVID__EAVID, config->savid__eavid);
-	venc_write_reg(VENC_FLEN__FAL, config->flen__fal);
-	venc_write_reg(VENC_LAL__PHASE_RESET, config->lal__phase_reset);
-	venc_write_reg(VENC_HS_INT_START_STOP_X, config->hs_int_start_stop_x);
-	venc_write_reg(VENC_HS_EXT_START_STOP_X, config->hs_ext_start_stop_x);
-	venc_write_reg(VENC_VS_INT_START_X, config->vs_int_start_x);
-	venc_write_reg(VENC_VS_INT_STOP_X__VS_INT_START_Y,
+	venc_write_reg(venc, VENC_LLEN, config->llen);
+	venc_write_reg(venc, VENC_FLENS, config->flens);
+	venc_write_reg(venc, VENC_CC_CARR_WSS_CARR, config->cc_carr_wss_carr);
+	venc_write_reg(venc, VENC_C_PHASE, config->c_phase);
+	venc_write_reg(venc, VENC_GAIN_U, config->gain_u);
+	venc_write_reg(venc, VENC_GAIN_V, config->gain_v);
+	venc_write_reg(venc, VENC_GAIN_Y, config->gain_y);
+	venc_write_reg(venc, VENC_BLACK_LEVEL, config->black_level);
+	venc_write_reg(venc, VENC_BLANK_LEVEL, config->blank_level);
+	venc_write_reg(venc, VENC_M_CONTROL, config->m_control);
+	venc_write_reg(venc, VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |
+		       venc->wss_data);
+	venc_write_reg(venc, VENC_S_CARR, config->s_carr);
+	venc_write_reg(venc, VENC_L21__WC_CTL, config->l21__wc_ctl);
+	venc_write_reg(venc, VENC_SAVID__EAVID, config->savid__eavid);
+	venc_write_reg(venc, VENC_FLEN__FAL, config->flen__fal);
+	venc_write_reg(venc, VENC_LAL__PHASE_RESET, config->lal__phase_reset);
+	venc_write_reg(venc, VENC_HS_INT_START_STOP_X,
+		       config->hs_int_start_stop_x);
+	venc_write_reg(venc, VENC_HS_EXT_START_STOP_X,
+		       config->hs_ext_start_stop_x);
+	venc_write_reg(venc, VENC_VS_INT_START_X, config->vs_int_start_x);
+	venc_write_reg(venc, VENC_VS_INT_STOP_X__VS_INT_START_Y,
 		       config->vs_int_stop_x__vs_int_start_y);
-	venc_write_reg(VENC_VS_INT_STOP_Y__VS_EXT_START_X,
+	venc_write_reg(venc, VENC_VS_INT_STOP_Y__VS_EXT_START_X,
 		       config->vs_int_stop_y__vs_ext_start_x);
-	venc_write_reg(VENC_VS_EXT_STOP_X__VS_EXT_START_Y,
+	venc_write_reg(venc, VENC_VS_EXT_STOP_X__VS_EXT_START_Y,
 		       config->vs_ext_stop_x__vs_ext_start_y);
-	venc_write_reg(VENC_VS_EXT_STOP_Y, config->vs_ext_stop_y);
-	venc_write_reg(VENC_AVID_START_STOP_X, config->avid_start_stop_x);
-	venc_write_reg(VENC_AVID_START_STOP_Y, config->avid_start_stop_y);
-	venc_write_reg(VENC_FID_INT_START_X__FID_INT_START_Y,
+	venc_write_reg(venc, VENC_VS_EXT_STOP_Y, config->vs_ext_stop_y);
+	venc_write_reg(venc, VENC_AVID_START_STOP_X, config->avid_start_stop_x);
+	venc_write_reg(venc, VENC_AVID_START_STOP_Y, config->avid_start_stop_y);
+	venc_write_reg(venc, VENC_FID_INT_START_X__FID_INT_START_Y,
 		       config->fid_int_start_x__fid_int_start_y);
-	venc_write_reg(VENC_FID_INT_OFFSET_Y__FID_EXT_START_X,
+	venc_write_reg(venc, VENC_FID_INT_OFFSET_Y__FID_EXT_START_X,
 		       config->fid_int_offset_y__fid_ext_start_x);
-	venc_write_reg(VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y,
+	venc_write_reg(venc, VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y,
 		       config->fid_ext_start_y__fid_ext_offset_y);
 
-	venc_write_reg(VENC_DAC_B__DAC_C,  venc_read_reg(VENC_DAC_B__DAC_C));
-	venc_write_reg(VENC_VIDOUT_CTRL, config->vidout_ctrl);
-	venc_write_reg(VENC_HFLTR_CTRL, config->hfltr_ctrl);
-	venc_write_reg(VENC_X_COLOR, config->x_color);
-	venc_write_reg(VENC_LINE21, config->line21);
-	venc_write_reg(VENC_LN_SEL, config->ln_sel);
-	venc_write_reg(VENC_HTRIGGER_VTRIGGER, config->htrigger_vtrigger);
-	venc_write_reg(VENC_TVDETGP_INT_START_STOP_X,
+	venc_write_reg(venc, VENC_DAC_B__DAC_C,
+		       venc_read_reg(venc, VENC_DAC_B__DAC_C));
+	venc_write_reg(venc, VENC_VIDOUT_CTRL, config->vidout_ctrl);
+	venc_write_reg(venc, VENC_HFLTR_CTRL, config->hfltr_ctrl);
+	venc_write_reg(venc, VENC_X_COLOR, config->x_color);
+	venc_write_reg(venc, VENC_LINE21, config->line21);
+	venc_write_reg(venc, VENC_LN_SEL, config->ln_sel);
+	venc_write_reg(venc, VENC_HTRIGGER_VTRIGGER, config->htrigger_vtrigger);
+	venc_write_reg(venc, VENC_TVDETGP_INT_START_STOP_X,
 		       config->tvdetgp_int_start_stop_x);
-	venc_write_reg(VENC_TVDETGP_INT_START_STOP_Y,
+	venc_write_reg(venc, VENC_TVDETGP_INT_START_STOP_Y,
 		       config->tvdetgp_int_start_stop_y);
-	venc_write_reg(VENC_GEN_CTRL, config->gen_ctrl);
-	venc_write_reg(VENC_F_CONTROL, config->f_control);
-	venc_write_reg(VENC_SYNC_CTRL, config->sync_ctrl);
+	venc_write_reg(venc, VENC_GEN_CTRL, config->gen_ctrl);
+	venc_write_reg(venc, VENC_F_CONTROL, config->f_control);
+	venc_write_reg(venc, VENC_SYNC_CTRL, config->sync_ctrl);
 }
 
-static void venc_reset(void)
+static void venc_reset(struct venc_device *venc)
 {
 	int t = 1000;
 
-	venc_write_reg(VENC_F_CONTROL, 1<<8);
-	while (venc_read_reg(VENC_F_CONTROL) & (1<<8)) {
+	venc_write_reg(venc, VENC_F_CONTROL, 1<<8);
+	while (venc_read_reg(venc, VENC_F_CONTROL) & (1<<8)) {
 		if (--t == 0) {
 			DSSERR("Failed to reset venc\n");
 			return;
@@ -425,24 +431,24 @@ static void venc_reset(void)
 #endif
 }
 
-static int venc_runtime_get(void)
+static int venc_runtime_get(struct venc_device *venc)
 {
 	int r;
 
 	DSSDBG("venc_runtime_get\n");
 
-	r = pm_runtime_get_sync(&venc.pdev->dev);
+	r = pm_runtime_get_sync(&venc->pdev->dev);
 	WARN_ON(r < 0);
 	return r < 0 ? r : 0;
 }
 
-static void venc_runtime_put(void)
+static void venc_runtime_put(struct venc_device *venc)
 {
 	int r;
 
 	DSSDBG("venc_runtime_put\n");
 
-	r = pm_runtime_put_sync(&venc.pdev->dev);
+	r = pm_runtime_put_sync(&venc->pdev->dev);
 	WARN_ON(r < 0 && r != -ENOSYS);
 }
 
@@ -458,116 +464,119 @@ static const struct venc_config *venc_ti
 	}
 }
 
-static int venc_power_on(struct omap_dss_device *dssdev)
+static int venc_power_on(struct venc_device *venc)
 {
 	u32 l;
 	int r;
 
-	r = venc_runtime_get();
+	r = venc_runtime_get(venc);
 	if (r)
 		goto err0;
 
-	venc_reset();
-	venc_write_config(venc_timings_to_config(&venc.vm));
+	venc_reset(venc);
+	venc_write_config(venc, venc_timings_to_config(&venc->vm));
 
-	dss_set_venc_output(venc.dss, venc.type);
-	dss_set_dac_pwrdn_bgz(venc.dss, 1);
+	dss_set_venc_output(venc->dss, venc->type);
+	dss_set_dac_pwrdn_bgz(venc->dss, 1);
 
 	l = 0;
 
-	if (venc.type == OMAP_DSS_VENC_TYPE_COMPOSITE)
+	if (venc->type == OMAP_DSS_VENC_TYPE_COMPOSITE)
 		l |= 1 << 1;
 	else /* S-Video */
 		l |= (1 << 0) | (1 << 2);
 
-	if (venc.invert_polarity == false)
+	if (venc->invert_polarity == false)
 		l |= 1 << 3;
 
-	venc_write_reg(VENC_OUTPUT_CONTROL, l);
+	venc_write_reg(venc, VENC_OUTPUT_CONTROL, l);
 
-	dss_mgr_set_timings(&venc.output, &venc.vm);
+	dss_mgr_set_timings(&venc->output, &venc->vm);
 
-	r = regulator_enable(venc.vdda_dac_reg);
+	r = regulator_enable(venc->vdda_dac_reg);
 	if (r)
 		goto err1;
 
-	r = dss_mgr_enable(&venc.output);
+	r = dss_mgr_enable(&venc->output);
 	if (r)
 		goto err2;
 
 	return 0;
 
 err2:
-	regulator_disable(venc.vdda_dac_reg);
+	regulator_disable(venc->vdda_dac_reg);
 err1:
-	venc_write_reg(VENC_OUTPUT_CONTROL, 0);
-	dss_set_dac_pwrdn_bgz(venc.dss, 0);
+	venc_write_reg(venc, VENC_OUTPUT_CONTROL, 0);
+	dss_set_dac_pwrdn_bgz(venc->dss, 0);
 
-	venc_runtime_put();
+	venc_runtime_put(venc);
 err0:
 	return r;
 }
 
-static void venc_power_off(struct omap_dss_device *dssdev)
+static void venc_power_off(struct venc_device *venc)
 {
-	venc_write_reg(VENC_OUTPUT_CONTROL, 0);
-	dss_set_dac_pwrdn_bgz(venc.dss, 0);
+	venc_write_reg(venc, VENC_OUTPUT_CONTROL, 0);
+	dss_set_dac_pwrdn_bgz(venc->dss, 0);
 
-	dss_mgr_disable(&venc.output);
+	dss_mgr_disable(&venc->output);
 
-	regulator_disable(venc.vdda_dac_reg);
+	regulator_disable(venc->vdda_dac_reg);
 
-	venc_runtime_put();
+	venc_runtime_put(venc);
 }
 
 static int venc_display_enable(struct omap_dss_device *dssdev)
 {
-	struct omap_dss_device *out = &venc.output;
+	struct venc_device *venc = dssdev_to_venc(dssdev);
 	int r;
 
 	DSSDBG("venc_display_enable\n");
 
-	mutex_lock(&venc.venc_lock);
+	mutex_lock(&venc->venc_lock);
 
-	if (!out->dispc_channel_connected) {
+	if (!dssdev->dispc_channel_connected) {
 		DSSERR("Failed to enable display: no output/manager\n");
 		r = -ENODEV;
 		goto err0;
 	}
 
-	r = venc_power_on(dssdev);
+	r = venc_power_on(venc);
 	if (r)
 		goto err0;
 
-	venc.wss_data = 0;
+	venc->wss_data = 0;
 
-	mutex_unlock(&venc.venc_lock);
+	mutex_unlock(&venc->venc_lock);
 
 	return 0;
 err0:
-	mutex_unlock(&venc.venc_lock);
+	mutex_unlock(&venc->venc_lock);
 	return r;
 }
 
 static void venc_display_disable(struct omap_dss_device *dssdev)
 {
+	struct venc_device *venc = dssdev_to_venc(dssdev);
+
 	DSSDBG("venc_display_disable\n");
 
-	mutex_lock(&venc.venc_lock);
+	mutex_lock(&venc->venc_lock);
 
-	venc_power_off(dssdev);
+	venc_power_off(venc);
 
-	mutex_unlock(&venc.venc_lock);
+	mutex_unlock(&venc->venc_lock);
 }
 
 static void venc_set_timings(struct omap_dss_device *dssdev,
 			     struct videomode *vm)
 {
+	struct venc_device *venc = dssdev_to_venc(dssdev);
 	struct videomode actual_vm;
 
 	DSSDBG("venc_set_timings\n");
 
-	mutex_lock(&venc.venc_lock);
+	mutex_lock(&venc->venc_lock);
 
 	switch (venc_get_videomode(vm)) {
 	default:
@@ -581,14 +590,14 @@ static void venc_set_timings(struct omap
 	}
 
 	/* Reset WSS data when the TV standard changes. */
-	if (memcmp(&venc.vm, &actual_vm, sizeof(actual_vm)))
-		venc.wss_data = 0;
+	if (memcmp(&venc->vm, &actual_vm, sizeof(actual_vm)))
+		venc->wss_data = 0;
 
-	venc.vm = actual_vm;
+	venc->vm = actual_vm;
 
-	dispc_set_tv_pclk(venc.dss->dispc, 13500000);
+	dispc_set_tv_pclk(venc->dss->dispc, 13500000);
 
-	mutex_unlock(&venc.venc_lock);
+	mutex_unlock(&venc->venc_lock);
 }
 
 static int venc_check_timings(struct omap_dss_device *dssdev,
@@ -608,128 +617,136 @@ static int venc_check_timings(struct oma
 static void venc_get_timings(struct omap_dss_device *dssdev,
 			     struct videomode *vm)
 {
-	mutex_lock(&venc.venc_lock);
+	struct venc_device *venc = dssdev_to_venc(dssdev);
+
+	mutex_lock(&venc->venc_lock);
 
-	*vm = venc.vm;
+	*vm = venc->vm;
 
-	mutex_unlock(&venc.venc_lock);
+	mutex_unlock(&venc->venc_lock);
 }
 
 static u32 venc_get_wss(struct omap_dss_device *dssdev)
 {
+	struct venc_device *venc = dssdev_to_venc(dssdev);
+
 	/* Invert due to VENC_L21_WC_CTL:INV=1 */
-	return (venc.wss_data >> 8) ^ 0xfffff;
+	return (venc->wss_data >> 8) ^ 0xfffff;
 }
 
 static int venc_set_wss(struct omap_dss_device *dssdev, u32 wss)
 {
+	struct venc_device *venc = dssdev_to_venc(dssdev);
 	const struct venc_config *config;
 	int r;
 
 	DSSDBG("venc_set_wss\n");
 
-	mutex_lock(&venc.venc_lock);
+	mutex_lock(&venc->venc_lock);
 
-	config = venc_timings_to_config(&venc.vm);
+	config = venc_timings_to_config(&venc->vm);
 
 	/* Invert due to VENC_L21_WC_CTL:INV=1 */
-	venc.wss_data = (wss ^ 0xfffff) << 8;
+	venc->wss_data = (wss ^ 0xfffff) << 8;
 
-	r = venc_runtime_get();
+	r = venc_runtime_get(venc);
 	if (r)
 		goto err;
 
-	venc_write_reg(VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |
-			venc.wss_data);
+	venc_write_reg(venc, VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data |
+		       venc->wss_data);
 
-	venc_runtime_put();
+	venc_runtime_put(venc);
 
 err:
-	mutex_unlock(&venc.venc_lock);
+	mutex_unlock(&venc->venc_lock);
 
 	return r;
 }
 
-static int venc_init_regulator(void)
+static int venc_init_regulator(struct venc_device *venc)
 {
 	struct regulator *vdda_dac;
 
-	if (venc.vdda_dac_reg != NULL)
+	if (venc->vdda_dac_reg != NULL)
 		return 0;
 
-	vdda_dac = devm_regulator_get(&venc.pdev->dev, "vdda");
+	vdda_dac = devm_regulator_get(&venc->pdev->dev, "vdda");
 	if (IS_ERR(vdda_dac)) {
 		if (PTR_ERR(vdda_dac) != -EPROBE_DEFER)
 			DSSERR("can't get VDDA_DAC regulator\n");
 		return PTR_ERR(vdda_dac);
 	}
 
-	venc.vdda_dac_reg = vdda_dac;
+	venc->vdda_dac_reg = vdda_dac;
 
 	return 0;
 }
 
 static int venc_dump_regs(struct seq_file *s, void *p)
 {
-#define DUMPREG(r) seq_printf(s, "%-35s %08x\n", #r, venc_read_reg(r))
+	struct venc_device *venc = s->private;
+
+#define DUMPREG(venc, r) \
+	seq_printf(s, "%-35s %08x\n", #r, venc_read_reg(venc, r))
 
-	if (venc_runtime_get())
+	if (venc_runtime_get(venc))
 		return 0;
 
-	DUMPREG(VENC_F_CONTROL);
-	DUMPREG(VENC_VIDOUT_CTRL);
-	DUMPREG(VENC_SYNC_CTRL);
-	DUMPREG(VENC_LLEN);
-	DUMPREG(VENC_FLENS);
-	DUMPREG(VENC_HFLTR_CTRL);
-	DUMPREG(VENC_CC_CARR_WSS_CARR);
-	DUMPREG(VENC_C_PHASE);
-	DUMPREG(VENC_GAIN_U);
-	DUMPREG(VENC_GAIN_V);
-	DUMPREG(VENC_GAIN_Y);
-	DUMPREG(VENC_BLACK_LEVEL);
-	DUMPREG(VENC_BLANK_LEVEL);
-	DUMPREG(VENC_X_COLOR);
-	DUMPREG(VENC_M_CONTROL);
-	DUMPREG(VENC_BSTAMP_WSS_DATA);
-	DUMPREG(VENC_S_CARR);
-	DUMPREG(VENC_LINE21);
-	DUMPREG(VENC_LN_SEL);
-	DUMPREG(VENC_L21__WC_CTL);
-	DUMPREG(VENC_HTRIGGER_VTRIGGER);
-	DUMPREG(VENC_SAVID__EAVID);
-	DUMPREG(VENC_FLEN__FAL);
-	DUMPREG(VENC_LAL__PHASE_RESET);
-	DUMPREG(VENC_HS_INT_START_STOP_X);
-	DUMPREG(VENC_HS_EXT_START_STOP_X);
-	DUMPREG(VENC_VS_INT_START_X);
-	DUMPREG(VENC_VS_INT_STOP_X__VS_INT_START_Y);
-	DUMPREG(VENC_VS_INT_STOP_Y__VS_EXT_START_X);
-	DUMPREG(VENC_VS_EXT_STOP_X__VS_EXT_START_Y);
-	DUMPREG(VENC_VS_EXT_STOP_Y);
-	DUMPREG(VENC_AVID_START_STOP_X);
-	DUMPREG(VENC_AVID_START_STOP_Y);
-	DUMPREG(VENC_FID_INT_START_X__FID_INT_START_Y);
-	DUMPREG(VENC_FID_INT_OFFSET_Y__FID_EXT_START_X);
-	DUMPREG(VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y);
-	DUMPREG(VENC_TVDETGP_INT_START_STOP_X);
-	DUMPREG(VENC_TVDETGP_INT_START_STOP_Y);
-	DUMPREG(VENC_GEN_CTRL);
-	DUMPREG(VENC_OUTPUT_CONTROL);
-	DUMPREG(VENC_OUTPUT_TEST);
+	DUMPREG(venc, VENC_F_CONTROL);
+	DUMPREG(venc, VENC_VIDOUT_CTRL);
+	DUMPREG(venc, VENC_SYNC_CTRL);
+	DUMPREG(venc, VENC_LLEN);
+	DUMPREG(venc, VENC_FLENS);
+	DUMPREG(venc, VENC_HFLTR_CTRL);
+	DUMPREG(venc, VENC_CC_CARR_WSS_CARR);
+	DUMPREG(venc, VENC_C_PHASE);
+	DUMPREG(venc, VENC_GAIN_U);
+	DUMPREG(venc, VENC_GAIN_V);
+	DUMPREG(venc, VENC_GAIN_Y);
+	DUMPREG(venc, VENC_BLACK_LEVEL);
+	DUMPREG(venc, VENC_BLANK_LEVEL);
+	DUMPREG(venc, VENC_X_COLOR);
+	DUMPREG(venc, VENC_M_CONTROL);
+	DUMPREG(venc, VENC_BSTAMP_WSS_DATA);
+	DUMPREG(venc, VENC_S_CARR);
+	DUMPREG(venc, VENC_LINE21);
+	DUMPREG(venc, VENC_LN_SEL);
+	DUMPREG(venc, VENC_L21__WC_CTL);
+	DUMPREG(venc, VENC_HTRIGGER_VTRIGGER);
+	DUMPREG(venc, VENC_SAVID__EAVID);
+	DUMPREG(venc, VENC_FLEN__FAL);
+	DUMPREG(venc, VENC_LAL__PHASE_RESET);
+	DUMPREG(venc, VENC_HS_INT_START_STOP_X);
+	DUMPREG(venc, VENC_HS_EXT_START_STOP_X);
+	DUMPREG(venc, VENC_VS_INT_START_X);
+	DUMPREG(venc, VENC_VS_INT_STOP_X__VS_INT_START_Y);
+	DUMPREG(venc, VENC_VS_INT_STOP_Y__VS_EXT_START_X);
+	DUMPREG(venc, VENC_VS_EXT_STOP_X__VS_EXT_START_Y);
+	DUMPREG(venc, VENC_VS_EXT_STOP_Y);
+	DUMPREG(venc, VENC_AVID_START_STOP_X);
+	DUMPREG(venc, VENC_AVID_START_STOP_Y);
+	DUMPREG(venc, VENC_FID_INT_START_X__FID_INT_START_Y);
+	DUMPREG(venc, VENC_FID_INT_OFFSET_Y__FID_EXT_START_X);
+	DUMPREG(venc, VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y);
+	DUMPREG(venc, VENC_TVDETGP_INT_START_STOP_X);
+	DUMPREG(venc, VENC_TVDETGP_INT_START_STOP_Y);
+	DUMPREG(venc, VENC_GEN_CTRL);
+	DUMPREG(venc, VENC_OUTPUT_CONTROL);
+	DUMPREG(venc, VENC_OUTPUT_TEST);
 
-	venc_runtime_put();
+	venc_runtime_put(venc);
 
 #undef DUMPREG
 	return 0;
 }
 
-static int venc_get_clocks(struct platform_device *pdev)
+static int venc_get_clocks(struct venc_device *venc)
 {
 	struct clk *clk;
 
-	if (venc.requires_tv_dac_clk) {
-		clk = devm_clk_get(&pdev->dev, "tv_dac_clk");
+	if (venc->requires_tv_dac_clk) {
+		clk = devm_clk_get(&venc->pdev->dev, "tv_dac_clk");
 		if (IS_ERR(clk)) {
 			DSSERR("can't get tv_dac_clk\n");
 			return PTR_ERR(clk);
@@ -738,7 +755,7 @@ static int venc_get_clocks(struct platfo
 		clk = NULL;
 	}
 
-	venc.tv_dac_clk = clk;
+	venc->tv_dac_clk = clk;
 
 	return 0;
 }
@@ -746,13 +763,14 @@ static int venc_get_clocks(struct platfo
 static int venc_connect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
+	struct venc_device *venc = dssdev_to_venc(dssdev);
 	int r;
 
-	r = venc_init_regulator();
+	r = venc_init_regulator(venc);
 	if (r)
 		return r;
 
-	r = dss_mgr_connect(&venc.output, dssdev);
+	r = dss_mgr_connect(&venc->output, dssdev);
 	if (r)
 		return r;
 
@@ -760,7 +778,7 @@ static int venc_connect(struct omap_dss_
 	if (r) {
 		DSSERR("failed to connect output to new device: %s\n",
 				dst->name);
-		dss_mgr_disconnect(&venc.output, dssdev);
+		dss_mgr_disconnect(&venc->output, dssdev);
 		return r;
 	}
 
@@ -770,6 +788,8 @@ static int venc_connect(struct omap_dss_
 static void venc_disconnect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
+	struct venc_device *venc = dssdev_to_venc(dssdev);
+
 	WARN_ON(dst != dssdev->dst);
 
 	if (dst != dssdev->dst)
@@ -777,7 +797,7 @@ static void venc_disconnect(struct omap_
 
 	omapdss_output_unset_device(dssdev);
 
-	dss_mgr_disconnect(&venc.output, dssdev);
+	dss_mgr_disconnect(&venc->output, dssdev);
 }
 
 static const struct omapdss_atv_ops venc_ops = {
@@ -795,11 +815,11 @@ static const struct omapdss_atv_ops venc
 	.get_wss = venc_get_wss,
 };
 
-static void venc_init_output(struct platform_device *pdev)
+static void venc_init_output(struct venc_device *venc)
 {
-	struct omap_dss_device *out = &venc.output;
+	struct omap_dss_device *out = &venc->output;
 
-	out->dev = &pdev->dev;
+	out->dev = &venc->pdev->dev;
 	out->id = OMAP_DSS_OUTPUT_VENC;
 	out->output_type = OMAP_DISPLAY_TYPE_VENC;
 	out->name = "venc.0";
@@ -810,16 +830,14 @@ static void venc_init_output(struct plat
 	omapdss_register_output(out);
 }
 
-static void venc_uninit_output(struct platform_device *pdev)
+static void venc_uninit_output(struct venc_device *venc)
 {
-	struct omap_dss_device *out = &venc.output;
-
-	omapdss_unregister_output(out);
+	omapdss_unregister_output(&venc->output);
 }
 
-static int venc_probe_of(struct platform_device *pdev)
+static int venc_probe_of(struct venc_device *venc)
 {
-	struct device_node *node = pdev->dev.of_node;
+	struct device_node *node = venc->pdev->dev.of_node;
 	struct device_node *ep;
 	u32 channels;
 	int r;
@@ -828,24 +846,25 @@ static int venc_probe_of(struct platform
 	if (!ep)
 		return 0;
 
-	venc.invert_polarity = of_property_read_bool(ep, "ti,invert-polarity");
+	venc->invert_polarity = of_property_read_bool(ep, "ti,invert-polarity");
 
 	r = of_property_read_u32(ep, "ti,channels", &channels);
 	if (r) {
-		dev_err(&pdev->dev,
+		dev_err(&venc->pdev->dev,
 			"failed to read property 'ti,channels': %d\n", r);
 		goto err;
 	}
 
 	switch (channels) {
 	case 1:
-		venc.type = OMAP_DSS_VENC_TYPE_COMPOSITE;
+		venc->type = OMAP_DSS_VENC_TYPE_COMPOSITE;
 		break;
 	case 2:
-		venc.type = OMAP_DSS_VENC_TYPE_SVIDEO;
+		venc->type = OMAP_DSS_VENC_TYPE_SVIDEO;
 		break;
 	default:
-		dev_err(&pdev->dev, "bad channel propert '%d'\n", channels);
+		dev_err(&venc->pdev->dev, "bad channel propert '%d'\n",
+			channels);
 		r = -EINVAL;
 		goto err;
 	}
@@ -870,69 +889,81 @@ static int venc_bind(struct device *dev,
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dss_device *dss = dss_get_device(master);
+	struct venc_device *venc;
 	u8 rev_id;
 	struct resource *venc_mem;
 	int r;
 
-	venc.pdev = pdev;
-	venc.dss = dss;
+	venc = kzalloc(sizeof(*venc), GFP_KERNEL);
+	if (!venc)
+		return -ENOMEM;
+
+	venc->pdev = pdev;
+	venc->dss = dss;
+	dev_set_drvdata(dev, venc);
 
 	/* The OMAP34xx, OMAP35xx and AM35xx VENC require the TV DAC clock. */
 	if (soc_device_match(venc_soc_devices))
-		venc.requires_tv_dac_clk = true;
+		venc->requires_tv_dac_clk = true;
 
-	mutex_init(&venc.venc_lock);
+	mutex_init(&venc->venc_lock);
 
-	venc.wss_data = 0;
+	venc->wss_data = 0;
 
-	venc_mem = platform_get_resource(venc.pdev, IORESOURCE_MEM, 0);
-	venc.base = devm_ioremap_resource(&pdev->dev, venc_mem);
-	if (IS_ERR(venc.base))
-		return PTR_ERR(venc.base);
+	venc_mem = platform_get_resource(venc->pdev, IORESOURCE_MEM, 0);
+	venc->base = devm_ioremap_resource(&pdev->dev, venc_mem);
+	if (IS_ERR(venc->base)) {
+		r = PTR_ERR(venc->base);
+		goto err_free;
+	}
 
-	r = venc_get_clocks(pdev);
+	r = venc_get_clocks(venc);
 	if (r)
-		return r;
+		goto err_free;
 
 	pm_runtime_enable(&pdev->dev);
 
-	r = venc_runtime_get();
+	r = venc_runtime_get(venc);
 	if (r)
 		goto err_runtime_get;
 
-	rev_id = (u8)(venc_read_reg(VENC_REV_ID) & 0xff);
+	rev_id = (u8)(venc_read_reg(venc, VENC_REV_ID) & 0xff);
 	dev_dbg(&pdev->dev, "OMAP VENC rev %d\n", rev_id);
 
-	venc_runtime_put();
+	venc_runtime_put(venc);
 
-	r = venc_probe_of(pdev);
+	r = venc_probe_of(venc);
 	if (r) {
 		DSSERR("Invalid DT data\n");
 		goto err_probe_of;
 	}
 
-	venc.debugfs = dss_debugfs_create_file(dss, "venc", venc_dump_regs,
-						&venc);
+	venc->debugfs = dss_debugfs_create_file(dss, "venc", venc_dump_regs,
+						venc);
 
-	venc_init_output(pdev);
+	venc_init_output(venc);
 
 	return 0;
 
 err_probe_of:
 err_runtime_get:
 	pm_runtime_disable(&pdev->dev);
+err_free:
+	kfree(venc);
 	return r;
 }
 
 static void venc_unbind(struct device *dev, struct device *master, void *data)
 {
-	struct platform_device *pdev = to_platform_device(dev);
+	struct venc_device *venc = dev_get_drvdata(dev);
 
-	dss_debugfs_remove_file(venc.debugfs);
+	dss_debugfs_remove_file(venc->debugfs);
 
-	venc_uninit_output(pdev);
+	venc_uninit_output(venc);
 
-	pm_runtime_disable(&pdev->dev);
+	pm_runtime_disable(dev);
+
+	kfree(venc);
 }
 
 static const struct component_ops venc_component_ops = {
@@ -953,24 +984,27 @@ static int venc_remove(struct platform_d
 
 static int venc_runtime_suspend(struct device *dev)
 {
-	if (venc.tv_dac_clk)
-		clk_disable_unprepare(venc.tv_dac_clk);
+	struct venc_device *venc = dev_get_drvdata(dev);
+
+	if (venc->tv_dac_clk)
+		clk_disable_unprepare(venc->tv_dac_clk);
 
-	dispc_runtime_put(venc.dss->dispc);
+	dispc_runtime_put(venc->dss->dispc);
 
 	return 0;
 }
 
 static int venc_runtime_resume(struct device *dev)
 {
+	struct venc_device *venc = dev_get_drvdata(dev);
 	int r;
 
-	r = dispc_runtime_get(venc.dss->dispc);
+	r = dispc_runtime_get(venc->dss->dispc);
 	if (r < 0)
 		return r;
 
-	if (venc.tv_dac_clk)
-		clk_prepare_enable(venc.tv_dac_clk);
+	if (venc->tv_dac_clk)
+		clk_prepare_enable(venc->tv_dac_clk);
 
 	return 0;
 }
