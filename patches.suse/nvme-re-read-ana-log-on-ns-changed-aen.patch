From: Daniel Wagner <dwagner@suse.de>
Date: Tue, 9 Feb 2021 18:01:54 +0100
Subject: [PATCH] nvme: re-read ANA log on NS CHANGED AEN
Patch-mainline: Not yet, waiting for upstream
References: bsc#1179137

As discussed on the mailing list we might be getting an NS CHANGED AEN
for a namespace on a newly created ANA group, and due to optimisations
within the spec no corresponding ANA CHANGED AEN will be send.
Ideally we would re-read the ANA log when we're figuring out that
no ANA Group exists, but that code is hidden behind two stacked void
functions, so it'll be impossible to recover from an error on reading
the ANA log.
Instead this patch re-reads the ANA log on every NS CHANGED AEN prior
to scanning the namespaces; that will resolve the situation, too,
but doesn't risk into running into an unrecoverable error.

Signed-off-by: Hannes Reinecke <hare@suse.de>
[dwagner: export nvme_queue_scan()]
Acked-by: Daniel Wagner <dwagner@suse.de>
---
 drivers/nvme/host/core.c      |  9 ++++++++-
 drivers/nvme/host/multipath.c | 18 ++++++++++++++----
 drivers/nvme/host/nvme.h      |  1 +
 3 files changed, 23 insertions(+), 5 deletions(-)

diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index c7a01ca1213a..c77ae9029acb 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -111,7 +111,7 @@ static void nvme_set_queue_dying(struct nvme_ns *ns)
 	revalidate_disk(ns->disk);
 }
 
-static void nvme_queue_scan(struct nvme_ctrl *ctrl)
+void nvme_queue_scan(struct nvme_ctrl *ctrl)
 {
 	/*
 	 * Only new queue scan work when admin and IO queues are both alive
@@ -119,6 +119,7 @@ static void nvme_queue_scan(struct nvme_ctrl *ctrl)
 	if (ctrl->state == NVME_CTRL_LIVE && ctrl->tagset)
 		queue_work(nvme_wq, &ctrl->scan_work);
 }
+EXPORT_SYMBOL_GPL(nvme_queue_scan);
 
 /*
  * Use this function to proceed with scheduling reset_work for a controller
@@ -3866,6 +3867,12 @@ static void nvme_handle_aen_notice(struct nvme_ctrl *ctrl, u32 result)
 	switch (aer_notice_type) {
 	case NVME_AER_NOTICE_NS_CHANGED:
 		set_bit(NVME_AER_NOTICE_NS_CHANGED, &ctrl->events);
+#ifdef CONFIG_NVME_MULTIPATH
+		if (ctrl->ana_log_buf) {
+			queue_work(nvme_wq, &ctrl->ana_work);
+			break;
+		}
+#endif
 		nvme_queue_scan(ctrl);
 		break;
 	case NVME_AER_NOTICE_FW_ACT_STARTING:
diff --git a/drivers/nvme/host/multipath.c b/drivers/nvme/host/multipath.c
index de105ef695cd..1da61a95f2d3 100644
--- a/drivers/nvme/host/multipath.c
+++ b/drivers/nvme/host/multipath.c
@@ -555,10 +555,16 @@ static int nvme_read_ana_log(struct nvme_ctrl *ctrl)
 		goto out_unlock;
 	}
 
-	error = nvme_parse_ana_log(ctrl, &nr_change_groups,
-			nvme_update_ana_state);
-	if (error)
-		goto out_unlock;
+	/*
+	 * Don't update ANA groups if triggered by an NS CHANGED
+	 * AEN; we'll be rescanning all namespaces anyway afterwards.
+	 */
+	if (!test_bit(NVME_AER_NOTICE_NS_CHANGED, &ctrl->events)) {
+		error = nvme_parse_ana_log(ctrl, &nr_change_groups,
+					   nvme_update_ana_state);
+		if (error)
+			goto out_unlock;
+	}
 
 	/*
 	 * In theory we should have an ANATT timer per group as they might enter
@@ -577,6 +583,10 @@ static int nvme_read_ana_log(struct nvme_ctrl *ctrl)
 		del_timer_sync(&ctrl->anatt_timer);
 out_unlock:
 	mutex_unlock(&ctrl->ana_lock);
+
+	if (test_bit(NVME_AER_NOTICE_NS_CHANGED, &ctrl->events))
+		nvme_queue_scan(ctrl);
+
 	return error;
 }
 
diff --git a/drivers/nvme/host/nvme.h b/drivers/nvme/host/nvme.h
index 157caeea8b6d..b4fe52655e8d 100644
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@ -550,6 +550,7 @@ int nvme_reset_ctrl(struct nvme_ctrl *ctrl);
 int nvme_reset_ctrl_sync(struct nvme_ctrl *ctrl);
 int nvme_try_sched_reset(struct nvme_ctrl *ctrl);
 int nvme_delete_ctrl(struct nvme_ctrl *ctrl);
+void nvme_queue_scan(struct nvme_ctrl *ctrl);
 
 int nvme_get_log(struct nvme_ctrl *ctrl, u32 nsid, u8 log_page, u8 lsp,
 		void *log, size_t size, u64 offset);
-- 
2.29.2

