From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Sun, 11 Feb 2018 15:07:41 +0200
Subject: drm: omapdrm: displays: Get encoder source at connect time
Git-commit: e28cea0feeda57ce49a8ca84db883814544460d2
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

The encoder drivers need a handle to the source they are connected to in
order to control the source.

All drivers get that handle at probe time, resulting in probe deferral
when the source hasn't been probed yet. However they don't need the
handle until their connect handler is called.

Move retrieval of the source handle to the connect handler to avoid
probe deferrals.

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/omapdrm/displays/encoder-opa362.c    |   35 ++++------
 drivers/gpu/drm/omapdrm/displays/encoder-tfp410.c    |   36 ++++------
 drivers/gpu/drm/omapdrm/displays/encoder-tpd12s015.c |   66 ++++++-------------
 3 files changed, 54 insertions(+), 83 deletions(-)

--- a/drivers/gpu/drm/omapdrm/displays/encoder-opa362.c
+++ b/drivers/gpu/drm/omapdrm/displays/encoder-opa362.c
@@ -36,7 +36,7 @@ static int opa362_connect(struct omap_ds
 		struct omap_dss_device *dst)
 {
 	struct panel_drv_data *ddata = to_panel_data(dssdev);
-	struct omap_dss_device *in = ddata->in;
+	struct omap_dss_device *in;
 	int r;
 
 	dev_dbg(dssdev->dev, "connect\n");
@@ -44,13 +44,22 @@ static int opa362_connect(struct omap_ds
 	if (omapdss_device_is_connected(dssdev))
 		return -EBUSY;
 
+	in = omapdss_of_find_source_for_first_ep(dssdev->dev->of_node);
+	if (IS_ERR(in)) {
+		dev_err(dssdev->dev, "failed to find video source\n");
+		return PTR_ERR(in);
+	}
+
 	r = in->ops.atv->connect(in, dssdev);
-	if (r)
+	if (r) {
+		omap_dss_put_device(in);
 		return r;
+	}
 
 	dst->src = dssdev;
 	dssdev->dst = dst;
 
+	ddata->in = in;
 	return 0;
 }
 
@@ -74,6 +83,9 @@ static void opa362_disconnect(struct oma
 	dssdev->dst = NULL;
 
 	in->ops.atv->disconnect(in, &ddata->dssdev);
+
+	omap_dss_put_device(in);
+	ddata->in = NULL;
 }
 
 static int opa362_enable(struct omap_dss_device *dssdev)
@@ -171,9 +183,8 @@ static const struct omapdss_atv_ops opa3
 
 static int opa362_probe(struct platform_device *pdev)
 {
-	struct device_node *node = pdev->dev.of_node;
 	struct panel_drv_data *ddata;
-	struct omap_dss_device *dssdev, *in;
+	struct omap_dss_device *dssdev;
 	struct gpio_desc *gpio;
 	int r;
 
@@ -191,14 +202,6 @@ static int opa362_probe(struct platform_
 
 	ddata->enable_gpio = gpio;
 
-	in = omapdss_of_find_source_for_first_ep(node);
-	if (IS_ERR(in)) {
-		dev_err(&pdev->dev, "failed to find video source\n");
-		return PTR_ERR(in);
-	}
-
-	ddata->in = in;
-
 	dssdev = &ddata->dssdev;
 	dssdev->ops.atv = &opa362_atv_ops;
 	dssdev->dev = &pdev->dev;
@@ -209,20 +212,16 @@ static int opa362_probe(struct platform_
 	r = omapdss_register_output(dssdev);
 	if (r) {
 		dev_err(&pdev->dev, "Failed to register output\n");
-		goto err_reg;
+		return r;
 	}
 
 	return 0;
-err_reg:
-	omap_dss_put_device(ddata->in);
-	return r;
 }
 
 static int __exit opa362_remove(struct platform_device *pdev)
 {
 	struct panel_drv_data *ddata = platform_get_drvdata(pdev);
 	struct omap_dss_device *dssdev = &ddata->dssdev;
-	struct omap_dss_device *in = ddata->in;
 
 	omapdss_unregister_output(&ddata->dssdev);
 
@@ -234,8 +233,6 @@ static int __exit opa362_remove(struct p
 	if (omapdss_device_is_connected(dssdev))
 		opa362_disconnect(dssdev, dssdev->dst);
 
-	omap_dss_put_device(in);
-
 	return 0;
 }
 
--- a/drivers/gpu/drm/omapdrm/displays/encoder-tfp410.c
+++ b/drivers/gpu/drm/omapdrm/displays/encoder-tfp410.c
@@ -32,19 +32,28 @@ static int tfp410_connect(struct omap_ds
 		struct omap_dss_device *dst)
 {
 	struct panel_drv_data *ddata = to_panel_data(dssdev);
-	struct omap_dss_device *in = ddata->in;
+	struct omap_dss_device *in;
 	int r;
 
 	if (omapdss_device_is_connected(dssdev))
 		return -EBUSY;
 
+	in = omapdss_of_find_source_for_first_ep(dssdev->dev->of_node);
+	if (IS_ERR(in)) {
+		dev_err(dssdev->dev, "failed to find video source\n");
+		return PTR_ERR(in);
+	}
+
 	r = in->ops.dpi->connect(in, dssdev);
-	if (r)
+	if (r) {
+		omap_dss_put_device(in);
 		return r;
+	}
 
 	dst->src = dssdev;
 	dssdev->dst = dst;
 
+	ddata->in = in;
 	return 0;
 }
 
@@ -66,6 +75,9 @@ static void tfp410_disconnect(struct oma
 	dssdev->dst = NULL;
 
 	in->ops.dpi->disconnect(in, &ddata->dssdev);
+
+	omap_dss_put_device(in);
+	ddata->in = NULL;
 }
 
 static int tfp410_enable(struct omap_dss_device *dssdev)
@@ -165,7 +177,6 @@ static int tfp410_probe_of(struct platfo
 {
 	struct panel_drv_data *ddata = platform_get_drvdata(pdev);
 	struct device_node *node = pdev->dev.of_node;
-	struct omap_dss_device *in;
 	int gpio;
 
 	gpio = of_get_named_gpio(node, "powerdown-gpios", 0);
@@ -178,14 +189,6 @@ static int tfp410_probe_of(struct platfo
 		return gpio;
 	}
 
-	in = omapdss_of_find_source_for_first_ep(node);
-	if (IS_ERR(in)) {
-		dev_err(&pdev->dev, "failed to find video source\n");
-		return PTR_ERR(in);
-	}
-
-	ddata->in = in;
-
 	return 0;
 }
 
@@ -211,7 +214,7 @@ static int tfp410_probe(struct platform_
 		if (r) {
 			dev_err(&pdev->dev, "Failed to request PD GPIO %d\n",
 					ddata->pd_gpio);
-			goto err_gpio;
+			return r;
 		}
 	}
 
@@ -226,21 +229,16 @@ static int tfp410_probe(struct platform_
 	r = omapdss_register_output(dssdev);
 	if (r) {
 		dev_err(&pdev->dev, "Failed to register output\n");
-		goto err_reg;
+		return r;
 	}
 
 	return 0;
-err_reg:
-err_gpio:
-	omap_dss_put_device(ddata->in);
-	return r;
 }
 
 static int __exit tfp410_remove(struct platform_device *pdev)
 {
 	struct panel_drv_data *ddata = platform_get_drvdata(pdev);
 	struct omap_dss_device *dssdev = &ddata->dssdev;
-	struct omap_dss_device *in = ddata->in;
 
 	omapdss_unregister_output(&ddata->dssdev);
 
@@ -252,8 +250,6 @@ static int __exit tfp410_remove(struct p
 	if (omapdss_device_is_connected(dssdev))
 		tfp410_disconnect(dssdev, dssdev->dst);
 
-	omap_dss_put_device(in);
-
 	return 0;
 }
 
--- a/drivers/gpu/drm/omapdrm/displays/encoder-tpd12s015.c
+++ b/drivers/gpu/drm/omapdrm/displays/encoder-tpd12s015.c
@@ -40,12 +40,20 @@ static int tpd_connect(struct omap_dss_d
 		struct omap_dss_device *dst)
 {
 	struct panel_drv_data *ddata = to_panel_data(dssdev);
-	struct omap_dss_device *in = ddata->in;
+	struct omap_dss_device *in;
 	int r;
 
+	in = omapdss_of_find_source_for_first_ep(dssdev->dev->of_node);
+	if (IS_ERR(in)) {
+		dev_err(dssdev->dev, "failed to find video source\n");
+		return PTR_ERR(in);
+	}
+
 	r = in->ops.hdmi->connect(in, dssdev);
-	if (r)
+	if (r) {
+		omap_dss_put_device(in);
 		return r;
+	}
 
 	dst->src = dssdev;
 	dssdev->dst = dst;
@@ -56,6 +64,7 @@ static int tpd_connect(struct omap_dss_d
 	/* DC-DC converter needs at max 300us to get to 90% of 5V */
 	udelay(300);
 
+	ddata->in = in;
 	return 0;
 }
 
@@ -77,6 +86,9 @@ static void tpd_disconnect(struct omap_d
 	dssdev->dst = NULL;
 
 	in->ops.hdmi->disconnect(in, &ddata->dssdev);
+
+	omap_dss_put_device(in);
+	ddata->in = NULL;
 }
 
 static int tpd_enable(struct omap_dss_device *dssdev)
@@ -269,23 +281,6 @@ static irqreturn_t tpd_hpd_isr(int irq,
 	return IRQ_HANDLED;
 }
 
-static int tpd_probe_of(struct platform_device *pdev)
-{
-	struct panel_drv_data *ddata = platform_get_drvdata(pdev);
-	struct device_node *node = pdev->dev.of_node;
-	struct omap_dss_device *in;
-
-	in = omapdss_of_find_source_for_first_ep(node);
-	if (IS_ERR(in)) {
-		dev_err(&pdev->dev, "failed to find video source\n");
-		return PTR_ERR(in);
-	}
-
-	ddata->in = in;
-
-	return 0;
-}
-
 static int tpd_probe(struct platform_device *pdev)
 {
 	struct omap_dss_device *in, *dssdev;
@@ -299,34 +294,24 @@ static int tpd_probe(struct platform_dev
 
 	platform_set_drvdata(pdev, ddata);
 
-	r = tpd_probe_of(pdev);
-	if (r)
-		return r;
-
 	gpio = devm_gpiod_get_index_optional(&pdev->dev, NULL, 0,
 		 GPIOD_OUT_LOW);
-	if (IS_ERR(gpio)) {
-		r = PTR_ERR(gpio);
-		goto err_gpio;
-	}
+	if (IS_ERR(gpio))
+		return PTR_ERR(gpio);
 
 	ddata->ct_cp_hpd_gpio = gpio;
 
 	gpio = devm_gpiod_get_index_optional(&pdev->dev, NULL, 1,
 		 GPIOD_OUT_LOW);
-	if (IS_ERR(gpio)) {
-		r = PTR_ERR(gpio);
-		goto err_gpio;
-	}
+	if (IS_ERR(gpio))
+		return PTR_ERR(gpio);
 
 	ddata->ls_oe_gpio = gpio;
 
 	gpio = devm_gpiod_get_index(&pdev->dev, NULL, 2,
 		GPIOD_IN);
-	if (IS_ERR(gpio)) {
-		r = PTR_ERR(gpio);
-		goto err_gpio;
-	}
+	if (IS_ERR(gpio))
+		return PTR_ERR(gpio);
 
 	ddata->hpd_gpio = gpio;
 
@@ -337,7 +322,7 @@ static int tpd_probe(struct platform_dev
 		IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
 		"tpd12s015 hpd", ddata);
 	if (r)
-		goto err_gpio;
+		return r;
 
 	dssdev = &ddata->dssdev;
 	dssdev->ops.hdmi = &tpd_hdmi_ops;
@@ -352,21 +337,16 @@ static int tpd_probe(struct platform_dev
 	r = omapdss_register_output(dssdev);
 	if (r) {
 		dev_err(&pdev->dev, "Failed to register output\n");
-		goto err_reg;
+		return r;
 	}
 
 	return 0;
-err_reg:
-err_gpio:
-	omap_dss_put_device(ddata->in);
-	return r;
 }
 
 static int __exit tpd_remove(struct platform_device *pdev)
 {
 	struct panel_drv_data *ddata = platform_get_drvdata(pdev);
 	struct omap_dss_device *dssdev = &ddata->dssdev;
-	struct omap_dss_device *in = ddata->in;
 
 	omapdss_unregister_output(&ddata->dssdev);
 
@@ -378,8 +358,6 @@ static int __exit tpd_remove(struct plat
 	if (omapdss_device_is_connected(dssdev))
 		tpd_disconnect(dssdev, dssdev->dst);
 
-	omap_dss_put_device(in);
-
 	return 0;
 }
 
