From: Peter Chen <peter.chen@nxp.com>
Date: Thu, 23 Jan 2020 10:49:19 +0800
Subject: usb: chipidea: udc: using structure ci_hdrc device for runtime PM
Git-commit: 7fd87c956c0ab5633f20597cb828713f9c03aa5b
Patch-mainline: v5.7-rc1
References: jsc#SLE-16106

At current code, it doesn't maintain ci->gadget.dev's runtime PM
status well, eg, during the PM operation, the PM counter for
ci->gadget.dev doesn't be changed accordingly.

In this commit, we use ci_hdrc device instead of ci->gadget.dev
for runtime PM APIs at udc driver, in the way, we handle runtime
PM APIs using unify device structure between core and udc driver.

Reviewed-by: Jun Li <jun.li@nxp.com>
Signed-off-by: Peter Chen <peter.chen@nxp.com>
Acked-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
---
 drivers/usb/chipidea/udc.c |   13 +++++--------
 1 file changed, 5 insertions(+), 8 deletions(-)

--- a/drivers/usb/chipidea/udc.c
+++ b/drivers/usb/chipidea/udc.c
@@ -1532,7 +1532,7 @@ static void ci_hdrc_gadget_connect(struc
 	struct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);
 
 	if (is_active) {
-		pm_runtime_get_sync(&_gadget->dev);
+		pm_runtime_get_sync(ci->dev);
 		hw_device_reset(ci);
 		spin_lock_irq(&ci->lock);
 		if (ci->driver) {
@@ -1552,7 +1552,7 @@ static void ci_hdrc_gadget_connect(struc
 			ci->platdata->notify_event(ci,
 			CI_HDRC_CONTROLLER_STOPPED_EVENT);
 		_gadget_stop_activity(&ci->gadget);
-		pm_runtime_put_sync(&_gadget->dev);
+		pm_runtime_put_sync(ci->dev);
 		usb_gadget_set_state(_gadget, USB_STATE_NOTATTACHED);
 	}
 }
@@ -1637,12 +1637,12 @@ static int ci_udc_pullup(struct usb_gadg
 	if (ci_otg_is_fsm_mode(ci) || ci->role == CI_ROLE_HOST)
 		return 0;
 
-	pm_runtime_get_sync(&ci->gadget.dev);
+	pm_runtime_get_sync(ci->dev);
 	if (is_on)
 		hw_write(ci, OP_USBCMD, USBCMD_RS, USBCMD_RS);
 	else
 		hw_write(ci, OP_USBCMD, USBCMD_RS, 0);
-	pm_runtime_put_sync(&ci->gadget.dev);
+	pm_runtime_put_sync(ci->dev);
 
 	return 0;
 }
@@ -1840,7 +1840,7 @@ static int ci_udc_stop(struct usb_gadget
 			CI_HDRC_CONTROLLER_STOPPED_EVENT);
 		_gadget_stop_activity(&ci->gadget);
 		spin_lock_irqsave(&ci->lock, flags);
-		pm_runtime_put(&ci->gadget.dev);
+		pm_runtime_put(ci->dev);
 	}
 
 	spin_unlock_irqrestore(&ci->lock, flags);
@@ -1971,9 +1971,6 @@ static int udc_start(struct ci_hdrc *ci)
 	if (retval)
 		goto destroy_eps;
 
-	pm_runtime_no_callbacks(&ci->gadget.dev);
-	pm_runtime_enable(&ci->gadget.dev);
-
 	return retval;
 
 destroy_eps:
