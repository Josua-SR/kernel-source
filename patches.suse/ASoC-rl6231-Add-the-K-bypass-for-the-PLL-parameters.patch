From c25504ad64fe391acb23dcfab039831c3825c17e Mon Sep 17 00:00:00 2001
From: Oder Chiou <oder_chiou@realtek.com>
Date: Mon, 4 May 2020 15:40:07 +0800
Subject: [PATCH] ASoC: rl6231: Add the K bypass for the PLL parameters
Git-commit: c25504ad64fe391acb23dcfab039831c3825c17e
Patch-mainline: v5.8-rc1
References: jsc#SLE-16518

The patch adds the K bypass for the PLL parameters.

Signed-off-by: Oder Chiou <oder_chiou@realtek.com>
Link: https://lore.kernel.org/r/20200504074007.13002-2-oder_chiou@realtek.com
Signed-off-by: Mark Brown <broonie@kernel.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 sound/soc/codecs/rl6231.c | 29 +++++++++++++++++++----------
 sound/soc/codecs/rl6231.h |  1 +
 2 files changed, 20 insertions(+), 10 deletions(-)

diff --git a/sound/soc/codecs/rl6231.c b/sound/soc/codecs/rl6231.c
index d181c217d835..2586d1cafc0c 100644
--- a/sound/soc/codecs/rl6231.c
+++ b/sound/soc/codecs/rl6231.c
@@ -97,12 +97,13 @@ struct pll_calc_map {
 	int n;
 	int m;
 	bool m_bp;
+	bool k_bp;
 };
 
 static const struct pll_calc_map pll_preset_table[] = {
-	{19200000,  4096000,  23, 14, 1, false},
-	{19200000,  24576000,  3, 30, 3, false},
-	{3840000,   24576000,  3, 30, 0, true},
+	{19200000,  4096000,  23, 14, 1, false, false},
+	{19200000,  24576000,  3, 30, 3, false, false},
+	{3840000,   24576000,  3, 30, 0, true, false},
 };
 
 static unsigned int find_best_div(unsigned int in,
@@ -128,7 +129,7 @@ static unsigned int find_best_div(unsigned int in,
  * rl6231_pll_calc - Calcualte PLL M/N/K code.
  * @freq_in: external clock provided to codec.
  * @freq_out: target clock which codec works on.
- * @pll_code: Pointer to structure with M, N, K and bypass flag.
+ * @pll_code: Pointer to structure with M, N, K, m_bypass and k_bypass flag.
  *
  * Calcualte M/N/K code to configure PLL for codec.
  *
@@ -143,7 +144,7 @@ int rl6231_pll_calc(const unsigned int freq_in,
 	unsigned int red, pll_out, in_t, out_t, div, div_t;
 	unsigned int red_t = abs(freq_out - freq_in);
 	unsigned int f_in, f_out, f_max;
-	bool bypass = false;
+	bool m_bypass = false, k_bypass = false;
 
 	if (RL6231_PLL_INP_MAX < freq_in || RL6231_PLL_INP_MIN > freq_in)
 		return -EINVAL;
@@ -154,7 +155,8 @@ int rl6231_pll_calc(const unsigned int freq_in,
 			k = pll_preset_table[i].k;
 			m = pll_preset_table[i].m;
 			n = pll_preset_table[i].n;
-			bypass = pll_preset_table[i].m_bp;
+			m_bypass = pll_preset_table[i].m_bp;
+			k_bypass = pll_preset_table[i].k_bp;
 			pr_debug("Use preset PLL parameter table\n");
 			goto code_find;
 		}
@@ -172,12 +174,14 @@ int rl6231_pll_calc(const unsigned int freq_in,
 	f_in = freq_in / div;
 	f_out = freq_out / div;
 	k = min_k;
+	if (min_k < -1)
+		min_k = -1;
 	for (k_t = min_k; k_t <= max_k; k_t++) {
 		for (n_t = 0; n_t <= max_n; n_t++) {
 			in_t = f_in * (n_t + 2);
 			pll_out = f_out * (k_t + 2);
 			if (in_t == pll_out) {
-				bypass = true;
+				m_bypass = true;
 				n = n_t;
 				k = k_t;
 				goto code_find;
@@ -185,7 +189,7 @@ int rl6231_pll_calc(const unsigned int freq_in,
 			out_t = in_t / (k_t + 2);
 			red = abs(f_out - out_t);
 			if (red < red_t) {
-				bypass = true;
+				m_bypass = true;
 				n = n_t;
 				m = 0;
 				k = k_t;
@@ -197,7 +201,7 @@ int rl6231_pll_calc(const unsigned int freq_in,
 				out_t = in_t / ((m_t + 2) * (k_t + 2));
 				red = abs(f_out - out_t);
 				if (red < red_t) {
-					bypass = false;
+					m_bypass = false;
 					n = n_t;
 					m = m_t;
 					k = k_t;
@@ -211,8 +215,13 @@ int rl6231_pll_calc(const unsigned int freq_in,
 	pr_debug("Only get approximation about PLL\n");
 
 code_find:
+	if (k == -1) {
+		k_bypass = true;
+		k = 0;
+	}
 
-	pll_code->m_bp = bypass;
+	pll_code->m_bp = m_bypass;
+	pll_code->k_bp = k_bypass;
 	pll_code->m_code = m;
 	pll_code->n_code = n;
 	pll_code->k_code = k;
diff --git a/sound/soc/codecs/rl6231.h b/sound/soc/codecs/rl6231.h
index 6d8ed0377296..928082750860 100644
--- a/sound/soc/codecs/rl6231.h
+++ b/sound/soc/codecs/rl6231.h
@@ -18,6 +18,7 @@
 
 struct rl6231_pll_code {
 	bool m_bp; /* Indicates bypass m code or not. */
+	bool k_bp; /* Indicates bypass k code or not. */
 	int m_code;
 	int n_code;
 	int k_code;
-- 
2.16.4

