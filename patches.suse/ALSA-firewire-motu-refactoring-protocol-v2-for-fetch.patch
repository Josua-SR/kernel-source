From 506ad56a59086751eee28b6b6e5dff5572cd669f Mon Sep 17 00:00:00 2001
From: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date: Tue, 19 May 2020 20:16:41 +0900
Subject: [PATCH] ALSA: firewire-motu: refactoring protocol v2 for fetching mode switch
Git-commit: 506ad56a59086751eee28b6b6e5dff5572cd669f
Patch-mainline: v5.8-rc1
References: jsc#SLE-16518

This commit splits the method to switch fetching mode for protocol
version 2 so that model-dependent operations are explicitly defined.

Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Link: https://lore.kernel.org/r/20200519111641.123211-15-o-takashi@sakamocchi.jp
Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 sound/firewire/motu/motu-protocol-v2.c | 77 +++++++++++++++++++++-------------
 1 file changed, 47 insertions(+), 30 deletions(-)

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 2e6c3cc8a9e1..e59e69ab1538 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -170,52 +170,69 @@ int snd_motu_protocol_v2_get_clock_source(struct snd_motu *motu,
 	return get_clock_source(motu, be32_to_cpu(reg), src);
 }
 
-int snd_motu_protocol_v2_switch_fetching_mode(struct snd_motu *motu,
-					      bool enable)
+// Expected for Traveler and 896HD, which implements Altera Cyclone EP1C3.
+static int switch_fetching_mode_cyclone(struct snd_motu *motu, u32 *data,
+					bool enable)
 {
-	enum snd_motu_clock_source src;
-	__be32 reg;
-	u32 data;
-	int err = 0;
+	*data |= V2_CLOCK_MODEL_SPECIFIC;
 
-	// 828mkII implements Altera ACEX 1K EP1K30. Nothing to do.
-	if (motu->spec == &snd_motu_spec_828mk2)
-		return 0;
+	return 0;
+}
 
-	err = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET, &reg,
-					sizeof(reg));
+// For UltraLite and 8pre, which implements Xilinx Spartan XC3S200.
+static int switch_fetching_mode_spartan(struct snd_motu *motu, u32 *data,
+					bool enable)
+{
+	unsigned int rate;
+	enum snd_motu_clock_source src;
+	int err;
+
+	err = get_clock_source(motu, *data, &src);
 	if (err < 0)
 		return err;
-	data = be32_to_cpu(reg);
 
-	err = get_clock_source(motu, data, &src);
+	err = get_clock_rate(*data, &rate);
 	if (err < 0)
 		return err;
 
-	data &= ~(V2_CLOCK_FETCH_ENABLE | V2_CLOCK_MODEL_SPECIFIC);
-	if (enable)
-		data |= V2_CLOCK_FETCH_ENABLE;
+	if (src == SND_MOTU_CLOCK_SOURCE_SPH && rate > 48000)
+		*data |= V2_CLOCK_MODEL_SPECIFIC;
 
-	if (motu->spec == &snd_motu_spec_traveler) {
-		// Expected for Traveler and 896HD, which implements Altera
-		// Cyclone EP1C3.
-		data |= V2_CLOCK_MODEL_SPECIFIC;
+	return 0;
+}
+
+int snd_motu_protocol_v2_switch_fetching_mode(struct snd_motu *motu,
+					      bool enable)
+{
+	if (motu->spec == &snd_motu_spec_828mk2) {
+		// 828mkII implements Altera ACEX 1K EP1K30. Nothing to do.
+		return 0;
 	} else {
-		// For UltraLite and 8pre, which implements Xilinx Spartan
-		// XC3S200.
-		unsigned int rate;
+		__be32 reg;
+		u32 data;
+		int err;
 
-		err = get_clock_rate(data, &rate);
+		err = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET,
+						&reg, sizeof(reg));
 		if (err < 0)
 			return err;
+		data = be32_to_cpu(reg);
 
-		if (src == SND_MOTU_CLOCK_SOURCE_SPH && rate > 48000)
-			data |= V2_CLOCK_MODEL_SPECIFIC;
-	}
+		data &= ~(V2_CLOCK_FETCH_ENABLE | V2_CLOCK_MODEL_SPECIFIC);
+		if (enable)
+			data |= V2_CLOCK_FETCH_ENABLE;
 
-	reg = cpu_to_be32(data);
-	return snd_motu_transaction_write(motu, V2_CLOCK_STATUS_OFFSET, &reg,
-					  sizeof(reg));
+		if (motu->spec == &snd_motu_spec_traveler)
+			err = switch_fetching_mode_cyclone(motu, &data, enable);
+		else
+			err = switch_fetching_mode_spartan(motu, &data, enable);
+		if (err < 0)
+			return err;
+
+		reg = cpu_to_be32(data);
+		return snd_motu_transaction_write(motu, V2_CLOCK_STATUS_OFFSET,
+						  &reg, sizeof(reg));
+	}
 }
 
 static int detect_packet_formats_828mk2(struct snd_motu *motu, u32 data)
-- 
2.16.4

