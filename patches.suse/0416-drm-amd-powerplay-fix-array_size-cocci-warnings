From: kbuild test robot <fengguang.wu@intel.com>
Date: Thu, 11 May 2017 09:30:28 +0800
Subject: drm/amd/powerplay: fix array_size.cocci warnings
Git-commit: c651fd7c116b7438730b9ea8c154a29ca77f88d1
Patch-mainline: v4.13-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

drivers/gpu/drm/amd/amdgpu/../powerplay/hwmgr/rv_hwmgr.c:75:42-43: WARNING: Use ARRAY_SIZE
drivers/gpu/drm/amd/amdgpu/../powerplay/hwmgr/rv_hwmgr.c:466:22-23: WARNING: Use ARRAY_SIZE
drivers/gpu/drm/amd/amdgpu/../powerplay/hwmgr/rv_hwmgr.c:468:22-23: WARNING: Use ARRAY_SIZE
drivers/gpu/drm/amd/amdgpu/../powerplay/hwmgr/rv_hwmgr.c:470:20-21: WARNING: Use ARRAY_SIZE
drivers/gpu/drm/amd/amdgpu/../powerplay/hwmgr/rv_hwmgr.c:473:22-23: WARNING: Use ARRAY_SIZE
drivers/gpu/drm/amd/amdgpu/../powerplay/hwmgr/rv_hwmgr.c:475:21-22: WARNING: Use ARRAY_SIZE
drivers/gpu/drm/amd/amdgpu/../powerplay/hwmgr/rv_hwmgr.c:477:21-22: WARNING: Use ARRAY_SIZE

 Use ARRAY_SIZE instead of dividing sizeof array with sizeof an element

Semantic patch information:
 This makes an effort to find cases where ARRAY_SIZE can be used such as
 where there is a division of sizeof the array by the sizeof its first
 element or by any indexed element or the element type. It replaces the
 division of the two sizeofs by ARRAY_SIZE.

Generated by: scripts/coccinelle/misc/array_size.cocci

CC: Rex Zhu <Rex.Zhu@amd.com>
Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/amd/powerplay/hwmgr/rv_hwmgr.c |   18 +++++++++++-------
 1 file changed, 11 insertions(+), 7 deletions(-)

--- a/drivers/gpu/drm/amd/powerplay/hwmgr/rv_hwmgr.c
+++ b/drivers/gpu/drm/amd/powerplay/hwmgr/rv_hwmgr.c
@@ -72,7 +72,7 @@ static int rv_init_vq_budget_table(struc
 {
 	uint32_t table_size, i;
 	struct phm_vq_budgeting_table *ptable;
-	uint32_t num_entries = (sizeof(rv_vqtable) / sizeof(*rv_vqtable));
+	uint32_t num_entries = ARRAY_SIZE(rv_vqtable);
 
 	if (hwmgr->dyn_state.vq_budgeting_table != NULL)
 		return 0;
@@ -463,18 +463,22 @@ static int rv_populate_clock_table(struc
 						&rv_data->clock_table.MemClocks[0]);
 	} else {
 		rv_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_dcefclk,
-						sizeof(VddDcfClk)/sizeof(*VddDcfClk), &VddDcfClk[0]);
+						ARRAY_SIZE(VddDcfClk),
+						&VddDcfClk[0]);
 		rv_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_socclk,
-						sizeof(VddSocClk)/sizeof(*VddSocClk), &VddSocClk[0]);
+						ARRAY_SIZE(VddSocClk),
+						&VddSocClk[0]);
 		rv_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_fclk,
-						sizeof(VddFClk)/sizeof(*VddFClk), &VddFClk[0]);
+						ARRAY_SIZE(VddFClk),
+						&VddFClk[0]);
 	}
 	rv_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_dispclk,
-					sizeof(VddDispClk)/sizeof(*VddDispClk), &VddDispClk[0]);
+					ARRAY_SIZE(VddDispClk),
+					&VddDispClk[0]);
 	rv_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_dppclk,
-					sizeof(VddDppClk)/sizeof(*VddDppClk), &VddDppClk[0]);
+					ARRAY_SIZE(VddDppClk), &VddDppClk[0]);
 	rv_get_clock_voltage_dependency_table(hwmgr, &pinfo->vdd_dep_on_phyclk,
-					sizeof(VddPhyClk)/sizeof(*VddPhyClk), &VddPhyClk[0]);
+					ARRAY_SIZE(VddPhyClk), &VddPhyClk[0]);
 
 	return 0;
 }
