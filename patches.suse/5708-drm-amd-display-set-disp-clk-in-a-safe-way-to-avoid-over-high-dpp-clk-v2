From: Yongqiang Sun <yongqiang.sun@amd.com>
Date: Wed, 28 Feb 2018 17:14:50 -0500
Subject: drm/amd/display: Set disp clk in a safe way to avoid over high dpp
 clk. (v2)
Git-commit: 45bb8dd696eaff9c96afd2b210f0d8cf5025dd65
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Increase clock, if current dpp div is 0 and request dpp div is 1, request clk is
higher than maximum dpp clk as per dpm table.
	set dispclk to the value of maximum supported dpp clk
	set div to 1
	set dispclk to request value.
Decrease clock, currrent dpp div is 1 and request dpp div is 0, current clk is
higher than maximum dpp clk as per dpm table.
	set dispclk to the value of maximum supported dpp clk
	set div to 0
	set dispclk to request value.

v2: squash in !DCN build fix

Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c          |   19 +
 drivers/gpu/drm/amd/display/dc/dc.h                       |    1 
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c |  142 +++++++++++---
 3 files changed, 139 insertions(+), 23 deletions(-)

--- a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
+++ b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
@@ -1000,6 +1000,25 @@ bool dcn_validate_bandwidth(
 
 		context->bw.dcn.calc_clk.max_dppclk_khz = context->bw.dcn.calc_clk.dispclk_khz / v->dispclk_dppclk_ratio;
 
+		switch (v->voltage_level) {
+		case 0:
+			context->bw.dcn.calc_clk.max_supported_dppclk_khz =
+					(int)(dc->dcn_soc->max_dppclk_vmin0p65 * 1000);
+			break;
+		case 1:
+			context->bw.dcn.calc_clk.max_supported_dppclk_khz =
+					(int)(dc->dcn_soc->max_dppclk_vmid0p72 * 1000);
+			break;
+		case 2:
+			context->bw.dcn.calc_clk.max_supported_dppclk_khz =
+					(int)(dc->dcn_soc->max_dppclk_vnom0p8 * 1000);
+			break;
+		default:
+			context->bw.dcn.calc_clk.max_supported_dppclk_khz =
+					(int)(dc->dcn_soc->max_dppclk_vmax0p9 * 1000);
+			break;
+		}
+
 		for (i = 0, input_idx = 0; i < pool->pipe_count; i++) {
 			struct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];
 
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
@@ -187,6 +187,7 @@ enum wm_report_mode {
 struct dc_clocks {
 	int dispclk_khz;
 	int max_dppclk_khz;
+	int max_supported_dppclk_khz;
 	int dcfclk_khz;
 	int socclk_khz;
 	int dcfclk_deep_sleep_khz;
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1709,16 +1709,22 @@ static void update_dchubp_dpp(
 	union plane_size size = plane_state->plane_size;
 
 	/* depends on DML calculation, DPP clock value may change dynamically */
+	/* If request max dpp clk is lower than current dispclk, no need to
+	 * divided by 2
+	 */
 	if (plane_state->update_flags.bits.full_update) {
+		bool should_divided_by_2 = context->bw.dcn.calc_clk.max_dppclk_khz <=
+				context->bw.dcn.cur_clk.dispclk_khz / 2;
+
 		dpp->funcs->dpp_dppclk_control(
 				dpp,
-				context->bw.dcn.calc_clk.max_dppclk_khz <
-						context->bw.dcn.calc_clk.dispclk_khz,
+				should_divided_by_2,
 				true);
 
 		dc->current_state->bw.dcn.cur_clk.max_dppclk_khz =
-				context->bw.dcn.calc_clk.max_dppclk_khz;
-		context->bw.dcn.cur_clk.max_dppclk_khz = context->bw.dcn.calc_clk.max_dppclk_khz;
+				should_divided_by_2 ?
+				context->bw.dcn.cur_clk.dispclk_khz / 2 :
+				context->bw.dcn.cur_clk.dispclk_khz;
 	}
 
 	/* TODO: Need input parameter to tell current DCHUB pipe tie to which OTG
@@ -2127,6 +2133,96 @@ static inline bool should_set_clock(bool
 	return ((decrease_allowed && calc_clk < cur_clk) || calc_clk > cur_clk);
 }
 
+static int determine_dppclk_threshold(struct dc *dc, struct dc_state *context)
+{
+	bool request_dpp_div = context->bw.dcn.calc_clk.dispclk_khz >
+			context->bw.dcn.calc_clk.max_dppclk_khz;
+	bool dispclk_increase = context->bw.dcn.calc_clk.dispclk_khz >
+			context->bw.dcn.cur_clk.dispclk_khz;
+	int disp_clk_threshold = context->bw.dcn.calc_clk.max_supported_dppclk_khz;
+	bool cur_dpp_div = context->bw.dcn.cur_clk.dispclk_khz >
+			context->bw.dcn.cur_clk.max_dppclk_khz;
+
+	/* increase clock, looking for div is 0 for current, request div is 1*/
+	if (dispclk_increase) {
+		/* already divided by 2, no need to reach target clk with 2 steps*/
+		if (cur_dpp_div)
+			return context->bw.dcn.calc_clk.dispclk_khz;
+
+		/* request disp clk is lower than maximum supported dpp clk,
+		 * no need to reach target clk with two steps.
+		 */
+		if (context->bw.dcn.calc_clk.dispclk_khz <= disp_clk_threshold)
+			return context->bw.dcn.calc_clk.dispclk_khz;
+
+		/* target dpp clk not request divided by 2, still within threshold */
+		if (!request_dpp_div)
+			return context->bw.dcn.calc_clk.dispclk_khz;
+
+	} else {
+		/* decrease clock, looking for current dppclk divided by 2,
+		 * request dppclk not divided by 2.
+		 */
+
+		/* current dpp clk not divided by 2, no need to ramp*/
+		if (!cur_dpp_div)
+			return context->bw.dcn.calc_clk.dispclk_khz;
+
+		/* current disp clk is lower than current maximum dpp clk,
+		 * no need to ramp
+		 */
+		if (context->bw.dcn.cur_clk.dispclk_khz <= disp_clk_threshold)
+			return context->bw.dcn.calc_clk.dispclk_khz;
+
+		/* request dpp clk need to be divided by 2 */
+		if (request_dpp_div)
+			return context->bw.dcn.calc_clk.dispclk_khz;
+	}
+
+	return disp_clk_threshold;
+}
+
+static void ramp_up_dispclk_with_dpp(struct dc *dc, struct dc_state *context)
+{
+	int i;
+	bool request_dpp_div = context->bw.dcn.calc_clk.dispclk_khz >
+				context->bw.dcn.calc_clk.max_dppclk_khz;
+
+	int dispclk_to_dpp_threshold = determine_dppclk_threshold(dc, context);
+
+	/* set disp clk to dpp clk threshold */
+	dc->res_pool->display_clock->funcs->set_clock(
+			dc->res_pool->display_clock,
+			dispclk_to_dpp_threshold);
+
+	/* update request dpp clk division option */
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
+
+		if (!pipe_ctx->plane_state)
+			continue;
+
+		pipe_ctx->plane_res.dpp->funcs->dpp_dppclk_control(
+				pipe_ctx->plane_res.dpp,
+				request_dpp_div,
+				true);
+	}
+
+	/* If target clk not same as dppclk threshold, set to target clock */
+	if (dispclk_to_dpp_threshold != context->bw.dcn.calc_clk.dispclk_khz) {
+		dc->res_pool->display_clock->funcs->set_clock(
+				dc->res_pool->display_clock,
+				context->bw.dcn.calc_clk.dispclk_khz);
+	}
+
+	context->bw.dcn.cur_clk.dispclk_khz =
+			context->bw.dcn.calc_clk.dispclk_khz;
+	context->bw.dcn.cur_clk.max_dppclk_khz =
+			context->bw.dcn.calc_clk.max_dppclk_khz;
+	context->bw.dcn.cur_clk.max_supported_dppclk_khz =
+			context->bw.dcn.calc_clk.max_supported_dppclk_khz;
+}
+
 static void dcn10_set_bandwidth(
 		struct dc *dc,
 		struct dc_state *context,
@@ -2146,17 +2242,6 @@ static void dcn10_set_bandwidth(
 
 	if (should_set_clock(
 			decrease_allowed,
-			context->bw.dcn.calc_clk.dispclk_khz,
-			dc->current_state->bw.dcn.cur_clk.dispclk_khz)) {
-		dc->res_pool->display_clock->funcs->set_clock(
-				dc->res_pool->display_clock,
-				context->bw.dcn.calc_clk.dispclk_khz);
-		context->bw.dcn.cur_clk.dispclk_khz =
-				context->bw.dcn.calc_clk.dispclk_khz;
-	}
-
-	if (should_set_clock(
-			decrease_allowed,
 			context->bw.dcn.calc_clk.dcfclk_khz,
 			dc->current_state->bw.dcn.cur_clk.dcfclk_khz)) {
 		context->bw.dcn.cur_clk.dcfclk_khz =
@@ -2167,6 +2252,14 @@ static void dcn10_set_bandwidth(
 
 	if (should_set_clock(
 			decrease_allowed,
+			context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz,
+			dc->current_state->bw.dcn.cur_clk.dcfclk_deep_sleep_khz)) {
+		context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz =
+				context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
+	}
+
+	if (should_set_clock(
+			decrease_allowed,
 			context->bw.dcn.calc_clk.fclk_khz,
 			dc->current_state->bw.dcn.cur_clk.fclk_khz)) {
 		context->bw.dcn.cur_clk.fclk_khz =
@@ -2174,14 +2267,6 @@ static void dcn10_set_bandwidth(
 		smu_req.hard_min_fclk_khz = context->bw.dcn.calc_clk.fclk_khz;
 	}
 
-	if (should_set_clock(
-			decrease_allowed,
-			context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz,
-			dc->current_state->bw.dcn.cur_clk.dcfclk_deep_sleep_khz)) {
-		context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz =
-				context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
-	}
-
 	smu_req.display_count = context->stream_count;
 
 	if (pp_smu->set_display_requirement)
@@ -2189,6 +2274,17 @@ static void dcn10_set_bandwidth(
 
 	*smu_req_cur = smu_req;
 
+	/* make sure dcf clk is before dpp clk to
+	 * make sure we have enough voltage to run dpp clk
+	 */
+	if (should_set_clock(
+			decrease_allowed,
+			context->bw.dcn.calc_clk.dispclk_khz,
+			dc->current_state->bw.dcn.cur_clk.dispclk_khz)) {
+
+		ramp_up_dispclk_with_dpp(dc, context);
+	}
+
 	/* Decrease in freq is increase in period so opposite comparison for dram_ccm */
 	if ((decrease_allowed && context->bw.dcn.calc_clk.dram_ccm_us
 			> dc->current_state->bw.dcn.cur_clk.dram_ccm_us) ||
