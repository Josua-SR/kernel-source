From: Parav Pandit <parav@mellanox.com>
Date: Sun, 20 Oct 2019 09:54:27 +0300
Subject: IB/core: Do not notify GID change event of an unregistered device
Patch-mainline: v5.5-rc1
Git-commit: c4c8aff5a9ddb061a6246fb34eabdb9244b4d8f6
References: jsc#SLE-8449

When IB device is undergoing unregistration, the GID cache is always
cleaned up after all clients are unregistered with the below flow.

__ib_unregister_device()
  disable_device()
  ib_cache_cleanup_one()
    gid_table_cleanup_one()
      cleanup_gid_table_port()

There is no use in generating a GID change event at this stage, where
there is no active client of the device and device is nearly unregistered.

Link: https://lore.kernel.org/r/20191020065427.8772-4-leon@kernel.org
Signed-off-by: Parav Pandit <parav@mellanox.com>
Reviewed-by: Daniel Jurgens <danielj@mellanox.com>
Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
Reviewed-by: Jason Gunthorpe <jgg@mellanox.com>
Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/infiniband/core/cache.c |    8 +-------
 1 file changed, 1 insertion(+), 7 deletions(-)

--- a/drivers/infiniband/core/cache.c
+++ b/drivers/infiniband/core/cache.c
@@ -819,22 +819,16 @@ static void cleanup_gid_table_port(struc
 				   struct ib_gid_table *table)
 {
 	int i;
-	bool deleted = false;
 
 	if (!table)
 		return;
 
 	mutex_lock(&table->lock);
 	for (i = 0; i < table->sz; ++i) {
-		if (is_gid_entry_valid(table->data_vec[i])) {
+		if (is_gid_entry_valid(table->data_vec[i]))
 			del_gid(ib_dev, port, table, i);
-			deleted = true;
-		}
 	}
 	mutex_unlock(&table->lock);
-
-	if (deleted)
-		dispatch_gid_change_event(ib_dev, port);
 }
 
 void ib_cache_gid_set_default_gid(struct ib_device *ib_dev, u8 port,
