From d8c6cd452c6c5fde6ed6996889b93c5df96ffc69 Mon Sep 17 00:00:00 2001
From: Oscar Salvador <osalvador@suse.de>
Date: Tue, 22 Sep 2020 12:58:00 +0200
Subject: [PATCH 05/14] mm,hwpoison: refactor madvise_inject_error
References: bsc#1177686
Patch-mainline: Submitted, https://lkml.org/lkml/2020/9/22/564

Make a proper if-else condition for {hard,soft}-offline.

[akpm: refactor comment]
Signed-off-by: Oscar Salvador <osalvador@suse.de>
---
 mm/madvise.c | 30 ++++++++++++++----------------
 1 file changed, 14 insertions(+), 16 deletions(-)

diff --git a/mm/madvise.c b/mm/madvise.c
index fc7c39805d78..5f5c2812996a 100644
--- a/mm/madvise.c
+++ b/mm/madvise.c
@@ -618,7 +618,6 @@ static long madvise_remove(struct vm_area_struct *vma,
 static int madvise_inject_error(int behavior,
 		unsigned long start, unsigned long end)
 {
-	struct page *page;
 	struct zone *zone;
 	unsigned long size;
 
@@ -627,6 +626,7 @@ static int madvise_inject_error(int behavior,
 
 
 	for (; start < end; start += size) {
+		struct page *page;
 		unsigned long pfn;
 		int ret;
 
@@ -649,25 +649,23 @@ static int madvise_inject_error(int behavior,
 
 		if (behavior == MADV_SOFT_OFFLINE) {
 			pr_info("Soft offlining pfn %#lx at process virtual address %#lx\n",
-					pfn, start);
+				 pfn, start);
 
 			ret = soft_offline_page(pfn, MF_COUNT_INCREASED);
-			if (ret)
-				return ret;
-			continue;
+		} else {
+			pr_info("Injecting memory failure for pfn %#lx at process virtual address %#lx\n",
+				 pfn, start);
+			/*
+			 * Drop the page reference taken by
+			 * get_user_pages_fast(). In the absence of
+			 * MF_COUNT_INCREASED the memory_failure() routine is
+			 * responsible for pinning the page to prevent it
+			 * from being released back to the page allocator.
+			 */
+			put_page(page);
+			ret = memory_failure(pfn, 0);
 		}
 
-		pr_info("Injecting memory failure for pfn %#lx at process virtual address %#lx\n",
-				pfn, start);
-
-		/*
-		 * Drop the page reference taken by get_user_pages_fast(). In
-		 * the absence of MF_COUNT_INCREASED the memory_failure()
-		 * routine is responsible for pinning the page to prevent it
-		 * from being released back to the page allocator.
-		 */
-		put_page(page);
-		ret = memory_failure(pfn, 0);
 		if (ret)
 			return ret;
 	}
-- 
2.26.2

