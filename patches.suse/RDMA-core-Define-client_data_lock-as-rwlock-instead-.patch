From: Parav Pandit <parav@mellanox.com>
Date: Tue, 28 Aug 2018 15:08:45 +0300
Subject: RDMA/core: Define client_data_lock as rwlock instead of spinlock
Patch-mainline: v4.20-rc1
Git-commit: e1f540c3ed0e9634d0f8c4600f3c85df8aff4ae2
References: bsc#1103992 FATE#326009

Even though device registration/unregistration and client
registration/unregistration is not a performance path, define the
client_data_lock as rwlock for code clarity.

Signed-off-by: Parav Pandit <parav@mellanox.com>
Reviewed-by: Daniel Jurgens <danielj@mellanox.com>
Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/infiniband/core/device.c |   30 +++++++++++++++---------------
 include/rdma/ib_verbs.h          |    5 +++--
 2 files changed, 18 insertions(+), 17 deletions(-)

--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@ -270,7 +270,7 @@ struct ib_device *ib_alloc_device(size_t
 
 	INIT_LIST_HEAD(&device->event_handler_list);
 	spin_lock_init(&device->event_handler_lock);
-	spin_lock_init(&device->client_data_lock);
+	rwlock_init(&device->client_data_lock);
 	INIT_LIST_HEAD(&device->client_data_list);
 	INIT_LIST_HEAD(&device->port_list);
 
@@ -307,9 +307,9 @@ static int add_client_context(struct ib_
 	context->going_down = false;
 
 	down_write(&lists_rwsem);
-	spin_lock_irq(&device->client_data_lock);
+	write_lock_irq(&device->client_data_lock);
 	list_add(&context->list, &device->client_data_list);
-	spin_unlock_irq(&device->client_data_lock);
+	write_unlock_irq(&device->client_data_lock);
 	up_write(&lists_rwsem);
 
 	return 0;
@@ -586,10 +586,10 @@ void ib_unregister_device(struct ib_devi
 
 	down_write(&lists_rwsem);
 	list_del(&device->core_list);
-	spin_lock_irq(&device->client_data_lock);
+	write_lock_irq(&device->client_data_lock);
 	list_for_each_entry(context, &device->client_data_list, list)
 		context->going_down = true;
-	spin_unlock_irq(&device->client_data_lock);
+	write_unlock_irq(&device->client_data_lock);
 	downgrade_write(&lists_rwsem);
 
 	list_for_each_entry(context, &device->client_data_list, list) {
@@ -609,13 +609,13 @@ void ib_unregister_device(struct ib_devi
 	kfree(device->port_pkey_list);
 
 	down_write(&lists_rwsem);
-	spin_lock_irqsave(&device->client_data_lock, flags);
+	write_lock_irqsave(&device->client_data_lock, flags);
 	list_for_each_entry_safe(context, tmp, &device->client_data_list,
 				 list) {
 		list_del(&context->list);
 		kfree(context);
 	}
-	spin_unlock_irqrestore(&device->client_data_lock, flags);
+	write_unlock_irqrestore(&device->client_data_lock, flags);
 	up_write(&lists_rwsem);
 
 	device->reg_state = IB_DEV_UNREGISTERED;
@@ -678,14 +678,14 @@ void ib_unregister_client(struct ib_clie
 		struct ib_client_data *found_context = NULL;
 
 		down_write(&lists_rwsem);
-		spin_lock_irq(&device->client_data_lock);
+		write_lock_irq(&device->client_data_lock);
 		list_for_each_entry(context, &device->client_data_list, list)
 			if (context->client == client) {
 				context->going_down = true;
 				found_context = context;
 				break;
 			}
-		spin_unlock_irq(&device->client_data_lock);
+		write_unlock_irq(&device->client_data_lock);
 		up_write(&lists_rwsem);
 
 		if (client->remove)
@@ -699,9 +699,9 @@ void ib_unregister_client(struct ib_clie
 		}
 
 		down_write(&lists_rwsem);
-		spin_lock_irq(&device->client_data_lock);
+		write_lock_irq(&device->client_data_lock);
 		list_del(&found_context->list);
-		spin_unlock_irq(&device->client_data_lock);
+		write_unlock_irq(&device->client_data_lock);
 		up_write(&lists_rwsem);
 		kfree(found_context);
 	}
@@ -724,13 +724,13 @@ void *ib_get_client_data(struct ib_devic
 	void *ret = NULL;
 	unsigned long flags;
 
-	spin_lock_irqsave(&device->client_data_lock, flags);
+	read_lock_irqsave(&device->client_data_lock, flags);
 	list_for_each_entry(context, &device->client_data_list, list)
 		if (context->client == client) {
 			ret = context->data;
 			break;
 		}
-	spin_unlock_irqrestore(&device->client_data_lock, flags);
+	read_unlock_irqrestore(&device->client_data_lock, flags);
 
 	return ret;
 }
@@ -751,7 +751,7 @@ void ib_set_client_data(struct ib_device
 	struct ib_client_data *context;
 	unsigned long flags;
 
-	spin_lock_irqsave(&device->client_data_lock, flags);
+	write_lock_irqsave(&device->client_data_lock, flags);
 	list_for_each_entry(context, &device->client_data_list, list)
 		if (context->client == client) {
 			context->data = data;
@@ -762,7 +762,7 @@ void ib_set_client_data(struct ib_device
 		device->name, client->name);
 
 out:
-	spin_unlock_irqrestore(&device->client_data_lock, flags);
+	write_unlock_irqrestore(&device->client_data_lock, flags);
 }
 EXPORT_SYMBOL(ib_set_client_data);
 
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@ -2269,10 +2269,11 @@ struct ib_device {
 	struct list_head              event_handler_list;
 	spinlock_t                    event_handler_lock;
 
-	spinlock_t                    client_data_lock;
+	rwlock_t			client_data_lock;
 	struct list_head              core_list;
 	/* Access to the client_data_list is protected by the client_data_lock
-	 * spinlock and the lists_rwsem read-write semaphore */
+	 * rwlock and the lists_rwsem read-write semaphore
+	 */
 	struct list_head              client_data_list;
 
 	struct ib_cache               cache;
