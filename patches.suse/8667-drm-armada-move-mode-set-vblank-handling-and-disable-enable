From: Russell King <rmk+kernel@armlinux.org.uk>
Date: Mon, 30 Jul 2018 11:52:34 +0100
Subject: drm/armada: move mode set vblank handling and disable/enable
Git-commit: f9a13bb3baf6009225e91f2b9748ed27f2db9c2c
Patch-mainline: v4.19-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Move the mode set vblank handling and controller enable/disable to the
prepare() and commit() callbacks.  This will be needed when we move to
mode_set_nofb() as we should not enable the controller without the
plane coordinates and location having been properly updated.

Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/armada/armada_crtc.c |   41 +++++++++++++++++------------------
 drivers/gpu/drm/armada/armada_crtc.h |    1 
 2 files changed, 21 insertions(+), 21 deletions(-)

--- a/drivers/gpu/drm/armada/armada_crtc.c
+++ b/drivers/gpu/drm/armada/armada_crtc.c
@@ -399,6 +399,7 @@ static void armada_drm_crtc_prepare(stru
 {
 	struct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);
 	struct drm_plane *plane;
+	u32 val;
 
 	/*
 	 * If we have an overlay plane associated with this CRTC, disable
@@ -411,6 +412,18 @@ static void armada_drm_crtc_prepare(stru
 		WARN_ON(!armada_drm_plane_work_wait(drm_to_armada_plane(plane),
 						    HZ));
 	}
+
+	/* Wait for pending flips to complete */
+	armada_drm_plane_work_wait(drm_to_armada_plane(dcrtc->crtc.primary),
+				   MAX_SCHEDULE_TIMEOUT);
+
+	drm_crtc_vblank_off(crtc);
+
+	val = dcrtc->dumb_ctrl & ~CFG_DUMB_ENA;
+	if (val != dcrtc->dumb_ctrl) {
+		dcrtc->dumb_ctrl = val;
+		writel_relaxed(val, dcrtc->base + LCD_SPU_DUMB_CTRL);
+	}
 }
 
 /* The mode_config.mutex will be held for this call */
@@ -418,10 +431,12 @@ static void armada_drm_crtc_commit(struc
 {
 	struct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);
 
-	if (dcrtc->dpms != DRM_MODE_DPMS_ON) {
-		dcrtc->dpms = DRM_MODE_DPMS_ON;
-		armada_drm_crtc_update(dcrtc);
-	}
+	dcrtc->dpms = DRM_MODE_DPMS_ON;
+	armada_drm_crtc_update(dcrtc);
+	drm_crtc_vblank_on(crtc);
+
+	if (dcrtc->old_modeset_fb)
+		armada_drm_crtc_finish_fb(dcrtc, dcrtc->old_modeset_fb, false);
 }
 
 /* The mode_config.mutex will be held for this call */
@@ -623,6 +638,7 @@ static int armada_drm_crtc_mode_set(stru
 	bool interlaced;
 
 	drm_framebuffer_get(crtc->primary->fb);
+	dcrtc->old_modeset_fb = old_fb;
 
 	interlaced = !!(adj->flags & DRM_MODE_FLAG_INTERLACE);
 
@@ -656,18 +672,6 @@ static int armada_drm_crtc_mode_set(stru
 		adj->crtc_vsync_end,
 		adj->crtc_vtotal, tm, bm);
 
-	/* Wait for pending flips to complete */
-	armada_drm_plane_work_wait(drm_to_armada_plane(dcrtc->crtc.primary),
-				   MAX_SCHEDULE_TIMEOUT);
-
-	drm_crtc_vblank_off(crtc);
-
-	val = dcrtc->dumb_ctrl & ~CFG_DUMB_ENA;
-	if (val != dcrtc->dumb_ctrl) {
-		dcrtc->dumb_ctrl = val;
-		writel_relaxed(val, dcrtc->base + LCD_SPU_DUMB_CTRL);
-	}
-
 	/*
 	 * If we are blanked, we would have disabled the clock.  Re-enable
 	 * it so that compute_clock() does the right thing.
@@ -739,11 +743,6 @@ static int armada_drm_crtc_mode_set(stru
 	armada_drm_primary_set(crtc, crtc->primary, x, y);
 	spin_unlock_irqrestore(&dcrtc->irq_lock, flags);
 
-	armada_drm_crtc_update(dcrtc);
-
-	drm_crtc_vblank_on(crtc);
-	armada_drm_crtc_finish_fb(dcrtc, old_fb, dpms_blanked(dcrtc->dpms));
-
 	return 0;
 }
 
--- a/drivers/gpu/drm/armada/armada_crtc.h
+++ b/drivers/gpu/drm/armada/armada_crtc.h
@@ -93,6 +93,7 @@ struct armada_crtc {
 	uint8_t			csc_rgb_mode;
 
 	struct drm_plane	*plane;
+	struct drm_framebuffer	*old_modeset_fb;
 
 	struct armada_gem_object	*cursor_obj;
 	int			cursor_x;
