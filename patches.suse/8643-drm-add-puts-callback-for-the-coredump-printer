From: Jordan Crouse <jcrouse@codeaurora.org>
Date: Tue, 24 Jul 2018 10:33:23 -0600
Subject: drm: Add puts callback for the coredump printer
Git-commit: 5dc634bdbfd6dd9bdf98bce0d6f64878e1d47b1f
Patch-mainline: v4.19-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Add a puts function for the coredump printer to bypass printf()
for constant strings for a speed boost. Reorganize the
coredump printf callback to share as much code as possible.

v2: Try to reuse code between print and puts as suggested by
    Chris Wilson

Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
Signed-off-by: Rob Clark <robdclark@gmail.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/drm_print.c |   84 +++++++++++++++++++++++++-------------------
 include/drm/drm_print.h     |    2 +
 2 files changed, 51 insertions(+), 35 deletions(-)

--- a/drivers/gpu/drm/drm_print.c
+++ b/drivers/gpu/drm/drm_print.c
@@ -30,7 +30,7 @@
 #include <drm/drmP.h>
 #include <drm/drm_print.h>
 
-void __drm_printfn_coredump(struct drm_printer *p, struct va_format *vaf)
+void __drm_puts_coredump(struct drm_printer *p, const char *str)
 {
 	struct drm_print_iterator *iterator = p->arg;
 	ssize_t len;
@@ -38,26 +38,16 @@ void __drm_printfn_coredump(struct drm_p
 	if (!iterator->remain)
 		return;
 
-	/* Figure out how big the string will be */
-	len = snprintf(NULL, 0, "%pV", vaf);
-
 	if (iterator->offset < iterator->start) {
-		char *buf;
 		ssize_t copy;
 
+		len = strlen(str);
+
 		if (iterator->offset + len <= iterator->start) {
 			iterator->offset += len;
 			return;
 		}
 
-		/* Print the string into a temporary buffer */
-		buf = kmalloc(len + 1,
-			GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);
-		if (!buf)
-			return;
-
-		snprintf(buf, len + 1, "%pV", vaf);
-
 		copy = len - (iterator->start - iterator->offset);
 
 		if (copy > iterator->remain)
@@ -65,42 +55,66 @@ void __drm_printfn_coredump(struct drm_p
 
 		/* Copy out the bit of the string that we need */
 		memcpy(iterator->data,
-			buf + (iterator->start - iterator->offset), copy);
+			str + (iterator->start - iterator->offset), copy);
 
 		iterator->offset = iterator->start + copy;
 		iterator->remain -= copy;
-
-		kfree(buf);
 	} else {
-		char *buf;
 		ssize_t pos = iterator->offset - iterator->start;
 
-		if (len < iterator->remain) {
-			snprintf(((char *) iterator->data) + pos,
-				iterator->remain, "%pV", vaf);
+		len = min_t(ssize_t, strlen(str), iterator->remain);
 
-			iterator->offset += len;
-			iterator->remain -= len;
+		memcpy(iterator->data + pos, str, len);
 
-			return;
-		}
+		iterator->offset += len;
+		iterator->remain -= len;
+	}
+}
+EXPORT_SYMBOL(__drm_puts_coredump);
 
-		/* Print the string into a temporary buffer */
-		buf = kmalloc(len + 1,
-			GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);
-		if (!buf)
-			return;
+void __drm_printfn_coredump(struct drm_printer *p, struct va_format *vaf)
+{
+	struct drm_print_iterator *iterator = p->arg;
+	size_t len;
+	char *buf;
+
+	if (!iterator->remain)
+		return;
+
+	/* Figure out how big the string will be */
+	len = snprintf(NULL, 0, "%pV", vaf);
+
+	/* This is the easiest path, we've already advanced beyond the offset */
+	if (iterator->offset + len <= iterator->start) {
+		iterator->offset += len;
+		return;
+	}
 
-		snprintf(buf, len + 1, "%pV", vaf);
+	/* Then check if we can directly copy into the target buffer */
+	if ((iterator->offset >= iterator->start) && (len < iterator->remain)) {
+		ssize_t pos = iterator->offset - iterator->start;
 
-		/* Copy out the remaining bits */
-		memcpy(iterator->data + pos, buf, iterator->remain);
+		snprintf(((char *) iterator->data) + pos,
+			iterator->remain, "%pV", vaf);
 
-		iterator->offset += iterator->remain;
-		iterator->remain = 0;
+		iterator->offset += len;
+		iterator->remain -= len;
 
-		kfree(buf);
+		return;
 	}
+
+	/*
+	 * Finally, hit the slow path and make a temporary string to copy over
+	 * using _drm_puts_coredump
+	 */
+	buf = kmalloc(len + 1, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);
+	if (!buf)
+		return;
+
+	snprintf(buf, len + 1, "%pV", vaf);
+	__drm_puts_coredump(p, (const char *) buf);
+
+	kfree(buf);
 }
 EXPORT_SYMBOL(__drm_printfn_coredump);
 
--- a/include/drm/drm_print.h
+++ b/include/drm/drm_print.h
@@ -75,6 +75,7 @@ struct drm_printer {
 };
 
 void __drm_printfn_coredump(struct drm_printer *p, struct va_format *vaf);
+void __drm_puts_coredump(struct drm_printer *p, const char *str);
 void __drm_printfn_seq_file(struct drm_printer *p, struct va_format *vaf);
 void __drm_puts_seq_file(struct drm_printer *p, const char *str);
 void __drm_printfn_info(struct drm_printer *p, struct va_format *vaf);
@@ -163,6 +164,7 @@ drm_coredump_printer(struct drm_print_it
 {
 	struct drm_printer p = {
 		.printfn = __drm_printfn_coredump,
+		.puts = __drm_puts_coredump,
 		.arg = iter,
 	};
 
