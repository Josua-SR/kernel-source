From: Russell King <rmk+kernel@armlinux.org.uk>
Date: Mon, 30 Jul 2018 11:52:34 +0100
Subject: drm/armada: pass plane state into armada_drm_plane_calc_addrs()
Git-commit: b4df3ba0d76823cb5e548505de104837d89aa5a9
Patch-mainline: v4.19-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

armada_drm_plane_calc_addrs() gets all its information from the plane
state, so it makes sense to pass the plane state pointer down into this
function, rather than extracting the information in identical ways,
sometimes a couple of layers up.

Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/armada/armada_overlay.c |    6 +++---
 drivers/gpu/drm/armada/armada_plane.c   |   25 ++++++++++++-------------
 drivers/gpu/drm/armada/armada_plane.h   |    3 +--
 3 files changed, 16 insertions(+), 18 deletions(-)

--- a/drivers/gpu/drm/armada/armada_overlay.c
+++ b/drivers/gpu/drm/armada/armada_overlay.c
@@ -130,11 +130,10 @@ static void armada_drm_overlay_plane_ato
 	    old_state->src.y1 != state->src.y1 ||
 	    old_state->fb != state->fb) {
 		const struct drm_format_info *format;
-		u16 src_x = state->src.x1 >> 16;
-		u16 src_y = state->src.y1 >> 16;
+		u16 src_x;
 		u32 addrs[3];
 
-		armada_drm_plane_calc_addrs(addrs, state->fb, src_x, src_y);
+		armada_drm_plane_calc_addrs(state, addrs);
 
 		armada_reg_queue_set(regs, idx, addrs[0],
 				     LCD_SPU_DMA_START_ADDR_Y0);
@@ -166,6 +165,7 @@ static void armada_drm_overlay_plane_ato
 		 * the UV swap.
 		 */
 		format = state->fb->format;
+		src_x = state->src.x1 >> 16;
 		if (format->num_planes == 1 && src_x & (format->hsub - 1))
 			cfg ^= CFG_DMA_MOD(CFG_SWAPUV);
 		cfg_mask = CFG_CBSH_ENA | CFG_DMAFORMAT |
--- a/drivers/gpu/drm/armada/armada_plane.c
+++ b/drivers/gpu/drm/armada/armada_plane.c
@@ -35,14 +35,19 @@ static const uint32_t armada_primary_for
 	DRM_FORMAT_BGR565,
 };
 
-void armada_drm_plane_calc_addrs(u32 *addrs, struct drm_framebuffer *fb,
-	int x, int y)
+void armada_drm_plane_calc_addrs(struct drm_plane_state *state, u32 addrs[3])
 {
+	struct drm_framebuffer *fb = state->fb;
 	const struct drm_format_info *format = fb->format;
 	unsigned int num_planes = format->num_planes;
+	unsigned int x = state->src.x1 >> 16;
+	unsigned int y = state->src.y1 >> 16;
 	u32 addr = drm_fb_obj(fb)->dev_addr;
 	int i;
 
+	DRM_DEBUG_KMS("pitch %u x %d y %d bpp %d\n",
+		      fb->pitches[0], x, y, format->cpp[0] * 8);
+
 	if (num_planes > 3)
 		num_planes = 3;
 
@@ -59,17 +64,14 @@ void armada_drm_plane_calc_addrs(u32 *ad
 		addrs[i] = 0;
 }
 
-static unsigned armada_drm_crtc_calc_fb(struct drm_framebuffer *fb,
-	int x, int y, struct armada_regs *regs, bool interlaced)
+static unsigned armada_drm_crtc_calc_fb(struct drm_plane_state *state,
+	struct armada_regs *regs, bool interlaced)
 {
-	unsigned pitch = fb->pitches[0];
+	unsigned pitch = state->fb->pitches[0];
 	u32 addrs[3], addr_odd, addr_even;
 	unsigned i = 0;
 
-	DRM_DEBUG_DRIVER("pitch %u x %d y %d bpp %d\n",
-		pitch, x, y, fb->format->cpp[0] * 8);
-
-	armada_drm_plane_calc_addrs(addrs, fb, x, y);
+	armada_drm_plane_calc_addrs(state, addrs);
 
 	addr_odd = addr_even = addrs[0];
 
@@ -175,10 +177,7 @@ static void armada_drm_primary_plane_ato
 	if (old_state->src.x1 != state->src.x1 ||
 	    old_state->src.y1 != state->src.y1 ||
 	    old_state->fb != state->fb) {
-		idx += armada_drm_crtc_calc_fb(state->fb,
-					       state->src.x1 >> 16,
-					       state->src.y1 >> 16,
-					       regs + idx,
+		idx += armada_drm_crtc_calc_fb(state, regs + idx,
 					       dcrtc->interlaced);
 	}
 	if (old_state->fb != state->fb) {
--- a/drivers/gpu/drm/armada/armada_plane.h
+++ b/drivers/gpu/drm/armada/armada_plane.h
@@ -1,8 +1,7 @@
 #ifndef ARMADA_PLANE_H
 #define ARMADA_PLANE_H
 
-void armada_drm_plane_calc_addrs(u32 *addrs, struct drm_framebuffer *fb,
-	int x, int y);
+void armada_drm_plane_calc_addrs(struct drm_plane_state *state, u32 addrs[3]);
 int armada_drm_plane_prepare_fb(struct drm_plane *plane,
 	struct drm_plane_state *state);
 void armada_drm_plane_cleanup_fb(struct drm_plane *plane,
