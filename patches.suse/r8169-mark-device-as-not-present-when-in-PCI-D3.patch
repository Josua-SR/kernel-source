From 476c4f5de3689a39a097ad20120ca5653a52dad4 Mon Sep 17 00:00:00 2001
From: Heiner Kallweit <hkallweit1@gmail.com>
Date: Sat, 20 Jun 2020 22:36:26 +0200
Subject: [PATCH] r8169: mark device as not present when in PCI D3
Git-commit: 476c4f5de3689a39a097ad20120ca5653a52dad4
Patch-mainline: v5.9-rc1
References: bsc#1175746

Mark the netdevice as detached whenever we go into PCI D3hot.
This allows to remove some checks e.g. from ethtool ops because
dev_ethtool() checks for netif_device_present() in the beginning.

In this context move waking up the queue out of rtl_reset_work()
because in cases where netif_device_attach() is called afterwards
the queue should be woken up by the latter function only.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/net/ethernet/realtek/r8169_main.c | 25 ++++++++++++++-----------
 1 file changed, 14 insertions(+), 11 deletions(-)

diff --git a/drivers/net/ethernet/realtek/r8169_main.c b/drivers/net/ethernet/realtek/r8169_main.c
index a3c4187d918b..ec724e69931d 100644
--- a/drivers/net/ethernet/realtek/r8169_main.c
+++ b/drivers/net/ethernet/realtek/r8169_main.c
@@ -3977,10 +3977,9 @@ static void rtl8169_cleanup(struct rtl8169_private *tp, bool going_down)
 
 static void rtl_reset_work(struct rtl8169_private *tp)
 {
-	struct net_device *dev = tp->dev;
 	int i;
 
-	netif_stop_queue(dev);
+	netif_stop_queue(tp->dev);
 
 	rtl8169_cleanup(tp, false);
 
@@ -3989,7 +3988,6 @@ static void rtl_reset_work(struct rtl8169_private *tp)
 
 	napi_enable(&tp->napi);
 	rtl_hw_start(tp);
-	netif_wake_queue(dev);
 }
 
 static void rtl8169_tx_timeout(struct net_device *dev, unsigned int txqueue)
@@ -4574,8 +4572,10 @@ static void rtl_task(struct work_struct *work)
 	    !test_bit(RTL_FLAG_TASK_ENABLED, tp->wk.flags))
 		goto out_unlock;
 
-	if (test_and_clear_bit(RTL_FLAG_TASK_RESET_PENDING, tp->wk.flags))
+	if (test_and_clear_bit(RTL_FLAG_TASK_RESET_PENDING, tp->wk.flags)) {
 		rtl_reset_work(tp);
+		netif_wake_queue(tp->dev);
+	}
 out_unlock:
 	rtl_unlock_work(tp);
 }
@@ -4820,11 +4820,10 @@ rtl8169_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
 
 static void rtl8169_net_suspend(struct rtl8169_private *tp)
 {
-	if (!netif_running(tp->dev))
-		return;
-
 	netif_device_detach(tp->dev);
-	rtl8169_down(tp);
+
+	if (netif_running(tp->dev))
+		rtl8169_down(tp);
 }
 
 #ifdef CONFIG_PM
@@ -4840,8 +4839,6 @@ static int __maybe_unused rtl8169_suspend(struct device *device)
 
 static void __rtl8169_resume(struct rtl8169_private *tp)
 {
-	netif_device_attach(tp->dev);
-
 	rtl_pll_power_up(tp);
 	rtl8169_init_phy(tp);
 
@@ -4863,6 +4860,8 @@ static int __maybe_unused rtl8169_resume(struct device *device)
 	if (netif_running(tp->dev))
 		__rtl8169_resume(tp);
 
+	netif_device_attach(tp->dev);
+
 	return 0;
 }
 
@@ -4870,8 +4869,10 @@ static int rtl8169_runtime_suspend(struct device *device)
 {
 	struct rtl8169_private *tp = dev_get_drvdata(device);
 
-	if (!tp->TxDescArray)
+	if (!tp->TxDescArray) {
+		netif_device_detach(tp->dev);
 		return 0;
+	}
 
 	rtl_lock_work(tp);
 	__rtl8169_set_wol(tp, WAKE_PHY);
@@ -4895,6 +4896,8 @@ static int rtl8169_runtime_resume(struct device *device)
 	if (tp->TxDescArray)
 		__rtl8169_resume(tp);
 
+	netif_device_attach(tp->dev);
+
 	return 0;
 }
 
-- 
2.16.4

