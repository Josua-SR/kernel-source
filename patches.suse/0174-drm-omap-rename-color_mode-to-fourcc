From: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date: Thu, 4 May 2017 11:31:56 +0300
Subject: drm/omap: rename color_mode to fourcc
Git-commit: 41aff42ae6e3e9dbb800640fe3bb62383d4aa6e3
Patch-mainline: v4.13-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Now that we use fourccs, we can also rename the 'color_mode' variables
to 'fourcc'.

Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/omapdrm/dss/dispc.c        |  108 +++++++++++++----------------
 drivers/gpu/drm/omapdrm/dss/dss_features.c |    5 -
 drivers/gpu/drm/omapdrm/dss/dss_features.h |    2 
 drivers/gpu/drm/omapdrm/dss/omapdss.h      |    4 -
 drivers/gpu/drm/omapdrm/omap_fb.c          |    2 
 5 files changed, 58 insertions(+), 63 deletions(-)

--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -78,7 +78,7 @@ struct dispc_features {
 	int (*calc_scaling) (unsigned long pclk, unsigned long lclk,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 color_mode, bool *five_taps,
+		u32 fourcc, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
 		u16 pos_x, unsigned long *core_clk, bool mem_to_mem);
 	unsigned long (*calc_core_clk) (unsigned long pclk,
@@ -906,12 +906,11 @@ static void dispc_ovl_set_row_inc(enum o
 	dispc_write_reg(DISPC_OVL_ROW_INC(plane), inc);
 }
 
-static void dispc_ovl_set_color_mode(enum omap_plane_id plane,
-		u32 color_mode)
+static void dispc_ovl_set_color_mode(enum omap_plane_id plane, u32 fourcc)
 {
 	u32 m = 0;
 	if (plane != OMAP_DSS_GFX) {
-		switch (color_mode) {
+		switch (fourcc) {
 		case DRM_FORMAT_NV12:
 			m = 0x0; break;
 		case DRM_FORMAT_XRGB4444:
@@ -946,7 +945,7 @@ static void dispc_ovl_set_color_mode(enu
 			BUG(); return;
 		}
 	} else {
-		switch (color_mode) {
+		switch (fourcc) {
 		case DRM_FORMAT_RGBX4444:
 			m = 0x4; break;
 		case DRM_FORMAT_ARGB4444:
@@ -979,9 +978,9 @@ static void dispc_ovl_set_color_mode(enu
 	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), m, 4, 1);
 }
 
-static bool format_is_yuv(u32 color_mode)
+static bool format_is_yuv(u32 fourcc)
 {
-	switch (color_mode) {
+	switch (fourcc) {
 	case DRM_FORMAT_YUYV:
 	case DRM_FORMAT_UYVY:
 	case DRM_FORMAT_NV12:
@@ -1563,7 +1562,7 @@ static void dispc_ovl_set_scale_param(en
 
 static void dispc_ovl_set_accu_uv(enum omap_plane_id plane,
 		u16 orig_width,	u16 orig_height, u16 out_width, u16 out_height,
-		bool ilace, u32 color_mode, u8 rotation)
+		bool ilace, u32 fourcc, u8 rotation)
 {
 	int h_accu2_0, h_accu2_1;
 	int v_accu2_0, v_accu2_1;
@@ -1619,7 +1618,7 @@ static void dispc_ovl_set_accu_uv(enum o
 		return;
 	}
 
-	switch (color_mode) {
+	switch (fourcc) {
 	case DRM_FORMAT_NV12:
 		if (ilace)
 			accu_table = accu_nv12_ilace;
@@ -1653,7 +1652,7 @@ static void dispc_ovl_set_scaling_common
 		u16 orig_width, u16 orig_height,
 		u16 out_width, u16 out_height,
 		bool ilace, bool five_taps,
-		bool fieldmode, u32 color_mode,
+		bool fieldmode, u32 fourcc,
 		u8 rotation)
 {
 	int accu0 = 0;
@@ -1707,7 +1706,7 @@ static void dispc_ovl_set_scaling_uv(enu
 		u16 orig_width, u16 orig_height,
 		u16 out_width, u16 out_height,
 		bool ilace, bool five_taps,
-		bool fieldmode, u32 color_mode,
+		bool fieldmode, u32 fourcc,
 		u8 rotation)
 {
 	int scale_x = out_width != orig_width;
@@ -1717,7 +1716,7 @@ static void dispc_ovl_set_scaling_uv(enu
 	if (!dss_has_feature(FEAT_HANDLE_UV_SEPARATE))
 		return;
 
-	if (!format_is_yuv(color_mode)) {
+	if (!format_is_yuv(fourcc)) {
 		/* reset chroma resampling for RGB formats  */
 		if (plane != OMAP_DSS_WB)
 			REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), 0, 8, 8);
@@ -1725,9 +1724,9 @@ static void dispc_ovl_set_scaling_uv(enu
 	}
 
 	dispc_ovl_set_accu_uv(plane, orig_width, orig_height, out_width,
-			out_height, ilace, color_mode, rotation);
+			out_height, ilace, fourcc, rotation);
 
-	switch (color_mode) {
+	switch (fourcc) {
 	case DRM_FORMAT_NV12:
 		if (chroma_upscale) {
 			/* UV is subsampled by 2 horizontally and vertically */
@@ -1786,7 +1785,7 @@ static void dispc_ovl_set_scaling(enum o
 		u16 orig_width, u16 orig_height,
 		u16 out_width, u16 out_height,
 		bool ilace, bool five_taps,
-		bool fieldmode, u32 color_mode,
+		bool fieldmode, u32 fourcc,
 		u8 rotation)
 {
 	BUG_ON(plane == OMAP_DSS_GFX);
@@ -1795,26 +1794,25 @@ static void dispc_ovl_set_scaling(enum o
 			orig_width, orig_height,
 			out_width, out_height,
 			ilace, five_taps,
-			fieldmode, color_mode,
+			fieldmode, fourcc,
 			rotation);
 
 	dispc_ovl_set_scaling_uv(plane,
 		orig_width, orig_height,
 		out_width, out_height,
 		ilace, five_taps,
-		fieldmode, color_mode,
+		fieldmode, fourcc,
 		rotation);
 }
 
 static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
 		enum omap_dss_rotation_type rotation_type,
-		bool mirroring, u32 color_mode)
+		bool mirroring, u32 fourcc)
 {
 	bool row_repeat = false;
 	int vidrot = 0;
 
-	if (color_mode == DRM_FORMAT_YUYV ||
-			color_mode == DRM_FORMAT_UYVY) {
+	if (fourcc == DRM_FORMAT_YUYV || fourcc == DRM_FORMAT_UYVY) {
 
 		if (mirroring) {
 			switch (rotation) {
@@ -1859,8 +1857,7 @@ static void dispc_ovl_set_rotation_attrs
 	 * NV12 in 1D mode must use ROTATION=1. Otherwise DSS will fetch extra
 	 * rows beyond the framebuffer, which may cause OCP error.
 	 */
-	if (color_mode == DRM_FORMAT_NV12 &&
-			rotation_type != OMAP_DSS_ROT_TILER)
+	if (fourcc == DRM_FORMAT_NV12 && rotation_type != OMAP_DSS_ROT_TILER)
 		vidrot = 1;
 
 	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), vidrot, 13, 12);
@@ -1870,7 +1867,7 @@ static void dispc_ovl_set_rotation_attrs
 
 	if (dss_feat_color_mode_supported(plane, DRM_FORMAT_NV12)) {
 		bool doublestride =
-			color_mode == DRM_FORMAT_NV12 &&
+			fourcc == DRM_FORMAT_NV12 &&
 			rotation_type == OMAP_DSS_ROT_TILER &&
 			(rotation == OMAP_DSS_ROT_0 || rotation == OMAP_DSS_ROT_180);
 
@@ -1879,9 +1876,9 @@ static void dispc_ovl_set_rotation_attrs
 	}
 }
 
-static int color_mode_to_bpp(u32 color_mode)
+static int color_mode_to_bpp(u32 fourcc)
 {
-	switch (color_mode) {
+	switch (fourcc) {
 	case DRM_FORMAT_NV12:
 		return 8;
 	case DRM_FORMAT_RGBX4444:
@@ -1921,13 +1918,13 @@ static s32 pixinc(int pixels, u8 ps)
 }
 
 static void calc_offset(u16 screen_width, u16 width,
-		u32 color_mode, bool fieldmode,
+		u32 fourcc, bool fieldmode,
 		unsigned int field_offset, unsigned *offset0, unsigned *offset1,
 		s32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)
 {
 	u8 ps;
 
-	ps = color_mode_to_bpp(color_mode) / 8;
+	ps = color_mode_to_bpp(fourcc) / 8;
 
 	DSSDBG("scrw %d, width %d\n", screen_width, width);
 
@@ -1940,8 +1937,7 @@ static void calc_offset(u16 screen_width
 
 	*row_inc = pixinc(1 + (y_predecim * screen_width - width * x_predecim) +
 			(fieldmode ? screen_width : 0), ps);
-	if (color_mode == DRM_FORMAT_YUYV ||
-		color_mode == DRM_FORMAT_UYVY)
+	if (fourcc == DRM_FORMAT_YUYV || fourcc == DRM_FORMAT_UYVY)
 		*pix_inc = pixinc(x_predecim, 2 * ps);
 	else
 		*pix_inc = pixinc(x_predecim, ps);
@@ -2008,7 +2004,7 @@ static int check_horiz_timing_omap3(unsi
 static unsigned long calc_core_clk_five_taps(unsigned long pclk,
 		const struct videomode *vm, u16 width,
 		u16 height, u16 out_width, u16 out_height,
-		u32 color_mode)
+		u32 fourcc)
 {
 	u32 core_clk = 0;
 	u64 tmp;
@@ -2038,7 +2034,7 @@ static unsigned long calc_core_clk_five_
 		do_div(tmp, out_width);
 		core_clk = max_t(u32, core_clk, tmp);
 
-		if (color_mode == DRM_FORMAT_XRGB8888)
+		if (fourcc == DRM_FORMAT_XRGB8888)
 			core_clk <<= 1;
 	}
 
@@ -2101,7 +2097,7 @@ static unsigned long calc_core_clk_44xx(
 static int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 color_mode, bool *five_taps,
+		u32 fourcc, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
 		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
 {
@@ -2147,7 +2143,7 @@ static int dispc_ovl_calc_scaling_24xx(u
 static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 color_mode, bool *five_taps,
+		u32 fourcc, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
 		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
 {
@@ -2169,7 +2165,7 @@ again:
 		if (*five_taps)
 			*core_clk = calc_core_clk_five_taps(pclk, vm,
 						in_width, in_height, out_width,
-						out_height, color_mode);
+						out_height, fourcc);
 		else
 			*core_clk = dispc.feat->calc_core_clk(pclk, in_width,
 					in_height, out_width, out_height,
@@ -2232,7 +2228,7 @@ again:
 static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 color_mode, bool *five_taps,
+		u32 fourcc, bool *five_taps,
 		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
 		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
 {
@@ -2266,7 +2262,7 @@ static int dispc_ovl_calc_scaling_44xx(u
 		return -EINVAL;
 	}
 
-	if (*decim_x > 4 && color_mode != DRM_FORMAT_NV12) {
+	if (*decim_x > 4 && fourcc != DRM_FORMAT_NV12) {
 		/*
 		 * Let's disable all scaling that requires horizontal
 		 * decimation with higher factor than 4, until we have
@@ -2297,7 +2293,7 @@ static int dispc_ovl_calc_scaling(unsign
 		enum omap_overlay_caps caps,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 color_mode, bool *five_taps,
+		u32 fourcc, bool *five_taps,
 		int *x_predecim, int *y_predecim, u16 pos_x,
 		enum omap_dss_rotation_type rotation_type, bool mem_to_mem)
 {
@@ -2336,7 +2332,7 @@ static int dispc_ovl_calc_scaling(unsign
 		return -EINVAL;
 
 	ret = dispc.feat->calc_scaling(pclk, lclk, vm, width, height,
-		out_width, out_height, color_mode, five_taps,
+		out_width, out_height, fourcc, five_taps,
 		x_predecim, y_predecim, &decim_x, &decim_y, pos_x, &core_clk,
 		mem_to_mem);
 	if (ret)
@@ -2372,7 +2368,7 @@ static int dispc_ovl_calc_scaling(unsign
 static int dispc_ovl_setup_common(enum omap_plane_id plane,
 		enum omap_overlay_caps caps, u32 paddr, u32 p_uv_addr,
 		u16 screen_width, int pos_x, int pos_y, u16 width, u16 height,
-		u16 out_width, u16 out_height, u32 color_mode,
+		u16 out_width, u16 out_height, u32 fourcc,
 		u8 rotation, bool mirror, u8 zorder, u8 pre_mult_alpha,
 		u8 global_alpha, enum omap_dss_rotation_type rotation_type,
 		bool replication, const struct videomode *vm,
@@ -2396,7 +2392,7 @@ static int dispc_ovl_setup_common(enum o
 	if (paddr == 0 && rotation_type != OMAP_DSS_ROT_TILER)
 		return -EINVAL;
 
-	if (format_is_yuv(color_mode) && (in_width & 1)) {
+	if (format_is_yuv(fourcc) && (in_width & 1)) {
 		DSSERR("input width %d is not even for YUV format\n", in_width);
 		return -EINVAL;
 	}
@@ -2418,11 +2414,11 @@ static int dispc_ovl_setup_common(enum o
 			out_height);
 	}
 
-	if (!dss_feat_color_mode_supported(plane, color_mode))
+	if (!dss_feat_color_mode_supported(plane, fourcc))
 		return -EINVAL;
 
 	r = dispc_ovl_calc_scaling(pclk, lclk, caps, vm, in_width,
-			in_height, out_width, out_height, color_mode,
+			in_height, out_width, out_height, fourcc,
 			&five_taps, &x_predecim, &y_predecim, pos_x,
 			rotation_type, mem_to_mem);
 	if (r)
@@ -2435,7 +2431,7 @@ static int dispc_ovl_setup_common(enum o
 		DSSDBG("predecimation %d x %x, new input size %d x %d\n",
 			x_predecim, y_predecim, in_width, in_height);
 
-	if (format_is_yuv(color_mode) && (in_width & 1)) {
+	if (format_is_yuv(fourcc) && (in_width & 1)) {
 		DSSDBG("predecimated input width is not even for YUV format\n");
 		DSSDBG("adjusting input width %d -> %d\n",
 			in_width, in_width & ~1);
@@ -2443,7 +2439,7 @@ static int dispc_ovl_setup_common(enum o
 		in_width &= ~1;
 	}
 
-	if (format_is_yuv(color_mode))
+	if (format_is_yuv(fourcc))
 		cconv = 1;
 
 	if (ilace && !fieldmode) {
@@ -2478,14 +2474,14 @@ static int dispc_ovl_setup_common(enum o
 	}
 
 	calc_offset(screen_width, frame_width,
-			color_mode, fieldmode, field_offset,
+			fourcc, fieldmode, field_offset,
 			&offset0, &offset1, &row_inc, &pix_inc,
 			x_predecim, y_predecim);
 
 	DSSDBG("offset0 %u, offset1 %u, row_inc %d, pix_inc %d\n",
 			offset0, offset1, row_inc, pix_inc);
 
-	dispc_ovl_set_color_mode(plane, color_mode);
+	dispc_ovl_set_color_mode(plane, fourcc);
 
 	dispc_ovl_configure_burst_type(plane, rotation_type);
 
@@ -2495,7 +2491,7 @@ static int dispc_ovl_setup_common(enum o
 	dispc_ovl_set_ba0(plane, paddr + offset0);
 	dispc_ovl_set_ba1(plane, paddr + offset1);
 
-	if (color_mode == DRM_FORMAT_NV12) {
+	if (fourcc == DRM_FORMAT_NV12) {
 		dispc_ovl_set_ba0_uv(plane, p_uv_addr + offset0);
 		dispc_ovl_set_ba1_uv(plane, p_uv_addr + offset1);
 	}
@@ -2516,13 +2512,13 @@ static int dispc_ovl_setup_common(enum o
 	if (caps & OMAP_DSS_OVL_CAP_SCALE) {
 		dispc_ovl_set_scaling(plane, in_width, in_height, out_width,
 				   out_height, ilace, five_taps, fieldmode,
-				   color_mode, rotation);
+				   fourcc, rotation);
 		dispc_ovl_set_output_size(plane, out_width, out_height);
 		dispc_ovl_set_vid_color_conv(plane, cconv);
 	}
 
 	dispc_ovl_set_rotation_attrs(plane, rotation, rotation_type, mirror,
-			color_mode);
+			fourcc);
 
 	dispc_ovl_set_zorder(plane, caps, zorder);
 	dispc_ovl_set_pre_mult_alpha(plane, caps, pre_mult_alpha);
@@ -2546,13 +2542,13 @@ static int dispc_ovl_setup(enum omap_pla
 		" %dx%d, cmode %x, rot %d, mir %d, chan %d repl %d\n",
 		plane, &oi->paddr, &oi->p_uv_addr, oi->screen_width, oi->pos_x,
 		oi->pos_y, oi->width, oi->height, oi->out_width, oi->out_height,
-		oi->color_mode, oi->rotation, oi->mirror, channel, replication);
+		oi->fourcc, oi->rotation, oi->mirror, channel, replication);
 
 	dispc_ovl_set_channel_out(plane, channel);
 
 	r = dispc_ovl_setup_common(plane, caps, oi->paddr, oi->p_uv_addr,
 		oi->screen_width, oi->pos_x, oi->pos_y, oi->width, oi->height,
-		oi->out_width, oi->out_height, oi->color_mode, oi->rotation,
+		oi->out_width, oi->out_height, oi->fourcc, oi->rotation,
 		oi->mirror, oi->zorder, oi->pre_mult_alpha, oi->global_alpha,
 		oi->rotation_type, replication, vm, mem_to_mem);
 
@@ -2576,16 +2572,16 @@ int dispc_wb_setup(const struct omap_dss
 
 	DSSDBG("dispc_wb_setup, pa %x, pa_uv %x, %d,%d -> %dx%d, cmode %x, "
 		"rot %d, mir %d\n", wi->paddr, wi->p_uv_addr, in_width,
-		in_height, wi->width, wi->height, wi->color_mode, wi->rotation,
+		in_height, wi->width, wi->height, wi->fourcc, wi->rotation,
 		wi->mirror);
 
 	r = dispc_ovl_setup_common(plane, caps, wi->paddr, wi->p_uv_addr,
 		wi->buf_width, pos_x, pos_y, in_width, in_height, wi->width,
-		wi->height, wi->color_mode, wi->rotation, wi->mirror, zorder,
+		wi->height, wi->fourcc, wi->rotation, wi->mirror, zorder,
 		wi->pre_mult_alpha, global_alpha, wi->rotation_type,
 		replication, vm, mem_to_mem);
 
-	switch (wi->color_mode) {
+	switch (wi->fourcc) {
 	case DRM_FORMAT_RGB565:
 	case DRM_FORMAT_RGB888:
 	case DRM_FORMAT_ARGB4444:
@@ -3919,7 +3915,7 @@ static const struct dispc_errata_i734_da
 	.ovli = {
 		.screen_width = 1,
 		.width = 1, .height = 1,
-		.color_mode = DRM_FORMAT_XRGB8888,
+		.fourcc = DRM_FORMAT_XRGB8888,
 		.rotation = OMAP_DSS_ROT_0,
 		.rotation_type = OMAP_DSS_ROT_NONE,
 		.mirror = 0,
@@ -3960,7 +3956,7 @@ static int dispc_errata_i734_wa_init(voi
 		return 0;
 
 	i734_buf.size = i734.ovli.width * i734.ovli.height *
-		color_mode_to_bpp(i734.ovli.color_mode) / 8;
+		color_mode_to_bpp(i734.ovli.fourcc) / 8;
 
 	i734_buf.vaddr = dma_alloc_writecombine(&dispc.pdev->dev, i734_buf.size,
 						&i734_buf.paddr, GFP_KERNEL);
--- a/drivers/gpu/drm/omapdrm/dss/dss_features.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss_features.c
@@ -808,8 +808,7 @@ enum omap_overlay_caps dss_feat_get_over
 	return omap_current_dss_features->overlay_caps[plane];
 }
 
-bool dss_feat_color_mode_supported(enum omap_plane_id plane,
-		u32 color_mode)
+bool dss_feat_color_mode_supported(enum omap_plane_id plane, u32 fourcc)
 {
 	const u32 *modes;
 	unsigned int i;
@@ -817,7 +816,7 @@ bool dss_feat_color_mode_supported(enum
 	modes = omap_current_dss_features->supported_color_modes[plane];
 
 	for (i = 0; modes[i]; ++i) {
-		if (modes[i] == color_mode)
+		if (modes[i] == fourcc)
 			return true;
 	}
 
--- a/drivers/gpu/drm/omapdrm/dss/dss_features.h
+++ b/drivers/gpu/drm/omapdrm/dss/dss_features.h
@@ -90,7 +90,7 @@ unsigned long dss_feat_get_param_min(enu
 unsigned long dss_feat_get_param_max(enum dss_range_param param);
 enum omap_overlay_caps dss_feat_get_overlay_caps(enum omap_plane_id plane);
 bool dss_feat_color_mode_supported(enum omap_plane_id plane,
-		u32 color_mode);
+		u32 fourcc);
 
 u32 dss_feat_get_buffer_size_unit(void);	/* in bytes */
 u32 dss_feat_get_burst_size_unit(void);		/* in bytes */
--- a/drivers/gpu/drm/omapdrm/dss/omapdss.h
+++ b/drivers/gpu/drm/omapdrm/dss/omapdss.h
@@ -268,7 +268,7 @@ struct omap_overlay_info {
 	u16 screen_width;
 	u16 width;
 	u16 height;
-	u32 color_mode;
+	u32 fourcc;
 	u8 rotation;
 	enum omap_dss_rotation_type rotation_type;
 	bool mirror;
@@ -316,7 +316,7 @@ struct omap_dss_writeback_info {
 	u16 buf_width;
 	u16 width;
 	u16 height;
-	u32 color_mode;
+	u32 fourcc;
 	u8 rotation;
 	enum omap_dss_rotation_type rotation_type;
 	bool mirror;
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -132,7 +132,7 @@ void omap_framebuffer_update_scanout(str
 	struct plane *plane = &omap_fb->planes[0];
 	uint32_t x, y, orient = 0;
 
-	info->color_mode = fb->format->format;
+	info->fourcc = fb->format->format;
 
 	info->pos_x      = win->crtc_x;
 	info->pos_y      = win->crtc_y;
