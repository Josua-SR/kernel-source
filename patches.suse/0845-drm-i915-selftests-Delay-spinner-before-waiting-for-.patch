From 166646fff203ded90ecbaefd665c59aa507263ee Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Fri, 17 Apr 2020 10:39:27 +0100
Subject: drm/i915/selftests: Delay spinner before waiting for an interrupt
Git-commit: 9d7e560f432766e5894bfbac41d6faa5f3daf1b7
Patch-mainline: v5.8-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

It seems that although (perhaps because of the memory stall?) the
spinner has signaled that it has started, it still takes some time to
spin up to 100% utilisation of the HW. Since the test depends on the
full utilisation of the HW to trigger the RPS interrupt, wait a little
bit and flush the interrupt status to be sure that the event we see if
from the spinner.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Reviewed-by: Andi Shyti <andi.shyti@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200417093928.17822-1-chris@chris-wilson.co.uk
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/i915/gt/selftest_rps.c | 28 +++++++++++++++-----------
 1 file changed, 16 insertions(+), 12 deletions(-)

diff --git a/drivers/gpu/drm/i915/gt/selftest_rps.c b/drivers/gpu/drm/i915/gt/selftest_rps.c
index 26aadc2ae3be..199d608aa763 100644
--- a/drivers/gpu/drm/i915/gt/selftest_rps.c
+++ b/drivers/gpu/drm/i915/gt/selftest_rps.c
@@ -14,6 +14,20 @@ static void dummy_rps_work(struct work_struct *wrk)
 {
 }
 
+static void sleep_for_ei(struct intel_rps *rps, int timeout_us)
+{
+	/* Flush any previous EI */
+	usleep_range(timeout_us, 2 * timeout_us);
+
+	/* Reset the interrupt status */
+	rps_disable_interrupts(rps);
+	GEM_BUG_ON(rps->pm_iir);
+	rps_enable_interrupts(rps);
+
+	/* And then wait for the timeout, for real this time */
+	usleep_range(2 * timeout_us, 3 * timeout_us);
+}
+
 static int __rps_up_interrupt(struct intel_rps *rps,
 			      struct intel_engine_cs *engine,
 			      struct igt_spinner *spin)
@@ -28,7 +42,6 @@ static int __rps_up_interrupt(struct intel_rps *rps,
 	intel_gt_pm_wait_for_idle(engine->gt);
 	GEM_BUG_ON(rps->active);
 
-	rps->pm_iir = 0;
 	rps->cur_freq = rps->min_freq;
 
 	rq = igt_spinner_create_request(spin, engine->kernel_context, MI_NOOP);
@@ -71,7 +84,7 @@ static int __rps_up_interrupt(struct intel_rps *rps,
 	timeout = intel_uncore_read(uncore, GEN6_RP_UP_EI);
 	timeout = GT_PM_INTERVAL_TO_US(engine->i915, timeout);
 
-	usleep_range(2 * timeout, 3 * timeout);
+	sleep_for_ei(rps, timeout);
 	GEM_BUG_ON(i915_request_completed(rq));
 
 	igt_spinner_end(spin);
@@ -122,16 +135,7 @@ static int __rps_down_interrupt(struct intel_rps *rps,
 	timeout = intel_uncore_read(uncore, GEN6_RP_DOWN_EI);
 	timeout = GT_PM_INTERVAL_TO_US(engine->i915, timeout);
 
-	/* Flush any previous EI */
-	usleep_range(timeout, 2 * timeout);
-
-	/* Reset the interrupt status */
-	rps_disable_interrupts(rps);
-	GEM_BUG_ON(rps->pm_iir);
-	rps_enable_interrupts(rps);
-
-	/* And then wait for the timeout, for real this time */
-	usleep_range(2 * timeout, 3 * timeout);
+	sleep_for_ei(rps, timeout);
 
 	if (rps->cur_freq != rps->max_freq) {
 		pr_err("%s: Frequency unexpectedly changed [down], now %d!\n",
-- 
2.28.0

