From 3985fb80d0d37810e55ef328c9c406d0e963c444 Mon Sep 17 00:00:00 2001
From: Nikolay Borisov <nborisov@suse.com>
Date: Wed, 10 Oct 2018 12:48:41 +0300
Subject: [PATCH 4/6] btrfs: Introduce 2 more members to struct
 btrfs_fs_devices
References: fate#325871
Patch-mainline: Submitted, awaiting review

In order to gracefully handle split-brain scenario which are very
unlikely, yet possible, while performing the FSID change I'm
gonna need two more pieces of information:

 1. The highest generation number among all devices registered to a
 particular btrfs_fs_devices

 2. A boolean flag whether a given btrfs_fs_devices was created by a
 device which had the FSID_CHANGING_V2 flag set.

This is a preparatory patch and just introduces the variables as well
as code which sets them, their actual use is going to happen in a later
patch.

Signed-off-by: Nikolay Borisov <nborisov@suse.com>
---
 fs/btrfs/volumes.c |    9 ++++++++-
 fs/btrfs/volumes.h |    4 ++++
 2 files changed, 12 insertions(+), 1 deletion(-)

--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -634,6 +634,8 @@ static noinline int device_list_add(cons
 	u64 found_transid = btrfs_super_generation(disk_super);
 	bool has_metadata_uuid = (btrfs_super_incompat_flags(disk_super) &
 		BTRFS_FEATURE_INCOMPAT_METADATA_UUID);
+	bool fsid_change_in_progress = (btrfs_super_flags(disk_super) &
+					BTRFS_SUPER_FLAG_CHANGING_FSID_V2);
 
 	if (has_metadata_uuid)
 		fs_devices = find_fsid(disk_super->fsid, disk_super->metadata_uuid);
@@ -650,6 +652,8 @@ static noinline int device_list_add(cons
 		if (IS_ERR(fs_devices))
 			return PTR_ERR(fs_devices);
 
+		fs_devices->fsid_change = fsid_change_in_progress;
+
 		list_add(&fs_devices->list, &fs_uuids);
 
 		device = NULL;
@@ -738,8 +742,11 @@ static noinline int device_list_add(cons
 	 * it back. We need it to pick the disk with largest generation
 	 * (as above).
 	 */
-	if (!fs_devices->opened)
+	if (!fs_devices->opened) {
 		device->generation = found_transid;
+		fs_devices->latest_generation = max(found_transid,
+						fs_devices->latest_generation);
+	}
 
 	/*
 	 * if there is new btrfs on an already registered device,
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -220,6 +220,7 @@ BTRFS_DEVICE_GETSET_FUNCS(bytes_used);
 struct btrfs_fs_devices {
 	u8 fsid[BTRFS_FSID_SIZE]; /* FS specific uuid */
 	u8 metadata_uuid[BTRFS_FSID_SIZE];
+	bool fsid_change;
 
 	u64 num_devices;
 	u64 open_devices;
@@ -229,6 +230,9 @@ struct btrfs_fs_devices {
 	u64 total_devices;
 	struct block_device *latest_bdev;
 
+	/* Highest generation number of seen devices */
+	u64 latest_generation;
+
 	/* all of the devices in the FS, protected by a mutex
 	 * so we can safely walk it to write out the supers without
 	 * worrying about add/remove by the multi-device code.
