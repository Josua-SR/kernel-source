From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Tue, 13 Feb 2018 14:00:43 +0200
Subject: drm: omapdrm: dispc: Pass DISPC pointer to remaining dispc API
 functions
Git-commit: 8a7eda7686675b73d74c22c0d5b83059f9d783f6
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

This removes the need to access the global DISPC private data in those
functions (both for the current accesses and the future ones that will
be introduced when allocating the DISPC private data dynamically).

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/omapdrm/dss/dispc.c |  102 +++++++++++++++++++-----------------
 drivers/gpu/drm/omapdrm/dss/dpi.c   |   12 ++--
 drivers/gpu/drm/omapdrm/dss/dsi.c   |   22 ++++---
 drivers/gpu/drm/omapdrm/dss/dss.c   |   14 ++--
 drivers/gpu/drm/omapdrm/dss/dss.h   |   74 ++++++++++++++------------
 drivers/gpu/drm/omapdrm/dss/hdmi4.c |    4 -
 drivers/gpu/drm/omapdrm/dss/hdmi5.c |    4 -
 drivers/gpu/drm/omapdrm/dss/sdi.c   |    9 +--
 drivers/gpu/drm/omapdrm/dss/venc.c  |    2 
 9 files changed, 133 insertions(+), 110 deletions(-)

--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -704,7 +704,7 @@ static u32 dispc_mgr_get_sync_lost_irq(s
 	return mgr_desc[channel].sync_lost_irq;
 }
 
-u32 dispc_wb_get_framedone_irq(void)
+u32 dispc_wb_get_framedone_irq(struct dispc_device *dispc)
 {
 	return DISPC_IRQ_FRAMEDONEWB;
 }
@@ -739,12 +739,12 @@ static void dispc_mgr_go(struct dispc_de
 	mgr_fld_write(channel, DISPC_MGR_FLD_GO, 1);
 }
 
-bool dispc_wb_go_busy(void)
+bool dispc_wb_go_busy(struct dispc_device *dispc)
 {
 	return REG_GET(DISPC_CONTROL2, 6, 6) == 1;
 }
 
-void dispc_wb_go(void)
+void dispc_wb_go(struct dispc_device *dispc)
 {
 	enum omap_plane_id plane = OMAP_DSS_WB;
 	bool enable, go;
@@ -1196,7 +1196,8 @@ static enum omap_channel dispc_ovl_get_c
 	}
 }
 
-void dispc_wb_set_channel_in(enum dss_writeback_channel channel)
+void dispc_wb_set_channel_in(struct dispc_device *dispc,
+			     enum dss_writeback_channel channel)
 {
 	enum omap_plane_id plane = OMAP_DSS_WB;
 
@@ -1371,10 +1372,10 @@ static void dispc_init_fifos(void)
 		const bool use_fifomerge = false;
 		const bool manual_update = false;
 
-		dispc_ovl_compute_fifo_thresholds(i, &low, &high,
+		dispc_ovl_compute_fifo_thresholds(&dispc, i, &low, &high,
 			use_fifomerge, manual_update);
 
-		dispc_ovl_set_fifo_threshold(i, low, high);
+		dispc_ovl_set_fifo_threshold(&dispc, i, low, high);
 	}
 
 	if (dispc.feat->has_writeback) {
@@ -1382,10 +1383,11 @@ static void dispc_init_fifos(void)
 		const bool use_fifomerge = false;
 		const bool manual_update = false;
 
-		dispc_ovl_compute_fifo_thresholds(OMAP_DSS_WB, &low, &high,
-			use_fifomerge, manual_update);
+		dispc_ovl_compute_fifo_thresholds(&dispc, OMAP_DSS_WB,
+						  &low, &high,
+						  use_fifomerge, manual_update);
 
-		dispc_ovl_set_fifo_threshold(OMAP_DSS_WB, low, high);
+		dispc_ovl_set_fifo_threshold(&dispc, OMAP_DSS_WB, low, high);
 	}
 }
 
@@ -1402,13 +1404,14 @@ static u32 dispc_ovl_get_fifo_size(enum
 	return size;
 }
 
-void dispc_ovl_set_fifo_threshold(enum omap_plane_id plane, u32 low,
-				  u32 high)
+void dispc_ovl_set_fifo_threshold(struct dispc_device *dispc,
+				  enum omap_plane_id plane,
+				  u32 low, u32 high)
 {
 	u8 hi_start, hi_end, lo_start, lo_end;
 	u32 unit;
 
-	unit = dispc.feat->buffer_size_unit;
+	unit = dispc->feat->buffer_size_unit;
 
 	WARN_ON(low % unit != 0);
 	WARN_ON(high % unit != 0);
@@ -1436,12 +1439,12 @@ void dispc_ovl_set_fifo_threshold(enum o
 	 * large for the preload field, set the threshold to the maximum value
 	 * that can be held by the preload register
 	 */
-	if (dispc_has_feature(FEAT_PRELOAD) && dispc.feat->set_max_preload &&
+	if (dispc_has_feature(FEAT_PRELOAD) && dispc->feat->set_max_preload &&
 			plane != OMAP_DSS_WB)
 		dispc_write_reg(DISPC_OVL_PRELOAD(plane), min(high, 0xfffu));
 }
 
-void dispc_enable_fifomerge(bool enable)
+void dispc_enable_fifomerge(struct dispc_device *dispc, bool enable)
 {
 	if (!dispc_has_feature(FEAT_FIFO_MERGE)) {
 		WARN_ON(enable);
@@ -1452,15 +1455,16 @@ void dispc_enable_fifomerge(bool enable)
 	REG_FLD_MOD(DISPC_CONFIG, enable ? 1 : 0, 14, 14);
 }
 
-void dispc_ovl_compute_fifo_thresholds(enum omap_plane_id plane,
-		u32 *fifo_low, u32 *fifo_high, bool use_fifomerge,
-		bool manual_update)
+void dispc_ovl_compute_fifo_thresholds(struct dispc_device *dispc,
+				       enum omap_plane_id plane,
+				       u32 *fifo_low, u32 *fifo_high,
+				       bool use_fifomerge, bool manual_update)
 {
 	/*
 	 * All sizes are in bytes. Both the buffer and burst are made of
 	 * buffer_units, and the fifo thresholds must be buffer_unit aligned.
 	 */
-	unsigned int buf_unit = dispc.feat->buffer_size_unit;
+	unsigned int buf_unit = dispc->feat->buffer_size_unit;
 	unsigned int ovl_fifo_size, total_fifo_size, burst_size;
 	int i;
 
@@ -1469,7 +1473,7 @@ void dispc_ovl_compute_fifo_thresholds(e
 
 	if (use_fifomerge) {
 		total_fifo_size = 0;
-		for (i = 0; i < dispc_get_num_ovls(&dispc); ++i)
+		for (i = 0; i < dispc_get_num_ovls(dispc); ++i)
 			total_fifo_size += dispc_ovl_get_fifo_size(i);
 	} else {
 		total_fifo_size = ovl_fifo_size;
@@ -2665,8 +2669,9 @@ static int dispc_ovl_setup(struct dispc_
 	return r;
 }
 
-int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
-		bool mem_to_mem, const struct videomode *vm)
+int dispc_wb_setup(struct dispc_device *dispc,
+		   const struct omap_dss_writeback_info *wi,
+		   bool mem_to_mem, const struct videomode *vm)
 {
 	int r;
 	u32 l;
@@ -2757,7 +2762,7 @@ static void dispc_lcd_enable_signal_pola
 	REG_FLD_MOD(DISPC_CONTROL, act_high ? 1 : 0, 29, 29);
 }
 
-void dispc_lcd_enable_signal(bool enable)
+void dispc_lcd_enable_signal(struct dispc_device *dispc, bool enable)
 {
 	if (!dispc_has_feature(FEAT_LCDENABLESIGNAL))
 		return;
@@ -2765,7 +2770,7 @@ void dispc_lcd_enable_signal(bool enable
 	REG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 28, 28);
 }
 
-void dispc_pck_free_enable(bool enable)
+void dispc_pck_free_enable(struct dispc_device *dispc, bool enable)
 {
 	if (!dispc_has_feature(FEAT_PCKFREEENABLE))
 		return;
@@ -2904,7 +2909,7 @@ static void dispc_mgr_set_lcd_config(str
 	dispc_mgr_enable_stallmode(channel, config->stallmode);
 	dispc_mgr_enable_fifohandcheck(channel, config->fifohandcheck);
 
-	dispc_mgr_set_clock_div(channel, &config->clock_info);
+	dispc_mgr_set_clock_div(dispc, channel, &config->clock_info);
 
 	dispc_mgr_set_tft_data_lines(channel, config->video_port_width);
 
@@ -2941,7 +2946,8 @@ static bool _dispc_mgr_pclk_ok(enum omap
 		return pclk <= dispc.feat->max_tv_pclk;
 }
 
-bool dispc_mgr_timings_ok(enum omap_channel channel, const struct videomode *vm)
+bool dispc_mgr_timings_ok(struct dispc_device *dispc, enum omap_channel channel,
+			  const struct videomode *vm)
 {
 	if (!_dispc_mgr_size_ok(vm->hactive, vm->vactive))
 		return false;
@@ -3062,7 +3068,7 @@ static void dispc_mgr_set_timings(struct
 
 	DSSDBG("channel %d xres %u yres %u\n", channel, t.hactive, t.vactive);
 
-	if (!dispc_mgr_timings_ok(channel, &t)) {
+	if (!dispc_mgr_timings_ok(dispc, channel, &t)) {
 		BUG();
 		return;
 	}
@@ -3195,9 +3201,9 @@ static unsigned long dispc_mgr_pclk_rate
 	}
 }
 
-void dispc_set_tv_pclk(unsigned long pclk)
+void dispc_set_tv_pclk(struct dispc_device *dispc, unsigned long pclk)
 {
-	dispc.tv_pclk_rate = pclk;
+	dispc->tv_pclk_rate = pclk;
 }
 
 static unsigned long dispc_core_clk_rate(void)
@@ -3249,17 +3255,18 @@ static void dispc_dump_clocks_channel(st
 		dispc_mgr_pclk_rate(channel), pcd);
 }
 
-void dispc_dump_clocks(struct seq_file *s)
+void dispc_dump_clocks(struct dispc_device *dispc, struct seq_file *s)
 {
+	enum dss_clk_source dispc_clk_src;
 	int lcd;
 	u32 l;
-	enum dss_clk_source dispc_clk_src = dss_get_dispc_clk_source(dispc.dss);
 
-	if (dispc_runtime_get(&dispc))
+	if (dispc_runtime_get(dispc))
 		return;
 
 	seq_printf(s, "- DISPC -\n");
 
+	dispc_clk_src = dss_get_dispc_clk_source(dispc->dss);
 	seq_printf(s, "dispc fclk source = %s\n",
 			dss_get_clk_source_name(dispc_clk_src));
 
@@ -3281,7 +3288,7 @@ void dispc_dump_clocks(struct seq_file *
 	if (dispc_has_feature(FEAT_MGR_LCD3))
 		dispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD3);
 
-	dispc_runtime_put(&dispc);
+	dispc_runtime_put(dispc);
 }
 
 static int dispc_dump_regs(struct seq_file *s, void *p)
@@ -3482,8 +3489,9 @@ static int dispc_dump_regs(struct seq_fi
 }
 
 /* calculate clock rates using dividers in cinfo */
-int dispc_calc_clock_rates(unsigned long dispc_fclk_rate,
-		struct dispc_clock_info *cinfo)
+int dispc_calc_clock_rates(struct dispc_device *dispc,
+			   unsigned long dispc_fclk_rate,
+			   struct dispc_clock_info *cinfo)
 {
 	if (cinfo->lck_div > 255 || cinfo->lck_div == 0)
 		return -EINVAL;
@@ -3496,9 +3504,9 @@ int dispc_calc_clock_rates(unsigned long
 	return 0;
 }
 
-bool dispc_div_calc(unsigned long dispc_freq,
-		unsigned long pck_min, unsigned long pck_max,
-		dispc_div_calc_func func, void *data)
+bool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,
+		    unsigned long pck_min, unsigned long pck_max,
+		    dispc_div_calc_func func, void *data)
 {
 	int lckd, lckd_start, lckd_stop;
 	int pckd, pckd_start, pckd_stop;
@@ -3514,10 +3522,10 @@ bool dispc_div_calc(unsigned long dispc_
 	min_fck_per_pck = 0;
 #endif
 
-	pckd_hw_min = dispc.feat->min_pcd;
+	pckd_hw_min = dispc->feat->min_pcd;
 	pckd_hw_max = 255;
 
-	lck_max = dss_get_max_fck_rate(dispc.dss);
+	lck_max = dss_get_max_fck_rate(dispc->dss);
 
 	pck_min = pck_min ? pck_min : 1;
 	pck_max = pck_max ? pck_max : ULONG_MAX;
@@ -3556,8 +3564,9 @@ bool dispc_div_calc(unsigned long dispc_
 	return false;
 }
 
-void dispc_mgr_set_clock_div(enum omap_channel channel,
-		const struct dispc_clock_info *cinfo)
+void dispc_mgr_set_clock_div(struct dispc_device *dispc,
+			     enum omap_channel channel,
+			     const struct dispc_clock_info *cinfo)
 {
 	DSSDBG("lck = %lu (%u)\n", cinfo->lck, cinfo->lck_div);
 	DSSDBG("pck = %lu (%u)\n", cinfo->pck, cinfo->pck_div);
@@ -3565,8 +3574,9 @@ void dispc_mgr_set_clock_div(enum omap_c
 	dispc_mgr_set_lcd_divisor(channel, cinfo->lck_div, cinfo->pck_div);
 }
 
-int dispc_mgr_get_clock_div(enum omap_channel channel,
-		struct dispc_clock_info *cinfo)
+int dispc_mgr_get_clock_div(struct dispc_device *dispc,
+			    enum omap_channel channel,
+			    struct dispc_clock_info *cinfo)
 {
 	unsigned long fck;
 
@@ -3604,12 +3614,12 @@ static void dispc_write_irqenable(struct
 	dispc_read_reg(DISPC_IRQENABLE);
 }
 
-void dispc_enable_sidle(void)
+void dispc_enable_sidle(struct dispc_device *dispc)
 {
 	REG_FLD_MOD(DISPC_SYSCONFIG, 2, 4, 3);	/* SIDLEMODE: smart idle */
 }
 
-void dispc_disable_sidle(void)
+void dispc_disable_sidle(struct dispc_device *dispc)
 {
 	REG_FLD_MOD(DISPC_SYSCONFIG, 1, 4, 3);	/* SIDLEMODE: no idle */
 }
@@ -4482,7 +4492,7 @@ static void dispc_errata_i734_wa(void)
 
 	/* Set up and enable display manager for LCD1 */
 	dispc_mgr_setup(&dispc, OMAP_DSS_CHANNEL_LCD, &i734.mgri);
-	dispc_calc_clock_rates(dss_get_dispc_clk_rate(dispc.dss),
+	dispc_calc_clock_rates(&dispc, dss_get_dispc_clk_rate(dispc.dss),
 			       &lcd_conf.clock_info);
 	dispc_mgr_set_lcd_config(&dispc, OMAP_DSS_CHANNEL_LCD, &lcd_conf);
 	dispc_mgr_set_timings(&dispc, OMAP_DSS_CHANNEL_LCD, &i734.vm);
--- a/drivers/gpu/drm/omapdrm/dss/dpi.c
+++ b/drivers/gpu/drm/omapdrm/dss/dpi.c
@@ -191,8 +191,9 @@ static bool dpi_calc_hsdiv_cb(int m_disp
 	ctx->pll_cinfo.mX[ctx->clkout_idx] = m_dispc;
 	ctx->pll_cinfo.clkout[ctx->clkout_idx] = dispc;
 
-	return dispc_div_calc(dispc, ctx->pck_min, ctx->pck_max,
-			dpi_calc_dispc_cb, ctx);
+	return dispc_div_calc(ctx->pll->dss->dispc, dispc,
+			      ctx->pck_min, ctx->pck_max,
+			      dpi_calc_dispc_cb, ctx);
 }
 
 
@@ -218,8 +219,9 @@ static bool dpi_calc_dss_cb(unsigned lon
 
 	ctx->fck = fck;
 
-	return dispc_div_calc(fck, ctx->pck_min, ctx->pck_max,
-			dpi_calc_dispc_cb, ctx);
+	return dispc_div_calc(ctx->pll->dss->dispc, fck,
+			      ctx->pck_min, ctx->pck_max,
+			      dpi_calc_dispc_cb, ctx);
 }
 
 static bool dpi_pll_clk_calc(struct dpi_data *dpi, unsigned long pck,
@@ -514,7 +516,7 @@ static int dpi_check_timings(struct omap
 	if (vm->hactive % 8 != 0)
 		return -EINVAL;
 
-	if (!dispc_mgr_timings_ok(channel, vm))
+	if (!dispc_mgr_timings_ok(dpi->dss->dispc, channel, vm))
 		return -EINVAL;
 
 	if (vm->pixelclock == 0)
--- a/drivers/gpu/drm/omapdrm/dss/dsi.c
+++ b/drivers/gpu/drm/omapdrm/dss/dsi.c
@@ -1394,18 +1394,18 @@ static int dsi_pll_enable(struct dss_pll
 	}
 
 	/* XXX PLL does not come out of reset without this... */
-	dispc_pck_free_enable(1);
+	dispc_pck_free_enable(dsi->dss->dispc, 1);
 
 	if (!wait_for_bit_change(dsi, DSI_PLL_STATUS, 0, 1)) {
 		DSSERR("PLL not coming out of reset.\n");
 		r = -ENODEV;
-		dispc_pck_free_enable(0);
+		dispc_pck_free_enable(dsi->dss->dispc, 0);
 		goto err1;
 	}
 
 	/* XXX ... but if left on, we get problems when planes do not
 	 * fill the whole display. No idea about this */
-	dispc_pck_free_enable(0);
+	dispc_pck_free_enable(dsi->dss->dispc, 0);
 
 	r = dsi_pll_power(dsi, DSI_PLL_POWER_ON_ALL);
 
@@ -3972,7 +3972,7 @@ static void dsi_update_screen_dispc(stru
 	 * the same goes for any DSS interrupts, but for some reason I have not
 	 * seen the problem anywhere else than here.
 	 */
-	dispc_disable_sidle();
+	dispc_disable_sidle(dsi->dss->dispc);
 
 	dsi_perf_mark_start(dsi);
 
@@ -4007,7 +4007,7 @@ static void dsi_te_timeout(unsigned long
 static void dsi_handle_framedone(struct dsi_data *dsi, int error)
 {
 	/* SIDLEMODE back to smart-idle */
-	dispc_enable_sidle();
+	dispc_enable_sidle(dsi->dss->dispc);
 
 	if (dsi->te_enabled) {
 		/* enable LP_RX_TO again after the TE */
@@ -4088,7 +4088,7 @@ static int dsi_configure_dispc_clocks(st
 	dispc_cinfo.lck_div = dsi->user_dispc_cinfo.lck_div;
 	dispc_cinfo.pck_div = dsi->user_dispc_cinfo.pck_div;
 
-	r = dispc_calc_clock_rates(fck, &dispc_cinfo);
+	r = dispc_calc_clock_rates(dsi->dss->dispc, fck, &dispc_cinfo);
 	if (r) {
 		DSSERR("Failed to calc dispc clocks\n");
 		return r;
@@ -4439,8 +4439,9 @@ static bool dsi_cm_calc_hsdiv_cb(int m_d
 	ctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;
 	ctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;
 
-	return dispc_div_calc(dispc, ctx->req_pck_min, ctx->req_pck_max,
-			dsi_cm_calc_dispc_cb, ctx);
+	return dispc_div_calc(ctx->dsi->dss->dispc, dispc,
+			      ctx->req_pck_min, ctx->req_pck_max,
+			      dsi_cm_calc_dispc_cb, ctx);
 }
 
 static bool dsi_cm_calc_pll_cb(int n, int m, unsigned long fint,
@@ -4739,8 +4740,9 @@ static bool dsi_vm_calc_hsdiv_cb(int m_d
 	else
 		pck_max = ctx->req_pck_max;
 
-	return dispc_div_calc(dispc, ctx->req_pck_min, pck_max,
-			dsi_vm_calc_dispc_cb, ctx);
+	return dispc_div_calc(ctx->dsi->dss->dispc, dispc,
+			      ctx->req_pck_min, pck_max,
+			      dsi_vm_calc_dispc_cb, ctx);
 }
 
 static bool dsi_vm_calc_pll_cb(int n, int m, unsigned long fint,
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -274,7 +274,7 @@ int dss_sdi_enable(struct dss_device *ds
 {
 	unsigned long timeout;
 
-	dispc_pck_free_enable(1);
+	dispc_pck_free_enable(dss->dispc, 1);
 
 	/* Reset SDI PLL */
 	REG_FLD_MOD(dss, DSS_PLL_CONTROL, 1, 18, 18); /* SDI_PLL_SYSRESET */
@@ -304,7 +304,7 @@ int dss_sdi_enable(struct dss_device *ds
 		}
 	}
 
-	dispc_lcd_enable_signal(1);
+	dispc_lcd_enable_signal(dss->dispc, 1);
 
 	/* Waiting for SDI reset to complete */
 	timeout = jiffies + msecs_to_jiffies(500);
@@ -318,21 +318,21 @@ int dss_sdi_enable(struct dss_device *ds
 	return 0;
 
  err2:
-	dispc_lcd_enable_signal(0);
+	dispc_lcd_enable_signal(dss->dispc, 0);
  err1:
 	/* Reset SDI PLL */
 	REG_FLD_MOD(dss, DSS_PLL_CONTROL, 0, 18, 18); /* SDI_PLL_SYSRESET */
 
-	dispc_pck_free_enable(0);
+	dispc_pck_free_enable(dss->dispc, 0);
 
 	return -ETIMEDOUT;
 }
 
 void dss_sdi_disable(struct dss_device *dss)
 {
-	dispc_lcd_enable_signal(0);
+	dispc_lcd_enable_signal(dss->dispc, 0);
 
-	dispc_pck_free_enable(0);
+	dispc_pck_free_enable(dss->dispc, 0);
 
 	/* Reset SDI PLL */
 	REG_FLD_MOD(dss, DSS_PLL_CONTROL, 0, 18, 18); /* SDI_PLL_SYSRESET */
@@ -894,7 +894,7 @@ static int dss_debug_dump_clocks(struct
 	struct dss_device *dss = s->private;
 
 	dss_dump_clocks(dss, s);
-	dispc_dump_clocks(s);
+	dispc_dump_clocks(dss->dispc, s);
 #ifdef CONFIG_OMAP2_DSS_DSI
 	dsi_dump_clocks(s);
 #endif
--- a/drivers/gpu/drm/omapdrm/dss/dss.h
+++ b/drivers/gpu/drm/omapdrm/dss/dss.h
@@ -407,47 +407,55 @@ static inline void dpi_uninit_port(struc
 #endif
 
 /* DISPC */
-void dispc_dump_clocks(struct seq_file *s);
+void dispc_dump_clocks(struct dispc_device *dispc, struct seq_file *s);
 
 int dispc_runtime_get(struct dispc_device *dispc);
 void dispc_runtime_put(struct dispc_device *dispc);
 
-void dispc_enable_sidle(void);
-void dispc_disable_sidle(void);
+void dispc_enable_sidle(struct dispc_device *dispc);
+void dispc_disable_sidle(struct dispc_device *dispc);
 
-void dispc_lcd_enable_signal(bool enable);
-void dispc_pck_free_enable(bool enable);
-void dispc_enable_fifomerge(bool enable);
+void dispc_lcd_enable_signal(struct dispc_device *dispc, bool enable);
+void dispc_pck_free_enable(struct dispc_device *dispc, bool enable);
+void dispc_enable_fifomerge(struct dispc_device *dispc, bool enable);
 
 typedef bool (*dispc_div_calc_func)(int lckd, int pckd, unsigned long lck,
 		unsigned long pck, void *data);
-bool dispc_div_calc(unsigned long dispc,
-		unsigned long pck_min, unsigned long pck_max,
-		dispc_div_calc_func func, void *data);
-
-bool dispc_mgr_timings_ok(enum omap_channel channel, const struct videomode *vm);
-int dispc_calc_clock_rates(unsigned long dispc_fclk_rate,
-		struct dispc_clock_info *cinfo);
-
-
-void dispc_ovl_set_fifo_threshold(enum omap_plane_id plane, u32 low,
-				  u32 high);
-void dispc_ovl_compute_fifo_thresholds(enum omap_plane_id plane,
-		u32 *fifo_low, u32 *fifo_high, bool use_fifomerge,
-		bool manual_update);
-
-void dispc_mgr_set_clock_div(enum omap_channel channel,
-		const struct dispc_clock_info *cinfo);
-int dispc_mgr_get_clock_div(enum omap_channel channel,
-		struct dispc_clock_info *cinfo);
-void dispc_set_tv_pclk(unsigned long pclk);
-
-u32 dispc_wb_get_framedone_irq(void);
-bool dispc_wb_go_busy(void);
-void dispc_wb_go(void);
-void dispc_wb_set_channel_in(enum dss_writeback_channel channel);
-int dispc_wb_setup(const struct omap_dss_writeback_info *wi,
-		bool mem_to_mem, const struct videomode *vm);
+bool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,
+		    unsigned long pck_min, unsigned long pck_max,
+		    dispc_div_calc_func func, void *data);
+
+bool dispc_mgr_timings_ok(struct dispc_device *dispc,
+			  enum omap_channel channel,
+			  const struct videomode *vm);
+int dispc_calc_clock_rates(struct dispc_device *dispc,
+			   unsigned long dispc_fclk_rate,
+			   struct dispc_clock_info *cinfo);
+
+
+void dispc_ovl_set_fifo_threshold(struct dispc_device *dispc,
+				  enum omap_plane_id plane, u32 low, u32 high);
+void dispc_ovl_compute_fifo_thresholds(struct dispc_device *dispc,
+				       enum omap_plane_id plane,
+				       u32 *fifo_low, u32 *fifo_high,
+				       bool use_fifomerge, bool manual_update);
+
+void dispc_mgr_set_clock_div(struct dispc_device *dispc,
+			     enum omap_channel channel,
+			     const struct dispc_clock_info *cinfo);
+int dispc_mgr_get_clock_div(struct dispc_device *dispc,
+			    enum omap_channel channel,
+			    struct dispc_clock_info *cinfo);
+void dispc_set_tv_pclk(struct dispc_device *dispc, unsigned long pclk);
+
+u32 dispc_wb_get_framedone_irq(struct dispc_device *dispc);
+bool dispc_wb_go_busy(struct dispc_device *dispc);
+void dispc_wb_go(struct dispc_device *dispc);
+void dispc_wb_set_channel_in(struct dispc_device *dispc,
+			     enum dss_writeback_channel channel);
+int dispc_wb_setup(struct dispc_device *dispc,
+		   const struct omap_dss_writeback_info *wi,
+		   bool mem_to_mem, const struct videomode *vm);
 
 #ifdef CONFIG_OMAP2_DSS_COLLECT_IRQ_STATS
 static inline void dss_collect_irq_stats(u32 irqstatus, unsigned int *irq_arr)
--- a/drivers/gpu/drm/omapdrm/dss/hdmi4.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi4.c
@@ -276,7 +276,7 @@ static void hdmi_power_off_full(struct o
 static int hdmi_display_check_timing(struct omap_dss_device *dssdev,
 				     struct videomode *vm)
 {
-	if (!dispc_mgr_timings_ok(dssdev->dispc_channel, vm))
+	if (!dispc_mgr_timings_ok(hdmi.dss->dispc, dssdev->dispc_channel, vm))
 		return -EINVAL;
 
 	return 0;
@@ -289,7 +289,7 @@ static void hdmi_display_set_timing(stru
 
 	hdmi.cfg.vm = *vm;
 
-	dispc_set_tv_pclk(vm->pixelclock);
+	dispc_set_tv_pclk(hdmi.dss->dispc, vm->pixelclock);
 
 	mutex_unlock(&hdmi.lock);
 }
--- a/drivers/gpu/drm/omapdrm/dss/hdmi5.c
+++ b/drivers/gpu/drm/omapdrm/dss/hdmi5.c
@@ -272,7 +272,7 @@ static void hdmi_power_off_full(struct o
 static int hdmi_display_check_timing(struct omap_dss_device *dssdev,
 				     struct videomode *vm)
 {
-	if (!dispc_mgr_timings_ok(dssdev->dispc_channel, vm))
+	if (!dispc_mgr_timings_ok(hdmi.dss->dispc, dssdev->dispc_channel, vm))
 		return -EINVAL;
 
 	return 0;
@@ -285,7 +285,7 @@ static void hdmi_display_set_timing(stru
 
 	hdmi.cfg.vm = *vm;
 
-	dispc_set_tv_pclk(vm->pixelclock);
+	dispc_set_tv_pclk(hdmi.dss->dispc, vm->pixelclock);
 
 	mutex_unlock(&hdmi.lock);
 }
--- a/drivers/gpu/drm/omapdrm/dss/sdi.c
+++ b/drivers/gpu/drm/omapdrm/dss/sdi.c
@@ -71,8 +71,9 @@ static bool dpi_calc_dss_cb(unsigned lon
 
 	ctx->fck = fck;
 
-	return dispc_div_calc(fck, ctx->pck_min, ctx->pck_max,
-			dpi_calc_dispc_cb, ctx);
+	return dispc_div_calc(sdi.dss->dispc, fck,
+			      ctx->pck_min, ctx->pck_max,
+			      dpi_calc_dispc_cb, ctx);
 }
 
 static int sdi_calc_clock_div(unsigned long pclk,
@@ -183,7 +184,7 @@ static int sdi_display_enable(struct oma
 	 * need to care about the shadow register mechanism for pck-free. The
 	 * exact reason for this is unknown.
 	 */
-	dispc_mgr_set_clock_div(sdi.output.dispc_channel,
+	dispc_mgr_set_clock_div(sdi.dss->dispc, sdi.output.dispc_channel,
 				&sdi.mgr_config.clock_info);
 
 	dss_sdi_init(sdi.dss, sdi.datapairs);
@@ -238,7 +239,7 @@ static int sdi_check_timings(struct omap
 {
 	enum omap_channel channel = dssdev->dispc_channel;
 
-	if (!dispc_mgr_timings_ok(channel, vm))
+	if (!dispc_mgr_timings_ok(sdi.dss->dispc, channel, vm))
 		return -EINVAL;
 
 	if (vm->pixelclock == 0)
--- a/drivers/gpu/drm/omapdrm/dss/venc.c
+++ b/drivers/gpu/drm/omapdrm/dss/venc.c
@@ -586,7 +586,7 @@ static void venc_set_timings(struct omap
 
 	venc.vm = actual_vm;
 
-	dispc_set_tv_pclk(13500000);
+	dispc_set_tv_pclk(venc.dss->dispc, 13500000);
 
 	mutex_unlock(&venc.venc_lock);
 }
