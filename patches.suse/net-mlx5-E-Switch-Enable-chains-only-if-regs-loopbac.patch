From: Paul Blakey <paulb@mellanox.com>
Date: Wed, 18 Mar 2020 11:43:06 +0200
Subject: net/mlx5: E-Switch, Enable chains only if regs loopback is enabled
Patch-mainline: v5.7-rc1
Git-commit: 7983a675ba65c5f8dae7532dcd91a40adc237da8
References: jsc#SLE-15172

Register c0 loopback is needed to fully support chains and prios.

Enable chains and prio only if loopback (of reg c1 which came together
with c0), is enabled. To be able to check that, move enabling of loopback
before eswitch chains init.

Signed-off-by: Paul Blakey <paulb@mellanox.com>
Reviewed-by: Roi Dayan <roid@mellanox.com>
Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c        |   11 +--
 drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.c |   35 +++++-----
 2 files changed, 26 insertions(+), 20 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@ -2350,14 +2350,15 @@ int esw_offloads_enable(struct mlx5_eswi
 
 	mutex_init(&esw->offloads.termtbl_mutex);
 	mlx5_rdma_enable_roce(esw->dev);
-	err = esw_offloads_steering_init(esw);
-	if (err)
-		goto err_steering_init;
 
 	err = esw_set_passing_vport_metadata(esw, true);
 	if (err)
 		goto err_vport_metadata;
 
+	err = esw_offloads_steering_init(esw);
+	if (err)
+		goto err_steering_init;
+
 	/* Representor will control the vport link state */
 	mlx5_esw_for_each_vf_vport(esw, i, vport, esw->esw_funcs.num_vfs)
 		vport->info.link_state = MLX5_VPORT_ADMIN_STATE_DOWN;
@@ -2379,9 +2380,9 @@ err_vports:
 	esw_offloads_unload_rep(esw, MLX5_VPORT_UPLINK);
 err_uplink:
 	esw_set_passing_vport_metadata(esw, false);
-err_vport_metadata:
-	esw_offloads_steering_cleanup(esw);
 err_steering_init:
+	esw_offloads_steering_cleanup(esw);
+err_vport_metadata:
 	mlx5_rdma_disable_roce(esw->dev);
 	mutex_destroy(&esw->offloads.termtbl_mutex);
 	return err;
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.c
@@ -280,7 +280,8 @@ create_fdb_chain_restore(struct fdb_chai
 	u32 index;
 	int err;
 
-	if (fdb_chain->chain == mlx5_esw_chains_get_ft_chain(esw))
+	if (fdb_chain->chain == mlx5_esw_chains_get_ft_chain(esw) ||
+	    !mlx5_esw_chains_prios_supported(esw))
 		return 0;
 
 	err = mapping_add(esw_chains_mapping(esw), &fdb_chain->chain, &index);
@@ -335,6 +336,18 @@ err_mod_hdr:
 	return err;
 }
 
+static void destroy_fdb_chain_restore(struct fdb_chain *fdb_chain)
+{
+	struct mlx5_eswitch *esw = fdb_chain->esw;
+
+	if (!fdb_chain->miss_modify_hdr)
+		return;
+
+	mlx5_del_flow_rules(fdb_chain->restore_rule);
+	mlx5_modify_header_dealloc(esw->dev, fdb_chain->miss_modify_hdr);
+	mapping_remove(esw_chains_mapping(esw), fdb_chain->id);
+}
+
 static struct fdb_chain *
 mlx5_esw_chains_create_fdb_chain(struct mlx5_eswitch *esw, u32 chain)
 {
@@ -361,11 +374,7 @@ mlx5_esw_chains_create_fdb_chain(struct
 	return fdb_chain;
 
 err_insert:
-	if (fdb_chain->chain != mlx5_esw_chains_get_ft_chain(esw)) {
-		mlx5_del_flow_rules(fdb_chain->restore_rule);
-		mlx5_modify_header_dealloc(esw->dev,
-					   fdb_chain->miss_modify_hdr);
-	}
+	destroy_fdb_chain_restore(fdb_chain);
 err_restore:
 	kvfree(fdb_chain);
 	return ERR_PTR(err);
@@ -379,14 +388,7 @@ mlx5_esw_chains_destroy_fdb_chain(struct
 	rhashtable_remove_fast(&esw_chains_ht(esw), &fdb_chain->node,
 			       chain_params);
 
-	if (fdb_chain->chain != mlx5_esw_chains_get_ft_chain(esw)) {
-		mlx5_del_flow_rules(fdb_chain->restore_rule);
-		mlx5_modify_header_dealloc(esw->dev,
-					   fdb_chain->miss_modify_hdr);
-
-		mapping_remove(esw_chains_mapping(esw), fdb_chain->id);
-	}
-
+	destroy_fdb_chain_restore(fdb_chain);
 	kvfree(fdb_chain);
 }
 
@@ -423,7 +425,7 @@ mlx5_esw_chains_add_miss_rule(struct fdb
 	dest.ft = next_fdb;
 
 	if (next_fdb == tc_end_fdb(esw) &&
-	    fdb_modify_header_fwd_to_table_supported(esw)) {
+	    mlx5_esw_chains_prios_supported(esw)) {
 		act.modify_hdr = fdb_chain->miss_modify_hdr;
 		act.action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
 	}
@@ -783,6 +785,9 @@ mlx5_esw_chains_init(struct mlx5_eswitch
 	    esw->offloads.encap != DEVLINK_ESWITCH_ENCAP_MODE_NONE) {
 		esw->fdb_table.flags &= ~ESW_FDB_CHAINS_AND_PRIOS_SUPPORTED;
 		esw_warn(dev, "Tc chains and priorities offload aren't supported, update firmware if needed\n");
+	} else if (!mlx5_eswitch_reg_c1_loopback_enabled(esw)) {
+		esw->fdb_table.flags &= ~ESW_FDB_CHAINS_AND_PRIOS_SUPPORTED;
+		esw_warn(dev, "Tc chains and priorities offload aren't supported\n");
 	} else if (!fdb_modify_header_fwd_to_table_supported(esw)) {
 		/* Disabled when ttl workaround is needed, e.g
 		 * when ESWITCH_IPV4_TTL_MODIFY_ENABLE = true in mlxconfig
