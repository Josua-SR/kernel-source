From: Carl Heymann <carl.heymann@netronome.com>
Date: Thu, 14 Dec 2017 10:50:26 +0100
Subject: nfp: fix XPB register reads in debug dump
Patch-mainline: v4.16-rc1
Git-commit: 28b2d7d04b00150e2f06fa4ba9a99b9d2eb379bf
References: bsc#1109837

For XPB registers reads, some island IDs require special handling (e.g.
ARM island), which is already taken care of in nfp_xpb_readl(), so use
that instead of a straight CPP read.

Without this fix all "xpbm:ArmIsldXpbmMap.*" registers are reported as
0xffffffff. It has also been observed to cause a system reboot.

With this fix correct values are reported, none of which are 0xffffffff.

The values may be read using ethtool debug level 2.
 # ethtool -W <netdev> 2
 # ethtool -w <netdev> data dump.dat

Fixes: 0e6c4955e149 ("nfp: dump CPP, XPB and direct ME CSRs")
Signed-off-by: Carl Heymann <carl.heymann@netronome.com>
Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
Signed-off-by: Simon Horman <simon.horman@netronome.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/netronome/nfp/nfp_net_debugdump.c |   15 +++++++++++++--
 1 file changed, 13 insertions(+), 2 deletions(-)

--- a/drivers/net/ethernet/netronome/nfp/nfp_net_debugdump.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_debugdump.c
@@ -38,6 +38,7 @@
 #include "nfp_main.h"
 #include "nfpcore/nfp.h"
 #include "nfpcore/nfp_nffw.h"
+#include "nfpcore/nfp6000/nfp6000.h"
 
 #define NFP_DUMP_SPEC_RTSYM	"_abi_dump_spec"
 
@@ -478,6 +479,12 @@ static int nfp_dump_hwinfo_field(struct
 	return 0;
 }
 
+static bool is_xpb_read(struct nfp_dumpspec_cpp_isl_id *cpp_id)
+{
+	return cpp_id->target == NFP_CPP_TARGET_ISLAND_XPB &&
+	       cpp_id->action == 0 && cpp_id->token == 0;
+}
+
 static int
 nfp_dump_csr_range(struct nfp_pf *pf, struct nfp_dumpspec_csr *spec_csr,
 		   struct nfp_dump_state *dump)
@@ -511,8 +518,12 @@ nfp_dump_csr_range(struct nfp_pf *pf, st
 	max_rd_addr = cpp_rd_addr + be32_to_cpu(spec_csr->cpp.dump_length);
 
 	while (cpp_rd_addr < max_rd_addr) {
-		bytes_read = nfp_cpp_read(pf->cpp, cpp_id, cpp_rd_addr, dest,
-					  reg_sz);
+		if (is_xpb_read(&spec_csr->cpp.cpp_id))
+			bytes_read = nfp_xpb_readl(pf->cpp, cpp_rd_addr,
+						   (u32 *)dest);
+		else
+			bytes_read = nfp_cpp_read(pf->cpp, cpp_id, cpp_rd_addr,
+						  dest, reg_sz);
 		if (bytes_read != reg_sz) {
 			if (bytes_read >= 0)
 				bytes_read = -EIO;
