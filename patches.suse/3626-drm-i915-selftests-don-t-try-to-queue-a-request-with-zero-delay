From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 24 Oct 2017 23:08:54 +0100
Subject: drm/i915/selftests: Don't try to queue a request with zero delay
Git-commit: b1f9107e1b251b2cbd413062fad3636570d2ea20
Patch-mainline: v4.16-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Instead of trying to create a timer with zero delay (i.e. with expires
set to the current jiffies and not the future, an already expired
timer), execute that request immediately.

v2: Refactor list_del_init+signal into its own little function.
v3: Reorder testing so as not to immediately signal a delayed request.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Link: https://patchwork.freedesktop.org/patch/msgid/20171024220855.30155-1-chris@chris-wilson.co.uk
Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/i915/selftests/mock_engine.c |   37 ++++++++++++++++++++-------
 1 file changed, 28 insertions(+), 9 deletions(-)

--- a/drivers/gpu/drm/i915/selftests/mock_engine.c
+++ b/drivers/gpu/drm/i915/selftests/mock_engine.c
@@ -32,6 +32,13 @@ static struct mock_request *first_reques
 					link);
 }
 
+static void advance(struct mock_engine *engine,
+		    struct mock_request *request)
+{
+	list_del_init(&request->link);
+	mock_seqno_advance(&engine->base, request->base.global_seqno);
+}
+
 static void hw_delay_complete(struct timer_list *t)
 {
 	struct mock_engine *engine = from_timer(engine, t, hw_delay);
@@ -39,15 +46,23 @@ static void hw_delay_complete(struct tim
 
 	spin_lock(&engine->hw_lock);
 
-	request = first_request(engine);
-	if (request) {
-		list_del_init(&request->link);
-		mock_seqno_advance(&engine->base, request->base.global_seqno);
-	}
-
+	/* Timer fired, first request is complete */
 	request = first_request(engine);
 	if (request)
-		mod_timer(&engine->hw_delay, jiffies + request->delay);
+		advance(engine, request);
+
+	/*
+	 * Also immediately signal any subsequent 0-delay requests, but
+	 * requeue the timer for the next delayed request.
+	 */
+	while ((request = first_request(engine))) {
+		if (request->delay) {
+			mod_timer(&engine->hw_delay, jiffies + request->delay);
+			break;
+		}
+
+		advance(engine, request);
+	}
 
 	spin_unlock(&engine->hw_lock);
 }
@@ -98,8 +113,12 @@ static void mock_submit_request(struct d
 
 	spin_lock_irq(&engine->hw_lock);
 	list_add_tail(&mock->link, &engine->hw_queue);
-	if (mock->link.prev == &engine->hw_queue)
-		mod_timer(&engine->hw_delay, jiffies + mock->delay);
+	if (mock->link.prev == &engine->hw_queue) {
+		if (mock->delay)
+			mod_timer(&engine->hw_delay, jiffies + mock->delay);
+		else
+			advance(engine, mock);
+	}
 	spin_unlock_irq(&engine->hw_lock);
 }
 
