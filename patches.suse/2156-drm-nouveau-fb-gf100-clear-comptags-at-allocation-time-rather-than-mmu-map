From: Ben Skeggs <bskeggs@redhat.com>
Date: Wed, 1 Nov 2017 03:56:19 +1000
Subject: drm/nouveau/fb/gf100: clear comptags at allocation time rather than
 mmu map
Git-commit: b1e839f3b3d82a0774c296f9950214057b045b72
Patch-mainline: v4.15-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

We probably don't want to destroy compression data when doing multiple
mappings of a memory object.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/nouveau/include/nvkm/subdev/ltc.h |    2 +-
 drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c |    6 +++++-
 drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c    |    3 ++-
 drivers/gpu/drm/nouveau/nvkm/subdev/mmu/gf100.c   |    3 ---
 4 files changed, 8 insertions(+), 6 deletions(-)

--- a/drivers/gpu/drm/nouveau/include/nvkm/subdev/ltc.h
+++ b/drivers/gpu/drm/nouveau/include/nvkm/subdev/ltc.h
@@ -25,7 +25,7 @@ struct nvkm_ltc {
 
 int nvkm_ltc_tags_alloc(struct nvkm_ltc *, u32 count, struct nvkm_mm_node **);
 void nvkm_ltc_tags_free(struct nvkm_ltc *, struct nvkm_mm_node **);
-void nvkm_ltc_tags_clear(struct nvkm_ltc *, u32 first, u32 count);
+void nvkm_ltc_tags_clear(struct nvkm_device *, u32 first, u32 count);
 
 int nvkm_ltc_zbc_color_get(struct nvkm_ltc *, int index, const u32[4]);
 int nvkm_ltc_zbc_depth_get(struct nvkm_ltc *, int index, const u32);
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c
@@ -443,6 +443,7 @@ int
 gf100_ram_get(struct nvkm_ram *ram, u64 size, u32 align, u32 ncmin,
 	      u32 memtype, struct nvkm_mem **pmem)
 {
+	struct nvkm_device *device = ram->fb->subdev.device;
 	struct nvkm_ltc *ltc = ram->fb->subdev.device->ltc;
 	struct nvkm_mm *mm = &ram->vram;
 	struct nvkm_mm_node **node, *r;
@@ -469,7 +470,10 @@ gf100_ram_get(struct nvkm_ram *ram, u64
 		/* compression only works with lpages */
 		if (align == (1 << (17 - NVKM_RAM_MM_SHIFT))) {
 			int n = size >> 5;
-			nvkm_ltc_tags_alloc(ltc, n, &mem->tag);
+			if (!nvkm_ltc_tags_alloc(ltc, n, &mem->tag)) {
+				nvkm_ltc_tags_clear(device, mem->tag->offset,
+							    mem->tag->length);
+			}
 		}
 
 		if (unlikely(!mem->tag))
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
@@ -41,8 +41,9 @@ nvkm_ltc_tags_free(struct nvkm_ltc *ltc,
 }
 
 void
-nvkm_ltc_tags_clear(struct nvkm_ltc *ltc, u32 first, u32 count)
+nvkm_ltc_tags_clear(struct nvkm_device *device, u32 first, u32 count)
 {
+	struct nvkm_ltc *ltc = device->ltc;
 	const u32 limit = first + count - 1;
 
 	BUG_ON((first > limit) || (limit >= ltc->num_tags));
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/gf100.c
@@ -24,7 +24,6 @@
 #include "priv.h"
 
 #include <subdev/fb.h>
-#include <subdev/ltc.h>
 #include <subdev/timer.h>
 
 #include <core/gpuobj.h>
@@ -109,11 +108,9 @@ gf100_vm_map(struct nvkm_vma *vma, struc
 	pte <<= 3;
 
 	if (mem->tag) {
-		struct nvkm_ltc *ltc = vma->vm->mmu->subdev.device->ltc;
 		u32 tag = mem->tag->offset + (delta >> 17);
 		phys |= (u64)tag << (32 + 12);
 		next |= (u64)1   << (32 + 12);
-		nvkm_ltc_tags_clear(ltc, tag, cnt);
 	}
 
 	nvkm_kmap(pgt);
