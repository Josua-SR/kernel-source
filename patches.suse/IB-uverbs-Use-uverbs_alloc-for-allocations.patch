From: Jason Gunthorpe <jgg@mellanox.com>
Date: Thu, 9 Aug 2018 20:14:41 -0600
Subject: IB/uverbs: Use uverbs_alloc for allocations
Patch-mainline: v4.19-rc1
Git-commit: b61815e241652096b61f59ca2063edecb23602a2
References: bsc#1103992 FATE#326009

Several handlers need temporary allocations for the life of the method,
switch them to use the uverbs_alloc allocator.

Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/infiniband/core/uverbs_std_types_counters.c |   20 +---
 drivers/infiniband/hw/mlx5/devx.c                   |   83 +++++++-------------
 2 files changed, 38 insertions(+), 65 deletions(-)

--- a/drivers/infiniband/core/uverbs_std_types_counters.c
+++ b/drivers/infiniband/core/uverbs_std_types_counters.c
@@ -104,22 +104,18 @@ static int UVERBS_HANDLER(UVERBS_METHOD_
 
 	uattr = uverbs_attr_get(attrs, UVERBS_ATTR_READ_COUNTERS_BUFF);
 	read_attr.ncounters = uattr->ptr_attr.len / sizeof(u64);
-	read_attr.counters_buff = kcalloc(read_attr.ncounters,
-					  sizeof(u64), GFP_KERNEL);
-	if (!read_attr.counters_buff)
-		return -ENOMEM;
+	read_attr.counters_buff = uverbs_zalloc(
+		attrs, array_size(read_attr.ncounters, sizeof(u64)));
+	if (IS_ERR(read_attr.counters_buff))
+		return PTR_ERR(read_attr.counters_buff);
 
 	ret = counters->device->read_counters(counters, &read_attr, attrs);
 	if (ret)
-		goto err_read;
+		return ret;
 
-	ret = uverbs_copy_to(attrs, UVERBS_ATTR_READ_COUNTERS_BUFF,
-			     read_attr.counters_buff,
-			     read_attr.ncounters * sizeof(u64));
-
-err_read:
-	kfree(read_attr.counters_buff);
-	return ret;
+	return uverbs_copy_to(attrs, UVERBS_ATTR_READ_COUNTERS_BUFF,
+			      read_attr.counters_buff,
+			      read_attr.ncounters * sizeof(u64));
 }
 
 DECLARE_UVERBS_NAMED_METHOD(
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@ -511,22 +511,19 @@ static int UVERBS_HANDLER(MLX5_IB_METHOD
 	if (!devx_is_general_cmd(cmd_in))
 		return -EINVAL;
 
-	cmd_out = kvzalloc(cmd_out_len, GFP_KERNEL);
-	if (!cmd_out)
-		return -ENOMEM;
+	cmd_out = uverbs_zalloc(attrs, cmd_out_len);
+	if (IS_ERR(cmd_out))
+		return PTR_ERR(cmd_out);
 
 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, c->devx_uid);
 	err = mlx5_cmd_exec(dev->mdev, cmd_in,
 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OTHER_CMD_IN),
 			    cmd_out, cmd_out_len);
 	if (err)
-		goto other_cmd_free;
-
-	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OTHER_CMD_OUT, cmd_out, cmd_out_len);
+		return err;
 
-other_cmd_free:
-	kvfree(cmd_out);
-	return err;
+	return uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OTHER_CMD_OUT, cmd_out,
+			      cmd_out_len);
 }
 
 static void devx_obj_build_destroy_cmd(void *in, void *out, void *din,
@@ -735,22 +732,20 @@ static int UVERBS_HANDLER(MLX5_IB_METHOD
 	if (!devx_is_obj_create_cmd(cmd_in))
 		return -EINVAL;
 
+	cmd_out = uverbs_zalloc(attrs, cmd_out_len);
+	if (IS_ERR(cmd_out))
+		return PTR_ERR(cmd_out);
+
 	obj = kzalloc(sizeof(struct devx_obj), GFP_KERNEL);
 	if (!obj)
 		return -ENOMEM;
 
-	cmd_out = kvzalloc(cmd_out_len, GFP_KERNEL);
-	if (!cmd_out) {
-		err = -ENOMEM;
-		goto obj_free;
-	}
-
 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, c->devx_uid);
 	err = mlx5_cmd_exec(dev->mdev, cmd_in,
 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_IN),
 			    cmd_out, cmd_out_len);
 	if (err)
-		goto cmd_free;
+		goto obj_free;
 
 	uobj->object = obj;
 	obj->mdev = dev->mdev;
@@ -759,13 +754,10 @@ static int UVERBS_HANDLER(MLX5_IB_METHOD
 
 	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_OUT, cmd_out, cmd_out_len);
 	if (err)
-		goto cmd_free;
+		goto obj_free;
 
-	kvfree(cmd_out);
 	return 0;
 
-cmd_free:
-	kvfree(cmd_out);
 obj_free:
 	kfree(obj);
 	return err;
@@ -793,23 +785,19 @@ static int UVERBS_HANDLER(MLX5_IB_METHOD
 	if (!devx_is_valid_obj_id(obj, cmd_in))
 		return -EINVAL;
 
-	cmd_out = kvzalloc(cmd_out_len, GFP_KERNEL);
-	if (!cmd_out)
-		return -ENOMEM;
+	cmd_out = uverbs_zalloc(attrs, cmd_out_len);
+	if (IS_ERR(cmd_out))
+		return PTR_ERR(cmd_out);
 
 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, c->devx_uid);
 	err = mlx5_cmd_exec(obj->mdev, cmd_in,
 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_IN),
 			    cmd_out, cmd_out_len);
 	if (err)
-		goto other_cmd_free;
-
-	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT,
-			     cmd_out, cmd_out_len);
+		return err;
 
-other_cmd_free:
-	kvfree(cmd_out);
-	return err;
+	return uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_MODIFY_CMD_OUT,
+			      cmd_out, cmd_out_len);
 }
 
 static int UVERBS_HANDLER(MLX5_IB_METHOD_DEVX_OBJ_QUERY)(
@@ -834,22 +822,19 @@ static int UVERBS_HANDLER(MLX5_IB_METHOD
 	if (!devx_is_valid_obj_id(obj, cmd_in))
 		return -EINVAL;
 
-	cmd_out = kvzalloc(cmd_out_len, GFP_KERNEL);
-	if (!cmd_out)
-		return -ENOMEM;
+	cmd_out = uverbs_zalloc(attrs, cmd_out_len);
+	if (IS_ERR(cmd_out))
+		return PTR_ERR(cmd_out);
 
 	MLX5_SET(general_obj_in_cmd_hdr, cmd_in, uid, c->devx_uid);
 	err = mlx5_cmd_exec(obj->mdev, cmd_in,
 			    uverbs_attr_get_len(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_IN),
 			    cmd_out, cmd_out_len);
 	if (err)
-		goto other_cmd_free;
-
-	err = uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT, cmd_out, cmd_out_len);
+		return err;
 
-other_cmd_free:
-	kvfree(cmd_out);
-	return err;
+	return uverbs_copy_to(attrs, MLX5_IB_ATTR_DEVX_OBJ_QUERY_CMD_OUT,
+			      cmd_out, cmd_out_len);
 }
 
 static int devx_umem_get(struct mlx5_ib_dev *dev, struct ib_ucontext *ucontext,
@@ -896,18 +881,14 @@ static int devx_umem_get(struct mlx5_ib_
 	return 0;
 }
 
-static int devx_umem_reg_cmd_alloc(struct devx_umem *obj,
+static int devx_umem_reg_cmd_alloc(struct uverbs_attr_bundle *attrs,
+				   struct devx_umem *obj,
 				   struct devx_umem_reg_cmd *cmd)
 {
 	cmd->inlen = MLX5_ST_SZ_BYTES(create_umem_in) +
 		    (MLX5_ST_SZ_BYTES(mtt) * obj->ncont);
-	cmd->in = kvzalloc(cmd->inlen, GFP_KERNEL);
-	return cmd->in ? 0 : -ENOMEM;
-}
-
-static void devx_umem_reg_cmd_free(struct devx_umem_reg_cmd *cmd)
-{
-	kvfree(cmd->in);
+	cmd->in = uverbs_zalloc(attrs, cmd->inlen);
+	return PTR_ERR_OR_ZERO(cmd->in);
 }
 
 static void devx_umem_reg_cmd_build(struct mlx5_ib_dev *dev,
@@ -954,7 +935,7 @@ static int UVERBS_HANDLER(MLX5_IB_METHOD
 	if (err)
 		goto err_obj_free;
 
-	err = devx_umem_reg_cmd_alloc(obj, &cmd);
+	err = devx_umem_reg_cmd_alloc(attrs, obj, &cmd);
 	if (err)
 		goto err_umem_release;
 
@@ -964,7 +945,7 @@ static int UVERBS_HANDLER(MLX5_IB_METHOD
 	err = mlx5_cmd_exec(dev->mdev, cmd.in, cmd.inlen, cmd.out,
 			    sizeof(cmd.out));
 	if (err)
-		goto err_umem_reg_cmd_free;
+		goto err_umem_release;
 
 	obj->mdev = dev->mdev;
 	uobj->object = obj;
@@ -973,14 +954,10 @@ static int UVERBS_HANDLER(MLX5_IB_METHOD
 	if (err)
 		goto err_umem_destroy;
 
-	devx_umem_reg_cmd_free(&cmd);
-
 	return 0;
 
 err_umem_destroy:
 	mlx5_cmd_exec(obj->mdev, obj->dinbox, obj->dinlen, cmd.out, sizeof(cmd.out));
-err_umem_reg_cmd_free:
-	devx_umem_reg_cmd_free(&cmd);
 err_umem_release:
 	ib_umem_release(obj->umem);
 err_obj_free:
