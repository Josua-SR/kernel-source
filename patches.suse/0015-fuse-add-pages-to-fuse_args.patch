From: Miklos Szeredi <mszeredi@redhat.com>
Date: Tue, 10 Sep 2019 15:04:09 +0200
Subject: fuse: add pages to fuse_args
Git-commit: 68583165f962793a6fe7d11f54713045f43fc8bb
Patch-mainline: v5.4-rc1
References: jsc#SLE-13782

Derive fuse_args_pages from fuse_args. This is used to handle requests
which use pages for input or output.  The related flags are added to
fuse_args.

New FR_ALLOC_PAGES flags is added to indicate whether the page arrays in
fuse_req need to be freed by fuse_put_request() or not.

Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Acked-by: Luis Henriques <lhenriques@suse.com>
---
 fs/fuse/dev.c    | 41 +++++++++++++++++++++++++++++++----------
 fs/fuse/fuse_i.h | 12 ++++++++++++
 2 files changed, 43 insertions(+), 10 deletions(-)

diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c
index 9f1549166a5d..3ef85c957122 100644
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@ -81,6 +81,7 @@ static struct fuse_req *__fuse_request_alloc(unsigned npages, gfp_t flags)
 				kmem_cache_free(fuse_req_cachep, req);
 				return NULL;
 			}
+			__set_bit(FR_ALLOC_PAGES, &req->flags);
 		} else if (npages) {
 			pages = req->inline_pages;
 			page_descs = req->inline_page_descs;
@@ -104,7 +105,7 @@ struct fuse_req *fuse_request_alloc_nofs(unsigned npages)
 
 static void fuse_req_pages_free(struct fuse_req *req)
 {
-	if (req->pages != req->inline_pages)
+	if (test_bit(FR_ALLOC_PAGES, &req->flags))
 		kfree(req->pages);
 }
 
@@ -127,6 +128,7 @@ bool fuse_req_realloc_pages(struct fuse_conn *fc, struct fuse_req *req,
 	memcpy(page_descs, req->page_descs,
 	       sizeof(struct fuse_page_desc) * req->max_pages);
 	fuse_req_pages_free(req);
+	__set_bit(FR_ALLOC_PAGES, &req->flags);
 	req->pages = pages;
 	req->page_descs = page_descs;
 	req->max_pages = npages;
@@ -544,6 +546,33 @@ static void fuse_force_creds(struct fuse_conn *fc, struct fuse_req *req)
 	req->in.h.pid = pid_nr_ns(task_pid(current), fc->pid_ns);
 }
 
+void fuse_args_to_req(struct fuse_req *req, struct fuse_args *args)
+{
+	struct fuse_args_pages *ap = container_of(args, typeof(*ap), args);
+
+	req->in.h.opcode = args->opcode;
+	req->in.h.nodeid = args->nodeid;
+	req->in.numargs = args->in_numargs;
+	memcpy(req->in.args, args->in_args,
+	       args->in_numargs * sizeof(struct fuse_in_arg));
+	req->out.argvar = args->out_argvar;
+	req->out.numargs = args->out_numargs;
+	memcpy(req->out.args, args->out_args,
+	       args->out_numargs * sizeof(struct fuse_arg));
+
+	if (args->in_pages || args->out_pages) {
+		req->in.argpages = args->in_pages;
+		req->out.argpages = args->out_pages;
+		req->out.page_zeroing = args->page_zeroing;
+		req->out.page_replace = args->page_replace;
+
+		req->pages = ap->pages;
+		req->page_descs = ap->descs;
+		req->num_pages = ap->num_pages;
+	}
+
+}
+
 ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)
 {
 	struct fuse_req *req;
@@ -567,16 +596,8 @@ ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)
 
 	/* Needs to be done after fuse_get_req() so that fc->minor is valid */
 	fuse_adjust_compat(fc, args);
+	fuse_args_to_req(req, args);
 
-	req->in.h.opcode = args->opcode;
-	req->in.h.nodeid = args->nodeid;
-	req->in.numargs = args->in_numargs;
-	memcpy(req->in.args, args->in_args,
-	       args->in_numargs * sizeof(struct fuse_in_arg));
-	req->out.argvar = args->out_argvar;
-	req->out.numargs = args->out_numargs;
-	memcpy(req->out.args, args->out_args,
-	       args->out_numargs * sizeof(struct fuse_arg));
 	if (!args->noreply)
 		__set_bit(FR_ISREPLY, &req->flags);
 	__fuse_request_send(fc, req);
diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index 73f70f3872e7..1998d6ab4025 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -294,11 +294,22 @@ struct fuse_args {
 	bool force:1;
 	bool noreply:1;
 	bool nocreds:1;
+	bool in_pages:1;
+	bool out_pages:1;
 	bool out_argvar:1;
+	bool page_zeroing:1;
+	bool page_replace:1;
 	struct fuse_in_arg in_args[3];
 	struct fuse_arg out_args[2];
 };
 
+struct fuse_args_pages {
+	struct fuse_args args;
+	struct page **pages;
+	struct fuse_page_desc *descs;
+	unsigned int num_pages;
+};
+
 #define FUSE_ARGS(args) struct fuse_args args = {}
 
 /** The request IO state (for asynchronous processing) */
@@ -352,6 +363,7 @@ enum fuse_req_flag {
 	FR_SENT,
 	FR_FINISHED,
 	FR_PRIVATE,
+	FR_ALLOC_PAGES,
 };
 
 /**

