From: Jason Wang <jasowang@redhat.com>
Date: Fri, 8 Dec 2017 12:02:30 +0800
Subject: tuntap: fix possible deadlock when fail to register netdev
Patch-mainline: v4.16-rc1
Git-commit: 124da8f6118bce3d9aeb5c6f5395ed131141aad5
References: bsc#1109837

Private destructor could be called when register_netdev() fail with
rtnl lock held. This will lead deadlock in tun_free_netdev() who tries
to hold rtnl_lock. Fixing this by switching to use spinlock to
synchronize.

Fixes: 96f84061620c ("tun: add eBPF based queue selection method")
Reported-by: Eric Dumazet <eric.dumazet@gmail.com>
Cc: Eric Dumazet <eric.dumazet@gmail.com>
Cc: Willem de Bruijn <willemb@google.com>
Signed-off-by: Jason Wang <jasowang@redhat.com>
Acked-by: Michael S. Tsirkin <mst@redhat.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/tun.c |    7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -2055,8 +2055,11 @@ static int __tun_set_steering_ebpf(struc
 		new->prog = prog;
 	}
 
-	old = rtnl_dereference(tun->steering_prog);
+	spin_lock_bh(&tun->lock);
+	old = rcu_dereference_protected(tun->steering_prog,
+					lockdep_is_held(&tun->lock));
 	rcu_assign_pointer(tun->steering_prog, new);
+	spin_unlock_bh(&tun->lock);
 
 	if (old)
 		call_rcu(&old->rcu, tun_steering_prog_free);
@@ -2072,9 +2075,7 @@ static void tun_free_netdev(struct net_d
 	free_percpu(tun->pcpu_stats);
 	tun_flow_uninit(tun);
 	security_tun_dev_free_security(tun->security);
-	rtnl_lock();
 	__tun_set_steering_ebpf(tun, NULL);
-	rtnl_unlock();
 }
 
 static void tun_setup(struct net_device *dev)
