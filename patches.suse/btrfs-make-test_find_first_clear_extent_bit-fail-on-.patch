From: Filipe Manana <fdmanana@suse.com>
Date: Mon, 5 Aug 2019 10:57:41 +0100
Patch-mainline: v5.4-rc1
Git-commit: 202f64ef427cce8478d9cfc1a96970db066b1ece
References: bsc#1158210
Subject: [PATCH] Btrfs: make test_find_first_clear_extent_bit fail on
 incorrect results

If any call to find_first_clear_extent_bit() returns an unexpected result,
the test should fail and not just print an error message, otherwise it
makes detection of regressions much harder to notice.

Fixes: 1eaebb341d2b41 ("btrfs: Don't trim returned range based on input value in find_first_clear_extent_bit")
Reviewed-by: Nikolay Borisov <nborisov@suse.com>
Signed-off-by: Filipe Manana <fdmanana@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
---
 fs/btrfs/tests/extent-io-tests.c | 29 ++++++++++++++++++++++-------
 1 file changed, 22 insertions(+), 7 deletions(-)

diff --git a/fs/btrfs/tests/extent-io-tests.c b/fs/btrfs/tests/extent-io-tests.c
index 705a8a7eb815..123d9a614357 100644
--- a/fs/btrfs/tests/extent-io-tests.c
+++ b/fs/btrfs/tests/extent-io-tests.c
@@ -438,6 +438,7 @@ static int test_find_first_clear_extent_bit(void)
 {
 	struct extent_io_tree tree;
 	u64 start, end;
+	int ret = -EINVAL;
 
 	test_msg("running find_first_clear_extent_bit test");
 	extent_io_tree_init(NULL, &tree, IO_TREE_SELFTEST, NULL);
@@ -452,9 +453,11 @@ static int test_find_first_clear_extent_bit(void)
 	find_first_clear_extent_bit(&tree, SZ_512K, &start, &end,
 				    CHUNK_TRIMMED | CHUNK_ALLOCATED);
 
-	if (start != 0 || end != SZ_1M -1)
+	if (start != 0 || end != SZ_1M - 1) {
 		test_err("error finding beginning range: start %llu end %llu",
 			 start, end);
+		goto out;
+	}
 
 	/* Now add 32M-64M so that we have a hole between 4M-32M */
 	set_extent_bits(&tree, SZ_32M, SZ_64M - 1,
@@ -466,9 +469,11 @@ static int test_find_first_clear_extent_bit(void)
 	find_first_clear_extent_bit(&tree, 12 * SZ_1M, &start, &end,
 				    CHUNK_TRIMMED | CHUNK_ALLOCATED);
 
-	if (start != SZ_4M || end != SZ_32M - 1)
+	if (start != SZ_4M || end != SZ_32M - 1) {
 		test_err("error finding trimmed range: start %llu end %llu",
 			 start, end);
+		goto out;
+	}
 
 	/*
 	 * Search in the middle of allocated range, should get the next one
@@ -477,9 +482,11 @@ static int test_find_first_clear_extent_bit(void)
 	find_first_clear_extent_bit(&tree, SZ_2M, &start, &end,
 				    CHUNK_TRIMMED | CHUNK_ALLOCATED);
 
-	if (start != SZ_4M || end != SZ_32M -1)
+	if (start != SZ_4M || end != SZ_32M - 1) {
 		test_err("error finding next unalloc range: start %llu end %llu",
 			 start, end);
+		goto out;
+	}
 
 	/*
 	 * Set 64M-72M with CHUNK_ALLOC flag, then search for CHUNK_TRIMMED flag
@@ -489,9 +496,11 @@ static int test_find_first_clear_extent_bit(void)
 	find_first_clear_extent_bit(&tree, SZ_64M + SZ_1M, &start, &end,
 				    CHUNK_TRIMMED);
 
-	if (start != SZ_64M || end != SZ_64M + SZ_8M - 1)
+	if (start != SZ_64M || end != SZ_64M + SZ_8M - 1) {
 		test_err("error finding exact range: start %llu end %llu",
 			 start, end);
+		goto out;
+	}
 
 	find_first_clear_extent_bit(&tree, SZ_64M - SZ_8M, &start, &end,
 				    CHUNK_TRIMMED);
@@ -500,23 +509,29 @@ static int test_find_first_clear_extent_bit(void)
 	 * Search in the middle of set range whose immediate neighbour doesn't
 	 * have the bits set so it must be returned
 	 */
-	if (start != SZ_64M || end != SZ_64M + SZ_8M - 1)
+	if (start != SZ_64M || end != SZ_64M + SZ_8M - 1) {
 		test_err("error finding next alloc range: start %llu end %llu",
 			 start, end);
+		goto out;
+	}
 
 	/*
 	 * Search beyond any known range, shall return after last known range
 	 * and end should be -1
 	 */
 	find_first_clear_extent_bit(&tree, -1, &start, &end, CHUNK_TRIMMED);
-	if (start != SZ_64M + SZ_8M || end != -1)
+	if (start != SZ_64M + SZ_8M || end != -1) {
 		test_err(
 		"error handling beyond end of range search: start %llu end %llu",
 			start, end);
+		goto out;
+	}
 
+	ret = 0;
+out:
 	clear_extent_bits(&tree, 0, (u64)-1, CHUNK_TRIMMED | CHUNK_ALLOCATED);
 
-	return 0;
+	return ret;
 }
 
 int btrfs_test_extent_io(u32 sectorsize, u32 nodesize)
-- 
2.16.4

