From: Thomas Hellstrom <thellstrom@vmware.com>
Date: Thu, 22 Mar 2018 10:30:19 +0100
Subject: drm/vmwgfx: Get rid of the device-private suspended member
Git-commit: 4e3e733b45df457147441b79cf2cb654c82ec402
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

It was used to early block fbdev dirty processing. Replace it with an
unprotected check of the par->dirty.active field. While this might
race with the vmw_fb_off() function, we do a protected check later so
the race will at worst lead to grabbing and releasing a couple of locks.

Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
Reviewed-by: Brian Paul <brianp@vmware.com>
Reviewed-by: Sinclair Yeh <syeh@vmware.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/vmwgfx/vmwgfx_drv.c |    3 ---
 drivers/gpu/drm/vmwgfx/vmwgfx_drv.h |    1 -
 drivers/gpu/drm/vmwgfx/vmwgfx_fb.c  |    2 +-
 3 files changed, 1 insertion(+), 5 deletions(-)

--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c
@@ -1462,7 +1462,6 @@ static int vmw_pm_freeze(struct device *
 		DRM_ERROR("Failed to freeze modesetting.\n");
 		return ret;
 	}
-	dev_priv->suspended = true;
 	if (dev_priv->enable_fb)
 		vmw_fb_off(dev_priv);
 
@@ -1484,7 +1483,6 @@ static int vmw_pm_freeze(struct device *
 			vmw_kms_resume(dev);
 		if (dev_priv->enable_fb)
 			vmw_fb_on(dev_priv);
-		dev_priv->suspended = false;
 		vmw_fb_refresh(dev_priv);
 		return -EBUSY;
 	}
@@ -1525,7 +1523,6 @@ static int vmw_pm_restore(struct device
 	if (dev_priv->enable_fb)
 		vmw_fb_on(dev_priv);
 
-	dev_priv->suspended = false;
 	vmw_fb_refresh(dev_priv);
 
 	return 0;
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h
@@ -497,7 +497,6 @@ struct vmw_private {
 	struct vmw_master *active_master;
 	struct vmw_master fbdev_master;
 	struct notifier_block pm_nb;
-	bool suspended;
 	bool refuse_hibernation;
 	bool suspend_locked;
 
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c
@@ -187,7 +187,7 @@ static void vmw_fb_dirty_flush(struct wo
 	struct vmw_dma_buffer *vbo = par->vmw_bo;
 	void *virtual;
 
-	if (vmw_priv->suspended)
+	if (!READ_ONCE(par->dirty.active))
 		return;
 
 	mutex_lock(&par->bo_mutex);
