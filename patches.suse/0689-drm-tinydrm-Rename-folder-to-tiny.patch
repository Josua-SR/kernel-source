From 043386a0f094e0ae8bda6f824461debe9b708db5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Noralf=20Tr=C3=B8nnes?= <noralf@tronnes.org>
Date: Thu, 25 Jul 2019 12:51:31 +0200
Subject: drm/tinydrm: Rename folder to tiny
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 043386a0f094e0ae8bda6f824461debe9b708db5
Patch-mainline: v5.4-rc1
References: bsc#1152472

The drm in tinydrm is superfluous so rename to tiny.

Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Acked-by: Sam Ravnborg <sam@ravnborg.org>
Reviewed-by: Hans de Goede <hdegoede@redhat.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20190725105132.22545-3-noralf@tronnes.org
Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
---
 MAINTAINERS                        |   12 
 drivers/gpu/drm/Kconfig            |    2 
 drivers/gpu/drm/Makefile           |    2 
 drivers/gpu/drm/tiny/Kconfig       |   89 ++
 drivers/gpu/drm/tiny/Makefile      |    9 
 drivers/gpu/drm/tiny/hx8357d.c     |  304 +++++++++
 drivers/gpu/drm/tiny/ili9225.c     |  470 ++++++++++++++
 drivers/gpu/drm/tiny/ili9341.c     |  268 ++++++++
 drivers/gpu/drm/tiny/mi0283qt.c    |  294 ++++++++
 drivers/gpu/drm/tiny/repaper.c     | 1212 +++++++++++++++++++++++++++++++++++++
 drivers/gpu/drm/tiny/st7586.c      |  424 ++++++++++++
 drivers/gpu/drm/tiny/st7735r.c     |  246 +++++++
 drivers/gpu/drm/tinydrm/Kconfig    |   89 --
 drivers/gpu/drm/tinydrm/Makefile   |    9 
 drivers/gpu/drm/tinydrm/hx8357d.c  |  304 ---------
 drivers/gpu/drm/tinydrm/ili9225.c  |  470 --------------
 drivers/gpu/drm/tinydrm/ili9341.c  |  268 --------
 drivers/gpu/drm/tinydrm/mi0283qt.c |  294 --------
 drivers/gpu/drm/tinydrm/repaper.c  | 1212 -------------------------------------
 drivers/gpu/drm/tinydrm/st7586.c   |  424 ------------
 drivers/gpu/drm/tinydrm/st7735r.c  |  246 -------
 21 files changed, 3324 insertions(+), 3324 deletions(-)
 create mode 100644 drivers/gpu/drm/tiny/Kconfig
 create mode 100644 drivers/gpu/drm/tiny/Makefile
 create mode 100644 drivers/gpu/drm/tiny/hx8357d.c
 create mode 100644 drivers/gpu/drm/tiny/ili9225.c
 create mode 100644 drivers/gpu/drm/tiny/ili9341.c
 create mode 100644 drivers/gpu/drm/tiny/mi0283qt.c
 create mode 100644 drivers/gpu/drm/tiny/repaper.c
 create mode 100644 drivers/gpu/drm/tiny/st7586.c
 create mode 100644 drivers/gpu/drm/tiny/st7735r.c
 delete mode 100644 drivers/gpu/drm/tinydrm/Kconfig
 delete mode 100644 drivers/gpu/drm/tinydrm/Makefile
 delete mode 100644 drivers/gpu/drm/tinydrm/hx8357d.c
 delete mode 100644 drivers/gpu/drm/tinydrm/ili9225.c
 delete mode 100644 drivers/gpu/drm/tinydrm/ili9341.c
 delete mode 100644 drivers/gpu/drm/tinydrm/mi0283qt.c
 delete mode 100644 drivers/gpu/drm/tinydrm/repaper.c
 delete mode 100644 drivers/gpu/drm/tinydrm/st7586.c
 delete mode 100644 drivers/gpu/drm/tinydrm/st7735r.c

--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -5114,14 +5114,14 @@ F:	drivers/gpu/drm/gm12u320/
 DRM DRIVER FOR ILITEK ILI9225 PANELS
 M:	David Lechner <david@lechnology.com>
 S:	Maintained
-F:	drivers/gpu/drm/tinydrm/ili9225.c
+F:	drivers/gpu/drm/tiny/ili9225.c
 F:	Documentation/devicetree/bindings/display/ilitek,ili9225.txt
 
 DRM DRIVER FOR HX8357D PANELS
 M:	Eric Anholt <eric@anholt.net>
 T:	git git://anongit.freedesktop.org/drm/drm-misc
 S:	Maintained
-F:	drivers/gpu/drm/tinydrm/hx8357d.c
+F:	drivers/gpu/drm/tiny/hx8357d.c
 F:	Documentation/devicetree/bindings/display/himax,hx8357d.txt
 
 DRM DRIVER FOR INTEL I810 VIDEO CARDS
@@ -5142,7 +5142,7 @@ F:	drivers/gpu/drm/mgag200/
 DRM DRIVER FOR MI0283QT
 M:	Noralf Trønnes <noralf@tronnes.org>
 S:	Maintained
-F:	drivers/gpu/drm/tinydrm/mi0283qt.c
+F:	drivers/gpu/drm/tiny/mi0283qt.c
 F:	Documentation/devicetree/bindings/display/multi-inno,mi0283qt.txt
 
 DRM DRIVER FOR MSM ADRENO GPU
@@ -5175,7 +5175,7 @@ F:	Documentation/devicetree/bindings/dis
 DRM DRIVER FOR PERVASIVE DISPLAYS REPAPER PANELS
 M:	Noralf Trønnes <noralf@tronnes.org>
 S:	Maintained
-F:	drivers/gpu/drm/tinydrm/repaper.c
+F:	drivers/gpu/drm/tiny/repaper.c
 F:	Documentation/devicetree/bindings/display/repaper.txt
 
 DRM DRIVER FOR QEMU'S CIRRUS DEVICE
@@ -5233,13 +5233,13 @@ F:	Documentation/devicetree/bindings/dis
 DRM DRIVER FOR SITRONIX ST7586 PANELS
 M:	David Lechner <david@lechnology.com>
 S:	Maintained
-F:	drivers/gpu/drm/tinydrm/st7586.c
+F:	drivers/gpu/drm/tiny/st7586.c
 F:	Documentation/devicetree/bindings/display/sitronix,st7586.txt
 
 DRM DRIVER FOR SITRONIX ST7735R PANELS
 M:	David Lechner <david@lechnology.com>
 S:	Maintained
-F:	drivers/gpu/drm/tinydrm/st7735r.c
+F:	drivers/gpu/drm/tiny/st7735r.c
 F:	Documentation/devicetree/bindings/display/sitronix,st7735r.txt
 
 DRM DRIVER FOR ST-ERICSSON MCDE
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -340,7 +340,7 @@ source "drivers/gpu/drm/mxsfb/Kconfig"
 
 source "drivers/gpu/drm/meson/Kconfig"
 
-source "drivers/gpu/drm/tinydrm/Kconfig"
+source "drivers/gpu/drm/tiny/Kconfig"
 
 source "drivers/gpu/drm/pl111/Kconfig"
 
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -112,7 +112,7 @@ obj-$(CONFIG_DRM_ARCPGU)+= arc/
 obj-y			+= hisilicon/
 obj-$(CONFIG_DRM_ZTE)	+= zte/
 obj-$(CONFIG_DRM_MXSFB)	+= mxsfb/
-obj-y			+= tinydrm/
+obj-y			+= tiny/
 obj-$(CONFIG_DRM_PL111) += pl111/
 obj-$(CONFIG_DRM_TVE200) += tve200/
 obj-$(CONFIG_DRM_XEN) += xen/
--- /dev/null
+++ b/drivers/gpu/drm/tiny/Kconfig
@@ -0,0 +1,89 @@
+# SPDX-License-Identifier: GPL-2.0-only
+config TINYDRM_HX8357D
+	tristate "DRM support for HX8357D display panels"
+	depends on DRM && SPI
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_MIPI_DBI
+	select BACKLIGHT_CLASS_DEVICE
+	help
+	  DRM driver for the following HX8357D panels:
+	  * YX350HV15-T 3.5" 340x350 TFT (Adafruit 3.5")
+
+	  If M is selected the module will be called hx8357d.
+
+config TINYDRM_ILI9225
+	tristate "DRM support for ILI9225 display panels"
+	depends on DRM && SPI
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_MIPI_DBI
+	help
+	  DRM driver for the following Ilitek ILI9225 panels:
+	  * No-name 2.2" color screen module
+
+	  If M is selected the module will be called ili9225.
+
+config TINYDRM_ILI9341
+	tristate "DRM support for ILI9341 display panels"
+	depends on DRM && SPI
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_MIPI_DBI
+	select BACKLIGHT_CLASS_DEVICE
+	help
+	  DRM driver for the following Ilitek ILI9341 panels:
+	  * YX240QV29-T 2.4" 240x320 TFT (Adafruit 2.4")
+
+	  If M is selected the module will be called ili9341.
+
+config TINYDRM_MI0283QT
+	tristate "DRM support for MI0283QT"
+	depends on DRM && SPI
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_MIPI_DBI
+	select BACKLIGHT_CLASS_DEVICE
+	help
+	  DRM driver for the Multi-Inno MI0283QT display panel
+	  If M is selected the module will be called mi0283qt.
+
+config TINYDRM_REPAPER
+	tristate "DRM support for Pervasive Displays RePaper panels (V231)"
+	depends on DRM && SPI
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	depends on THERMAL || !THERMAL
+	help
+	  DRM driver for the following Pervasive Displays panels:
+	  1.44" TFT EPD Panel (E1144CS021)
+	  1.90" TFT EPD Panel (E1190CS021)
+	  2.00" TFT EPD Panel (E2200CS021)
+	  2.71" TFT EPD Panel (E2271CS021)
+
+	  If M is selected the module will be called repaper.
+
+config TINYDRM_ST7586
+	tristate "DRM support for Sitronix ST7586 display panels"
+	depends on DRM && SPI
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_MIPI_DBI
+	help
+	  DRM driver for the following Sitronix ST7586 panels:
+	  * LEGO MINDSTORMS EV3
+
+	  If M is selected the module will be called st7586.
+
+config TINYDRM_ST7735R
+	tristate "DRM support for Sitronix ST7735R display panels"
+	depends on DRM && SPI
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_MIPI_DBI
+	select BACKLIGHT_CLASS_DEVICE
+	help
+	  DRM driver Sitronix ST7735R with one of the following LCDs:
+	  * JD-T18003-T01 1.8" 128x160 TFT
+
+	  If M is selected the module will be called st7735r.
--- /dev/null
+++ b/drivers/gpu/drm/tiny/Makefile
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+obj-$(CONFIG_TINYDRM_HX8357D)		+= hx8357d.o
+obj-$(CONFIG_TINYDRM_ILI9225)		+= ili9225.o
+obj-$(CONFIG_TINYDRM_ILI9341)		+= ili9341.o
+obj-$(CONFIG_TINYDRM_MI0283QT)		+= mi0283qt.o
+obj-$(CONFIG_TINYDRM_REPAPER)		+= repaper.o
+obj-$(CONFIG_TINYDRM_ST7586)		+= st7586.o
+obj-$(CONFIG_TINYDRM_ST7735R)		+= st7735r.o
--- /dev/null
+++ b/drivers/gpu/drm/tiny/hx8357d.c
@@ -0,0 +1,304 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * DRM driver for the HX8357D LCD controller
+ *
+ * Copyright 2018 Broadcom
+ * Copyright 2018 David Lechner <david@lechnology.com>
+ * Copyright 2016 Noralf Trønnes
+ * Copyright (C) 2015 Adafruit Industries
+ * Copyright (C) 2013 Christian Vogelgsang
+ */
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/property.h>
+#include <linux/spi/spi.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_mipi_dbi.h>
+#include <drm/drm_modeset_helper.h>
+#include <video/mipi_display.h>
+
+#define HX8357D_SETOSC 0xb0
+#define HX8357D_SETPOWER 0xb1
+#define HX8357D_SETRGB 0xb3
+#define HX8357D_SETCYC 0xb3
+#define HX8357D_SETCOM 0xb6
+#define HX8357D_SETEXTC 0xb9
+#define HX8357D_SETSTBA 0xc0
+#define HX8357D_SETPANEL 0xcc
+#define HX8357D_SETGAMMA 0xe0
+
+#define HX8357D_MADCTL_MY  0x80
+#define HX8357D_MADCTL_MX  0x40
+#define HX8357D_MADCTL_MV  0x20
+#define HX8357D_MADCTL_ML  0x10
+#define HX8357D_MADCTL_RGB 0x00
+#define HX8357D_MADCTL_BGR 0x08
+#define HX8357D_MADCTL_MH  0x04
+
+static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
+			     struct drm_crtc_state *crtc_state,
+			     struct drm_plane_state *plane_state)
+{
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
+	struct mipi_dbi *dbi = &dbidev->dbi;
+	u8 addr_mode;
+	int ret, idx;
+
+	if (!drm_dev_enter(pipe->crtc.dev, &idx))
+		return;
+
+	DRM_DEBUG_KMS("\n");
+
+	ret = mipi_dbi_poweron_conditional_reset(dbidev);
+	if (ret < 0)
+		goto out_exit;
+	if (ret == 1)
+		goto out_enable;
+
+	/* setextc */
+	mipi_dbi_command(dbi, HX8357D_SETEXTC, 0xFF, 0x83, 0x57);
+	msleep(150);
+
+	/* setRGB which also enables SDO */
+	mipi_dbi_command(dbi, HX8357D_SETRGB, 0x00, 0x00, 0x06, 0x06);
+
+	/* -1.52V */
+	mipi_dbi_command(dbi, HX8357D_SETCOM, 0x25);
+
+	/* Normal mode 70Hz, Idle mode 55 Hz */
+	mipi_dbi_command(dbi, HX8357D_SETOSC, 0x68);
+
+	/* Set Panel - BGR, Gate direction swapped */
+	mipi_dbi_command(dbi, HX8357D_SETPANEL, 0x05);
+
+	mipi_dbi_command(dbi, HX8357D_SETPOWER,
+			 0x00,  /* Not deep standby */
+			 0x15,  /* BT */
+			 0x1C,  /* VSPR */
+			 0x1C,  /* VSNR */
+			 0x83,  /* AP */
+			 0xAA);  /* FS */
+
+	mipi_dbi_command(dbi, HX8357D_SETSTBA,
+			 0x50,  /* OPON normal */
+			 0x50,  /* OPON idle */
+			 0x01,  /* STBA */
+			 0x3C,  /* STBA */
+			 0x1E,  /* STBA */
+			 0x08);  /* GEN */
+
+	mipi_dbi_command(dbi, HX8357D_SETCYC,
+			 0x02,  /* NW 0x02 */
+			 0x40,  /* RTN */
+			 0x00,  /* DIV */
+			 0x2A,  /* DUM */
+			 0x2A,  /* DUM */
+			 0x0D,  /* GDON */
+			 0x78);  /* GDOFF */
+
+	mipi_dbi_command(dbi, HX8357D_SETGAMMA,
+			 0x02,
+			 0x0A,
+			 0x11,
+			 0x1d,
+			 0x23,
+			 0x35,
+			 0x41,
+			 0x4b,
+			 0x4b,
+			 0x42,
+			 0x3A,
+			 0x27,
+			 0x1B,
+			 0x08,
+			 0x09,
+			 0x03,
+			 0x02,
+			 0x0A,
+			 0x11,
+			 0x1d,
+			 0x23,
+			 0x35,
+			 0x41,
+			 0x4b,
+			 0x4b,
+			 0x42,
+			 0x3A,
+			 0x27,
+			 0x1B,
+			 0x08,
+			 0x09,
+			 0x03,
+			 0x00,
+			 0x01);
+
+	/* 16 bit */
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT,
+			 MIPI_DCS_PIXEL_FMT_16BIT);
+
+	/* TE off */
+	mipi_dbi_command(dbi, MIPI_DCS_SET_TEAR_ON, 0x00);
+
+	/* tear line */
+	mipi_dbi_command(dbi, MIPI_DCS_SET_TEAR_SCANLINE, 0x00, 0x02);
+
+	/* Exit Sleep */
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(150);
+
+	/* display on */
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
+	usleep_range(5000, 7000);
+
+out_enable:
+	switch (dbidev->rotation) {
+	default:
+		addr_mode = HX8357D_MADCTL_MX | HX8357D_MADCTL_MY;
+		break;
+	case 90:
+		addr_mode = HX8357D_MADCTL_MV | HX8357D_MADCTL_MY;
+		break;
+	case 180:
+		addr_mode = 0;
+		break;
+	case 270:
+		addr_mode = HX8357D_MADCTL_MV | HX8357D_MADCTL_MX;
+		break;
+	}
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
+out_exit:
+	drm_dev_exit(idx);
+}
+
+static const struct drm_simple_display_pipe_funcs hx8357d_pipe_funcs = {
+	.enable = yx240qv29_enable,
+	.disable = mipi_dbi_pipe_disable,
+	.update = mipi_dbi_pipe_update,
+	.prepare_fb = drm_gem_fb_simple_display_pipe_prepare_fb,
+};
+
+static const struct drm_display_mode yx350hv15_mode = {
+	DRM_SIMPLE_MODE(320, 480, 60, 75),
+};
+
+DEFINE_DRM_GEM_CMA_FOPS(hx8357d_fops);
+
+static struct drm_driver hx8357d_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
+	.fops			= &hx8357d_fops,
+	.release		= mipi_dbi_release,
+	DRM_GEM_CMA_VMAP_DRIVER_OPS,
+	.debugfs_init		= mipi_dbi_debugfs_init,
+	.name			= "hx8357d",
+	.desc			= "HX8357D",
+	.date			= "20181023",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static const struct of_device_id hx8357d_of_match[] = {
+	{ .compatible = "adafruit,yx350hv15" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, hx8357d_of_match);
+
+static const struct spi_device_id hx8357d_id[] = {
+	{ "yx350hv15", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, hx8357d_id);
+
+static int hx8357d_probe(struct spi_device *spi)
+{
+	struct device *dev = &spi->dev;
+	struct mipi_dbi_dev *dbidev;
+	struct drm_device *drm;
+	struct gpio_desc *dc;
+	u32 rotation = 0;
+	int ret;
+
+	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
+	if (!dbidev)
+		return -ENOMEM;
+
+	drm = &dbidev->drm;
+	ret = devm_drm_dev_init(dev, drm, &hx8357d_driver);
+	if (ret) {
+		kfree(dbidev);
+		return ret;
+	}
+
+	drm_mode_config_init(drm);
+
+	dc = devm_gpiod_get(dev, "dc", GPIOD_OUT_LOW);
+	if (IS_ERR(dc)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'dc'\n");
+		return PTR_ERR(dc);
+	}
+
+	dbidev->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(dbidev->backlight))
+		return PTR_ERR(dbidev->backlight);
+
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	ret = mipi_dbi_spi_init(spi, &dbidev->dbi, dc);
+	if (ret)
+		return ret;
+
+	ret = mipi_dbi_dev_init(dbidev, &hx8357d_pipe_funcs, &yx350hv15_mode, rotation);
+	if (ret)
+		return ret;
+
+	drm_mode_config_reset(drm);
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		return ret;
+
+	spi_set_drvdata(spi, drm);
+
+	drm_fbdev_generic_setup(drm, 0);
+
+	return 0;
+}
+
+static int hx8357d_remove(struct spi_device *spi)
+{
+	struct drm_device *drm = spi_get_drvdata(spi);
+
+	drm_dev_unplug(drm);
+	drm_atomic_helper_shutdown(drm);
+
+	return 0;
+}
+
+static void hx8357d_shutdown(struct spi_device *spi)
+{
+	drm_atomic_helper_shutdown(spi_get_drvdata(spi));
+}
+
+static struct spi_driver hx8357d_spi_driver = {
+	.driver = {
+		.name = "hx8357d",
+		.of_match_table = hx8357d_of_match,
+	},
+	.id_table = hx8357d_id,
+	.probe = hx8357d_probe,
+	.remove = hx8357d_remove,
+	.shutdown = hx8357d_shutdown,
+};
+module_spi_driver(hx8357d_spi_driver);
+
+MODULE_DESCRIPTION("HX8357D DRM driver");
+MODULE_AUTHOR("Eric Anholt <eric@anholt.net>");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/gpu/drm/tiny/ili9225.c
@@ -0,0 +1,470 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * DRM driver for Ilitek ILI9225 panels
+ *
+ * Copyright 2017 David Lechner <david@lechnology.com>
+ *
+ * Some code copied from mipi-dbi.c
+ * Copyright 2016 Noralf Trønnes
+ */
+
+#include <linux/delay.h>
+#include <linux/dma-buf.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/property.h>
+#include <linux/spi/spi.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_damage_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_mipi_dbi.h>
+#include <drm/drm_rect.h>
+#include <drm/drm_vblank.h>
+
+#define ILI9225_DRIVER_READ_CODE	0x00
+#define ILI9225_DRIVER_OUTPUT_CONTROL	0x01
+#define ILI9225_LCD_AC_DRIVING_CONTROL	0x02
+#define ILI9225_ENTRY_MODE		0x03
+#define ILI9225_DISPLAY_CONTROL_1	0x07
+#define ILI9225_BLANK_PERIOD_CONTROL_1	0x08
+#define ILI9225_FRAME_CYCLE_CONTROL	0x0b
+#define ILI9225_INTERFACE_CONTROL	0x0c
+#define ILI9225_OSCILLATION_CONTROL	0x0f
+#define ILI9225_POWER_CONTROL_1		0x10
+#define ILI9225_POWER_CONTROL_2		0x11
+#define ILI9225_POWER_CONTROL_3		0x12
+#define ILI9225_POWER_CONTROL_4		0x13
+#define ILI9225_POWER_CONTROL_5		0x14
+#define ILI9225_VCI_RECYCLING		0x15
+#define ILI9225_RAM_ADDRESS_SET_1	0x20
+#define ILI9225_RAM_ADDRESS_SET_2	0x21
+#define ILI9225_WRITE_DATA_TO_GRAM	0x22
+#define ILI9225_SOFTWARE_RESET		0x28
+#define ILI9225_GATE_SCAN_CONTROL	0x30
+#define ILI9225_VERTICAL_SCROLL_1	0x31
+#define ILI9225_VERTICAL_SCROLL_2	0x32
+#define ILI9225_VERTICAL_SCROLL_3	0x33
+#define ILI9225_PARTIAL_DRIVING_POS_1	0x34
+#define ILI9225_PARTIAL_DRIVING_POS_2	0x35
+#define ILI9225_HORIZ_WINDOW_ADDR_1	0x36
+#define ILI9225_HORIZ_WINDOW_ADDR_2	0x37
+#define ILI9225_VERT_WINDOW_ADDR_1	0x38
+#define ILI9225_VERT_WINDOW_ADDR_2	0x39
+#define ILI9225_GAMMA_CONTROL_1		0x50
+#define ILI9225_GAMMA_CONTROL_2		0x51
+#define ILI9225_GAMMA_CONTROL_3		0x52
+#define ILI9225_GAMMA_CONTROL_4		0x53
+#define ILI9225_GAMMA_CONTROL_5		0x54
+#define ILI9225_GAMMA_CONTROL_6		0x55
+#define ILI9225_GAMMA_CONTROL_7		0x56
+#define ILI9225_GAMMA_CONTROL_8		0x57
+#define ILI9225_GAMMA_CONTROL_9		0x58
+#define ILI9225_GAMMA_CONTROL_10	0x59
+
+static inline int ili9225_command(struct mipi_dbi *dbi, u8 cmd, u16 data)
+{
+	u8 par[2] = { data >> 8, data & 0xff };
+
+	return mipi_dbi_command_buf(dbi, cmd, par, 2);
+}
+
+static void ili9225_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
+{
+	struct drm_gem_cma_object *cma_obj = drm_fb_cma_get_gem_obj(fb, 0);
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(fb->dev);
+	unsigned int height = rect->y2 - rect->y1;
+	unsigned int width = rect->x2 - rect->x1;
+	struct mipi_dbi *dbi = &dbidev->dbi;
+	bool swap = dbi->swap_bytes;
+	u16 x_start, y_start;
+	u16 x1, x2, y1, y2;
+	int idx, ret = 0;
+	bool full;
+	void *tr;
+
+	if (!dbidev->enabled)
+		return;
+
+	if (!drm_dev_enter(fb->dev, &idx))
+		return;
+
+	full = width == fb->width && height == fb->height;
+
+	DRM_DEBUG_KMS("Flushing [FB:%d] " DRM_RECT_FMT "\n", fb->base.id, DRM_RECT_ARG(rect));
+
+	if (!dbi->dc || !full || swap ||
+	    fb->format->format == DRM_FORMAT_XRGB8888) {
+		tr = dbidev->tx_buf;
+		ret = mipi_dbi_buf_copy(dbidev->tx_buf, fb, rect, swap);
+		if (ret)
+			goto err_msg;
+	} else {
+		tr = cma_obj->vaddr;
+	}
+
+	switch (dbidev->rotation) {
+	default:
+		x1 = rect->x1;
+		x2 = rect->x2 - 1;
+		y1 = rect->y1;
+		y2 = rect->y2 - 1;
+		x_start = x1;
+		y_start = y1;
+		break;
+	case 90:
+		x1 = rect->y1;
+		x2 = rect->y2 - 1;
+		y1 = fb->width - rect->x2;
+		y2 = fb->width - rect->x1 - 1;
+		x_start = x1;
+		y_start = y2;
+		break;
+	case 180:
+		x1 = fb->width - rect->x2;
+		x2 = fb->width - rect->x1 - 1;
+		y1 = fb->height - rect->y2;
+		y2 = fb->height - rect->y1 - 1;
+		x_start = x2;
+		y_start = y2;
+		break;
+	case 270:
+		x1 = fb->height - rect->y2;
+		x2 = fb->height - rect->y1 - 1;
+		y1 = rect->x1;
+		y2 = rect->x2 - 1;
+		x_start = x2;
+		y_start = y1;
+		break;
+	}
+
+	ili9225_command(dbi, ILI9225_HORIZ_WINDOW_ADDR_1, x2);
+	ili9225_command(dbi, ILI9225_HORIZ_WINDOW_ADDR_2, x1);
+	ili9225_command(dbi, ILI9225_VERT_WINDOW_ADDR_1, y2);
+	ili9225_command(dbi, ILI9225_VERT_WINDOW_ADDR_2, y1);
+
+	ili9225_command(dbi, ILI9225_RAM_ADDRESS_SET_1, x_start);
+	ili9225_command(dbi, ILI9225_RAM_ADDRESS_SET_2, y_start);
+
+	ret = mipi_dbi_command_buf(dbi, ILI9225_WRITE_DATA_TO_GRAM, tr,
+				   width * height * 2);
+err_msg:
+	if (ret)
+		dev_err_once(fb->dev->dev, "Failed to update display %d\n", ret);
+
+	drm_dev_exit(idx);
+}
+
+static void ili9225_pipe_update(struct drm_simple_display_pipe *pipe,
+				struct drm_plane_state *old_state)
+{
+	struct drm_plane_state *state = pipe->plane.state;
+	struct drm_crtc *crtc = &pipe->crtc;
+	struct drm_rect rect;
+
+	if (drm_atomic_helper_damage_merged(old_state, state, &rect))
+		ili9225_fb_dirty(state->fb, &rect);
+
+	if (crtc->state->event) {
+		spin_lock_irq(&crtc->dev->event_lock);
+		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		spin_unlock_irq(&crtc->dev->event_lock);
+		crtc->state->event = NULL;
+	}
+}
+
+static void ili9225_pipe_enable(struct drm_simple_display_pipe *pipe,
+				struct drm_crtc_state *crtc_state,
+				struct drm_plane_state *plane_state)
+{
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
+	struct drm_framebuffer *fb = plane_state->fb;
+	struct device *dev = pipe->crtc.dev->dev;
+	struct mipi_dbi *dbi = &dbidev->dbi;
+	struct drm_rect rect = {
+		.x1 = 0,
+		.x2 = fb->width,
+		.y1 = 0,
+		.y2 = fb->height,
+	};
+	int ret, idx;
+	u8 am_id;
+
+	if (!drm_dev_enter(pipe->crtc.dev, &idx))
+		return;
+
+	DRM_DEBUG_KMS("\n");
+
+	mipi_dbi_hw_reset(dbi);
+
+	/*
+	 * There don't seem to be two example init sequences that match, so
+	 * using the one from the popular Arduino library for this display.
+	 * https://github.com/Nkawu/TFT_22_ILI9225/blob/master/src/TFT_22_ILI9225.cpp
+	 */
+
+	ret = ili9225_command(dbi, ILI9225_POWER_CONTROL_1, 0x0000);
+	if (ret) {
+		DRM_DEV_ERROR(dev, "Error sending command %d\n", ret);
+		goto out_exit;
+	}
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_2, 0x0000);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_3, 0x0000);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_4, 0x0000);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_5, 0x0000);
+
+	msleep(40);
+
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_2, 0x0018);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_3, 0x6121);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_4, 0x006f);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_5, 0x495f);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_1, 0x0800);
+
+	msleep(10);
+
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_2, 0x103b);
+
+	msleep(50);
+
+	switch (dbidev->rotation) {
+	default:
+		am_id = 0x30;
+		break;
+	case 90:
+		am_id = 0x18;
+		break;
+	case 180:
+		am_id = 0x00;
+		break;
+	case 270:
+		am_id = 0x28;
+		break;
+	}
+	ili9225_command(dbi, ILI9225_DRIVER_OUTPUT_CONTROL, 0x011c);
+	ili9225_command(dbi, ILI9225_LCD_AC_DRIVING_CONTROL, 0x0100);
+	ili9225_command(dbi, ILI9225_ENTRY_MODE, 0x1000 | am_id);
+	ili9225_command(dbi, ILI9225_DISPLAY_CONTROL_1, 0x0000);
+	ili9225_command(dbi, ILI9225_BLANK_PERIOD_CONTROL_1, 0x0808);
+	ili9225_command(dbi, ILI9225_FRAME_CYCLE_CONTROL, 0x1100);
+	ili9225_command(dbi, ILI9225_INTERFACE_CONTROL, 0x0000);
+	ili9225_command(dbi, ILI9225_OSCILLATION_CONTROL, 0x0d01);
+	ili9225_command(dbi, ILI9225_VCI_RECYCLING, 0x0020);
+	ili9225_command(dbi, ILI9225_RAM_ADDRESS_SET_1, 0x0000);
+	ili9225_command(dbi, ILI9225_RAM_ADDRESS_SET_2, 0x0000);
+
+	ili9225_command(dbi, ILI9225_GATE_SCAN_CONTROL, 0x0000);
+	ili9225_command(dbi, ILI9225_VERTICAL_SCROLL_1, 0x00db);
+	ili9225_command(dbi, ILI9225_VERTICAL_SCROLL_2, 0x0000);
+	ili9225_command(dbi, ILI9225_VERTICAL_SCROLL_3, 0x0000);
+	ili9225_command(dbi, ILI9225_PARTIAL_DRIVING_POS_1, 0x00db);
+	ili9225_command(dbi, ILI9225_PARTIAL_DRIVING_POS_2, 0x0000);
+
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_1, 0x0000);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_2, 0x0808);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_3, 0x080a);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_4, 0x000a);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_5, 0x0a08);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_6, 0x0808);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_7, 0x0000);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_8, 0x0a00);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_9, 0x0710);
+	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_10, 0x0710);
+
+	ili9225_command(dbi, ILI9225_DISPLAY_CONTROL_1, 0x0012);
+
+	msleep(50);
+
+	ili9225_command(dbi, ILI9225_DISPLAY_CONTROL_1, 0x1017);
+
+	dbidev->enabled = true;
+	ili9225_fb_dirty(fb, &rect);
+out_exit:
+	drm_dev_exit(idx);
+}
+
+static void ili9225_pipe_disable(struct drm_simple_display_pipe *pipe)
+{
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
+	struct mipi_dbi *dbi = &dbidev->dbi;
+
+	DRM_DEBUG_KMS("\n");
+
+	/*
+	 * This callback is not protected by drm_dev_enter/exit since we want to
+	 * turn off the display on regular driver unload. It's highly unlikely
+	 * that the underlying SPI controller is gone should this be called after
+	 * unplug.
+	 */
+
+	if (!dbidev->enabled)
+		return;
+
+	ili9225_command(dbi, ILI9225_DISPLAY_CONTROL_1, 0x0000);
+	msleep(50);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_2, 0x0007);
+	msleep(50);
+	ili9225_command(dbi, ILI9225_POWER_CONTROL_1, 0x0a02);
+
+	dbidev->enabled = false;
+}
+
+static int ili9225_dbi_command(struct mipi_dbi *dbi, u8 *cmd, u8 *par,
+			       size_t num)
+{
+	struct spi_device *spi = dbi->spi;
+	unsigned int bpw = 8;
+	u32 speed_hz;
+	int ret;
+
+	gpiod_set_value_cansleep(dbi->dc, 0);
+	speed_hz = mipi_dbi_spi_cmd_max_speed(spi, 1);
+	ret = mipi_dbi_spi_transfer(spi, speed_hz, 8, cmd, 1);
+	if (ret || !num)
+		return ret;
+
+	if (*cmd == ILI9225_WRITE_DATA_TO_GRAM && !dbi->swap_bytes)
+		bpw = 16;
+
+	gpiod_set_value_cansleep(dbi->dc, 1);
+	speed_hz = mipi_dbi_spi_cmd_max_speed(spi, num);
+
+	return mipi_dbi_spi_transfer(spi, speed_hz, bpw, par, num);
+}
+
+static const struct drm_simple_display_pipe_funcs ili9225_pipe_funcs = {
+	.enable		= ili9225_pipe_enable,
+	.disable	= ili9225_pipe_disable,
+	.update		= ili9225_pipe_update,
+	.prepare_fb	= drm_gem_fb_simple_display_pipe_prepare_fb,
+};
+
+static const struct drm_display_mode ili9225_mode = {
+	DRM_SIMPLE_MODE(176, 220, 35, 44),
+};
+
+DEFINE_DRM_GEM_CMA_FOPS(ili9225_fops);
+
+static struct drm_driver ili9225_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
+	.fops			= &ili9225_fops,
+	.release		= mipi_dbi_release,
+	DRM_GEM_CMA_VMAP_DRIVER_OPS,
+	.name			= "ili9225",
+	.desc			= "Ilitek ILI9225",
+	.date			= "20171106",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static const struct of_device_id ili9225_of_match[] = {
+	{ .compatible = "vot,v220hf01a-t" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ili9225_of_match);
+
+static const struct spi_device_id ili9225_id[] = {
+	{ "v220hf01a-t", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, ili9225_id);
+
+static int ili9225_probe(struct spi_device *spi)
+{
+	struct device *dev = &spi->dev;
+	struct mipi_dbi_dev *dbidev;
+	struct drm_device *drm;
+	struct mipi_dbi *dbi;
+	struct gpio_desc *rs;
+	u32 rotation = 0;
+	int ret;
+
+	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
+	if (!dbidev)
+		return -ENOMEM;
+
+	dbi = &dbidev->dbi;
+	drm = &dbidev->drm;
+	ret = devm_drm_dev_init(dev, drm, &ili9225_driver);
+	if (ret) {
+		kfree(dbidev);
+		return ret;
+	}
+
+	drm_mode_config_init(drm);
+
+	dbi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
+		return PTR_ERR(dbi->reset);
+	}
+
+	rs = devm_gpiod_get(dev, "rs", GPIOD_OUT_LOW);
+	if (IS_ERR(rs)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'rs'\n");
+		return PTR_ERR(rs);
+	}
+
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	ret = mipi_dbi_spi_init(spi, dbi, rs);
+	if (ret)
+		return ret;
+
+	/* override the command function set in  mipi_dbi_spi_init() */
+	dbi->command = ili9225_dbi_command;
+
+	ret = mipi_dbi_dev_init(dbidev, &ili9225_pipe_funcs, &ili9225_mode, rotation);
+	if (ret)
+		return ret;
+
+	drm_mode_config_reset(drm);
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		return ret;
+
+	spi_set_drvdata(spi, drm);
+
+	drm_fbdev_generic_setup(drm, 0);
+
+	return 0;
+}
+
+static int ili9225_remove(struct spi_device *spi)
+{
+	struct drm_device *drm = spi_get_drvdata(spi);
+
+	drm_dev_unplug(drm);
+	drm_atomic_helper_shutdown(drm);
+
+	return 0;
+}
+
+static void ili9225_shutdown(struct spi_device *spi)
+{
+	drm_atomic_helper_shutdown(spi_get_drvdata(spi));
+}
+
+static struct spi_driver ili9225_spi_driver = {
+	.driver = {
+		.name = "ili9225",
+		.owner = THIS_MODULE,
+		.of_match_table = ili9225_of_match,
+	},
+	.id_table = ili9225_id,
+	.probe = ili9225_probe,
+	.remove = ili9225_remove,
+	.shutdown = ili9225_shutdown,
+};
+module_spi_driver(ili9225_spi_driver);
+
+MODULE_DESCRIPTION("Ilitek ILI9225 DRM driver");
+MODULE_AUTHOR("David Lechner <david@lechnology.com>");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/gpu/drm/tiny/ili9341.c
@@ -0,0 +1,268 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * DRM driver for Ilitek ILI9341 panels
+ *
+ * Copyright 2018 David Lechner <david@lechnology.com>
+ *
+ * Based on mi0283qt.c:
+ * Copyright 2016 Noralf Trønnes
+ */
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/property.h>
+#include <linux/spi/spi.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_mipi_dbi.h>
+#include <drm/drm_modeset_helper.h>
+#include <video/mipi_display.h>
+
+#define ILI9341_FRMCTR1		0xb1
+#define ILI9341_DISCTRL		0xb6
+#define ILI9341_ETMOD		0xb7
+
+#define ILI9341_PWCTRL1		0xc0
+#define ILI9341_PWCTRL2		0xc1
+#define ILI9341_VMCTRL1		0xc5
+#define ILI9341_VMCTRL2		0xc7
+#define ILI9341_PWCTRLA		0xcb
+#define ILI9341_PWCTRLB		0xcf
+
+#define ILI9341_PGAMCTRL	0xe0
+#define ILI9341_NGAMCTRL	0xe1
+#define ILI9341_DTCTRLA		0xe8
+#define ILI9341_DTCTRLB		0xea
+#define ILI9341_PWRSEQ		0xed
+
+#define ILI9341_EN3GAM		0xf2
+#define ILI9341_PUMPCTRL	0xf7
+
+#define ILI9341_MADCTL_BGR	BIT(3)
+#define ILI9341_MADCTL_MV	BIT(5)
+#define ILI9341_MADCTL_MX	BIT(6)
+#define ILI9341_MADCTL_MY	BIT(7)
+
+static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
+			     struct drm_crtc_state *crtc_state,
+			     struct drm_plane_state *plane_state)
+{
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
+	struct mipi_dbi *dbi = &dbidev->dbi;
+	u8 addr_mode;
+	int ret, idx;
+
+	if (!drm_dev_enter(pipe->crtc.dev, &idx))
+		return;
+
+	DRM_DEBUG_KMS("\n");
+
+	ret = mipi_dbi_poweron_conditional_reset(dbidev);
+	if (ret < 0)
+		goto out_exit;
+	if (ret == 1)
+		goto out_enable;
+
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);
+
+	mipi_dbi_command(dbi, ILI9341_PWCTRLB, 0x00, 0xc1, 0x30);
+	mipi_dbi_command(dbi, ILI9341_PWRSEQ, 0x64, 0x03, 0x12, 0x81);
+	mipi_dbi_command(dbi, ILI9341_DTCTRLA, 0x85, 0x00, 0x78);
+	mipi_dbi_command(dbi, ILI9341_PWCTRLA, 0x39, 0x2c, 0x00, 0x34, 0x02);
+	mipi_dbi_command(dbi, ILI9341_PUMPCTRL, 0x20);
+	mipi_dbi_command(dbi, ILI9341_DTCTRLB, 0x00, 0x00);
+
+	/* Power Control */
+	mipi_dbi_command(dbi, ILI9341_PWCTRL1, 0x23);
+	mipi_dbi_command(dbi, ILI9341_PWCTRL2, 0x10);
+	/* VCOM */
+	mipi_dbi_command(dbi, ILI9341_VMCTRL1, 0x3e, 0x28);
+	mipi_dbi_command(dbi, ILI9341_VMCTRL2, 0x86);
+
+	/* Memory Access Control */
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT, MIPI_DCS_PIXEL_FMT_16BIT);
+
+	/* Frame Rate */
+	mipi_dbi_command(dbi, ILI9341_FRMCTR1, 0x00, 0x1b);
+
+	/* Gamma */
+	mipi_dbi_command(dbi, ILI9341_EN3GAM, 0x00);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_GAMMA_CURVE, 0x01);
+	mipi_dbi_command(dbi, ILI9341_PGAMCTRL,
+			 0x0f, 0x31, 0x2b, 0x0c, 0x0e, 0x08, 0x4e, 0xf1,
+			 0x37, 0x07, 0x10, 0x03, 0x0e, 0x09, 0x00);
+	mipi_dbi_command(dbi, ILI9341_NGAMCTRL,
+			 0x00, 0x0e, 0x14, 0x03, 0x11, 0x07, 0x31, 0xc1,
+			 0x48, 0x08, 0x0f, 0x0c, 0x31, 0x36, 0x0f);
+
+	/* DDRAM */
+	mipi_dbi_command(dbi, ILI9341_ETMOD, 0x07);
+
+	/* Display */
+	mipi_dbi_command(dbi, ILI9341_DISCTRL, 0x08, 0x82, 0x27, 0x00);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(100);
+
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
+	msleep(100);
+
+out_enable:
+	switch (dbidev->rotation) {
+	default:
+		addr_mode = ILI9341_MADCTL_MX;
+		break;
+	case 90:
+		addr_mode = ILI9341_MADCTL_MV;
+		break;
+	case 180:
+		addr_mode = ILI9341_MADCTL_MY;
+		break;
+	case 270:
+		addr_mode = ILI9341_MADCTL_MV | ILI9341_MADCTL_MY |
+			    ILI9341_MADCTL_MX;
+		break;
+	}
+	addr_mode |= ILI9341_MADCTL_BGR;
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
+out_exit:
+	drm_dev_exit(idx);
+}
+
+static const struct drm_simple_display_pipe_funcs ili9341_pipe_funcs = {
+	.enable = yx240qv29_enable,
+	.disable = mipi_dbi_pipe_disable,
+	.update = mipi_dbi_pipe_update,
+	.prepare_fb = drm_gem_fb_simple_display_pipe_prepare_fb,
+};
+
+static const struct drm_display_mode yx240qv29_mode = {
+	DRM_SIMPLE_MODE(240, 320, 37, 49),
+};
+
+DEFINE_DRM_GEM_CMA_FOPS(ili9341_fops);
+
+static struct drm_driver ili9341_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
+	.fops			= &ili9341_fops,
+	.release		= mipi_dbi_release,
+	DRM_GEM_CMA_VMAP_DRIVER_OPS,
+	.debugfs_init		= mipi_dbi_debugfs_init,
+	.name			= "ili9341",
+	.desc			= "Ilitek ILI9341",
+	.date			= "20180514",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static const struct of_device_id ili9341_of_match[] = {
+	{ .compatible = "adafruit,yx240qv29" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ili9341_of_match);
+
+static const struct spi_device_id ili9341_id[] = {
+	{ "yx240qv29", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, ili9341_id);
+
+static int ili9341_probe(struct spi_device *spi)
+{
+	struct device *dev = &spi->dev;
+	struct mipi_dbi_dev *dbidev;
+	struct drm_device *drm;
+	struct mipi_dbi *dbi;
+	struct gpio_desc *dc;
+	u32 rotation = 0;
+	int ret;
+
+	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
+	if (!dbidev)
+		return -ENOMEM;
+
+	dbi = &dbidev->dbi;
+	drm = &dbidev->drm;
+	ret = devm_drm_dev_init(dev, drm, &ili9341_driver);
+	if (ret) {
+		kfree(dbidev);
+		return ret;
+	}
+
+	drm_mode_config_init(drm);
+
+	dbi->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
+		return PTR_ERR(dbi->reset);
+	}
+
+	dc = devm_gpiod_get_optional(dev, "dc", GPIOD_OUT_LOW);
+	if (IS_ERR(dc)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'dc'\n");
+		return PTR_ERR(dc);
+	}
+
+	dbidev->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(dbidev->backlight))
+		return PTR_ERR(dbidev->backlight);
+
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	ret = mipi_dbi_spi_init(spi, dbi, dc);
+	if (ret)
+		return ret;
+
+	ret = mipi_dbi_dev_init(dbidev, &ili9341_pipe_funcs, &yx240qv29_mode, rotation);
+	if (ret)
+		return ret;
+
+	drm_mode_config_reset(drm);
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		return ret;
+
+	spi_set_drvdata(spi, drm);
+
+	drm_fbdev_generic_setup(drm, 0);
+
+	return 0;
+}
+
+static int ili9341_remove(struct spi_device *spi)
+{
+	struct drm_device *drm = spi_get_drvdata(spi);
+
+	drm_dev_unplug(drm);
+	drm_atomic_helper_shutdown(drm);
+
+	return 0;
+}
+
+static void ili9341_shutdown(struct spi_device *spi)
+{
+	drm_atomic_helper_shutdown(spi_get_drvdata(spi));
+}
+
+static struct spi_driver ili9341_spi_driver = {
+	.driver = {
+		.name = "ili9341",
+		.of_match_table = ili9341_of_match,
+	},
+	.id_table = ili9341_id,
+	.probe = ili9341_probe,
+	.remove = ili9341_remove,
+	.shutdown = ili9341_shutdown,
+};
+module_spi_driver(ili9341_spi_driver);
+
+MODULE_DESCRIPTION("Ilitek ILI9341 DRM driver");
+MODULE_AUTHOR("David Lechner <david@lechnology.com>");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/gpu/drm/tiny/mi0283qt.c
@@ -0,0 +1,294 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * DRM driver for Multi-Inno MI0283QT panels
+ *
+ * Copyright 2016 Noralf Trønnes
+ */
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/property.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_mipi_dbi.h>
+#include <drm/drm_modeset_helper.h>
+#include <video/mipi_display.h>
+
+#define ILI9341_FRMCTR1		0xb1
+#define ILI9341_DISCTRL		0xb6
+#define ILI9341_ETMOD		0xb7
+
+#define ILI9341_PWCTRL1		0xc0
+#define ILI9341_PWCTRL2		0xc1
+#define ILI9341_VMCTRL1		0xc5
+#define ILI9341_VMCTRL2		0xc7
+#define ILI9341_PWCTRLA		0xcb
+#define ILI9341_PWCTRLB		0xcf
+
+#define ILI9341_PGAMCTRL	0xe0
+#define ILI9341_NGAMCTRL	0xe1
+#define ILI9341_DTCTRLA		0xe8
+#define ILI9341_DTCTRLB		0xea
+#define ILI9341_PWRSEQ		0xed
+
+#define ILI9341_EN3GAM		0xf2
+#define ILI9341_PUMPCTRL	0xf7
+
+#define ILI9341_MADCTL_BGR	BIT(3)
+#define ILI9341_MADCTL_MV	BIT(5)
+#define ILI9341_MADCTL_MX	BIT(6)
+#define ILI9341_MADCTL_MY	BIT(7)
+
+static void mi0283qt_enable(struct drm_simple_display_pipe *pipe,
+			    struct drm_crtc_state *crtc_state,
+			    struct drm_plane_state *plane_state)
+{
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
+	struct mipi_dbi *dbi = &dbidev->dbi;
+	u8 addr_mode;
+	int ret, idx;
+
+	if (!drm_dev_enter(pipe->crtc.dev, &idx))
+		return;
+
+	DRM_DEBUG_KMS("\n");
+
+	ret = mipi_dbi_poweron_conditional_reset(dbidev);
+	if (ret < 0)
+		goto out_exit;
+	if (ret == 1)
+		goto out_enable;
+
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);
+
+	mipi_dbi_command(dbi, ILI9341_PWCTRLB, 0x00, 0x83, 0x30);
+	mipi_dbi_command(dbi, ILI9341_PWRSEQ, 0x64, 0x03, 0x12, 0x81);
+	mipi_dbi_command(dbi, ILI9341_DTCTRLA, 0x85, 0x01, 0x79);
+	mipi_dbi_command(dbi, ILI9341_PWCTRLA, 0x39, 0x2c, 0x00, 0x34, 0x02);
+	mipi_dbi_command(dbi, ILI9341_PUMPCTRL, 0x20);
+	mipi_dbi_command(dbi, ILI9341_DTCTRLB, 0x00, 0x00);
+
+	/* Power Control */
+	mipi_dbi_command(dbi, ILI9341_PWCTRL1, 0x26);
+	mipi_dbi_command(dbi, ILI9341_PWCTRL2, 0x11);
+	/* VCOM */
+	mipi_dbi_command(dbi, ILI9341_VMCTRL1, 0x35, 0x3e);
+	mipi_dbi_command(dbi, ILI9341_VMCTRL2, 0xbe);
+
+	/* Memory Access Control */
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT, MIPI_DCS_PIXEL_FMT_16BIT);
+
+	/* Frame Rate */
+	mipi_dbi_command(dbi, ILI9341_FRMCTR1, 0x00, 0x1b);
+
+	/* Gamma */
+	mipi_dbi_command(dbi, ILI9341_EN3GAM, 0x08);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_GAMMA_CURVE, 0x01);
+	mipi_dbi_command(dbi, ILI9341_PGAMCTRL,
+		       0x1f, 0x1a, 0x18, 0x0a, 0x0f, 0x06, 0x45, 0x87,
+		       0x32, 0x0a, 0x07, 0x02, 0x07, 0x05, 0x00);
+	mipi_dbi_command(dbi, ILI9341_NGAMCTRL,
+		       0x00, 0x25, 0x27, 0x05, 0x10, 0x09, 0x3a, 0x78,
+		       0x4d, 0x05, 0x18, 0x0d, 0x38, 0x3a, 0x1f);
+
+	/* DDRAM */
+	mipi_dbi_command(dbi, ILI9341_ETMOD, 0x07);
+
+	/* Display */
+	mipi_dbi_command(dbi, ILI9341_DISCTRL, 0x0a, 0x82, 0x27, 0x00);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(100);
+
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
+	msleep(100);
+
+out_enable:
+	/* The PiTFT (ili9340) has a hardware reset circuit that
+	 * resets only on power-on and not on each reboot through
+	 * a gpio like the rpi-display does.
+	 * As a result, we need to always apply the rotation value
+	 * regardless of the display "on/off" state.
+	 */
+	switch (dbidev->rotation) {
+	default:
+		addr_mode = ILI9341_MADCTL_MV | ILI9341_MADCTL_MY |
+			    ILI9341_MADCTL_MX;
+		break;
+	case 90:
+		addr_mode = ILI9341_MADCTL_MY;
+		break;
+	case 180:
+		addr_mode = ILI9341_MADCTL_MV;
+		break;
+	case 270:
+		addr_mode = ILI9341_MADCTL_MX;
+		break;
+	}
+	addr_mode |= ILI9341_MADCTL_BGR;
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
+out_exit:
+	drm_dev_exit(idx);
+}
+
+static const struct drm_simple_display_pipe_funcs mi0283qt_pipe_funcs = {
+	.enable = mi0283qt_enable,
+	.disable = mipi_dbi_pipe_disable,
+	.update = mipi_dbi_pipe_update,
+	.prepare_fb = drm_gem_fb_simple_display_pipe_prepare_fb,
+};
+
+static const struct drm_display_mode mi0283qt_mode = {
+	DRM_SIMPLE_MODE(320, 240, 58, 43),
+};
+
+DEFINE_DRM_GEM_CMA_FOPS(mi0283qt_fops);
+
+static struct drm_driver mi0283qt_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
+	.fops			= &mi0283qt_fops,
+	.release		= mipi_dbi_release,
+	DRM_GEM_CMA_VMAP_DRIVER_OPS,
+	.debugfs_init		= mipi_dbi_debugfs_init,
+	.name			= "mi0283qt",
+	.desc			= "Multi-Inno MI0283QT",
+	.date			= "20160614",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static const struct of_device_id mi0283qt_of_match[] = {
+	{ .compatible = "multi-inno,mi0283qt" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mi0283qt_of_match);
+
+static const struct spi_device_id mi0283qt_id[] = {
+	{ "mi0283qt", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, mi0283qt_id);
+
+static int mi0283qt_probe(struct spi_device *spi)
+{
+	struct device *dev = &spi->dev;
+	struct mipi_dbi_dev *dbidev;
+	struct drm_device *drm;
+	struct mipi_dbi *dbi;
+	struct gpio_desc *dc;
+	u32 rotation = 0;
+	int ret;
+
+	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
+	if (!dbidev)
+		return -ENOMEM;
+
+	dbi = &dbidev->dbi;
+	drm = &dbidev->drm;
+	ret = devm_drm_dev_init(dev, drm, &mi0283qt_driver);
+	if (ret) {
+		kfree(dbidev);
+		return ret;
+	}
+
+	drm_mode_config_init(drm);
+
+	dbi->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
+		return PTR_ERR(dbi->reset);
+	}
+
+	dc = devm_gpiod_get_optional(dev, "dc", GPIOD_OUT_LOW);
+	if (IS_ERR(dc)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'dc'\n");
+		return PTR_ERR(dc);
+	}
+
+	dbidev->regulator = devm_regulator_get(dev, "power");
+	if (IS_ERR(dbidev->regulator))
+		return PTR_ERR(dbidev->regulator);
+
+	dbidev->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(dbidev->backlight))
+		return PTR_ERR(dbidev->backlight);
+
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	ret = mipi_dbi_spi_init(spi, dbi, dc);
+	if (ret)
+		return ret;
+
+	ret = mipi_dbi_dev_init(dbidev, &mi0283qt_pipe_funcs, &mi0283qt_mode, rotation);
+	if (ret)
+		return ret;
+
+	drm_mode_config_reset(drm);
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		return ret;
+
+	spi_set_drvdata(spi, drm);
+
+	drm_fbdev_generic_setup(drm, 0);
+
+	return 0;
+}
+
+static int mi0283qt_remove(struct spi_device *spi)
+{
+	struct drm_device *drm = spi_get_drvdata(spi);
+
+	drm_dev_unplug(drm);
+	drm_atomic_helper_shutdown(drm);
+
+	return 0;
+}
+
+static void mi0283qt_shutdown(struct spi_device *spi)
+{
+	drm_atomic_helper_shutdown(spi_get_drvdata(spi));
+}
+
+static int __maybe_unused mi0283qt_pm_suspend(struct device *dev)
+{
+	return drm_mode_config_helper_suspend(dev_get_drvdata(dev));
+}
+
+static int __maybe_unused mi0283qt_pm_resume(struct device *dev)
+{
+	drm_mode_config_helper_resume(dev_get_drvdata(dev));
+
+	return 0;
+}
+
+static const struct dev_pm_ops mi0283qt_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mi0283qt_pm_suspend, mi0283qt_pm_resume)
+};
+
+static struct spi_driver mi0283qt_spi_driver = {
+	.driver = {
+		.name = "mi0283qt",
+		.owner = THIS_MODULE,
+		.of_match_table = mi0283qt_of_match,
+		.pm = &mi0283qt_pm_ops,
+	},
+	.id_table = mi0283qt_id,
+	.probe = mi0283qt_probe,
+	.remove = mi0283qt_remove,
+	.shutdown = mi0283qt_shutdown,
+};
+module_spi_driver(mi0283qt_spi_driver);
+
+MODULE_DESCRIPTION("Multi-Inno MI0283QT DRM driver");
+MODULE_AUTHOR("Noralf Trønnes");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/gpu/drm/tiny/repaper.c
@@ -0,0 +1,1212 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * DRM driver for Pervasive Displays RePaper branded e-ink panels
+ *
+ * Copyright 2013-2017 Pervasive Displays, Inc.
+ * Copyright 2017 Noralf Trønnes
+ *
+ * The driver supports:
+ * Material Film: Aurora Mb (V231)
+ * Driver IC: G2 (eTC)
+ *
+ * The controller code was taken from the userspace driver:
+ * https://github.com/repaper/gratis
+ */
+
+#include <linux/delay.h>
+#include <linux/dma-buf.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/sched/clock.h>
+#include <linux/spi/spi.h>
+#include <linux/thermal.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_connector.h>
+#include <drm/drm_damage_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_format_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_rect.h>
+#include <drm/drm_vblank.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_simple_kms_helper.h>
+
+#define REPAPER_RID_G2_COG_ID	0x12
+
+enum repaper_model {
+	E1144CS021 = 1,
+	E1190CS021,
+	E2200CS021,
+	E2271CS021,
+};
+
+enum repaper_stage {         /* Image pixel -> Display pixel */
+	REPAPER_COMPENSATE,  /* B -> W, W -> B (Current Image) */
+	REPAPER_WHITE,       /* B -> N, W -> W (Current Image) */
+	REPAPER_INVERSE,     /* B -> N, W -> B (New Image) */
+	REPAPER_NORMAL       /* B -> B, W -> W (New Image) */
+};
+
+enum repaper_epd_border_byte {
+	REPAPER_BORDER_BYTE_NONE,
+	REPAPER_BORDER_BYTE_ZERO,
+	REPAPER_BORDER_BYTE_SET,
+};
+
+struct repaper_epd {
+	struct drm_device drm;
+	struct drm_simple_display_pipe pipe;
+	const struct drm_display_mode *mode;
+	struct drm_connector connector;
+	struct spi_device *spi;
+
+	struct gpio_desc *panel_on;
+	struct gpio_desc *border;
+	struct gpio_desc *discharge;
+	struct gpio_desc *reset;
+	struct gpio_desc *busy;
+
+	struct thermal_zone_device *thermal;
+
+	unsigned int height;
+	unsigned int width;
+	unsigned int bytes_per_scan;
+	const u8 *channel_select;
+	unsigned int stage_time;
+	unsigned int factored_stage_time;
+	bool middle_scan;
+	bool pre_border_byte;
+	enum repaper_epd_border_byte border_byte;
+
+	u8 *line_buffer;
+	void *current_frame;
+
+	bool enabled;
+	bool cleared;
+	bool partial;
+};
+
+static inline struct repaper_epd *drm_to_epd(struct drm_device *drm)
+{
+	return container_of(drm, struct repaper_epd, drm);
+}
+
+static int repaper_spi_transfer(struct spi_device *spi, u8 header,
+				const void *tx, void *rx, size_t len)
+{
+	void *txbuf = NULL, *rxbuf = NULL;
+	struct spi_transfer tr[2] = {};
+	u8 *headerbuf;
+	int ret;
+
+	headerbuf = kmalloc(1, GFP_KERNEL);
+	if (!headerbuf)
+		return -ENOMEM;
+
+	headerbuf[0] = header;
+	tr[0].tx_buf = headerbuf;
+	tr[0].len = 1;
+
+	/* Stack allocated tx? */
+	if (tx && len <= 32) {
+		txbuf = kmemdup(tx, len, GFP_KERNEL);
+		if (!txbuf) {
+			ret = -ENOMEM;
+			goto out_free;
+		}
+	}
+
+	if (rx) {
+		rxbuf = kmalloc(len, GFP_KERNEL);
+		if (!rxbuf) {
+			ret = -ENOMEM;
+			goto out_free;
+		}
+	}
+
+	tr[1].tx_buf = txbuf ? txbuf : tx;
+	tr[1].rx_buf = rxbuf;
+	tr[1].len = len;
+
+	ndelay(80);
+	ret = spi_sync_transfer(spi, tr, 2);
+	if (rx && !ret)
+		memcpy(rx, rxbuf, len);
+
+out_free:
+	kfree(headerbuf);
+	kfree(txbuf);
+	kfree(rxbuf);
+
+	return ret;
+}
+
+static int repaper_write_buf(struct spi_device *spi, u8 reg,
+			     const u8 *buf, size_t len)
+{
+	int ret;
+
+	ret = repaper_spi_transfer(spi, 0x70, &reg, NULL, 1);
+	if (ret)
+		return ret;
+
+	return repaper_spi_transfer(spi, 0x72, buf, NULL, len);
+}
+
+static int repaper_write_val(struct spi_device *spi, u8 reg, u8 val)
+{
+	return repaper_write_buf(spi, reg, &val, 1);
+}
+
+static int repaper_read_val(struct spi_device *spi, u8 reg)
+{
+	int ret;
+	u8 val;
+
+	ret = repaper_spi_transfer(spi, 0x70, &reg, NULL, 1);
+	if (ret)
+		return ret;
+
+	ret = repaper_spi_transfer(spi, 0x73, NULL, &val, 1);
+
+	return ret ? ret : val;
+}
+
+static int repaper_read_id(struct spi_device *spi)
+{
+	int ret;
+	u8 id;
+
+	ret = repaper_spi_transfer(spi, 0x71, NULL, &id, 1);
+
+	return ret ? ret : id;
+}
+
+static void repaper_spi_mosi_low(struct spi_device *spi)
+{
+	const u8 buf[1] = { 0 };
+
+	spi_write(spi, buf, 1);
+}
+
+/* pixels on display are numbered from 1 so even is actually bits 1,3,5,... */
+static void repaper_even_pixels(struct repaper_epd *epd, u8 **pp,
+				const u8 *data, u8 fixed_value, const u8 *mask,
+				enum repaper_stage stage)
+{
+	unsigned int b;
+
+	for (b = 0; b < (epd->width / 8); b++) {
+		if (data) {
+			u8 pixels = data[b] & 0xaa;
+			u8 pixel_mask = 0xff;
+			u8 p1, p2, p3, p4;
+
+			if (mask) {
+				pixel_mask = (mask[b] ^ pixels) & 0xaa;
+				pixel_mask |= pixel_mask >> 1;
+			}
+
+			switch (stage) {
+			case REPAPER_COMPENSATE: /* B -> W, W -> B (Current) */
+				pixels = 0xaa | ((pixels ^ 0xaa) >> 1);
+				break;
+			case REPAPER_WHITE:      /* B -> N, W -> W (Current) */
+				pixels = 0x55 + ((pixels ^ 0xaa) >> 1);
+				break;
+			case REPAPER_INVERSE:    /* B -> N, W -> B (New) */
+				pixels = 0x55 | (pixels ^ 0xaa);
+				break;
+			case REPAPER_NORMAL:     /* B -> B, W -> W (New) */
+				pixels = 0xaa | (pixels >> 1);
+				break;
+			}
+
+			pixels = (pixels & pixel_mask) | (~pixel_mask & 0x55);
+			p1 = (pixels >> 6) & 0x03;
+			p2 = (pixels >> 4) & 0x03;
+			p3 = (pixels >> 2) & 0x03;
+			p4 = (pixels >> 0) & 0x03;
+			pixels = (p1 << 0) | (p2 << 2) | (p3 << 4) | (p4 << 6);
+			*(*pp)++ = pixels;
+		} else {
+			*(*pp)++ = fixed_value;
+		}
+	}
+}
+
+/* pixels on display are numbered from 1 so odd is actually bits 0,2,4,... */
+static void repaper_odd_pixels(struct repaper_epd *epd, u8 **pp,
+			       const u8 *data, u8 fixed_value, const u8 *mask,
+			       enum repaper_stage stage)
+{
+	unsigned int b;
+
+	for (b = epd->width / 8; b > 0; b--) {
+		if (data) {
+			u8 pixels = data[b - 1] & 0x55;
+			u8 pixel_mask = 0xff;
+
+			if (mask) {
+				pixel_mask = (mask[b - 1] ^ pixels) & 0x55;
+				pixel_mask |= pixel_mask << 1;
+			}
+
+			switch (stage) {
+			case REPAPER_COMPENSATE: /* B -> W, W -> B (Current) */
+				pixels = 0xaa | (pixels ^ 0x55);
+				break;
+			case REPAPER_WHITE:      /* B -> N, W -> W (Current) */
+				pixels = 0x55 + (pixels ^ 0x55);
+				break;
+			case REPAPER_INVERSE:    /* B -> N, W -> B (New) */
+				pixels = 0x55 | ((pixels ^ 0x55) << 1);
+				break;
+			case REPAPER_NORMAL:     /* B -> B, W -> W (New) */
+				pixels = 0xaa | pixels;
+				break;
+			}
+
+			pixels = (pixels & pixel_mask) | (~pixel_mask & 0x55);
+			*(*pp)++ = pixels;
+		} else {
+			*(*pp)++ = fixed_value;
+		}
+	}
+}
+
+/* interleave bits: (byte)76543210 -> (16 bit).7.6.5.4.3.2.1 */
+static inline u16 repaper_interleave_bits(u16 value)
+{
+	value = (value | (value << 4)) & 0x0f0f;
+	value = (value | (value << 2)) & 0x3333;
+	value = (value | (value << 1)) & 0x5555;
+
+	return value;
+}
+
+/* pixels on display are numbered from 1 */
+static void repaper_all_pixels(struct repaper_epd *epd, u8 **pp,
+			       const u8 *data, u8 fixed_value, const u8 *mask,
+			       enum repaper_stage stage)
+{
+	unsigned int b;
+
+	for (b = epd->width / 8; b > 0; b--) {
+		if (data) {
+			u16 pixels = repaper_interleave_bits(data[b - 1]);
+			u16 pixel_mask = 0xffff;
+
+			if (mask) {
+				pixel_mask = repaper_interleave_bits(mask[b - 1]);
+
+				pixel_mask = (pixel_mask ^ pixels) & 0x5555;
+				pixel_mask |= pixel_mask << 1;
+			}
+
+			switch (stage) {
+			case REPAPER_COMPENSATE: /* B -> W, W -> B (Current) */
+				pixels = 0xaaaa | (pixels ^ 0x5555);
+				break;
+			case REPAPER_WHITE:      /* B -> N, W -> W (Current) */
+				pixels = 0x5555 + (pixels ^ 0x5555);
+				break;
+			case REPAPER_INVERSE:    /* B -> N, W -> B (New) */
+				pixels = 0x5555 | ((pixels ^ 0x5555) << 1);
+				break;
+			case REPAPER_NORMAL:     /* B -> B, W -> W (New) */
+				pixels = 0xaaaa | pixels;
+				break;
+			}
+
+			pixels = (pixels & pixel_mask) | (~pixel_mask & 0x5555);
+			*(*pp)++ = pixels >> 8;
+			*(*pp)++ = pixels;
+		} else {
+			*(*pp)++ = fixed_value;
+			*(*pp)++ = fixed_value;
+		}
+	}
+}
+
+/* output one line of scan and data bytes to the display */
+static void repaper_one_line(struct repaper_epd *epd, unsigned int line,
+			     const u8 *data, u8 fixed_value, const u8 *mask,
+			     enum repaper_stage stage)
+{
+	u8 *p = epd->line_buffer;
+	unsigned int b;
+
+	repaper_spi_mosi_low(epd->spi);
+
+	if (epd->pre_border_byte)
+		*p++ = 0x00;
+
+	if (epd->middle_scan) {
+		/* data bytes */
+		repaper_odd_pixels(epd, &p, data, fixed_value, mask, stage);
+
+		/* scan line */
+		for (b = epd->bytes_per_scan; b > 0; b--) {
+			if (line / 4 == b - 1)
+				*p++ = 0x03 << (2 * (line & 0x03));
+			else
+				*p++ = 0x00;
+		}
+
+		/* data bytes */
+		repaper_even_pixels(epd, &p, data, fixed_value, mask, stage);
+	} else {
+		/*
+		 * even scan line, but as lines on display are numbered from 1,
+		 * line: 1,3,5,...
+		 */
+		for (b = 0; b < epd->bytes_per_scan; b++) {
+			if (0 != (line & 0x01) && line / 8 == b)
+				*p++ = 0xc0 >> (line & 0x06);
+			else
+				*p++ = 0x00;
+		}
+
+		/* data bytes */
+		repaper_all_pixels(epd, &p, data, fixed_value, mask, stage);
+
+		/*
+		 * odd scan line, but as lines on display are numbered from 1,
+		 * line: 0,2,4,6,...
+		 */
+		for (b = epd->bytes_per_scan; b > 0; b--) {
+			if (0 == (line & 0x01) && line / 8 == b - 1)
+				*p++ = 0x03 << (line & 0x06);
+			else
+				*p++ = 0x00;
+		}
+	}
+
+	switch (epd->border_byte) {
+	case REPAPER_BORDER_BYTE_NONE:
+		break;
+
+	case REPAPER_BORDER_BYTE_ZERO:
+		*p++ = 0x00;
+		break;
+
+	case REPAPER_BORDER_BYTE_SET:
+		switch (stage) {
+		case REPAPER_COMPENSATE:
+		case REPAPER_WHITE:
+		case REPAPER_INVERSE:
+			*p++ = 0x00;
+			break;
+		case REPAPER_NORMAL:
+			*p++ = 0xaa;
+			break;
+		}
+		break;
+	}
+
+	repaper_write_buf(epd->spi, 0x0a, epd->line_buffer,
+			  p - epd->line_buffer);
+
+	/* Output data to panel */
+	repaper_write_val(epd->spi, 0x02, 0x07);
+
+	repaper_spi_mosi_low(epd->spi);
+}
+
+static void repaper_frame_fixed(struct repaper_epd *epd, u8 fixed_value,
+				enum repaper_stage stage)
+{
+	unsigned int line;
+
+	for (line = 0; line < epd->height; line++)
+		repaper_one_line(epd, line, NULL, fixed_value, NULL, stage);
+}
+
+static void repaper_frame_data(struct repaper_epd *epd, const u8 *image,
+			       const u8 *mask, enum repaper_stage stage)
+{
+	unsigned int line;
+
+	if (!mask) {
+		for (line = 0; line < epd->height; line++) {
+			repaper_one_line(epd, line,
+					 &image[line * (epd->width / 8)],
+					 0, NULL, stage);
+		}
+	} else {
+		for (line = 0; line < epd->height; line++) {
+			size_t n = line * epd->width / 8;
+
+			repaper_one_line(epd, line, &image[n], 0, &mask[n],
+					 stage);
+		}
+	}
+}
+
+static void repaper_frame_fixed_repeat(struct repaper_epd *epd, u8 fixed_value,
+				       enum repaper_stage stage)
+{
+	u64 start = local_clock();
+	u64 end = start + (epd->factored_stage_time * 1000 * 1000);
+
+	do {
+		repaper_frame_fixed(epd, fixed_value, stage);
+	} while (local_clock() < end);
+}
+
+static void repaper_frame_data_repeat(struct repaper_epd *epd, const u8 *image,
+				      const u8 *mask, enum repaper_stage stage)
+{
+	u64 start = local_clock();
+	u64 end = start + (epd->factored_stage_time * 1000 * 1000);
+
+	do {
+		repaper_frame_data(epd, image, mask, stage);
+	} while (local_clock() < end);
+}
+
+static void repaper_get_temperature(struct repaper_epd *epd)
+{
+	int ret, temperature = 0;
+	unsigned int factor10x;
+
+	if (!epd->thermal)
+		return;
+
+	ret = thermal_zone_get_temp(epd->thermal, &temperature);
+	if (ret) {
+		DRM_DEV_ERROR(&epd->spi->dev, "Failed to get temperature (%d)\n", ret);
+		return;
+	}
+
+	temperature /= 1000;
+
+	if (temperature <= -10)
+		factor10x = 170;
+	else if (temperature <= -5)
+		factor10x = 120;
+	else if (temperature <= 5)
+		factor10x = 80;
+	else if (temperature <= 10)
+		factor10x = 40;
+	else if (temperature <= 15)
+		factor10x = 30;
+	else if (temperature <= 20)
+		factor10x = 20;
+	else if (temperature <= 40)
+		factor10x = 10;
+	else
+		factor10x = 7;
+
+	epd->factored_stage_time = epd->stage_time * factor10x / 10;
+}
+
+static void repaper_gray8_to_mono_reversed(u8 *buf, u32 width, u32 height)
+{
+	u8 *gray8 = buf, *mono = buf;
+	int y, xb, i;
+
+	for (y = 0; y < height; y++)
+		for (xb = 0; xb < width / 8; xb++) {
+			u8 byte = 0x00;
+
+			for (i = 0; i < 8; i++) {
+				int x = xb * 8 + i;
+
+				byte >>= 1;
+				if (gray8[y * width + x] >> 7)
+					byte |= BIT(7);
+			}
+			*mono++ = byte;
+		}
+}
+
+static int repaper_fb_dirty(struct drm_framebuffer *fb)
+{
+	struct drm_gem_cma_object *cma_obj = drm_fb_cma_get_gem_obj(fb, 0);
+	struct dma_buf_attachment *import_attach = cma_obj->base.import_attach;
+	struct repaper_epd *epd = drm_to_epd(fb->dev);
+	struct drm_rect clip;
+	int idx, ret = 0;
+	u8 *buf = NULL;
+
+	if (!epd->enabled)
+		return 0;
+
+	if (!drm_dev_enter(fb->dev, &idx))
+		return -ENODEV;
+
+	/* repaper can't do partial updates */
+	clip.x1 = 0;
+	clip.x2 = fb->width;
+	clip.y1 = 0;
+	clip.y2 = fb->height;
+
+	repaper_get_temperature(epd);
+
+	DRM_DEBUG("Flushing [FB:%d] st=%ums\n", fb->base.id,
+		  epd->factored_stage_time);
+
+	buf = kmalloc_array(fb->width, fb->height, GFP_KERNEL);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto out_exit;
+	}
+
+	if (import_attach) {
+		ret = dma_buf_begin_cpu_access(import_attach->dmabuf,
+					       DMA_FROM_DEVICE);
+		if (ret)
+			goto out_free;
+	}
+
+	drm_fb_xrgb8888_to_gray8(buf, cma_obj->vaddr, fb, &clip);
+
+	if (import_attach) {
+		ret = dma_buf_end_cpu_access(import_attach->dmabuf,
+					     DMA_FROM_DEVICE);
+		if (ret)
+			goto out_free;
+	}
+
+	repaper_gray8_to_mono_reversed(buf, fb->width, fb->height);
+
+	if (epd->partial) {
+		repaper_frame_data_repeat(epd, buf, epd->current_frame,
+					  REPAPER_NORMAL);
+	} else if (epd->cleared) {
+		repaper_frame_data_repeat(epd, epd->current_frame, NULL,
+					  REPAPER_COMPENSATE);
+		repaper_frame_data_repeat(epd, epd->current_frame, NULL,
+					  REPAPER_WHITE);
+		repaper_frame_data_repeat(epd, buf, NULL, REPAPER_INVERSE);
+		repaper_frame_data_repeat(epd, buf, NULL, REPAPER_NORMAL);
+
+		epd->partial = true;
+	} else {
+		/* Clear display (anything -> white) */
+		repaper_frame_fixed_repeat(epd, 0xff, REPAPER_COMPENSATE);
+		repaper_frame_fixed_repeat(epd, 0xff, REPAPER_WHITE);
+		repaper_frame_fixed_repeat(epd, 0xaa, REPAPER_INVERSE);
+		repaper_frame_fixed_repeat(epd, 0xaa, REPAPER_NORMAL);
+
+		/* Assuming a clear (white) screen output an image */
+		repaper_frame_fixed_repeat(epd, 0xaa, REPAPER_COMPENSATE);
+		repaper_frame_fixed_repeat(epd, 0xaa, REPAPER_WHITE);
+		repaper_frame_data_repeat(epd, buf, NULL, REPAPER_INVERSE);
+		repaper_frame_data_repeat(epd, buf, NULL, REPAPER_NORMAL);
+
+		epd->cleared = true;
+		epd->partial = true;
+	}
+
+	memcpy(epd->current_frame, buf, fb->width * fb->height / 8);
+
+	/*
+	 * An extra frame write is needed if pixels are set in the bottom line,
+	 * or else grey lines rises up from the pixels
+	 */
+	if (epd->pre_border_byte) {
+		unsigned int x;
+
+		for (x = 0; x < (fb->width / 8); x++)
+			if (buf[x + (fb->width * (fb->height - 1) / 8)]) {
+				repaper_frame_data_repeat(epd, buf,
+							  epd->current_frame,
+							  REPAPER_NORMAL);
+				break;
+			}
+	}
+
+out_free:
+	kfree(buf);
+out_exit:
+	drm_dev_exit(idx);
+
+	return ret;
+}
+
+static void power_off(struct repaper_epd *epd)
+{
+	/* Turn off power and all signals */
+	gpiod_set_value_cansleep(epd->reset, 0);
+	gpiod_set_value_cansleep(epd->panel_on, 0);
+	if (epd->border)
+		gpiod_set_value_cansleep(epd->border, 0);
+
+	/* Ensure SPI MOSI and CLOCK are Low before CS Low */
+	repaper_spi_mosi_low(epd->spi);
+
+	/* Discharge pulse */
+	gpiod_set_value_cansleep(epd->discharge, 1);
+	msleep(150);
+	gpiod_set_value_cansleep(epd->discharge, 0);
+}
+
+static void repaper_pipe_enable(struct drm_simple_display_pipe *pipe,
+				struct drm_crtc_state *crtc_state,
+				struct drm_plane_state *plane_state)
+{
+	struct repaper_epd *epd = drm_to_epd(pipe->crtc.dev);
+	struct spi_device *spi = epd->spi;
+	struct device *dev = &spi->dev;
+	bool dc_ok = false;
+	int i, ret, idx;
+
+	if (!drm_dev_enter(pipe->crtc.dev, &idx))
+		return;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	/* Power up sequence */
+	gpiod_set_value_cansleep(epd->reset, 0);
+	gpiod_set_value_cansleep(epd->panel_on, 0);
+	gpiod_set_value_cansleep(epd->discharge, 0);
+	if (epd->border)
+		gpiod_set_value_cansleep(epd->border, 0);
+	repaper_spi_mosi_low(spi);
+	usleep_range(5000, 10000);
+
+	gpiod_set_value_cansleep(epd->panel_on, 1);
+	/*
+	 * This delay comes from the repaper.org userspace driver, it's not
+	 * mentioned in the datasheet.
+	 */
+	usleep_range(10000, 15000);
+	gpiod_set_value_cansleep(epd->reset, 1);
+	if (epd->border)
+		gpiod_set_value_cansleep(epd->border, 1);
+	usleep_range(5000, 10000);
+	gpiod_set_value_cansleep(epd->reset, 0);
+	usleep_range(5000, 10000);
+	gpiod_set_value_cansleep(epd->reset, 1);
+	usleep_range(5000, 10000);
+
+	/* Wait for COG to become ready */
+	for (i = 100; i > 0; i--) {
+		if (!gpiod_get_value_cansleep(epd->busy))
+			break;
+
+		usleep_range(10, 100);
+	}
+
+	if (!i) {
+		DRM_DEV_ERROR(dev, "timeout waiting for panel to become ready.\n");
+		power_off(epd);
+		goto out_exit;
+	}
+
+	repaper_read_id(spi);
+	ret = repaper_read_id(spi);
+	if (ret != REPAPER_RID_G2_COG_ID) {
+		if (ret < 0)
+			dev_err(dev, "failed to read chip (%d)\n", ret);
+		else
+			dev_err(dev, "wrong COG ID 0x%02x\n", ret);
+		power_off(epd);
+		goto out_exit;
+	}
+
+	/* Disable OE */
+	repaper_write_val(spi, 0x02, 0x40);
+
+	ret = repaper_read_val(spi, 0x0f);
+	if (ret < 0 || !(ret & 0x80)) {
+		if (ret < 0)
+			DRM_DEV_ERROR(dev, "failed to read chip (%d)\n", ret);
+		else
+			DRM_DEV_ERROR(dev, "panel is reported broken\n");
+		power_off(epd);
+		goto out_exit;
+	}
+
+	/* Power saving mode */
+	repaper_write_val(spi, 0x0b, 0x02);
+	/* Channel select */
+	repaper_write_buf(spi, 0x01, epd->channel_select, 8);
+	/* High power mode osc */
+	repaper_write_val(spi, 0x07, 0xd1);
+	/* Power setting */
+	repaper_write_val(spi, 0x08, 0x02);
+	/* Vcom level */
+	repaper_write_val(spi, 0x09, 0xc2);
+	/* Power setting */
+	repaper_write_val(spi, 0x04, 0x03);
+	/* Driver latch on */
+	repaper_write_val(spi, 0x03, 0x01);
+	/* Driver latch off */
+	repaper_write_val(spi, 0x03, 0x00);
+	usleep_range(5000, 10000);
+
+	/* Start chargepump */
+	for (i = 0; i < 4; ++i) {
+		/* Charge pump positive voltage on - VGH/VDL on */
+		repaper_write_val(spi, 0x05, 0x01);
+		msleep(240);
+
+		/* Charge pump negative voltage on - VGL/VDL on */
+		repaper_write_val(spi, 0x05, 0x03);
+		msleep(40);
+
+		/* Charge pump Vcom on - Vcom driver on */
+		repaper_write_val(spi, 0x05, 0x0f);
+		msleep(40);
+
+		/* check DC/DC */
+		ret = repaper_read_val(spi, 0x0f);
+		if (ret < 0) {
+			DRM_DEV_ERROR(dev, "failed to read chip (%d)\n", ret);
+			power_off(epd);
+			goto out_exit;
+		}
+
+		if (ret & 0x40) {
+			dc_ok = true;
+			break;
+		}
+	}
+
+	if (!dc_ok) {
+		DRM_DEV_ERROR(dev, "dc/dc failed\n");
+		power_off(epd);
+		goto out_exit;
+	}
+
+	/*
+	 * Output enable to disable
+	 * The userspace driver sets this to 0x04, but the datasheet says 0x06
+	 */
+	repaper_write_val(spi, 0x02, 0x04);
+
+	epd->enabled = true;
+	epd->partial = false;
+out_exit:
+	drm_dev_exit(idx);
+}
+
+static void repaper_pipe_disable(struct drm_simple_display_pipe *pipe)
+{
+	struct repaper_epd *epd = drm_to_epd(pipe->crtc.dev);
+	struct spi_device *spi = epd->spi;
+	unsigned int line;
+
+	/*
+	 * This callback is not protected by drm_dev_enter/exit since we want to
+	 * turn off the display on regular driver unload. It's highly unlikely
+	 * that the underlying SPI controller is gone should this be called after
+	 * unplug.
+	 */
+
+	if (!epd->enabled)
+		return;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	epd->enabled = false;
+
+	/* Nothing frame */
+	for (line = 0; line < epd->height; line++)
+		repaper_one_line(epd, 0x7fffu, NULL, 0x00, NULL,
+				 REPAPER_COMPENSATE);
+
+	/* 2.7" */
+	if (epd->border) {
+		/* Dummy line */
+		repaper_one_line(epd, 0x7fffu, NULL, 0x00, NULL,
+				 REPAPER_COMPENSATE);
+		msleep(25);
+		gpiod_set_value_cansleep(epd->border, 0);
+		msleep(200);
+		gpiod_set_value_cansleep(epd->border, 1);
+	} else {
+		/* Border dummy line */
+		repaper_one_line(epd, 0x7fffu, NULL, 0x00, NULL,
+				 REPAPER_NORMAL);
+		msleep(200);
+	}
+
+	/* not described in datasheet */
+	repaper_write_val(spi, 0x0b, 0x00);
+	/* Latch reset turn on */
+	repaper_write_val(spi, 0x03, 0x01);
+	/* Power off charge pump Vcom */
+	repaper_write_val(spi, 0x05, 0x03);
+	/* Power off charge pump neg voltage */
+	repaper_write_val(spi, 0x05, 0x01);
+	msleep(120);
+	/* Discharge internal */
+	repaper_write_val(spi, 0x04, 0x80);
+	/* turn off all charge pumps */
+	repaper_write_val(spi, 0x05, 0x00);
+	/* Turn off osc */
+	repaper_write_val(spi, 0x07, 0x01);
+	msleep(50);
+
+	power_off(epd);
+}
+
+static void repaper_pipe_update(struct drm_simple_display_pipe *pipe,
+				struct drm_plane_state *old_state)
+{
+	struct drm_plane_state *state = pipe->plane.state;
+	struct drm_crtc *crtc = &pipe->crtc;
+	struct drm_rect rect;
+
+	if (drm_atomic_helper_damage_merged(old_state, state, &rect))
+		repaper_fb_dirty(state->fb);
+
+	if (crtc->state->event) {
+		spin_lock_irq(&crtc->dev->event_lock);
+		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		spin_unlock_irq(&crtc->dev->event_lock);
+		crtc->state->event = NULL;
+	}
+}
+
+static const struct drm_simple_display_pipe_funcs repaper_pipe_funcs = {
+	.enable = repaper_pipe_enable,
+	.disable = repaper_pipe_disable,
+	.update = repaper_pipe_update,
+	.prepare_fb = drm_gem_fb_simple_display_pipe_prepare_fb,
+};
+
+static int repaper_connector_get_modes(struct drm_connector *connector)
+{
+	struct repaper_epd *epd = drm_to_epd(connector->dev);
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, epd->mode);
+	if (!mode) {
+		DRM_ERROR("Failed to duplicate mode\n");
+		return 0;
+	}
+
+	drm_mode_set_name(mode);
+	mode->type |= DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+
+	return 1;
+}
+
+static const struct drm_connector_helper_funcs repaper_connector_hfuncs = {
+	.get_modes = repaper_connector_get_modes,
+};
+
+static const struct drm_connector_funcs repaper_connector_funcs = {
+	.reset = drm_atomic_helper_connector_reset,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = drm_connector_cleanup,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static const struct drm_mode_config_funcs repaper_mode_config_funcs = {
+	.fb_create = drm_gem_fb_create_with_dirty,
+	.atomic_check = drm_atomic_helper_check,
+	.atomic_commit = drm_atomic_helper_commit,
+};
+
+static void repaper_release(struct drm_device *drm)
+{
+	struct repaper_epd *epd = drm_to_epd(drm);
+
+	DRM_DEBUG_DRIVER("\n");
+
+	drm_mode_config_cleanup(drm);
+	drm_dev_fini(drm);
+	kfree(epd);
+}
+
+static const uint32_t repaper_formats[] = {
+	DRM_FORMAT_XRGB8888,
+};
+
+static const struct drm_display_mode repaper_e1144cs021_mode = {
+	DRM_SIMPLE_MODE(128, 96, 29, 22),
+};
+
+static const u8 repaper_e1144cs021_cs[] = { 0x00, 0x00, 0x00, 0x00,
+					    0x00, 0x0f, 0xff, 0x00 };
+
+static const struct drm_display_mode repaper_e1190cs021_mode = {
+	DRM_SIMPLE_MODE(144, 128, 36, 32),
+};
+
+static const u8 repaper_e1190cs021_cs[] = { 0x00, 0x00, 0x00, 0x03,
+					    0xfc, 0x00, 0x00, 0xff };
+
+static const struct drm_display_mode repaper_e2200cs021_mode = {
+	DRM_SIMPLE_MODE(200, 96, 46, 22),
+};
+
+static const u8 repaper_e2200cs021_cs[] = { 0x00, 0x00, 0x00, 0x00,
+					    0x01, 0xff, 0xe0, 0x00 };
+
+static const struct drm_display_mode repaper_e2271cs021_mode = {
+	DRM_SIMPLE_MODE(264, 176, 57, 38),
+};
+
+static const u8 repaper_e2271cs021_cs[] = { 0x00, 0x00, 0x00, 0x7f,
+					    0xff, 0xfe, 0x00, 0x00 };
+
+DEFINE_DRM_GEM_CMA_FOPS(repaper_fops);
+
+static struct drm_driver repaper_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
+	.fops			= &repaper_fops,
+	.release		= repaper_release,
+	DRM_GEM_CMA_VMAP_DRIVER_OPS,
+	.name			= "repaper",
+	.desc			= "Pervasive Displays RePaper e-ink panels",
+	.date			= "20170405",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static const struct of_device_id repaper_of_match[] = {
+	{ .compatible = "pervasive,e1144cs021", .data = (void *)E1144CS021 },
+	{ .compatible = "pervasive,e1190cs021", .data = (void *)E1190CS021 },
+	{ .compatible = "pervasive,e2200cs021", .data = (void *)E2200CS021 },
+	{ .compatible = "pervasive,e2271cs021", .data = (void *)E2271CS021 },
+	{},
+};
+MODULE_DEVICE_TABLE(of, repaper_of_match);
+
+static const struct spi_device_id repaper_id[] = {
+	{ "e1144cs021", E1144CS021 },
+	{ "e1190cs021", E1190CS021 },
+	{ "e2200cs021", E2200CS021 },
+	{ "e2271cs021", E2271CS021 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, repaper_id);
+
+static int repaper_probe(struct spi_device *spi)
+{
+	const struct drm_display_mode *mode;
+	const struct spi_device_id *spi_id;
+	const struct of_device_id *match;
+	struct device *dev = &spi->dev;
+	enum repaper_model model;
+	const char *thermal_zone;
+	struct repaper_epd *epd;
+	size_t line_buffer_size;
+	struct drm_device *drm;
+	int ret;
+
+	match = of_match_device(repaper_of_match, dev);
+	if (match) {
+		model = (enum repaper_model)match->data;
+	} else {
+		spi_id = spi_get_device_id(spi);
+		model = spi_id->driver_data;
+	}
+
+	/* The SPI device is used to allocate dma memory */
+	if (!dev->coherent_dma_mask) {
+		ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
+		if (ret) {
+			dev_warn(dev, "Failed to set dma mask %d\n", ret);
+			return ret;
+		}
+	}
+
+	epd = kzalloc(sizeof(*epd), GFP_KERNEL);
+	if (!epd)
+		return -ENOMEM;
+
+	drm = &epd->drm;
+
+	ret = devm_drm_dev_init(dev, drm, &repaper_driver);
+	if (ret) {
+		kfree(epd);
+		return ret;
+	}
+
+	drm_mode_config_init(drm);
+	drm->mode_config.funcs = &repaper_mode_config_funcs;
+
+	epd->spi = spi;
+
+	epd->panel_on = devm_gpiod_get(dev, "panel-on", GPIOD_OUT_LOW);
+	if (IS_ERR(epd->panel_on)) {
+		ret = PTR_ERR(epd->panel_on);
+		if (ret != -EPROBE_DEFER)
+			DRM_DEV_ERROR(dev, "Failed to get gpio 'panel-on'\n");
+		return ret;
+	}
+
+	epd->discharge = devm_gpiod_get(dev, "discharge", GPIOD_OUT_LOW);
+	if (IS_ERR(epd->discharge)) {
+		ret = PTR_ERR(epd->discharge);
+		if (ret != -EPROBE_DEFER)
+			DRM_DEV_ERROR(dev, "Failed to get gpio 'discharge'\n");
+		return ret;
+	}
+
+	epd->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(epd->reset)) {
+		ret = PTR_ERR(epd->reset);
+		if (ret != -EPROBE_DEFER)
+			DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
+		return ret;
+	}
+
+	epd->busy = devm_gpiod_get(dev, "busy", GPIOD_IN);
+	if (IS_ERR(epd->busy)) {
+		ret = PTR_ERR(epd->busy);
+		if (ret != -EPROBE_DEFER)
+			DRM_DEV_ERROR(dev, "Failed to get gpio 'busy'\n");
+		return ret;
+	}
+
+	if (!device_property_read_string(dev, "pervasive,thermal-zone",
+					 &thermal_zone)) {
+		epd->thermal = thermal_zone_get_zone_by_name(thermal_zone);
+		if (IS_ERR(epd->thermal)) {
+			DRM_DEV_ERROR(dev, "Failed to get thermal zone: %s\n", thermal_zone);
+			return PTR_ERR(epd->thermal);
+		}
+	}
+
+	switch (model) {
+	case E1144CS021:
+		mode = &repaper_e1144cs021_mode;
+		epd->channel_select = repaper_e1144cs021_cs;
+		epd->stage_time = 480;
+		epd->bytes_per_scan = 96 / 4;
+		epd->middle_scan = true; /* data-scan-data */
+		epd->pre_border_byte = false;
+		epd->border_byte = REPAPER_BORDER_BYTE_ZERO;
+		break;
+
+	case E1190CS021:
+		mode = &repaper_e1190cs021_mode;
+		epd->channel_select = repaper_e1190cs021_cs;
+		epd->stage_time = 480;
+		epd->bytes_per_scan = 128 / 4 / 2;
+		epd->middle_scan = false; /* scan-data-scan */
+		epd->pre_border_byte = false;
+		epd->border_byte = REPAPER_BORDER_BYTE_SET;
+		break;
+
+	case E2200CS021:
+		mode = &repaper_e2200cs021_mode;
+		epd->channel_select = repaper_e2200cs021_cs;
+		epd->stage_time = 480;
+		epd->bytes_per_scan = 96 / 4;
+		epd->middle_scan = true; /* data-scan-data */
+		epd->pre_border_byte = true;
+		epd->border_byte = REPAPER_BORDER_BYTE_NONE;
+		break;
+
+	case E2271CS021:
+		epd->border = devm_gpiod_get(dev, "border", GPIOD_OUT_LOW);
+		if (IS_ERR(epd->border)) {
+			ret = PTR_ERR(epd->border);
+			if (ret != -EPROBE_DEFER)
+				DRM_DEV_ERROR(dev, "Failed to get gpio 'border'\n");
+			return ret;
+		}
+
+		mode = &repaper_e2271cs021_mode;
+		epd->channel_select = repaper_e2271cs021_cs;
+		epd->stage_time = 630;
+		epd->bytes_per_scan = 176 / 4;
+		epd->middle_scan = true; /* data-scan-data */
+		epd->pre_border_byte = true;
+		epd->border_byte = REPAPER_BORDER_BYTE_NONE;
+		break;
+
+	default:
+		return -ENODEV;
+	}
+
+	epd->mode = mode;
+	epd->width = mode->hdisplay;
+	epd->height = mode->vdisplay;
+	epd->factored_stage_time = epd->stage_time;
+
+	line_buffer_size = 2 * epd->width / 8 + epd->bytes_per_scan + 2;
+	epd->line_buffer = devm_kzalloc(dev, line_buffer_size, GFP_KERNEL);
+	if (!epd->line_buffer)
+		return -ENOMEM;
+
+	epd->current_frame = devm_kzalloc(dev, epd->width * epd->height / 8,
+					  GFP_KERNEL);
+	if (!epd->current_frame)
+		return -ENOMEM;
+
+	drm->mode_config.min_width = mode->hdisplay;
+	drm->mode_config.max_width = mode->hdisplay;
+	drm->mode_config.min_height = mode->vdisplay;
+	drm->mode_config.max_height = mode->vdisplay;
+
+	drm_connector_helper_add(&epd->connector, &repaper_connector_hfuncs);
+	ret = drm_connector_init(drm, &epd->connector, &repaper_connector_funcs,
+				 DRM_MODE_CONNECTOR_SPI);
+	if (ret)
+		return ret;
+
+	ret = drm_simple_display_pipe_init(drm, &epd->pipe, &repaper_pipe_funcs,
+					   repaper_formats, ARRAY_SIZE(repaper_formats),
+					   NULL, &epd->connector);
+	if (ret)
+		return ret;
+
+	drm_mode_config_reset(drm);
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		return ret;
+
+	spi_set_drvdata(spi, drm);
+
+	DRM_DEBUG_DRIVER("SPI speed: %uMHz\n", spi->max_speed_hz / 1000000);
+
+	drm_fbdev_generic_setup(drm, 0);
+
+	return 0;
+}
+
+static int repaper_remove(struct spi_device *spi)
+{
+	struct drm_device *drm = spi_get_drvdata(spi);
+
+	drm_dev_unplug(drm);
+	drm_atomic_helper_shutdown(drm);
+
+	return 0;
+}
+
+static void repaper_shutdown(struct spi_device *spi)
+{
+	drm_atomic_helper_shutdown(spi_get_drvdata(spi));
+}
+
+static struct spi_driver repaper_spi_driver = {
+	.driver = {
+		.name = "repaper",
+		.owner = THIS_MODULE,
+		.of_match_table = repaper_of_match,
+	},
+	.id_table = repaper_id,
+	.probe = repaper_probe,
+	.remove = repaper_remove,
+	.shutdown = repaper_shutdown,
+};
+module_spi_driver(repaper_spi_driver);
+
+MODULE_DESCRIPTION("Pervasive Displays RePaper DRM driver");
+MODULE_AUTHOR("Noralf Trønnes");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/gpu/drm/tiny/st7586.c
@@ -0,0 +1,424 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * DRM driver for Sitronix ST7586 panels
+ *
+ * Copyright 2017 David Lechner <david@lechnology.com>
+ */
+
+#include <linux/delay.h>
+#include <linux/dma-buf.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/property.h>
+#include <linux/spi/spi.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_damage_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_format_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_mipi_dbi.h>
+#include <drm/drm_rect.h>
+#include <drm/drm_vblank.h>
+
+/* controller-specific commands */
+#define ST7586_DISP_MODE_GRAY	0x38
+#define ST7586_DISP_MODE_MONO	0x39
+#define ST7586_ENABLE_DDRAM	0x3a
+#define ST7586_SET_DISP_DUTY	0xb0
+#define ST7586_SET_PART_DISP	0xb4
+#define ST7586_SET_NLINE_INV	0xb5
+#define ST7586_SET_VOP		0xc0
+#define ST7586_SET_BIAS_SYSTEM	0xc3
+#define ST7586_SET_BOOST_LEVEL	0xc4
+#define ST7586_SET_VOP_OFFSET	0xc7
+#define ST7586_ENABLE_ANALOG	0xd0
+#define ST7586_AUTO_READ_CTRL	0xd7
+#define ST7586_OTP_RW_CTRL	0xe0
+#define ST7586_OTP_CTRL_OUT	0xe1
+#define ST7586_OTP_READ		0xe3
+
+#define ST7586_DISP_CTRL_MX	BIT(6)
+#define ST7586_DISP_CTRL_MY	BIT(7)
+
+/*
+ * The ST7586 controller has an unusual pixel format where 2bpp grayscale is
+ * packed 3 pixels per byte with the first two pixels using 3 bits and the 3rd
+ * pixel using only 2 bits.
+ *
+ * |  D7  |  D6  |  D5  ||      |      || 2bpp |
+ * | (D4) | (D3) | (D2) ||  D1  |  D0  || GRAY |
+ * +------+------+------++------+------++------+
+ * |  1   |  1   |  1   ||  1   |  1   || 0  0 | black
+ * |  1   |  0   |  0   ||  1   |  0   || 0  1 | dark gray
+ * |  0   |  1   |  0   ||  0   |  1   || 1  0 | light gray
+ * |  0   |  0   |  0   ||  0   |  0   || 1  1 | white
+ */
+
+static const u8 st7586_lookup[] = { 0x7, 0x4, 0x2, 0x0 };
+
+static void st7586_xrgb8888_to_gray332(u8 *dst, void *vaddr,
+				       struct drm_framebuffer *fb,
+				       struct drm_rect *clip)
+{
+	size_t len = (clip->x2 - clip->x1) * (clip->y2 - clip->y1);
+	unsigned int x, y;
+	u8 *src, *buf, val;
+
+	buf = kmalloc(len, GFP_KERNEL);
+	if (!buf)
+		return;
+
+	drm_fb_xrgb8888_to_gray8(buf, vaddr, fb, clip);
+	src = buf;
+
+	for (y = clip->y1; y < clip->y2; y++) {
+		for (x = clip->x1; x < clip->x2; x += 3) {
+			val = st7586_lookup[*src++ >> 6] << 5;
+			val |= st7586_lookup[*src++ >> 6] << 2;
+			val |= st7586_lookup[*src++ >> 6] >> 1;
+			*dst++ = val;
+		}
+	}
+
+	kfree(buf);
+}
+
+static int st7586_buf_copy(void *dst, struct drm_framebuffer *fb,
+			   struct drm_rect *clip)
+{
+	struct drm_gem_cma_object *cma_obj = drm_fb_cma_get_gem_obj(fb, 0);
+	struct dma_buf_attachment *import_attach = cma_obj->base.import_attach;
+	void *src = cma_obj->vaddr;
+	int ret = 0;
+
+	if (import_attach) {
+		ret = dma_buf_begin_cpu_access(import_attach->dmabuf,
+					       DMA_FROM_DEVICE);
+		if (ret)
+			return ret;
+	}
+
+	st7586_xrgb8888_to_gray332(dst, src, fb, clip);
+
+	if (import_attach)
+		ret = dma_buf_end_cpu_access(import_attach->dmabuf,
+					     DMA_FROM_DEVICE);
+
+	return ret;
+}
+
+static void st7586_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
+{
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(fb->dev);
+	struct mipi_dbi *dbi = &dbidev->dbi;
+	int start, end, idx, ret = 0;
+
+	if (!dbidev->enabled)
+		return;
+
+	if (!drm_dev_enter(fb->dev, &idx))
+		return;
+
+	/* 3 pixels per byte, so grow clip to nearest multiple of 3 */
+	rect->x1 = rounddown(rect->x1, 3);
+	rect->x2 = roundup(rect->x2, 3);
+
+	DRM_DEBUG_KMS("Flushing [FB:%d] " DRM_RECT_FMT "\n", fb->base.id, DRM_RECT_ARG(rect));
+
+	ret = st7586_buf_copy(dbidev->tx_buf, fb, rect);
+	if (ret)
+		goto err_msg;
+
+	/* Pixels are packed 3 per byte */
+	start = rect->x1 / 3;
+	end = rect->x2 / 3;
+
+	mipi_dbi_command(dbi, MIPI_DCS_SET_COLUMN_ADDRESS,
+			 (start >> 8) & 0xFF, start & 0xFF,
+			 (end >> 8) & 0xFF, (end - 1) & 0xFF);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PAGE_ADDRESS,
+			 (rect->y1 >> 8) & 0xFF, rect->y1 & 0xFF,
+			 (rect->y2 >> 8) & 0xFF, (rect->y2 - 1) & 0xFF);
+
+	ret = mipi_dbi_command_buf(dbi, MIPI_DCS_WRITE_MEMORY_START,
+				   (u8 *)dbidev->tx_buf,
+				   (end - start) * (rect->y2 - rect->y1));
+err_msg:
+	if (ret)
+		dev_err_once(fb->dev->dev, "Failed to update display %d\n", ret);
+
+	drm_dev_exit(idx);
+}
+
+static void st7586_pipe_update(struct drm_simple_display_pipe *pipe,
+			       struct drm_plane_state *old_state)
+{
+	struct drm_plane_state *state = pipe->plane.state;
+	struct drm_crtc *crtc = &pipe->crtc;
+	struct drm_rect rect;
+
+	if (drm_atomic_helper_damage_merged(old_state, state, &rect))
+		st7586_fb_dirty(state->fb, &rect);
+
+	if (crtc->state->event) {
+		spin_lock_irq(&crtc->dev->event_lock);
+		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		spin_unlock_irq(&crtc->dev->event_lock);
+		crtc->state->event = NULL;
+	}
+}
+
+static void st7586_pipe_enable(struct drm_simple_display_pipe *pipe,
+			       struct drm_crtc_state *crtc_state,
+			       struct drm_plane_state *plane_state)
+{
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
+	struct drm_framebuffer *fb = plane_state->fb;
+	struct mipi_dbi *dbi = &dbidev->dbi;
+	struct drm_rect rect = {
+		.x1 = 0,
+		.x2 = fb->width,
+		.y1 = 0,
+		.y2 = fb->height,
+	};
+	int idx, ret;
+	u8 addr_mode;
+
+	if (!drm_dev_enter(pipe->crtc.dev, &idx))
+		return;
+
+	DRM_DEBUG_KMS("\n");
+
+	ret = mipi_dbi_poweron_reset(dbidev);
+	if (ret)
+		goto out_exit;
+
+	mipi_dbi_command(dbi, ST7586_AUTO_READ_CTRL, 0x9f);
+	mipi_dbi_command(dbi, ST7586_OTP_RW_CTRL, 0x00);
+
+	msleep(10);
+
+	mipi_dbi_command(dbi, ST7586_OTP_READ);
+
+	msleep(20);
+
+	mipi_dbi_command(dbi, ST7586_OTP_CTRL_OUT);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);
+
+	msleep(50);
+
+	mipi_dbi_command(dbi, ST7586_SET_VOP_OFFSET, 0x00);
+	mipi_dbi_command(dbi, ST7586_SET_VOP, 0xe3, 0x00);
+	mipi_dbi_command(dbi, ST7586_SET_BIAS_SYSTEM, 0x02);
+	mipi_dbi_command(dbi, ST7586_SET_BOOST_LEVEL, 0x04);
+	mipi_dbi_command(dbi, ST7586_ENABLE_ANALOG, 0x1d);
+	mipi_dbi_command(dbi, ST7586_SET_NLINE_INV, 0x00);
+	mipi_dbi_command(dbi, ST7586_DISP_MODE_GRAY);
+	mipi_dbi_command(dbi, ST7586_ENABLE_DDRAM, 0x02);
+
+	switch (dbidev->rotation) {
+	default:
+		addr_mode = 0x00;
+		break;
+	case 90:
+		addr_mode = ST7586_DISP_CTRL_MY;
+		break;
+	case 180:
+		addr_mode = ST7586_DISP_CTRL_MX | ST7586_DISP_CTRL_MY;
+		break;
+	case 270:
+		addr_mode = ST7586_DISP_CTRL_MX;
+		break;
+	}
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+
+	mipi_dbi_command(dbi, ST7586_SET_DISP_DUTY, 0x7f);
+	mipi_dbi_command(dbi, ST7586_SET_PART_DISP, 0xa0);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PARTIAL_AREA, 0x00, 0x00, 0x00, 0x77);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_INVERT_MODE);
+
+	msleep(100);
+
+	dbidev->enabled = true;
+	st7586_fb_dirty(fb, &rect);
+
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
+out_exit:
+	drm_dev_exit(idx);
+}
+
+static void st7586_pipe_disable(struct drm_simple_display_pipe *pipe)
+{
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
+
+	/*
+	 * This callback is not protected by drm_dev_enter/exit since we want to
+	 * turn off the display on regular driver unload. It's highly unlikely
+	 * that the underlying SPI controller is gone should this be called after
+	 * unplug.
+	 */
+
+	DRM_DEBUG_KMS("\n");
+
+	if (!dbidev->enabled)
+		return;
+
+	mipi_dbi_command(&dbidev->dbi, MIPI_DCS_SET_DISPLAY_OFF);
+	dbidev->enabled = false;
+}
+
+static const u32 st7586_formats[] = {
+	DRM_FORMAT_XRGB8888,
+};
+
+static const struct drm_simple_display_pipe_funcs st7586_pipe_funcs = {
+	.enable		= st7586_pipe_enable,
+	.disable	= st7586_pipe_disable,
+	.update		= st7586_pipe_update,
+	.prepare_fb	= drm_gem_fb_simple_display_pipe_prepare_fb,
+};
+
+static const struct drm_display_mode st7586_mode = {
+	DRM_SIMPLE_MODE(178, 128, 37, 27),
+};
+
+DEFINE_DRM_GEM_CMA_FOPS(st7586_fops);
+
+static struct drm_driver st7586_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
+	.fops			= &st7586_fops,
+	.release		= mipi_dbi_release,
+	DRM_GEM_CMA_VMAP_DRIVER_OPS,
+	.debugfs_init		= mipi_dbi_debugfs_init,
+	.name			= "st7586",
+	.desc			= "Sitronix ST7586",
+	.date			= "20170801",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static const struct of_device_id st7586_of_match[] = {
+	{ .compatible = "lego,ev3-lcd" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, st7586_of_match);
+
+static const struct spi_device_id st7586_id[] = {
+	{ "ev3-lcd", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, st7586_id);
+
+static int st7586_probe(struct spi_device *spi)
+{
+	struct device *dev = &spi->dev;
+	struct mipi_dbi_dev *dbidev;
+	struct drm_device *drm;
+	struct mipi_dbi *dbi;
+	struct gpio_desc *a0;
+	u32 rotation = 0;
+	size_t bufsize;
+	int ret;
+
+	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
+	if (!dbidev)
+		return -ENOMEM;
+
+	dbi = &dbidev->dbi;
+	drm = &dbidev->drm;
+	ret = devm_drm_dev_init(dev, drm, &st7586_driver);
+	if (ret) {
+		kfree(dbidev);
+		return ret;
+	}
+
+	drm_mode_config_init(drm);
+
+	bufsize = (st7586_mode.vdisplay + 2) / 3 * st7586_mode.hdisplay;
+
+	dbi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
+		return PTR_ERR(dbi->reset);
+	}
+
+	a0 = devm_gpiod_get(dev, "a0", GPIOD_OUT_LOW);
+	if (IS_ERR(a0)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'a0'\n");
+		return PTR_ERR(a0);
+	}
+
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	ret = mipi_dbi_spi_init(spi, dbi, a0);
+	if (ret)
+		return ret;
+
+	/* Cannot read from this controller via SPI */
+	dbi->read_commands = NULL;
+
+	ret = mipi_dbi_dev_init_with_formats(dbidev, &st7586_pipe_funcs,
+					     st7586_formats, ARRAY_SIZE(st7586_formats),
+					     &st7586_mode, rotation, bufsize);
+	if (ret)
+		return ret;
+
+	/*
+	 * we are using 8-bit data, so we are not actually swapping anything,
+	 * but setting mipi->swap_bytes makes mipi_dbi_typec3_command() do the
+	 * right thing and not use 16-bit transfers (which results in swapped
+	 * bytes on little-endian systems and causes out of order data to be
+	 * sent to the display).
+	 */
+	dbi->swap_bytes = true;
+
+	drm_mode_config_reset(drm);
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		return ret;
+
+	spi_set_drvdata(spi, drm);
+
+	drm_fbdev_generic_setup(drm, 0);
+
+	return 0;
+}
+
+static int st7586_remove(struct spi_device *spi)
+{
+	struct drm_device *drm = spi_get_drvdata(spi);
+
+	drm_dev_unplug(drm);
+	drm_atomic_helper_shutdown(drm);
+
+	return 0;
+}
+
+static void st7586_shutdown(struct spi_device *spi)
+{
+	drm_atomic_helper_shutdown(spi_get_drvdata(spi));
+}
+
+static struct spi_driver st7586_spi_driver = {
+	.driver = {
+		.name = "st7586",
+		.owner = THIS_MODULE,
+		.of_match_table = st7586_of_match,
+	},
+	.id_table = st7586_id,
+	.probe = st7586_probe,
+	.remove = st7586_remove,
+	.shutdown = st7586_shutdown,
+};
+module_spi_driver(st7586_spi_driver);
+
+MODULE_DESCRIPTION("Sitronix ST7586 DRM driver");
+MODULE_AUTHOR("David Lechner <david@lechnology.com>");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/gpu/drm/tiny/st7735r.c
@@ -0,0 +1,246 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * DRM driver for Sitronix ST7735R panels
+ *
+ * Copyright 2017 David Lechner <david@lechnology.com>
+ */
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/dma-buf.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/property.h>
+#include <linux/spi/spi.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_mipi_dbi.h>
+
+#define ST7735R_FRMCTR1		0xb1
+#define ST7735R_FRMCTR2		0xb2
+#define ST7735R_FRMCTR3		0xb3
+#define ST7735R_INVCTR		0xb4
+#define ST7735R_PWCTR1		0xc0
+#define ST7735R_PWCTR2		0xc1
+#define ST7735R_PWCTR3		0xc2
+#define ST7735R_PWCTR4		0xc3
+#define ST7735R_PWCTR5		0xc4
+#define ST7735R_VMCTR1		0xc5
+#define ST7735R_GAMCTRP1	0xe0
+#define ST7735R_GAMCTRN1	0xe1
+
+#define ST7735R_MY	BIT(7)
+#define ST7735R_MX	BIT(6)
+#define ST7735R_MV	BIT(5)
+
+static void jd_t18003_t01_pipe_enable(struct drm_simple_display_pipe *pipe,
+				      struct drm_crtc_state *crtc_state,
+				      struct drm_plane_state *plane_state)
+{
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
+	struct mipi_dbi *dbi = &dbidev->dbi;
+	int ret, idx;
+	u8 addr_mode;
+
+	if (!drm_dev_enter(pipe->crtc.dev, &idx))
+		return;
+
+	DRM_DEBUG_KMS("\n");
+
+	ret = mipi_dbi_poweron_reset(dbidev);
+	if (ret)
+		goto out_exit;
+
+	msleep(150);
+
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(500);
+
+	mipi_dbi_command(dbi, ST7735R_FRMCTR1, 0x01, 0x2c, 0x2d);
+	mipi_dbi_command(dbi, ST7735R_FRMCTR2, 0x01, 0x2c, 0x2d);
+	mipi_dbi_command(dbi, ST7735R_FRMCTR3, 0x01, 0x2c, 0x2d, 0x01, 0x2c,
+			 0x2d);
+	mipi_dbi_command(dbi, ST7735R_INVCTR, 0x07);
+	mipi_dbi_command(dbi, ST7735R_PWCTR1, 0xa2, 0x02, 0x84);
+	mipi_dbi_command(dbi, ST7735R_PWCTR2, 0xc5);
+	mipi_dbi_command(dbi, ST7735R_PWCTR3, 0x0a, 0x00);
+	mipi_dbi_command(dbi, ST7735R_PWCTR4, 0x8a, 0x2a);
+	mipi_dbi_command(dbi, ST7735R_PWCTR5, 0x8a, 0xee);
+	mipi_dbi_command(dbi, ST7735R_VMCTR1, 0x0e);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_INVERT_MODE);
+	switch (dbidev->rotation) {
+	default:
+		addr_mode = ST7735R_MX | ST7735R_MY;
+		break;
+	case 90:
+		addr_mode = ST7735R_MX | ST7735R_MV;
+		break;
+	case 180:
+		addr_mode = 0;
+		break;
+	case 270:
+		addr_mode = ST7735R_MY | ST7735R_MV;
+		break;
+	}
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT,
+			 MIPI_DCS_PIXEL_FMT_16BIT);
+	mipi_dbi_command(dbi, ST7735R_GAMCTRP1, 0x02, 0x1c, 0x07, 0x12, 0x37,
+			 0x32, 0x29, 0x2d, 0x29, 0x25, 0x2b, 0x39, 0x00, 0x01,
+			 0x03, 0x10);
+	mipi_dbi_command(dbi, ST7735R_GAMCTRN1, 0x03, 0x1d, 0x07, 0x06, 0x2e,
+			 0x2c, 0x29, 0x2d, 0x2e, 0x2e, 0x37, 0x3f, 0x00, 0x00,
+			 0x02, 0x10);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
+
+	msleep(100);
+
+	mipi_dbi_command(dbi, MIPI_DCS_ENTER_NORMAL_MODE);
+
+	msleep(20);
+
+	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
+out_exit:
+	drm_dev_exit(idx);
+}
+
+static const struct drm_simple_display_pipe_funcs jd_t18003_t01_pipe_funcs = {
+	.enable		= jd_t18003_t01_pipe_enable,
+	.disable	= mipi_dbi_pipe_disable,
+	.update		= mipi_dbi_pipe_update,
+	.prepare_fb	= drm_gem_fb_simple_display_pipe_prepare_fb,
+};
+
+static const struct drm_display_mode jd_t18003_t01_mode = {
+	DRM_SIMPLE_MODE(128, 160, 28, 35),
+};
+
+DEFINE_DRM_GEM_CMA_FOPS(st7735r_fops);
+
+static struct drm_driver st7735r_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
+	.fops			= &st7735r_fops,
+	.release		= mipi_dbi_release,
+	DRM_GEM_CMA_VMAP_DRIVER_OPS,
+	.debugfs_init		= mipi_dbi_debugfs_init,
+	.name			= "st7735r",
+	.desc			= "Sitronix ST7735R",
+	.date			= "20171128",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static const struct of_device_id st7735r_of_match[] = {
+	{ .compatible = "jianda,jd-t18003-t01" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, st7735r_of_match);
+
+static const struct spi_device_id st7735r_id[] = {
+	{ "jd-t18003-t01", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, st7735r_id);
+
+static int st7735r_probe(struct spi_device *spi)
+{
+	struct device *dev = &spi->dev;
+	struct mipi_dbi_dev *dbidev;
+	struct drm_device *drm;
+	struct mipi_dbi *dbi;
+	struct gpio_desc *dc;
+	u32 rotation = 0;
+	int ret;
+
+	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
+	if (!dbidev)
+		return -ENOMEM;
+
+	dbi = &dbidev->dbi;
+	drm = &dbidev->drm;
+	ret = devm_drm_dev_init(dev, drm, &st7735r_driver);
+	if (ret) {
+		kfree(dbidev);
+		return ret;
+	}
+
+	drm_mode_config_init(drm);
+
+	dbi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
+		return PTR_ERR(dbi->reset);
+	}
+
+	dc = devm_gpiod_get(dev, "dc", GPIOD_OUT_LOW);
+	if (IS_ERR(dc)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'dc'\n");
+		return PTR_ERR(dc);
+	}
+
+	dbidev->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(dbidev->backlight))
+		return PTR_ERR(dbidev->backlight);
+
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	ret = mipi_dbi_spi_init(spi, dbi, dc);
+	if (ret)
+		return ret;
+
+	/* Cannot read from Adafruit 1.8" display via SPI */
+	dbi->read_commands = NULL;
+
+	ret = mipi_dbi_dev_init(dbidev, &jd_t18003_t01_pipe_funcs, &jd_t18003_t01_mode, rotation);
+	if (ret)
+		return ret;
+
+	drm_mode_config_reset(drm);
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		return ret;
+
+	spi_set_drvdata(spi, drm);
+
+	drm_fbdev_generic_setup(drm, 0);
+
+	return 0;
+}
+
+static int st7735r_remove(struct spi_device *spi)
+{
+	struct drm_device *drm = spi_get_drvdata(spi);
+
+	drm_dev_unplug(drm);
+	drm_atomic_helper_shutdown(drm);
+
+	return 0;
+}
+
+static void st7735r_shutdown(struct spi_device *spi)
+{
+	drm_atomic_helper_shutdown(spi_get_drvdata(spi));
+}
+
+static struct spi_driver st7735r_spi_driver = {
+	.driver = {
+		.name = "st7735r",
+		.owner = THIS_MODULE,
+		.of_match_table = st7735r_of_match,
+	},
+	.id_table = st7735r_id,
+	.probe = st7735r_probe,
+	.remove = st7735r_remove,
+	.shutdown = st7735r_shutdown,
+};
+module_spi_driver(st7735r_spi_driver);
+
+MODULE_DESCRIPTION("Sitronix ST7735R DRM driver");
+MODULE_AUTHOR("David Lechner <david@lechnology.com>");
+MODULE_LICENSE("GPL");
--- a/drivers/gpu/drm/tinydrm/Kconfig
+++ /dev/null
@@ -1,89 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-config TINYDRM_HX8357D
-	tristate "DRM support for HX8357D display panels"
-	depends on DRM && SPI
-	select DRM_KMS_HELPER
-	select DRM_KMS_CMA_HELPER
-	select DRM_MIPI_DBI
-	select BACKLIGHT_CLASS_DEVICE
-	help
-	  DRM driver for the following HX8357D panels:
-	  * YX350HV15-T 3.5" 340x350 TFT (Adafruit 3.5")
-
-	  If M is selected the module will be called hx8357d.
-
-config TINYDRM_ILI9225
-	tristate "DRM support for ILI9225 display panels"
-	depends on DRM && SPI
-	select DRM_KMS_HELPER
-	select DRM_KMS_CMA_HELPER
-	select DRM_MIPI_DBI
-	help
-	  DRM driver for the following Ilitek ILI9225 panels:
-	  * No-name 2.2" color screen module
-
-	  If M is selected the module will be called ili9225.
-
-config TINYDRM_ILI9341
-	tristate "DRM support for ILI9341 display panels"
-	depends on DRM && SPI
-	select DRM_KMS_HELPER
-	select DRM_KMS_CMA_HELPER
-	select DRM_MIPI_DBI
-	select BACKLIGHT_CLASS_DEVICE
-	help
-	  DRM driver for the following Ilitek ILI9341 panels:
-	  * YX240QV29-T 2.4" 240x320 TFT (Adafruit 2.4")
-
-	  If M is selected the module will be called ili9341.
-
-config TINYDRM_MI0283QT
-	tristate "DRM support for MI0283QT"
-	depends on DRM && SPI
-	select DRM_KMS_HELPER
-	select DRM_KMS_CMA_HELPER
-	select DRM_MIPI_DBI
-	select BACKLIGHT_CLASS_DEVICE
-	help
-	  DRM driver for the Multi-Inno MI0283QT display panel
-	  If M is selected the module will be called mi0283qt.
-
-config TINYDRM_REPAPER
-	tristate "DRM support for Pervasive Displays RePaper panels (V231)"
-	depends on DRM && SPI
-	select DRM_KMS_HELPER
-	select DRM_KMS_CMA_HELPER
-	depends on THERMAL || !THERMAL
-	help
-	  DRM driver for the following Pervasive Displays panels:
-	  1.44" TFT EPD Panel (E1144CS021)
-	  1.90" TFT EPD Panel (E1190CS021)
-	  2.00" TFT EPD Panel (E2200CS021)
-	  2.71" TFT EPD Panel (E2271CS021)
-
-	  If M is selected the module will be called repaper.
-
-config TINYDRM_ST7586
-	tristate "DRM support for Sitronix ST7586 display panels"
-	depends on DRM && SPI
-	select DRM_KMS_HELPER
-	select DRM_KMS_CMA_HELPER
-	select DRM_MIPI_DBI
-	help
-	  DRM driver for the following Sitronix ST7586 panels:
-	  * LEGO MINDSTORMS EV3
-
-	  If M is selected the module will be called st7586.
-
-config TINYDRM_ST7735R
-	tristate "DRM support for Sitronix ST7735R display panels"
-	depends on DRM && SPI
-	select DRM_KMS_HELPER
-	select DRM_KMS_CMA_HELPER
-	select DRM_MIPI_DBI
-	select BACKLIGHT_CLASS_DEVICE
-	help
-	  DRM driver Sitronix ST7735R with one of the following LCDs:
-	  * JD-T18003-T01 1.8" 128x160 TFT
-
-	  If M is selected the module will be called st7735r.
--- a/drivers/gpu/drm/tinydrm/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-
-obj-$(CONFIG_TINYDRM_HX8357D)		+= hx8357d.o
-obj-$(CONFIG_TINYDRM_ILI9225)		+= ili9225.o
-obj-$(CONFIG_TINYDRM_ILI9341)		+= ili9341.o
-obj-$(CONFIG_TINYDRM_MI0283QT)		+= mi0283qt.o
-obj-$(CONFIG_TINYDRM_REPAPER)		+= repaper.o
-obj-$(CONFIG_TINYDRM_ST7586)		+= st7586.o
-obj-$(CONFIG_TINYDRM_ST7735R)		+= st7735r.o
--- a/drivers/gpu/drm/tinydrm/hx8357d.c
+++ /dev/null
@@ -1,304 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * DRM driver for the HX8357D LCD controller
- *
- * Copyright 2018 Broadcom
- * Copyright 2018 David Lechner <david@lechnology.com>
- * Copyright 2016 Noralf Trønnes
- * Copyright (C) 2015 Adafruit Industries
- * Copyright (C) 2013 Christian Vogelgsang
- */
-
-#include <linux/backlight.h>
-#include <linux/delay.h>
-#include <linux/gpio/consumer.h>
-#include <linux/module.h>
-#include <linux/property.h>
-#include <linux/spi/spi.h>
-
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_drv.h>
-#include <drm/drm_fb_helper.h>
-#include <drm/drm_gem_cma_helper.h>
-#include <drm/drm_gem_framebuffer_helper.h>
-#include <drm/drm_mipi_dbi.h>
-#include <drm/drm_modeset_helper.h>
-#include <video/mipi_display.h>
-
-#define HX8357D_SETOSC 0xb0
-#define HX8357D_SETPOWER 0xb1
-#define HX8357D_SETRGB 0xb3
-#define HX8357D_SETCYC 0xb3
-#define HX8357D_SETCOM 0xb6
-#define HX8357D_SETEXTC 0xb9
-#define HX8357D_SETSTBA 0xc0
-#define HX8357D_SETPANEL 0xcc
-#define HX8357D_SETGAMMA 0xe0
-
-#define HX8357D_MADCTL_MY  0x80
-#define HX8357D_MADCTL_MX  0x40
-#define HX8357D_MADCTL_MV  0x20
-#define HX8357D_MADCTL_ML  0x10
-#define HX8357D_MADCTL_RGB 0x00
-#define HX8357D_MADCTL_BGR 0x08
-#define HX8357D_MADCTL_MH  0x04
-
-static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
-			     struct drm_crtc_state *crtc_state,
-			     struct drm_plane_state *plane_state)
-{
-	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
-	struct mipi_dbi *dbi = &dbidev->dbi;
-	u8 addr_mode;
-	int ret, idx;
-
-	if (!drm_dev_enter(pipe->crtc.dev, &idx))
-		return;
-
-	DRM_DEBUG_KMS("\n");
-
-	ret = mipi_dbi_poweron_conditional_reset(dbidev);
-	if (ret < 0)
-		goto out_exit;
-	if (ret == 1)
-		goto out_enable;
-
-	/* setextc */
-	mipi_dbi_command(dbi, HX8357D_SETEXTC, 0xFF, 0x83, 0x57);
-	msleep(150);
-
-	/* setRGB which also enables SDO */
-	mipi_dbi_command(dbi, HX8357D_SETRGB, 0x00, 0x00, 0x06, 0x06);
-
-	/* -1.52V */
-	mipi_dbi_command(dbi, HX8357D_SETCOM, 0x25);
-
-	/* Normal mode 70Hz, Idle mode 55 Hz */
-	mipi_dbi_command(dbi, HX8357D_SETOSC, 0x68);
-
-	/* Set Panel - BGR, Gate direction swapped */
-	mipi_dbi_command(dbi, HX8357D_SETPANEL, 0x05);
-
-	mipi_dbi_command(dbi, HX8357D_SETPOWER,
-			 0x00,  /* Not deep standby */
-			 0x15,  /* BT */
-			 0x1C,  /* VSPR */
-			 0x1C,  /* VSNR */
-			 0x83,  /* AP */
-			 0xAA);  /* FS */
-
-	mipi_dbi_command(dbi, HX8357D_SETSTBA,
-			 0x50,  /* OPON normal */
-			 0x50,  /* OPON idle */
-			 0x01,  /* STBA */
-			 0x3C,  /* STBA */
-			 0x1E,  /* STBA */
-			 0x08);  /* GEN */
-
-	mipi_dbi_command(dbi, HX8357D_SETCYC,
-			 0x02,  /* NW 0x02 */
-			 0x40,  /* RTN */
-			 0x00,  /* DIV */
-			 0x2A,  /* DUM */
-			 0x2A,  /* DUM */
-			 0x0D,  /* GDON */
-			 0x78);  /* GDOFF */
-
-	mipi_dbi_command(dbi, HX8357D_SETGAMMA,
-			 0x02,
-			 0x0A,
-			 0x11,
-			 0x1d,
-			 0x23,
-			 0x35,
-			 0x41,
-			 0x4b,
-			 0x4b,
-			 0x42,
-			 0x3A,
-			 0x27,
-			 0x1B,
-			 0x08,
-			 0x09,
-			 0x03,
-			 0x02,
-			 0x0A,
-			 0x11,
-			 0x1d,
-			 0x23,
-			 0x35,
-			 0x41,
-			 0x4b,
-			 0x4b,
-			 0x42,
-			 0x3A,
-			 0x27,
-			 0x1B,
-			 0x08,
-			 0x09,
-			 0x03,
-			 0x00,
-			 0x01);
-
-	/* 16 bit */
-	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT,
-			 MIPI_DCS_PIXEL_FMT_16BIT);
-
-	/* TE off */
-	mipi_dbi_command(dbi, MIPI_DCS_SET_TEAR_ON, 0x00);
-
-	/* tear line */
-	mipi_dbi_command(dbi, MIPI_DCS_SET_TEAR_SCANLINE, 0x00, 0x02);
-
-	/* Exit Sleep */
-	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
-	msleep(150);
-
-	/* display on */
-	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
-	usleep_range(5000, 7000);
-
-out_enable:
-	switch (dbidev->rotation) {
-	default:
-		addr_mode = HX8357D_MADCTL_MX | HX8357D_MADCTL_MY;
-		break;
-	case 90:
-		addr_mode = HX8357D_MADCTL_MV | HX8357D_MADCTL_MY;
-		break;
-	case 180:
-		addr_mode = 0;
-		break;
-	case 270:
-		addr_mode = HX8357D_MADCTL_MV | HX8357D_MADCTL_MX;
-		break;
-	}
-	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
-	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
-out_exit:
-	drm_dev_exit(idx);
-}
-
-static const struct drm_simple_display_pipe_funcs hx8357d_pipe_funcs = {
-	.enable = yx240qv29_enable,
-	.disable = mipi_dbi_pipe_disable,
-	.update = mipi_dbi_pipe_update,
-	.prepare_fb = drm_gem_fb_simple_display_pipe_prepare_fb,
-};
-
-static const struct drm_display_mode yx350hv15_mode = {
-	DRM_SIMPLE_MODE(320, 480, 60, 75),
-};
-
-DEFINE_DRM_GEM_CMA_FOPS(hx8357d_fops);
-
-static struct drm_driver hx8357d_driver = {
-	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
-	.fops			= &hx8357d_fops,
-	.release		= mipi_dbi_release,
-	DRM_GEM_CMA_VMAP_DRIVER_OPS,
-	.debugfs_init		= mipi_dbi_debugfs_init,
-	.name			= "hx8357d",
-	.desc			= "HX8357D",
-	.date			= "20181023",
-	.major			= 1,
-	.minor			= 0,
-};
-
-static const struct of_device_id hx8357d_of_match[] = {
-	{ .compatible = "adafruit,yx350hv15" },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, hx8357d_of_match);
-
-static const struct spi_device_id hx8357d_id[] = {
-	{ "yx350hv15", 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(spi, hx8357d_id);
-
-static int hx8357d_probe(struct spi_device *spi)
-{
-	struct device *dev = &spi->dev;
-	struct mipi_dbi_dev *dbidev;
-	struct drm_device *drm;
-	struct gpio_desc *dc;
-	u32 rotation = 0;
-	int ret;
-
-	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
-	if (!dbidev)
-		return -ENOMEM;
-
-	drm = &dbidev->drm;
-	ret = devm_drm_dev_init(dev, drm, &hx8357d_driver);
-	if (ret) {
-		kfree(dbidev);
-		return ret;
-	}
-
-	drm_mode_config_init(drm);
-
-	dc = devm_gpiod_get(dev, "dc", GPIOD_OUT_LOW);
-	if (IS_ERR(dc)) {
-		DRM_DEV_ERROR(dev, "Failed to get gpio 'dc'\n");
-		return PTR_ERR(dc);
-	}
-
-	dbidev->backlight = devm_of_find_backlight(dev);
-	if (IS_ERR(dbidev->backlight))
-		return PTR_ERR(dbidev->backlight);
-
-	device_property_read_u32(dev, "rotation", &rotation);
-
-	ret = mipi_dbi_spi_init(spi, &dbidev->dbi, dc);
-	if (ret)
-		return ret;
-
-	ret = mipi_dbi_dev_init(dbidev, &hx8357d_pipe_funcs, &yx350hv15_mode, rotation);
-	if (ret)
-		return ret;
-
-	drm_mode_config_reset(drm);
-
-	ret = drm_dev_register(drm, 0);
-	if (ret)
-		return ret;
-
-	spi_set_drvdata(spi, drm);
-
-	drm_fbdev_generic_setup(drm, 0);
-
-	return 0;
-}
-
-static int hx8357d_remove(struct spi_device *spi)
-{
-	struct drm_device *drm = spi_get_drvdata(spi);
-
-	drm_dev_unplug(drm);
-	drm_atomic_helper_shutdown(drm);
-
-	return 0;
-}
-
-static void hx8357d_shutdown(struct spi_device *spi)
-{
-	drm_atomic_helper_shutdown(spi_get_drvdata(spi));
-}
-
-static struct spi_driver hx8357d_spi_driver = {
-	.driver = {
-		.name = "hx8357d",
-		.of_match_table = hx8357d_of_match,
-	},
-	.id_table = hx8357d_id,
-	.probe = hx8357d_probe,
-	.remove = hx8357d_remove,
-	.shutdown = hx8357d_shutdown,
-};
-module_spi_driver(hx8357d_spi_driver);
-
-MODULE_DESCRIPTION("HX8357D DRM driver");
-MODULE_AUTHOR("Eric Anholt <eric@anholt.net>");
-MODULE_LICENSE("GPL");
--- a/drivers/gpu/drm/tinydrm/ili9225.c
+++ /dev/null
@@ -1,470 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * DRM driver for Ilitek ILI9225 panels
- *
- * Copyright 2017 David Lechner <david@lechnology.com>
- *
- * Some code copied from mipi-dbi.c
- * Copyright 2016 Noralf Trønnes
- */
-
-#include <linux/delay.h>
-#include <linux/dma-buf.h>
-#include <linux/gpio/consumer.h>
-#include <linux/module.h>
-#include <linux/property.h>
-#include <linux/spi/spi.h>
-#include <video/mipi_display.h>
-
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_damage_helper.h>
-#include <drm/drm_drv.h>
-#include <drm/drm_fb_cma_helper.h>
-#include <drm/drm_fb_helper.h>
-#include <drm/drm_fourcc.h>
-#include <drm/drm_gem_cma_helper.h>
-#include <drm/drm_gem_framebuffer_helper.h>
-#include <drm/drm_mipi_dbi.h>
-#include <drm/drm_rect.h>
-#include <drm/drm_vblank.h>
-
-#define ILI9225_DRIVER_READ_CODE	0x00
-#define ILI9225_DRIVER_OUTPUT_CONTROL	0x01
-#define ILI9225_LCD_AC_DRIVING_CONTROL	0x02
-#define ILI9225_ENTRY_MODE		0x03
-#define ILI9225_DISPLAY_CONTROL_1	0x07
-#define ILI9225_BLANK_PERIOD_CONTROL_1	0x08
-#define ILI9225_FRAME_CYCLE_CONTROL	0x0b
-#define ILI9225_INTERFACE_CONTROL	0x0c
-#define ILI9225_OSCILLATION_CONTROL	0x0f
-#define ILI9225_POWER_CONTROL_1		0x10
-#define ILI9225_POWER_CONTROL_2		0x11
-#define ILI9225_POWER_CONTROL_3		0x12
-#define ILI9225_POWER_CONTROL_4		0x13
-#define ILI9225_POWER_CONTROL_5		0x14
-#define ILI9225_VCI_RECYCLING		0x15
-#define ILI9225_RAM_ADDRESS_SET_1	0x20
-#define ILI9225_RAM_ADDRESS_SET_2	0x21
-#define ILI9225_WRITE_DATA_TO_GRAM	0x22
-#define ILI9225_SOFTWARE_RESET		0x28
-#define ILI9225_GATE_SCAN_CONTROL	0x30
-#define ILI9225_VERTICAL_SCROLL_1	0x31
-#define ILI9225_VERTICAL_SCROLL_2	0x32
-#define ILI9225_VERTICAL_SCROLL_3	0x33
-#define ILI9225_PARTIAL_DRIVING_POS_1	0x34
-#define ILI9225_PARTIAL_DRIVING_POS_2	0x35
-#define ILI9225_HORIZ_WINDOW_ADDR_1	0x36
-#define ILI9225_HORIZ_WINDOW_ADDR_2	0x37
-#define ILI9225_VERT_WINDOW_ADDR_1	0x38
-#define ILI9225_VERT_WINDOW_ADDR_2	0x39
-#define ILI9225_GAMMA_CONTROL_1		0x50
-#define ILI9225_GAMMA_CONTROL_2		0x51
-#define ILI9225_GAMMA_CONTROL_3		0x52
-#define ILI9225_GAMMA_CONTROL_4		0x53
-#define ILI9225_GAMMA_CONTROL_5		0x54
-#define ILI9225_GAMMA_CONTROL_6		0x55
-#define ILI9225_GAMMA_CONTROL_7		0x56
-#define ILI9225_GAMMA_CONTROL_8		0x57
-#define ILI9225_GAMMA_CONTROL_9		0x58
-#define ILI9225_GAMMA_CONTROL_10	0x59
-
-static inline int ili9225_command(struct mipi_dbi *dbi, u8 cmd, u16 data)
-{
-	u8 par[2] = { data >> 8, data & 0xff };
-
-	return mipi_dbi_command_buf(dbi, cmd, par, 2);
-}
-
-static void ili9225_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
-{
-	struct drm_gem_cma_object *cma_obj = drm_fb_cma_get_gem_obj(fb, 0);
-	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(fb->dev);
-	unsigned int height = rect->y2 - rect->y1;
-	unsigned int width = rect->x2 - rect->x1;
-	struct mipi_dbi *dbi = &dbidev->dbi;
-	bool swap = dbi->swap_bytes;
-	u16 x_start, y_start;
-	u16 x1, x2, y1, y2;
-	int idx, ret = 0;
-	bool full;
-	void *tr;
-
-	if (!dbidev->enabled)
-		return;
-
-	if (!drm_dev_enter(fb->dev, &idx))
-		return;
-
-	full = width == fb->width && height == fb->height;
-
-	DRM_DEBUG_KMS("Flushing [FB:%d] " DRM_RECT_FMT "\n", fb->base.id, DRM_RECT_ARG(rect));
-
-	if (!dbi->dc || !full || swap ||
-	    fb->format->format == DRM_FORMAT_XRGB8888) {
-		tr = dbidev->tx_buf;
-		ret = mipi_dbi_buf_copy(dbidev->tx_buf, fb, rect, swap);
-		if (ret)
-			goto err_msg;
-	} else {
-		tr = cma_obj->vaddr;
-	}
-
-	switch (dbidev->rotation) {
-	default:
-		x1 = rect->x1;
-		x2 = rect->x2 - 1;
-		y1 = rect->y1;
-		y2 = rect->y2 - 1;
-		x_start = x1;
-		y_start = y1;
-		break;
-	case 90:
-		x1 = rect->y1;
-		x2 = rect->y2 - 1;
-		y1 = fb->width - rect->x2;
-		y2 = fb->width - rect->x1 - 1;
-		x_start = x1;
-		y_start = y2;
-		break;
-	case 180:
-		x1 = fb->width - rect->x2;
-		x2 = fb->width - rect->x1 - 1;
-		y1 = fb->height - rect->y2;
-		y2 = fb->height - rect->y1 - 1;
-		x_start = x2;
-		y_start = y2;
-		break;
-	case 270:
-		x1 = fb->height - rect->y2;
-		x2 = fb->height - rect->y1 - 1;
-		y1 = rect->x1;
-		y2 = rect->x2 - 1;
-		x_start = x2;
-		y_start = y1;
-		break;
-	}
-
-	ili9225_command(dbi, ILI9225_HORIZ_WINDOW_ADDR_1, x2);
-	ili9225_command(dbi, ILI9225_HORIZ_WINDOW_ADDR_2, x1);
-	ili9225_command(dbi, ILI9225_VERT_WINDOW_ADDR_1, y2);
-	ili9225_command(dbi, ILI9225_VERT_WINDOW_ADDR_2, y1);
-
-	ili9225_command(dbi, ILI9225_RAM_ADDRESS_SET_1, x_start);
-	ili9225_command(dbi, ILI9225_RAM_ADDRESS_SET_2, y_start);
-
-	ret = mipi_dbi_command_buf(dbi, ILI9225_WRITE_DATA_TO_GRAM, tr,
-				   width * height * 2);
-err_msg:
-	if (ret)
-		dev_err_once(fb->dev->dev, "Failed to update display %d\n", ret);
-
-	drm_dev_exit(idx);
-}
-
-static void ili9225_pipe_update(struct drm_simple_display_pipe *pipe,
-				struct drm_plane_state *old_state)
-{
-	struct drm_plane_state *state = pipe->plane.state;
-	struct drm_crtc *crtc = &pipe->crtc;
-	struct drm_rect rect;
-
-	if (drm_atomic_helper_damage_merged(old_state, state, &rect))
-		ili9225_fb_dirty(state->fb, &rect);
-
-	if (crtc->state->event) {
-		spin_lock_irq(&crtc->dev->event_lock);
-		drm_crtc_send_vblank_event(crtc, crtc->state->event);
-		spin_unlock_irq(&crtc->dev->event_lock);
-		crtc->state->event = NULL;
-	}
-}
-
-static void ili9225_pipe_enable(struct drm_simple_display_pipe *pipe,
-				struct drm_crtc_state *crtc_state,
-				struct drm_plane_state *plane_state)
-{
-	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
-	struct drm_framebuffer *fb = plane_state->fb;
-	struct device *dev = pipe->crtc.dev->dev;
-	struct mipi_dbi *dbi = &dbidev->dbi;
-	struct drm_rect rect = {
-		.x1 = 0,
-		.x2 = fb->width,
-		.y1 = 0,
-		.y2 = fb->height,
-	};
-	int ret, idx;
-	u8 am_id;
-
-	if (!drm_dev_enter(pipe->crtc.dev, &idx))
-		return;
-
-	DRM_DEBUG_KMS("\n");
-
-	mipi_dbi_hw_reset(dbi);
-
-	/*
-	 * There don't seem to be two example init sequences that match, so
-	 * using the one from the popular Arduino library for this display.
-	 * https://github.com/Nkawu/TFT_22_ILI9225/blob/master/src/TFT_22_ILI9225.cpp
-	 */
-
-	ret = ili9225_command(dbi, ILI9225_POWER_CONTROL_1, 0x0000);
-	if (ret) {
-		DRM_DEV_ERROR(dev, "Error sending command %d\n", ret);
-		goto out_exit;
-	}
-	ili9225_command(dbi, ILI9225_POWER_CONTROL_2, 0x0000);
-	ili9225_command(dbi, ILI9225_POWER_CONTROL_3, 0x0000);
-	ili9225_command(dbi, ILI9225_POWER_CONTROL_4, 0x0000);
-	ili9225_command(dbi, ILI9225_POWER_CONTROL_5, 0x0000);
-
-	msleep(40);
-
-	ili9225_command(dbi, ILI9225_POWER_CONTROL_2, 0x0018);
-	ili9225_command(dbi, ILI9225_POWER_CONTROL_3, 0x6121);
-	ili9225_command(dbi, ILI9225_POWER_CONTROL_4, 0x006f);
-	ili9225_command(dbi, ILI9225_POWER_CONTROL_5, 0x495f);
-	ili9225_command(dbi, ILI9225_POWER_CONTROL_1, 0x0800);
-
-	msleep(10);
-
-	ili9225_command(dbi, ILI9225_POWER_CONTROL_2, 0x103b);
-
-	msleep(50);
-
-	switch (dbidev->rotation) {
-	default:
-		am_id = 0x30;
-		break;
-	case 90:
-		am_id = 0x18;
-		break;
-	case 180:
-		am_id = 0x00;
-		break;
-	case 270:
-		am_id = 0x28;
-		break;
-	}
-	ili9225_command(dbi, ILI9225_DRIVER_OUTPUT_CONTROL, 0x011c);
-	ili9225_command(dbi, ILI9225_LCD_AC_DRIVING_CONTROL, 0x0100);
-	ili9225_command(dbi, ILI9225_ENTRY_MODE, 0x1000 | am_id);
-	ili9225_command(dbi, ILI9225_DISPLAY_CONTROL_1, 0x0000);
-	ili9225_command(dbi, ILI9225_BLANK_PERIOD_CONTROL_1, 0x0808);
-	ili9225_command(dbi, ILI9225_FRAME_CYCLE_CONTROL, 0x1100);
-	ili9225_command(dbi, ILI9225_INTERFACE_CONTROL, 0x0000);
-	ili9225_command(dbi, ILI9225_OSCILLATION_CONTROL, 0x0d01);
-	ili9225_command(dbi, ILI9225_VCI_RECYCLING, 0x0020);
-	ili9225_command(dbi, ILI9225_RAM_ADDRESS_SET_1, 0x0000);
-	ili9225_command(dbi, ILI9225_RAM_ADDRESS_SET_2, 0x0000);
-
-	ili9225_command(dbi, ILI9225_GATE_SCAN_CONTROL, 0x0000);
-	ili9225_command(dbi, ILI9225_VERTICAL_SCROLL_1, 0x00db);
-	ili9225_command(dbi, ILI9225_VERTICAL_SCROLL_2, 0x0000);
-	ili9225_command(dbi, ILI9225_VERTICAL_SCROLL_3, 0x0000);
-	ili9225_command(dbi, ILI9225_PARTIAL_DRIVING_POS_1, 0x00db);
-	ili9225_command(dbi, ILI9225_PARTIAL_DRIVING_POS_2, 0x0000);
-
-	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_1, 0x0000);
-	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_2, 0x0808);
-	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_3, 0x080a);
-	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_4, 0x000a);
-	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_5, 0x0a08);
-	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_6, 0x0808);
-	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_7, 0x0000);
-	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_8, 0x0a00);
-	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_9, 0x0710);
-	ili9225_command(dbi, ILI9225_GAMMA_CONTROL_10, 0x0710);
-
-	ili9225_command(dbi, ILI9225_DISPLAY_CONTROL_1, 0x0012);
-
-	msleep(50);
-
-	ili9225_command(dbi, ILI9225_DISPLAY_CONTROL_1, 0x1017);
-
-	dbidev->enabled = true;
-	ili9225_fb_dirty(fb, &rect);
-out_exit:
-	drm_dev_exit(idx);
-}
-
-static void ili9225_pipe_disable(struct drm_simple_display_pipe *pipe)
-{
-	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
-	struct mipi_dbi *dbi = &dbidev->dbi;
-
-	DRM_DEBUG_KMS("\n");
-
-	/*
-	 * This callback is not protected by drm_dev_enter/exit since we want to
-	 * turn off the display on regular driver unload. It's highly unlikely
-	 * that the underlying SPI controller is gone should this be called after
-	 * unplug.
-	 */
-
-	if (!dbidev->enabled)
-		return;
-
-	ili9225_command(dbi, ILI9225_DISPLAY_CONTROL_1, 0x0000);
-	msleep(50);
-	ili9225_command(dbi, ILI9225_POWER_CONTROL_2, 0x0007);
-	msleep(50);
-	ili9225_command(dbi, ILI9225_POWER_CONTROL_1, 0x0a02);
-
-	dbidev->enabled = false;
-}
-
-static int ili9225_dbi_command(struct mipi_dbi *dbi, u8 *cmd, u8 *par,
-			       size_t num)
-{
-	struct spi_device *spi = dbi->spi;
-	unsigned int bpw = 8;
-	u32 speed_hz;
-	int ret;
-
-	gpiod_set_value_cansleep(dbi->dc, 0);
-	speed_hz = mipi_dbi_spi_cmd_max_speed(spi, 1);
-	ret = mipi_dbi_spi_transfer(spi, speed_hz, 8, cmd, 1);
-	if (ret || !num)
-		return ret;
-
-	if (*cmd == ILI9225_WRITE_DATA_TO_GRAM && !dbi->swap_bytes)
-		bpw = 16;
-
-	gpiod_set_value_cansleep(dbi->dc, 1);
-	speed_hz = mipi_dbi_spi_cmd_max_speed(spi, num);
-
-	return mipi_dbi_spi_transfer(spi, speed_hz, bpw, par, num);
-}
-
-static const struct drm_simple_display_pipe_funcs ili9225_pipe_funcs = {
-	.enable		= ili9225_pipe_enable,
-	.disable	= ili9225_pipe_disable,
-	.update		= ili9225_pipe_update,
-	.prepare_fb	= drm_gem_fb_simple_display_pipe_prepare_fb,
-};
-
-static const struct drm_display_mode ili9225_mode = {
-	DRM_SIMPLE_MODE(176, 220, 35, 44),
-};
-
-DEFINE_DRM_GEM_CMA_FOPS(ili9225_fops);
-
-static struct drm_driver ili9225_driver = {
-	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
-	.fops			= &ili9225_fops,
-	.release		= mipi_dbi_release,
-	DRM_GEM_CMA_VMAP_DRIVER_OPS,
-	.name			= "ili9225",
-	.desc			= "Ilitek ILI9225",
-	.date			= "20171106",
-	.major			= 1,
-	.minor			= 0,
-};
-
-static const struct of_device_id ili9225_of_match[] = {
-	{ .compatible = "vot,v220hf01a-t" },
-	{},
-};
-MODULE_DEVICE_TABLE(of, ili9225_of_match);
-
-static const struct spi_device_id ili9225_id[] = {
-	{ "v220hf01a-t", 0 },
-	{ },
-};
-MODULE_DEVICE_TABLE(spi, ili9225_id);
-
-static int ili9225_probe(struct spi_device *spi)
-{
-	struct device *dev = &spi->dev;
-	struct mipi_dbi_dev *dbidev;
-	struct drm_device *drm;
-	struct mipi_dbi *dbi;
-	struct gpio_desc *rs;
-	u32 rotation = 0;
-	int ret;
-
-	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
-	if (!dbidev)
-		return -ENOMEM;
-
-	dbi = &dbidev->dbi;
-	drm = &dbidev->drm;
-	ret = devm_drm_dev_init(dev, drm, &ili9225_driver);
-	if (ret) {
-		kfree(dbidev);
-		return ret;
-	}
-
-	drm_mode_config_init(drm);
-
-	dbi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
-	if (IS_ERR(dbi->reset)) {
-		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
-		return PTR_ERR(dbi->reset);
-	}
-
-	rs = devm_gpiod_get(dev, "rs", GPIOD_OUT_LOW);
-	if (IS_ERR(rs)) {
-		DRM_DEV_ERROR(dev, "Failed to get gpio 'rs'\n");
-		return PTR_ERR(rs);
-	}
-
-	device_property_read_u32(dev, "rotation", &rotation);
-
-	ret = mipi_dbi_spi_init(spi, dbi, rs);
-	if (ret)
-		return ret;
-
-	/* override the command function set in  mipi_dbi_spi_init() */
-	dbi->command = ili9225_dbi_command;
-
-	ret = mipi_dbi_dev_init(dbidev, &ili9225_pipe_funcs, &ili9225_mode, rotation);
-	if (ret)
-		return ret;
-
-	drm_mode_config_reset(drm);
-
-	ret = drm_dev_register(drm, 0);
-	if (ret)
-		return ret;
-
-	spi_set_drvdata(spi, drm);
-
-	drm_fbdev_generic_setup(drm, 0);
-
-	return 0;
-}
-
-static int ili9225_remove(struct spi_device *spi)
-{
-	struct drm_device *drm = spi_get_drvdata(spi);
-
-	drm_dev_unplug(drm);
-	drm_atomic_helper_shutdown(drm);
-
-	return 0;
-}
-
-static void ili9225_shutdown(struct spi_device *spi)
-{
-	drm_atomic_helper_shutdown(spi_get_drvdata(spi));
-}
-
-static struct spi_driver ili9225_spi_driver = {
-	.driver = {
-		.name = "ili9225",
-		.owner = THIS_MODULE,
-		.of_match_table = ili9225_of_match,
-	},
-	.id_table = ili9225_id,
-	.probe = ili9225_probe,
-	.remove = ili9225_remove,
-	.shutdown = ili9225_shutdown,
-};
-module_spi_driver(ili9225_spi_driver);
-
-MODULE_DESCRIPTION("Ilitek ILI9225 DRM driver");
-MODULE_AUTHOR("David Lechner <david@lechnology.com>");
-MODULE_LICENSE("GPL");
--- a/drivers/gpu/drm/tinydrm/ili9341.c
+++ /dev/null
@@ -1,268 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * DRM driver for Ilitek ILI9341 panels
- *
- * Copyright 2018 David Lechner <david@lechnology.com>
- *
- * Based on mi0283qt.c:
- * Copyright 2016 Noralf Trønnes
- */
-
-#include <linux/backlight.h>
-#include <linux/delay.h>
-#include <linux/gpio/consumer.h>
-#include <linux/module.h>
-#include <linux/property.h>
-#include <linux/spi/spi.h>
-
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_drv.h>
-#include <drm/drm_fb_helper.h>
-#include <drm/drm_gem_cma_helper.h>
-#include <drm/drm_gem_framebuffer_helper.h>
-#include <drm/drm_mipi_dbi.h>
-#include <drm/drm_modeset_helper.h>
-#include <video/mipi_display.h>
-
-#define ILI9341_FRMCTR1		0xb1
-#define ILI9341_DISCTRL		0xb6
-#define ILI9341_ETMOD		0xb7
-
-#define ILI9341_PWCTRL1		0xc0
-#define ILI9341_PWCTRL2		0xc1
-#define ILI9341_VMCTRL1		0xc5
-#define ILI9341_VMCTRL2		0xc7
-#define ILI9341_PWCTRLA		0xcb
-#define ILI9341_PWCTRLB		0xcf
-
-#define ILI9341_PGAMCTRL	0xe0
-#define ILI9341_NGAMCTRL	0xe1
-#define ILI9341_DTCTRLA		0xe8
-#define ILI9341_DTCTRLB		0xea
-#define ILI9341_PWRSEQ		0xed
-
-#define ILI9341_EN3GAM		0xf2
-#define ILI9341_PUMPCTRL	0xf7
-
-#define ILI9341_MADCTL_BGR	BIT(3)
-#define ILI9341_MADCTL_MV	BIT(5)
-#define ILI9341_MADCTL_MX	BIT(6)
-#define ILI9341_MADCTL_MY	BIT(7)
-
-static void yx240qv29_enable(struct drm_simple_display_pipe *pipe,
-			     struct drm_crtc_state *crtc_state,
-			     struct drm_plane_state *plane_state)
-{
-	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
-	struct mipi_dbi *dbi = &dbidev->dbi;
-	u8 addr_mode;
-	int ret, idx;
-
-	if (!drm_dev_enter(pipe->crtc.dev, &idx))
-		return;
-
-	DRM_DEBUG_KMS("\n");
-
-	ret = mipi_dbi_poweron_conditional_reset(dbidev);
-	if (ret < 0)
-		goto out_exit;
-	if (ret == 1)
-		goto out_enable;
-
-	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);
-
-	mipi_dbi_command(dbi, ILI9341_PWCTRLB, 0x00, 0xc1, 0x30);
-	mipi_dbi_command(dbi, ILI9341_PWRSEQ, 0x64, 0x03, 0x12, 0x81);
-	mipi_dbi_command(dbi, ILI9341_DTCTRLA, 0x85, 0x00, 0x78);
-	mipi_dbi_command(dbi, ILI9341_PWCTRLA, 0x39, 0x2c, 0x00, 0x34, 0x02);
-	mipi_dbi_command(dbi, ILI9341_PUMPCTRL, 0x20);
-	mipi_dbi_command(dbi, ILI9341_DTCTRLB, 0x00, 0x00);
-
-	/* Power Control */
-	mipi_dbi_command(dbi, ILI9341_PWCTRL1, 0x23);
-	mipi_dbi_command(dbi, ILI9341_PWCTRL2, 0x10);
-	/* VCOM */
-	mipi_dbi_command(dbi, ILI9341_VMCTRL1, 0x3e, 0x28);
-	mipi_dbi_command(dbi, ILI9341_VMCTRL2, 0x86);
-
-	/* Memory Access Control */
-	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT, MIPI_DCS_PIXEL_FMT_16BIT);
-
-	/* Frame Rate */
-	mipi_dbi_command(dbi, ILI9341_FRMCTR1, 0x00, 0x1b);
-
-	/* Gamma */
-	mipi_dbi_command(dbi, ILI9341_EN3GAM, 0x00);
-	mipi_dbi_command(dbi, MIPI_DCS_SET_GAMMA_CURVE, 0x01);
-	mipi_dbi_command(dbi, ILI9341_PGAMCTRL,
-			 0x0f, 0x31, 0x2b, 0x0c, 0x0e, 0x08, 0x4e, 0xf1,
-			 0x37, 0x07, 0x10, 0x03, 0x0e, 0x09, 0x00);
-	mipi_dbi_command(dbi, ILI9341_NGAMCTRL,
-			 0x00, 0x0e, 0x14, 0x03, 0x11, 0x07, 0x31, 0xc1,
-			 0x48, 0x08, 0x0f, 0x0c, 0x31, 0x36, 0x0f);
-
-	/* DDRAM */
-	mipi_dbi_command(dbi, ILI9341_ETMOD, 0x07);
-
-	/* Display */
-	mipi_dbi_command(dbi, ILI9341_DISCTRL, 0x08, 0x82, 0x27, 0x00);
-	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
-	msleep(100);
-
-	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
-	msleep(100);
-
-out_enable:
-	switch (dbidev->rotation) {
-	default:
-		addr_mode = ILI9341_MADCTL_MX;
-		break;
-	case 90:
-		addr_mode = ILI9341_MADCTL_MV;
-		break;
-	case 180:
-		addr_mode = ILI9341_MADCTL_MY;
-		break;
-	case 270:
-		addr_mode = ILI9341_MADCTL_MV | ILI9341_MADCTL_MY |
-			    ILI9341_MADCTL_MX;
-		break;
-	}
-	addr_mode |= ILI9341_MADCTL_BGR;
-	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
-	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
-out_exit:
-	drm_dev_exit(idx);
-}
-
-static const struct drm_simple_display_pipe_funcs ili9341_pipe_funcs = {
-	.enable = yx240qv29_enable,
-	.disable = mipi_dbi_pipe_disable,
-	.update = mipi_dbi_pipe_update,
-	.prepare_fb = drm_gem_fb_simple_display_pipe_prepare_fb,
-};
-
-static const struct drm_display_mode yx240qv29_mode = {
-	DRM_SIMPLE_MODE(240, 320, 37, 49),
-};
-
-DEFINE_DRM_GEM_CMA_FOPS(ili9341_fops);
-
-static struct drm_driver ili9341_driver = {
-	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
-	.fops			= &ili9341_fops,
-	.release		= mipi_dbi_release,
-	DRM_GEM_CMA_VMAP_DRIVER_OPS,
-	.debugfs_init		= mipi_dbi_debugfs_init,
-	.name			= "ili9341",
-	.desc			= "Ilitek ILI9341",
-	.date			= "20180514",
-	.major			= 1,
-	.minor			= 0,
-};
-
-static const struct of_device_id ili9341_of_match[] = {
-	{ .compatible = "adafruit,yx240qv29" },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, ili9341_of_match);
-
-static const struct spi_device_id ili9341_id[] = {
-	{ "yx240qv29", 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(spi, ili9341_id);
-
-static int ili9341_probe(struct spi_device *spi)
-{
-	struct device *dev = &spi->dev;
-	struct mipi_dbi_dev *dbidev;
-	struct drm_device *drm;
-	struct mipi_dbi *dbi;
-	struct gpio_desc *dc;
-	u32 rotation = 0;
-	int ret;
-
-	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
-	if (!dbidev)
-		return -ENOMEM;
-
-	dbi = &dbidev->dbi;
-	drm = &dbidev->drm;
-	ret = devm_drm_dev_init(dev, drm, &ili9341_driver);
-	if (ret) {
-		kfree(dbidev);
-		return ret;
-	}
-
-	drm_mode_config_init(drm);
-
-	dbi->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
-	if (IS_ERR(dbi->reset)) {
-		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
-		return PTR_ERR(dbi->reset);
-	}
-
-	dc = devm_gpiod_get_optional(dev, "dc", GPIOD_OUT_LOW);
-	if (IS_ERR(dc)) {
-		DRM_DEV_ERROR(dev, "Failed to get gpio 'dc'\n");
-		return PTR_ERR(dc);
-	}
-
-	dbidev->backlight = devm_of_find_backlight(dev);
-	if (IS_ERR(dbidev->backlight))
-		return PTR_ERR(dbidev->backlight);
-
-	device_property_read_u32(dev, "rotation", &rotation);
-
-	ret = mipi_dbi_spi_init(spi, dbi, dc);
-	if (ret)
-		return ret;
-
-	ret = mipi_dbi_dev_init(dbidev, &ili9341_pipe_funcs, &yx240qv29_mode, rotation);
-	if (ret)
-		return ret;
-
-	drm_mode_config_reset(drm);
-
-	ret = drm_dev_register(drm, 0);
-	if (ret)
-		return ret;
-
-	spi_set_drvdata(spi, drm);
-
-	drm_fbdev_generic_setup(drm, 0);
-
-	return 0;
-}
-
-static int ili9341_remove(struct spi_device *spi)
-{
-	struct drm_device *drm = spi_get_drvdata(spi);
-
-	drm_dev_unplug(drm);
-	drm_atomic_helper_shutdown(drm);
-
-	return 0;
-}
-
-static void ili9341_shutdown(struct spi_device *spi)
-{
-	drm_atomic_helper_shutdown(spi_get_drvdata(spi));
-}
-
-static struct spi_driver ili9341_spi_driver = {
-	.driver = {
-		.name = "ili9341",
-		.of_match_table = ili9341_of_match,
-	},
-	.id_table = ili9341_id,
-	.probe = ili9341_probe,
-	.remove = ili9341_remove,
-	.shutdown = ili9341_shutdown,
-};
-module_spi_driver(ili9341_spi_driver);
-
-MODULE_DESCRIPTION("Ilitek ILI9341 DRM driver");
-MODULE_AUTHOR("David Lechner <david@lechnology.com>");
-MODULE_LICENSE("GPL");
--- a/drivers/gpu/drm/tinydrm/mi0283qt.c
+++ /dev/null
@@ -1,294 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * DRM driver for Multi-Inno MI0283QT panels
- *
- * Copyright 2016 Noralf Trønnes
- */
-
-#include <linux/backlight.h>
-#include <linux/delay.h>
-#include <linux/gpio/consumer.h>
-#include <linux/module.h>
-#include <linux/property.h>
-#include <linux/regulator/consumer.h>
-#include <linux/spi/spi.h>
-
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_drv.h>
-#include <drm/drm_fb_helper.h>
-#include <drm/drm_gem_cma_helper.h>
-#include <drm/drm_gem_framebuffer_helper.h>
-#include <drm/drm_mipi_dbi.h>
-#include <drm/drm_modeset_helper.h>
-#include <video/mipi_display.h>
-
-#define ILI9341_FRMCTR1		0xb1
-#define ILI9341_DISCTRL		0xb6
-#define ILI9341_ETMOD		0xb7
-
-#define ILI9341_PWCTRL1		0xc0
-#define ILI9341_PWCTRL2		0xc1
-#define ILI9341_VMCTRL1		0xc5
-#define ILI9341_VMCTRL2		0xc7
-#define ILI9341_PWCTRLA		0xcb
-#define ILI9341_PWCTRLB		0xcf
-
-#define ILI9341_PGAMCTRL	0xe0
-#define ILI9341_NGAMCTRL	0xe1
-#define ILI9341_DTCTRLA		0xe8
-#define ILI9341_DTCTRLB		0xea
-#define ILI9341_PWRSEQ		0xed
-
-#define ILI9341_EN3GAM		0xf2
-#define ILI9341_PUMPCTRL	0xf7
-
-#define ILI9341_MADCTL_BGR	BIT(3)
-#define ILI9341_MADCTL_MV	BIT(5)
-#define ILI9341_MADCTL_MX	BIT(6)
-#define ILI9341_MADCTL_MY	BIT(7)
-
-static void mi0283qt_enable(struct drm_simple_display_pipe *pipe,
-			    struct drm_crtc_state *crtc_state,
-			    struct drm_plane_state *plane_state)
-{
-	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
-	struct mipi_dbi *dbi = &dbidev->dbi;
-	u8 addr_mode;
-	int ret, idx;
-
-	if (!drm_dev_enter(pipe->crtc.dev, &idx))
-		return;
-
-	DRM_DEBUG_KMS("\n");
-
-	ret = mipi_dbi_poweron_conditional_reset(dbidev);
-	if (ret < 0)
-		goto out_exit;
-	if (ret == 1)
-		goto out_enable;
-
-	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);
-
-	mipi_dbi_command(dbi, ILI9341_PWCTRLB, 0x00, 0x83, 0x30);
-	mipi_dbi_command(dbi, ILI9341_PWRSEQ, 0x64, 0x03, 0x12, 0x81);
-	mipi_dbi_command(dbi, ILI9341_DTCTRLA, 0x85, 0x01, 0x79);
-	mipi_dbi_command(dbi, ILI9341_PWCTRLA, 0x39, 0x2c, 0x00, 0x34, 0x02);
-	mipi_dbi_command(dbi, ILI9341_PUMPCTRL, 0x20);
-	mipi_dbi_command(dbi, ILI9341_DTCTRLB, 0x00, 0x00);
-
-	/* Power Control */
-	mipi_dbi_command(dbi, ILI9341_PWCTRL1, 0x26);
-	mipi_dbi_command(dbi, ILI9341_PWCTRL2, 0x11);
-	/* VCOM */
-	mipi_dbi_command(dbi, ILI9341_VMCTRL1, 0x35, 0x3e);
-	mipi_dbi_command(dbi, ILI9341_VMCTRL2, 0xbe);
-
-	/* Memory Access Control */
-	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT, MIPI_DCS_PIXEL_FMT_16BIT);
-
-	/* Frame Rate */
-	mipi_dbi_command(dbi, ILI9341_FRMCTR1, 0x00, 0x1b);
-
-	/* Gamma */
-	mipi_dbi_command(dbi, ILI9341_EN3GAM, 0x08);
-	mipi_dbi_command(dbi, MIPI_DCS_SET_GAMMA_CURVE, 0x01);
-	mipi_dbi_command(dbi, ILI9341_PGAMCTRL,
-		       0x1f, 0x1a, 0x18, 0x0a, 0x0f, 0x06, 0x45, 0x87,
-		       0x32, 0x0a, 0x07, 0x02, 0x07, 0x05, 0x00);
-	mipi_dbi_command(dbi, ILI9341_NGAMCTRL,
-		       0x00, 0x25, 0x27, 0x05, 0x10, 0x09, 0x3a, 0x78,
-		       0x4d, 0x05, 0x18, 0x0d, 0x38, 0x3a, 0x1f);
-
-	/* DDRAM */
-	mipi_dbi_command(dbi, ILI9341_ETMOD, 0x07);
-
-	/* Display */
-	mipi_dbi_command(dbi, ILI9341_DISCTRL, 0x0a, 0x82, 0x27, 0x00);
-	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
-	msleep(100);
-
-	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
-	msleep(100);
-
-out_enable:
-	/* The PiTFT (ili9340) has a hardware reset circuit that
-	 * resets only on power-on and not on each reboot through
-	 * a gpio like the rpi-display does.
-	 * As a result, we need to always apply the rotation value
-	 * regardless of the display "on/off" state.
-	 */
-	switch (dbidev->rotation) {
-	default:
-		addr_mode = ILI9341_MADCTL_MV | ILI9341_MADCTL_MY |
-			    ILI9341_MADCTL_MX;
-		break;
-	case 90:
-		addr_mode = ILI9341_MADCTL_MY;
-		break;
-	case 180:
-		addr_mode = ILI9341_MADCTL_MV;
-		break;
-	case 270:
-		addr_mode = ILI9341_MADCTL_MX;
-		break;
-	}
-	addr_mode |= ILI9341_MADCTL_BGR;
-	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
-	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
-out_exit:
-	drm_dev_exit(idx);
-}
-
-static const struct drm_simple_display_pipe_funcs mi0283qt_pipe_funcs = {
-	.enable = mi0283qt_enable,
-	.disable = mipi_dbi_pipe_disable,
-	.update = mipi_dbi_pipe_update,
-	.prepare_fb = drm_gem_fb_simple_display_pipe_prepare_fb,
-};
-
-static const struct drm_display_mode mi0283qt_mode = {
-	DRM_SIMPLE_MODE(320, 240, 58, 43),
-};
-
-DEFINE_DRM_GEM_CMA_FOPS(mi0283qt_fops);
-
-static struct drm_driver mi0283qt_driver = {
-	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
-	.fops			= &mi0283qt_fops,
-	.release		= mipi_dbi_release,
-	DRM_GEM_CMA_VMAP_DRIVER_OPS,
-	.debugfs_init		= mipi_dbi_debugfs_init,
-	.name			= "mi0283qt",
-	.desc			= "Multi-Inno MI0283QT",
-	.date			= "20160614",
-	.major			= 1,
-	.minor			= 0,
-};
-
-static const struct of_device_id mi0283qt_of_match[] = {
-	{ .compatible = "multi-inno,mi0283qt" },
-	{},
-};
-MODULE_DEVICE_TABLE(of, mi0283qt_of_match);
-
-static const struct spi_device_id mi0283qt_id[] = {
-	{ "mi0283qt", 0 },
-	{ },
-};
-MODULE_DEVICE_TABLE(spi, mi0283qt_id);
-
-static int mi0283qt_probe(struct spi_device *spi)
-{
-	struct device *dev = &spi->dev;
-	struct mipi_dbi_dev *dbidev;
-	struct drm_device *drm;
-	struct mipi_dbi *dbi;
-	struct gpio_desc *dc;
-	u32 rotation = 0;
-	int ret;
-
-	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
-	if (!dbidev)
-		return -ENOMEM;
-
-	dbi = &dbidev->dbi;
-	drm = &dbidev->drm;
-	ret = devm_drm_dev_init(dev, drm, &mi0283qt_driver);
-	if (ret) {
-		kfree(dbidev);
-		return ret;
-	}
-
-	drm_mode_config_init(drm);
-
-	dbi->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
-	if (IS_ERR(dbi->reset)) {
-		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
-		return PTR_ERR(dbi->reset);
-	}
-
-	dc = devm_gpiod_get_optional(dev, "dc", GPIOD_OUT_LOW);
-	if (IS_ERR(dc)) {
-		DRM_DEV_ERROR(dev, "Failed to get gpio 'dc'\n");
-		return PTR_ERR(dc);
-	}
-
-	dbidev->regulator = devm_regulator_get(dev, "power");
-	if (IS_ERR(dbidev->regulator))
-		return PTR_ERR(dbidev->regulator);
-
-	dbidev->backlight = devm_of_find_backlight(dev);
-	if (IS_ERR(dbidev->backlight))
-		return PTR_ERR(dbidev->backlight);
-
-	device_property_read_u32(dev, "rotation", &rotation);
-
-	ret = mipi_dbi_spi_init(spi, dbi, dc);
-	if (ret)
-		return ret;
-
-	ret = mipi_dbi_dev_init(dbidev, &mi0283qt_pipe_funcs, &mi0283qt_mode, rotation);
-	if (ret)
-		return ret;
-
-	drm_mode_config_reset(drm);
-
-	ret = drm_dev_register(drm, 0);
-	if (ret)
-		return ret;
-
-	spi_set_drvdata(spi, drm);
-
-	drm_fbdev_generic_setup(drm, 0);
-
-	return 0;
-}
-
-static int mi0283qt_remove(struct spi_device *spi)
-{
-	struct drm_device *drm = spi_get_drvdata(spi);
-
-	drm_dev_unplug(drm);
-	drm_atomic_helper_shutdown(drm);
-
-	return 0;
-}
-
-static void mi0283qt_shutdown(struct spi_device *spi)
-{
-	drm_atomic_helper_shutdown(spi_get_drvdata(spi));
-}
-
-static int __maybe_unused mi0283qt_pm_suspend(struct device *dev)
-{
-	return drm_mode_config_helper_suspend(dev_get_drvdata(dev));
-}
-
-static int __maybe_unused mi0283qt_pm_resume(struct device *dev)
-{
-	drm_mode_config_helper_resume(dev_get_drvdata(dev));
-
-	return 0;
-}
-
-static const struct dev_pm_ops mi0283qt_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(mi0283qt_pm_suspend, mi0283qt_pm_resume)
-};
-
-static struct spi_driver mi0283qt_spi_driver = {
-	.driver = {
-		.name = "mi0283qt",
-		.owner = THIS_MODULE,
-		.of_match_table = mi0283qt_of_match,
-		.pm = &mi0283qt_pm_ops,
-	},
-	.id_table = mi0283qt_id,
-	.probe = mi0283qt_probe,
-	.remove = mi0283qt_remove,
-	.shutdown = mi0283qt_shutdown,
-};
-module_spi_driver(mi0283qt_spi_driver);
-
-MODULE_DESCRIPTION("Multi-Inno MI0283QT DRM driver");
-MODULE_AUTHOR("Noralf Trønnes");
-MODULE_LICENSE("GPL");
--- a/drivers/gpu/drm/tinydrm/repaper.c
+++ /dev/null
@@ -1,1212 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * DRM driver for Pervasive Displays RePaper branded e-ink panels
- *
- * Copyright 2013-2017 Pervasive Displays, Inc.
- * Copyright 2017 Noralf Trønnes
- *
- * The driver supports:
- * Material Film: Aurora Mb (V231)
- * Driver IC: G2 (eTC)
- *
- * The controller code was taken from the userspace driver:
- * https://github.com/repaper/gratis
- */
-
-#include <linux/delay.h>
-#include <linux/dma-buf.h>
-#include <linux/gpio/consumer.h>
-#include <linux/module.h>
-#include <linux/of_device.h>
-#include <linux/sched/clock.h>
-#include <linux/spi/spi.h>
-#include <linux/thermal.h>
-
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_connector.h>
-#include <drm/drm_damage_helper.h>
-#include <drm/drm_drv.h>
-#include <drm/drm_fb_cma_helper.h>
-#include <drm/drm_fb_helper.h>
-#include <drm/drm_format_helper.h>
-#include <drm/drm_gem_cma_helper.h>
-#include <drm/drm_gem_framebuffer_helper.h>
-#include <drm/drm_modes.h>
-#include <drm/drm_rect.h>
-#include <drm/drm_vblank.h>
-#include <drm/drm_probe_helper.h>
-#include <drm/drm_simple_kms_helper.h>
-
-#define REPAPER_RID_G2_COG_ID	0x12
-
-enum repaper_model {
-	E1144CS021 = 1,
-	E1190CS021,
-	E2200CS021,
-	E2271CS021,
-};
-
-enum repaper_stage {         /* Image pixel -> Display pixel */
-	REPAPER_COMPENSATE,  /* B -> W, W -> B (Current Image) */
-	REPAPER_WHITE,       /* B -> N, W -> W (Current Image) */
-	REPAPER_INVERSE,     /* B -> N, W -> B (New Image) */
-	REPAPER_NORMAL       /* B -> B, W -> W (New Image) */
-};
-
-enum repaper_epd_border_byte {
-	REPAPER_BORDER_BYTE_NONE,
-	REPAPER_BORDER_BYTE_ZERO,
-	REPAPER_BORDER_BYTE_SET,
-};
-
-struct repaper_epd {
-	struct drm_device drm;
-	struct drm_simple_display_pipe pipe;
-	const struct drm_display_mode *mode;
-	struct drm_connector connector;
-	struct spi_device *spi;
-
-	struct gpio_desc *panel_on;
-	struct gpio_desc *border;
-	struct gpio_desc *discharge;
-	struct gpio_desc *reset;
-	struct gpio_desc *busy;
-
-	struct thermal_zone_device *thermal;
-
-	unsigned int height;
-	unsigned int width;
-	unsigned int bytes_per_scan;
-	const u8 *channel_select;
-	unsigned int stage_time;
-	unsigned int factored_stage_time;
-	bool middle_scan;
-	bool pre_border_byte;
-	enum repaper_epd_border_byte border_byte;
-
-	u8 *line_buffer;
-	void *current_frame;
-
-	bool enabled;
-	bool cleared;
-	bool partial;
-};
-
-static inline struct repaper_epd *drm_to_epd(struct drm_device *drm)
-{
-	return container_of(drm, struct repaper_epd, drm);
-}
-
-static int repaper_spi_transfer(struct spi_device *spi, u8 header,
-				const void *tx, void *rx, size_t len)
-{
-	void *txbuf = NULL, *rxbuf = NULL;
-	struct spi_transfer tr[2] = {};
-	u8 *headerbuf;
-	int ret;
-
-	headerbuf = kmalloc(1, GFP_KERNEL);
-	if (!headerbuf)
-		return -ENOMEM;
-
-	headerbuf[0] = header;
-	tr[0].tx_buf = headerbuf;
-	tr[0].len = 1;
-
-	/* Stack allocated tx? */
-	if (tx && len <= 32) {
-		txbuf = kmemdup(tx, len, GFP_KERNEL);
-		if (!txbuf) {
-			ret = -ENOMEM;
-			goto out_free;
-		}
-	}
-
-	if (rx) {
-		rxbuf = kmalloc(len, GFP_KERNEL);
-		if (!rxbuf) {
-			ret = -ENOMEM;
-			goto out_free;
-		}
-	}
-
-	tr[1].tx_buf = txbuf ? txbuf : tx;
-	tr[1].rx_buf = rxbuf;
-	tr[1].len = len;
-
-	ndelay(80);
-	ret = spi_sync_transfer(spi, tr, 2);
-	if (rx && !ret)
-		memcpy(rx, rxbuf, len);
-
-out_free:
-	kfree(headerbuf);
-	kfree(txbuf);
-	kfree(rxbuf);
-
-	return ret;
-}
-
-static int repaper_write_buf(struct spi_device *spi, u8 reg,
-			     const u8 *buf, size_t len)
-{
-	int ret;
-
-	ret = repaper_spi_transfer(spi, 0x70, &reg, NULL, 1);
-	if (ret)
-		return ret;
-
-	return repaper_spi_transfer(spi, 0x72, buf, NULL, len);
-}
-
-static int repaper_write_val(struct spi_device *spi, u8 reg, u8 val)
-{
-	return repaper_write_buf(spi, reg, &val, 1);
-}
-
-static int repaper_read_val(struct spi_device *spi, u8 reg)
-{
-	int ret;
-	u8 val;
-
-	ret = repaper_spi_transfer(spi, 0x70, &reg, NULL, 1);
-	if (ret)
-		return ret;
-
-	ret = repaper_spi_transfer(spi, 0x73, NULL, &val, 1);
-
-	return ret ? ret : val;
-}
-
-static int repaper_read_id(struct spi_device *spi)
-{
-	int ret;
-	u8 id;
-
-	ret = repaper_spi_transfer(spi, 0x71, NULL, &id, 1);
-
-	return ret ? ret : id;
-}
-
-static void repaper_spi_mosi_low(struct spi_device *spi)
-{
-	const u8 buf[1] = { 0 };
-
-	spi_write(spi, buf, 1);
-}
-
-/* pixels on display are numbered from 1 so even is actually bits 1,3,5,... */
-static void repaper_even_pixels(struct repaper_epd *epd, u8 **pp,
-				const u8 *data, u8 fixed_value, const u8 *mask,
-				enum repaper_stage stage)
-{
-	unsigned int b;
-
-	for (b = 0; b < (epd->width / 8); b++) {
-		if (data) {
-			u8 pixels = data[b] & 0xaa;
-			u8 pixel_mask = 0xff;
-			u8 p1, p2, p3, p4;
-
-			if (mask) {
-				pixel_mask = (mask[b] ^ pixels) & 0xaa;
-				pixel_mask |= pixel_mask >> 1;
-			}
-
-			switch (stage) {
-			case REPAPER_COMPENSATE: /* B -> W, W -> B (Current) */
-				pixels = 0xaa | ((pixels ^ 0xaa) >> 1);
-				break;
-			case REPAPER_WHITE:      /* B -> N, W -> W (Current) */
-				pixels = 0x55 + ((pixels ^ 0xaa) >> 1);
-				break;
-			case REPAPER_INVERSE:    /* B -> N, W -> B (New) */
-				pixels = 0x55 | (pixels ^ 0xaa);
-				break;
-			case REPAPER_NORMAL:     /* B -> B, W -> W (New) */
-				pixels = 0xaa | (pixels >> 1);
-				break;
-			}
-
-			pixels = (pixels & pixel_mask) | (~pixel_mask & 0x55);
-			p1 = (pixels >> 6) & 0x03;
-			p2 = (pixels >> 4) & 0x03;
-			p3 = (pixels >> 2) & 0x03;
-			p4 = (pixels >> 0) & 0x03;
-			pixels = (p1 << 0) | (p2 << 2) | (p3 << 4) | (p4 << 6);
-			*(*pp)++ = pixels;
-		} else {
-			*(*pp)++ = fixed_value;
-		}
-	}
-}
-
-/* pixels on display are numbered from 1 so odd is actually bits 0,2,4,... */
-static void repaper_odd_pixels(struct repaper_epd *epd, u8 **pp,
-			       const u8 *data, u8 fixed_value, const u8 *mask,
-			       enum repaper_stage stage)
-{
-	unsigned int b;
-
-	for (b = epd->width / 8; b > 0; b--) {
-		if (data) {
-			u8 pixels = data[b - 1] & 0x55;
-			u8 pixel_mask = 0xff;
-
-			if (mask) {
-				pixel_mask = (mask[b - 1] ^ pixels) & 0x55;
-				pixel_mask |= pixel_mask << 1;
-			}
-
-			switch (stage) {
-			case REPAPER_COMPENSATE: /* B -> W, W -> B (Current) */
-				pixels = 0xaa | (pixels ^ 0x55);
-				break;
-			case REPAPER_WHITE:      /* B -> N, W -> W (Current) */
-				pixels = 0x55 + (pixels ^ 0x55);
-				break;
-			case REPAPER_INVERSE:    /* B -> N, W -> B (New) */
-				pixels = 0x55 | ((pixels ^ 0x55) << 1);
-				break;
-			case REPAPER_NORMAL:     /* B -> B, W -> W (New) */
-				pixels = 0xaa | pixels;
-				break;
-			}
-
-			pixels = (pixels & pixel_mask) | (~pixel_mask & 0x55);
-			*(*pp)++ = pixels;
-		} else {
-			*(*pp)++ = fixed_value;
-		}
-	}
-}
-
-/* interleave bits: (byte)76543210 -> (16 bit).7.6.5.4.3.2.1 */
-static inline u16 repaper_interleave_bits(u16 value)
-{
-	value = (value | (value << 4)) & 0x0f0f;
-	value = (value | (value << 2)) & 0x3333;
-	value = (value | (value << 1)) & 0x5555;
-
-	return value;
-}
-
-/* pixels on display are numbered from 1 */
-static void repaper_all_pixels(struct repaper_epd *epd, u8 **pp,
-			       const u8 *data, u8 fixed_value, const u8 *mask,
-			       enum repaper_stage stage)
-{
-	unsigned int b;
-
-	for (b = epd->width / 8; b > 0; b--) {
-		if (data) {
-			u16 pixels = repaper_interleave_bits(data[b - 1]);
-			u16 pixel_mask = 0xffff;
-
-			if (mask) {
-				pixel_mask = repaper_interleave_bits(mask[b - 1]);
-
-				pixel_mask = (pixel_mask ^ pixels) & 0x5555;
-				pixel_mask |= pixel_mask << 1;
-			}
-
-			switch (stage) {
-			case REPAPER_COMPENSATE: /* B -> W, W -> B (Current) */
-				pixels = 0xaaaa | (pixels ^ 0x5555);
-				break;
-			case REPAPER_WHITE:      /* B -> N, W -> W (Current) */
-				pixels = 0x5555 + (pixels ^ 0x5555);
-				break;
-			case REPAPER_INVERSE:    /* B -> N, W -> B (New) */
-				pixels = 0x5555 | ((pixels ^ 0x5555) << 1);
-				break;
-			case REPAPER_NORMAL:     /* B -> B, W -> W (New) */
-				pixels = 0xaaaa | pixels;
-				break;
-			}
-
-			pixels = (pixels & pixel_mask) | (~pixel_mask & 0x5555);
-			*(*pp)++ = pixels >> 8;
-			*(*pp)++ = pixels;
-		} else {
-			*(*pp)++ = fixed_value;
-			*(*pp)++ = fixed_value;
-		}
-	}
-}
-
-/* output one line of scan and data bytes to the display */
-static void repaper_one_line(struct repaper_epd *epd, unsigned int line,
-			     const u8 *data, u8 fixed_value, const u8 *mask,
-			     enum repaper_stage stage)
-{
-	u8 *p = epd->line_buffer;
-	unsigned int b;
-
-	repaper_spi_mosi_low(epd->spi);
-
-	if (epd->pre_border_byte)
-		*p++ = 0x00;
-
-	if (epd->middle_scan) {
-		/* data bytes */
-		repaper_odd_pixels(epd, &p, data, fixed_value, mask, stage);
-
-		/* scan line */
-		for (b = epd->bytes_per_scan; b > 0; b--) {
-			if (line / 4 == b - 1)
-				*p++ = 0x03 << (2 * (line & 0x03));
-			else
-				*p++ = 0x00;
-		}
-
-		/* data bytes */
-		repaper_even_pixels(epd, &p, data, fixed_value, mask, stage);
-	} else {
-		/*
-		 * even scan line, but as lines on display are numbered from 1,
-		 * line: 1,3,5,...
-		 */
-		for (b = 0; b < epd->bytes_per_scan; b++) {
-			if (0 != (line & 0x01) && line / 8 == b)
-				*p++ = 0xc0 >> (line & 0x06);
-			else
-				*p++ = 0x00;
-		}
-
-		/* data bytes */
-		repaper_all_pixels(epd, &p, data, fixed_value, mask, stage);
-
-		/*
-		 * odd scan line, but as lines on display are numbered from 1,
-		 * line: 0,2,4,6,...
-		 */
-		for (b = epd->bytes_per_scan; b > 0; b--) {
-			if (0 == (line & 0x01) && line / 8 == b - 1)
-				*p++ = 0x03 << (line & 0x06);
-			else
-				*p++ = 0x00;
-		}
-	}
-
-	switch (epd->border_byte) {
-	case REPAPER_BORDER_BYTE_NONE:
-		break;
-
-	case REPAPER_BORDER_BYTE_ZERO:
-		*p++ = 0x00;
-		break;
-
-	case REPAPER_BORDER_BYTE_SET:
-		switch (stage) {
-		case REPAPER_COMPENSATE:
-		case REPAPER_WHITE:
-		case REPAPER_INVERSE:
-			*p++ = 0x00;
-			break;
-		case REPAPER_NORMAL:
-			*p++ = 0xaa;
-			break;
-		}
-		break;
-	}
-
-	repaper_write_buf(epd->spi, 0x0a, epd->line_buffer,
-			  p - epd->line_buffer);
-
-	/* Output data to panel */
-	repaper_write_val(epd->spi, 0x02, 0x07);
-
-	repaper_spi_mosi_low(epd->spi);
-}
-
-static void repaper_frame_fixed(struct repaper_epd *epd, u8 fixed_value,
-				enum repaper_stage stage)
-{
-	unsigned int line;
-
-	for (line = 0; line < epd->height; line++)
-		repaper_one_line(epd, line, NULL, fixed_value, NULL, stage);
-}
-
-static void repaper_frame_data(struct repaper_epd *epd, const u8 *image,
-			       const u8 *mask, enum repaper_stage stage)
-{
-	unsigned int line;
-
-	if (!mask) {
-		for (line = 0; line < epd->height; line++) {
-			repaper_one_line(epd, line,
-					 &image[line * (epd->width / 8)],
-					 0, NULL, stage);
-		}
-	} else {
-		for (line = 0; line < epd->height; line++) {
-			size_t n = line * epd->width / 8;
-
-			repaper_one_line(epd, line, &image[n], 0, &mask[n],
-					 stage);
-		}
-	}
-}
-
-static void repaper_frame_fixed_repeat(struct repaper_epd *epd, u8 fixed_value,
-				       enum repaper_stage stage)
-{
-	u64 start = local_clock();
-	u64 end = start + (epd->factored_stage_time * 1000 * 1000);
-
-	do {
-		repaper_frame_fixed(epd, fixed_value, stage);
-	} while (local_clock() < end);
-}
-
-static void repaper_frame_data_repeat(struct repaper_epd *epd, const u8 *image,
-				      const u8 *mask, enum repaper_stage stage)
-{
-	u64 start = local_clock();
-	u64 end = start + (epd->factored_stage_time * 1000 * 1000);
-
-	do {
-		repaper_frame_data(epd, image, mask, stage);
-	} while (local_clock() < end);
-}
-
-static void repaper_get_temperature(struct repaper_epd *epd)
-{
-	int ret, temperature = 0;
-	unsigned int factor10x;
-
-	if (!epd->thermal)
-		return;
-
-	ret = thermal_zone_get_temp(epd->thermal, &temperature);
-	if (ret) {
-		DRM_DEV_ERROR(&epd->spi->dev, "Failed to get temperature (%d)\n", ret);
-		return;
-	}
-
-	temperature /= 1000;
-
-	if (temperature <= -10)
-		factor10x = 170;
-	else if (temperature <= -5)
-		factor10x = 120;
-	else if (temperature <= 5)
-		factor10x = 80;
-	else if (temperature <= 10)
-		factor10x = 40;
-	else if (temperature <= 15)
-		factor10x = 30;
-	else if (temperature <= 20)
-		factor10x = 20;
-	else if (temperature <= 40)
-		factor10x = 10;
-	else
-		factor10x = 7;
-
-	epd->factored_stage_time = epd->stage_time * factor10x / 10;
-}
-
-static void repaper_gray8_to_mono_reversed(u8 *buf, u32 width, u32 height)
-{
-	u8 *gray8 = buf, *mono = buf;
-	int y, xb, i;
-
-	for (y = 0; y < height; y++)
-		for (xb = 0; xb < width / 8; xb++) {
-			u8 byte = 0x00;
-
-			for (i = 0; i < 8; i++) {
-				int x = xb * 8 + i;
-
-				byte >>= 1;
-				if (gray8[y * width + x] >> 7)
-					byte |= BIT(7);
-			}
-			*mono++ = byte;
-		}
-}
-
-static int repaper_fb_dirty(struct drm_framebuffer *fb)
-{
-	struct drm_gem_cma_object *cma_obj = drm_fb_cma_get_gem_obj(fb, 0);
-	struct dma_buf_attachment *import_attach = cma_obj->base.import_attach;
-	struct repaper_epd *epd = drm_to_epd(fb->dev);
-	struct drm_rect clip;
-	int idx, ret = 0;
-	u8 *buf = NULL;
-
-	if (!epd->enabled)
-		return 0;
-
-	if (!drm_dev_enter(fb->dev, &idx))
-		return -ENODEV;
-
-	/* repaper can't do partial updates */
-	clip.x1 = 0;
-	clip.x2 = fb->width;
-	clip.y1 = 0;
-	clip.y2 = fb->height;
-
-	repaper_get_temperature(epd);
-
-	DRM_DEBUG("Flushing [FB:%d] st=%ums\n", fb->base.id,
-		  epd->factored_stage_time);
-
-	buf = kmalloc_array(fb->width, fb->height, GFP_KERNEL);
-	if (!buf) {
-		ret = -ENOMEM;
-		goto out_exit;
-	}
-
-	if (import_attach) {
-		ret = dma_buf_begin_cpu_access(import_attach->dmabuf,
-					       DMA_FROM_DEVICE);
-		if (ret)
-			goto out_free;
-	}
-
-	drm_fb_xrgb8888_to_gray8(buf, cma_obj->vaddr, fb, &clip);
-
-	if (import_attach) {
-		ret = dma_buf_end_cpu_access(import_attach->dmabuf,
-					     DMA_FROM_DEVICE);
-		if (ret)
-			goto out_free;
-	}
-
-	repaper_gray8_to_mono_reversed(buf, fb->width, fb->height);
-
-	if (epd->partial) {
-		repaper_frame_data_repeat(epd, buf, epd->current_frame,
-					  REPAPER_NORMAL);
-	} else if (epd->cleared) {
-		repaper_frame_data_repeat(epd, epd->current_frame, NULL,
-					  REPAPER_COMPENSATE);
-		repaper_frame_data_repeat(epd, epd->current_frame, NULL,
-					  REPAPER_WHITE);
-		repaper_frame_data_repeat(epd, buf, NULL, REPAPER_INVERSE);
-		repaper_frame_data_repeat(epd, buf, NULL, REPAPER_NORMAL);
-
-		epd->partial = true;
-	} else {
-		/* Clear display (anything -> white) */
-		repaper_frame_fixed_repeat(epd, 0xff, REPAPER_COMPENSATE);
-		repaper_frame_fixed_repeat(epd, 0xff, REPAPER_WHITE);
-		repaper_frame_fixed_repeat(epd, 0xaa, REPAPER_INVERSE);
-		repaper_frame_fixed_repeat(epd, 0xaa, REPAPER_NORMAL);
-
-		/* Assuming a clear (white) screen output an image */
-		repaper_frame_fixed_repeat(epd, 0xaa, REPAPER_COMPENSATE);
-		repaper_frame_fixed_repeat(epd, 0xaa, REPAPER_WHITE);
-		repaper_frame_data_repeat(epd, buf, NULL, REPAPER_INVERSE);
-		repaper_frame_data_repeat(epd, buf, NULL, REPAPER_NORMAL);
-
-		epd->cleared = true;
-		epd->partial = true;
-	}
-
-	memcpy(epd->current_frame, buf, fb->width * fb->height / 8);
-
-	/*
-	 * An extra frame write is needed if pixels are set in the bottom line,
-	 * or else grey lines rises up from the pixels
-	 */
-	if (epd->pre_border_byte) {
-		unsigned int x;
-
-		for (x = 0; x < (fb->width / 8); x++)
-			if (buf[x + (fb->width * (fb->height - 1) / 8)]) {
-				repaper_frame_data_repeat(epd, buf,
-							  epd->current_frame,
-							  REPAPER_NORMAL);
-				break;
-			}
-	}
-
-out_free:
-	kfree(buf);
-out_exit:
-	drm_dev_exit(idx);
-
-	return ret;
-}
-
-static void power_off(struct repaper_epd *epd)
-{
-	/* Turn off power and all signals */
-	gpiod_set_value_cansleep(epd->reset, 0);
-	gpiod_set_value_cansleep(epd->panel_on, 0);
-	if (epd->border)
-		gpiod_set_value_cansleep(epd->border, 0);
-
-	/* Ensure SPI MOSI and CLOCK are Low before CS Low */
-	repaper_spi_mosi_low(epd->spi);
-
-	/* Discharge pulse */
-	gpiod_set_value_cansleep(epd->discharge, 1);
-	msleep(150);
-	gpiod_set_value_cansleep(epd->discharge, 0);
-}
-
-static void repaper_pipe_enable(struct drm_simple_display_pipe *pipe,
-				struct drm_crtc_state *crtc_state,
-				struct drm_plane_state *plane_state)
-{
-	struct repaper_epd *epd = drm_to_epd(pipe->crtc.dev);
-	struct spi_device *spi = epd->spi;
-	struct device *dev = &spi->dev;
-	bool dc_ok = false;
-	int i, ret, idx;
-
-	if (!drm_dev_enter(pipe->crtc.dev, &idx))
-		return;
-
-	DRM_DEBUG_DRIVER("\n");
-
-	/* Power up sequence */
-	gpiod_set_value_cansleep(epd->reset, 0);
-	gpiod_set_value_cansleep(epd->panel_on, 0);
-	gpiod_set_value_cansleep(epd->discharge, 0);
-	if (epd->border)
-		gpiod_set_value_cansleep(epd->border, 0);
-	repaper_spi_mosi_low(spi);
-	usleep_range(5000, 10000);
-
-	gpiod_set_value_cansleep(epd->panel_on, 1);
-	/*
-	 * This delay comes from the repaper.org userspace driver, it's not
-	 * mentioned in the datasheet.
-	 */
-	usleep_range(10000, 15000);
-	gpiod_set_value_cansleep(epd->reset, 1);
-	if (epd->border)
-		gpiod_set_value_cansleep(epd->border, 1);
-	usleep_range(5000, 10000);
-	gpiod_set_value_cansleep(epd->reset, 0);
-	usleep_range(5000, 10000);
-	gpiod_set_value_cansleep(epd->reset, 1);
-	usleep_range(5000, 10000);
-
-	/* Wait for COG to become ready */
-	for (i = 100; i > 0; i--) {
-		if (!gpiod_get_value_cansleep(epd->busy))
-			break;
-
-		usleep_range(10, 100);
-	}
-
-	if (!i) {
-		DRM_DEV_ERROR(dev, "timeout waiting for panel to become ready.\n");
-		power_off(epd);
-		goto out_exit;
-	}
-
-	repaper_read_id(spi);
-	ret = repaper_read_id(spi);
-	if (ret != REPAPER_RID_G2_COG_ID) {
-		if (ret < 0)
-			dev_err(dev, "failed to read chip (%d)\n", ret);
-		else
-			dev_err(dev, "wrong COG ID 0x%02x\n", ret);
-		power_off(epd);
-		goto out_exit;
-	}
-
-	/* Disable OE */
-	repaper_write_val(spi, 0x02, 0x40);
-
-	ret = repaper_read_val(spi, 0x0f);
-	if (ret < 0 || !(ret & 0x80)) {
-		if (ret < 0)
-			DRM_DEV_ERROR(dev, "failed to read chip (%d)\n", ret);
-		else
-			DRM_DEV_ERROR(dev, "panel is reported broken\n");
-		power_off(epd);
-		goto out_exit;
-	}
-
-	/* Power saving mode */
-	repaper_write_val(spi, 0x0b, 0x02);
-	/* Channel select */
-	repaper_write_buf(spi, 0x01, epd->channel_select, 8);
-	/* High power mode osc */
-	repaper_write_val(spi, 0x07, 0xd1);
-	/* Power setting */
-	repaper_write_val(spi, 0x08, 0x02);
-	/* Vcom level */
-	repaper_write_val(spi, 0x09, 0xc2);
-	/* Power setting */
-	repaper_write_val(spi, 0x04, 0x03);
-	/* Driver latch on */
-	repaper_write_val(spi, 0x03, 0x01);
-	/* Driver latch off */
-	repaper_write_val(spi, 0x03, 0x00);
-	usleep_range(5000, 10000);
-
-	/* Start chargepump */
-	for (i = 0; i < 4; ++i) {
-		/* Charge pump positive voltage on - VGH/VDL on */
-		repaper_write_val(spi, 0x05, 0x01);
-		msleep(240);
-
-		/* Charge pump negative voltage on - VGL/VDL on */
-		repaper_write_val(spi, 0x05, 0x03);
-		msleep(40);
-
-		/* Charge pump Vcom on - Vcom driver on */
-		repaper_write_val(spi, 0x05, 0x0f);
-		msleep(40);
-
-		/* check DC/DC */
-		ret = repaper_read_val(spi, 0x0f);
-		if (ret < 0) {
-			DRM_DEV_ERROR(dev, "failed to read chip (%d)\n", ret);
-			power_off(epd);
-			goto out_exit;
-		}
-
-		if (ret & 0x40) {
-			dc_ok = true;
-			break;
-		}
-	}
-
-	if (!dc_ok) {
-		DRM_DEV_ERROR(dev, "dc/dc failed\n");
-		power_off(epd);
-		goto out_exit;
-	}
-
-	/*
-	 * Output enable to disable
-	 * The userspace driver sets this to 0x04, but the datasheet says 0x06
-	 */
-	repaper_write_val(spi, 0x02, 0x04);
-
-	epd->enabled = true;
-	epd->partial = false;
-out_exit:
-	drm_dev_exit(idx);
-}
-
-static void repaper_pipe_disable(struct drm_simple_display_pipe *pipe)
-{
-	struct repaper_epd *epd = drm_to_epd(pipe->crtc.dev);
-	struct spi_device *spi = epd->spi;
-	unsigned int line;
-
-	/*
-	 * This callback is not protected by drm_dev_enter/exit since we want to
-	 * turn off the display on regular driver unload. It's highly unlikely
-	 * that the underlying SPI controller is gone should this be called after
-	 * unplug.
-	 */
-
-	if (!epd->enabled)
-		return;
-
-	DRM_DEBUG_DRIVER("\n");
-
-	epd->enabled = false;
-
-	/* Nothing frame */
-	for (line = 0; line < epd->height; line++)
-		repaper_one_line(epd, 0x7fffu, NULL, 0x00, NULL,
-				 REPAPER_COMPENSATE);
-
-	/* 2.7" */
-	if (epd->border) {
-		/* Dummy line */
-		repaper_one_line(epd, 0x7fffu, NULL, 0x00, NULL,
-				 REPAPER_COMPENSATE);
-		msleep(25);
-		gpiod_set_value_cansleep(epd->border, 0);
-		msleep(200);
-		gpiod_set_value_cansleep(epd->border, 1);
-	} else {
-		/* Border dummy line */
-		repaper_one_line(epd, 0x7fffu, NULL, 0x00, NULL,
-				 REPAPER_NORMAL);
-		msleep(200);
-	}
-
-	/* not described in datasheet */
-	repaper_write_val(spi, 0x0b, 0x00);
-	/* Latch reset turn on */
-	repaper_write_val(spi, 0x03, 0x01);
-	/* Power off charge pump Vcom */
-	repaper_write_val(spi, 0x05, 0x03);
-	/* Power off charge pump neg voltage */
-	repaper_write_val(spi, 0x05, 0x01);
-	msleep(120);
-	/* Discharge internal */
-	repaper_write_val(spi, 0x04, 0x80);
-	/* turn off all charge pumps */
-	repaper_write_val(spi, 0x05, 0x00);
-	/* Turn off osc */
-	repaper_write_val(spi, 0x07, 0x01);
-	msleep(50);
-
-	power_off(epd);
-}
-
-static void repaper_pipe_update(struct drm_simple_display_pipe *pipe,
-				struct drm_plane_state *old_state)
-{
-	struct drm_plane_state *state = pipe->plane.state;
-	struct drm_crtc *crtc = &pipe->crtc;
-	struct drm_rect rect;
-
-	if (drm_atomic_helper_damage_merged(old_state, state, &rect))
-		repaper_fb_dirty(state->fb);
-
-	if (crtc->state->event) {
-		spin_lock_irq(&crtc->dev->event_lock);
-		drm_crtc_send_vblank_event(crtc, crtc->state->event);
-		spin_unlock_irq(&crtc->dev->event_lock);
-		crtc->state->event = NULL;
-	}
-}
-
-static const struct drm_simple_display_pipe_funcs repaper_pipe_funcs = {
-	.enable = repaper_pipe_enable,
-	.disable = repaper_pipe_disable,
-	.update = repaper_pipe_update,
-	.prepare_fb = drm_gem_fb_simple_display_pipe_prepare_fb,
-};
-
-static int repaper_connector_get_modes(struct drm_connector *connector)
-{
-	struct repaper_epd *epd = drm_to_epd(connector->dev);
-	struct drm_display_mode *mode;
-
-	mode = drm_mode_duplicate(connector->dev, epd->mode);
-	if (!mode) {
-		DRM_ERROR("Failed to duplicate mode\n");
-		return 0;
-	}
-
-	drm_mode_set_name(mode);
-	mode->type |= DRM_MODE_TYPE_PREFERRED;
-	drm_mode_probed_add(connector, mode);
-
-	connector->display_info.width_mm = mode->width_mm;
-	connector->display_info.height_mm = mode->height_mm;
-
-	return 1;
-}
-
-static const struct drm_connector_helper_funcs repaper_connector_hfuncs = {
-	.get_modes = repaper_connector_get_modes,
-};
-
-static const struct drm_connector_funcs repaper_connector_funcs = {
-	.reset = drm_atomic_helper_connector_reset,
-	.fill_modes = drm_helper_probe_single_connector_modes,
-	.destroy = drm_connector_cleanup,
-	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
-	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
-};
-
-static const struct drm_mode_config_funcs repaper_mode_config_funcs = {
-	.fb_create = drm_gem_fb_create_with_dirty,
-	.atomic_check = drm_atomic_helper_check,
-	.atomic_commit = drm_atomic_helper_commit,
-};
-
-static void repaper_release(struct drm_device *drm)
-{
-	struct repaper_epd *epd = drm_to_epd(drm);
-
-	DRM_DEBUG_DRIVER("\n");
-
-	drm_mode_config_cleanup(drm);
-	drm_dev_fini(drm);
-	kfree(epd);
-}
-
-static const uint32_t repaper_formats[] = {
-	DRM_FORMAT_XRGB8888,
-};
-
-static const struct drm_display_mode repaper_e1144cs021_mode = {
-	DRM_SIMPLE_MODE(128, 96, 29, 22),
-};
-
-static const u8 repaper_e1144cs021_cs[] = { 0x00, 0x00, 0x00, 0x00,
-					    0x00, 0x0f, 0xff, 0x00 };
-
-static const struct drm_display_mode repaper_e1190cs021_mode = {
-	DRM_SIMPLE_MODE(144, 128, 36, 32),
-};
-
-static const u8 repaper_e1190cs021_cs[] = { 0x00, 0x00, 0x00, 0x03,
-					    0xfc, 0x00, 0x00, 0xff };
-
-static const struct drm_display_mode repaper_e2200cs021_mode = {
-	DRM_SIMPLE_MODE(200, 96, 46, 22),
-};
-
-static const u8 repaper_e2200cs021_cs[] = { 0x00, 0x00, 0x00, 0x00,
-					    0x01, 0xff, 0xe0, 0x00 };
-
-static const struct drm_display_mode repaper_e2271cs021_mode = {
-	DRM_SIMPLE_MODE(264, 176, 57, 38),
-};
-
-static const u8 repaper_e2271cs021_cs[] = { 0x00, 0x00, 0x00, 0x7f,
-					    0xff, 0xfe, 0x00, 0x00 };
-
-DEFINE_DRM_GEM_CMA_FOPS(repaper_fops);
-
-static struct drm_driver repaper_driver = {
-	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
-	.fops			= &repaper_fops,
-	.release		= repaper_release,
-	DRM_GEM_CMA_VMAP_DRIVER_OPS,
-	.name			= "repaper",
-	.desc			= "Pervasive Displays RePaper e-ink panels",
-	.date			= "20170405",
-	.major			= 1,
-	.minor			= 0,
-};
-
-static const struct of_device_id repaper_of_match[] = {
-	{ .compatible = "pervasive,e1144cs021", .data = (void *)E1144CS021 },
-	{ .compatible = "pervasive,e1190cs021", .data = (void *)E1190CS021 },
-	{ .compatible = "pervasive,e2200cs021", .data = (void *)E2200CS021 },
-	{ .compatible = "pervasive,e2271cs021", .data = (void *)E2271CS021 },
-	{},
-};
-MODULE_DEVICE_TABLE(of, repaper_of_match);
-
-static const struct spi_device_id repaper_id[] = {
-	{ "e1144cs021", E1144CS021 },
-	{ "e1190cs021", E1190CS021 },
-	{ "e2200cs021", E2200CS021 },
-	{ "e2271cs021", E2271CS021 },
-	{ },
-};
-MODULE_DEVICE_TABLE(spi, repaper_id);
-
-static int repaper_probe(struct spi_device *spi)
-{
-	const struct drm_display_mode *mode;
-	const struct spi_device_id *spi_id;
-	const struct of_device_id *match;
-	struct device *dev = &spi->dev;
-	enum repaper_model model;
-	const char *thermal_zone;
-	struct repaper_epd *epd;
-	size_t line_buffer_size;
-	struct drm_device *drm;
-	int ret;
-
-	match = of_match_device(repaper_of_match, dev);
-	if (match) {
-		model = (enum repaper_model)match->data;
-	} else {
-		spi_id = spi_get_device_id(spi);
-		model = spi_id->driver_data;
-	}
-
-	/* The SPI device is used to allocate dma memory */
-	if (!dev->coherent_dma_mask) {
-		ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
-		if (ret) {
-			dev_warn(dev, "Failed to set dma mask %d\n", ret);
-			return ret;
-		}
-	}
-
-	epd = kzalloc(sizeof(*epd), GFP_KERNEL);
-	if (!epd)
-		return -ENOMEM;
-
-	drm = &epd->drm;
-
-	ret = devm_drm_dev_init(dev, drm, &repaper_driver);
-	if (ret) {
-		kfree(epd);
-		return ret;
-	}
-
-	drm_mode_config_init(drm);
-	drm->mode_config.funcs = &repaper_mode_config_funcs;
-
-	epd->spi = spi;
-
-	epd->panel_on = devm_gpiod_get(dev, "panel-on", GPIOD_OUT_LOW);
-	if (IS_ERR(epd->panel_on)) {
-		ret = PTR_ERR(epd->panel_on);
-		if (ret != -EPROBE_DEFER)
-			DRM_DEV_ERROR(dev, "Failed to get gpio 'panel-on'\n");
-		return ret;
-	}
-
-	epd->discharge = devm_gpiod_get(dev, "discharge", GPIOD_OUT_LOW);
-	if (IS_ERR(epd->discharge)) {
-		ret = PTR_ERR(epd->discharge);
-		if (ret != -EPROBE_DEFER)
-			DRM_DEV_ERROR(dev, "Failed to get gpio 'discharge'\n");
-		return ret;
-	}
-
-	epd->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
-	if (IS_ERR(epd->reset)) {
-		ret = PTR_ERR(epd->reset);
-		if (ret != -EPROBE_DEFER)
-			DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
-		return ret;
-	}
-
-	epd->busy = devm_gpiod_get(dev, "busy", GPIOD_IN);
-	if (IS_ERR(epd->busy)) {
-		ret = PTR_ERR(epd->busy);
-		if (ret != -EPROBE_DEFER)
-			DRM_DEV_ERROR(dev, "Failed to get gpio 'busy'\n");
-		return ret;
-	}
-
-	if (!device_property_read_string(dev, "pervasive,thermal-zone",
-					 &thermal_zone)) {
-		epd->thermal = thermal_zone_get_zone_by_name(thermal_zone);
-		if (IS_ERR(epd->thermal)) {
-			DRM_DEV_ERROR(dev, "Failed to get thermal zone: %s\n", thermal_zone);
-			return PTR_ERR(epd->thermal);
-		}
-	}
-
-	switch (model) {
-	case E1144CS021:
-		mode = &repaper_e1144cs021_mode;
-		epd->channel_select = repaper_e1144cs021_cs;
-		epd->stage_time = 480;
-		epd->bytes_per_scan = 96 / 4;
-		epd->middle_scan = true; /* data-scan-data */
-		epd->pre_border_byte = false;
-		epd->border_byte = REPAPER_BORDER_BYTE_ZERO;
-		break;
-
-	case E1190CS021:
-		mode = &repaper_e1190cs021_mode;
-		epd->channel_select = repaper_e1190cs021_cs;
-		epd->stage_time = 480;
-		epd->bytes_per_scan = 128 / 4 / 2;
-		epd->middle_scan = false; /* scan-data-scan */
-		epd->pre_border_byte = false;
-		epd->border_byte = REPAPER_BORDER_BYTE_SET;
-		break;
-
-	case E2200CS021:
-		mode = &repaper_e2200cs021_mode;
-		epd->channel_select = repaper_e2200cs021_cs;
-		epd->stage_time = 480;
-		epd->bytes_per_scan = 96 / 4;
-		epd->middle_scan = true; /* data-scan-data */
-		epd->pre_border_byte = true;
-		epd->border_byte = REPAPER_BORDER_BYTE_NONE;
-		break;
-
-	case E2271CS021:
-		epd->border = devm_gpiod_get(dev, "border", GPIOD_OUT_LOW);
-		if (IS_ERR(epd->border)) {
-			ret = PTR_ERR(epd->border);
-			if (ret != -EPROBE_DEFER)
-				DRM_DEV_ERROR(dev, "Failed to get gpio 'border'\n");
-			return ret;
-		}
-
-		mode = &repaper_e2271cs021_mode;
-		epd->channel_select = repaper_e2271cs021_cs;
-		epd->stage_time = 630;
-		epd->bytes_per_scan = 176 / 4;
-		epd->middle_scan = true; /* data-scan-data */
-		epd->pre_border_byte = true;
-		epd->border_byte = REPAPER_BORDER_BYTE_NONE;
-		break;
-
-	default:
-		return -ENODEV;
-	}
-
-	epd->mode = mode;
-	epd->width = mode->hdisplay;
-	epd->height = mode->vdisplay;
-	epd->factored_stage_time = epd->stage_time;
-
-	line_buffer_size = 2 * epd->width / 8 + epd->bytes_per_scan + 2;
-	epd->line_buffer = devm_kzalloc(dev, line_buffer_size, GFP_KERNEL);
-	if (!epd->line_buffer)
-		return -ENOMEM;
-
-	epd->current_frame = devm_kzalloc(dev, epd->width * epd->height / 8,
-					  GFP_KERNEL);
-	if (!epd->current_frame)
-		return -ENOMEM;
-
-	drm->mode_config.min_width = mode->hdisplay;
-	drm->mode_config.max_width = mode->hdisplay;
-	drm->mode_config.min_height = mode->vdisplay;
-	drm->mode_config.max_height = mode->vdisplay;
-
-	drm_connector_helper_add(&epd->connector, &repaper_connector_hfuncs);
-	ret = drm_connector_init(drm, &epd->connector, &repaper_connector_funcs,
-				 DRM_MODE_CONNECTOR_SPI);
-	if (ret)
-		return ret;
-
-	ret = drm_simple_display_pipe_init(drm, &epd->pipe, &repaper_pipe_funcs,
-					   repaper_formats, ARRAY_SIZE(repaper_formats),
-					   NULL, &epd->connector);
-	if (ret)
-		return ret;
-
-	drm_mode_config_reset(drm);
-
-	ret = drm_dev_register(drm, 0);
-	if (ret)
-		return ret;
-
-	spi_set_drvdata(spi, drm);
-
-	DRM_DEBUG_DRIVER("SPI speed: %uMHz\n", spi->max_speed_hz / 1000000);
-
-	drm_fbdev_generic_setup(drm, 0);
-
-	return 0;
-}
-
-static int repaper_remove(struct spi_device *spi)
-{
-	struct drm_device *drm = spi_get_drvdata(spi);
-
-	drm_dev_unplug(drm);
-	drm_atomic_helper_shutdown(drm);
-
-	return 0;
-}
-
-static void repaper_shutdown(struct spi_device *spi)
-{
-	drm_atomic_helper_shutdown(spi_get_drvdata(spi));
-}
-
-static struct spi_driver repaper_spi_driver = {
-	.driver = {
-		.name = "repaper",
-		.owner = THIS_MODULE,
-		.of_match_table = repaper_of_match,
-	},
-	.id_table = repaper_id,
-	.probe = repaper_probe,
-	.remove = repaper_remove,
-	.shutdown = repaper_shutdown,
-};
-module_spi_driver(repaper_spi_driver);
-
-MODULE_DESCRIPTION("Pervasive Displays RePaper DRM driver");
-MODULE_AUTHOR("Noralf Trønnes");
-MODULE_LICENSE("GPL");
--- a/drivers/gpu/drm/tinydrm/st7586.c
+++ /dev/null
@@ -1,424 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * DRM driver for Sitronix ST7586 panels
- *
- * Copyright 2017 David Lechner <david@lechnology.com>
- */
-
-#include <linux/delay.h>
-#include <linux/dma-buf.h>
-#include <linux/gpio/consumer.h>
-#include <linux/module.h>
-#include <linux/property.h>
-#include <linux/spi/spi.h>
-#include <video/mipi_display.h>
-
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_damage_helper.h>
-#include <drm/drm_drv.h>
-#include <drm/drm_fb_cma_helper.h>
-#include <drm/drm_fb_helper.h>
-#include <drm/drm_format_helper.h>
-#include <drm/drm_gem_cma_helper.h>
-#include <drm/drm_gem_framebuffer_helper.h>
-#include <drm/drm_mipi_dbi.h>
-#include <drm/drm_rect.h>
-#include <drm/drm_vblank.h>
-
-/* controller-specific commands */
-#define ST7586_DISP_MODE_GRAY	0x38
-#define ST7586_DISP_MODE_MONO	0x39
-#define ST7586_ENABLE_DDRAM	0x3a
-#define ST7586_SET_DISP_DUTY	0xb0
-#define ST7586_SET_PART_DISP	0xb4
-#define ST7586_SET_NLINE_INV	0xb5
-#define ST7586_SET_VOP		0xc0
-#define ST7586_SET_BIAS_SYSTEM	0xc3
-#define ST7586_SET_BOOST_LEVEL	0xc4
-#define ST7586_SET_VOP_OFFSET	0xc7
-#define ST7586_ENABLE_ANALOG	0xd0
-#define ST7586_AUTO_READ_CTRL	0xd7
-#define ST7586_OTP_RW_CTRL	0xe0
-#define ST7586_OTP_CTRL_OUT	0xe1
-#define ST7586_OTP_READ		0xe3
-
-#define ST7586_DISP_CTRL_MX	BIT(6)
-#define ST7586_DISP_CTRL_MY	BIT(7)
-
-/*
- * The ST7586 controller has an unusual pixel format where 2bpp grayscale is
- * packed 3 pixels per byte with the first two pixels using 3 bits and the 3rd
- * pixel using only 2 bits.
- *
- * |  D7  |  D6  |  D5  ||      |      || 2bpp |
- * | (D4) | (D3) | (D2) ||  D1  |  D0  || GRAY |
- * +------+------+------++------+------++------+
- * |  1   |  1   |  1   ||  1   |  1   || 0  0 | black
- * |  1   |  0   |  0   ||  1   |  0   || 0  1 | dark gray
- * |  0   |  1   |  0   ||  0   |  1   || 1  0 | light gray
- * |  0   |  0   |  0   ||  0   |  0   || 1  1 | white
- */
-
-static const u8 st7586_lookup[] = { 0x7, 0x4, 0x2, 0x0 };
-
-static void st7586_xrgb8888_to_gray332(u8 *dst, void *vaddr,
-				       struct drm_framebuffer *fb,
-				       struct drm_rect *clip)
-{
-	size_t len = (clip->x2 - clip->x1) * (clip->y2 - clip->y1);
-	unsigned int x, y;
-	u8 *src, *buf, val;
-
-	buf = kmalloc(len, GFP_KERNEL);
-	if (!buf)
-		return;
-
-	drm_fb_xrgb8888_to_gray8(buf, vaddr, fb, clip);
-	src = buf;
-
-	for (y = clip->y1; y < clip->y2; y++) {
-		for (x = clip->x1; x < clip->x2; x += 3) {
-			val = st7586_lookup[*src++ >> 6] << 5;
-			val |= st7586_lookup[*src++ >> 6] << 2;
-			val |= st7586_lookup[*src++ >> 6] >> 1;
-			*dst++ = val;
-		}
-	}
-
-	kfree(buf);
-}
-
-static int st7586_buf_copy(void *dst, struct drm_framebuffer *fb,
-			   struct drm_rect *clip)
-{
-	struct drm_gem_cma_object *cma_obj = drm_fb_cma_get_gem_obj(fb, 0);
-	struct dma_buf_attachment *import_attach = cma_obj->base.import_attach;
-	void *src = cma_obj->vaddr;
-	int ret = 0;
-
-	if (import_attach) {
-		ret = dma_buf_begin_cpu_access(import_attach->dmabuf,
-					       DMA_FROM_DEVICE);
-		if (ret)
-			return ret;
-	}
-
-	st7586_xrgb8888_to_gray332(dst, src, fb, clip);
-
-	if (import_attach)
-		ret = dma_buf_end_cpu_access(import_attach->dmabuf,
-					     DMA_FROM_DEVICE);
-
-	return ret;
-}
-
-static void st7586_fb_dirty(struct drm_framebuffer *fb, struct drm_rect *rect)
-{
-	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(fb->dev);
-	struct mipi_dbi *dbi = &dbidev->dbi;
-	int start, end, idx, ret = 0;
-
-	if (!dbidev->enabled)
-		return;
-
-	if (!drm_dev_enter(fb->dev, &idx))
-		return;
-
-	/* 3 pixels per byte, so grow clip to nearest multiple of 3 */
-	rect->x1 = rounddown(rect->x1, 3);
-	rect->x2 = roundup(rect->x2, 3);
-
-	DRM_DEBUG_KMS("Flushing [FB:%d] " DRM_RECT_FMT "\n", fb->base.id, DRM_RECT_ARG(rect));
-
-	ret = st7586_buf_copy(dbidev->tx_buf, fb, rect);
-	if (ret)
-		goto err_msg;
-
-	/* Pixels are packed 3 per byte */
-	start = rect->x1 / 3;
-	end = rect->x2 / 3;
-
-	mipi_dbi_command(dbi, MIPI_DCS_SET_COLUMN_ADDRESS,
-			 (start >> 8) & 0xFF, start & 0xFF,
-			 (end >> 8) & 0xFF, (end - 1) & 0xFF);
-	mipi_dbi_command(dbi, MIPI_DCS_SET_PAGE_ADDRESS,
-			 (rect->y1 >> 8) & 0xFF, rect->y1 & 0xFF,
-			 (rect->y2 >> 8) & 0xFF, (rect->y2 - 1) & 0xFF);
-
-	ret = mipi_dbi_command_buf(dbi, MIPI_DCS_WRITE_MEMORY_START,
-				   (u8 *)dbidev->tx_buf,
-				   (end - start) * (rect->y2 - rect->y1));
-err_msg:
-	if (ret)
-		dev_err_once(fb->dev->dev, "Failed to update display %d\n", ret);
-
-	drm_dev_exit(idx);
-}
-
-static void st7586_pipe_update(struct drm_simple_display_pipe *pipe,
-			       struct drm_plane_state *old_state)
-{
-	struct drm_plane_state *state = pipe->plane.state;
-	struct drm_crtc *crtc = &pipe->crtc;
-	struct drm_rect rect;
-
-	if (drm_atomic_helper_damage_merged(old_state, state, &rect))
-		st7586_fb_dirty(state->fb, &rect);
-
-	if (crtc->state->event) {
-		spin_lock_irq(&crtc->dev->event_lock);
-		drm_crtc_send_vblank_event(crtc, crtc->state->event);
-		spin_unlock_irq(&crtc->dev->event_lock);
-		crtc->state->event = NULL;
-	}
-}
-
-static void st7586_pipe_enable(struct drm_simple_display_pipe *pipe,
-			       struct drm_crtc_state *crtc_state,
-			       struct drm_plane_state *plane_state)
-{
-	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
-	struct drm_framebuffer *fb = plane_state->fb;
-	struct mipi_dbi *dbi = &dbidev->dbi;
-	struct drm_rect rect = {
-		.x1 = 0,
-		.x2 = fb->width,
-		.y1 = 0,
-		.y2 = fb->height,
-	};
-	int idx, ret;
-	u8 addr_mode;
-
-	if (!drm_dev_enter(pipe->crtc.dev, &idx))
-		return;
-
-	DRM_DEBUG_KMS("\n");
-
-	ret = mipi_dbi_poweron_reset(dbidev);
-	if (ret)
-		goto out_exit;
-
-	mipi_dbi_command(dbi, ST7586_AUTO_READ_CTRL, 0x9f);
-	mipi_dbi_command(dbi, ST7586_OTP_RW_CTRL, 0x00);
-
-	msleep(10);
-
-	mipi_dbi_command(dbi, ST7586_OTP_READ);
-
-	msleep(20);
-
-	mipi_dbi_command(dbi, ST7586_OTP_CTRL_OUT);
-	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
-	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_OFF);
-
-	msleep(50);
-
-	mipi_dbi_command(dbi, ST7586_SET_VOP_OFFSET, 0x00);
-	mipi_dbi_command(dbi, ST7586_SET_VOP, 0xe3, 0x00);
-	mipi_dbi_command(dbi, ST7586_SET_BIAS_SYSTEM, 0x02);
-	mipi_dbi_command(dbi, ST7586_SET_BOOST_LEVEL, 0x04);
-	mipi_dbi_command(dbi, ST7586_ENABLE_ANALOG, 0x1d);
-	mipi_dbi_command(dbi, ST7586_SET_NLINE_INV, 0x00);
-	mipi_dbi_command(dbi, ST7586_DISP_MODE_GRAY);
-	mipi_dbi_command(dbi, ST7586_ENABLE_DDRAM, 0x02);
-
-	switch (dbidev->rotation) {
-	default:
-		addr_mode = 0x00;
-		break;
-	case 90:
-		addr_mode = ST7586_DISP_CTRL_MY;
-		break;
-	case 180:
-		addr_mode = ST7586_DISP_CTRL_MX | ST7586_DISP_CTRL_MY;
-		break;
-	case 270:
-		addr_mode = ST7586_DISP_CTRL_MX;
-		break;
-	}
-	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
-
-	mipi_dbi_command(dbi, ST7586_SET_DISP_DUTY, 0x7f);
-	mipi_dbi_command(dbi, ST7586_SET_PART_DISP, 0xa0);
-	mipi_dbi_command(dbi, MIPI_DCS_SET_PARTIAL_AREA, 0x00, 0x00, 0x00, 0x77);
-	mipi_dbi_command(dbi, MIPI_DCS_EXIT_INVERT_MODE);
-
-	msleep(100);
-
-	dbidev->enabled = true;
-	st7586_fb_dirty(fb, &rect);
-
-	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
-out_exit:
-	drm_dev_exit(idx);
-}
-
-static void st7586_pipe_disable(struct drm_simple_display_pipe *pipe)
-{
-	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
-
-	/*
-	 * This callback is not protected by drm_dev_enter/exit since we want to
-	 * turn off the display on regular driver unload. It's highly unlikely
-	 * that the underlying SPI controller is gone should this be called after
-	 * unplug.
-	 */
-
-	DRM_DEBUG_KMS("\n");
-
-	if (!dbidev->enabled)
-		return;
-
-	mipi_dbi_command(&dbidev->dbi, MIPI_DCS_SET_DISPLAY_OFF);
-	dbidev->enabled = false;
-}
-
-static const u32 st7586_formats[] = {
-	DRM_FORMAT_XRGB8888,
-};
-
-static const struct drm_simple_display_pipe_funcs st7586_pipe_funcs = {
-	.enable		= st7586_pipe_enable,
-	.disable	= st7586_pipe_disable,
-	.update		= st7586_pipe_update,
-	.prepare_fb	= drm_gem_fb_simple_display_pipe_prepare_fb,
-};
-
-static const struct drm_display_mode st7586_mode = {
-	DRM_SIMPLE_MODE(178, 128, 37, 27),
-};
-
-DEFINE_DRM_GEM_CMA_FOPS(st7586_fops);
-
-static struct drm_driver st7586_driver = {
-	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
-	.fops			= &st7586_fops,
-	.release		= mipi_dbi_release,
-	DRM_GEM_CMA_VMAP_DRIVER_OPS,
-	.debugfs_init		= mipi_dbi_debugfs_init,
-	.name			= "st7586",
-	.desc			= "Sitronix ST7586",
-	.date			= "20170801",
-	.major			= 1,
-	.minor			= 0,
-};
-
-static const struct of_device_id st7586_of_match[] = {
-	{ .compatible = "lego,ev3-lcd" },
-	{},
-};
-MODULE_DEVICE_TABLE(of, st7586_of_match);
-
-static const struct spi_device_id st7586_id[] = {
-	{ "ev3-lcd", 0 },
-	{ },
-};
-MODULE_DEVICE_TABLE(spi, st7586_id);
-
-static int st7586_probe(struct spi_device *spi)
-{
-	struct device *dev = &spi->dev;
-	struct mipi_dbi_dev *dbidev;
-	struct drm_device *drm;
-	struct mipi_dbi *dbi;
-	struct gpio_desc *a0;
-	u32 rotation = 0;
-	size_t bufsize;
-	int ret;
-
-	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
-	if (!dbidev)
-		return -ENOMEM;
-
-	dbi = &dbidev->dbi;
-	drm = &dbidev->drm;
-	ret = devm_drm_dev_init(dev, drm, &st7586_driver);
-	if (ret) {
-		kfree(dbidev);
-		return ret;
-	}
-
-	drm_mode_config_init(drm);
-
-	bufsize = (st7586_mode.vdisplay + 2) / 3 * st7586_mode.hdisplay;
-
-	dbi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
-	if (IS_ERR(dbi->reset)) {
-		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
-		return PTR_ERR(dbi->reset);
-	}
-
-	a0 = devm_gpiod_get(dev, "a0", GPIOD_OUT_LOW);
-	if (IS_ERR(a0)) {
-		DRM_DEV_ERROR(dev, "Failed to get gpio 'a0'\n");
-		return PTR_ERR(a0);
-	}
-
-	device_property_read_u32(dev, "rotation", &rotation);
-
-	ret = mipi_dbi_spi_init(spi, dbi, a0);
-	if (ret)
-		return ret;
-
-	/* Cannot read from this controller via SPI */
-	dbi->read_commands = NULL;
-
-	ret = mipi_dbi_dev_init_with_formats(dbidev, &st7586_pipe_funcs,
-					     st7586_formats, ARRAY_SIZE(st7586_formats),
-					     &st7586_mode, rotation, bufsize);
-	if (ret)
-		return ret;
-
-	/*
-	 * we are using 8-bit data, so we are not actually swapping anything,
-	 * but setting mipi->swap_bytes makes mipi_dbi_typec3_command() do the
-	 * right thing and not use 16-bit transfers (which results in swapped
-	 * bytes on little-endian systems and causes out of order data to be
-	 * sent to the display).
-	 */
-	dbi->swap_bytes = true;
-
-	drm_mode_config_reset(drm);
-
-	ret = drm_dev_register(drm, 0);
-	if (ret)
-		return ret;
-
-	spi_set_drvdata(spi, drm);
-
-	drm_fbdev_generic_setup(drm, 0);
-
-	return 0;
-}
-
-static int st7586_remove(struct spi_device *spi)
-{
-	struct drm_device *drm = spi_get_drvdata(spi);
-
-	drm_dev_unplug(drm);
-	drm_atomic_helper_shutdown(drm);
-
-	return 0;
-}
-
-static void st7586_shutdown(struct spi_device *spi)
-{
-	drm_atomic_helper_shutdown(spi_get_drvdata(spi));
-}
-
-static struct spi_driver st7586_spi_driver = {
-	.driver = {
-		.name = "st7586",
-		.owner = THIS_MODULE,
-		.of_match_table = st7586_of_match,
-	},
-	.id_table = st7586_id,
-	.probe = st7586_probe,
-	.remove = st7586_remove,
-	.shutdown = st7586_shutdown,
-};
-module_spi_driver(st7586_spi_driver);
-
-MODULE_DESCRIPTION("Sitronix ST7586 DRM driver");
-MODULE_AUTHOR("David Lechner <david@lechnology.com>");
-MODULE_LICENSE("GPL");
--- a/drivers/gpu/drm/tinydrm/st7735r.c
+++ /dev/null
@@ -1,246 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * DRM driver for Sitronix ST7735R panels
- *
- * Copyright 2017 David Lechner <david@lechnology.com>
- */
-
-#include <linux/backlight.h>
-#include <linux/delay.h>
-#include <linux/dma-buf.h>
-#include <linux/gpio/consumer.h>
-#include <linux/module.h>
-#include <linux/property.h>
-#include <linux/spi/spi.h>
-#include <video/mipi_display.h>
-
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_drv.h>
-#include <drm/drm_fb_helper.h>
-#include <drm/drm_gem_cma_helper.h>
-#include <drm/drm_gem_framebuffer_helper.h>
-#include <drm/drm_mipi_dbi.h>
-
-#define ST7735R_FRMCTR1		0xb1
-#define ST7735R_FRMCTR2		0xb2
-#define ST7735R_FRMCTR3		0xb3
-#define ST7735R_INVCTR		0xb4
-#define ST7735R_PWCTR1		0xc0
-#define ST7735R_PWCTR2		0xc1
-#define ST7735R_PWCTR3		0xc2
-#define ST7735R_PWCTR4		0xc3
-#define ST7735R_PWCTR5		0xc4
-#define ST7735R_VMCTR1		0xc5
-#define ST7735R_GAMCTRP1	0xe0
-#define ST7735R_GAMCTRN1	0xe1
-
-#define ST7735R_MY	BIT(7)
-#define ST7735R_MX	BIT(6)
-#define ST7735R_MV	BIT(5)
-
-static void jd_t18003_t01_pipe_enable(struct drm_simple_display_pipe *pipe,
-				      struct drm_crtc_state *crtc_state,
-				      struct drm_plane_state *plane_state)
-{
-	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
-	struct mipi_dbi *dbi = &dbidev->dbi;
-	int ret, idx;
-	u8 addr_mode;
-
-	if (!drm_dev_enter(pipe->crtc.dev, &idx))
-		return;
-
-	DRM_DEBUG_KMS("\n");
-
-	ret = mipi_dbi_poweron_reset(dbidev);
-	if (ret)
-		goto out_exit;
-
-	msleep(150);
-
-	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
-	msleep(500);
-
-	mipi_dbi_command(dbi, ST7735R_FRMCTR1, 0x01, 0x2c, 0x2d);
-	mipi_dbi_command(dbi, ST7735R_FRMCTR2, 0x01, 0x2c, 0x2d);
-	mipi_dbi_command(dbi, ST7735R_FRMCTR3, 0x01, 0x2c, 0x2d, 0x01, 0x2c,
-			 0x2d);
-	mipi_dbi_command(dbi, ST7735R_INVCTR, 0x07);
-	mipi_dbi_command(dbi, ST7735R_PWCTR1, 0xa2, 0x02, 0x84);
-	mipi_dbi_command(dbi, ST7735R_PWCTR2, 0xc5);
-	mipi_dbi_command(dbi, ST7735R_PWCTR3, 0x0a, 0x00);
-	mipi_dbi_command(dbi, ST7735R_PWCTR4, 0x8a, 0x2a);
-	mipi_dbi_command(dbi, ST7735R_PWCTR5, 0x8a, 0xee);
-	mipi_dbi_command(dbi, ST7735R_VMCTR1, 0x0e);
-	mipi_dbi_command(dbi, MIPI_DCS_EXIT_INVERT_MODE);
-	switch (dbidev->rotation) {
-	default:
-		addr_mode = ST7735R_MX | ST7735R_MY;
-		break;
-	case 90:
-		addr_mode = ST7735R_MX | ST7735R_MV;
-		break;
-	case 180:
-		addr_mode = 0;
-		break;
-	case 270:
-		addr_mode = ST7735R_MY | ST7735R_MV;
-		break;
-	}
-	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
-	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT,
-			 MIPI_DCS_PIXEL_FMT_16BIT);
-	mipi_dbi_command(dbi, ST7735R_GAMCTRP1, 0x02, 0x1c, 0x07, 0x12, 0x37,
-			 0x32, 0x29, 0x2d, 0x29, 0x25, 0x2b, 0x39, 0x00, 0x01,
-			 0x03, 0x10);
-	mipi_dbi_command(dbi, ST7735R_GAMCTRN1, 0x03, 0x1d, 0x07, 0x06, 0x2e,
-			 0x2c, 0x29, 0x2d, 0x2e, 0x2e, 0x37, 0x3f, 0x00, 0x00,
-			 0x02, 0x10);
-	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
-
-	msleep(100);
-
-	mipi_dbi_command(dbi, MIPI_DCS_ENTER_NORMAL_MODE);
-
-	msleep(20);
-
-	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
-out_exit:
-	drm_dev_exit(idx);
-}
-
-static const struct drm_simple_display_pipe_funcs jd_t18003_t01_pipe_funcs = {
-	.enable		= jd_t18003_t01_pipe_enable,
-	.disable	= mipi_dbi_pipe_disable,
-	.update		= mipi_dbi_pipe_update,
-	.prepare_fb	= drm_gem_fb_simple_display_pipe_prepare_fb,
-};
-
-static const struct drm_display_mode jd_t18003_t01_mode = {
-	DRM_SIMPLE_MODE(128, 160, 28, 35),
-};
-
-DEFINE_DRM_GEM_CMA_FOPS(st7735r_fops);
-
-static struct drm_driver st7735r_driver = {
-	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
-	.fops			= &st7735r_fops,
-	.release		= mipi_dbi_release,
-	DRM_GEM_CMA_VMAP_DRIVER_OPS,
-	.debugfs_init		= mipi_dbi_debugfs_init,
-	.name			= "st7735r",
-	.desc			= "Sitronix ST7735R",
-	.date			= "20171128",
-	.major			= 1,
-	.minor			= 0,
-};
-
-static const struct of_device_id st7735r_of_match[] = {
-	{ .compatible = "jianda,jd-t18003-t01" },
-	{ },
-};
-MODULE_DEVICE_TABLE(of, st7735r_of_match);
-
-static const struct spi_device_id st7735r_id[] = {
-	{ "jd-t18003-t01", 0 },
-	{ },
-};
-MODULE_DEVICE_TABLE(spi, st7735r_id);
-
-static int st7735r_probe(struct spi_device *spi)
-{
-	struct device *dev = &spi->dev;
-	struct mipi_dbi_dev *dbidev;
-	struct drm_device *drm;
-	struct mipi_dbi *dbi;
-	struct gpio_desc *dc;
-	u32 rotation = 0;
-	int ret;
-
-	dbidev = kzalloc(sizeof(*dbidev), GFP_KERNEL);
-	if (!dbidev)
-		return -ENOMEM;
-
-	dbi = &dbidev->dbi;
-	drm = &dbidev->drm;
-	ret = devm_drm_dev_init(dev, drm, &st7735r_driver);
-	if (ret) {
-		kfree(dbidev);
-		return ret;
-	}
-
-	drm_mode_config_init(drm);
-
-	dbi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
-	if (IS_ERR(dbi->reset)) {
-		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
-		return PTR_ERR(dbi->reset);
-	}
-
-	dc = devm_gpiod_get(dev, "dc", GPIOD_OUT_LOW);
-	if (IS_ERR(dc)) {
-		DRM_DEV_ERROR(dev, "Failed to get gpio 'dc'\n");
-		return PTR_ERR(dc);
-	}
-
-	dbidev->backlight = devm_of_find_backlight(dev);
-	if (IS_ERR(dbidev->backlight))
-		return PTR_ERR(dbidev->backlight);
-
-	device_property_read_u32(dev, "rotation", &rotation);
-
-	ret = mipi_dbi_spi_init(spi, dbi, dc);
-	if (ret)
-		return ret;
-
-	/* Cannot read from Adafruit 1.8" display via SPI */
-	dbi->read_commands = NULL;
-
-	ret = mipi_dbi_dev_init(dbidev, &jd_t18003_t01_pipe_funcs, &jd_t18003_t01_mode, rotation);
-	if (ret)
-		return ret;
-
-	drm_mode_config_reset(drm);
-
-	ret = drm_dev_register(drm, 0);
-	if (ret)
-		return ret;
-
-	spi_set_drvdata(spi, drm);
-
-	drm_fbdev_generic_setup(drm, 0);
-
-	return 0;
-}
-
-static int st7735r_remove(struct spi_device *spi)
-{
-	struct drm_device *drm = spi_get_drvdata(spi);
-
-	drm_dev_unplug(drm);
-	drm_atomic_helper_shutdown(drm);
-
-	return 0;
-}
-
-static void st7735r_shutdown(struct spi_device *spi)
-{
-	drm_atomic_helper_shutdown(spi_get_drvdata(spi));
-}
-
-static struct spi_driver st7735r_spi_driver = {
-	.driver = {
-		.name = "st7735r",
-		.owner = THIS_MODULE,
-		.of_match_table = st7735r_of_match,
-	},
-	.id_table = st7735r_id,
-	.probe = st7735r_probe,
-	.remove = st7735r_remove,
-	.shutdown = st7735r_shutdown,
-};
-module_spi_driver(st7735r_spi_driver);
-
-MODULE_DESCRIPTION("Sitronix ST7735R DRM driver");
-MODULE_AUTHOR("David Lechner <david@lechnology.com>");
-MODULE_LICENSE("GPL");
