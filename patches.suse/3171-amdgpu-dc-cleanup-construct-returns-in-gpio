From: Dave Airlie <airlied@redhat.com>
Date: Fri, 29 Sep 2017 14:34:38 +1000
Subject: amdgpu/dc: cleanup construct returns in gpio.
Git-commit: 0e1c42fd181e7359be5c97655198551b6660f028
Patch-mainline: v4.15-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

This is similiar to previous patches, don't return when we don't
need to, also do error checking before allocating memory, makes
it simpler to cleanup after.

Signed-off-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/amd/display/dc/gpio/hw_ddc.c  |   33 ++++++------------
 drivers/gpu/drm/amd/display/dc/gpio/hw_gpio.c |    4 --
 drivers/gpu/drm/amd/display/dc/gpio/hw_gpio.h |    2 -
 drivers/gpu/drm/amd/display/dc/gpio/hw_hpd.c  |   47 +++++++++-----------------
 4 files changed, 30 insertions(+), 56 deletions(-)

--- a/drivers/gpu/drm/amd/display/dc/gpio/hw_ddc.c
+++ b/drivers/gpu/drm/amd/display/dc/gpio/hw_ddc.c
@@ -199,25 +199,14 @@ static const struct hw_gpio_pin_funcs fu
 	.close = dal_hw_gpio_close,
 };
 
-static bool construct(
+static void construct(
 	struct hw_ddc *ddc,
 	enum gpio_id id,
 	uint32_t en,
 	struct dc_context *ctx)
 {
-	if ((en < GPIO_DDC_LINE_MIN) || (en > GPIO_DDC_LINE_MAX)) {
-		ASSERT_CRITICAL(false);
-		return false;
-	}
-
-	if (!dal_hw_gpio_construct(&ddc->base, id, en, ctx)) {
-		ASSERT_CRITICAL(false);
-		return false;
-	}
-
+	dal_hw_gpio_construct(&ddc->base, id, en, ctx);
 	ddc->base.base.funcs = &funcs;
-
-	return true;
 }
 
 struct hw_gpio_pin *dal_hw_ddc_create(
@@ -225,19 +214,19 @@ struct hw_gpio_pin *dal_hw_ddc_create(
 	enum gpio_id id,
 	uint32_t en)
 {
-	struct hw_ddc *pin = kzalloc(sizeof(struct hw_ddc), GFP_KERNEL);
+	struct hw_ddc *pin;
 
-	if (!pin) {
+	if ((en < GPIO_DDC_LINE_MIN) || (en > GPIO_DDC_LINE_MAX)) {
 		ASSERT_CRITICAL(false);
 		return NULL;
 	}
 
-	if (construct(pin, id, en, ctx))
-		return &pin->base.base;
-
-	ASSERT_CRITICAL(false);
-
-	kfree(pin);
+	pin = kzalloc(sizeof(struct hw_ddc), GFP_KERNEL);
+	if (!pin) {
+		ASSERT_CRITICAL(false);
+		return NULL;
+	}
 
-	return NULL;
+	construct(pin, id, en, ctx);
+	return &pin->base.base;
 }
--- a/drivers/gpu/drm/amd/display/dc/gpio/hw_gpio.c
+++ b/drivers/gpu/drm/amd/display/dc/gpio/hw_gpio.c
@@ -176,7 +176,7 @@ enum gpio_result dal_hw_gpio_config_mode
 	}
 }
 
-bool dal_hw_gpio_construct(
+void dal_hw_gpio_construct(
 	struct hw_gpio *pin,
 	enum gpio_id id,
 	uint32_t en,
@@ -194,8 +194,6 @@ bool dal_hw_gpio_construct(
 	pin->store.mux = 0;
 
 	pin->mux_supported = false;
-
-	return true;
 }
 
 void dal_hw_gpio_destruct(
--- a/drivers/gpu/drm/amd/display/dc/gpio/hw_gpio.h
+++ b/drivers/gpu/drm/amd/display/dc/gpio/hw_gpio.h
@@ -109,7 +109,7 @@ struct hw_gpio {
 #define HW_GPIO_FROM_BASE(hw_gpio_pin) \
 	container_of((hw_gpio_pin), struct hw_gpio, base)
 
-bool dal_hw_gpio_construct(
+void dal_hw_gpio_construct(
 	struct hw_gpio *pin,
 	enum gpio_id id,
 	uint32_t en,
--- a/drivers/gpu/drm/amd/display/dc/gpio/hw_hpd.c
+++ b/drivers/gpu/drm/amd/display/dc/gpio/hw_hpd.c
@@ -41,15 +41,13 @@
 #define REG(reg)\
 	(hpd->regs->reg)
 
-static bool dal_hw_hpd_construct(
+static void dal_hw_hpd_construct(
 	struct hw_hpd *pin,
 	enum gpio_id id,
 	uint32_t en,
 	struct dc_context *ctx)
 {
-	if (!dal_hw_gpio_construct(&pin->base, id, en, ctx))
-		return false;
-	return true;
+	dal_hw_gpio_construct(&pin->base, id, en, ctx);
 }
 
 static void dal_hw_hpd_destruct(
@@ -126,30 +124,14 @@ static const struct hw_gpio_pin_funcs fu
 	.close = dal_hw_gpio_close,
 };
 
-static bool construct(
+static void construct(
 	struct hw_hpd *hpd,
 	enum gpio_id id,
 	uint32_t en,
 	struct dc_context *ctx)
 {
-	if (id != GPIO_ID_HPD) {
-		ASSERT_CRITICAL(false);
-		return false;
-	}
-
-	if ((en < GPIO_HPD_MIN) || (en > GPIO_HPD_MAX)) {
-		ASSERT_CRITICAL(false);
-		return false;
-	}
-
-	if (!dal_hw_hpd_construct(hpd, id, en, ctx)) {
-		ASSERT_CRITICAL(false);
-		return false;
-	}
-
+	dal_hw_hpd_construct(hpd, id, en, ctx);
 	hpd->base.base.funcs = &funcs;
-
-	return true;
 }
 
 struct hw_gpio_pin *dal_hw_hpd_create(
@@ -157,19 +139,24 @@ struct hw_gpio_pin *dal_hw_hpd_create(
 	enum gpio_id id,
 	uint32_t en)
 {
-	struct hw_hpd *hpd = kzalloc(sizeof(struct hw_hpd), GFP_KERNEL);
+	struct hw_hpd *hpd;
 
-	if (!hpd) {
+	if (id != GPIO_ID_HPD) {
 		ASSERT_CRITICAL(false);
 		return NULL;
 	}
 
-	if (construct(hpd, id, en, ctx))
-		return &hpd->base.base;
-
-	ASSERT_CRITICAL(false);
+	if ((en < GPIO_HPD_MIN) || (en > GPIO_HPD_MAX)) {
+		ASSERT_CRITICAL(false);
+		return NULL;
+	}
 
-	kfree(hpd);
+	hpd = kzalloc(sizeof(struct hw_hpd), GFP_KERNEL);
+	if (!hpd) {
+		ASSERT_CRITICAL(false);
+		return NULL;
+	}
 
-	return NULL;
+	construct(hpd, id, en, ctx);
+	return &hpd->base.base;
 }
