From: Hoegeun Kwon <hoegeun.kwon@samsung.com>
Date: Tue, 18 Apr 2017 17:40:35 +0900
Subject: drm/panel: s6e3ha2: Add support for s6e3hf2 panel on TM2e board
Git-commit: e2af12bfb0ba198d66acf99e14aedc34244e74dc
Patch-mainline: v4.13-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

This patch supports TM2e panel and the panel has 1600x2560 resolution
in 5.65" physical.

This identify panel type with compatibility string, also invoke
display mode that matches the type. So add the check code for s6e3ha2
compatibility and s6e3hf2 type and select the drm_display_mode of
default and edge type.

Signed-off-by: Hoegeun Kwon <hoegeun.kwon@samsung.com>
Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
Reviewed-by: Inki Dae <inki.dae@samsung.com>
[treding@nvidia.com: fixup checkpatch warnings]
Signed-off-by: Thierry Reding <treding@nvidia.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1492504836-19225-3-git-send-email-hoegeun.kwon@samsung.com

Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/panel/panel-samsung-s6e3ha2.c |   64 +++++++++++++++++++++++---
 1 file changed, 57 insertions(+), 7 deletions(-)

--- a/drivers/gpu/drm/panel/panel-samsung-s6e3ha2.c
+++ b/drivers/gpu/drm/panel/panel-samsung-s6e3ha2.c
@@ -16,6 +16,7 @@
 #include <drm/drm_panel.h>
 #include <linux/backlight.h>
 #include <linux/gpio/consumer.h>
+#include <linux/of_device.h>
 #include <linux/regulator/consumer.h>
 
 #define S6E3HA2_MIN_BRIGHTNESS		0
@@ -218,6 +219,16 @@ unsigned char vint_table[S6E3HA2_VINT_ST
 	0x1d, 0x1e, 0x1f, 0x20, 0x21
 };
 
+enum s6e3ha2_type {
+	HA2_TYPE,
+	HF2_TYPE,
+};
+
+struct s6e3ha2_panel_desc {
+	const struct drm_display_mode *mode;
+	enum s6e3ha2_type type;
+};
+
 struct s6e3ha2 {
 	struct device *dev;
 	struct drm_panel panel;
@@ -226,6 +237,8 @@ struct s6e3ha2 {
 	struct regulator_bulk_data supplies[2];
 	struct gpio_desc *reset_gpio;
 	struct gpio_desc *enable_gpio;
+
+	const struct s6e3ha2_panel_desc *desc;
 };
 
 static int s6e3ha2_dcs_write(struct s6e3ha2 *ctx, const void *data, size_t len)
@@ -283,11 +296,21 @@ static int s6e3ha2_single_dsi_set(struct
 static int s6e3ha2_freq_calibration(struct s6e3ha2 *ctx)
 {
 	s6e3ha2_dcs_write_seq_static(ctx, 0xfd, 0x1c);
+	if (ctx->desc->type == HF2_TYPE)
+		s6e3ha2_dcs_write_seq_static(ctx, 0xf2, 0x67, 0x40, 0xc5);
 	s6e3ha2_dcs_write_seq_static(ctx, 0xfe, 0x20, 0x39);
 	s6e3ha2_dcs_write_seq_static(ctx, 0xfe, 0xa0);
 	s6e3ha2_dcs_write_seq_static(ctx, 0xfe, 0x20);
-	s6e3ha2_dcs_write_seq_static(ctx, 0xce, 0x03, 0x3b, 0x12, 0x62, 0x40,
-				0x80, 0xc0, 0x28, 0x28, 0x28, 0x28, 0x39, 0xc5);
+
+	if (ctx->desc->type == HA2_TYPE)
+		s6e3ha2_dcs_write_seq_static(ctx, 0xce, 0x03, 0x3b, 0x12, 0x62,
+						  0x40, 0x80, 0xc0, 0x28, 0x28,
+						  0x28, 0x28, 0x39, 0xc5);
+	else
+		s6e3ha2_dcs_write_seq_static(ctx, 0xce, 0x03, 0x3b, 0x14, 0x6d,
+						  0x40, 0x80, 0xc0, 0x28, 0x28,
+						  0x28, 0x28, 0x39, 0xc5);
+
 	return 0;
 }
 
@@ -583,7 +606,7 @@ static int s6e3ha2_enable(struct drm_pan
 	return 0;
 }
 
-static const struct drm_display_mode default_mode = {
+static const struct drm_display_mode s6e3ha2_mode = {
 	.clock = 222372,
 	.hdisplay = 1440,
 	.hsync_start = 1440 + 1,
@@ -597,16 +620,41 @@ static const struct drm_display_mode def
 	.flags = 0,
 };
 
+static const struct s6e3ha2_panel_desc samsung_s6e3ha2 = {
+	.mode = &s6e3ha2_mode,
+	.type = HA2_TYPE,
+};
+
+static const struct drm_display_mode s6e3hf2_mode = {
+	.clock = 247856,
+	.hdisplay = 1600,
+	.hsync_start = 1600 + 1,
+	.hsync_end = 1600 + 1 + 1,
+	.htotal = 1600 + 1 + 1 + 1,
+	.vdisplay = 2560,
+	.vsync_start = 2560 + 1,
+	.vsync_end = 2560 + 1 + 1,
+	.vtotal = 2560 + 1 + 1 + 15,
+	.vrefresh = 60,
+	.flags = 0,
+};
+
+static const struct s6e3ha2_panel_desc samsung_s6e3hf2 = {
+	.mode = &s6e3hf2_mode,
+	.type = HF2_TYPE,
+};
+
 static int s6e3ha2_get_modes(struct drm_panel *panel)
 {
 	struct drm_connector *connector = panel->connector;
+	struct s6e3ha2 *ctx = container_of(panel, struct s6e3ha2, panel);
 	struct drm_display_mode *mode;
 
-	mode = drm_mode_duplicate(panel->drm, &default_mode);
+	mode = drm_mode_duplicate(panel->drm, ctx->desc->mode);
 	if (!mode) {
 		DRM_ERROR("failed to add mode %ux%ux@%u\n",
-				default_mode.hdisplay, default_mode.vdisplay,
-				default_mode.vrefresh);
+			ctx->desc->mode->hdisplay, ctx->desc->mode->vdisplay,
+			ctx->desc->mode->vrefresh);
 		return -ENOMEM;
 	}
 
@@ -642,6 +690,7 @@ static int s6e3ha2_probe(struct mipi_dsi
 	mipi_dsi_set_drvdata(dsi, ctx);
 
 	ctx->dev = dev;
+	ctx->desc = of_device_get_match_data(dev);
 
 	dsi->lanes = 4;
 	dsi->format = MIPI_DSI_FMT_RGB888;
@@ -717,7 +766,8 @@ static int s6e3ha2_remove(struct mipi_ds
 }
 
 static const struct of_device_id s6e3ha2_of_match[] = {
-	{ .compatible = "samsung,s6e3ha2" },
+	{ .compatible = "samsung,s6e3ha2", .data = &samsung_s6e3ha2 },
+	{ .compatible = "samsung,s6e3hf2", .data = &samsung_s6e3hf2 },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, s6e3ha2_of_match);
