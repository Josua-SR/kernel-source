From: Yunsheng Lin <linyunsheng@huawei.com>
Date: Mon, 6 May 2019 10:48:46 +0800
Subject: net: hns3: refactor BD filling for l2l3l4 info
Patch-mainline: v5.2-rc1
Git-commit: 07918fcde144628f12048d5f95f28c40b073fba8
References: bsc#1104353 FATE#326415 bsc#1134947

This patch separates the inner and outer l2l3l4 len handling in
hns3_set_l2l3l4_len, this is a preparation to combine the l2l3l4
len and checksum handling for inner and outer header.

Signed-off-by: Yunsheng Lin <linyunsheng@huawei.com>
Signed-off-by: Huazhong Tan <tanhuazhong@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/hisilicon/hns3/hns3_enet.c |   64 +++++++++---------------
 1 file changed, 24 insertions(+), 40 deletions(-)

--- a/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
@@ -741,65 +741,49 @@ static void hns3_set_l2l3l4_len(struct s
 				u8 il4_proto, u32 *type_cs_vlan_tso,
 				u32 *ol_type_vlan_len_msec)
 {
+	unsigned char *l2_hdr = skb->data;
+	u8 l4_proto = ol4_proto;
 	union l3_hdr_info l3;
 	union l4_hdr_info l4;
-	unsigned char *l2_hdr;
-	u8 l4_proto = ol4_proto;
-	u32 ol2_len;
-	u32 ol3_len;
-	u32 ol4_len;
 	u32 l2_len;
 	u32 l3_len;
+	u32 l4_len;
 
 	l3.hdr = skb_network_header(skb);
 	l4.hdr = skb_transport_header(skb);
 
-	/* compute L2 header size for normal packet, defined in 2 Bytes */
-	l2_len = l3.hdr - skb->data;
-	hns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L2LEN_S, l2_len >> 1);
-
-	/* tunnel packet*/
+	/* tunnel packet */
 	if (skb->encapsulation) {
+		/* not MAC in UDP, MAC in GRE (0x6558) */
+		if (!(ol4_proto == IPPROTO_UDP || ol4_proto == IPPROTO_GRE))
+			return;
+
 		/* compute OL2 header size, defined in 2 Bytes */
-		ol2_len = l2_len;
+		l2_len = l3.hdr - skb->data;
 		hns3_set_field(*ol_type_vlan_len_msec,
-			       HNS3_TXD_L2LEN_S, ol2_len >> 1);
+			       HNS3_TXD_L2LEN_S, l2_len >> 1);
 
 		/* compute OL3 header size, defined in 4 Bytes */
-		ol3_len = l4.hdr - l3.hdr;
+		l3_len = l4.hdr - l3.hdr;
 		hns3_set_field(*ol_type_vlan_len_msec, HNS3_TXD_L3LEN_S,
-			       ol3_len >> 2);
+			       l3_len >> 2);
 
-		/* MAC in UDP, MAC in GRE (0x6558)*/
-		if ((ol4_proto == IPPROTO_UDP) || (ol4_proto == IPPROTO_GRE)) {
-			/* switch MAC header ptr from outer to inner header.*/
-			l2_hdr = skb_inner_mac_header(skb);
-
-			/* compute OL4 header size, defined in 4 Bytes. */
-			ol4_len = l2_hdr - l4.hdr;
-			hns3_set_field(*ol_type_vlan_len_msec,
-				       HNS3_TXD_L4LEN_S, ol4_len >> 2);
-
-			/* switch IP header ptr from outer to inner header */
-			l3.hdr = skb_inner_network_header(skb);
-
-			/* compute inner l2 header size, defined in 2 Bytes. */
-			l2_len = l3.hdr - l2_hdr;
-			hns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L2LEN_S,
-				       l2_len >> 1);
-		} else {
-			/* skb packet types not supported by hardware,
-			 * txbd len fild doesn't be filled.
-			 */
-			return;
-		}
-
-		/* switch L4 header pointer from outer to inner */
+		l2_hdr = skb_inner_mac_header(skb);
+		/* compute OL4 header size, defined in 4 Bytes. */
+		l4_len = l2_hdr - l4.hdr;
+		hns3_set_field(*ol_type_vlan_len_msec, HNS3_TXD_L4LEN_S,
+			       l4_len >> 2);
+
+		/* switch to inner header */
+		l2_hdr = skb_inner_mac_header(skb);
+		l3.hdr = skb_inner_network_header(skb);
 		l4.hdr = skb_inner_transport_header(skb);
-
 		l4_proto = il4_proto;
 	}
 
+	l2_len = l3.hdr - l2_hdr;
+	hns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L2LEN_S, l2_len >> 1);
+
 	/* compute inner(/normal) L3 header size, defined in 4 Bytes */
 	l3_len = l4.hdr - l3.hdr;
 	hns3_set_field(*type_cs_vlan_tso, HNS3_TXD_L3LEN_S, l3_len >> 2);
