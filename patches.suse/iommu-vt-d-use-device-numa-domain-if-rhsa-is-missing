From: Lu Baolu <baolu.lu@linux.intel.com>
Date: Tue, 22 Sep 2020 14:08:43 +0800
Subject: iommu/vt-d: Use device numa domain if RHSA is missing
Git-commit: d2ef0962492c3be3563e53a431c285678849b3c1
Patch-mainline: v5.10-rc1
References: bsc#1184585

If there are multiple NUMA domains but the RHSA is missing in ACPI/DMAR
table, we could default to the device NUMA domain as fall back.

Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
Reviewed-by: Kevin Tian <kevin.tian@intel.com>
Cc: Jacob Pan <jacob.jun.pan@linux.intel.com>
Cc: Kevin Tian <kevin.tian@intel.com>
Cc: Ashok Raj <ashok.raj@intel.com>
Link: https://lore.kernel.org/r/20200904010303.2961-1-baolu.lu@linux.intel.com
Link: https://lore.kernel.org/r/20200922060843.31546-2-baolu.lu@linux.intel.com
Signed-off-by: Joerg Roedel <jroedel@suse.de>
---
 drivers/iommu/intel/iommu.c |   37 +++++++++++++++++++++++++++++++++++--
 1 file changed, 35 insertions(+), 2 deletions(-)

--- a/drivers/iommu/intel/iommu.c
+++ b/drivers/iommu/intel/iommu.c
@@ -699,12 +699,47 @@ static int domain_update_iommu_superpage
 	return fls(mask);
 }
 
+static int domain_update_device_node(struct dmar_domain *domain)
+{
+       struct device_domain_info *info;
+       int nid = NUMA_NO_NODE;
+
+       assert_spin_locked(&device_domain_lock);
+
+       if (list_empty(&domain->devices))
+               return NUMA_NO_NODE;
+
+       list_for_each_entry(info, &domain->devices, link) {
+               if (!info->dev)
+                       continue;
+
+               /*
+                * There could possibly be multiple device numa nodes as devices
+                * within the same domain may sit behind different IOMMUs. There
+                * isn't perfect answer in such situation, so we select first
+                * come first served policy.
+                */
+               nid = dev_to_node(info->dev);
+               if (nid != NUMA_NO_NODE)
+                       break;
+       }
+
+       return nid;
+}
+
 /* Some capabilities may be different across iommus */
 static void domain_update_iommu_cap(struct dmar_domain *domain)
 {
 	domain_update_iommu_coherency(domain);
 	domain->iommu_snooping = domain_update_iommu_snooping(NULL);
 	domain->iommu_superpage = domain_update_iommu_superpage(domain, NULL);
+
+	/*
+	 * If RHSA is missing, we should default to the device numa domain
+	 * as fall back.
+	 */
+	if (domain->nid == NUMA_NO_NODE)
+		domain->nid = domain_update_device_node(domain);
 }
 
 struct context_entry *iommu_context_addr(struct intel_iommu *iommu, u8 bus,
@@ -5075,8 +5110,6 @@ static struct iommu_domain *intel_iommu_
 		if (type == IOMMU_DOMAIN_DMA)
 			intel_init_iova_domain(dmar_domain);
 
-		domain_update_iommu_cap(dmar_domain);
-
 		domain = &dmar_domain->domain;
 		domain->geometry.aperture_start = 0;
 		domain->geometry.aperture_end   =
