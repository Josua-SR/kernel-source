From: Marc Zyngier <marc.zyngier@arm.com>
Date: Sun, 27 May 2018 17:03:03 +0100
Subject: irqchip/gic-v3-its: Drop chunk allocation compatibility
Git-commit: 38dd7c494cf604879e187e9b56690d25f876cf69
Patch-mainline: v4.19-rc1
References: bsc#1111147

The chunk allocation system is now officially dead, so let's
remove it.

Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
Signed-off-by: Matthias Brugger <mbrugger@suse.com>
---
 drivers/irqchip/irq-gic-v3-its.c |   41 +++++++++++++++------------------------
 1 file changed, 16 insertions(+), 25 deletions(-)

--- a/drivers/irqchip/irq-gic-v3-its.c
+++ b/drivers/irqchip/irq-gic-v3-its.c
@@ -1435,12 +1435,6 @@ static struct irq_chip its_irq_chip = {
  * freeing is expensive. We assumes that freeing rarely occurs.
  */
 
-/*
- * Compatibility defines until we fully refactor the allocator
- */
-#define IRQS_PER_CHUNK_SHIFT	5
-#define IRQS_PER_CHUNK		(1UL << IRQS_PER_CHUNK_SHIFT)
-
 static DEFINE_MUTEX(lpi_range_lock);
 static LIST_HEAD(lpi_range_list);
 
@@ -1553,30 +1547,27 @@ static int __init its_lpi_init(u32 id_bi
 	return err;
 }
 
-static unsigned long *its_lpi_alloc_chunks(int nr_irqs, u32 *base, int *nr_ids)
+static unsigned long *its_lpi_alloc(int nr_irqs, u32 *base, int *nr_ids)
 {
 	unsigned long *bitmap = NULL;
 	int err = 0;
-	int nr_lpis;
-
-	nr_lpis = round_up(nr_irqs, IRQS_PER_CHUNK);
 
 	do {
-		err = alloc_lpi_range(nr_lpis, base);
+		err = alloc_lpi_range(nr_irqs, base);
 		if (!err)
 			break;
 
-		nr_lpis -= IRQS_PER_CHUNK;
-	} while (nr_lpis > 0);
+		nr_irqs /= 2;
+	} while (nr_irqs > 0);
 
 	if (err)
 		goto out;
 
-	bitmap = kcalloc(BITS_TO_LONGS(nr_lpis), sizeof (long), GFP_ATOMIC);
+	bitmap = kcalloc(BITS_TO_LONGS(nr_irqs), sizeof (long), GFP_ATOMIC);
 	if (!bitmap)
 		goto out;
 
-	*nr_ids = nr_lpis;
+	*nr_ids = nr_irqs;
 
 out:
 	if (!bitmap)
@@ -1585,7 +1576,7 @@ out:
 	return bitmap;
 }
 
-static void its_lpi_free_chunks(unsigned long *bitmap, u32 base, u32 nr_ids)
+static void its_lpi_free(unsigned long *bitmap, u32 base, u32 nr_ids)
 {
 	WARN_ON(free_lpi_range(base, nr_ids));
 	kfree(bitmap);
@@ -2207,7 +2198,7 @@ static struct its_device *its_create_dev
 	sz = max(sz, ITS_ITT_ALIGN) + ITS_ITT_ALIGN - 1;
 	itt = kzalloc(sz, GFP_KERNEL);
 	if (alloc_lpis) {
-		lpi_map = its_lpi_alloc_chunks(nvecs, &lpi_base, &nr_lpis);
+		lpi_map = its_lpi_alloc(nvecs, &lpi_base, &nr_lpis);
 		if (lpi_map)
 			col_map = kzalloc(sizeof(*col_map) * nr_lpis,
 					  GFP_KERNEL);
@@ -2434,9 +2425,9 @@ static void its_irq_domain_free(struct i
 	/* If all interrupts have been freed, start mopping the floor */
 	if (bitmap_empty(its_dev->event_map.lpi_map,
 			 its_dev->event_map.nr_lpis)) {
-		its_lpi_free_chunks(its_dev->event_map.lpi_map,
-				    its_dev->event_map.lpi_base,
-				    its_dev->event_map.nr_lpis);
+		its_lpi_free(its_dev->event_map.lpi_map,
+			     its_dev->event_map.lpi_base,
+			     its_dev->event_map.nr_lpis);
 		kfree(its_dev->event_map.col_map);
 
 		/* Unmap device/itt */
@@ -2837,7 +2828,7 @@ static void its_vpe_irq_domain_free(stru
 	}
 
 	if (bitmap_empty(vm->db_bitmap, vm->nr_db_lpis)) {
-		its_lpi_free_chunks(vm->db_bitmap, vm->db_lpi_base, vm->nr_db_lpis);
+		its_lpi_free(vm->db_bitmap, vm->db_lpi_base, vm->nr_db_lpis);
 		its_free_prop_table(vm->vprop_page);
 	}
 }
@@ -2852,18 +2843,18 @@ static int its_vpe_irq_domain_alloc(stru
 
 	BUG_ON(!vm);
 
-	bitmap = its_lpi_alloc_chunks(roundup_pow_of_two(nr_irqs), &base, &nr_ids);
+	bitmap = its_lpi_alloc(roundup_pow_of_two(nr_irqs), &base, &nr_ids);
 	if (!bitmap)
 		return -ENOMEM;
 
 	if (nr_ids < nr_irqs) {
-		its_lpi_free_chunks(bitmap, base, nr_ids);
+		its_lpi_free(bitmap, base, nr_ids);
 		return -ENOMEM;
 	}
 
 	vprop_page = its_allocate_prop_table(GFP_KERNEL);
 	if (!vprop_page) {
-		its_lpi_free_chunks(bitmap, base, nr_ids);
+		its_lpi_free(bitmap, base, nr_ids);
 		return -ENOMEM;
 	}
 
@@ -2890,7 +2881,7 @@ static int its_vpe_irq_domain_alloc(stru
 		if (i > 0)
 			its_vpe_irq_domain_free(domain, virq, i - 1);
 
-		its_lpi_free_chunks(bitmap, base, nr_ids);
+		its_lpi_free(bitmap, base, nr_ids);
 		its_free_prop_table(vprop_page);
 	}
 
