From: Parav Pandit <parav@mellanox.com>
Date: Tue, 28 Aug 2018 15:08:44 +0300
Subject: RDMA/core: Use simpler spin lock irq API from blocking context
Patch-mainline: v4.20-rc1
Git-commit: 2d65f49ff961da5e974a48e250edd24b0c6f54d6
References: bsc#1103992 FATE#326009

add_client_context(), ib_unregister_device() and ib_unregister_client()
are designed to call from blocking context.  There is no need to save and
restore last interrupt state when called from such blocking context.  Even
though this is not a performance path, using the right spin lock API is
desired for code clarity.

To avoid checkpatch warning while removing flags, sizeof() is used.

Signed-off-by: Parav Pandit <parav@mellanox.com>
Reviewed-by: Daniel Jurgens <danielj@mellanox.com>
Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/infiniband/core/device.c |   20 +++++++++-----------
 1 file changed, 9 insertions(+), 11 deletions(-)

--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@ -297,9 +297,8 @@ EXPORT_SYMBOL(ib_dealloc_device);
 static int add_client_context(struct ib_device *device, struct ib_client *client)
 {
 	struct ib_client_data *context;
-	unsigned long flags;
 
-	context = kmalloc(sizeof *context, GFP_KERNEL);
+	context = kmalloc(sizeof(*context), GFP_KERNEL);
 	if (!context)
 		return -ENOMEM;
 
@@ -308,9 +307,9 @@ static int add_client_context(struct ib_
 	context->going_down = false;
 
 	down_write(&lists_rwsem);
-	spin_lock_irqsave(&device->client_data_lock, flags);
+	spin_lock_irq(&device->client_data_lock);
 	list_add(&context->list, &device->client_data_list);
-	spin_unlock_irqrestore(&device->client_data_lock, flags);
+	spin_unlock_irq(&device->client_data_lock);
 	up_write(&lists_rwsem);
 
 	return 0;
@@ -587,10 +586,10 @@ void ib_unregister_device(struct ib_devi
 
 	down_write(&lists_rwsem);
 	list_del(&device->core_list);
-	spin_lock_irqsave(&device->client_data_lock, flags);
+	spin_lock_irq(&device->client_data_lock);
 	list_for_each_entry(context, &device->client_data_list, list)
 		context->going_down = true;
-	spin_unlock_irqrestore(&device->client_data_lock, flags);
+	spin_unlock_irq(&device->client_data_lock);
 	downgrade_write(&lists_rwsem);
 
 	list_for_each_entry(context, &device->client_data_list, list) {
@@ -668,7 +667,6 @@ void ib_unregister_client(struct ib_clie
 {
 	struct ib_client_data *context;
 	struct ib_device *device;
-	unsigned long flags;
 
 	mutex_lock(&device_mutex);
 
@@ -680,14 +678,14 @@ void ib_unregister_client(struct ib_clie
 		struct ib_client_data *found_context = NULL;
 
 		down_write(&lists_rwsem);
-		spin_lock_irqsave(&device->client_data_lock, flags);
+		spin_lock_irq(&device->client_data_lock);
 		list_for_each_entry(context, &device->client_data_list, list)
 			if (context->client == client) {
 				context->going_down = true;
 				found_context = context;
 				break;
 			}
-		spin_unlock_irqrestore(&device->client_data_lock, flags);
+		spin_unlock_irq(&device->client_data_lock);
 		up_write(&lists_rwsem);
 
 		if (client->remove)
@@ -701,9 +699,9 @@ void ib_unregister_client(struct ib_clie
 		}
 
 		down_write(&lists_rwsem);
-		spin_lock_irqsave(&device->client_data_lock, flags);
+		spin_lock_irq(&device->client_data_lock);
 		list_del(&found_context->list);
-		spin_unlock_irqrestore(&device->client_data_lock, flags);
+		spin_unlock_irq(&device->client_data_lock);
 		up_write(&lists_rwsem);
 		kfree(found_context);
 	}
