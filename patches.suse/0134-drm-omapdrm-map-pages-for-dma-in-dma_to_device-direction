From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Fri, 21 Apr 2017 00:33:58 +0300
Subject: drm: omapdrm: Map pages for DMA in DMA_TO_DEVICE direction
Git-commit: 97817fd46518aa2f457ce41f6a9aecd36b461426
Patch-mainline: v4.13-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

The display engine only reads from memory, there's no need to use
bidirectional DMA mappings. Use DMA_TO_DEVICE instead.

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/omapdrm/omap_gem.c        |   11 +++++------
 drivers/gpu/drm/omapdrm/omap_gem_dmabuf.c |    4 ++--
 2 files changed, 7 insertions(+), 8 deletions(-)

--- a/drivers/gpu/drm/omapdrm/omap_gem.c
+++ b/drivers/gpu/drm/omapdrm/omap_gem.c
@@ -254,7 +254,7 @@ static int omap_gem_attach_pages(struct
 
 		for (i = 0; i < npages; i++) {
 			addrs[i] = dma_map_page(dev->dev, pages[i],
-					0, PAGE_SIZE, DMA_BIDIRECTIONAL);
+					0, PAGE_SIZE, DMA_TO_DEVICE);
 
 			if (dma_mapping_error(dev->dev, addrs[i])) {
 				dev_warn(dev->dev,
@@ -262,7 +262,7 @@ static int omap_gem_attach_pages(struct
 
 				for (i = i - 1; i >= 0; --i) {
 					dma_unmap_page(dev->dev, addrs[i],
-						PAGE_SIZE, DMA_BIDIRECTIONAL);
+						PAGE_SIZE, DMA_TO_DEVICE);
 				}
 
 				ret = -ENOMEM;
@@ -322,7 +322,7 @@ static void omap_gem_detach_pages(struct
 	for (i = 0; i < npages; i++) {
 		if (omap_obj->dma_addrs[i])
 			dma_unmap_page(obj->dev->dev, omap_obj->dma_addrs[i],
-				       PAGE_SIZE, DMA_BIDIRECTIONAL);
+				       PAGE_SIZE, DMA_TO_DEVICE);
 	}
 
 	kfree(omap_obj->dma_addrs);
@@ -744,7 +744,7 @@ void omap_gem_cpu_sync_page(struct drm_g
 
 	if (omap_obj->dma_addrs[pgoff]) {
 		dma_unmap_page(dev->dev, omap_obj->dma_addrs[pgoff],
-				PAGE_SIZE, DMA_BIDIRECTIONAL);
+				PAGE_SIZE, DMA_TO_DEVICE);
 		omap_obj->dma_addrs[pgoff] = 0;
 	}
 }
@@ -767,8 +767,7 @@ void omap_gem_dma_sync_buffer(struct drm
 			dma_addr_t addr;
 
 			addr = dma_map_page(dev->dev, pages[i], 0,
-					    PAGE_SIZE, DMA_BIDIRECTIONAL);
-
+					    PAGE_SIZE, dir);
 			if (dma_mapping_error(dev->dev, addr)) {
 				dev_warn(dev->dev, "%s: failed to map page\n",
 					__func__);
--- a/drivers/gpu/drm/omapdrm/omap_gem_dmabuf.c
+++ b/drivers/gpu/drm/omapdrm/omap_gem_dmabuf.c
@@ -210,7 +210,7 @@ struct drm_gem_object *omap_gem_prime_im
 
 	get_dma_buf(dma_buf);
 
-	sgt = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);
+	sgt = dma_buf_map_attachment(attach, DMA_TO_DEVICE);
 	if (IS_ERR(sgt)) {
 		ret = PTR_ERR(sgt);
 		goto fail_detach;
@@ -227,7 +227,7 @@ struct drm_gem_object *omap_gem_prime_im
 	return obj;
 
 fail_unmap:
-	dma_buf_unmap_attachment(attach, sgt, DMA_BIDIRECTIONAL);
+	dma_buf_unmap_attachment(attach, sgt, DMA_TO_DEVICE);
 fail_detach:
 	dma_buf_detach(dma_buf, attach);
 	dma_buf_put(dma_buf);
