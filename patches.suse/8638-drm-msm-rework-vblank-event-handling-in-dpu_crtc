From: Rajesh Yadav <ryadav@codeaurora.org>
Date: Fri, 13 Jul 2018 18:27:23 +0530
Subject: drm/msm: rework vblank event handling in dpu_crtc
Git-commit: 2f2eb723b50b4da887a34570ff15a3c23d966b85
Patch-mainline: v4.19-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

The vblank on/off calls were missing in dpu_crtc
leading to "driver forgot to call drm_crtc_vblank_off()"
warning while entering suspend state.
Also handle the state update completion event for
a crtc being disabled in current atomic commit.

This patch depends on https://www.spinics.net/lists/dri-devel/msg182402.html

Signed-off-by: Rajesh Yadav <ryadav@codeaurora.org>
Signed-off-by: Sean Paul <seanpaul@chromium.org>
Signed-off-by: Rob Clark <robdclark@gmail.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/msm/disp/dpu1/dpu_crtc.c |   15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

--- a/drivers/gpu/drm/msm/disp/dpu1/dpu_crtc.c
+++ b/drivers/gpu/drm/msm/disp/dpu1/dpu_crtc.c
@@ -1606,6 +1606,7 @@ static void dpu_crtc_disable(struct drm_
 	struct drm_encoder *encoder;
 	struct msm_drm_private *priv;
 	int ret;
+	unsigned long flags;
 
 	if (!crtc || !crtc->dev || !crtc->dev->dev_private || !crtc->state) {
 		DPU_ERROR("invalid crtc\n");
@@ -1621,6 +1622,9 @@ static void dpu_crtc_disable(struct drm_
 	if (dpu_kms_is_suspend_state(crtc->dev))
 		_dpu_crtc_set_suspend(crtc, true);
 
+	/* Disable/save vblank irq handling */
+	drm_crtc_vblank_off(crtc);
+
 	mutex_lock(&dpu_crtc->crtc_lock);
 
 	/* wait for frame_event_done completion */
@@ -1658,7 +1662,6 @@ static void dpu_crtc_disable(struct drm_
 		dpu_power_handle_unregister_event(dpu_crtc->phandle,
 				dpu_crtc->power_event);
 
-
 	memset(dpu_crtc->mixers, 0, sizeof(dpu_crtc->mixers));
 	dpu_crtc->num_mixers = 0;
 	dpu_crtc->mixers_swapped = false;
@@ -1668,6 +1671,13 @@ static void dpu_crtc_disable(struct drm_
 	cstate->bw_split_vote = false;
 
 	mutex_unlock(&dpu_crtc->crtc_lock);
+
+	if (crtc->state->event && !crtc->state->active) {
+		spin_lock_irqsave(&crtc->dev->event_lock, flags);
+		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		crtc->state->event = NULL;
+		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+	}
 }
 
 static void dpu_crtc_enable(struct drm_crtc *crtc,
@@ -1707,6 +1717,9 @@ static void dpu_crtc_enable(struct drm_c
 
 	mutex_unlock(&dpu_crtc->crtc_lock);
 
+	/* Enable/restore vblank irq handling */
+	drm_crtc_vblank_on(crtc);
+
 	dpu_crtc->power_event = dpu_power_handle_register_event(
 		dpu_crtc->phandle,
 		DPU_POWER_EVENT_POST_ENABLE | DPU_POWER_EVENT_POST_DISABLE |
