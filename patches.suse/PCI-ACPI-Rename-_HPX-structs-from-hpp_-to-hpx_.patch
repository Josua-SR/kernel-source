From: Krzysztof Wilczynski <kw@linux.com>
Date: Tue, 27 Aug 2019 11:49:49 +0200
Subject: PCI/ACPI: Rename _HPX structs from hpp_* to hpx_*
Patch-mainline: v5.4-rc1
Git-commit: e2797ad31fb40f4ff59ebc4314d6f000d713bad9
References: jsc#SLE-16407

The names of the hpp_type0, hpp_type1 and hpp_type2 structs suggest that
they're related to _HPP, when in fact they're related to _HPX.

The struct hpp_type0 denotes an _HPX Type 0 setting record that supersedes
the _HPP setting record, and it has been used interchangeably for _HPP as
per the ACPI specification (see version 6.3, section 6.2.9.1) which states
that it should be applied to PCI, PCI-X and PCI Express devices, with
settings being ignored if they are not applicable.

Rename them to hpx_type0, hpx_type1 and hpx_type2 to reflect their relation
to _HPX rather than _HPP.

Link: https://lore.kernel.org/r/20190827094951.10613-2-kw@linux.com
Signed-off-by: Krzysztof Wilczynski <kw@linux.com>
Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
Acked-by: Lee, Chun-Yi <jlee@suse.com>
---
 drivers/pci/pci-acpi.c      |   28 ++++++++---------
 drivers/pci/probe.c         |   72 ++++++++++++++++++++++----------------------
 include/linux/pci_hotplug.h |   30 ++++++++----------
 3 files changed, 64 insertions(+), 66 deletions(-)

--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -118,7 +118,7 @@ phys_addr_t acpi_pci_root_get_mcfg_addr(
 }
 
 static acpi_status decode_type0_hpx_record(union acpi_object *record,
-					   struct hpp_type0 *hpx0)
+					   struct hpx_type0 *hpx0)
 {
 	int i;
 	union acpi_object *fields = record->package.elements;
@@ -146,7 +146,7 @@ static acpi_status decode_type0_hpx_reco
 }
 
 static acpi_status decode_type1_hpx_record(union acpi_object *record,
-					   struct hpp_type1 *hpx1)
+					   struct hpx_type1 *hpx1)
 {
 	int i;
 	union acpi_object *fields = record->package.elements;
@@ -173,7 +173,7 @@ static acpi_status decode_type1_hpx_reco
 }
 
 static acpi_status decode_type2_hpx_record(union acpi_object *record,
-					   struct hpp_type2 *hpx2)
+					   struct hpx_type2 *hpx2)
 {
 	int i;
 	union acpi_object *fields = record->package.elements;
@@ -276,9 +276,9 @@ static acpi_status acpi_run_hpx(struct p
 	acpi_status status;
 	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
 	union acpi_object *package, *record, *fields;
-	struct hpp_type0 hpx0;
-	struct hpp_type1 hpx1;
-	struct hpp_type2 hpx2;
+	struct hpx_type0 hpx0;
+	struct hpx_type1 hpx1;
+	struct hpx_type2 hpx2;
 	u32 type;
 	int i;
 
@@ -352,10 +352,10 @@ static acpi_status acpi_run_hpp(struct p
 	acpi_status status;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *package, *fields;
-	struct hpp_type0 hpp0;
+	struct hpx_type0 hpx0;
 	int i;
 
-	memset(&hpp0, 0, sizeof(hpp0));
+	memset(&hpx0, 0, sizeof(hpx0));
 
 	status = acpi_evaluate_object(handle, "_HPP", NULL, &buffer);
 	if (ACPI_FAILURE(status))
@@ -376,13 +376,13 @@ static acpi_status acpi_run_hpp(struct p
 		}
 	}
 
-	hpp0.revision        = 1;
-	hpp0.cache_line_size = fields[0].integer.value;
-	hpp0.latency_timer   = fields[1].integer.value;
-	hpp0.enable_serr     = fields[2].integer.value;
-	hpp0.enable_perr     = fields[3].integer.value;
+	hpx0.revision        = 1;
+	hpx0.cache_line_size = fields[0].integer.value;
+	hpx0.latency_timer   = fields[1].integer.value;
+	hpx0.enable_serr     = fields[2].integer.value;
+	hpx0.enable_perr     = fields[3].integer.value;
 
-	hp_ops->program_type0(dev, &hpp0);
+	hp_ops->program_type0(dev, &hpx0);
 
 exit:
 	kfree(buffer.pointer);
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1920,7 +1920,7 @@ static void pci_configure_mps(struct pci
 		 p_mps, mps, mpss);
 }
 
-static struct hpp_type0 pci_default_type0 = {
+static struct hpx_type0 pci_default_type0 = {
 	.revision = 1,
 	.cache_line_size = 8,
 	.latency_timer = 0x40,
@@ -1928,44 +1928,44 @@ static struct hpp_type0 pci_default_type
 	.enable_perr = 0,
 };
 
-static void program_hpp_type0(struct pci_dev *dev, struct hpp_type0 *hpp)
+static void program_hpx_type0(struct pci_dev *dev, struct hpx_type0 *hpx)
 {
 	u16 pci_cmd, pci_bctl;
 
-	if (!hpp)
-		hpp = &pci_default_type0;
+	if (!hpx)
+		hpx = &pci_default_type0;
 
-	if (hpp->revision > 1) {
+	if (hpx->revision > 1) {
 		pci_warn(dev, "PCI settings rev %d not supported; using defaults\n",
-			 hpp->revision);
-		hpp = &pci_default_type0;
+			 hpx->revision);
+		hpx = &pci_default_type0;
 	}
 
-	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, hpp->cache_line_size);
-	pci_write_config_byte(dev, PCI_LATENCY_TIMER, hpp->latency_timer);
+	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, hpx->cache_line_size);
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, hpx->latency_timer);
 	pci_read_config_word(dev, PCI_COMMAND, &pci_cmd);
-	if (hpp->enable_serr)
+	if (hpx->enable_serr)
 		pci_cmd |= PCI_COMMAND_SERR;
-	if (hpp->enable_perr)
+	if (hpx->enable_perr)
 		pci_cmd |= PCI_COMMAND_PARITY;
 	pci_write_config_word(dev, PCI_COMMAND, pci_cmd);
 
 	/* Program bridge control value */
 	if ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
 		pci_write_config_byte(dev, PCI_SEC_LATENCY_TIMER,
-				      hpp->latency_timer);
+				      hpx->latency_timer);
 		pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &pci_bctl);
-		if (hpp->enable_perr)
+		if (hpx->enable_perr)
 			pci_bctl |= PCI_BRIDGE_CTL_PARITY;
 		pci_write_config_word(dev, PCI_BRIDGE_CONTROL, pci_bctl);
 	}
 }
 
-static void program_hpp_type1(struct pci_dev *dev, struct hpp_type1 *hpp)
+static void program_hpx_type1(struct pci_dev *dev, struct hpx_type1 *hpx)
 {
 	int pos;
 
-	if (!hpp)
+	if (!hpx)
 		return;
 
 	pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
@@ -1990,20 +1990,20 @@ static bool pcie_root_rcb_set(struct pci
 	return false;
 }
 
-static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
+static void program_hpx_type2(struct pci_dev *dev, struct hpx_type2 *hpx)
 {
 	int pos;
 	u32 reg32;
 
-	if (!hpp)
+	if (!hpx)
 		return;
 
 	if (!pci_is_pcie(dev))
 		return;
 
-	if (hpp->revision > 1) {
+	if (hpx->revision > 1) {
 		pci_warn(dev, "PCIe settings rev %d not supported\n",
-			 hpp->revision);
+			 hpx->revision);
 		return;
 	}
 
@@ -2012,14 +2012,14 @@ static void program_hpp_type2(struct pci
 	 * those to make sure they're consistent with the rest of the
 	 * platform.
 	 */
-	hpp->pci_exp_devctl_and |= PCI_EXP_DEVCTL_PAYLOAD |
+	hpx->pci_exp_devctl_and |= PCI_EXP_DEVCTL_PAYLOAD |
 				    PCI_EXP_DEVCTL_READRQ;
-	hpp->pci_exp_devctl_or &= ~(PCI_EXP_DEVCTL_PAYLOAD |
+	hpx->pci_exp_devctl_or &= ~(PCI_EXP_DEVCTL_PAYLOAD |
 				    PCI_EXP_DEVCTL_READRQ);
 
 	/* Initialize Device Control Register */
 	pcie_capability_clear_and_set_word(dev, PCI_EXP_DEVCTL,
-			~hpp->pci_exp_devctl_and, hpp->pci_exp_devctl_or);
+			~hpx->pci_exp_devctl_and, hpx->pci_exp_devctl_or);
 
 	/* Initialize Link Control Register */
 	if (pcie_cap_has_lnkctl(dev)) {
@@ -2028,13 +2028,13 @@ static void program_hpp_type2(struct pci
 		 * If the Root Port supports Read Completion Boundary of
 		 * 128, set RCB to 128.  Otherwise, clear it.
 		 */
-		hpp->pci_exp_lnkctl_and |= PCI_EXP_LNKCTL_RCB;
-		hpp->pci_exp_lnkctl_or &= ~PCI_EXP_LNKCTL_RCB;
+		hpx->pci_exp_lnkctl_and |= PCI_EXP_LNKCTL_RCB;
+		hpx->pci_exp_lnkctl_or &= ~PCI_EXP_LNKCTL_RCB;
 		if (pcie_root_rcb_set(dev))
-			hpp->pci_exp_lnkctl_or |= PCI_EXP_LNKCTL_RCB;
+			hpx->pci_exp_lnkctl_or |= PCI_EXP_LNKCTL_RCB;
 
 		pcie_capability_clear_and_set_word(dev, PCI_EXP_LNKCTL,
-			~hpp->pci_exp_lnkctl_and, hpp->pci_exp_lnkctl_or);
+			~hpx->pci_exp_lnkctl_and, hpx->pci_exp_lnkctl_or);
 	}
 
 	/* Find Advanced Error Reporting Enhanced Capability */
@@ -2044,22 +2044,22 @@ static void program_hpp_type2(struct pci
 
 	/* Initialize Uncorrectable Error Mask Register */
 	pci_read_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, &reg32);
-	reg32 = (reg32 & hpp->unc_err_mask_and) | hpp->unc_err_mask_or;
+	reg32 = (reg32 & hpx->unc_err_mask_and) | hpx->unc_err_mask_or;
 	pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, reg32);
 
 	/* Initialize Uncorrectable Error Severity Register */
 	pci_read_config_dword(dev, pos + PCI_ERR_UNCOR_SEVER, &reg32);
-	reg32 = (reg32 & hpp->unc_err_sever_and) | hpp->unc_err_sever_or;
+	reg32 = (reg32 & hpx->unc_err_sever_and) | hpx->unc_err_sever_or;
 	pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_SEVER, reg32);
 
 	/* Initialize Correctable Error Mask Register */
 	pci_read_config_dword(dev, pos + PCI_ERR_COR_MASK, &reg32);
-	reg32 = (reg32 & hpp->cor_err_mask_and) | hpp->cor_err_mask_or;
+	reg32 = (reg32 & hpx->cor_err_mask_and) | hpx->cor_err_mask_or;
 	pci_write_config_dword(dev, pos + PCI_ERR_COR_MASK, reg32);
 
 	/* Initialize Advanced Error Capabilities and Control Register */
 	pci_read_config_dword(dev, pos + PCI_ERR_CAP, &reg32);
-	reg32 = (reg32 & hpp->adv_err_cap_and) | hpp->adv_err_cap_or;
+	reg32 = (reg32 & hpx->adv_err_cap_and) | hpx->adv_err_cap_or;
 
 	/* Don't enable ECRC generation or checking if unsupported */
 	if (!(reg32 & PCI_ERR_CAP_ECRC_GENC))
@@ -2178,15 +2178,15 @@ static void program_hpx_type3_register(s
 		pos, orig_value, write_reg);
 }
 
-static void program_hpx_type3(struct pci_dev *dev, struct hpx_type3 *hpx3)
+static void program_hpx_type3(struct pci_dev *dev, struct hpx_type3 *hpx)
 {
-	if (!hpx3)
+	if (!hpx)
 		return;
 
 	if (!pci_is_pcie(dev))
 		return;
 
-	program_hpx_type3_register(dev, hpx3);
+	program_hpx_type3_register(dev, hpx);
 }
 
 int pci_configure_extended_tags(struct pci_dev *dev, void *ign)
@@ -2370,9 +2370,9 @@ static void pci_configure_serr(struct pc
 static void pci_configure_device(struct pci_dev *dev)
 {
 	static const struct hotplug_program_ops hp_ops = {
-		.program_type0 = program_hpp_type0,
-		.program_type1 = program_hpp_type1,
-		.program_type2 = program_hpp_type2,
+		.program_type0 = program_hpx_type0,
+		.program_type1 = program_hpx_type1,
+		.program_type2 = program_hpx_type2,
 		.program_type3 = program_hpx_type3,
 	};
 
--- a/include/linux/pci_hotplug.h
+++ b/include/linux/pci_hotplug.h
@@ -86,25 +86,25 @@ void pci_hp_deregister(struct hotplug_sl
 #define pci_hp_initialize(slot, bus, nr, name) \
 	__pci_hp_initialize(slot, bus, nr, name, THIS_MODULE, KBUILD_MODNAME)
 
-/* PCI Setting Record (Type 0) */
-struct hpp_type0 {
-	u32 revision;
-	u8  cache_line_size;
-	u8  latency_timer;
+/* _HPX PCI Setting Record (Type 0); same as _HPP */
+struct hpx_type0 {
+	u32 revision;		/* Not present in _HPP */
+	u8  cache_line_size;	/* Not applicable to PCIe */
+	u8  latency_timer;	/* Not applicable to PCIe */
 	u8  enable_serr;
 	u8  enable_perr;
 };
 
-/* PCI-X Setting Record (Type 1) */
-struct hpp_type1 {
+/* _HPX PCI-X Setting Record (Type 1) */
+struct hpx_type1 {
 	u32 revision;
 	u8  max_mem_read;
 	u8  avg_max_split;
 	u16 tot_max_split;
 };
 
-/* PCI Express Setting Record (Type 2) */
-struct hpp_type2 {
+/* _HPX PCI Express Setting Record (Type 2) */
+struct hpx_type2 {
 	u32 revision;
 	u32 unc_err_mask_and;
 	u32 unc_err_mask_or;
@@ -124,9 +124,7 @@ struct hpp_type2 {
 	u32 sec_unc_err_mask_or;
 };
 
-/*
- * _HPX PCI Express Setting Record (Type 3)
- */
+/* _HPX PCI Express Setting Record (Type 3) */
 struct hpx_type3 {
 	u16 device_type;
 	u16 function_type;
@@ -145,10 +143,10 @@ struct hpx_type3 {
 };
 
 struct hotplug_program_ops {
-	void (*program_type0)(struct pci_dev *dev, struct hpp_type0 *hpp);
-	void (*program_type1)(struct pci_dev *dev, struct hpp_type1 *hpp);
-	void (*program_type2)(struct pci_dev *dev, struct hpp_type2 *hpp);
-	void (*program_type3)(struct pci_dev *dev, struct hpx_type3 *hpp);
+	void (*program_type0)(struct pci_dev *dev, struct hpx_type0 *hpx);
+	void (*program_type1)(struct pci_dev *dev, struct hpx_type1 *hpx);
+	void (*program_type2)(struct pci_dev *dev, struct hpx_type2 *hpx);
+	void (*program_type3)(struct pci_dev *dev, struct hpx_type3 *hpx);
 };
 
 enum hpx_type3_dev_type {
