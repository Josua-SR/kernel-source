From: John Fastabend <john.fastabend@gmail.com>
Date: Mon, 28 Aug 2017 07:12:01 -0700
Subject: bpf: sockmap indicate sock events to listeners
Patch-mainline: v4.14-rc1
Git-commit: 78aeaaef997db7096a17d0d3572a7940ffa5c9a0
References: bsc#1109837

After userspace pushes sockets into a sockmap it may not be receiving
data (assuming stream_{parser|verdict} programs are attached). But, it
may still want to manage the socks. A common pattern is to poll/select
for a POLLRDHUP event so we can close the sock.

This patch adds the logic to wake up these listeners.

Also add TCP_SYN_SENT to the list of events to handle. We don't want
to break the connection just because we happen to be in this state.

Signed-off-by: John Fastabend <john.fastabend@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 kernel/bpf/sockmap.c |    6 ++++++
 1 file changed, 6 insertions(+)

--- a/kernel/bpf/sockmap.c
+++ b/kernel/bpf/sockmap.c
@@ -162,6 +162,7 @@ static void smap_state_change(struct soc
 {
 	struct smap_psock_map_entry *e, *tmp;
 	struct smap_psock *psock;
+	struct socket_wq *wq;
 	struct sock *osk;
 
 	rcu_read_lock();
@@ -171,6 +172,7 @@ static void smap_state_change(struct soc
 	 * is established.
 	 */
 	switch (sk->sk_state) {
+	case TCP_SYN_SENT:
 	case TCP_SYN_RECV:
 	case TCP_ESTABLISHED:
 		break;
@@ -208,6 +210,10 @@ static void smap_state_change(struct soc
 		smap_report_sk_error(psock, EPIPE);
 		break;
 	}
+
+	wq = rcu_dereference(sk->sk_wq);
+	if (skwq_has_sleeper(wq))
+		wake_up_interruptible_all(&wq->wait);
 	rcu_read_unlock();
 }
 
