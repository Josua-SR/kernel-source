From 938a0447f094233e269f7f5ded474b13f3de8d80 Mon Sep 17 00:00:00 2001
From: Ping-Ke Shih <pkshih@realtek.com>
Date: Thu, 17 Aug 2017 12:46:48 -0500
Subject: [PATCH] staging: r8822be: Add code for halmac sub-driver
Git-commit: 938a0447f094233e269f7f5ded474b13f3de8d80
Patch-mainline: v4.14-rc1
References: FATE#326887

The RTL8822BE, an 802.11ac wireless network card, is now appearing in
new computers. Its driver is being placed in staging to reduce the time
that users of this new card will have access to in-kernel drivers.

New Realtek devices implement a common sub-driver to control the MAC
layer. The RTL8822BE is the first of these devices, thus its introduction
involves some extra code. In the wireless tree, this will be a separate
module; however, it is compiled into the 8822be driver here.

Signed-off-by: Ping-Ke Shih <pkshih@realtek.com>
Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
Cc: Yan-Hsuan Chuang <yhchuang@realtek.com>
Cc: Birming Chiu <birming@realtek.com>
Cc: Shaofu <shaofu@realtek.com>
Cc: Steven Ting <steventing@realtek.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 .../rtlwifi/halmac/halmac_2_platform.h        |    52 +
 .../halmac_8822b/halmac_8822b_cfg.h           |   132 +
 .../halmac_8822b/halmac_8822b_phy.c           |   106 +
 .../halmac_8822b/halmac_8822b_pwr_seq.c       |   563 +
 .../halmac_8822b/halmac_8822b_pwr_seq.h       |    40 +
 .../halmac_8822b/halmac_api_8822b.c           |   343 +
 .../halmac_8822b/halmac_api_8822b.h           |    44 +
 .../halmac_8822b/halmac_api_8822b_pcie.c      |   323 +
 .../halmac_8822b/halmac_api_8822b_pcie.h      |    53 +
 .../halmac_8822b/halmac_api_8822b_sdio.c      |   184 +
 .../halmac_8822b/halmac_api_8822b_sdio.h      |    42 +
 .../halmac_8822b/halmac_api_8822b_usb.c       |   185 +
 .../halmac_8822b/halmac_api_8822b_usb.h       |    45 +
 .../halmac_8822b/halmac_func_8822b.c          |   414 +
 .../halmac_8822b/halmac_func_8822b.h          |    38 +
 .../halmac/halmac_88xx/halmac_88xx_cfg.h      |   171 +
 .../halmac/halmac_88xx/halmac_api_88xx.c      |  5980 +++++++
 .../halmac/halmac_88xx/halmac_api_88xx.h      |   396 +
 .../halmac/halmac_88xx/halmac_api_88xx_pcie.c |   329 +
 .../halmac/halmac_88xx/halmac_api_88xx_pcie.h |    71 +
 .../halmac/halmac_88xx/halmac_api_88xx_sdio.c |   974 ++
 .../halmac/halmac_88xx/halmac_api_88xx_sdio.h |    84 +
 .../halmac/halmac_88xx/halmac_api_88xx_usb.c  |   554 +
 .../halmac/halmac_88xx/halmac_api_88xx_usb.h  |    73 +
 .../halmac/halmac_88xx/halmac_func_88xx.c     |  4499 ++++++
 .../halmac/halmac_88xx/halmac_func_88xx.h     |   321 +
 drivers/staging/rtlwifi/halmac/halmac_api.c   |   426 +
 drivers/staging/rtlwifi/halmac/halmac_api.h   |    82 +
 drivers/staging/rtlwifi/halmac/halmac_bit2.h  | 13407 ++++++++++++++++
 .../staging/rtlwifi/halmac/halmac_bit_8822b.h | 12103 ++++++++++++++
 .../staging/rtlwifi/halmac/halmac_fw_info.h   |   122 +
 .../halmac/halmac_fw_offload_c2h_nic.h        |   184 +
 .../halmac/halmac_fw_offload_h2c_nic.h        |   515 +
 .../halmac/halmac_h2c_extra_info_nic.h        |   115 +
 .../rtlwifi/halmac/halmac_intf_phy_cmd.h      |    54 +
 .../rtlwifi/halmac/halmac_original_c2h_nic.h  |   403 +
 .../rtlwifi/halmac/halmac_original_h2c_nic.h  |  1011 ++
 .../staging/rtlwifi/halmac/halmac_pcie_reg.h  |    28 +
 .../rtlwifi/halmac/halmac_pwr_seq_cmd.h       |   116 +
 drivers/staging/rtlwifi/halmac/halmac_reg2.h  |  1132 ++
 .../staging/rtlwifi/halmac/halmac_reg_8822b.h |   728 +
 .../rtlwifi/halmac/halmac_rx_bd_chip.h        |    48 +
 .../staging/rtlwifi/halmac/halmac_rx_bd_nic.h |    48 +
 .../rtlwifi/halmac/halmac_rx_desc_chip.h      |   118 +
 .../rtlwifi/halmac/halmac_rx_desc_nic.h       |   133 +
 .../staging/rtlwifi/halmac/halmac_sdio_reg.h  |    62 +
 .../rtlwifi/halmac/halmac_tx_bd_chip.h        |   118 +
 .../staging/rtlwifi/halmac/halmac_tx_bd_nic.h |   123 +
 .../rtlwifi/halmac/halmac_tx_desc_chip.h      |   444 +
 .../rtlwifi/halmac/halmac_tx_desc_nic.h       |   506 +
 drivers/staging/rtlwifi/halmac/halmac_type.h  |  1934 +++
 .../staging/rtlwifi/halmac/halmac_usb_reg.h   |    28 +
 drivers/staging/rtlwifi/halmac/rtl_halmac.c   |  1410 ++
 drivers/staging/rtlwifi/halmac/rtl_halmac.h   |    94 +
 54 files changed, 51508 insertions(+)
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_2_platform.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_cfg.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_phy.c
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_pwr_seq.c
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_pwr_seq.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b.c
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_pcie.c
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_pcie.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_sdio.c
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_sdio.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_usb.c
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_usb.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_func_8822b.c
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_func_8822b.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_88xx_cfg.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx.c
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_pcie.c
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_pcie.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_sdio.c
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_sdio.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_usb.c
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_usb.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_func_88xx.c
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_func_88xx.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_api.c
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_api.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_bit2.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_bit_8822b.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_fw_info.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_fw_offload_c2h_nic.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_fw_offload_h2c_nic.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_h2c_extra_info_nic.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_intf_phy_cmd.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_original_c2h_nic.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_original_h2c_nic.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_pcie_reg.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_pwr_seq_cmd.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_reg2.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_reg_8822b.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_rx_bd_chip.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_rx_bd_nic.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_rx_desc_chip.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_rx_desc_nic.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_sdio_reg.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_tx_bd_chip.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_tx_bd_nic.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_tx_desc_chip.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_tx_desc_nic.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_type.h
 create mode 100644 drivers/staging/rtlwifi/halmac/halmac_usb_reg.h
 create mode 100644 drivers/staging/rtlwifi/halmac/rtl_halmac.c
 create mode 100644 drivers/staging/rtlwifi/halmac/rtl_halmac.h

diff --git a/drivers/staging/rtlwifi/halmac/halmac_2_platform.h b/drivers/staging/rtlwifi/halmac/halmac_2_platform.h
new file mode 100644
index 000000000000..26e60cb873eb
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_2_platform.h
@@ -0,0 +1,52 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_2_PLATFORM_H_
+#define _HALMAC_2_PLATFORM_H_
+
+#include "../wifi.h"
+#include <asm/byteorder.h>
+
+#define HALMAC_PLATFORM_LITTLE_ENDIAN 1
+#define HALMAC_PLATFORM_BIG_ENDIAN 0
+
+/* Note : Named HALMAC_PLATFORM_LITTLE_ENDIAN / HALMAC_PLATFORM_BIG_ENDIAN
+ * is not mandatory. But Little endian must be '1'. Big endian must be '0'
+ */
+#if defined(__LITTLE_ENDIAN)
+#define HALMAC_SYSTEM_ENDIAN HALMAC_PLATFORM_LITTLE_ENDIAN
+#elif defined(__BIG_ENDIAN)
+#define HALMAC_SYSTEM_ENDIAN HALMAC_PLATFORM_BIG_ENDIAN
+#else
+#error
+#endif
+
+/* define the Platform SDIO Bus CLK */
+#define PLATFORM_SD_CLK 50000000 /*50MHz*/
+
+/* define the Rx FIFO expanding mode packet size unit for 8821C and 8822B */
+/* Should be 8 Byte alignment */
+#define HALMAC_RX_FIFO_EXPANDING_MODE_PKT_SIZE 16 /*Bytes*/
+
+#endif /* _HALMAC_2_PLATFORM_H_ */
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_cfg.h b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_cfg.h
new file mode 100644
index 000000000000..04e44aed9b45
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_cfg.h
@@ -0,0 +1,132 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_8822B_CFG_H_
+#define _HALMAC_8822B_CFG_H_
+
+#include "halmac_8822b_pwr_seq.h"
+#include "halmac_api_8822b.h"
+#include "halmac_api_8822b_usb.h"
+#include "halmac_api_8822b_sdio.h"
+#include "halmac_api_8822b_pcie.h"
+#include "../../halmac_bit2.h"
+#include "../../halmac_reg2.h"
+#include "../../halmac_api.h"
+
+#define HALMAC_TX_FIFO_SIZE_8822B 262144 /* 256k */
+#define HALMAC_TX_FIFO_SIZE_LA_8822B 131072 /* 128k */
+#define HALMAC_RX_FIFO_SIZE_8822B 24576 /* 24k */
+#define HALMAC_TX_PAGE_SIZE_8822B 128 /* PageSize 128Byte */
+#define HALMAC_TX_ALIGN_SIZE_8822B 8
+#define HALMAC_TX_PAGE_SIZE_2_POWER_8822B 7 /* 128 = 2^7 */
+#define HALMAC_SECURITY_CAM_ENTRY_NUM_8822B 64 /* CAM Entry size */
+#define HALMAC_TX_AGG_ALIGNMENT_SIZE_8822B 8
+#define HALMAC_TX_DESC_SIZE_8822B 48
+#define HALMAC_RX_DESC_SIZE_8822B 24
+#define HALMAC_RX_DESC_DUMMY_SIZE_MAX_8822B 120
+#define HALMAC_C2H_PKT_BUF_8822B 256
+#define HALMAC_RX_FIFO_EXPANDING_MODE_PKT_SIZE_MAX_8822B 80 /* align 8 Byte*/
+#define HALMAC_RX_FIFO_EXPANDING_UNIT_8822B                                    \
+	(HALMAC_RX_DESC_SIZE_8822B + HALMAC_RX_DESC_DUMMY_SIZE_MAX_8822B +     \
+	 HALMAC_RX_FIFO_EXPANDING_MODE_PKT_SIZE) /* align 8 Byte*/
+#define HALMAC_RX_FIFO_EXPANDING_UNIT_MAX_8822B                                \
+	(HALMAC_RX_DESC_SIZE_8822B + HALMAC_RX_DESC_DUMMY_SIZE_MAX_8822B +     \
+	 HALMAC_RX_FIFO_EXPANDING_MODE_PKT_SIZE_MAX_8822B) /* align 8 Byte*/
+
+#define HALMAC_TX_FIFO_SIZE_EX_1_BLK_8822B 196608 /* 192k */
+#define HALMAC_RX_FIFO_SIZE_EX_1_BLK_8822B                                     \
+	((((HALMAC_RX_FIFO_EXPANDING_UNIT_8822B << 8) - 1) >> 10)              \
+	 << 10) /* < 56k*/
+#define HALMAC_RX_FIFO_SIZE_EX_1_BLK_MAX_8822B                                 \
+	((((HALMAC_RX_FIFO_EXPANDING_UNIT_MAX_8822B << 8) - 1) >> 10)          \
+	 << 10) /* 55k*/
+#define HALMAC_TX_FIFO_SIZE_EX_2_BLK_8822B 131072 /* 128k */
+#define HALMAC_RX_FIFO_SIZE_EX_2_BLK_8822B 155648 /* 152k */
+#define HALMAC_TX_FIFO_SIZE_EX_3_BLK_8822B 65536 /* 64k */
+#define HALMAC_RX_FIFO_SIZE_EX_3_BLK_8822B 221184 /* 216k */
+
+/* TXFIFO LAYOUT
+ * HIGH_QUEUE
+ * NORMAL_QUEUE
+ * LOW_QUEUE
+ * EXTRA_QUEUE
+ * PUBLIC_QUEUE -- decided after all other queue are defined
+ * GAP_QUEUE -- Used to separate AC queue and Rsvd page
+ *
+ * RSVD_DRIVER -- Driver used rsvd page area
+ * RSVD_H2C_EXTRAINFO -- Extra Information for h2c
+ * RSVD_H2C_QUEUE -- h2c queue in rsvd page
+ * RSVD_CPU_INSTRUCTION -- extend fw code
+ * RSVD_FW_TXBUFF -- fw used this area to send packet
+ *
+ * Symbol: HALMAC_MODE_QUEUE_UNIT_CHIP, ex: HALMAC_LB_2BULKOUT_FWCMD_PGNUM_8822B
+ */
+#define HALMAC_EXTRA_INFO_BUFF_SIZE_FULL_FIFO_8822B                            \
+	16384 /*16K, only used in init case*/
+
+#define HALMAC_RSVD_DRV_PGNUM_8822B 16 /*2048*/
+#define HALMAC_RSVD_H2C_EXTRAINFO_PGNUM_8822B 32 /*4096*/
+#define HALMAC_RSVD_H2C_QUEUE_PGNUM_8822B 8 /*1024*/
+#define HALMAC_RSVD_CPU_INSTRUCTION_PGNUM_8822B 0 /*0*/
+#define HALMAC_RSVD_FW_TXBUFF_PGNUM_8822B 4 /*512*/
+
+#define HALMAC_EFUSE_SIZE_8822B 1024 /* 0x400 */
+#define HALMAC_BT_EFUSE_SIZE_8822B 128 /* 0x80 */
+#define HALMAC_EEPROM_SIZE_8822B 0x300
+#define HALMAC_CR_TRX_ENABLE_8822B                                             \
+	(BIT_HCI_TXDMA_EN | BIT_HCI_RXDMA_EN | BIT_TXDMA_EN | BIT_RXDMA_EN |   \
+	 BIT_PROTOCOL_EN | BIT_SCHEDULE_EN | BIT_MACTXEN | BIT_MACRXEN)
+
+#define HALMAC_BLK_DESC_NUM_8822B 0x3 /* Only for USB */
+
+/* AMPDU max time (unit : 32us) */
+#define HALMAC_AMPDU_MAX_TIME_8822B 0x70
+
+/* Protect mode control */
+#define HALMAC_PROT_RTS_LEN_TH_8822B 0xFF
+#define HALMAC_PROT_RTS_TX_TIME_TH_8822B 0x08
+#define HALMAC_PROT_MAX_AGG_PKT_LIMIT_8822B 0x20
+#define HALMAC_PROT_RTS_MAX_AGG_PKT_LIMIT_8822B 0x20
+
+/* Fast EDCA setting */
+#define HALMAC_FAST_EDCA_VO_TH_8822B 0x06
+#define HALMAC_FAST_EDCA_VI_TH_8822B 0x06
+#define HALMAC_FAST_EDCA_BE_TH_8822B 0x06
+#define HALMAC_FAST_EDCA_BK_TH_8822B 0x06
+
+/* BAR setting */
+#define HALMAC_BAR_RETRY_LIMIT_8822B 0x01
+#define HALMAC_RA_TRY_RATE_AGG_LIMIT_8822B 0x08
+
+enum halmac_normal_rxagg_th_to_8822b {
+	HALMAC_NORMAL_RXAGG_THRESHOLD_8822B = 0xFF,
+	HALMAC_NORMAL_RXAGG_TIMEOUT_8822B = 0x01,
+};
+
+enum halmac_loopback_rxagg_th_to_8822b {
+	HALMAC_LOOPBACK_RXAGG_THRESHOLD_8822B = 0xFF,
+	HALMAC_LOOPBACK_RXAGG_TIMEOUT_8822B = 0x01,
+};
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_phy.c b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_phy.c
new file mode 100644
index 000000000000..b2a5aed75dca
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_phy.c
@@ -0,0 +1,106 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "../halmac_88xx_cfg.h"
+#include "halmac_8822b_cfg.h"
+
+/**
+ * ============ip sel item list============
+ * HALMAC_IP_SEL_INTF_PHY
+ *	USB2 : usb2 phy, 1byte value
+ *	USB3 : usb3 phy, 2byte value
+ *	PCIE1 : pcie gen1 mdio, 2byte value
+ *	PCIE2 : pcie gen2 mdio, 2byte value
+ * HALMAC_IP_SEL_MAC
+ *	USB2, USB3, PCIE1, PCIE2 : mac ip, 1byte value
+ * HALMAC_IP_SEL_PCIE_DBI
+ *	USB2 USB3 : none
+ *	PCIE1, PCIE2 : pcie dbi, 1byte value
+ */
+
+struct halmac_intf_phy_para_ HALMAC_RTL8822B_USB2_PHY[] = {
+	/* {offset, value, ip sel, cut mask, platform mask} */
+	{0xFFFF, 0x00, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_ALL,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+};
+
+struct halmac_intf_phy_para_ HALMAC_RTL8822B_USB3_PHY[] = {
+	/* {offset, value, ip sel, cut mask, platform mask} */
+	{0x0001, 0xA841, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_D,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0xFFFF, 0x0000, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_ALL,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+};
+
+struct halmac_intf_phy_para_ HALMAC_RTL8822B_PCIE_PHY_GEN1[] = {
+	/* {offset, value, ip sel, cut mask, platform mask} */
+	{0x0001, 0xA841, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x0002, 0x60C6, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x0008, 0x3596, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x0009, 0x321C, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x000A, 0x9623, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x0020, 0x94FF, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x0021, 0xFFCF, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x0026, 0xC006, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x0029, 0xFF0E, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x002A, 0x1840, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0xFFFF, 0x0000, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_ALL,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+};
+
+struct halmac_intf_phy_para_ HALMAC_RTL8822B_PCIE_PHY_GEN2[] = {
+	/* {offset, value, ip sel, cut mask, platform mask} */
+	{0x0001, 0xA841, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x0002, 0x60C6, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x0008, 0x3597, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x0009, 0x321C, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x000A, 0x9623, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x0020, 0x94FF, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x0021, 0xFFCF, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x0026, 0xC006, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x0029, 0xFF0E, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0x002A, 0x3040, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_C,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+	{0xFFFF, 0x0000, HALMAC_IP_SEL_INTF_PHY, HALMAC_INTF_PHY_CUT_ALL,
+	 HALMAC_INTF_PHY_PLATFORM_ALL},
+};
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_pwr_seq.c b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_pwr_seq.c
new file mode 100644
index 000000000000..0edd1f5a04a8
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_pwr_seq.c
@@ -0,0 +1,563 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "../halmac_88xx_cfg.h"
+#include "halmac_8822b_cfg.h"
+
+static struct halmac_wl_pwr_cfg_ HALMAC_RTL8822B_TRANS_CARDEMU_TO_ACT[] = {
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value } */
+	{0x0012, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(1), 0}, /*SWR OCP = SWR OCP = 010 1382.40*/
+	{0x0012, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0), BIT(0)}, /*SWR OCP = 010 1382.40 */
+	{0x0020, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_USB_MSK | HALMAC_PWR_INTF_SDIO_MSK,
+	 HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE, BIT(0),
+	 BIT(0)}, /*0x20[0] = 1b'1 enable LDOA12 MACRO block for all interface*/
+	{0x0001, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_USB_MSK | HALMAC_PWR_INTF_SDIO_MSK,
+	 HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_DELAY, 1,
+	 HALMAC_PWRSEQ_DELAY_MS}, /*Delay 1ms*/
+	{0x0000, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_USB_MSK | HALMAC_PWR_INTF_SDIO_MSK,
+	 HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE, BIT(5),
+	 0}, /*0x00[5] = 1b'0 release analog Ips to digital ,1:isolation*/
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 (BIT(4) | BIT(3) | BIT(2)),
+	 0}, /* disable SW LPS 0x04[10]=0 and WLSUS_EN 0x04[12:11]=0*/
+	{0x0075, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_PCI_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0), BIT(0)}, /* Disable USB suspend */
+	{0x0006, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_POLLING, BIT(1),
+	 BIT(1)}, /* wait till 0x04[17] = 1    power ready*/
+	{0x0075, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_PCI_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0), 0}, /* Enable USB suspend */
+	{0xFF1A, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_USB_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0}, /*0xFF1A = 0 to release resume signals*/
+	{0x0006, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0), BIT(0)}, /* release WLON reset  0x04[16]=1*/
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(7), 0}, /* disable HWPDN 0x04[15]=0*/
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 (BIT(4) | BIT(3)), 0}, /* disable WL suspend*/
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0), BIT(0)}, /* polling until return 0*/
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_POLLING, BIT(0), 0},
+	{0x0020, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(3), BIT(3)}, /*Enable XTAL_CLK*/
+	{0x10A8, HALMAC_PWR_CUT_C_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0}, /*NFC pad enabled*/
+	{0x10A9, HALMAC_PWR_CUT_C_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0xef}, /*NFC pad enabled*/
+	{0x10AA, HALMAC_PWR_CUT_C_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0x0c}, /*NFC pad enabled*/
+	{0x0068, HALMAC_PWR_CUT_C_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_WRITE, BIT(4), BIT(4)}, /*SDIO pad power down disabled*/
+	{0x0029, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0xF9}, /*PLL seting*/
+	{0x0024, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(2), 0}, /*Improve TX EVM of CH13 and some 5G channles */
+	{0x0074, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_PCI_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(5), BIT(5)}, /*PCIE WAKE# enabled*/
+	{0xFFFF, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, 0, HALMAC_PWR_CMD_END, 0, 0},
+};
+
+static struct halmac_wl_pwr_cfg_ HALMAC_RTL8822B_TRANS_ACT_TO_CARDEMU[] = {
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value } */
+	{0x0003, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_WRITE, BIT(2), 0}, /*0x02[10] = 0 Disable MCU Core*/
+	{0x0093, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(3), 0}, /*LPS option 0x93[3]=0 , SWR PFM*/
+	{0x001F, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0}, /*0x1F[7:0] = 0 turn off RF*/
+	{0x00EF, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0}, /*0xEF[7:0] = 0 turn off RF*/
+	{0xFF1A, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_USB_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0x30}, /*0xFF1A = 0x30 to block resume signals*/
+	{0x0049, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(1), 0}, /*Enable rising edge triggering interrupt*/
+	{0x0006, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0), BIT(0)}, /* release WLON reset  0x04[16]=1*/
+	{0x0002, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(1), 0}, /* Whole BB is reset */
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(1), BIT(1)}, /*0x04[9] = 1 turn off MAC by HW state machine*/
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_POLLING, BIT(1),
+	 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/
+	{0x0020, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(3), 0}, /* XTAL_CLK gated*/
+	{0x0000, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_USB_MSK | HALMAC_PWR_INTF_SDIO_MSK,
+	 HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE, BIT(5),
+	 BIT(5)}, /*0x00[5] = 1b'1 analog Ips to digital ,1:isolation*/
+	{0xFFFF, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, 0, HALMAC_PWR_CMD_END, 0, 0},
+};
+
+static struct halmac_wl_pwr_cfg_ HALMAC_RTL8822B_TRANS_CARDEMU_TO_SUS[] = {
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value } */
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_PCI_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(4) | BIT(3),
+	 (BIT(4) | BIT(3))}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_USB_MSK | HALMAC_PWR_INTF_SDIO_MSK,
+	 HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE, BIT(3) | BIT(4),
+	 BIT(3)}, /*0x04[12:11] = 2b'01 enable WL suspend*/
+	{0x0007, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_WRITE, 0xFF,
+	 0x20}, /*0x07[7:0] = 0x20 SDIO SOP option to disable BG/MB/ACK/SWR*/
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_PCI_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(3) | BIT(4),
+	 BIT(3) | BIT(4)}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/
+	{0x0086, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_SDIO,
+	 HALMAC_PWR_CMD_WRITE, BIT(0),
+	 BIT(0)}, /*Set SDIO suspend local register*/
+	{0x0086, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_SDIO,
+	 HALMAC_PWR_CMD_POLLING, BIT(1), 0}, /*wait power state to suspend*/
+	{0xFFFF, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, 0, HALMAC_PWR_CMD_END, 0, 0},
+};
+
+static struct halmac_wl_pwr_cfg_ HALMAC_RTL8822B_TRANS_SUS_TO_CARDEMU[] = {
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value } */
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(3) | BIT(7), 0}, /*clear suspend enable and power down enable*/
+	{0x0086, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_SDIO,
+	 HALMAC_PWR_CMD_WRITE, BIT(0), 0}, /*Set SDIO suspend local register*/
+	{0x0086, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_SDIO,
+	 HALMAC_PWR_CMD_POLLING, BIT(1),
+	 BIT(1)}, /*wait power state to suspend*/
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(3) | BIT(4), 0}, /*0x04[12:11] = 2b'01enable WL suspend*/
+	{0xFFFF, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, 0, HALMAC_PWR_CMD_END, 0, 0},
+};
+
+static struct halmac_wl_pwr_cfg_ HALMAC_RTL8822B_TRANS_CARDEMU_TO_CARDDIS[] = {
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value } */
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_WRITE, BIT(7),
+	 BIT(7)}, /*suspend enable and power down enable*/
+	{0x0007, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_USB_MSK | HALMAC_PWR_INTF_SDIO_MSK,
+	 HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE, 0xFF,
+	 0x20}, /*0x07=0x20 , SOP option to disable BG/MB*/
+	{0x0067, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(5), 0}, /*0x67[5]=0 , BIT_PAPE_WLBT_SEL*/
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_USB_MSK | HALMAC_PWR_INTF_SDIO_MSK,
+	 HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE, BIT(3) | BIT(4),
+	 BIT(3)}, /*0x04[12:11] = 2b'01 enable WL suspend*/
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_PCI_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(2), BIT(2)}, /*0x04[10] = 1, enable SW LPS*/
+	{0x004A, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_USB_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0), 0}, /*0x48[16] = 0 to disable GPIO9 as EXT WAKEUP*/
+	{0x0067, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_WRITE, BIT(5),
+	 0}, /* 0: BT PAPE control ; 1: WL BB LNAON control*/
+	{0x0067, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_WRITE, BIT(4),
+	 0}, /* 0: BT GPIO[11:10] control  ; 1: WL BB LNAON control*/
+	{0x004F, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_WRITE, BIT(0), 0}, /* 0: BT Control*/
+	{0x0067, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_WRITE, BIT(1),
+	 0}, /* turn off BT_3DD_SYNC_B and BT_GPIO[18] */
+	{0x0046, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_WRITE, BIT(6), BIT(6)}, /* GPIO[6] : Output mode*/
+	{0x0067, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_WRITE, BIT(2), 0}, /* turn off BT_GPIO[16] */
+	{0x0046, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_WRITE, BIT(7), BIT(7)}, /* GPIO[7] : Output mode*/
+	{0x0062, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_WRITE, BIT(4), BIT(4)}, /* GPIO[12] : Output mode */
+	{0x0086, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_SDIO,
+	 HALMAC_PWR_CMD_WRITE, BIT(0),
+	 BIT(0)}, /*Set SDIO suspend local register*/
+	{0x0086, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_SDIO,
+	 HALMAC_PWR_CMD_POLLING, BIT(1), 0}, /*wait power state to suspend*/
+	{0x0090, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_USB_MSK | HALMAC_PWR_INTF_PCI_MSK,
+	 HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE, BIT(1),
+	 0}, /*0x90[1]=0 , disable 32k clock*/
+	{0x0044, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_SDIO,
+	 HALMAC_PWR_CMD_WRITE, 0xFF,
+	 0}, /*0x90[1]=0 , disable 32k clock by indirect access*/
+	{0x0040, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_SDIO,
+	 HALMAC_PWR_CMD_WRITE, 0xFF,
+	 0x90}, /*0x90[1]=0 , disable 32k clock by indirect access*/
+	{0x0041, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_SDIO,
+	 HALMAC_PWR_CMD_WRITE, 0xFF,
+	 0x00}, /*0x90[1]=0 , disable 32k clock by indirect access*/
+	{0x0042, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_SDIO,
+	 HALMAC_PWR_CMD_WRITE, 0xFF,
+	 0x04}, /*0x90[1]=0 , disable 32k clock by indirect access*/
+	{0x0081, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(7), 0}, /*0x80[15]clean fw init ready bit*/
+	{0xFFFF, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, 0, HALMAC_PWR_CMD_END, 0, 0},
+};
+
+static struct halmac_wl_pwr_cfg_ HALMAC_RTL8822B_TRANS_CARDDIS_TO_CARDEMU[] = {
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value } */
+	{0x0086, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_SDIO,
+	 HALMAC_PWR_CMD_WRITE, BIT(0), 0}, /*Set SDIO suspend local register*/
+	{0x0086, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_SDIO,
+	 HALMAC_PWR_CMD_POLLING, BIT(1),
+	 BIT(1)}, /*wait power state to suspend*/
+	{0x004A, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_USB_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0), 0}, /*0x48[16] = 0 to disable GPIO9 as EXT WAKEUP*/
+	{0x0005, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(3) | BIT(4) | BIT(7),
+	 0}, /*clear suspend enable and power down enable*/
+	{0x0301, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_PCI_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0},
+	{0xFFFF, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, 0, HALMAC_PWR_CMD_END, 0, 0},
+};
+
+static struct halmac_wl_pwr_cfg_ HALMAC_RTL8822B_TRANS_ACT_TO_LPS[] = {
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value } */
+	{0x0101, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(2), BIT(2)}, /*Enable 32k calibration and thermal meter*/
+	{0x0199, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(3), BIT(3)}, /*Register write data of 32K calibration*/
+	{0x019B, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(7), BIT(7)}, /*Enable 32k calibration reg write*/
+	{0x1138, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0) | BIT(1), BIT(0) | BIT(1)}, /*set RPWM IMR*/
+	{0x0194, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0), BIT(0)}, /* enable 32K CLK*/
+	{0x0093, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0x42}, /* LPS Option MAC OFF enable*/
+	{0x0092, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0x20}, /* LPS Option  Enable memory to deep sleep mode*/
+	{0x0090, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(1), BIT(1)}, /* enable reg use 32K CLK*/
+	{0x0301, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_PCI_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0xFF}, /*PCIe DMA stop*/
+	{0x0522, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0xFF}, /*Tx Pause*/
+	{0x05F8, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_POLLING, 0xFF,
+	 0}, /*Should be zero if no packet is transmitting*/
+	{0x05F9, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_POLLING, 0xFF,
+	 0}, /*Should be zero if no packet is transmitting*/
+	{0x05FA, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_POLLING, 0xFF,
+	 0}, /*Should be zero if no packet is transmitting*/
+	{0x05FB, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_POLLING, 0xFF,
+	 0}, /*Should be zero if no packet is transmitting*/
+	{0x0002, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0), 0}, /*CCK and OFDM are disabled,and clock are gated*/
+	{0x0002, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_DELAY,
+	 0, HALMAC_PWRSEQ_DELAY_US}, /*Delay 1us*/
+	{0x0002, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(1), 0}, /*Whole BB is reset*/
+	{0x0100, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0x3F}, /*Reset MAC TRX*/
+	{0x0101, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(1), 0}, /*check if removed later*/
+	{0x0553, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(5), BIT(5)}, /*Respond TxOK to scheduler*/
+	{0x0008, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(4), BIT(4)}, /* switch TSF clock to 32K*/
+	{0x0109, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_POLLING, BIT(7),
+	 BIT(7)}, /*Polling 0x109[7]=0  TSF in 40M*/
+	{0x0090, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0), BIT(0)}, /* enable WL_LPS_EN*/
+	{0xFFFF, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, 0, HALMAC_PWR_CMD_END, 0, 0},
+};
+
+static struct halmac_wl_pwr_cfg_ HALMAC_RTL8822B_TRANS_ACT_TO_DEEP_LPS[] = {
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value } */
+	{0x0101, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(2), BIT(2)}, /*Enable 32k calibration and thermal meter*/
+	{0x0199, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(3), BIT(3)}, /*Register write data of 32K calibration*/
+	{0x019B, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(7), BIT(7)}, /*Enable 32k calibration reg write*/
+	{0x1138, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0) | BIT(1), BIT(0) | BIT(1)}, /*set RPWM IMR*/
+	{0x0194, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0), BIT(0)}, /* enable 32K CLK*/
+	{0x0093, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0x40}, /* LPS Option MAC OFF enable*/
+	{0x0092, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0x20}, /* LPS Option  Enable memory to deep sleep mode*/
+	{0x0090, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(1), BIT(1)}, /* enable reg use 32K CLK*/
+	{0x0301, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_PCI_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0xFF}, /*PCIe DMA stop*/
+	{0x0522, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0xFF}, /*Tx Pause*/
+	{0x05F8, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_POLLING, 0xFF,
+	 0}, /*Should be zero if no packet is transmitting*/
+	{0x05F9, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_POLLING, 0xFF,
+	 0}, /*Should be zero if no packet is transmitting*/
+	{0x05FA, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_POLLING, 0xFF,
+	 0}, /*Should be zero if no packet is transmitting*/
+	{0x05FB, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_POLLING, 0xFF,
+	 0}, /*Should be zero if no packet is transmitting*/
+	{0x0002, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0), 0}, /*CCK and OFDM are disabled,and clock are gated*/
+	{0x0002, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_DELAY,
+	 0, HALMAC_PWRSEQ_DELAY_US}, /*Delay 1us*/
+	{0x0002, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(1), 0}, /*Whole BB is reset*/
+	{0x0100, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0x3F}, /*Reset MAC TRX*/
+	{0x0101, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(1), 0}, /*check if removed later*/
+	{0x0553, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(5), BIT(5)}, /*Respond TxOK to scheduler*/
+	{0x0008, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(4), BIT(4)}, /* switch TSF clock to 32K*/
+	{0x0109, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_POLLING, BIT(7),
+	 BIT(7)}, /*Polling 0x109[7]=1  TSF in 32K*/
+	{0x0090, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(0), BIT(0)}, /* enable WL_LPS_EN*/
+	{0xFFFF, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, 0, HALMAC_PWR_CMD_END, 0, 0},
+};
+
+static struct halmac_wl_pwr_cfg_ HALMAC_RTL8822B_TRANS_LPS_TO_ACT[] = {
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value } */
+	{0x0080, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_SDIO,
+	 HALMAC_PWR_CMD_WRITE, BIT(7), BIT(7)}, /*SDIO RPWM*/
+	{0x0002, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_DELAY,
+	 0, HALMAC_PWRSEQ_DELAY_MS}, /*Delay*/
+	{0x0080, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_SDIO_MSK, HALMAC_PWR_BASEADDR_SDIO,
+	 HALMAC_PWR_CMD_WRITE, BIT(7), 0}, /*SDIO RPWM*/
+	{0xFE58, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_USB_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0x84}, /*USB RPWM*/
+	{0x0361, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_PCI_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0x84}, /*PCIe RPWM*/
+	{0x0002, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_DELAY,
+	 0, HALMAC_PWRSEQ_DELAY_MS}, /*Delay*/
+	{0x0008, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(4), 0}, /* switch TSF to 40M*/
+	{0x0109, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC,
+	 HALMAC_PWR_CMD_POLLING, BIT(7), 0}, /*Polling 0x109[7]=0  TSF in 40M*/
+	{0x0101, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(1), BIT(1)},
+	{0x0100, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0xFF}, /*nable WMAC TRX*/
+	{0x0002, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(1) | BIT(0), BIT(1) | BIT(0)}, /*nable BB macro*/
+	{0x0522, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0},
+	{0x113C, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0x03}, /*clear RPWM INT*/
+	{0x0124, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0xFF}, /*clear FW INT*/
+	{0x0125, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0xFF}, /*clear FW INT*/
+	{0x0126, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0xFF}, /*clear FW INT*/
+	{0x0127, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 0xFF, 0xFF}, /*clear FW INT*/
+	{0x0090, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(1), 0}, /* disable reg use 32K CLK*/
+	{0x0101, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, HALMAC_PWR_BASEADDR_MAC, HALMAC_PWR_CMD_WRITE,
+	 BIT(2), 0}, /*disable 32k calibration and thermal meter*/
+	{0xFFFF, HALMAC_PWR_CUT_ALL_MSK, HALMAC_PWR_FAB_ALL_MSK,
+	 HALMAC_PWR_INTF_ALL_MSK, 0, HALMAC_PWR_CMD_END, 0, 0},
+};
+
+/* Card Enable Array */
+struct halmac_wl_pwr_cfg_ *halmac_8822b_card_enable_flow[] = {
+	HALMAC_RTL8822B_TRANS_CARDDIS_TO_CARDEMU,
+	HALMAC_RTL8822B_TRANS_CARDEMU_TO_ACT, NULL};
+
+/* Card Disable Array */
+struct halmac_wl_pwr_cfg_ *halmac_8822b_card_disable_flow[] = {
+	HALMAC_RTL8822B_TRANS_ACT_TO_CARDEMU,
+	HALMAC_RTL8822B_TRANS_CARDEMU_TO_CARDDIS, NULL};
+
+/* Suspend Array */
+struct halmac_wl_pwr_cfg_ *halmac_8822b_suspend_flow[] = {
+	HALMAC_RTL8822B_TRANS_ACT_TO_CARDEMU,
+	HALMAC_RTL8822B_TRANS_CARDEMU_TO_SUS, NULL};
+
+/* Resume Array */
+struct halmac_wl_pwr_cfg_ *halmac_8822b_resume_flow[] = {
+	HALMAC_RTL8822B_TRANS_SUS_TO_CARDEMU,
+	HALMAC_RTL8822B_TRANS_CARDEMU_TO_ACT, NULL};
+
+/* HWPDN Array - HW behavior */
+struct halmac_wl_pwr_cfg_ *halmac_8822b_hwpdn_flow[] = {NULL};
+
+/* Enter LPS - FW behavior */
+struct halmac_wl_pwr_cfg_ *halmac_8822b_enter_lps_flow[] = {
+	HALMAC_RTL8822B_TRANS_ACT_TO_LPS, NULL};
+
+/* Enter Deep LPS - FW behavior */
+struct halmac_wl_pwr_cfg_ *halmac_8822b_enter_deep_lps_flow[] = {
+	HALMAC_RTL8822B_TRANS_ACT_TO_DEEP_LPS, NULL};
+
+/* Leave LPS -FW behavior */
+struct halmac_wl_pwr_cfg_ *halmac_8822b_leave_lps_flow[] = {
+	HALMAC_RTL8822B_TRANS_LPS_TO_ACT, NULL};
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_pwr_seq.h b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_pwr_seq.h
new file mode 100644
index 000000000000..79a6072ef2ef
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_8822b_pwr_seq.h
@@ -0,0 +1,40 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef HALMAC_POWER_SEQUENCE_8822B
+#define HALMAC_POWER_SEQUENCE_8822B
+
+#include "../../halmac_pwr_seq_cmd.h"
+
+#define HALMAC_8822B_PWR_SEQ_VER "V17"
+extern struct halmac_wl_pwr_cfg_ *halmac_8822b_card_disable_flow[];
+extern struct halmac_wl_pwr_cfg_ *halmac_8822b_card_enable_flow[];
+extern struct halmac_wl_pwr_cfg_ *halmac_8822b_suspend_flow[];
+extern struct halmac_wl_pwr_cfg_ *halmac_8822b_resume_flow[];
+extern struct halmac_wl_pwr_cfg_ *halmac_8822b_hwpdn_flow[];
+extern struct halmac_wl_pwr_cfg_ *halmac_8822b_enter_lps_flow[];
+extern struct halmac_wl_pwr_cfg_ *halmac_8822b_enter_deep_lps_flow[];
+extern struct halmac_wl_pwr_cfg_ *halmac_8822b_leave_lps_flow[];
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b.c b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b.c
new file mode 100644
index 000000000000..6b729fe4c096
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b.c
@@ -0,0 +1,343 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "halmac_8822b_cfg.h"
+#include "halmac_func_8822b.h"
+#include "../halmac_func_88xx.h"
+
+/**
+ * halmac_mount_api_8822b() - attach functions to function pointer
+ * @halmac_adapter
+ *
+ * SD1 internal use
+ *
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ */
+enum halmac_ret_status
+halmac_mount_api_8822b(struct halmac_adapter *halmac_adapter)
+{
+	struct halmac_api *halmac_api =
+		(struct halmac_api *)halmac_adapter->halmac_api;
+
+	halmac_adapter->chip_id = HALMAC_CHIP_ID_8822B;
+	halmac_adapter->hw_config_info.efuse_size = HALMAC_EFUSE_SIZE_8822B;
+	halmac_adapter->hw_config_info.eeprom_size = HALMAC_EEPROM_SIZE_8822B;
+	halmac_adapter->hw_config_info.bt_efuse_size =
+		HALMAC_BT_EFUSE_SIZE_8822B;
+	halmac_adapter->hw_config_info.cam_entry_num =
+		HALMAC_SECURITY_CAM_ENTRY_NUM_8822B;
+	halmac_adapter->hw_config_info.txdesc_size = HALMAC_TX_DESC_SIZE_8822B;
+	halmac_adapter->hw_config_info.rxdesc_size = HALMAC_RX_DESC_SIZE_8822B;
+	halmac_adapter->hw_config_info.tx_fifo_size = HALMAC_TX_FIFO_SIZE_8822B;
+	halmac_adapter->hw_config_info.rx_fifo_size = HALMAC_RX_FIFO_SIZE_8822B;
+	halmac_adapter->hw_config_info.page_size = HALMAC_TX_PAGE_SIZE_8822B;
+	halmac_adapter->hw_config_info.tx_align_size =
+		HALMAC_TX_ALIGN_SIZE_8822B;
+	halmac_adapter->hw_config_info.page_size_2_power =
+		HALMAC_TX_PAGE_SIZE_2_POWER_8822B;
+
+	halmac_adapter->txff_allocation.rsvd_drv_pg_num =
+		HALMAC_RSVD_DRV_PGNUM_8822B;
+
+	halmac_api->halmac_init_trx_cfg = halmac_init_trx_cfg_8822b;
+	halmac_api->halmac_init_protocol_cfg = halmac_init_protocol_cfg_8822b;
+	halmac_api->halmac_init_h2c = halmac_init_h2c_8822b;
+
+	if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_SDIO) {
+		halmac_api->halmac_tx_allowed_sdio =
+			halmac_tx_allowed_sdio_88xx;
+		halmac_api->halmac_cfg_tx_agg_align =
+			halmac_cfg_tx_agg_align_sdio_not_support_88xx;
+		halmac_api->halmac_mac_power_switch =
+			halmac_mac_power_switch_8822b_sdio;
+		halmac_api->halmac_phy_cfg = halmac_phy_cfg_8822b_sdio;
+		halmac_api->halmac_interface_integration_tuning =
+			halmac_interface_integration_tuning_8822b_sdio;
+	} else if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_USB) {
+		halmac_api->halmac_mac_power_switch =
+			halmac_mac_power_switch_8822b_usb;
+		halmac_api->halmac_cfg_tx_agg_align =
+			halmac_cfg_tx_agg_align_usb_not_support_88xx;
+		halmac_api->halmac_phy_cfg = halmac_phy_cfg_8822b_usb;
+		halmac_api->halmac_interface_integration_tuning =
+			halmac_interface_integration_tuning_8822b_usb;
+	} else if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_PCIE) {
+		halmac_api->halmac_mac_power_switch =
+			halmac_mac_power_switch_8822b_pcie;
+		halmac_api->halmac_cfg_tx_agg_align =
+			halmac_cfg_tx_agg_align_pcie_not_support_88xx;
+		halmac_api->halmac_pcie_switch = halmac_pcie_switch_8822b;
+		halmac_api->halmac_phy_cfg = halmac_phy_cfg_8822b_pcie;
+		halmac_api->halmac_interface_integration_tuning =
+			halmac_interface_integration_tuning_8822b_pcie;
+	} else {
+		halmac_api->halmac_pcie_switch = halmac_pcie_switch_8822b_nc;
+	}
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_init_trx_cfg_8822b() - config trx dma register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_trx_mode : trx mode selection
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_init_trx_cfg_8822b(struct halmac_adapter *halmac_adapter,
+			  enum halmac_trx_mode halmac_trx_mode)
+{
+	u8 value8;
+	u32 value32;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_INIT_TRX_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+	halmac_adapter->trx_mode = halmac_trx_mode;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"halmac_init_trx_cfg ==========>halmac_trx_mode = %d\n",
+			halmac_trx_mode);
+
+	status = halmac_txdma_queue_mapping_8822b(halmac_adapter,
+						  halmac_trx_mode);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"halmac_txdma_queue_mapping fail!\n");
+		return status;
+	}
+
+	value8 = 0;
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_CR, value8);
+	value8 = HALMAC_CR_TRX_ENABLE_8822B;
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_CR, value8);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_H2CQ_CSR, BIT(31));
+
+	status = halmac_priority_queue_config_8822b(halmac_adapter,
+						    halmac_trx_mode);
+	if (halmac_adapter->txff_allocation.rx_fifo_expanding_mode !=
+	    HALMAC_RX_FIFO_EXPANDING_MODE_DISABLE)
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_RX_DRVINFO_SZ, 0xF);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"halmac_txdma_queue_mapping fail!\n");
+		return status;
+	}
+
+	/* Config H2C packet buffer */
+	value32 = HALMAC_REG_READ_32(halmac_adapter, REG_H2C_HEAD);
+	value32 = (value32 & 0xFFFC0000) |
+		  (halmac_adapter->txff_allocation.rsvd_h2c_queue_pg_bndy
+		   << HALMAC_TX_PAGE_SIZE_2_POWER_8822B);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_H2C_HEAD, value32);
+
+	value32 = HALMAC_REG_READ_32(halmac_adapter, REG_H2C_READ_ADDR);
+	value32 = (value32 & 0xFFFC0000) |
+		  (halmac_adapter->txff_allocation.rsvd_h2c_queue_pg_bndy
+		   << HALMAC_TX_PAGE_SIZE_2_POWER_8822B);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_H2C_READ_ADDR, value32);
+
+	value32 = HALMAC_REG_READ_32(halmac_adapter, REG_H2C_TAIL);
+	value32 = (value32 & 0xFFFC0000) |
+		  ((halmac_adapter->txff_allocation.rsvd_h2c_queue_pg_bndy
+		    << HALMAC_TX_PAGE_SIZE_2_POWER_8822B) +
+		   (HALMAC_RSVD_H2C_QUEUE_PGNUM_8822B
+		    << HALMAC_TX_PAGE_SIZE_2_POWER_8822B));
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_H2C_TAIL, value32);
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_H2C_INFO);
+	value8 = (u8)((value8 & 0xFC) | 0x01);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_H2C_INFO, value8);
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_H2C_INFO);
+	value8 = (u8)((value8 & 0xFB) | 0x04);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_H2C_INFO, value8);
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_TXDMA_OFFSET_CHK + 1);
+	value8 = (u8)((value8 & 0x7f) | 0x80);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_TXDMA_OFFSET_CHK + 1, value8);
+
+	halmac_adapter->h2c_buff_size = HALMAC_RSVD_H2C_QUEUE_PGNUM_8822B
+					<< HALMAC_TX_PAGE_SIZE_2_POWER_8822B;
+	halmac_get_h2c_buff_free_space_88xx(halmac_adapter);
+
+	if (halmac_adapter->h2c_buff_size !=
+	    halmac_adapter->h2c_buf_free_space) {
+		pr_err("get h2c free space error!\n");
+		return HALMAC_RET_GET_H2C_SPACE_ERR;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"halmac_init_trx_cfg <==========\n");
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_init_protocol_cfg_8822b() - config protocol register
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_init_protocol_cfg_8822b(struct halmac_adapter *halmac_adapter)
+{
+	u32 value32;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_INIT_PROTOCOL_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"[TRACE]%s ==========>\n", __func__);
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_AMPDU_MAX_TIME_V1,
+			   HALMAC_AMPDU_MAX_TIME_8822B);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_TX_HANG_CTRL, BIT_EN_EOF_V1);
+
+	value32 = HALMAC_PROT_RTS_LEN_TH_8822B |
+		  (HALMAC_PROT_RTS_TX_TIME_TH_8822B << 8) |
+		  (HALMAC_PROT_MAX_AGG_PKT_LIMIT_8822B << 16) |
+		  (HALMAC_PROT_RTS_MAX_AGG_PKT_LIMIT_8822B << 24);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_PROT_MODE_CTRL, value32);
+
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_BAR_MODE_CTRL + 2,
+			    HALMAC_BAR_RETRY_LIMIT_8822B |
+				    HALMAC_RA_TRY_RATE_AGG_LIMIT_8822B << 8);
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_FAST_EDCA_VOVI_SETTING,
+			   HALMAC_FAST_EDCA_VO_TH_8822B);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_FAST_EDCA_VOVI_SETTING + 2,
+			   HALMAC_FAST_EDCA_VI_TH_8822B);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_FAST_EDCA_BEBK_SETTING,
+			   HALMAC_FAST_EDCA_BE_TH_8822B);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_FAST_EDCA_BEBK_SETTING + 2,
+			   HALMAC_FAST_EDCA_BK_TH_8822B);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"[TRACE]%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_init_h2c_8822b() - config h2c packet buffer
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_init_h2c_8822b(struct halmac_adapter *halmac_adapter)
+{
+	u8 value8;
+	u32 value32;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	value8 = 0;
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_CR, value8);
+	value8 = HALMAC_CR_TRX_ENABLE_8822B;
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_CR, value8);
+
+	value32 = HALMAC_REG_READ_32(halmac_adapter, REG_H2C_HEAD);
+	value32 = (value32 & 0xFFFC0000) |
+		  (halmac_adapter->txff_allocation.rsvd_h2c_queue_pg_bndy
+		   << HALMAC_TX_PAGE_SIZE_2_POWER_8822B);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_H2C_HEAD, value32);
+
+	value32 = HALMAC_REG_READ_32(halmac_adapter, REG_H2C_READ_ADDR);
+	value32 = (value32 & 0xFFFC0000) |
+		  (halmac_adapter->txff_allocation.rsvd_h2c_queue_pg_bndy
+		   << HALMAC_TX_PAGE_SIZE_2_POWER_8822B);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_H2C_READ_ADDR, value32);
+
+	value32 = HALMAC_REG_READ_32(halmac_adapter, REG_H2C_TAIL);
+	value32 = (value32 & 0xFFFC0000) |
+		  ((halmac_adapter->txff_allocation.rsvd_h2c_queue_pg_bndy
+		    << HALMAC_TX_PAGE_SIZE_2_POWER_8822B) +
+		   (HALMAC_RSVD_H2C_QUEUE_PGNUM_8822B
+		    << HALMAC_TX_PAGE_SIZE_2_POWER_8822B));
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_H2C_TAIL, value32);
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_H2C_INFO);
+	value8 = (u8)((value8 & 0xFC) | 0x01);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_H2C_INFO, value8);
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_H2C_INFO);
+	value8 = (u8)((value8 & 0xFB) | 0x04);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_H2C_INFO, value8);
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_TXDMA_OFFSET_CHK + 1);
+	value8 = (u8)((value8 & 0x7f) | 0x80);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_TXDMA_OFFSET_CHK + 1, value8);
+
+	halmac_adapter->h2c_buff_size = HALMAC_RSVD_H2C_QUEUE_PGNUM_8822B
+					<< HALMAC_TX_PAGE_SIZE_2_POWER_8822B;
+	halmac_get_h2c_buff_free_space_88xx(halmac_adapter);
+
+	if (halmac_adapter->h2c_buff_size !=
+	    halmac_adapter->h2c_buf_free_space) {
+		pr_err("get h2c free space error!\n");
+		return HALMAC_RET_GET_H2C_SPACE_ERR;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"h2c free space : %d\n",
+			halmac_adapter->h2c_buf_free_space);
+
+	return HALMAC_RET_SUCCESS;
+}
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b.h b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b.h
new file mode 100644
index 000000000000..cf21e3d25607
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b.h
@@ -0,0 +1,44 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_API_8822B_H_
+#define _HALMAC_API_8822B_H_
+
+#include "../../halmac_2_platform.h"
+#include "../../halmac_type.h"
+
+enum halmac_ret_status
+halmac_mount_api_8822b(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_init_trx_cfg_8822b(struct halmac_adapter *halmac_adapter,
+			  enum halmac_trx_mode halmac_trx_mode);
+
+enum halmac_ret_status
+halmac_init_protocol_cfg_8822b(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_init_h2c_8822b(struct halmac_adapter *halmac_adapter);
+
+#endif /* _HALMAC_API_8822B_H_ */
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_pcie.c b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_pcie.c
new file mode 100644
index 000000000000..e25e2b0ebb4c
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_pcie.c
@@ -0,0 +1,323 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "../halmac_88xx_cfg.h"
+#include "../halmac_api_88xx_pcie.h"
+#include "halmac_8822b_cfg.h"
+
+/**
+ * halmac_mac_power_switch_8822b_pcie() - switch mac power
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_power : power state
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_mac_power_switch_8822b_pcie(struct halmac_adapter *halmac_adapter,
+				   enum halmac_mac_power halmac_power)
+{
+	u8 interface_mask;
+	u8 value8;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_MAC_POWER_SWITCH);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+		"halmac_mac_power_switch_88xx_pcie halmac_power =  %x ==========>\n",
+		halmac_power);
+	interface_mask = HALMAC_PWR_INTF_PCI_MSK;
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_CR);
+	if (value8 == 0xEA)
+		halmac_adapter->halmac_state.mac_power = HALMAC_MAC_POWER_OFF;
+	else
+		halmac_adapter->halmac_state.mac_power = HALMAC_MAC_POWER_ON;
+
+	/* Check if power switch is needed */
+	if (halmac_power == HALMAC_MAC_POWER_ON &&
+	    halmac_adapter->halmac_state.mac_power == HALMAC_MAC_POWER_ON) {
+		HALMAC_RT_TRACE(
+			driver_adapter, HALMAC_MSG_PWR, DBG_WARNING,
+			"halmac_mac_power_switch power state unchange!\n");
+		return HALMAC_RET_PWR_UNCHANGE;
+	}
+
+	if (halmac_power == HALMAC_MAC_POWER_OFF) {
+		if (halmac_pwr_seq_parser_88xx(
+			    halmac_adapter, HALMAC_PWR_CUT_ALL_MSK,
+			    HALMAC_PWR_FAB_TSMC_MSK, interface_mask,
+			    halmac_8822b_card_disable_flow) !=
+		    HALMAC_RET_SUCCESS) {
+			pr_err("Handle power off cmd error\n");
+			return HALMAC_RET_POWER_OFF_FAIL;
+		}
+
+		halmac_adapter->halmac_state.mac_power = HALMAC_MAC_POWER_OFF;
+		halmac_adapter->halmac_state.ps_state =
+			HALMAC_PS_STATE_UNDEFINE;
+		halmac_adapter->halmac_state.dlfw_state = HALMAC_DLFW_NONE;
+		halmac_init_adapter_dynamic_para_88xx(halmac_adapter);
+	} else {
+		if (halmac_pwr_seq_parser_88xx(
+			    halmac_adapter, HALMAC_PWR_CUT_ALL_MSK,
+			    HALMAC_PWR_FAB_TSMC_MSK, interface_mask,
+			    halmac_8822b_card_enable_flow) !=
+		    HALMAC_RET_SUCCESS) {
+			pr_err("Handle power on cmd error\n");
+			return HALMAC_RET_POWER_ON_FAIL;
+		}
+
+		halmac_adapter->halmac_state.mac_power = HALMAC_MAC_POWER_ON;
+		halmac_adapter->halmac_state.ps_state = HALMAC_PS_STATE_ACT;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"halmac_mac_power_switch_88xx_pcie <==========\n");
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_pcie_switch_8822b() - pcie gen1/gen2 switch
+ * @halmac_adapter : the adapter of halmac
+ * @pcie_cfg : gen1/gen2 selection
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_pcie_switch_8822b(struct halmac_adapter *halmac_adapter,
+			 enum halmac_pcie_cfg pcie_cfg)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	u8 current_link_speed = 0;
+	u32 count = 0;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_PCIE_SWITCH);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	/* Link Control 2 Register[3:0] Target Link Speed
+	 * Defined encodings are:
+	 * 0001b Target Link 2.5 GT/s
+	 * 0010b Target Link 5.0 GT/s
+	 * 0100b Target Link 8.0 GT/s
+	 */
+
+	if (pcie_cfg == HALMAC_PCIE_GEN1) {
+		/* cfg 0xA0[3:0]=4'b0001 */
+		halmac_dbi_write8_88xx(
+			halmac_adapter, LINK_CTRL2_REG_OFFSET,
+			(halmac_dbi_read8_88xx(halmac_adapter,
+					       LINK_CTRL2_REG_OFFSET) &
+			 0xF0) | BIT(0));
+
+		/* cfg 0x80C[17]=1 //PCIe DesignWave */
+		halmac_dbi_write32_88xx(
+			halmac_adapter, GEN2_CTRL_OFFSET,
+			halmac_dbi_read32_88xx(halmac_adapter,
+					       GEN2_CTRL_OFFSET) |
+				BIT(17));
+
+		/* check link speed if GEN1 */
+		/* cfg 0x82[3:0]=4'b0001 */
+		current_link_speed =
+			halmac_dbi_read8_88xx(halmac_adapter,
+					      LINK_STATUS_REG_OFFSET) &
+			0x0F;
+		count = 2000;
+
+		while (current_link_speed != GEN1_SPEED && count != 0) {
+			usleep_range(50, 60);
+			current_link_speed =
+				halmac_dbi_read8_88xx(halmac_adapter,
+						      LINK_STATUS_REG_OFFSET) &
+				0x0F;
+			count--;
+		}
+
+		if (current_link_speed != GEN1_SPEED) {
+			pr_err("Speed change to GEN1 fail !\n");
+			return HALMAC_RET_FAIL;
+		}
+
+	} else if (pcie_cfg == HALMAC_PCIE_GEN2) {
+		/* cfg 0xA0[3:0]=4'b0010 */
+		halmac_dbi_write8_88xx(
+			halmac_adapter, LINK_CTRL2_REG_OFFSET,
+			(halmac_dbi_read8_88xx(halmac_adapter,
+					       LINK_CTRL2_REG_OFFSET) &
+			 0xF0) | BIT(1));
+
+		/* cfg 0x80C[17]=1 //PCIe DesignWave */
+		halmac_dbi_write32_88xx(
+			halmac_adapter, GEN2_CTRL_OFFSET,
+			halmac_dbi_read32_88xx(halmac_adapter,
+					       GEN2_CTRL_OFFSET) |
+				BIT(17));
+
+		/* check link speed if GEN2 */
+		/* cfg 0x82[3:0]=4'b0010 */
+		current_link_speed =
+			halmac_dbi_read8_88xx(halmac_adapter,
+					      LINK_STATUS_REG_OFFSET) &
+			0x0F;
+		count = 2000;
+
+		while (current_link_speed != GEN2_SPEED && count != 0) {
+			usleep_range(50, 60);
+			current_link_speed =
+				halmac_dbi_read8_88xx(halmac_adapter,
+						      LINK_STATUS_REG_OFFSET) &
+				0x0F;
+			count--;
+		}
+
+		if (current_link_speed != GEN2_SPEED) {
+			pr_err("Speed change to GEN1 fail !\n");
+			return HALMAC_RET_FAIL;
+		}
+
+	} else {
+		pr_err("Error Speed !\n");
+		return HALMAC_RET_FAIL;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_pcie_switch_8822b_nc(struct halmac_adapter *halmac_adapter,
+			    enum halmac_pcie_cfg pcie_cfg)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_PCIE_SWITCH);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_phy_cfg_8822b_pcie() - phy config
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_phy_cfg_8822b_pcie(struct halmac_adapter *halmac_adapter,
+			  enum halmac_intf_phy_platform platform)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_PHY_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"halmac_phy_cfg ==========>\n");
+
+	status = halmac_parse_intf_phy_88xx(halmac_adapter,
+					    HALMAC_RTL8822B_PCIE_PHY_GEN1,
+					    platform, HAL_INTF_PHY_PCIE_GEN1);
+
+	if (status != HALMAC_RET_SUCCESS)
+		return status;
+
+	status = halmac_parse_intf_phy_88xx(halmac_adapter,
+					    HALMAC_RTL8822B_PCIE_PHY_GEN2,
+					    platform, HAL_INTF_PHY_PCIE_GEN2);
+
+	if (status != HALMAC_RET_SUCCESS)
+		return status;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"halmac_phy_cfg <==========\n");
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_interface_integration_tuning_8822b_pcie() - pcie interface fine tuning
+ * @halmac_adapter : the adapter of halmac
+ * Author : Rick Liu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status halmac_interface_integration_tuning_8822b_pcie(
+	struct halmac_adapter *halmac_adapter)
+{
+	return HALMAC_RET_SUCCESS;
+}
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_pcie.h b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_pcie.h
new file mode 100644
index 000000000000..c68ea0039703
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_pcie.h
@@ -0,0 +1,53 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_API_8822B_PCIE_H_
+#define _HALMAC_API_8822B_PCIE_H_
+
+#include "../../halmac_2_platform.h"
+#include "../../halmac_type.h"
+
+extern struct halmac_intf_phy_para_ HALMAC_RTL8822B_PCIE_PHY_GEN1[];
+extern struct halmac_intf_phy_para_ HALMAC_RTL8822B_PCIE_PHY_GEN2[];
+
+enum halmac_ret_status
+halmac_mac_power_switch_8822b_pcie(struct halmac_adapter *halmac_adapter,
+				   enum halmac_mac_power halmac_power);
+
+enum halmac_ret_status
+halmac_pcie_switch_8822b(struct halmac_adapter *halmac_adapter,
+			 enum halmac_pcie_cfg pcie_cfg);
+
+enum halmac_ret_status
+halmac_pcie_switch_8822b_nc(struct halmac_adapter *halmac_adapter,
+			    enum halmac_pcie_cfg pcie_cfg);
+
+enum halmac_ret_status
+halmac_phy_cfg_8822b_pcie(struct halmac_adapter *halmac_adapter,
+			  enum halmac_intf_phy_platform platform);
+
+enum halmac_ret_status halmac_interface_integration_tuning_8822b_pcie(
+	struct halmac_adapter *halmac_adapter);
+
+#endif /* _HALMAC_API_8822B_PCIE_H_ */
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_sdio.c b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_sdio.c
new file mode 100644
index 000000000000..4d708d841bad
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_sdio.c
@@ -0,0 +1,184 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "halmac_8822b_cfg.h"
+
+/**
+ * halmac_mac_power_switch_8822b_sdio() - switch mac power
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_power : power state
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_mac_power_switch_8822b_sdio(struct halmac_adapter *halmac_adapter,
+				   enum halmac_mac_power halmac_power)
+{
+	u8 interface_mask;
+	u8 value8;
+	u8 rpwm;
+	u32 imr_backup;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+		"[TRACE]halmac_mac_power_switch_88xx_sdio==========>\n");
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"[TRACE]halmac_power = %x ==========>\n", halmac_power);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"[TRACE]8822B pwr seq ver = %s\n",
+			HALMAC_8822B_PWR_SEQ_VER);
+
+	interface_mask = HALMAC_PWR_INTF_SDIO_MSK;
+
+	halmac_adapter->rpwm_record =
+		HALMAC_REG_READ_8(halmac_adapter, REG_SDIO_HRPWM1);
+
+	/* Check FW still exist or not */
+	if (HALMAC_REG_READ_16(halmac_adapter, REG_MCUFW_CTRL) == 0xC078) {
+		/* Leave 32K */
+		rpwm = (u8)((halmac_adapter->rpwm_record ^ BIT(7)) & 0x80);
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_SDIO_HRPWM1, rpwm);
+	}
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_CR);
+	if (value8 == 0xEA)
+		halmac_adapter->halmac_state.mac_power = HALMAC_MAC_POWER_OFF;
+	else
+		halmac_adapter->halmac_state.mac_power = HALMAC_MAC_POWER_ON;
+
+	/*Check if power switch is needed*/
+	if (halmac_power == HALMAC_MAC_POWER_ON &&
+	    halmac_adapter->halmac_state.mac_power == HALMAC_MAC_POWER_ON) {
+		HALMAC_RT_TRACE(
+			driver_adapter, HALMAC_MSG_PWR, DBG_WARNING,
+			"[WARN]halmac_mac_power_switch power state unchange!\n");
+		return HALMAC_RET_PWR_UNCHANGE;
+	}
+
+	imr_backup = HALMAC_REG_READ_32(halmac_adapter, REG_SDIO_HIMR);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_SDIO_HIMR, 0);
+
+	if (halmac_power == HALMAC_MAC_POWER_OFF) {
+		if (halmac_pwr_seq_parser_88xx(
+			    halmac_adapter, HALMAC_PWR_CUT_ALL_MSK,
+			    HALMAC_PWR_FAB_TSMC_MSK, interface_mask,
+			    halmac_8822b_card_disable_flow) !=
+		    HALMAC_RET_SUCCESS) {
+			pr_err("[ERR]Handle power off cmd error\n");
+			HALMAC_REG_WRITE_32(halmac_adapter, REG_SDIO_HIMR,
+					    imr_backup);
+			return HALMAC_RET_POWER_OFF_FAIL;
+		}
+
+		halmac_adapter->halmac_state.mac_power = HALMAC_MAC_POWER_OFF;
+		halmac_adapter->halmac_state.ps_state =
+			HALMAC_PS_STATE_UNDEFINE;
+		halmac_adapter->halmac_state.dlfw_state = HALMAC_DLFW_NONE;
+		halmac_init_adapter_dynamic_para_88xx(halmac_adapter);
+	} else {
+		if (halmac_pwr_seq_parser_88xx(
+			    halmac_adapter, HALMAC_PWR_CUT_ALL_MSK,
+			    HALMAC_PWR_FAB_TSMC_MSK, interface_mask,
+			    halmac_8822b_card_enable_flow) !=
+		    HALMAC_RET_SUCCESS) {
+			pr_err("[ERR]Handle power on cmd error\n");
+			HALMAC_REG_WRITE_32(halmac_adapter, REG_SDIO_HIMR,
+					    imr_backup);
+			return HALMAC_RET_POWER_ON_FAIL;
+		}
+
+		halmac_adapter->halmac_state.mac_power = HALMAC_MAC_POWER_ON;
+		halmac_adapter->halmac_state.ps_state = HALMAC_PS_STATE_ACT;
+	}
+
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_SDIO_HIMR, imr_backup);
+
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+		"[TRACE]halmac_mac_power_switch_88xx_sdio <==========\n");
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_phy_cfg_8822b_sdio() - phy config
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_phy_cfg_8822b_sdio(struct halmac_adapter *halmac_adapter,
+			  enum halmac_intf_phy_platform platform)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_PHY_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"halmac_phy_cfg ==========>\n");
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"sdio no phy\n");
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"halmac_phy_cfg <==========\n");
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_interface_integration_tuning_8822b_sdio() - sdio interface fine tuning
+ * @halmac_adapter : the adapter of halmac
+ * Author : Ivan
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status halmac_interface_integration_tuning_8822b_sdio(
+	struct halmac_adapter *halmac_adapter)
+{
+	return HALMAC_RET_SUCCESS;
+}
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_sdio.h b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_sdio.h
new file mode 100644
index 000000000000..07ffb3baf7c0
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_sdio.h
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_API_8822B_SDIO_H_
+#define _HALMAC_API_8822B_SDIO_H_
+
+#include "../../halmac_2_platform.h"
+#include "../../halmac_type.h"
+
+enum halmac_ret_status
+halmac_mac_power_switch_8822b_sdio(struct halmac_adapter *halmac_adapter,
+				   enum halmac_mac_power halmac_power);
+
+enum halmac_ret_status
+halmac_phy_cfg_8822b_sdio(struct halmac_adapter *halmac_adapter,
+			  enum halmac_intf_phy_platform platform);
+
+enum halmac_ret_status halmac_interface_integration_tuning_8822b_sdio(
+	struct halmac_adapter *halmac_adapter);
+
+#endif /* _HALMAC_API_8822B_SDIO_H_ */
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_usb.c b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_usb.c
new file mode 100644
index 000000000000..5f27eb172430
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_usb.c
@@ -0,0 +1,185 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "../halmac_88xx_cfg.h"
+#include "halmac_8822b_cfg.h"
+
+/**
+ * halmac_mac_power_switch_8822b_usb() - switch mac power
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_power : power state
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_mac_power_switch_8822b_usb(struct halmac_adapter *halmac_adapter,
+				  enum halmac_mac_power halmac_power)
+{
+	u8 interface_mask;
+	u8 value8;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_MAC_POWER_SWITCH);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+		"halmac_mac_power_switch_88xx_usb halmac_power = %x ==========>\n",
+		halmac_power);
+
+	interface_mask = HALMAC_PWR_INTF_USB_MSK;
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_CR);
+	if (value8 == 0xEA) {
+		halmac_adapter->halmac_state.mac_power = HALMAC_MAC_POWER_OFF;
+	} else {
+		if (BIT(0) ==
+		    (HALMAC_REG_READ_8(halmac_adapter, REG_SYS_STATUS1 + 1) &
+		     BIT(0)))
+			halmac_adapter->halmac_state.mac_power =
+				HALMAC_MAC_POWER_OFF;
+		else
+			halmac_adapter->halmac_state.mac_power =
+				HALMAC_MAC_POWER_ON;
+	}
+
+	/*Check if power switch is needed*/
+	if (halmac_power == HALMAC_MAC_POWER_ON &&
+	    halmac_adapter->halmac_state.mac_power == HALMAC_MAC_POWER_ON) {
+		HALMAC_RT_TRACE(
+			driver_adapter, HALMAC_MSG_PWR, DBG_WARNING,
+			"halmac_mac_power_switch power state unchange!\n");
+		return HALMAC_RET_PWR_UNCHANGE;
+	}
+	if (halmac_power == HALMAC_MAC_POWER_OFF) {
+		if (halmac_pwr_seq_parser_88xx(
+			    halmac_adapter, HALMAC_PWR_CUT_ALL_MSK,
+			    HALMAC_PWR_FAB_TSMC_MSK, interface_mask,
+			    halmac_8822b_card_disable_flow) !=
+		    HALMAC_RET_SUCCESS) {
+			pr_err("Handle power off cmd error\n");
+			return HALMAC_RET_POWER_OFF_FAIL;
+		}
+
+		halmac_adapter->halmac_state.mac_power = HALMAC_MAC_POWER_OFF;
+		halmac_adapter->halmac_state.ps_state =
+			HALMAC_PS_STATE_UNDEFINE;
+		halmac_adapter->halmac_state.dlfw_state = HALMAC_DLFW_NONE;
+		halmac_init_adapter_dynamic_para_88xx(halmac_adapter);
+	} else {
+		if (halmac_pwr_seq_parser_88xx(
+			    halmac_adapter, HALMAC_PWR_CUT_ALL_MSK,
+			    HALMAC_PWR_FAB_TSMC_MSK, interface_mask,
+			    halmac_8822b_card_enable_flow) !=
+		    HALMAC_RET_SUCCESS) {
+			pr_err("Handle power on cmd error\n");
+			return HALMAC_RET_POWER_ON_FAIL;
+		}
+
+		HALMAC_REG_WRITE_8(
+			halmac_adapter, REG_SYS_STATUS1 + 1,
+			HALMAC_REG_READ_8(halmac_adapter, REG_SYS_STATUS1 + 1) &
+				~(BIT(0)));
+
+		halmac_adapter->halmac_state.mac_power = HALMAC_MAC_POWER_ON;
+		halmac_adapter->halmac_state.ps_state = HALMAC_PS_STATE_ACT;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"halmac_mac_power_switch_88xx_usb <==========\n");
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_phy_cfg_8822b_usb() - phy config
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_phy_cfg_8822b_usb(struct halmac_adapter *halmac_adapter,
+			 enum halmac_intf_phy_platform platform)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_PHY_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"halmac_phy_cfg ==========>\n");
+
+	status = halmac_parse_intf_phy_88xx(halmac_adapter,
+					    HALMAC_RTL8822B_USB2_PHY, platform,
+					    HAL_INTF_PHY_USB2);
+
+	if (status != HALMAC_RET_SUCCESS)
+		return status;
+
+	status = halmac_parse_intf_phy_88xx(halmac_adapter,
+					    HALMAC_RTL8822B_USB3_PHY, platform,
+					    HAL_INTF_PHY_USB3);
+
+	if (status != HALMAC_RET_SUCCESS)
+		return status;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"halmac_phy_cfg <==========\n");
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_interface_integration_tuning_8822b_usb() - usb interface fine tuning
+ * @halmac_adapter : the adapter of halmac
+ * Author : Ivan
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status halmac_interface_integration_tuning_8822b_usb(
+	struct halmac_adapter *halmac_adapter)
+{
+	return HALMAC_RET_SUCCESS;
+}
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_usb.h b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_usb.h
new file mode 100644
index 000000000000..3a99fd5675e0
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_api_8822b_usb.h
@@ -0,0 +1,45 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_API_8822B_USB_H_
+#define _HALMAC_API_8822B_USB_H_
+
+extern struct halmac_intf_phy_para_ HALMAC_RTL8822B_USB2_PHY[];
+extern struct halmac_intf_phy_para_ HALMAC_RTL8822B_USB3_PHY[];
+
+#include "../../halmac_2_platform.h"
+#include "../../halmac_type.h"
+
+enum halmac_ret_status
+halmac_mac_power_switch_8822b_usb(struct halmac_adapter *halmac_adapter,
+				  enum halmac_mac_power halmac_power);
+
+enum halmac_ret_status
+halmac_phy_cfg_8822b_usb(struct halmac_adapter *halmac_adapter,
+			 enum halmac_intf_phy_platform platform);
+
+enum halmac_ret_status halmac_interface_integration_tuning_8822b_usb(
+	struct halmac_adapter *halmac_adapter);
+
+#endif /* _HALMAC_API_8822B_USB_H_ */
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_func_8822b.c b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_func_8822b.c
new file mode 100644
index 000000000000..5f1dff8d9e3b
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_func_8822b.c
@@ -0,0 +1,414 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "halmac_8822b_cfg.h"
+#include "halmac_func_8822b.h"
+
+/*SDIO RQPN Mapping*/
+static struct halmac_rqpn_ HALMAC_RQPN_SDIO_8822B[] = {
+	/* { mode, vo_map, vi_map, be_map, bk_map, mg_map, hi_map } */
+	{HALMAC_TRX_MODE_NORMAL, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ, HALMAC_MAP2_LQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_TRXSHARE, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_LQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_WMM, HALMAC_MAP2_HQ, HALMAC_MAP2_NQ, HALMAC_MAP2_LQ,
+	 HALMAC_MAP2_NQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_P2P, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ, HALMAC_MAP2_LQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_LOOPBACK, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_LQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_DELAY_LOOPBACK, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_LQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+};
+
+/*PCIE RQPN Mapping*/
+static struct halmac_rqpn_ HALMAC_RQPN_PCIE_8822B[] = {
+	/* { mode, vo_map, vi_map, be_map, bk_map, mg_map, hi_map } */
+	{HALMAC_TRX_MODE_NORMAL, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ, HALMAC_MAP2_LQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_TRXSHARE, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_LQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_WMM, HALMAC_MAP2_HQ, HALMAC_MAP2_NQ, HALMAC_MAP2_LQ,
+	 HALMAC_MAP2_NQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_P2P, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ, HALMAC_MAP2_LQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_LOOPBACK, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_LQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_DELAY_LOOPBACK, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_LQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+};
+
+/*USB 2 Bulkout RQPN Mapping*/
+static struct halmac_rqpn_ HALMAC_RQPN_2BULKOUT_8822B[] = {
+	/* { mode, vo_map, vi_map, be_map, bk_map, mg_map, hi_map } */
+	{HALMAC_TRX_MODE_NORMAL, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ,
+	 HALMAC_MAP2_HQ, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_TRXSHARE, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ,
+	 HALMAC_MAP2_NQ, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_WMM, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ,
+	 HALMAC_MAP2_HQ, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_P2P, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ,
+	 HALMAC_MAP2_NQ, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_LOOPBACK, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ,
+	 HALMAC_MAP2_HQ, HALMAC_MAP2_NQ, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_DELAY_LOOPBACK, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ,
+	 HALMAC_MAP2_HQ, HALMAC_MAP2_NQ, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ},
+};
+
+/*USB 3 Bulkout RQPN Mapping*/
+static struct halmac_rqpn_ HALMAC_RQPN_3BULKOUT_8822B[] = {
+	/* { mode, vo_map, vi_map, be_map, bk_map, mg_map, hi_map } */
+	{HALMAC_TRX_MODE_NORMAL, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ, HALMAC_MAP2_LQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_TRXSHARE, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_LQ, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_WMM, HALMAC_MAP2_HQ, HALMAC_MAP2_NQ, HALMAC_MAP2_LQ,
+	 HALMAC_MAP2_NQ, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_P2P, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ, HALMAC_MAP2_LQ,
+	 HALMAC_MAP2_NQ, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_LOOPBACK, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_NQ, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_DELAY_LOOPBACK, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_NQ, HALMAC_MAP2_HQ, HALMAC_MAP2_HQ},
+};
+
+/*USB 4 Bulkout RQPN Mapping*/
+static struct halmac_rqpn_ HALMAC_RQPN_4BULKOUT_8822B[] = {
+	/* { mode, vo_map, vi_map, be_map, bk_map, mg_map, hi_map } */
+	{HALMAC_TRX_MODE_NORMAL, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ, HALMAC_MAP2_LQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_TRXSHARE, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_LQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_WMM, HALMAC_MAP2_HQ, HALMAC_MAP2_NQ, HALMAC_MAP2_LQ,
+	 HALMAC_MAP2_NQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_P2P, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ, HALMAC_MAP2_LQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_LOOPBACK, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_LQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+	{HALMAC_TRX_MODE_DELAY_LOOPBACK, HALMAC_MAP2_NQ, HALMAC_MAP2_NQ,
+	 HALMAC_MAP2_LQ, HALMAC_MAP2_LQ, HALMAC_MAP2_EXQ, HALMAC_MAP2_HQ},
+};
+
+/*SDIO Page Number*/
+static struct halmac_pg_num_ HALMAC_PG_NUM_SDIO_8822B[] = {
+	/* { mode, hq_num, nq_num, lq_num, exq_num, gap_num} */
+	{HALMAC_TRX_MODE_NORMAL, 64, 64, 64, 64, 1},
+	{HALMAC_TRX_MODE_TRXSHARE, 32, 32, 32, 32, 1},
+	{HALMAC_TRX_MODE_WMM, 64, 64, 64, 64, 1},
+	{HALMAC_TRX_MODE_P2P, 64, 64, 64, 64, 1},
+	{HALMAC_TRX_MODE_LOOPBACK, 64, 64, 64, 64, 640},
+	{HALMAC_TRX_MODE_DELAY_LOOPBACK, 64, 64, 64, 64, 640},
+};
+
+/*PCIE Page Number*/
+static struct halmac_pg_num_ HALMAC_PG_NUM_PCIE_8822B[] = {
+	/* { mode, hq_num, nq_num, lq_num, exq_num, gap_num} */
+	{HALMAC_TRX_MODE_NORMAL, 64, 64, 64, 64, 1},
+	{HALMAC_TRX_MODE_TRXSHARE, 64, 64, 64, 64, 1},
+	{HALMAC_TRX_MODE_WMM, 64, 64, 64, 64, 1},
+	{HALMAC_TRX_MODE_P2P, 64, 64, 64, 64, 1},
+	{HALMAC_TRX_MODE_LOOPBACK, 64, 64, 64, 64, 640},
+	{HALMAC_TRX_MODE_DELAY_LOOPBACK, 64, 64, 64, 64, 640},
+};
+
+/*USB 2 Bulkout Page Number*/
+static struct halmac_pg_num_ HALMAC_PG_NUM_2BULKOUT_8822B[] = {
+	/* { mode, hq_num, nq_num, lq_num, exq_num, gap_num} */
+	{HALMAC_TRX_MODE_NORMAL, 64, 64, 0, 0, 1},
+	{HALMAC_TRX_MODE_TRXSHARE, 64, 64, 0, 0, 1},
+	{HALMAC_TRX_MODE_WMM, 64, 64, 0, 0, 1},
+	{HALMAC_TRX_MODE_P2P, 64, 64, 0, 0, 1},
+	{HALMAC_TRX_MODE_LOOPBACK, 64, 64, 0, 0, 1024},
+	{HALMAC_TRX_MODE_DELAY_LOOPBACK, 64, 64, 0, 0, 1024},
+};
+
+/*USB 3 Bulkout Page Number*/
+static struct halmac_pg_num_ HALMAC_PG_NUM_3BULKOUT_8822B[] = {
+	/* { mode, hq_num, nq_num, lq_num, exq_num, gap_num} */
+	{HALMAC_TRX_MODE_NORMAL, 64, 64, 64, 0, 1},
+	{HALMAC_TRX_MODE_TRXSHARE, 64, 64, 64, 0, 1},
+	{HALMAC_TRX_MODE_WMM, 64, 64, 64, 0, 1},
+	{HALMAC_TRX_MODE_P2P, 64, 64, 64, 0, 1},
+	{HALMAC_TRX_MODE_LOOPBACK, 64, 64, 64, 0, 1024},
+	{HALMAC_TRX_MODE_DELAY_LOOPBACK, 64, 64, 64, 0, 1024},
+};
+
+/*USB 4 Bulkout Page Number*/
+static struct halmac_pg_num_ HALMAC_PG_NUM_4BULKOUT_8822B[] = {
+	/* { mode, hq_num, nq_num, lq_num, exq_num, gap_num} */
+	{HALMAC_TRX_MODE_NORMAL, 64, 64, 64, 64, 1},
+	{HALMAC_TRX_MODE_TRXSHARE, 64, 64, 64, 64, 1},
+	{HALMAC_TRX_MODE_WMM, 64, 64, 64, 64, 1},
+	{HALMAC_TRX_MODE_P2P, 64, 64, 64, 64, 1},
+	{HALMAC_TRX_MODE_LOOPBACK, 64, 64, 64, 64, 640},
+	{HALMAC_TRX_MODE_DELAY_LOOPBACK, 64, 64, 64, 64, 640},
+};
+
+enum halmac_ret_status
+halmac_txdma_queue_mapping_8822b(struct halmac_adapter *halmac_adapter,
+				 enum halmac_trx_mode halmac_trx_mode)
+{
+	u16 value16;
+	void *driver_adapter = NULL;
+	struct halmac_rqpn_ *curr_rqpn_sel = NULL;
+	enum halmac_ret_status status;
+	struct halmac_api *halmac_api;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_SDIO) {
+		curr_rqpn_sel = HALMAC_RQPN_SDIO_8822B;
+	} else if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_PCIE) {
+		curr_rqpn_sel = HALMAC_RQPN_PCIE_8822B;
+	} else if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_USB) {
+		if (halmac_adapter->halmac_bulkout_num == 2) {
+			curr_rqpn_sel = HALMAC_RQPN_2BULKOUT_8822B;
+		} else if (halmac_adapter->halmac_bulkout_num == 3) {
+			curr_rqpn_sel = HALMAC_RQPN_3BULKOUT_8822B;
+		} else if (halmac_adapter->halmac_bulkout_num == 4) {
+			curr_rqpn_sel = HALMAC_RQPN_4BULKOUT_8822B;
+		} else {
+			pr_err("[ERR]interface not support\n");
+			return HALMAC_RET_NOT_SUPPORT;
+		}
+	} else {
+		return HALMAC_RET_NOT_SUPPORT;
+	}
+
+	status = halmac_rqpn_parser_88xx(halmac_adapter, halmac_trx_mode,
+					 curr_rqpn_sel);
+	if (status != HALMAC_RET_SUCCESS)
+		return status;
+
+	value16 = 0;
+	value16 |= BIT_TXDMA_HIQ_MAP(
+		halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_HI]);
+	value16 |= BIT_TXDMA_MGQ_MAP(
+		halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_MG]);
+	value16 |= BIT_TXDMA_BKQ_MAP(
+		halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_BK]);
+	value16 |= BIT_TXDMA_BEQ_MAP(
+		halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_BE]);
+	value16 |= BIT_TXDMA_VIQ_MAP(
+		halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_VI]);
+	value16 |= BIT_TXDMA_VOQ_MAP(
+		halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_VO]);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_TXDMA_PQ_MAP, value16);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_priority_queue_config_8822b(struct halmac_adapter *halmac_adapter,
+				   enum halmac_trx_mode halmac_trx_mode)
+{
+	u8 transfer_mode = 0;
+	u8 value8;
+	u32 counter;
+	enum halmac_ret_status status;
+	struct halmac_pg_num_ *curr_pg_num = NULL;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if (halmac_adapter->txff_allocation.la_mode == HALMAC_LA_MODE_DISABLE) {
+		if (halmac_adapter->txff_allocation.rx_fifo_expanding_mode ==
+		    HALMAC_RX_FIFO_EXPANDING_MODE_DISABLE) {
+			halmac_adapter->txff_allocation.tx_fifo_pg_num =
+				HALMAC_TX_FIFO_SIZE_8822B >>
+				HALMAC_TX_PAGE_SIZE_2_POWER_8822B;
+		} else if (halmac_adapter->txff_allocation
+				   .rx_fifo_expanding_mode ==
+			   HALMAC_RX_FIFO_EXPANDING_MODE_1_BLOCK) {
+			halmac_adapter->txff_allocation.tx_fifo_pg_num =
+				HALMAC_TX_FIFO_SIZE_EX_1_BLK_8822B >>
+				HALMAC_TX_PAGE_SIZE_2_POWER_8822B;
+			halmac_adapter->hw_config_info.tx_fifo_size =
+				HALMAC_TX_FIFO_SIZE_EX_1_BLK_8822B;
+			if (HALMAC_RX_FIFO_SIZE_EX_1_BLK_8822B <=
+			    HALMAC_RX_FIFO_SIZE_EX_1_BLK_MAX_8822B)
+				halmac_adapter->hw_config_info.rx_fifo_size =
+					HALMAC_RX_FIFO_SIZE_EX_1_BLK_8822B;
+			else
+				halmac_adapter->hw_config_info.rx_fifo_size =
+					HALMAC_RX_FIFO_SIZE_EX_1_BLK_MAX_8822B;
+		} else {
+			halmac_adapter->txff_allocation.tx_fifo_pg_num =
+				HALMAC_TX_FIFO_SIZE_8822B >>
+				HALMAC_TX_PAGE_SIZE_2_POWER_8822B;
+			pr_err("[ERR]rx_fifo_expanding_mode = %d not support\n",
+			       halmac_adapter->txff_allocation
+				       .rx_fifo_expanding_mode);
+		}
+	} else {
+		halmac_adapter->txff_allocation.tx_fifo_pg_num =
+			HALMAC_TX_FIFO_SIZE_LA_8822B >>
+			HALMAC_TX_PAGE_SIZE_2_POWER_8822B;
+	}
+	halmac_adapter->txff_allocation.rsvd_pg_num =
+		(halmac_adapter->txff_allocation.rsvd_drv_pg_num +
+		 HALMAC_RSVD_H2C_EXTRAINFO_PGNUM_8822B +
+		 HALMAC_RSVD_H2C_QUEUE_PGNUM_8822B +
+		 HALMAC_RSVD_CPU_INSTRUCTION_PGNUM_8822B +
+		 HALMAC_RSVD_FW_TXBUFF_PGNUM_8822B);
+	if (halmac_adapter->txff_allocation.rsvd_pg_num >
+	    halmac_adapter->txff_allocation.tx_fifo_pg_num)
+		return HALMAC_RET_CFG_TXFIFO_PAGE_FAIL;
+
+	halmac_adapter->txff_allocation.ac_q_pg_num =
+		halmac_adapter->txff_allocation.tx_fifo_pg_num -
+		halmac_adapter->txff_allocation.rsvd_pg_num;
+	halmac_adapter->txff_allocation.rsvd_pg_bndy =
+		halmac_adapter->txff_allocation.tx_fifo_pg_num -
+		halmac_adapter->txff_allocation.rsvd_pg_num;
+	halmac_adapter->txff_allocation.rsvd_fw_txbuff_pg_bndy =
+		halmac_adapter->txff_allocation.tx_fifo_pg_num -
+		HALMAC_RSVD_FW_TXBUFF_PGNUM_8822B;
+	halmac_adapter->txff_allocation.rsvd_cpu_instr_pg_bndy =
+		halmac_adapter->txff_allocation.rsvd_fw_txbuff_pg_bndy -
+		HALMAC_RSVD_CPU_INSTRUCTION_PGNUM_8822B;
+	halmac_adapter->txff_allocation.rsvd_h2c_queue_pg_bndy =
+		halmac_adapter->txff_allocation.rsvd_cpu_instr_pg_bndy -
+		HALMAC_RSVD_H2C_QUEUE_PGNUM_8822B;
+	halmac_adapter->txff_allocation.rsvd_h2c_extra_info_pg_bndy =
+		halmac_adapter->txff_allocation.rsvd_h2c_queue_pg_bndy -
+		HALMAC_RSVD_H2C_EXTRAINFO_PGNUM_8822B;
+	halmac_adapter->txff_allocation.rsvd_drv_pg_bndy =
+		halmac_adapter->txff_allocation.rsvd_h2c_extra_info_pg_bndy -
+		halmac_adapter->txff_allocation.rsvd_drv_pg_num;
+
+	if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_SDIO) {
+		curr_pg_num = HALMAC_PG_NUM_SDIO_8822B;
+	} else if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_PCIE) {
+		curr_pg_num = HALMAC_PG_NUM_PCIE_8822B;
+	} else if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_USB) {
+		if (halmac_adapter->halmac_bulkout_num == 2) {
+			curr_pg_num = HALMAC_PG_NUM_2BULKOUT_8822B;
+		} else if (halmac_adapter->halmac_bulkout_num == 3) {
+			curr_pg_num = HALMAC_PG_NUM_3BULKOUT_8822B;
+		} else if (halmac_adapter->halmac_bulkout_num == 4) {
+			curr_pg_num = HALMAC_PG_NUM_4BULKOUT_8822B;
+		} else {
+			pr_err("[ERR]interface not support\n");
+			return HALMAC_RET_NOT_SUPPORT;
+		}
+	} else {
+		return HALMAC_RET_NOT_SUPPORT;
+	}
+
+	status = halmac_pg_num_parser_88xx(halmac_adapter, halmac_trx_mode,
+					   curr_pg_num);
+	if (status != HALMAC_RET_SUCCESS)
+		return status;
+
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_INFO_1,
+			    halmac_adapter->txff_allocation.high_queue_pg_num);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_INFO_2,
+			    halmac_adapter->txff_allocation.low_queue_pg_num);
+	HALMAC_REG_WRITE_16(
+		halmac_adapter, REG_FIFOPAGE_INFO_3,
+		halmac_adapter->txff_allocation.normal_queue_pg_num);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_INFO_4,
+			    halmac_adapter->txff_allocation.extra_queue_pg_num);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_INFO_5,
+			    halmac_adapter->txff_allocation.pub_queue_pg_num);
+
+	halmac_adapter->sdio_free_space.high_queue_number =
+		halmac_adapter->txff_allocation.high_queue_pg_num;
+	halmac_adapter->sdio_free_space.normal_queue_number =
+		halmac_adapter->txff_allocation.normal_queue_pg_num;
+	halmac_adapter->sdio_free_space.low_queue_number =
+		halmac_adapter->txff_allocation.low_queue_pg_num;
+	halmac_adapter->sdio_free_space.public_queue_number =
+		halmac_adapter->txff_allocation.pub_queue_pg_num;
+	halmac_adapter->sdio_free_space.extra_queue_number =
+		halmac_adapter->txff_allocation.extra_queue_pg_num;
+
+	HALMAC_REG_WRITE_32(
+		halmac_adapter, REG_RQPN_CTRL_2,
+		HALMAC_REG_READ_32(halmac_adapter, REG_RQPN_CTRL_2) | BIT(31));
+
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_CTRL_2,
+			    (u16)(halmac_adapter->txff_allocation.rsvd_pg_bndy &
+				  BIT_MASK_BCN_HEAD_1_V1));
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_BCNQ_BDNY_V1,
+			    (u16)(halmac_adapter->txff_allocation.rsvd_pg_bndy &
+				  BIT_MASK_BCNQ_PGBNDY_V1));
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_CTRL_2 + 2,
+			    (u16)(halmac_adapter->txff_allocation.rsvd_pg_bndy &
+				  BIT_MASK_BCN_HEAD_1_V1));
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_BCNQ1_BDNY_V1,
+			    (u16)(halmac_adapter->txff_allocation.rsvd_pg_bndy &
+				  BIT_MASK_BCNQ_PGBNDY_V1));
+
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_RXFF_BNDY,
+			    halmac_adapter->hw_config_info.rx_fifo_size -
+				    HALMAC_C2H_PKT_BUF_8822B - 1);
+
+	if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_USB) {
+		value8 = (u8)(
+			HALMAC_REG_READ_8(halmac_adapter, REG_AUTO_LLT_V1) &
+			~(BIT_MASK_BLK_DESC_NUM << BIT_SHIFT_BLK_DESC_NUM));
+		value8 = (u8)(value8 | (HALMAC_BLK_DESC_NUM_8822B
+					<< BIT_SHIFT_BLK_DESC_NUM));
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_AUTO_LLT_V1, value8);
+
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_AUTO_LLT_V1 + 3,
+				   HALMAC_BLK_DESC_NUM_8822B);
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_TXDMA_OFFSET_CHK + 1,
+				   HALMAC_REG_READ_8(halmac_adapter,
+						     REG_TXDMA_OFFSET_CHK + 1) |
+					   BIT(1));
+	}
+
+	HALMAC_REG_WRITE_8(
+		halmac_adapter, REG_AUTO_LLT_V1,
+		(u8)(HALMAC_REG_READ_8(halmac_adapter, REG_AUTO_LLT_V1) |
+		     BIT_AUTO_INIT_LLT_V1));
+	counter = 1000;
+	while (HALMAC_REG_READ_8(halmac_adapter, REG_AUTO_LLT_V1) &
+	       BIT_AUTO_INIT_LLT_V1) {
+		counter--;
+		if (counter == 0)
+			return HALMAC_RET_INIT_LLT_FAIL;
+	}
+
+	if (halmac_trx_mode == HALMAC_TRX_MODE_DELAY_LOOPBACK) {
+		transfer_mode = HALMAC_TRNSFER_LOOPBACK_DELAY;
+		HALMAC_REG_WRITE_16(
+			halmac_adapter, REG_WMAC_LBK_BUF_HD_V1,
+			(u16)halmac_adapter->txff_allocation.rsvd_pg_bndy);
+	} else if (halmac_trx_mode == HALMAC_TRX_MODE_LOOPBACK) {
+		transfer_mode = HALMAC_TRNSFER_LOOPBACK_DIRECT;
+	} else {
+		transfer_mode = HALMAC_TRNSFER_NORMAL;
+	}
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_CR + 3, (u8)transfer_mode);
+
+	return HALMAC_RET_SUCCESS;
+}
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_func_8822b.h b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_func_8822b.h
new file mode 100644
index 000000000000..5ac2b15477c0
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_8822b/halmac_func_8822b.h
@@ -0,0 +1,38 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_FUNC_8822B_H_
+#define _HALMAC_FUNC_8822B_H_
+
+#include "../../halmac_type.h"
+
+enum halmac_ret_status
+halmac_txdma_queue_mapping_8822b(struct halmac_adapter *halmac_adapter,
+				 enum halmac_trx_mode halmac_trx_mode);
+
+enum halmac_ret_status
+halmac_priority_queue_config_8822b(struct halmac_adapter *halmac_adapter,
+				   enum halmac_trx_mode halmac_trx_mode);
+
+#endif /* _HALMAC_FUNC_8822B_H_ */
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_88xx_cfg.h b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_88xx_cfg.h
new file mode 100644
index 000000000000..ea1206744902
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_88xx_cfg.h
@@ -0,0 +1,171 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_88XX_CFG_H_
+#define _HALMAC_88XX_CFG_H_
+
+#include "../halmac_2_platform.h"
+#include "../halmac_type.h"
+#include "../halmac_api.h"
+#include "../halmac_bit2.h"
+#include "../halmac_reg2.h"
+#include "../halmac_pwr_seq_cmd.h"
+#include "halmac_func_88xx.h"
+#include "halmac_api_88xx.h"
+#include "halmac_api_88xx_usb.h"
+#include "halmac_api_88xx_pcie.h"
+#include "halmac_api_88xx_sdio.h"
+
+#define HALMAC_SVN_VER_88XX "13359M"
+
+#define HALMAC_MAJOR_VER_88XX 0x0001 /* major version, ver_1 for async_api */
+/* For halmac_api num change or prototype change, increment prototype version.
+ * Otherwise, increase minor version
+ */
+#define HALMAC_PROTOTYPE_VER_88XX 0x0003 /* prototype version */
+#define HALMAC_MINOR_VER_88XX 0x0005 /* minor version */
+#define HALMAC_PATCH_VER_88XX 0x0000 /* patch version */
+
+#define HALMAC_C2H_DATA_OFFSET_88XX 10
+#define HALMAC_RX_AGG_ALIGNMENT_SIZE_88XX 8
+#define HALMAC_TX_AGG_ALIGNMENT_SIZE_88XX 8
+#define HALMAC_TX_AGG_BUFF_SIZE_88XX 32768
+
+#define HALMAC_EXTRA_INFO_BUFF_SIZE_88XX 4096 /*4K*/
+#define HALMAC_EXTRA_INFO_BUFF_SIZE_FULL_FIFO_88XX 16384 /*16K*/
+#define HALMAC_FW_OFFLOAD_CMD_SIZE_88XX                                        \
+	12 /*Fw config parameter cmd size, each 12 byte*/
+
+#define HALMAC_H2C_CMD_ORIGINAL_SIZE_88XX 8
+#define HALMAC_H2C_CMD_SIZE_UNIT_88XX 32 /* Only support 32 byte packet now */
+
+#define HALMAC_NLO_INFO_SIZE_88XX 1024
+
+/* Download FW */
+#define HALMAC_FW_SIZE_MAX_88XX 0x40000
+#define HALMAC_FWHDR_SIZE_88XX 64
+#define HALMAC_FW_CHKSUM_DUMMY_SIZE_88XX 8
+#define HALMAC_FW_MAX_DL_SIZE_88XX 0x2000 /* need power of 2 */
+/* Max dlfw size can not over 31K, because SDIO HW restriction */
+#define HALMAC_FW_CFG_MAX_DL_SIZE_MAX_88XX 0x7C00
+
+#define DLFW_RESTORE_REG_NUM_88XX 9
+#define ID_INFORM_DLEMEM_RDY 0x80
+
+/* FW header information */
+#define HALMAC_FWHDR_OFFSET_VERSION_88XX 4
+#define HALMAC_FWHDR_OFFSET_SUBVERSION_88XX 6
+#define HALMAC_FWHDR_OFFSET_SUBINDEX_88XX 7
+#define HALMAC_FWHDR_OFFSET_MEM_USAGE_88XX 24
+#define HALMAC_FWHDR_OFFSET_H2C_FORMAT_VER_88XX 28
+#define HALMAC_FWHDR_OFFSET_DMEM_ADDR_88XX 32
+#define HALMAC_FWHDR_OFFSET_DMEM_SIZE_88XX 36
+#define HALMAC_FWHDR_OFFSET_IRAM_SIZE_88XX 48
+#define HALMAC_FWHDR_OFFSET_ERAM_SIZE_88XX 52
+#define HALMAC_FWHDR_OFFSET_EMEM_ADDR_88XX 56
+#define HALMAC_FWHDR_OFFSET_IRAM_ADDR_88XX 60
+
+/* HW memory address */
+#define HALMAC_OCPBASE_TXBUF_88XX 0x18780000
+#define HALMAC_OCPBASE_DMEM_88XX 0x00200000
+#define HALMAC_OCPBASE_IMEM_88XX 0x00000000
+
+/* define the SDIO Bus CLK threshold, for avoiding CMD53 fails that
+ * result from SDIO CLK sync to ana_clk fail
+ */
+#define HALMAC_SD_CLK_THRESHOLD_88XX 150000000 /* 150MHz */
+
+/* MAC clock */
+#define HALMAC_MAC_CLOCK_88XX 80 /* 80M */
+
+/* H2C/C2H*/
+#define HALMAC_H2C_CMD_SIZE_88XX 32
+#define HALMAC_H2C_CMD_HDR_SIZE_88XX 8
+
+#define HALMAC_PROTECTED_EFUSE_SIZE_88XX 0x60
+
+/* Function enable */
+#define HALMAC_FUNCTION_ENABLE_88XX 0xDC
+
+/* FIFO size & packet size */
+/* #define HALMAC_WOWLAN_PATTERN_SIZE	256 */
+
+/* CFEND rate */
+#define HALMAC_BASIC_CFEND_RATE_88XX 0x5
+#define HALMAC_STBC_CFEND_RATE_88XX 0xF
+
+/* Response rate */
+#define HALMAC_RESPONSE_RATE_BITMAP_ALL_88XX 0xFFFFF
+#define HALMAC_RESPONSE_RATE_88XX HALMAC_RESPONSE_RATE_BITMAP_ALL_88XX
+
+/* Spec SIFS */
+#define HALMAC_SIFS_CCK_PTCL_88XX 16
+#define HALMAC_SIFS_OFDM_PTCL_88XX 16
+
+/* Retry limit */
+#define HALMAC_LONG_RETRY_LIMIT_88XX 8
+#define HALMAC_SHORT_RETRY_LIMIT_88XX 7
+
+/* Slot, SIFS, PIFS time */
+#define HALMAC_SLOT_TIME_88XX 0x05
+#define HALMAC_PIFS_TIME_88XX 0x19
+#define HALMAC_SIFS_CCK_CTX_88XX 0xA
+#define HALMAC_SIFS_OFDM_CTX_88XX 0xA
+#define HALMAC_SIFS_CCK_TRX_88XX 0x10
+#define HALMAC_SIFS_OFDM_TRX_88XX 0x10
+
+/* TXOP limit */
+#define HALMAC_VO_TXOP_LIMIT_88XX 0x186
+#define HALMAC_VI_TXOP_LIMIT_88XX 0x3BC
+
+/* NAV */
+#define HALMAC_RDG_NAV_88XX 0x05
+#define HALMAC_TXOP_NAV_88XX 0x1B
+
+/* TSF */
+#define HALMAC_CCK_RX_TSF_88XX 0x30
+#define HALMAC_OFDM_RX_TSF_88XX 0x30
+
+/* Send beacon related */
+#define HALMAC_TBTT_PROHIBIT_88XX 0x04
+#define HALMAC_TBTT_HOLD_TIME_88XX 0x064
+#define HALMAC_DRIVER_EARLY_INT_88XX 0x04
+#define HALMAC_BEACON_DMA_TIM_88XX 0x02
+
+/* RX filter */
+#define HALMAC_RX_FILTER0_RECIVE_ALL_88XX 0xFFFFFFF
+#define HALMAC_RX_FILTER0_88XX HALMAC_RX_FILTER0_RECIVE_ALL_88XX
+#define HALMAC_RX_FILTER_RECIVE_ALL_88XX 0xFFFF
+#define HALMAC_RX_FILTER_88XX HALMAC_RX_FILTER_RECIVE_ALL_88XX
+
+/* RCR */
+#define HALMAC_RCR_CONFIG_88XX 0xE400631E
+
+/* Security config */
+#define HALMAC_SECURITY_CONFIG_88XX 0x01CC
+
+/* CCK rate ACK timeout */
+#define HALMAC_ACK_TO_CCK_88XX 0x40
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx.c b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx.c
new file mode 100644
index 000000000000..fadb35f3ba88
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx.c
@@ -0,0 +1,5980 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "halmac_88xx_cfg.h"
+
+/**
+ * halmac_init_adapter_para_88xx() - int halmac adapter
+ * @halmac_adapter
+ *
+ * SD1 internal use
+ *
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : void
+ */
+void halmac_init_adapter_para_88xx(struct halmac_adapter *halmac_adapter)
+{
+	halmac_adapter->api_record.array_wptr = 0;
+	halmac_adapter->hal_adapter_backup = halmac_adapter;
+	halmac_adapter->hal_efuse_map = (u8 *)NULL;
+	halmac_adapter->hal_efuse_map_valid = false;
+	halmac_adapter->efuse_end = 0;
+	halmac_adapter->hal_mac_addr[0].address_l_h.address_low = 0;
+	halmac_adapter->hal_mac_addr[0].address_l_h.address_high = 0;
+	halmac_adapter->hal_mac_addr[1].address_l_h.address_low = 0;
+	halmac_adapter->hal_mac_addr[1].address_l_h.address_high = 0;
+	halmac_adapter->hal_bss_addr[0].address_l_h.address_low = 0;
+	halmac_adapter->hal_bss_addr[0].address_l_h.address_high = 0;
+	halmac_adapter->hal_bss_addr[1].address_l_h.address_low = 0;
+	halmac_adapter->hal_bss_addr[1].address_l_h.address_high = 0;
+
+	halmac_adapter->low_clk = false;
+	halmac_adapter->max_download_size = HALMAC_FW_MAX_DL_SIZE_88XX;
+
+	/* Init LPS Option */
+	halmac_adapter->fwlps_option.mode = 0x01; /*0:Active 1:LPS 2:WMMPS*/
+	halmac_adapter->fwlps_option.awake_interval = 1;
+	halmac_adapter->fwlps_option.enter_32K = 1;
+	halmac_adapter->fwlps_option.clk_request = 0;
+	halmac_adapter->fwlps_option.rlbm = 0;
+	halmac_adapter->fwlps_option.smart_ps = 0;
+	halmac_adapter->fwlps_option.awake_interval = 1;
+	halmac_adapter->fwlps_option.all_queue_uapsd = 0;
+	halmac_adapter->fwlps_option.pwr_state = 0;
+	halmac_adapter->fwlps_option.low_pwr_rx_beacon = 0;
+	halmac_adapter->fwlps_option.ant_auto_switch = 0;
+	halmac_adapter->fwlps_option.ps_allow_bt_high_priority = 0;
+	halmac_adapter->fwlps_option.protect_bcn = 0;
+	halmac_adapter->fwlps_option.silence_period = 0;
+	halmac_adapter->fwlps_option.fast_bt_connect = 0;
+	halmac_adapter->fwlps_option.two_antenna_en = 0;
+	halmac_adapter->fwlps_option.adopt_user_setting = 1;
+	halmac_adapter->fwlps_option.drv_bcn_early_shift = 0;
+
+	halmac_adapter->config_para_info.cfg_para_buf = NULL;
+	halmac_adapter->config_para_info.para_buf_w = NULL;
+	halmac_adapter->config_para_info.para_num = 0;
+	halmac_adapter->config_para_info.full_fifo_mode = false;
+	halmac_adapter->config_para_info.para_buf_size = 0;
+	halmac_adapter->config_para_info.avai_para_buf_size = 0;
+	halmac_adapter->config_para_info.offset_accumulation = 0;
+	halmac_adapter->config_para_info.value_accumulation = 0;
+	halmac_adapter->config_para_info.datapack_segment = 0;
+
+	halmac_adapter->ch_sw_info.ch_info_buf = NULL;
+	halmac_adapter->ch_sw_info.ch_info_buf_w = NULL;
+	halmac_adapter->ch_sw_info.extra_info_en = 0;
+	halmac_adapter->ch_sw_info.buf_size = 0;
+	halmac_adapter->ch_sw_info.avai_buf_size = 0;
+	halmac_adapter->ch_sw_info.total_size = 0;
+	halmac_adapter->ch_sw_info.ch_num = 0;
+
+	halmac_adapter->drv_info_size = 0;
+
+	memset(halmac_adapter->api_record.api_array, HALMAC_API_STUFF,
+	       sizeof(halmac_adapter->api_record.api_array));
+
+	halmac_adapter->txff_allocation.tx_fifo_pg_num = 0;
+	halmac_adapter->txff_allocation.ac_q_pg_num = 0;
+	halmac_adapter->txff_allocation.rsvd_pg_bndy = 0;
+	halmac_adapter->txff_allocation.rsvd_drv_pg_bndy = 0;
+	halmac_adapter->txff_allocation.rsvd_h2c_extra_info_pg_bndy = 0;
+	halmac_adapter->txff_allocation.rsvd_h2c_queue_pg_bndy = 0;
+	halmac_adapter->txff_allocation.rsvd_cpu_instr_pg_bndy = 0;
+	halmac_adapter->txff_allocation.rsvd_fw_txbuff_pg_bndy = 0;
+	halmac_adapter->txff_allocation.pub_queue_pg_num = 0;
+	halmac_adapter->txff_allocation.high_queue_pg_num = 0;
+	halmac_adapter->txff_allocation.low_queue_pg_num = 0;
+	halmac_adapter->txff_allocation.normal_queue_pg_num = 0;
+	halmac_adapter->txff_allocation.extra_queue_pg_num = 0;
+
+	halmac_adapter->txff_allocation.la_mode = HALMAC_LA_MODE_DISABLE;
+	halmac_adapter->txff_allocation.rx_fifo_expanding_mode =
+		HALMAC_RX_FIFO_EXPANDING_MODE_DISABLE;
+
+	halmac_init_adapter_dynamic_para_88xx(halmac_adapter);
+	halmac_init_state_machine_88xx(halmac_adapter);
+}
+
+/**
+ * halmac_init_adapter_dynamic_para_88xx() - int halmac adapter
+ * @halmac_adapter
+ *
+ * SD1 internal use
+ *
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : void
+ */
+void halmac_init_adapter_dynamic_para_88xx(
+	struct halmac_adapter *halmac_adapter)
+{
+	halmac_adapter->h2c_packet_seq = 0;
+	halmac_adapter->h2c_buf_free_space = 0;
+	halmac_adapter->gen_info_valid = false;
+}
+
+/**
+ * halmac_init_state_machine_88xx() - init halmac software state machine
+ * @halmac_adapter
+ *
+ * SD1 internal use.
+ *
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : void
+ */
+void halmac_init_state_machine_88xx(struct halmac_adapter *halmac_adapter)
+{
+	struct halmac_state *state = &halmac_adapter->halmac_state;
+
+	halmac_init_offload_feature_state_machine_88xx(halmac_adapter);
+
+	state->api_state = HALMAC_API_STATE_INIT;
+
+	state->dlfw_state = HALMAC_DLFW_NONE;
+	state->mac_power = HALMAC_MAC_POWER_OFF;
+	state->ps_state = HALMAC_PS_STATE_UNDEFINE;
+}
+
+/**
+ * halmac_mount_api_88xx() - attach functions to function pointer
+ * @halmac_adapter
+ *
+ * SD1 internal use
+ *
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ */
+enum halmac_ret_status
+halmac_mount_api_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = halmac_adapter->driver_adapter;
+	struct halmac_api *halmac_api = (struct halmac_api *)NULL;
+
+	halmac_adapter->halmac_api =
+		kzalloc(sizeof(struct halmac_api), GFP_KERNEL);
+	if (!halmac_adapter->halmac_api)
+		return HALMAC_RET_MALLOC_FAIL;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			HALMAC_SVN_VER_88XX "\n");
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"HALMAC_MAJOR_VER_88XX = %x\n", HALMAC_MAJOR_VER_88XX);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"HALMAC_PROTOTYPE_88XX = %x\n",
+			HALMAC_PROTOTYPE_VER_88XX);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"HALMAC_MINOR_VER_88XX = %x\n", HALMAC_MINOR_VER_88XX);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"HALMAC_PATCH_VER_88XX = %x\n", HALMAC_PATCH_VER_88XX);
+
+	/* Mount function pointer */
+	halmac_api->halmac_download_firmware = halmac_download_firmware_88xx;
+	halmac_api->halmac_free_download_firmware =
+		halmac_free_download_firmware_88xx;
+	halmac_api->halmac_get_fw_version = halmac_get_fw_version_88xx;
+	halmac_api->halmac_cfg_mac_addr = halmac_cfg_mac_addr_88xx;
+	halmac_api->halmac_cfg_bssid = halmac_cfg_bssid_88xx;
+	halmac_api->halmac_cfg_multicast_addr = halmac_cfg_multicast_addr_88xx;
+	halmac_api->halmac_pre_init_system_cfg =
+		halmac_pre_init_system_cfg_88xx;
+	halmac_api->halmac_init_system_cfg = halmac_init_system_cfg_88xx;
+	halmac_api->halmac_init_edca_cfg = halmac_init_edca_cfg_88xx;
+	halmac_api->halmac_cfg_operation_mode = halmac_cfg_operation_mode_88xx;
+	halmac_api->halmac_cfg_ch_bw = halmac_cfg_ch_bw_88xx;
+	halmac_api->halmac_cfg_bw = halmac_cfg_bw_88xx;
+	halmac_api->halmac_init_wmac_cfg = halmac_init_wmac_cfg_88xx;
+	halmac_api->halmac_init_mac_cfg = halmac_init_mac_cfg_88xx;
+	halmac_api->halmac_init_sdio_cfg = halmac_init_sdio_cfg_88xx;
+	halmac_api->halmac_init_usb_cfg = halmac_init_usb_cfg_88xx;
+	halmac_api->halmac_init_pcie_cfg = halmac_init_pcie_cfg_88xx;
+	halmac_api->halmac_deinit_sdio_cfg = halmac_deinit_sdio_cfg_88xx;
+	halmac_api->halmac_deinit_usb_cfg = halmac_deinit_usb_cfg_88xx;
+	halmac_api->halmac_deinit_pcie_cfg = halmac_deinit_pcie_cfg_88xx;
+	halmac_api->halmac_dump_efuse_map = halmac_dump_efuse_map_88xx;
+	halmac_api->halmac_dump_efuse_map_bt = halmac_dump_efuse_map_bt_88xx;
+	halmac_api->halmac_write_efuse_bt = halmac_write_efuse_bt_88xx;
+	halmac_api->halmac_dump_logical_efuse_map =
+		halmac_dump_logical_efuse_map_88xx;
+	halmac_api->halmac_pg_efuse_by_map = halmac_pg_efuse_by_map_88xx;
+	halmac_api->halmac_get_efuse_size = halmac_get_efuse_size_88xx;
+	halmac_api->halmac_get_efuse_available_size =
+		halmac_get_efuse_available_size_88xx;
+	halmac_api->halmac_get_c2h_info = halmac_get_c2h_info_88xx;
+
+	halmac_api->halmac_get_logical_efuse_size =
+		halmac_get_logical_efuse_size_88xx;
+
+	halmac_api->halmac_write_logical_efuse =
+		halmac_write_logical_efuse_88xx;
+	halmac_api->halmac_read_logical_efuse = halmac_read_logical_efuse_88xx;
+
+	halmac_api->halmac_cfg_fwlps_option = halmac_cfg_fwlps_option_88xx;
+	halmac_api->halmac_cfg_fwips_option = halmac_cfg_fwips_option_88xx;
+	halmac_api->halmac_enter_wowlan = halmac_enter_wowlan_88xx;
+	halmac_api->halmac_leave_wowlan = halmac_leave_wowlan_88xx;
+	halmac_api->halmac_enter_ps = halmac_enter_ps_88xx;
+	halmac_api->halmac_leave_ps = halmac_leave_ps_88xx;
+	halmac_api->halmac_h2c_lb = halmac_h2c_lb_88xx;
+	halmac_api->halmac_debug = halmac_debug_88xx;
+	halmac_api->halmac_cfg_parameter = halmac_cfg_parameter_88xx;
+	halmac_api->halmac_update_datapack = halmac_update_datapack_88xx;
+	halmac_api->halmac_run_datapack = halmac_run_datapack_88xx;
+	halmac_api->halmac_cfg_drv_info = halmac_cfg_drv_info_88xx;
+	halmac_api->halmac_send_bt_coex = halmac_send_bt_coex_88xx;
+	halmac_api->halmac_verify_platform_api =
+		halmac_verify_platform_api_88xx;
+	halmac_api->halmac_update_packet = halmac_update_packet_88xx;
+	halmac_api->halmac_bcn_ie_filter = halmac_bcn_ie_filter_88xx;
+	halmac_api->halmac_cfg_txbf = halmac_cfg_txbf_88xx;
+	halmac_api->halmac_cfg_mumimo = halmac_cfg_mumimo_88xx;
+	halmac_api->halmac_cfg_sounding = halmac_cfg_sounding_88xx;
+	halmac_api->halmac_del_sounding = halmac_del_sounding_88xx;
+	halmac_api->halmac_su_bfer_entry_init = halmac_su_bfer_entry_init_88xx;
+	halmac_api->halmac_su_bfee_entry_init = halmac_su_bfee_entry_init_88xx;
+	halmac_api->halmac_mu_bfer_entry_init = halmac_mu_bfer_entry_init_88xx;
+	halmac_api->halmac_mu_bfee_entry_init = halmac_mu_bfee_entry_init_88xx;
+	halmac_api->halmac_su_bfer_entry_del = halmac_su_bfer_entry_del_88xx;
+	halmac_api->halmac_su_bfee_entry_del = halmac_su_bfee_entry_del_88xx;
+	halmac_api->halmac_mu_bfer_entry_del = halmac_mu_bfer_entry_del_88xx;
+	halmac_api->halmac_mu_bfee_entry_del = halmac_mu_bfee_entry_del_88xx;
+
+	halmac_api->halmac_add_ch_info = halmac_add_ch_info_88xx;
+	halmac_api->halmac_add_extra_ch_info = halmac_add_extra_ch_info_88xx;
+	halmac_api->halmac_ctrl_ch_switch = halmac_ctrl_ch_switch_88xx;
+	halmac_api->halmac_p2pps = halmac_p2pps_88xx;
+	halmac_api->halmac_clear_ch_info = halmac_clear_ch_info_88xx;
+	halmac_api->halmac_send_general_info = halmac_send_general_info_88xx;
+
+	halmac_api->halmac_start_iqk = halmac_start_iqk_88xx;
+	halmac_api->halmac_ctrl_pwr_tracking = halmac_ctrl_pwr_tracking_88xx;
+	halmac_api->halmac_psd = halmac_psd_88xx;
+	halmac_api->halmac_cfg_la_mode = halmac_cfg_la_mode_88xx;
+	halmac_api->halmac_cfg_rx_fifo_expanding_mode =
+		halmac_cfg_rx_fifo_expanding_mode_88xx;
+
+	halmac_api->halmac_config_security = halmac_config_security_88xx;
+	halmac_api->halmac_get_used_cam_entry_num =
+		halmac_get_used_cam_entry_num_88xx;
+	halmac_api->halmac_read_cam_entry = halmac_read_cam_entry_88xx;
+	halmac_api->halmac_write_cam = halmac_write_cam_88xx;
+	halmac_api->halmac_clear_cam_entry = halmac_clear_cam_entry_88xx;
+
+	halmac_api->halmac_get_hw_value = halmac_get_hw_value_88xx;
+	halmac_api->halmac_set_hw_value = halmac_set_hw_value_88xx;
+
+	halmac_api->halmac_cfg_drv_rsvd_pg_num =
+		halmac_cfg_drv_rsvd_pg_num_88xx;
+	halmac_api->halmac_get_chip_version = halmac_get_chip_version_88xx;
+
+	halmac_api->halmac_query_status = halmac_query_status_88xx;
+	halmac_api->halmac_reset_feature = halmac_reset_feature_88xx;
+	halmac_api->halmac_check_fw_status = halmac_check_fw_status_88xx;
+	halmac_api->halmac_dump_fw_dmem = halmac_dump_fw_dmem_88xx;
+	halmac_api->halmac_cfg_max_dl_size = halmac_cfg_max_dl_size_88xx;
+
+	halmac_api->halmac_dump_fifo = halmac_dump_fifo_88xx;
+	halmac_api->halmac_get_fifo_size = halmac_get_fifo_size_88xx;
+
+	halmac_api->halmac_chk_txdesc = halmac_chk_txdesc_88xx;
+	halmac_api->halmac_dl_drv_rsvd_page = halmac_dl_drv_rsvd_page_88xx;
+	halmac_api->halmac_cfg_csi_rate = halmac_cfg_csi_rate_88xx;
+
+	halmac_api->halmac_sdio_cmd53_4byte = halmac_sdio_cmd53_4byte_88xx;
+	halmac_api->halmac_txfifo_is_empty = halmac_txfifo_is_empty_88xx;
+
+	if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_SDIO) {
+		halmac_api->halmac_cfg_rx_aggregation =
+			halmac_cfg_rx_aggregation_88xx_sdio;
+		halmac_api->halmac_init_interface_cfg =
+			halmac_init_sdio_cfg_88xx;
+		halmac_api->halmac_deinit_interface_cfg =
+			halmac_deinit_sdio_cfg_88xx;
+		halmac_api->halmac_reg_read_8 = halmac_reg_read_8_sdio_88xx;
+		halmac_api->halmac_reg_write_8 = halmac_reg_write_8_sdio_88xx;
+		halmac_api->halmac_reg_read_16 = halmac_reg_read_16_sdio_88xx;
+		halmac_api->halmac_reg_write_16 = halmac_reg_write_16_sdio_88xx;
+		halmac_api->halmac_reg_read_32 = halmac_reg_read_32_sdio_88xx;
+		halmac_api->halmac_reg_write_32 = halmac_reg_write_32_sdio_88xx;
+		halmac_api->halmac_reg_read_indirect_32 =
+			halmac_reg_read_indirect_32_sdio_88xx;
+		halmac_api->halmac_reg_sdio_cmd53_read_n =
+			halmac_reg_read_nbyte_sdio_88xx;
+	} else if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_USB) {
+		halmac_api->halmac_cfg_rx_aggregation =
+			halmac_cfg_rx_aggregation_88xx_usb;
+		halmac_api->halmac_init_interface_cfg =
+			halmac_init_usb_cfg_88xx;
+		halmac_api->halmac_deinit_interface_cfg =
+			halmac_deinit_usb_cfg_88xx;
+		halmac_api->halmac_reg_read_8 = halmac_reg_read_8_usb_88xx;
+		halmac_api->halmac_reg_write_8 = halmac_reg_write_8_usb_88xx;
+		halmac_api->halmac_reg_read_16 = halmac_reg_read_16_usb_88xx;
+		halmac_api->halmac_reg_write_16 = halmac_reg_write_16_usb_88xx;
+		halmac_api->halmac_reg_read_32 = halmac_reg_read_32_usb_88xx;
+		halmac_api->halmac_reg_write_32 = halmac_reg_write_32_usb_88xx;
+	} else if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_PCIE) {
+		halmac_api->halmac_cfg_rx_aggregation =
+			halmac_cfg_rx_aggregation_88xx_pcie;
+		halmac_api->halmac_init_interface_cfg =
+			halmac_init_pcie_cfg_88xx;
+		halmac_api->halmac_deinit_interface_cfg =
+			halmac_deinit_pcie_cfg_88xx;
+		halmac_api->halmac_reg_read_8 = halmac_reg_read_8_pcie_88xx;
+		halmac_api->halmac_reg_write_8 = halmac_reg_write_8_pcie_88xx;
+		halmac_api->halmac_reg_read_16 = halmac_reg_read_16_pcie_88xx;
+		halmac_api->halmac_reg_write_16 = halmac_reg_write_16_pcie_88xx;
+		halmac_api->halmac_reg_read_32 = halmac_reg_read_32_pcie_88xx;
+		halmac_api->halmac_reg_write_32 = halmac_reg_write_32_pcie_88xx;
+	} else {
+		pr_err("Set halmac io function Error!!\n");
+	}
+
+	halmac_api->halmac_set_bulkout_num = halmac_set_bulkout_num_88xx;
+	halmac_api->halmac_get_sdio_tx_addr = halmac_get_sdio_tx_addr_88xx;
+	halmac_api->halmac_get_usb_bulkout_id = halmac_get_usb_bulkout_id_88xx;
+	halmac_api->halmac_timer_2s = halmac_timer_2s_88xx;
+	halmac_api->halmac_fill_txdesc_checksum =
+		halmac_fill_txdesc_check_sum_88xx;
+
+	if (halmac_adapter->chip_id == HALMAC_CHIP_ID_8822B) {
+		/*mount 8822b function and data*/
+		halmac_mount_api_8822b(halmac_adapter);
+
+	} else if (halmac_adapter->chip_id == HALMAC_CHIP_ID_8821C) {
+	} else if (halmac_adapter->chip_id == HALMAC_CHIP_ID_8814B) {
+	} else if (halmac_adapter->chip_id == HALMAC_CHIP_ID_8197F) {
+	} else {
+		pr_err("Chip ID undefine!!\n");
+		return HALMAC_RET_CHIP_NOT_SUPPORT;
+	}
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_download_firmware_88xx() - download Firmware
+ * @halmac_adapter : the adapter of halmac
+ * @hamacl_fw : firmware bin
+ * @halmac_fw_size : firmware size
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_download_firmware_88xx(struct halmac_adapter *halmac_adapter,
+			      u8 *hamacl_fw, u32 halmac_fw_size)
+{
+	u8 value8;
+	u8 *file_ptr;
+	u32 dest;
+	u16 value16;
+	u32 restore_index = 0;
+	u32 halmac_h2c_ver = 0, fw_h2c_ver = 0;
+	u32 iram_pkt_size, dmem_pkt_size, eram_pkt_size = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	struct halmac_restore_info restore_info[DLFW_RESTORE_REG_NUM_88XX];
+	u32 temp;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_DOWNLOAD_FIRMWARE);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s start!!\n", __func__);
+
+	if (halmac_fw_size > HALMAC_FW_SIZE_MAX_88XX ||
+	    halmac_fw_size < HALMAC_FWHDR_SIZE_88XX) {
+		pr_err("FW size error!\n");
+		return HALMAC_RET_FW_SIZE_ERR;
+	}
+
+	fw_h2c_ver = le32_to_cpu(
+		*((__le32 *)
+		  (hamacl_fw + HALMAC_FWHDR_OFFSET_H2C_FORMAT_VER_88XX)));
+	halmac_h2c_ver = H2C_FORMAT_VERSION;
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+		"halmac h2c/c2h format = %x, fw h2c/c2h format = %x!!\n",
+		halmac_h2c_ver, fw_h2c_ver);
+	if (fw_h2c_ver != halmac_h2c_ver)
+		HALMAC_RT_TRACE(
+			driver_adapter, HALMAC_MSG_INIT, DBG_WARNING,
+			"[WARN]H2C/C2H version between HALMAC and FW is compatible!!\n");
+
+	halmac_adapter->halmac_state.dlfw_state = HALMAC_DLFW_NONE;
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_SYS_FUNC_EN + 1);
+	value8 = (u8)(value8 & ~(BIT(2)));
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_SYS_FUNC_EN + 1,
+			   value8); /* Disable CPU reset */
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_RSV_CTRL + 1);
+	value8 = (u8)(value8 & ~(BIT(0)));
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_RSV_CTRL + 1, value8);
+
+	restore_info[restore_index].length = 1;
+	restore_info[restore_index].mac_register = REG_TXDMA_PQ_MAP + 1;
+	restore_info[restore_index].value =
+		HALMAC_REG_READ_8(halmac_adapter, REG_TXDMA_PQ_MAP + 1);
+	restore_index++;
+	value8 = HALMAC_DMA_MAPPING_HIGH << 6;
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_TXDMA_PQ_MAP + 1,
+			   value8); /* set HIQ to hi priority */
+
+	/* DLFW only use HIQ, map HIQ to hi priority */
+	halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_HI] =
+		HALMAC_DMA_MAPPING_HIGH;
+	restore_info[restore_index].length = 1;
+	restore_info[restore_index].mac_register = REG_CR;
+	restore_info[restore_index].value =
+		HALMAC_REG_READ_8(halmac_adapter, REG_CR);
+	restore_index++;
+	restore_info[restore_index].length = 4;
+	restore_info[restore_index].mac_register = REG_H2CQ_CSR;
+	restore_info[restore_index].value = BIT(31);
+	restore_index++;
+	value8 = BIT_HCI_TXDMA_EN | BIT_TXDMA_EN;
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_CR, value8);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_H2CQ_CSR, BIT(31));
+
+	/* Config hi priority queue and public priority queue page number
+	 * (only for DLFW)
+	 */
+	restore_info[restore_index].length = 2;
+	restore_info[restore_index].mac_register = REG_FIFOPAGE_INFO_1;
+	restore_info[restore_index].value =
+		HALMAC_REG_READ_16(halmac_adapter, REG_FIFOPAGE_INFO_1);
+	restore_index++;
+	restore_info[restore_index].length = 4;
+	restore_info[restore_index].mac_register = REG_RQPN_CTRL_2;
+	restore_info[restore_index].value =
+		HALMAC_REG_READ_32(halmac_adapter, REG_RQPN_CTRL_2) | BIT(31);
+	restore_index++;
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_INFO_1, 0x200);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_RQPN_CTRL_2,
+			    restore_info[restore_index - 1].value);
+
+	if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_SDIO) {
+		HALMAC_REG_READ_32(halmac_adapter, REG_SDIO_FREE_TXPG);
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_SDIO_TX_CTRL,
+				    0x00000000);
+	}
+
+	halmac_adapter->fw_version.version = le16_to_cpu(
+		*((__le16 *)(hamacl_fw + HALMAC_FWHDR_OFFSET_VERSION_88XX)));
+	halmac_adapter->fw_version.sub_version =
+		*(hamacl_fw + HALMAC_FWHDR_OFFSET_SUBVERSION_88XX);
+	halmac_adapter->fw_version.sub_index =
+		*(hamacl_fw + HALMAC_FWHDR_OFFSET_SUBINDEX_88XX);
+	halmac_adapter->fw_version.h2c_version = (u16)fw_h2c_ver;
+
+	dmem_pkt_size = le32_to_cpu(*((__le32 *)(hamacl_fw +
+				      HALMAC_FWHDR_OFFSET_DMEM_SIZE_88XX)));
+	iram_pkt_size = le32_to_cpu(*((__le32 *)(hamacl_fw +
+				      HALMAC_FWHDR_OFFSET_IRAM_SIZE_88XX)));
+	if (((*(hamacl_fw + HALMAC_FWHDR_OFFSET_MEM_USAGE_88XX)) & BIT(4)) != 0)
+		eram_pkt_size =
+		     le32_to_cpu(*((__le32 *)(hamacl_fw +
+				   HALMAC_FWHDR_OFFSET_ERAM_SIZE_88XX)));
+
+	dmem_pkt_size += HALMAC_FW_CHKSUM_DUMMY_SIZE_88XX;
+	iram_pkt_size += HALMAC_FW_CHKSUM_DUMMY_SIZE_88XX;
+	if (eram_pkt_size != 0)
+		eram_pkt_size += HALMAC_FW_CHKSUM_DUMMY_SIZE_88XX;
+
+	if (halmac_fw_size != (HALMAC_FWHDR_SIZE_88XX + dmem_pkt_size +
+			       iram_pkt_size + eram_pkt_size)) {
+		pr_err("FW size mismatch the real fw size!\n");
+		goto DLFW_FAIL;
+	}
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_CR + 1);
+	restore_info[restore_index].length = 1;
+	restore_info[restore_index].mac_register = REG_CR + 1;
+	restore_info[restore_index].value = value8;
+	restore_index++;
+	value8 = (u8)(value8 | BIT(0));
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_CR + 1,
+			   value8); /* Enable SW TX beacon */
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_BCN_CTRL);
+	restore_info[restore_index].length = 1;
+	restore_info[restore_index].mac_register = REG_BCN_CTRL;
+	restore_info[restore_index].value = value8;
+	restore_index++;
+	value8 = (u8)((value8 & (~BIT(3))) | BIT(4));
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_BCN_CTRL,
+			   value8); /* Disable beacon related functions */
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_FWHW_TXQ_CTRL + 2);
+	restore_info[restore_index].length = 1;
+	restore_info[restore_index].mac_register = REG_FWHW_TXQ_CTRL + 2;
+	restore_info[restore_index].value = value8;
+	restore_index++;
+	value8 = (u8)(value8 & ~(BIT(6)));
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_FWHW_TXQ_CTRL + 2,
+			   value8); /* Disable ptcl tx bcnq */
+
+	restore_info[restore_index].length = 2;
+	restore_info[restore_index].mac_register = REG_FIFOPAGE_CTRL_2;
+	restore_info[restore_index].value =
+		HALMAC_REG_READ_16(halmac_adapter, REG_FIFOPAGE_CTRL_2) |
+		BIT(15);
+	restore_index++;
+	value16 = 0x8000;
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_CTRL_2,
+			    value16); /* Set beacon header to  0 */
+
+	value16 = (u16)(HALMAC_REG_READ_16(halmac_adapter, REG_MCUFW_CTRL) &
+			0x3800);
+	value16 |= BIT(0);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_MCUFW_CTRL,
+			    value16); /* MCU/FW setting */
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_CPU_DMEM_CON + 2);
+	value8 &= ~(BIT(0));
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_CPU_DMEM_CON + 2, value8);
+	value8 |= BIT(0);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_CPU_DMEM_CON + 2, value8);
+
+	/* Download to DMEM */
+	file_ptr = hamacl_fw + HALMAC_FWHDR_SIZE_88XX;
+	temp = le32_to_cpu(*((__le32 *)(hamacl_fw +
+			   HALMAC_FWHDR_OFFSET_DMEM_ADDR_88XX))) &
+			   ~(BIT(31));
+	if (halmac_dlfw_to_mem_88xx(halmac_adapter, file_ptr, temp,
+				    dmem_pkt_size) != HALMAC_RET_SUCCESS)
+		goto DLFW_END;
+
+	/* Download to IMEM */
+	file_ptr = hamacl_fw + HALMAC_FWHDR_SIZE_88XX + dmem_pkt_size;
+	temp = le32_to_cpu(*((__le32 *)(hamacl_fw +
+			   HALMAC_FWHDR_OFFSET_IRAM_ADDR_88XX))) &
+			   ~(BIT(31));
+	if (halmac_dlfw_to_mem_88xx(halmac_adapter, file_ptr, temp,
+				    iram_pkt_size) != HALMAC_RET_SUCCESS)
+		goto DLFW_END;
+
+	/* Download to EMEM */
+	if (eram_pkt_size != 0) {
+		file_ptr = hamacl_fw + HALMAC_FWHDR_SIZE_88XX + dmem_pkt_size +
+			   iram_pkt_size;
+		dest = le32_to_cpu((*((__le32 *)(hamacl_fw +
+				    HALMAC_FWHDR_OFFSET_EMEM_ADDR_88XX)))) &
+				   ~(BIT(31));
+		if (halmac_dlfw_to_mem_88xx(halmac_adapter, file_ptr, dest,
+					    eram_pkt_size) !=
+		    HALMAC_RET_SUCCESS)
+			goto DLFW_END;
+	}
+
+	halmac_init_offload_feature_state_machine_88xx(halmac_adapter);
+DLFW_END:
+
+	halmac_restore_mac_register_88xx(halmac_adapter, restore_info,
+					 DLFW_RESTORE_REG_NUM_88XX);
+
+	if (halmac_dlfw_end_flow_88xx(halmac_adapter) != HALMAC_RET_SUCCESS)
+		goto DLFW_FAIL;
+
+	halmac_adapter->halmac_state.dlfw_state = HALMAC_DLFW_DONE;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+
+DLFW_FAIL:
+
+	/* Disable FWDL_EN */
+	HALMAC_REG_WRITE_8(
+		halmac_adapter, REG_MCUFW_CTRL,
+		(u8)(HALMAC_REG_READ_8(halmac_adapter, REG_MCUFW_CTRL) &
+		     ~(BIT(0))));
+
+	return HALMAC_RET_DLFW_FAIL;
+}
+
+/**
+ * halmac_free_download_firmware_88xx() - download specific memory firmware
+ * @halmac_adapter
+ * @dlfw_mem : memory selection
+ * @hamacl_fw : firmware bin
+ * @halmac_fw_size : firmware size
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ */
+enum halmac_ret_status
+halmac_free_download_firmware_88xx(struct halmac_adapter *halmac_adapter,
+				   enum halmac_dlfw_mem dlfw_mem, u8 *hamacl_fw,
+				   u32 halmac_fw_size)
+{
+	u8 tx_pause_backup;
+	u8 *file_ptr;
+	u32 dest;
+	u16 bcn_head_backup;
+	u32 iram_pkt_size, dmem_pkt_size, eram_pkt_size = 0;
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_DLFW_FAIL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"[TRACE]%s ==========>\n", __func__);
+
+	if (halmac_fw_size > HALMAC_FW_SIZE_MAX_88XX ||
+	    halmac_fw_size < HALMAC_FWHDR_SIZE_88XX) {
+		pr_err("[ERR]FW size error!\n");
+		return HALMAC_RET_FW_SIZE_ERR;
+	}
+
+	dmem_pkt_size =
+	    le32_to_cpu(*(__le32 *)(hamacl_fw +
+				    HALMAC_FWHDR_OFFSET_DMEM_SIZE_88XX));
+	iram_pkt_size =
+	    le32_to_cpu(*(__le32 *)(hamacl_fw +
+				    HALMAC_FWHDR_OFFSET_IRAM_SIZE_88XX));
+	if (((*(hamacl_fw + HALMAC_FWHDR_OFFSET_MEM_USAGE_88XX)) & BIT(4)) != 0)
+		eram_pkt_size =
+		  le32_to_cpu(*(__le32 *)(hamacl_fw +
+					  HALMAC_FWHDR_OFFSET_ERAM_SIZE_88XX));
+
+	dmem_pkt_size += HALMAC_FW_CHKSUM_DUMMY_SIZE_88XX;
+	iram_pkt_size += HALMAC_FW_CHKSUM_DUMMY_SIZE_88XX;
+	if (eram_pkt_size != 0)
+		eram_pkt_size += HALMAC_FW_CHKSUM_DUMMY_SIZE_88XX;
+
+	if (halmac_fw_size != (HALMAC_FWHDR_SIZE_88XX + dmem_pkt_size +
+			       iram_pkt_size + eram_pkt_size)) {
+		pr_err("[ERR]FW size mismatch the real fw size!\n");
+		return HALMAC_RET_DLFW_FAIL;
+	}
+
+	tx_pause_backup = HALMAC_REG_READ_8(halmac_adapter, REG_TXPAUSE);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_TXPAUSE,
+			   tx_pause_backup | BIT(7));
+
+	bcn_head_backup =
+		HALMAC_REG_READ_16(halmac_adapter, REG_FIFOPAGE_CTRL_2) |
+		BIT(15);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_CTRL_2, 0x8000);
+
+	if (eram_pkt_size != 0) {
+		file_ptr = hamacl_fw + HALMAC_FWHDR_SIZE_88XX + dmem_pkt_size +
+			   iram_pkt_size;
+		dest = le32_to_cpu(*((__le32 *)(hamacl_fw +
+				   HALMAC_FWHDR_OFFSET_EMEM_ADDR_88XX))) &
+				   ~(BIT(31));
+		status = halmac_dlfw_to_mem_88xx(halmac_adapter, file_ptr, dest,
+						 eram_pkt_size);
+		if (status != HALMAC_RET_SUCCESS)
+			goto DL_FREE_FW_END;
+	}
+
+	status = halmac_free_dl_fw_end_flow_88xx(halmac_adapter);
+
+DL_FREE_FW_END:
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_TXPAUSE, tx_pause_backup);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_CTRL_2,
+			    bcn_head_backup);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"[TRACE]%s <==========\n", __func__);
+
+	return status;
+}
+
+/**
+ * halmac_get_fw_version_88xx() - get FW version
+ * @halmac_adapter : the adapter of halmac
+ * @fw_version : fw version info
+ * Author : Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_get_fw_version_88xx(struct halmac_adapter *halmac_adapter,
+			   struct halmac_fw_version *fw_version)
+{
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_adapter->halmac_state.dlfw_state == 0)
+		return HALMAC_RET_DLFW_FAIL;
+
+	fw_version->version = halmac_adapter->fw_version.version;
+	fw_version->sub_version = halmac_adapter->fw_version.sub_version;
+	fw_version->sub_index = halmac_adapter->fw_version.sub_index;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_mac_addr_88xx() - config mac address
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_port :0 for port0, 1 for port1, 2 for port2, 3 for port3, 4 for port4
+ * @hal_address : mac address
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_mac_addr_88xx(struct halmac_adapter *halmac_adapter, u8 halmac_port,
+			 union halmac_wlan_addr *hal_address)
+{
+	u16 mac_address_H;
+	u32 mac_address_L;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"[TRACE]%s ==========>\n", __func__);
+
+	if (halmac_port >= HALMAC_PORTIDMAX) {
+		pr_err("[ERR]port index > 5\n");
+		return HALMAC_RET_PORT_NOT_SUPPORT;
+	}
+
+	mac_address_L = le32_to_cpu(hal_address->address_l_h.le_address_low);
+	mac_address_H = le16_to_cpu(hal_address->address_l_h.le_address_high);
+
+	halmac_adapter->hal_mac_addr[halmac_port].address_l_h.address_low =
+		mac_address_L;
+	halmac_adapter->hal_mac_addr[halmac_port].address_l_h.address_high =
+		mac_address_H;
+
+	switch (halmac_port) {
+	case HALMAC_PORTID0:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_MACID, mac_address_L);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_MACID + 4,
+				    mac_address_H);
+		break;
+
+	case HALMAC_PORTID1:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_MACID1, mac_address_L);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_MACID1 + 4,
+				    mac_address_H);
+		break;
+
+	case HALMAC_PORTID2:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_MACID2, mac_address_L);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_MACID2 + 4,
+				    mac_address_H);
+		break;
+
+	case HALMAC_PORTID3:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_MACID3, mac_address_L);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_MACID3 + 4,
+				    mac_address_H);
+		break;
+
+	case HALMAC_PORTID4:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_MACID4, mac_address_L);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_MACID4 + 4,
+				    mac_address_H);
+		break;
+
+	default:
+
+		break;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"[TRACE]%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_bssid_88xx() - config BSSID
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_port :0 for port0, 1 for port1, 2 for port2, 3 for port3, 4 for port4
+ * @hal_address : bssid
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_bssid_88xx(struct halmac_adapter *halmac_adapter, u8 halmac_port,
+		      union halmac_wlan_addr *hal_address)
+{
+	u16 bssid_address_H;
+	u32 bssid_address_L;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"[TRACE]%s ==========>\n", __func__);
+
+	if (halmac_port >= HALMAC_PORTIDMAX) {
+		pr_err("[ERR]port index > 5\n");
+		return HALMAC_RET_PORT_NOT_SUPPORT;
+	}
+
+	bssid_address_L = le32_to_cpu(hal_address->address_l_h.le_address_low);
+	bssid_address_H = le16_to_cpu(hal_address->address_l_h.le_address_high);
+
+	halmac_adapter->hal_bss_addr[halmac_port].address_l_h.address_low =
+		bssid_address_L;
+	halmac_adapter->hal_bss_addr[halmac_port].address_l_h.address_high =
+		bssid_address_H;
+
+	switch (halmac_port) {
+	case HALMAC_PORTID0:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_BSSID, bssid_address_L);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_BSSID + 4,
+				    bssid_address_H);
+		break;
+
+	case HALMAC_PORTID1:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_BSSID1,
+				    bssid_address_L);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_BSSID1 + 4,
+				    bssid_address_H);
+		break;
+
+	case HALMAC_PORTID2:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_BSSID2,
+				    bssid_address_L);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_BSSID2 + 4,
+				    bssid_address_H);
+		break;
+
+	case HALMAC_PORTID3:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_BSSID3,
+				    bssid_address_L);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_BSSID3 + 4,
+				    bssid_address_H);
+		break;
+
+	case HALMAC_PORTID4:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_BSSID4,
+				    bssid_address_L);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_BSSID4 + 4,
+				    bssid_address_H);
+		break;
+
+	default:
+
+		break;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"[TRACE]%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_multicast_addr_88xx() - config multicast address
+ * @halmac_adapter : the adapter of halmac
+ * @hal_address : multicast address
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_multicast_addr_88xx(struct halmac_adapter *halmac_adapter,
+			       union halmac_wlan_addr *hal_address)
+{
+	u16 address_H;
+	u32 address_L;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_CFG_MULTICAST_ADDR);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	address_L = le32_to_cpu(hal_address->address_l_h.le_address_low);
+	address_H = le16_to_cpu(hal_address->address_l_h.le_address_high);
+
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_MAR, address_L);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_MAR + 4, address_H);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_pre_init_system_cfg_88xx() - pre-init system config
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_pre_init_system_cfg_88xx(struct halmac_adapter *halmac_adapter)
+{
+	u32 value32, counter;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	bool enable_bb;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_PRE_INIT_SYSTEM_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"halmac_pre_init_system_cfg ==========>\n");
+
+	if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_SDIO) {
+		HALMAC_REG_WRITE_8(
+			halmac_adapter, REG_SDIO_HSUS_CTRL,
+			HALMAC_REG_READ_8(halmac_adapter, REG_SDIO_HSUS_CTRL) &
+				~(BIT(0)));
+		counter = 10000;
+		while (!(HALMAC_REG_READ_8(halmac_adapter, REG_SDIO_HSUS_CTRL) &
+			 0x02)) {
+			counter--;
+			if (counter == 0)
+				return HALMAC_RET_SDIO_LEAVE_SUSPEND_FAIL;
+		}
+	} else if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_USB) {
+		if (HALMAC_REG_READ_8(halmac_adapter, REG_SYS_CFG2 + 3) ==
+		    0x20) /* usb3.0 */
+			HALMAC_REG_WRITE_8(
+				halmac_adapter, 0xFE5B,
+				HALMAC_REG_READ_8(halmac_adapter, 0xFE5B) |
+					BIT(4));
+	}
+
+	/* Config PIN Mux */
+	value32 = HALMAC_REG_READ_32(halmac_adapter, REG_PAD_CTRL1);
+	value32 = value32 & (~(BIT(28) | BIT(29)));
+	value32 = value32 | BIT(28) | BIT(29);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_PAD_CTRL1, value32);
+
+	value32 = HALMAC_REG_READ_32(halmac_adapter, REG_LED_CFG);
+	value32 = value32 & (~(BIT(25) | BIT(26)));
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_LED_CFG, value32);
+
+	value32 = HALMAC_REG_READ_32(halmac_adapter, REG_GPIO_MUXCFG);
+	value32 = value32 & (~(BIT(2)));
+	value32 = value32 | BIT(2);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_GPIO_MUXCFG, value32);
+
+	enable_bb = false;
+	halmac_set_hw_value_88xx(halmac_adapter, HALMAC_HW_EN_BB_RF,
+				 &enable_bb);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"halmac_pre_init_system_cfg <==========\n");
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_init_system_cfg_88xx() -  init system config
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_init_system_cfg_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_INIT_SYSTEM_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"halmac_init_system_cfg ==========>\n");
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_SYS_FUNC_EN + 1,
+			   HALMAC_FUNCTION_ENABLE_88XX);
+	HALMAC_REG_WRITE_32(
+		halmac_adapter, REG_SYS_SDIO_CTRL,
+		(u32)(HALMAC_REG_READ_32(halmac_adapter, REG_SYS_SDIO_CTRL) |
+		      BIT_LTE_MUX_CTRL_PATH));
+	HALMAC_REG_WRITE_32(
+		halmac_adapter, REG_CPU_DMEM_CON,
+		(u32)(HALMAC_REG_READ_32(halmac_adapter, REG_CPU_DMEM_CON) |
+		      BIT_WL_PLATFORM_RST));
+
+	/* halmac_api->halmac_init_h2c(halmac_adapter); */
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"halmac_init_system_cfg <==========\n");
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_init_edca_cfg_88xx() - init EDCA config
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_init_edca_cfg_88xx(struct halmac_adapter *halmac_adapter)
+{
+	u8 value8;
+	u32 value32;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_INIT_EDCA_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	/* Clear TX pause */
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_TXPAUSE, 0x0000);
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_SLOT, HALMAC_SLOT_TIME_88XX);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_PIFS, HALMAC_PIFS_TIME_88XX);
+	value32 = HALMAC_SIFS_CCK_CTX_88XX |
+		  (HALMAC_SIFS_OFDM_CTX_88XX << BIT_SHIFT_SIFS_OFDM_CTX) |
+		  (HALMAC_SIFS_CCK_TRX_88XX << BIT_SHIFT_SIFS_CCK_TRX) |
+		  (HALMAC_SIFS_OFDM_TRX_88XX << BIT_SHIFT_SIFS_OFDM_TRX);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_SIFS, value32);
+
+	HALMAC_REG_WRITE_32(
+		halmac_adapter, REG_EDCA_VO_PARAM,
+		HALMAC_REG_READ_32(halmac_adapter, REG_EDCA_VO_PARAM) & 0xFFFF);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_EDCA_VO_PARAM + 2,
+			    HALMAC_VO_TXOP_LIMIT_88XX);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_EDCA_VI_PARAM + 2,
+			    HALMAC_VI_TXOP_LIMIT_88XX);
+
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_RD_NAV_NXT,
+			    HALMAC_RDG_NAV_88XX | (HALMAC_TXOP_NAV_88XX << 16));
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_RXTSF_OFFSET_CCK,
+			    HALMAC_CCK_RX_TSF_88XX |
+				    (HALMAC_OFDM_RX_TSF_88XX) << 8);
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_RD_CTRL + 1);
+	value8 |=
+		(BIT_VOQ_RD_INIT_EN | BIT_VIQ_RD_INIT_EN | BIT_BEQ_RD_INIT_EN);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_RD_CTRL + 1, value8);
+
+	/* Set beacon cotnrol - enable TSF and other related functions */
+	HALMAC_REG_WRITE_8(
+		halmac_adapter, REG_BCN_CTRL,
+		(u8)(HALMAC_REG_READ_8(halmac_adapter, REG_BCN_CTRL) |
+		     BIT_EN_BCN_FUNCTION));
+
+	/* Set send beacon related registers */
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_TBTT_PROHIBIT,
+			    HALMAC_TBTT_PROHIBIT_88XX |
+				    (HALMAC_TBTT_HOLD_TIME_88XX
+				     << BIT_SHIFT_TBTT_HOLD_TIME_AP));
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_DRVERLYINT,
+			   HALMAC_DRIVER_EARLY_INT_88XX);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_BCNDMATIM,
+			   HALMAC_BEACON_DMA_TIM_88XX);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_init_wmac_cfg_88xx() - init wmac config
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_init_wmac_cfg_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_INIT_WMAC_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_RXFLTMAP0,
+			    HALMAC_RX_FILTER0_88XX);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_RXFLTMAP,
+			    HALMAC_RX_FILTER_88XX);
+
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_RCR, HALMAC_RCR_CONFIG_88XX);
+
+	HALMAC_REG_WRITE_8(
+		halmac_adapter, REG_TCR + 1,
+		(u8)(HALMAC_REG_READ_8(halmac_adapter, REG_TCR + 1) | 0x30));
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_TCR + 2, 0x30);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_TCR + 1, 0x00);
+
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_WMAC_OPTION_FUNCTION + 8,
+			    0x30810041);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_WMAC_OPTION_FUNCTION + 4,
+			    0x50802080);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_init_mac_cfg_88xx() - config page1~page7 register
+ * @halmac_adapter : the adapter of halmac
+ * @mode : trx mode
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_init_mac_cfg_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_trx_mode mode)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_INIT_MAC_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>mode = %d\n", __func__,
+			mode);
+
+	status = halmac_api->halmac_init_trx_cfg(halmac_adapter, mode);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_init_trx_cfg errorr = %x\n", status);
+		return status;
+	}
+	status = halmac_api->halmac_init_protocol_cfg(halmac_adapter);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_init_protocol_cfg_88xx error = %x\n", status);
+		return status;
+	}
+
+	status = halmac_init_edca_cfg_88xx(halmac_adapter);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_init_edca_cfg_88xx error = %x\n", status);
+		return status;
+	}
+
+	status = halmac_init_wmac_cfg_88xx(halmac_adapter);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_init_wmac_cfg_88xx error = %x\n", status);
+		return status;
+	}
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return status;
+}
+
+/**
+ * halmac_cfg_operation_mode_88xx() - config operation mode
+ * @halmac_adapter : the adapter of halmac
+ * @wireless_mode : 802.11 standard(b/g/n/ac)
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_operation_mode_88xx(struct halmac_adapter *halmac_adapter,
+			       enum halmac_wireless_mode wireless_mode)
+{
+	void *driver_adapter = NULL;
+	enum halmac_wireless_mode wireless_mode_local =
+		HALMAC_WIRELESS_MODE_UNDEFINE;
+
+	wireless_mode_local = wireless_mode;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_CFG_OPERATION_MODE);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+		"%s ==========>wireless_mode = %d\n", __func__,
+		wireless_mode);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_ch_bw_88xx() - config channel & bandwidth
+ * @halmac_adapter : the adapter of halmac
+ * @channel : WLAN channel, support 2.4G & 5G
+ * @pri_ch_idx : primary channel index, idx1, idx2, idx3, idx4
+ * @bw : band width, 20, 40, 80, 160, 5 ,10
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_ch_bw_88xx(struct halmac_adapter *halmac_adapter, u8 channel,
+		      enum halmac_pri_ch_idx pri_ch_idx, enum halmac_bw bw)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_CH_BW);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>ch = %d, idx=%d, bw=%d\n", __func__,
+			channel, pri_ch_idx, bw);
+
+	halmac_cfg_pri_ch_idx_88xx(halmac_adapter, pri_ch_idx);
+
+	halmac_cfg_bw_88xx(halmac_adapter, bw);
+
+	halmac_cfg_ch_88xx(halmac_adapter, channel);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status halmac_cfg_ch_88xx(struct halmac_adapter *halmac_adapter,
+					  u8 channel)
+{
+	u8 value8;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_CH_BW);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>ch = %d\n", __func__, channel);
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_CCK_CHECK);
+	value8 = value8 & (~(BIT(7)));
+
+	if (channel > 35)
+		value8 = value8 | BIT(7);
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_CCK_CHECK, value8);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_cfg_pri_ch_idx_88xx(struct halmac_adapter *halmac_adapter,
+			   enum halmac_pri_ch_idx pri_ch_idx)
+{
+	u8 txsc_40 = 0, txsc_20 = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_CH_BW);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========> idx=%d\n", __func__,
+			pri_ch_idx);
+
+	txsc_20 = pri_ch_idx;
+	if (txsc_20 == HALMAC_CH_IDX_1 || txsc_20 == HALMAC_CH_IDX_3)
+		txsc_40 = 9;
+	else
+		txsc_40 = 10;
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_DATA_SC,
+			   BIT_TXSC_20M(txsc_20) | BIT_TXSC_40M(txsc_40));
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_bw_88xx() - config bandwidth
+ * @halmac_adapter : the adapter of halmac
+ * @bw : band width, 20, 40, 80, 160, 5 ,10
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status halmac_cfg_bw_88xx(struct halmac_adapter *halmac_adapter,
+					  enum halmac_bw bw)
+{
+	u32 value32;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_BW);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>bw=%d\n", __func__, bw);
+
+	/* RF mode */
+	value32 = HALMAC_REG_READ_32(halmac_adapter, REG_WMAC_TRXPTCL_CTL);
+	value32 = value32 & (~(BIT(7) | BIT(8)));
+
+	switch (bw) {
+	case HALMAC_BW_80:
+		value32 = value32 | BIT(7);
+		break;
+	case HALMAC_BW_40:
+		value32 = value32 | BIT(8);
+		break;
+	case HALMAC_BW_20:
+	case HALMAC_BW_10:
+	case HALMAC_BW_5:
+		break;
+	default:
+		pr_err("%s switch case not support\n", __func__);
+		break;
+	}
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_WMAC_TRXPTCL_CTL, value32);
+
+	/* MAC CLK */
+	value32 = HALMAC_REG_READ_32(halmac_adapter, REG_AFE_CTRL1);
+	value32 = (value32 & (~(BIT(20) | BIT(21)))) |
+		  (HALMAC_MAC_CLOCK_HW_DEF_80M << BIT_SHIFT_MAC_CLK_SEL);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_AFE_CTRL1, value32);
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_USTIME_TSF,
+			   HALMAC_MAC_CLOCK_88XX);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_USTIME_EDCA,
+			   HALMAC_MAC_CLOCK_88XX);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_dump_efuse_map_88xx() - dump "physical" efuse map
+ * @halmac_adapter : the adapter of halmac
+ * @cfg : dump efuse method
+ * Author : Ivan Lin/KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_dump_efuse_map_88xx(struct halmac_adapter *halmac_adapter,
+			   enum halmac_efuse_read_cfg cfg)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	enum halmac_cmd_process_status *process_status =
+		&halmac_adapter->halmac_state.efuse_state_set.process_status;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_DUMP_EFUSE_MAP);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>cfg=%d\n", __func__, cfg);
+
+	if (*process_status == HALMAC_CMD_PROCESS_SENDING) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Wait event(dump efuse)...\n");
+		return HALMAC_RET_BUSY_STATE;
+	}
+
+	if (halmac_query_efuse_curr_state_88xx(halmac_adapter) !=
+	    HALMAC_EFUSE_CMD_CONSTRUCT_IDLE) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Not idle state(dump efuse)...\n");
+		return HALMAC_RET_ERROR_STATE;
+	}
+
+	if (halmac_adapter->halmac_state.mac_power == HALMAC_MAC_POWER_OFF)
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_WARNING,
+				"[WARN]Dump efuse in suspend mode\n");
+
+	*process_status = HALMAC_CMD_PROCESS_IDLE;
+	halmac_adapter->event_trigger.physical_efuse_map = 1;
+
+	status = halmac_func_switch_efuse_bank_88xx(halmac_adapter,
+						    HALMAC_EFUSE_BANK_WIFI);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_func_switch_efuse_bank error = %x\n", status);
+		return status;
+	}
+
+	status = halmac_dump_efuse_88xx(halmac_adapter, cfg);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_read_efuse error = %x\n", status);
+		return status;
+	}
+
+	if (halmac_adapter->hal_efuse_map_valid) {
+		*process_status = HALMAC_CMD_PROCESS_DONE;
+
+		PLATFORM_EVENT_INDICATION(
+			driver_adapter, HALMAC_FEATURE_DUMP_PHYSICAL_EFUSE,
+			*process_status, halmac_adapter->hal_efuse_map,
+			halmac_adapter->hw_config_info.efuse_size);
+		halmac_adapter->event_trigger.physical_efuse_map = 0;
+	}
+
+	if (halmac_transition_efuse_state_88xx(
+		    halmac_adapter, HALMAC_EFUSE_CMD_CONSTRUCT_IDLE) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_dump_efuse_map_bt_88xx() - dump "BT physical" efuse map
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_efuse_bank : bt efuse bank
+ * @bt_efuse_map_size : bt efuse map size. get from halmac_get_efuse_size API
+ * @bt_efuse_map : bt efuse map
+ * Author : Soar / Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_dump_efuse_map_bt_88xx(struct halmac_adapter *halmac_adapter,
+			      enum halmac_efuse_bank halmac_efuse_bank,
+			      u32 bt_efuse_map_size, u8 *bt_efuse_map)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	enum halmac_cmd_process_status *process_status =
+		&halmac_adapter->halmac_state.efuse_state_set.process_status;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_DUMP_EFUSE_MAP_BT);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (halmac_adapter->hw_config_info.bt_efuse_size != bt_efuse_map_size)
+		return HALMAC_RET_EFUSE_SIZE_INCORRECT;
+
+	if ((halmac_efuse_bank >= HALMAC_EFUSE_BANK_MAX) ||
+	    halmac_efuse_bank == HALMAC_EFUSE_BANK_WIFI) {
+		pr_err("Undefined BT bank\n");
+		return HALMAC_RET_EFUSE_BANK_INCORRECT;
+	}
+
+	if (*process_status == HALMAC_CMD_PROCESS_SENDING) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Wait event(dump efuse)...\n");
+		return HALMAC_RET_BUSY_STATE;
+	}
+
+	if (halmac_query_efuse_curr_state_88xx(halmac_adapter) !=
+	    HALMAC_EFUSE_CMD_CONSTRUCT_IDLE) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Not idle state(dump efuse)...\n");
+		return HALMAC_RET_ERROR_STATE;
+	}
+
+	status = halmac_func_switch_efuse_bank_88xx(halmac_adapter,
+						    halmac_efuse_bank);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_func_switch_efuse_bank error = %x\n", status);
+		return status;
+	}
+
+	status = halmac_read_hw_efuse_88xx(halmac_adapter, 0, bt_efuse_map_size,
+					   bt_efuse_map);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_read_hw_efuse_88xx error = %x\n", status);
+		return status;
+	}
+
+	if (halmac_transition_efuse_state_88xx(
+		    halmac_adapter, HALMAC_EFUSE_CMD_CONSTRUCT_IDLE) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_write_efuse_bt_88xx() - write "BT physical" efuse offset
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : offset
+ * @halmac_value : Write value
+ * @bt_efuse_map : bt efuse map
+ * Author : Soar
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_write_efuse_bt_88xx(struct halmac_adapter *halmac_adapter,
+			   u32 halmac_offset, u8 halmac_value,
+			   enum halmac_efuse_bank halmac_efuse_bank)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	enum halmac_cmd_process_status *process_status =
+		&halmac_adapter->halmac_state.efuse_state_set.process_status;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_WRITE_EFUSE_BT);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s ==========>\n", __func__);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"offset : %X value : %X Bank : %X\n", halmac_offset,
+			halmac_value, halmac_efuse_bank);
+
+	if (*process_status == HALMAC_CMD_PROCESS_SENDING) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Wait/Rcvd event(dump efuse)...\n");
+		return HALMAC_RET_BUSY_STATE;
+	}
+
+	if (halmac_query_efuse_curr_state_88xx(halmac_adapter) !=
+	    HALMAC_EFUSE_CMD_CONSTRUCT_IDLE) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Not idle state(dump efuse)...\n");
+		return HALMAC_RET_ERROR_STATE;
+	}
+
+	if (halmac_offset >= halmac_adapter->hw_config_info.efuse_size) {
+		pr_err("Offset is too large\n");
+		return HALMAC_RET_EFUSE_SIZE_INCORRECT;
+	}
+
+	if (halmac_efuse_bank > HALMAC_EFUSE_BANK_MAX ||
+	    halmac_efuse_bank == HALMAC_EFUSE_BANK_WIFI) {
+		pr_err("Undefined BT bank\n");
+		return HALMAC_RET_EFUSE_BANK_INCORRECT;
+	}
+
+	status = halmac_func_switch_efuse_bank_88xx(halmac_adapter,
+						    halmac_efuse_bank);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_func_switch_efuse_bank error = %x\n", status);
+		return status;
+	}
+
+	status = halmac_func_write_efuse_88xx(halmac_adapter, halmac_offset,
+					      halmac_value);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_func_write_efuse error = %x\n", status);
+		return status;
+	}
+
+	if (halmac_transition_efuse_state_88xx(
+		    halmac_adapter, HALMAC_EFUSE_CMD_CONSTRUCT_IDLE) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_get_efuse_available_size_88xx() - get efuse available size
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_size : physical efuse available size
+ * Author : Soar
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_get_efuse_available_size_88xx(struct halmac_adapter *halmac_adapter,
+				     u32 *halmac_size)
+{
+	enum halmac_ret_status status;
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	status = halmac_dump_logical_efuse_map_88xx(halmac_adapter,
+						    HALMAC_EFUSE_R_DRV);
+
+	if (status != HALMAC_RET_SUCCESS)
+		return status;
+
+	*halmac_size = halmac_adapter->hw_config_info.efuse_size -
+		       HALMAC_PROTECTED_EFUSE_SIZE_88XX -
+		       halmac_adapter->efuse_end;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_get_efuse_size_88xx() - get "physical" efuse size
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_size : physical efuse size
+ * Author : Ivan Lin/KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_get_efuse_size_88xx(struct halmac_adapter *halmac_adapter,
+			   u32 *halmac_size)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_GET_EFUSE_SIZE);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	*halmac_size = halmac_adapter->hw_config_info.efuse_size;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_get_logical_efuse_size_88xx() - get "logical" efuse size
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_size : logical efuse size
+ * Author : Ivan Lin/KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_get_logical_efuse_size_88xx(struct halmac_adapter *halmac_adapter,
+				   u32 *halmac_size)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_GET_LOGICAL_EFUSE_SIZE);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	*halmac_size = halmac_adapter->hw_config_info.eeprom_size;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_dump_logical_efuse_map_88xx() - dump "logical" efuse map
+ * @halmac_adapter : the adapter of halmac
+ * @cfg : dump efuse method
+ * Author : Soar
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_dump_logical_efuse_map_88xx(struct halmac_adapter *halmac_adapter,
+				   enum halmac_efuse_read_cfg cfg)
+{
+	u8 *eeprom_map = NULL;
+	u32 eeprom_size = halmac_adapter->hw_config_info.eeprom_size;
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	enum halmac_cmd_process_status *process_status =
+		&halmac_adapter->halmac_state.efuse_state_set.process_status;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_DUMP_LOGICAL_EFUSE_MAP);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s ==========>cfg = %d\n", __func__, cfg);
+
+	if (*process_status == HALMAC_CMD_PROCESS_SENDING) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Wait/Rcvd event(dump efuse)...\n");
+		return HALMAC_RET_BUSY_STATE;
+	}
+
+	if (halmac_query_efuse_curr_state_88xx(halmac_adapter) !=
+	    HALMAC_EFUSE_CMD_CONSTRUCT_IDLE) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Not idle state(dump efuse)...\n");
+		return HALMAC_RET_ERROR_STATE;
+	}
+
+	if (halmac_adapter->halmac_state.mac_power == HALMAC_MAC_POWER_OFF)
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_WARNING,
+				"[WARN]Dump logical efuse in suspend mode\n");
+
+	*process_status = HALMAC_CMD_PROCESS_IDLE;
+	halmac_adapter->event_trigger.logical_efuse_map = 1;
+
+	status = halmac_func_switch_efuse_bank_88xx(halmac_adapter,
+						    HALMAC_EFUSE_BANK_WIFI);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_func_switch_efuse_bank error = %x\n", status);
+		return status;
+	}
+
+	status = halmac_dump_efuse_88xx(halmac_adapter, cfg);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_eeprom_parser_88xx error = %x\n", status);
+		return status;
+	}
+
+	if (halmac_adapter->hal_efuse_map_valid) {
+		*process_status = HALMAC_CMD_PROCESS_DONE;
+
+		eeprom_map = kzalloc(eeprom_size, GFP_KERNEL);
+		if (!eeprom_map) {
+			/* out of memory */
+			return HALMAC_RET_MALLOC_FAIL;
+		}
+		memset(eeprom_map, 0xFF, eeprom_size);
+
+		if (halmac_eeprom_parser_88xx(halmac_adapter,
+					      halmac_adapter->hal_efuse_map,
+					      eeprom_map) != HALMAC_RET_SUCCESS)
+			return HALMAC_RET_EEPROM_PARSING_FAIL;
+
+		PLATFORM_EVENT_INDICATION(
+			driver_adapter, HALMAC_FEATURE_DUMP_LOGICAL_EFUSE,
+			*process_status, eeprom_map, eeprom_size);
+		halmac_adapter->event_trigger.logical_efuse_map = 0;
+
+		kfree(eeprom_map);
+	}
+
+	if (halmac_transition_efuse_state_88xx(
+		    halmac_adapter, HALMAC_EFUSE_CMD_CONSTRUCT_IDLE) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_read_logical_efuse_88xx() - read logical efuse map 1 byte
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : offset
+ * @value : 1 byte efuse value
+ * Author : Soar
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_read_logical_efuse_88xx(struct halmac_adapter *halmac_adapter,
+			       u32 halmac_offset, u8 *value)
+{
+	u8 *eeprom_map = NULL;
+	u32 eeprom_size = halmac_adapter->hw_config_info.eeprom_size;
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	enum halmac_cmd_process_status *process_status =
+		&halmac_adapter->halmac_state.efuse_state_set.process_status;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_READ_LOGICAL_EFUSE);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (halmac_offset >= eeprom_size) {
+		pr_err("Offset is too large\n");
+		return HALMAC_RET_EFUSE_SIZE_INCORRECT;
+	}
+
+	if (*process_status == HALMAC_CMD_PROCESS_SENDING) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Wait/Rcvd event(dump efuse)...\n");
+		return HALMAC_RET_BUSY_STATE;
+	}
+	if (halmac_query_efuse_curr_state_88xx(halmac_adapter) !=
+	    HALMAC_EFUSE_CMD_CONSTRUCT_IDLE) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Not idle state(dump efuse)...\n");
+		return HALMAC_RET_ERROR_STATE;
+	}
+
+	status = halmac_func_switch_efuse_bank_88xx(halmac_adapter,
+						    HALMAC_EFUSE_BANK_WIFI);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_func_switch_efuse_bank error = %x\n", status);
+		return status;
+	}
+
+	eeprom_map = kzalloc(eeprom_size, GFP_KERNEL);
+	if (!eeprom_map) {
+		/* out of memory */
+		return HALMAC_RET_MALLOC_FAIL;
+	}
+	memset(eeprom_map, 0xFF, eeprom_size);
+
+	status = halmac_read_logical_efuse_map_88xx(halmac_adapter, eeprom_map);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_read_logical_efuse_map error = %x\n", status);
+		kfree(eeprom_map);
+		return status;
+	}
+
+	*value = *(eeprom_map + halmac_offset);
+
+	if (halmac_transition_efuse_state_88xx(
+		    halmac_adapter, HALMAC_EFUSE_CMD_CONSTRUCT_IDLE) !=
+	    HALMAC_RET_SUCCESS) {
+		kfree(eeprom_map);
+		return HALMAC_RET_ERROR_STATE;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	kfree(eeprom_map);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_write_logical_efuse_88xx() - write "logical" efuse offset
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : offset
+ * @halmac_value : value
+ * Author : Soar
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_write_logical_efuse_88xx(struct halmac_adapter *halmac_adapter,
+				u32 halmac_offset, u8 halmac_value)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	enum halmac_cmd_process_status *process_status =
+		&halmac_adapter->halmac_state.efuse_state_set.process_status;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_WRITE_LOGICAL_EFUSE);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (halmac_offset >= halmac_adapter->hw_config_info.eeprom_size) {
+		pr_err("Offset is too large\n");
+		return HALMAC_RET_EFUSE_SIZE_INCORRECT;
+	}
+
+	if (*process_status == HALMAC_CMD_PROCESS_SENDING) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Wait/Rcvd event(dump efuse)...\n");
+		return HALMAC_RET_BUSY_STATE;
+	}
+
+	if (halmac_query_efuse_curr_state_88xx(halmac_adapter) !=
+	    HALMAC_EFUSE_CMD_CONSTRUCT_IDLE) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Not idle state(dump efuse)...\n");
+		return HALMAC_RET_ERROR_STATE;
+	}
+
+	status = halmac_func_switch_efuse_bank_88xx(halmac_adapter,
+						    HALMAC_EFUSE_BANK_WIFI);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_func_switch_efuse_bank error = %x\n", status);
+		return status;
+	}
+
+	status = halmac_func_write_logical_efuse_88xx(
+		halmac_adapter, halmac_offset, halmac_value);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_write_logical_efuse error = %x\n", status);
+		return status;
+	}
+
+	if (halmac_transition_efuse_state_88xx(
+		    halmac_adapter, HALMAC_EFUSE_CMD_CONSTRUCT_IDLE) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_pg_efuse_by_map_88xx() - pg logical efuse by map
+ * @halmac_adapter : the adapter of halmac
+ * @pg_efuse_info : efuse map information
+ * @cfg : dump efuse method
+ * Author : Soar
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_pg_efuse_by_map_88xx(struct halmac_adapter *halmac_adapter,
+			    struct halmac_pg_efuse_info *pg_efuse_info,
+			    enum halmac_efuse_read_cfg cfg)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	enum halmac_cmd_process_status *process_status =
+		&halmac_adapter->halmac_state.efuse_state_set.process_status;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_PG_EFUSE_BY_MAP);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (pg_efuse_info->efuse_map_size !=
+	    halmac_adapter->hw_config_info.eeprom_size) {
+		pr_err("efuse_map_size is incorrect, should be %d bytes\n",
+		       halmac_adapter->hw_config_info.eeprom_size);
+		return HALMAC_RET_EFUSE_SIZE_INCORRECT;
+	}
+
+	if ((pg_efuse_info->efuse_map_size & 0xF) > 0) {
+		pr_err("efuse_map_size should be multiple of 16\n");
+		return HALMAC_RET_EFUSE_SIZE_INCORRECT;
+	}
+
+	if (pg_efuse_info->efuse_mask_size !=
+	    pg_efuse_info->efuse_map_size >> 4) {
+		pr_err("efuse_mask_size is incorrect, should be %d bytes\n",
+		       pg_efuse_info->efuse_map_size >> 4);
+		return HALMAC_RET_EFUSE_SIZE_INCORRECT;
+	}
+
+	if (!pg_efuse_info->efuse_map) {
+		pr_err("efuse_map is NULL\n");
+		return HALMAC_RET_NULL_POINTER;
+	}
+
+	if (!pg_efuse_info->efuse_mask) {
+		pr_err("efuse_mask is NULL\n");
+		return HALMAC_RET_NULL_POINTER;
+	}
+
+	if (*process_status == HALMAC_CMD_PROCESS_SENDING) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Wait/Rcvd event(dump efuse)...\n");
+		return HALMAC_RET_BUSY_STATE;
+	}
+
+	if (halmac_query_efuse_curr_state_88xx(halmac_adapter) !=
+	    HALMAC_EFUSE_CMD_CONSTRUCT_IDLE) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Not idle state(dump efuse)...\n");
+		return HALMAC_RET_ERROR_STATE;
+	}
+
+	status = halmac_func_switch_efuse_bank_88xx(halmac_adapter,
+						    HALMAC_EFUSE_BANK_WIFI);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_func_switch_efuse_bank error = %x\n", status);
+		return status;
+	}
+
+	status = halmac_func_pg_efuse_by_map_88xx(halmac_adapter, pg_efuse_info,
+						  cfg);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_pg_efuse_by_map error = %x\n", status);
+		return status;
+	}
+
+	if (halmac_transition_efuse_state_88xx(
+		    halmac_adapter, HALMAC_EFUSE_CMD_CONSTRUCT_IDLE) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_EFUSE, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_get_c2h_info_88xx() - process halmac C2H packet
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_buf : RX Packet pointer
+ * @halmac_size : RX Packet size
+ * Author : KaiYuan Chang/Ivan Lin
+ *
+ * Used to process c2h packet info from RX path. After receiving the packet,
+ * user need to call this api and pass the packet pointer.
+ *
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_get_c2h_info_88xx(struct halmac_adapter *halmac_adapter, u8 *halmac_buf,
+			 u32 halmac_size)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_GET_C2H_INFO);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	/* Check if it is C2H packet */
+	if (GET_RX_DESC_C2H(halmac_buf)) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+				"C2H packet, start parsing!\n");
+
+		status = halmac_parse_c2h_packet_88xx(halmac_adapter,
+						      halmac_buf, halmac_size);
+
+		if (status != HALMAC_RET_SUCCESS) {
+			pr_err("halmac_parse_c2h_packet_88xx error = %x\n",
+			       status);
+			return status;
+		}
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_cfg_fwlps_option_88xx(struct halmac_adapter *halmac_adapter,
+			     struct halmac_fwlps_option *lps_option)
+{
+	void *driver_adapter = NULL;
+	struct halmac_fwlps_option *hal_fwlps_option;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_FWLPS_OPTION);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	hal_fwlps_option = &halmac_adapter->fwlps_option;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	hal_fwlps_option->mode = lps_option->mode;
+	hal_fwlps_option->clk_request = lps_option->clk_request;
+	hal_fwlps_option->rlbm = lps_option->rlbm;
+	hal_fwlps_option->smart_ps = lps_option->smart_ps;
+	hal_fwlps_option->awake_interval = lps_option->awake_interval;
+	hal_fwlps_option->all_queue_uapsd = lps_option->all_queue_uapsd;
+	hal_fwlps_option->pwr_state = lps_option->pwr_state;
+	hal_fwlps_option->low_pwr_rx_beacon = lps_option->low_pwr_rx_beacon;
+	hal_fwlps_option->ant_auto_switch = lps_option->ant_auto_switch;
+	hal_fwlps_option->ps_allow_bt_high_priority =
+		lps_option->ps_allow_bt_high_priority;
+	hal_fwlps_option->protect_bcn = lps_option->protect_bcn;
+	hal_fwlps_option->silence_period = lps_option->silence_period;
+	hal_fwlps_option->fast_bt_connect = lps_option->fast_bt_connect;
+	hal_fwlps_option->two_antenna_en = lps_option->two_antenna_en;
+	hal_fwlps_option->adopt_user_setting = lps_option->adopt_user_setting;
+	hal_fwlps_option->drv_bcn_early_shift = lps_option->drv_bcn_early_shift;
+	hal_fwlps_option->enter_32K = lps_option->enter_32K;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_cfg_fwips_option_88xx(struct halmac_adapter *halmac_adapter,
+			     struct halmac_fwips_option *ips_option)
+{
+	void *driver_adapter = NULL;
+	struct halmac_fwips_option *ips_option_local;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_FWIPS_OPTION);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	ips_option_local = ips_option;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_enter_wowlan_88xx(struct halmac_adapter *halmac_adapter,
+			 struct halmac_wowlan_option *wowlan_option)
+{
+	void *driver_adapter = NULL;
+	struct halmac_wowlan_option *wowlan_option_local;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_ENTER_WOWLAN);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	wowlan_option_local = wowlan_option;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_leave_wowlan_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_LEAVE_WOWLAN);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_enter_ps_88xx(struct halmac_adapter *halmac_adapter,
+		     enum halmac_ps_state ps_state)
+{
+	u8 rpwm;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_ENTER_PS);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (ps_state == halmac_adapter->halmac_state.ps_state) {
+		pr_err("power state is already in PS State!!\n");
+		return HALMAC_RET_SUCCESS;
+	}
+
+	if (ps_state == HALMAC_PS_STATE_LPS) {
+		status = halmac_send_h2c_set_pwr_mode_88xx(
+			halmac_adapter, &halmac_adapter->fwlps_option);
+		if (status != HALMAC_RET_SUCCESS) {
+			pr_err("halmac_send_h2c_set_pwr_mode_88xx error = %x!!\n",
+			       status);
+			return status;
+		}
+	} else if (ps_state == HALMAC_PS_STATE_IPS) {
+	}
+
+	halmac_adapter->halmac_state.ps_state = ps_state;
+
+	/* Enter 32K */
+	if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_SDIO) {
+		if (halmac_adapter->fwlps_option.enter_32K) {
+			rpwm = (u8)(((halmac_adapter->rpwm_record ^ (BIT(7))) |
+				     (BIT(0))) &
+				    0x81);
+			HALMAC_REG_WRITE_8(halmac_adapter, REG_SDIO_HRPWM1,
+					   rpwm);
+			halmac_adapter->low_clk = true;
+		}
+	} else if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_USB) {
+		if (halmac_adapter->fwlps_option.enter_32K) {
+			rpwm = (u8)(((halmac_adapter->rpwm_record ^ (BIT(7))) |
+				     (BIT(0))) &
+				    0x81);
+			HALMAC_REG_WRITE_8(halmac_adapter, 0xFE58, rpwm);
+			halmac_adapter->low_clk = true;
+		}
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_leave_ps_88xx(struct halmac_adapter *halmac_adapter)
+{
+	u8 rpwm, cpwm;
+	u32 counter;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	struct halmac_fwlps_option fw_lps_option;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_LEAVE_PS);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (halmac_adapter->halmac_state.ps_state == HALMAC_PS_STATE_ACT) {
+		pr_err("power state is already in active!!\n");
+		return HALMAC_RET_SUCCESS;
+	}
+
+	if (halmac_adapter->low_clk) {
+		cpwm = HALMAC_REG_READ_8(halmac_adapter, REG_SDIO_HRPWM1);
+		rpwm = (u8)(
+			((halmac_adapter->rpwm_record ^ (BIT(7))) | (BIT(6))) &
+			0xC0);
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_SDIO_HRPWM1, rpwm);
+
+		cpwm = (u8)((cpwm ^ BIT(7)) & BIT(7));
+		counter = 100;
+		while (cpwm !=
+		       (HALMAC_REG_READ_8(halmac_adapter, REG_SDIO_HRPWM1) &
+			BIT(7))) {
+			usleep_range(50, 60);
+			counter--;
+			if (counter == 0)
+				return HALMAC_RET_CHANGE_PS_FAIL;
+		}
+		halmac_adapter->low_clk = false;
+	}
+
+	memcpy(&fw_lps_option, &halmac_adapter->fwlps_option,
+	       sizeof(struct halmac_fwlps_option));
+	fw_lps_option.mode = 0;
+
+	status = halmac_send_h2c_set_pwr_mode_88xx(halmac_adapter,
+						   &fw_lps_option);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_h2c_set_pwr_mode_88xx error!!=%x\n",
+		       status);
+		return status;
+	}
+
+	halmac_adapter->halmac_state.ps_state = HALMAC_PS_STATE_ACT;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * (debug API)halmac_h2c_lb_88xx() - send h2c loopback packet
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status halmac_h2c_lb_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_H2C_LB);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_debug_88xx() - dump information for debugging
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status halmac_debug_88xx(struct halmac_adapter *halmac_adapter)
+{
+	u8 temp8 = 0;
+	u32 i = 0, temp32 = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_DEBUG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_SDIO) {
+		/* Dump CCCR, it needs new platform api */
+
+		/*Dump SDIO Local Register, use CMD52*/
+		for (i = 0x10250000; i < 0x102500ff; i++) {
+			temp8 = PLATFORM_SDIO_CMD52_READ(halmac_adapter, i);
+			HALMAC_RT_TRACE(
+				driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"halmac_debug: sdio[%x]=%x\n", i, temp8);
+		}
+
+		/*Dump MAC Register*/
+		for (i = 0x0000; i < 0x17ff; i++) {
+			temp8 = PLATFORM_SDIO_CMD52_READ(halmac_adapter, i);
+			HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT,
+					DBG_DMESG, "halmac_debug: mac[%x]=%x\n",
+					i, temp8);
+		}
+
+		/*Check RX Fifo status*/
+		i = REG_RXFF_PTR_V1;
+		temp8 = PLATFORM_SDIO_CMD52_READ(halmac_adapter, i);
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"halmac_debug: mac[%x]=%x\n", i, temp8);
+		i = REG_RXFF_WTR_V1;
+		temp8 = PLATFORM_SDIO_CMD52_READ(halmac_adapter, i);
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"halmac_debug: mac[%x]=%x\n", i, temp8);
+		i = REG_RXFF_PTR_V1;
+		temp8 = PLATFORM_SDIO_CMD52_READ(halmac_adapter, i);
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"halmac_debug: mac[%x]=%x\n", i, temp8);
+		i = REG_RXFF_WTR_V1;
+		temp8 = PLATFORM_SDIO_CMD52_READ(halmac_adapter, i);
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"halmac_debug: mac[%x]=%x\n", i, temp8);
+	} else {
+		/*Dump MAC Register*/
+		for (i = 0x0000; i < 0x17fc; i += 4) {
+			temp32 = HALMAC_REG_READ_32(halmac_adapter, i);
+			HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT,
+					DBG_DMESG, "halmac_debug: mac[%x]=%x\n",
+					i, temp32);
+		}
+
+		/*Check RX Fifo status*/
+		i = REG_RXFF_PTR_V1;
+		temp32 = HALMAC_REG_READ_32(halmac_adapter, i);
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"halmac_debug: mac[%x]=%x\n", i, temp32);
+		i = REG_RXFF_WTR_V1;
+		temp32 = HALMAC_REG_READ_32(halmac_adapter, i);
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"halmac_debug: mac[%x]=%x\n", i, temp32);
+		i = REG_RXFF_PTR_V1;
+		temp32 = HALMAC_REG_READ_32(halmac_adapter, i);
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"halmac_debug: mac[%x]=%x\n", i, temp32);
+		i = REG_RXFF_WTR_V1;
+		temp32 = HALMAC_REG_READ_32(halmac_adapter, i);
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"halmac_debug: mac[%x]=%x\n", i, temp32);
+	}
+
+	/*	TODO: Add check register code, including MAC CLK, CPU CLK */
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_parameter_88xx() - config parameter by FW
+ * @halmac_adapter : the adapter of halmac
+ * @para_info : cmd id, content
+ * @full_fifo : parameter information
+ *
+ * If msk_en = true, the format of array is {reg_info, mask, value}.
+ * If msk_en =_FAUSE, the format of array is {reg_info, value}
+ * The format of reg_info is
+ * reg_info[31]=rf_reg, 0: MAC_BB reg, 1: RF reg
+ * reg_info[27:24]=rf_path, 0: path_A, 1: path_B
+ * if rf_reg=0(MAC_BB reg), rf_path is meaningless.
+ * ref_info[15:0]=offset
+ *
+ * Example: msk_en = false
+ * {0x8100000a, 0x00001122}
+ * =>Set RF register, path_B, offset 0xA to 0x00001122
+ * {0x00000824, 0x11224433}
+ * =>Set MAC_BB register, offset 0x800 to 0x11224433
+ *
+ * Note : full fifo mode only for init flow
+ *
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_parameter_88xx(struct halmac_adapter *halmac_adapter,
+			  struct halmac_phy_parameter_info *para_info,
+			  u8 full_fifo)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status ret_status = HALMAC_RET_SUCCESS;
+	enum halmac_cmd_process_status *process_status =
+		&halmac_adapter->halmac_state.cfg_para_state_set.process_status;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	if (halmac_adapter->fw_version.h2c_version < 4)
+		return HALMAC_RET_FW_NO_SUPPORT;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_PARAMETER);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	if (halmac_adapter->halmac_state.dlfw_state == HALMAC_DLFW_NONE) {
+		pr_err("%s Fail due to DLFW NONE!!\n", __func__);
+		return HALMAC_RET_DLFW_FAIL;
+	}
+
+	if (*process_status == HALMAC_CMD_PROCESS_SENDING) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Wait event(cfg para)...\n");
+		return HALMAC_RET_BUSY_STATE;
+	}
+
+	if (halmac_query_cfg_para_curr_state_88xx(halmac_adapter) !=
+		    HALMAC_CFG_PARA_CMD_CONSTRUCT_IDLE &&
+	    halmac_query_cfg_para_curr_state_88xx(halmac_adapter) !=
+		    HALMAC_CFG_PARA_CMD_CONSTRUCT_CONSTRUCTING) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Not idle state(cfg para)...\n");
+		return HALMAC_RET_BUSY_STATE;
+	}
+
+	*process_status = HALMAC_CMD_PROCESS_IDLE;
+
+	ret_status = halmac_send_h2c_phy_parameter_88xx(halmac_adapter,
+							para_info, full_fifo);
+
+	if (ret_status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_h2c_phy_parameter_88xx Fail!! = %x\n",
+		       ret_status);
+		return ret_status;
+	}
+
+	return ret_status;
+}
+
+/**
+ * halmac_update_packet_88xx() - send specific packet to FW
+ * @halmac_adapter : the adapter of halmac
+ * @pkt_id : packet id, to know the purpose of this packet
+ * @pkt : packet
+ * @pkt_size : packet size
+ *
+ * Note : TX_DESC is not included in the pkt
+ *
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_update_packet_88xx(struct halmac_adapter *halmac_adapter,
+			  enum halmac_packet_id pkt_id, u8 *pkt, u32 pkt_size)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	enum halmac_cmd_process_status *process_status =
+		&halmac_adapter->halmac_state.update_packet_set.process_status;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	if (halmac_adapter->fw_version.h2c_version < 4)
+		return HALMAC_RET_FW_NO_SUPPORT;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_UPDATE_PACKET);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (*process_status == HALMAC_CMD_PROCESS_SENDING) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Wait event(update_packet)...\n");
+		return HALMAC_RET_BUSY_STATE;
+	}
+
+	*process_status = HALMAC_CMD_PROCESS_SENDING;
+
+	status = halmac_send_h2c_update_packet_88xx(halmac_adapter, pkt_id, pkt,
+						    pkt_size);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_h2c_update_packet_88xx packet = %x,  fail = %x!!\n",
+		       pkt_id, status);
+		return status;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_bcn_ie_filter_88xx(struct halmac_adapter *halmac_adapter,
+			  struct halmac_bcn_ie_info *bcn_ie_info)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	if (halmac_adapter->fw_version.h2c_version < 4)
+		return HALMAC_RET_FW_NO_SUPPORT;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_BCN_IE_FILTER);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	status = halmac_send_h2c_update_bcn_parse_info_88xx(halmac_adapter,
+							    bcn_ie_info);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_h2c_update_bcn_parse_info_88xx fail = %x\n",
+		       status);
+		return status;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_update_datapack_88xx(struct halmac_adapter *halmac_adapter,
+			    enum halmac_data_type halmac_data_type,
+			    struct halmac_phy_parameter_info *para_info)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	if (halmac_adapter->fw_version.h2c_version < 4)
+		return HALMAC_RET_FW_NO_SUPPORT;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"[TRACE]%s ==========>\n", __func__);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"[TRACE]%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_run_datapack_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_data_type halmac_data_type)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status ret_status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	if (halmac_adapter->fw_version.h2c_version < 4)
+		return HALMAC_RET_FW_NO_SUPPORT;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_RUN_DATAPACK);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	ret_status = halmac_send_h2c_run_datapack_88xx(halmac_adapter,
+						       halmac_data_type);
+
+	if (ret_status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_h2c_run_datapack_88xx Fail, datatype = %x, status = %x!!\n",
+		       halmac_data_type, ret_status);
+		return ret_status;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"halmac_update_datapack_88xx <==========\n");
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_drv_info_88xx() - config driver info
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_drv_info : driver information selection
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_drv_info_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_drv_info halmac_drv_info)
+{
+	u8 drv_info_size = 0;
+	u8 phy_status_en = 0;
+	u8 sniffer_en = 0;
+	u8 plcp_hdr_en = 0;
+	u32 value32;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_DRV_INFO);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"halmac_cfg_drv_info = %d\n", halmac_drv_info);
+
+	switch (halmac_drv_info) {
+	case HALMAC_DRV_INFO_NONE:
+		drv_info_size = 0;
+		phy_status_en = 0;
+		sniffer_en = 0;
+		plcp_hdr_en = 0;
+		break;
+	case HALMAC_DRV_INFO_PHY_STATUS:
+		drv_info_size = 4;
+		phy_status_en = 1;
+		sniffer_en = 0;
+		plcp_hdr_en = 0;
+		break;
+	case HALMAC_DRV_INFO_PHY_SNIFFER:
+		drv_info_size = 5; /* phy status 4byte, sniffer info 1byte */
+		phy_status_en = 1;
+		sniffer_en = 1;
+		plcp_hdr_en = 0;
+		break;
+	case HALMAC_DRV_INFO_PHY_PLCP:
+		drv_info_size = 6; /* phy status 4byte, plcp header 2byte */
+		phy_status_en = 1;
+		sniffer_en = 0;
+		plcp_hdr_en = 1;
+		break;
+	default:
+		status = HALMAC_RET_SW_CASE_NOT_SUPPORT;
+		pr_err("%s error = %x\n", __func__, status);
+		return status;
+	}
+
+	if (halmac_adapter->txff_allocation.rx_fifo_expanding_mode !=
+	    HALMAC_RX_FIFO_EXPANDING_MODE_DISABLE)
+		drv_info_size = 0xF;
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_RX_DRVINFO_SZ, drv_info_size);
+
+	halmac_adapter->drv_info_size = drv_info_size;
+
+	value32 = HALMAC_REG_READ_32(halmac_adapter, REG_RCR);
+	value32 = (value32 & (~BIT_APP_PHYSTS));
+	if (phy_status_en == 1)
+		value32 = value32 | BIT_APP_PHYSTS;
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_RCR, value32);
+
+	value32 = HALMAC_REG_READ_32(halmac_adapter,
+				     REG_WMAC_OPTION_FUNCTION + 4);
+	value32 = (value32 & (~(BIT(8) | BIT(9))));
+	if (sniffer_en == 1)
+		value32 = value32 | BIT(9);
+	if (plcp_hdr_en == 1)
+		value32 = value32 | BIT(8);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_WMAC_OPTION_FUNCTION + 4,
+			    value32);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_send_bt_coex_88xx(struct halmac_adapter *halmac_adapter, u8 *bt_buf,
+			 u32 bt_size, u8 ack)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status ret_status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_SEND_BT_COEX);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	ret_status = halmac_send_bt_coex_cmd_88xx(halmac_adapter, bt_buf,
+						  bt_size, ack);
+
+	if (ret_status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_bt_coex_cmd_88xx Fail = %x!!\n",
+		       ret_status);
+		return ret_status;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * (debug API)halmac_verify_platform_api_88xx() - verify platform api
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_verify_platform_api_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status ret_status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_VERIFY_PLATFORM_API);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	ret_status = halmac_verify_io_88xx(halmac_adapter);
+
+	if (ret_status != HALMAC_RET_SUCCESS)
+		return ret_status;
+
+	if (halmac_adapter->txff_allocation.la_mode != HALMAC_LA_MODE_FULL)
+		ret_status = halmac_verify_send_rsvd_page_88xx(halmac_adapter);
+
+	if (ret_status != HALMAC_RET_SUCCESS)
+		return ret_status;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return ret_status;
+}
+
+enum halmac_ret_status
+halmac_send_original_h2c_88xx(struct halmac_adapter *halmac_adapter,
+			      u8 *original_h2c, u16 *seq, u8 ack)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_SEND_ORIGINAL_H2C);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	status = halmac_func_send_original_h2c_88xx(halmac_adapter,
+						    original_h2c, seq, ack);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_original_h2c FAIL = %x!!\n", status);
+		return status;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_timer_2s_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_fill_txdesc_check_sum_88xx() -  fill in tx desc check sum
+ * @halmac_adapter : the adapter of halmac
+ * @cur_desc : tx desc packet
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_fill_txdesc_check_sum_88xx(struct halmac_adapter *halmac_adapter,
+				  u8 *cur_desc)
+{
+	u16 chk_result = 0;
+	u16 *data = (u16 *)NULL;
+	u32 i;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_FILL_TXDESC_CHECKSUM);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if (!cur_desc) {
+		pr_err("%s NULL PTR", __func__);
+		return HALMAC_RET_NULL_POINTER;
+	}
+
+	SET_TX_DESC_TXDESC_CHECKSUM(cur_desc, 0x0000);
+
+	data = (u16 *)(cur_desc);
+
+	/* HW clculates only 32byte */
+	for (i = 0; i < 8; i++)
+		chk_result ^= (*(data + 2 * i) ^ *(data + (2 * i + 1)));
+
+	SET_TX_DESC_TXDESC_CHECKSUM(cur_desc, chk_result);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_dump_fifo_88xx() - dump fifo data
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_fifo_sel : FIFO selection
+ * @halmac_start_addr : start address of selected FIFO
+ * @halmac_fifo_dump_size : dump size of selected FIFO
+ * @fifo_map : FIFO data
+ *
+ * Note : before dump fifo, user need to call halmac_get_fifo_size to
+ * get fifo size. Then input this size to halmac_dump_fifo.
+ *
+ * Author : Ivan Lin/KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_dump_fifo_88xx(struct halmac_adapter *halmac_adapter,
+		      enum hal_fifo_sel halmac_fifo_sel, u32 halmac_start_addr,
+		      u32 halmac_fifo_dump_size, u8 *fifo_map)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_DUMP_FIFO);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (halmac_fifo_sel == HAL_FIFO_SEL_TX &&
+	    (halmac_start_addr + halmac_fifo_dump_size) >
+		    halmac_adapter->hw_config_info.tx_fifo_size) {
+		pr_err("TX fifo dump size is too large\n");
+		return HALMAC_RET_DUMP_FIFOSIZE_INCORRECT;
+	}
+
+	if (halmac_fifo_sel == HAL_FIFO_SEL_RX &&
+	    (halmac_start_addr + halmac_fifo_dump_size) >
+		    halmac_adapter->hw_config_info.rx_fifo_size) {
+		pr_err("RX fifo dump size is too large\n");
+		return HALMAC_RET_DUMP_FIFOSIZE_INCORRECT;
+	}
+
+	if ((halmac_fifo_dump_size & (4 - 1)) != 0) {
+		pr_err("halmac_fifo_dump_size shall 4byte align\n");
+		return HALMAC_RET_DUMP_FIFOSIZE_INCORRECT;
+	}
+
+	if (!fifo_map) {
+		pr_err("fifo_map address is NULL\n");
+		return HALMAC_RET_NULL_POINTER;
+	}
+
+	status = halmac_buffer_read_88xx(halmac_adapter, halmac_start_addr,
+					 halmac_fifo_dump_size, halmac_fifo_sel,
+					 fifo_map);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_buffer_read_88xx error = %x\n", status);
+		return status;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_get_fifo_size_88xx() - get fifo size
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_fifo_sel : FIFO selection
+ * Author : Ivan Lin/KaiYuan Chang
+ * Return : u32
+ * More details of status code can be found in prototype document
+ */
+u32 halmac_get_fifo_size_88xx(struct halmac_adapter *halmac_adapter,
+			      enum hal_fifo_sel halmac_fifo_sel)
+{
+	u32 fifo_size = 0;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_GET_FIFO_SIZE);
+
+	if (halmac_fifo_sel == HAL_FIFO_SEL_TX)
+		fifo_size = halmac_adapter->hw_config_info.tx_fifo_size;
+	else if (halmac_fifo_sel == HAL_FIFO_SEL_RX)
+		fifo_size = halmac_adapter->hw_config_info.rx_fifo_size;
+	else if (halmac_fifo_sel == HAL_FIFO_SEL_RSVD_PAGE)
+		fifo_size =
+			((halmac_adapter->hw_config_info.tx_fifo_size >> 7) -
+			 halmac_adapter->txff_allocation.rsvd_pg_bndy)
+			<< 7;
+	else if (halmac_fifo_sel == HAL_FIFO_SEL_REPORT)
+		fifo_size = 65536;
+	else if (halmac_fifo_sel == HAL_FIFO_SEL_LLT)
+		fifo_size = 65536;
+
+	return fifo_size;
+}
+
+/**
+ * halmac_cfg_txbf_88xx() - enable/disable specific user's txbf
+ * @halmac_adapter : the adapter of halmac
+ * @userid : su bfee userid = 0 or 1 to apply TXBF
+ * @bw : the sounding bandwidth
+ * @txbf_en : 0: disable TXBF, 1: enable TXBF
+ * Author : chunchu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_txbf_88xx(struct halmac_adapter *halmac_adapter, u8 userid,
+		     enum halmac_bw bw, u8 txbf_en)
+{
+	u16 temp42C = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_TXBF);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if (txbf_en) {
+		switch (bw) {
+		case HALMAC_BW_80:
+			temp42C |= BIT_R_TXBF0_80M;
+		case HALMAC_BW_40:
+			temp42C |= BIT_R_TXBF0_40M;
+		case HALMAC_BW_20:
+			temp42C |= BIT_R_TXBF0_20M;
+			break;
+		default:
+			pr_err("%s invalid TXBF BW setting 0x%x of userid %d\n",
+			       __func__, bw, userid);
+			return HALMAC_RET_INVALID_SOUNDING_SETTING;
+		}
+	}
+
+	switch (userid) {
+	case 0:
+		temp42C |=
+			HALMAC_REG_READ_16(halmac_adapter, REG_TXBF_CTRL) &
+			~(BIT_R_TXBF0_20M | BIT_R_TXBF0_40M | BIT_R_TXBF0_80M);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_TXBF_CTRL, temp42C);
+		break;
+	case 1:
+		temp42C |=
+			HALMAC_REG_READ_16(halmac_adapter, REG_TXBF_CTRL + 2) &
+			~(BIT_R_TXBF0_20M | BIT_R_TXBF0_40M | BIT_R_TXBF0_80M);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_TXBF_CTRL + 2, temp42C);
+		break;
+	default:
+		pr_err("%s invalid userid %d\n", __func__, userid);
+		return HALMAC_RET_INVALID_SOUNDING_SETTING;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_SND, DBG_DMESG,
+			"%s, txbf_en = %x <==========\n", __func__,
+			txbf_en);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_mumimo_88xx() -config mumimo
+ * @halmac_adapter : the adapter of halmac
+ * @cfgmu : parameters to configure MU PPDU Tx/Rx
+ * Author : chunchu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_mumimo_88xx(struct halmac_adapter *halmac_adapter,
+		       struct halmac_cfg_mumimo_para *cfgmu)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	u8 i, idx, id0, id1, gid, mu_tab_sel;
+	u8 mu_tab_valid = 0;
+	u32 gid_valid[6] = {0};
+	u8 temp14C0 = 0;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_MUMIMO);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if (cfgmu->role == HAL_BFEE) {
+		/*config MU BFEE*/
+		temp14C0 = HALMAC_REG_READ_8(halmac_adapter, REG_MU_TX_CTL) &
+			   ~BIT_MASK_R_MU_TABLE_VALID;
+		/*enable MU table 0 and 1, disable MU TX*/
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_MU_TX_CTL,
+				   (temp14C0 | BIT(0) | BIT(1)) & ~(BIT(7)));
+
+		/*config GID valid table and user position table*/
+		mu_tab_sel =
+			HALMAC_REG_READ_8(halmac_adapter, REG_MU_TX_CTL + 1) &
+			~(BIT(0) | BIT(1) | BIT(2));
+		for (i = 0; i < 2; i++) {
+			HALMAC_REG_WRITE_8(halmac_adapter, REG_MU_TX_CTL + 1,
+					   mu_tab_sel | i);
+			HALMAC_REG_WRITE_32(halmac_adapter, REG_MU_STA_GID_VLD,
+					    cfgmu->given_gid_tab[i]);
+			HALMAC_REG_WRITE_32(halmac_adapter,
+					    REG_MU_STA_USER_POS_INFO,
+					    cfgmu->given_user_pos[i * 2]);
+			HALMAC_REG_WRITE_32(halmac_adapter,
+					    REG_MU_STA_USER_POS_INFO + 4,
+					    cfgmu->given_user_pos[i * 2 + 1]);
+		}
+	} else {
+		/*config MU BFER*/
+		if (!cfgmu->mu_tx_en) {
+			HALMAC_REG_WRITE_8(halmac_adapter, REG_MU_TX_CTL,
+					   HALMAC_REG_READ_8(halmac_adapter,
+							     REG_MU_TX_CTL) &
+						   ~(BIT(7)));
+			HALMAC_RT_TRACE(
+				driver_adapter, HALMAC_MSG_SND, DBG_DMESG,
+				"%s disable mu tx <==========\n", __func__);
+			return HALMAC_RET_SUCCESS;
+		}
+
+		/*Transform BB grouping bitmap[14:0] to MAC GID_valid table*/
+		for (idx = 0; idx < 15; idx++) {
+			if (idx < 5) {
+				/*group_bitmap bit0~4, MU_STA0 with MUSTA1~5*/
+				id0 = 0;
+				id1 = (u8)(idx + 1);
+			} else if (idx < 9) {
+				/*group_bitmap bit5~8, MU_STA1 with MUSTA2~5*/
+				id0 = 1;
+				id1 = (u8)(idx - 3);
+			} else if (idx < 12) {
+				/*group_bitmap bit9~11, MU_STA2 with MUSTA3~5*/
+				id0 = 2;
+				id1 = (u8)(idx - 6);
+			} else if (idx < 14) {
+				/*group_bitmap bit12~13, MU_STA3 with MUSTA4~5*/
+				id0 = 3;
+				id1 = (u8)(idx - 8);
+			} else {
+				/*group_bitmap bit14, MU_STA4 with MUSTA5*/
+				id0 = 4;
+				id1 = (u8)(idx - 9);
+			}
+			if (cfgmu->grouping_bitmap & BIT(idx)) {
+				/*Pair 1*/
+				gid = (idx << 1) + 1;
+				gid_valid[id0] |= (BIT(gid));
+				gid_valid[id1] |= (BIT(gid));
+				/*Pair 2*/
+				gid += 1;
+				gid_valid[id0] |= (BIT(gid));
+				gid_valid[id1] |= (BIT(gid));
+			} else {
+				/*Pair 1*/
+				gid = (idx << 1) + 1;
+				gid_valid[id0] &= ~(BIT(gid));
+				gid_valid[id1] &= ~(BIT(gid));
+				/*Pair 2*/
+				gid += 1;
+				gid_valid[id0] &= ~(BIT(gid));
+				gid_valid[id1] &= ~(BIT(gid));
+			}
+		}
+
+		/*set MU STA GID valid TABLE*/
+		mu_tab_sel =
+			HALMAC_REG_READ_8(halmac_adapter, REG_MU_TX_CTL + 1) &
+			~(BIT(0) | BIT(1) | BIT(2));
+		for (idx = 0; idx < 6; idx++) {
+			HALMAC_REG_WRITE_8(halmac_adapter, REG_MU_TX_CTL + 1,
+					   idx | mu_tab_sel);
+			HALMAC_REG_WRITE_32(halmac_adapter, REG_MU_STA_GID_VLD,
+					    gid_valid[idx]);
+		}
+
+		/*To validate the sounding successful MU STA and enable MU TX*/
+		for (i = 0; i < 6; i++) {
+			if (cfgmu->sounding_sts[i])
+				mu_tab_valid |= BIT(i);
+		}
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_MU_TX_CTL,
+				   mu_tab_valid | BIT(7));
+	}
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_SND, DBG_DMESG,
+			"%s <==========\n", __func__);
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_sounding_88xx() - configure general sounding
+ * @halmac_adapter : the adapter of halmac
+ * @role : driver's role, BFer or BFee
+ * @datarate : set ndpa tx rate if driver is BFer, or set csi response rate
+ *             if driver is BFee
+ * Author : chunchu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_sounding_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_snd_role role,
+			 enum halmac_data_rate datarate)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_SOUNDING);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	switch (role) {
+	case HAL_BFER:
+		HALMAC_REG_WRITE_32(
+			halmac_adapter, REG_TXBF_CTRL,
+			HALMAC_REG_READ_32(halmac_adapter, REG_TXBF_CTRL) |
+				BIT_R_ENABLE_NDPA | BIT_USE_NDPA_PARAMETER |
+				BIT_R_EN_NDPA_INT | BIT_DIS_NDP_BFEN);
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_NDPA_RATE, datarate);
+		HALMAC_REG_WRITE_8(
+			halmac_adapter, REG_NDPA_OPT_CTRL,
+			HALMAC_REG_READ_8(halmac_adapter, REG_NDPA_OPT_CTRL) &
+				(~(BIT(0) | BIT(1))));
+		/*service file length 2 bytes; fix non-STA1 csi start offset */
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_SND_PTCL_CTRL + 1,
+				   0x2 | BIT(7));
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_SND_PTCL_CTRL + 2, 0x2);
+		break;
+	case HAL_BFEE:
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_SND_PTCL_CTRL, 0xDB);
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_SND_PTCL_CTRL + 3, 0x50);
+		/*use ndpa rx rate to decide csi rate*/
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_BBPSF_CTRL + 3,
+				   HALMAC_OFDM54 | BIT(6));
+		HALMAC_REG_WRITE_16(
+			halmac_adapter, REG_RRSR,
+			HALMAC_REG_READ_16(halmac_adapter, REG_RRSR) |
+				BIT(datarate));
+		/*RXFF do not accept BF Rpt Poll, avoid CSI crc error*/
+		HALMAC_REG_WRITE_8(
+			halmac_adapter, REG_RXFLTMAP1,
+			HALMAC_REG_READ_8(halmac_adapter, REG_RXFLTMAP1) &
+				(~(BIT(4))));
+		/*FWFF do not accept BF Rpt Poll, avoid CSI crc error*/
+		HALMAC_REG_WRITE_8(
+			halmac_adapter, REG_RXFLTMAP4,
+			HALMAC_REG_READ_8(halmac_adapter, REG_RXFLTMAP4) &
+				(~(BIT(4))));
+		break;
+	default:
+		pr_err("%s invalid role\n", __func__);
+		return HALMAC_RET_INVALID_SOUNDING_SETTING;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_SND, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_del_sounding_88xx() - reset general sounding
+ * @halmac_adapter : the adapter of halmac
+ * @role : driver's role, BFer or BFee
+ * Author : chunchu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_del_sounding_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_snd_role role)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_DEL_SOUNDING);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	switch (role) {
+	case HAL_BFER:
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_TXBF_CTRL + 3, 0);
+		break;
+	case HAL_BFEE:
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_SND_PTCL_CTRL, 0);
+		break;
+	default:
+		pr_err("%s invalid role\n", __func__);
+		return HALMAC_RET_INVALID_SOUNDING_SETTING;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_SND, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_su_bfee_entry_init_88xx() - config SU beamformee's registers
+ * @halmac_adapter : the adapter of halmac
+ * @userid : SU bfee userid = 0 or 1 to be added
+ * @paid : partial AID of this bfee
+ * Author : chunchu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_su_bfee_entry_init_88xx(struct halmac_adapter *halmac_adapter, u8 userid,
+			       u16 paid)
+{
+	u16 temp42C = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_SU_BFEE_ENTRY_INIT);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	switch (userid) {
+	case 0:
+		temp42C = HALMAC_REG_READ_16(halmac_adapter, REG_TXBF_CTRL) &
+			  ~(BIT_MASK_R_TXBF0_AID | BIT_R_TXBF0_20M |
+			    BIT_R_TXBF0_40M | BIT_R_TXBF0_80M);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_TXBF_CTRL,
+				    temp42C | paid);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_ASSOCIATED_BFMEE_SEL,
+				    paid);
+		break;
+	case 1:
+		temp42C =
+			HALMAC_REG_READ_16(halmac_adapter, REG_TXBF_CTRL + 2) &
+			~(BIT_MASK_R_TXBF1_AID | BIT_R_TXBF0_20M |
+			  BIT_R_TXBF0_40M | BIT_R_TXBF0_80M);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_TXBF_CTRL + 2,
+				    temp42C | paid);
+		HALMAC_REG_WRITE_16(halmac_adapter,
+				    REG_ASSOCIATED_BFMEE_SEL + 2,
+				    paid | BIT(9));
+		break;
+	default:
+		pr_err("%s invalid userid %d\n", __func__,
+		       userid);
+		return HALMAC_RET_INVALID_SOUNDING_SETTING;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_SND, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_su_bfee_entry_init_88xx() - config SU beamformer's registers
+ * @halmac_adapter : the adapter of halmac
+ * @su_bfer_init : parameters to configure SU BFER entry
+ * Author : chunchu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_su_bfer_entry_init_88xx(struct halmac_adapter *halmac_adapter,
+			       struct halmac_su_bfer_init_para *su_bfer_init)
+{
+	u16 mac_address_H;
+	u32 mac_address_L;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_SU_BFER_ENTRY_INIT);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	/* mac_address_L = bfer_address.address_l_h.address_low; */
+	/* mac_address_H = bfer_address.address_l_h.address_high; */
+
+	mac_address_L = le32_to_cpu(
+		su_bfer_init->bfer_address.address_l_h.le_address_low);
+	mac_address_H = le16_to_cpu(
+		su_bfer_init->bfer_address.address_l_h.le_address_high);
+
+	switch (su_bfer_init->userid) {
+	case 0:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_ASSOCIATED_BFMER0_INFO,
+				    mac_address_L);
+		HALMAC_REG_WRITE_16(halmac_adapter,
+				    REG_ASSOCIATED_BFMER0_INFO + 4,
+				    mac_address_H);
+		HALMAC_REG_WRITE_16(halmac_adapter,
+				    REG_ASSOCIATED_BFMER0_INFO + 6,
+				    su_bfer_init->paid);
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_TX_CSI_RPT_PARAM_BW20,
+				    su_bfer_init->csi_para);
+		break;
+	case 1:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_ASSOCIATED_BFMER1_INFO,
+				    mac_address_L);
+		HALMAC_REG_WRITE_16(halmac_adapter,
+				    REG_ASSOCIATED_BFMER1_INFO + 4,
+				    mac_address_H);
+		HALMAC_REG_WRITE_16(halmac_adapter,
+				    REG_ASSOCIATED_BFMER1_INFO + 6,
+				    su_bfer_init->paid);
+		HALMAC_REG_WRITE_16(halmac_adapter,
+				    REG_TX_CSI_RPT_PARAM_BW20 + 2,
+				    su_bfer_init->csi_para);
+		break;
+	default:
+		pr_err("%s invalid userid %d\n", __func__,
+		       su_bfer_init->userid);
+		return HALMAC_RET_INVALID_SOUNDING_SETTING;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_SND, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_mu_bfee_entry_init_88xx() - config MU beamformee's registers
+ * @halmac_adapter : the adapter of halmac
+ * @mu_bfee_init : parameters to configure MU BFEE entry
+ * Author : chunchu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_mu_bfee_entry_init_88xx(struct halmac_adapter *halmac_adapter,
+			       struct halmac_mu_bfee_init_para *mu_bfee_init)
+{
+	u16 temp168X = 0, temp14C0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_MU_BFEE_ENTRY_INIT);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	temp168X |= mu_bfee_init->paid | BIT(9);
+	HALMAC_REG_WRITE_16(halmac_adapter, (0x1680 + mu_bfee_init->userid * 2),
+			    temp168X);
+
+	temp14C0 = HALMAC_REG_READ_16(halmac_adapter, REG_MU_TX_CTL) &
+		   ~(BIT(8) | BIT(9) | BIT(10));
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_MU_TX_CTL,
+			    temp14C0 | ((mu_bfee_init->userid - 2) << 8));
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_MU_STA_GID_VLD, 0);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_MU_STA_USER_POS_INFO,
+			    mu_bfee_init->user_position_l);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_MU_STA_USER_POS_INFO + 4,
+			    mu_bfee_init->user_position_h);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_SND, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_mu_bfer_entry_init_88xx() - config MU beamformer's registers
+ * @halmac_adapter : the adapter of halmac
+ * @mu_bfer_init : parameters to configure MU BFER entry
+ * Author : chunchu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_mu_bfer_entry_init_88xx(struct halmac_adapter *halmac_adapter,
+			       struct halmac_mu_bfer_init_para *mu_bfer_init)
+{
+	u16 temp1680 = 0;
+	u16 mac_address_H;
+	u32 mac_address_L;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_MU_BFER_ENTRY_INIT);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	mac_address_L =
+	    le32_to_cpu(mu_bfer_init->bfer_address.address_l_h.le_address_low);
+	mac_address_H =
+	    le16_to_cpu(mu_bfer_init->bfer_address.address_l_h.le_address_high);
+
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_ASSOCIATED_BFMER0_INFO,
+			    mac_address_L);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_ASSOCIATED_BFMER0_INFO + 4,
+			    mac_address_H);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_ASSOCIATED_BFMER0_INFO + 6,
+			    mu_bfer_init->paid);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_TX_CSI_RPT_PARAM_BW20,
+			    mu_bfer_init->csi_para);
+
+	temp1680 = HALMAC_REG_READ_16(halmac_adapter, 0x1680) & 0xC000;
+	temp1680 |= mu_bfer_init->my_aid | (mu_bfer_init->csi_length_sel << 12);
+	HALMAC_REG_WRITE_16(halmac_adapter, 0x1680, temp1680);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_SND, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_su_bfee_entry_del_88xx() - reset SU beamformee's registers
+ * @halmac_adapter : the adapter of halmac
+ * @userid : the SU BFee userid to be deleted
+ * Author : chunchu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_su_bfee_entry_del_88xx(struct halmac_adapter *halmac_adapter, u8 userid)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_SU_BFEE_ENTRY_DEL);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	switch (userid) {
+	case 0:
+		HALMAC_REG_WRITE_16(
+			halmac_adapter, REG_TXBF_CTRL,
+			HALMAC_REG_READ_16(halmac_adapter, REG_TXBF_CTRL) &
+				~(BIT_MASK_R_TXBF0_AID | BIT_R_TXBF0_20M |
+				  BIT_R_TXBF0_40M | BIT_R_TXBF0_80M));
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_ASSOCIATED_BFMEE_SEL,
+				    0);
+		break;
+	case 1:
+		HALMAC_REG_WRITE_16(
+			halmac_adapter, REG_TXBF_CTRL + 2,
+			HALMAC_REG_READ_16(halmac_adapter, REG_TXBF_CTRL + 2) &
+				~(BIT_MASK_R_TXBF1_AID | BIT_R_TXBF0_20M |
+				  BIT_R_TXBF0_40M | BIT_R_TXBF0_80M));
+		HALMAC_REG_WRITE_16(halmac_adapter,
+				    REG_ASSOCIATED_BFMEE_SEL + 2, 0);
+		break;
+	default:
+		pr_err("%s invalid userid %d\n", __func__,
+		       userid);
+		return HALMAC_RET_INVALID_SOUNDING_SETTING;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_SND, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_su_bfee_entry_del_88xx() - reset SU beamformer's registers
+ * @halmac_adapter : the adapter of halmac
+ * @userid : the SU BFer userid to be deleted
+ * Author : chunchu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_su_bfer_entry_del_88xx(struct halmac_adapter *halmac_adapter, u8 userid)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_SU_BFER_ENTRY_DEL);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	switch (userid) {
+	case 0:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_ASSOCIATED_BFMER0_INFO,
+				    0);
+		HALMAC_REG_WRITE_32(halmac_adapter,
+				    REG_ASSOCIATED_BFMER0_INFO + 4, 0);
+		break;
+	case 1:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_ASSOCIATED_BFMER1_INFO,
+				    0);
+		HALMAC_REG_WRITE_32(halmac_adapter,
+				    REG_ASSOCIATED_BFMER1_INFO + 4, 0);
+		break;
+	default:
+		pr_err("%s invalid userid %d\n", __func__,
+		       userid);
+		return HALMAC_RET_INVALID_SOUNDING_SETTING;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_SND, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_mu_bfee_entry_del_88xx() - reset MU beamformee's registers
+ * @halmac_adapter : the adapter of halmac
+ * @userid : the MU STA userid to be deleted
+ * Author : chunchu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_mu_bfee_entry_del_88xx(struct halmac_adapter *halmac_adapter, u8 userid)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_MU_BFEE_ENTRY_DEL);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_REG_WRITE_16(halmac_adapter, 0x1680 + userid * 2, 0);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_MU_TX_CTL,
+			   HALMAC_REG_READ_8(halmac_adapter, REG_MU_TX_CTL) &
+				   ~(BIT(userid - 2)));
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_SND, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_mu_bfer_entry_del_88xx() -reset MU beamformer's registers
+ * @halmac_adapter : the adapter of halmac
+ * Author : chunchu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_mu_bfer_entry_del_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_MU_BFER_ENTRY_DEL);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_ASSOCIATED_BFMER0_INFO, 0);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_ASSOCIATED_BFMER0_INFO + 4, 0);
+	HALMAC_REG_WRITE_16(halmac_adapter, 0x1680, 0);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_MU_TX_CTL, 0);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_SND, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_add_ch_info_88xx() -add channel information
+ * @halmac_adapter : the adapter of halmac
+ * @ch_info : channel information
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_add_ch_info_88xx(struct halmac_adapter *halmac_adapter,
+			struct halmac_ch_info *ch_info)
+{
+	void *driver_adapter = NULL;
+	struct halmac_cs_info *ch_sw_info;
+	enum halmac_scan_cmd_construct_state state_scan;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	ch_sw_info = &halmac_adapter->ch_sw_info;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"[TRACE]%s ==========>\n", __func__);
+
+	if (halmac_adapter->halmac_state.dlfw_state != HALMAC_GEN_INFO_SENT) {
+		pr_err("[ERR]%s: gen_info is not send to FW!!!!\n", __func__);
+		return HALMAC_RET_GEN_INFO_NOT_SENT;
+	}
+
+	state_scan = halmac_query_scan_curr_state_88xx(halmac_adapter);
+	if (state_scan != HALMAC_SCAN_CMD_CONSTRUCT_BUFFER_CLEARED &&
+	    state_scan != HALMAC_SCAN_CMD_CONSTRUCT_CONSTRUCTING) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_WARNING,
+				"[WARN]Scan machine fail(add ch info)...\n");
+		return HALMAC_RET_ERROR_STATE;
+	}
+
+	if (!ch_sw_info->ch_info_buf) {
+		ch_sw_info->ch_info_buf =
+			kzalloc(HALMAC_EXTRA_INFO_BUFF_SIZE_88XX, GFP_KERNEL);
+		if (!ch_sw_info->ch_info_buf)
+			return HALMAC_RET_NULL_POINTER;
+		ch_sw_info->ch_info_buf_w = ch_sw_info->ch_info_buf;
+		ch_sw_info->buf_size = HALMAC_EXTRA_INFO_BUFF_SIZE_88XX;
+		ch_sw_info->avai_buf_size = HALMAC_EXTRA_INFO_BUFF_SIZE_88XX;
+		ch_sw_info->total_size = 0;
+		ch_sw_info->extra_info_en = 0;
+		ch_sw_info->ch_num = 0;
+	}
+
+	if (ch_sw_info->extra_info_en == 1) {
+		pr_err("[ERR]%s: construct sequence wrong!!\n", __func__);
+		return HALMAC_RET_CH_SW_SEQ_WRONG;
+	}
+
+	if (ch_sw_info->avai_buf_size < 4) {
+		pr_err("[ERR]%s: no available buffer!!\n", __func__);
+		return HALMAC_RET_CH_SW_NO_BUF;
+	}
+
+	if (halmac_transition_scan_state_88xx(
+		    halmac_adapter, HALMAC_SCAN_CMD_CONSTRUCT_CONSTRUCTING) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	CHANNEL_INFO_SET_CHANNEL(ch_sw_info->ch_info_buf_w, ch_info->channel);
+	CHANNEL_INFO_SET_PRI_CH_IDX(ch_sw_info->ch_info_buf_w,
+				    ch_info->pri_ch_idx);
+	CHANNEL_INFO_SET_BANDWIDTH(ch_sw_info->ch_info_buf_w, ch_info->bw);
+	CHANNEL_INFO_SET_TIMEOUT(ch_sw_info->ch_info_buf_w, ch_info->timeout);
+	CHANNEL_INFO_SET_ACTION_ID(ch_sw_info->ch_info_buf_w,
+				   ch_info->action_id);
+	CHANNEL_INFO_SET_CH_EXTRA_INFO(ch_sw_info->ch_info_buf_w,
+				       ch_info->extra_info);
+
+	ch_sw_info->avai_buf_size = ch_sw_info->avai_buf_size - 4;
+	ch_sw_info->total_size = ch_sw_info->total_size + 4;
+	ch_sw_info->ch_num++;
+	ch_sw_info->extra_info_en = ch_info->extra_info;
+	ch_sw_info->ch_info_buf_w = ch_sw_info->ch_info_buf_w + 4;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"[TRACE]%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_add_extra_ch_info_88xx() -add extra channel information
+ * @halmac_adapter : the adapter of halmac
+ * @ch_extra_info : extra channel information
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_add_extra_ch_info_88xx(struct halmac_adapter *halmac_adapter,
+			      struct halmac_ch_extra_info *ch_extra_info)
+{
+	void *driver_adapter = NULL;
+	struct halmac_cs_info *ch_sw_info;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_ADD_EXTRA_CH_INFO);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	ch_sw_info = &halmac_adapter->ch_sw_info;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (!ch_sw_info->ch_info_buf) {
+		pr_err("%s: NULL==ch_sw_info->ch_info_buf!!\n", __func__);
+		return HALMAC_RET_CH_SW_SEQ_WRONG;
+	}
+
+	if (ch_sw_info->extra_info_en == 0) {
+		pr_err("%s: construct sequence wrong!!\n", __func__);
+		return HALMAC_RET_CH_SW_SEQ_WRONG;
+	}
+
+	if (ch_sw_info->avai_buf_size <
+	    (u32)(ch_extra_info->extra_info_size + 2)) {
+		/* +2: ch_extra_info_id, ch_extra_info, ch_extra_info_size
+		 * are totally 2Byte
+		 */
+		pr_err("%s: no available buffer!!\n", __func__);
+		return HALMAC_RET_CH_SW_NO_BUF;
+	}
+
+	if (halmac_query_scan_curr_state_88xx(halmac_adapter) !=
+	    HALMAC_SCAN_CMD_CONSTRUCT_CONSTRUCTING) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Scan machine fail(add extra ch info)...\n");
+		return HALMAC_RET_ERROR_STATE;
+	}
+
+	if (halmac_transition_scan_state_88xx(
+		    halmac_adapter, HALMAC_SCAN_CMD_CONSTRUCT_CONSTRUCTING) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	CH_EXTRA_INFO_SET_CH_EXTRA_INFO_ID(ch_sw_info->ch_info_buf_w,
+					   ch_extra_info->extra_action_id);
+	CH_EXTRA_INFO_SET_CH_EXTRA_INFO(ch_sw_info->ch_info_buf_w,
+					ch_extra_info->extra_info);
+	CH_EXTRA_INFO_SET_CH_EXTRA_INFO_SIZE(ch_sw_info->ch_info_buf_w,
+					     ch_extra_info->extra_info_size);
+	memcpy(ch_sw_info->ch_info_buf_w + 2, ch_extra_info->extra_info_data,
+	       ch_extra_info->extra_info_size);
+
+	ch_sw_info->avai_buf_size = ch_sw_info->avai_buf_size -
+				    (2 + ch_extra_info->extra_info_size);
+	ch_sw_info->total_size =
+		ch_sw_info->total_size + (2 + ch_extra_info->extra_info_size);
+	ch_sw_info->extra_info_en = ch_extra_info->extra_info;
+	ch_sw_info->ch_info_buf_w = ch_sw_info->ch_info_buf_w +
+				    (2 + ch_extra_info->extra_info_size);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_ctrl_ch_switch_88xx() -send channel switch cmd
+ * @halmac_adapter : the adapter of halmac
+ * @cs_option : channel switch config
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_ctrl_ch_switch_88xx(struct halmac_adapter *halmac_adapter,
+			   struct halmac_ch_switch_option *cs_option)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	enum halmac_scan_cmd_construct_state state_scan;
+	enum halmac_cmd_process_status *process_status =
+		&halmac_adapter->halmac_state.scan_state_set.process_status;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	if (halmac_adapter->fw_version.h2c_version < 4)
+		return HALMAC_RET_FW_NO_SUPPORT;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CTRL_CH_SWITCH);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s  cs_option->switch_en = %d==========>\n", __func__,
+			cs_option->switch_en);
+
+	if (!cs_option->switch_en)
+		*process_status = HALMAC_CMD_PROCESS_IDLE;
+
+	if (*process_status == HALMAC_CMD_PROCESS_SENDING ||
+	    *process_status == HALMAC_CMD_PROCESS_RCVD) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Wait event(ctrl ch switch)...\n");
+		return HALMAC_RET_BUSY_STATE;
+	}
+
+	state_scan = halmac_query_scan_curr_state_88xx(halmac_adapter);
+	if (cs_option->switch_en) {
+		if (state_scan != HALMAC_SCAN_CMD_CONSTRUCT_CONSTRUCTING) {
+			HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C,
+					DBG_DMESG,
+					"%s(on)  invalid in state %x\n",
+					__func__, state_scan);
+			return HALMAC_RET_ERROR_STATE;
+		}
+	} else {
+		if (state_scan != HALMAC_SCAN_CMD_CONSTRUCT_BUFFER_CLEARED) {
+			HALMAC_RT_TRACE(
+				driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+				"%s(off)  invalid in state %x\n", __func__,
+				state_scan);
+			return HALMAC_RET_ERROR_STATE;
+		}
+	}
+
+	status = halmac_func_ctrl_ch_switch_88xx(halmac_adapter, cs_option);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_ctrl_ch_switch FAIL = %x!!\n", status);
+		return status;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_clear_ch_info_88xx() -clear channel information
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_clear_ch_info_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CLEAR_CH_INFO);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (halmac_query_scan_curr_state_88xx(halmac_adapter) ==
+	    HALMAC_SCAN_CMD_CONSTRUCT_H2C_SENT) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Scan machine fail(clear ch info)...\n");
+		return HALMAC_RET_ERROR_STATE;
+	}
+
+	if (halmac_transition_scan_state_88xx(
+		    halmac_adapter, HALMAC_SCAN_CMD_CONSTRUCT_BUFFER_CLEARED) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	kfree(halmac_adapter->ch_sw_info.ch_info_buf);
+	halmac_adapter->ch_sw_info.ch_info_buf = NULL;
+	halmac_adapter->ch_sw_info.ch_info_buf_w = NULL;
+	halmac_adapter->ch_sw_info.extra_info_en = 0;
+	halmac_adapter->ch_sw_info.buf_size = 0;
+	halmac_adapter->ch_sw_info.avai_buf_size = 0;
+	halmac_adapter->ch_sw_info.total_size = 0;
+	halmac_adapter->ch_sw_info.ch_num = 0;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status halmac_p2pps_88xx(struct halmac_adapter *halmac_adapter,
+					 struct halmac_p2pps *p2p_ps)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	if (halmac_adapter->fw_version.h2c_version < 6)
+		return HALMAC_RET_FW_NO_SUPPORT;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	status = halmac_func_p2pps_88xx(halmac_adapter, p2p_ps);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("[ERR]halmac_p2pps FAIL = %x!!\n", status);
+		return status;
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_func_p2pps_88xx(struct halmac_adapter *halmac_adapter,
+		       struct halmac_p2pps *p2p_ps)
+{
+	u8 h2c_buff[HALMAC_H2C_CMD_SIZE_88XX] = {0};
+	u16 h2c_seq_mum = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	struct halmac_h2c_header_info h2c_header_info;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"[TRACE]halmac_p2pps !!\n");
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	P2PPS_SET_OFFLOAD_EN(h2c_buff, p2p_ps->offload_en);
+	P2PPS_SET_ROLE(h2c_buff, p2p_ps->role);
+	P2PPS_SET_CTWINDOW_EN(h2c_buff, p2p_ps->ctwindow_en);
+	P2PPS_SET_NOA_EN(h2c_buff, p2p_ps->noa_en);
+	P2PPS_SET_NOA_SEL(h2c_buff, p2p_ps->noa_sel);
+	P2PPS_SET_ALLSTASLEEP(h2c_buff, p2p_ps->all_sta_sleep);
+	P2PPS_SET_DISCOVERY(h2c_buff, p2p_ps->discovery);
+	P2PPS_SET_P2P_PORT_ID(h2c_buff, p2p_ps->p2p_port_id);
+	P2PPS_SET_P2P_GROUP(h2c_buff, p2p_ps->p2p_group);
+	P2PPS_SET_P2P_MACID(h2c_buff, p2p_ps->p2p_macid);
+
+	P2PPS_SET_CTWINDOW_LENGTH(h2c_buff, p2p_ps->ctwindow_length);
+
+	P2PPS_SET_NOA_DURATION_PARA(h2c_buff, p2p_ps->noa_duration_para);
+	P2PPS_SET_NOA_INTERVAL_PARA(h2c_buff, p2p_ps->noa_interval_para);
+	P2PPS_SET_NOA_START_TIME_PARA(h2c_buff, p2p_ps->noa_start_time_para);
+	P2PPS_SET_NOA_COUNT_PARA(h2c_buff, p2p_ps->noa_count_para);
+
+	h2c_header_info.sub_cmd_id = SUB_CMD_ID_P2PPS;
+	h2c_header_info.content_size = 24;
+	h2c_header_info.ack = false;
+	halmac_set_fw_offload_h2c_header_88xx(halmac_adapter, h2c_buff,
+					      &h2c_header_info, &h2c_seq_mum);
+
+	status = halmac_send_h2c_pkt_88xx(halmac_adapter, h2c_buff,
+					  HALMAC_H2C_CMD_SIZE_88XX, false);
+
+	if (status != HALMAC_RET_SUCCESS)
+		pr_err("[ERR]halmac_send_h2c_p2pps_88xx Fail = %x!!\n", status);
+
+	return status;
+}
+
+/**
+ * halmac_send_general_info_88xx() -send general information to FW
+ * @halmac_adapter : the adapter of halmac
+ * @general_info : general information
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_send_general_info_88xx(struct halmac_adapter *halmac_adapter,
+			      struct halmac_general_info *general_info)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	if (halmac_adapter->fw_version.h2c_version < 4)
+		return HALMAC_RET_FW_NO_SUPPORT;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_SEND_GENERAL_INFO);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (halmac_adapter->halmac_state.dlfw_state == HALMAC_DLFW_NONE) {
+		pr_err("%s Fail due to DLFW NONE!!\n", __func__);
+		return HALMAC_RET_DLFW_FAIL;
+	}
+
+	status = halmac_func_send_general_info_88xx(halmac_adapter,
+						    general_info);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_general_info error = %x\n", status);
+		return status;
+	}
+
+	if (halmac_adapter->halmac_state.dlfw_state == HALMAC_DLFW_DONE)
+		halmac_adapter->halmac_state.dlfw_state = HALMAC_GEN_INFO_SENT;
+
+	halmac_adapter->gen_info_valid = true;
+	memcpy(&halmac_adapter->general_info, general_info,
+	       sizeof(struct halmac_general_info));
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_start_iqk_88xx() -trigger FW IQK
+ * @halmac_adapter : the adapter of halmac
+ * @iqk_para : IQK parameter
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_start_iqk_88xx(struct halmac_adapter *halmac_adapter,
+		      struct halmac_iqk_para_ *iqk_para)
+{
+	u8 h2c_buff[HALMAC_H2C_CMD_SIZE_88XX] = {0};
+	u16 h2c_seq_num = 0;
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	struct halmac_h2c_header_info h2c_header_info;
+	enum halmac_cmd_process_status *process_status =
+		&halmac_adapter->halmac_state.iqk_set.process_status;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_START_IQK);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (*process_status == HALMAC_CMD_PROCESS_SENDING) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Wait event(iqk)...\n");
+		return HALMAC_RET_BUSY_STATE;
+	}
+
+	*process_status = HALMAC_CMD_PROCESS_SENDING;
+
+	IQK_SET_CLEAR(h2c_buff, iqk_para->clear);
+	IQK_SET_SEGMENT_IQK(h2c_buff, iqk_para->segment_iqk);
+
+	h2c_header_info.sub_cmd_id = SUB_CMD_ID_IQK;
+	h2c_header_info.content_size = 1;
+	h2c_header_info.ack = true;
+	halmac_set_fw_offload_h2c_header_88xx(halmac_adapter, h2c_buff,
+					      &h2c_header_info, &h2c_seq_num);
+
+	halmac_adapter->halmac_state.iqk_set.seq_num = h2c_seq_num;
+
+	status = halmac_send_h2c_pkt_88xx(halmac_adapter, h2c_buff,
+					  HALMAC_H2C_CMD_SIZE_88XX, true);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_h2c_pkt_88xx Fail = %x!!\n", status);
+		return status;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_ctrl_pwr_tracking_88xx() -trigger FW power tracking
+ * @halmac_adapter : the adapter of halmac
+ * @pwr_tracking_opt : power tracking option
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status halmac_ctrl_pwr_tracking_88xx(
+	struct halmac_adapter *halmac_adapter,
+	struct halmac_pwr_tracking_option *pwr_tracking_opt)
+{
+	u8 h2c_buff[HALMAC_H2C_CMD_SIZE_88XX] = {0};
+	u16 h2c_seq_mum = 0;
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	struct halmac_h2c_header_info h2c_header_info;
+	enum halmac_cmd_process_status *process_status =
+		&halmac_adapter->halmac_state.power_tracking_set.process_status;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CTRL_PWR_TRACKING);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"halmac_start_iqk_88xx ==========>\n");
+
+	if (*process_status == HALMAC_CMD_PROCESS_SENDING) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Wait event(pwr tracking)...\n");
+		return HALMAC_RET_BUSY_STATE;
+	}
+
+	*process_status = HALMAC_CMD_PROCESS_SENDING;
+
+	POWER_TRACKING_SET_TYPE(h2c_buff, pwr_tracking_opt->type);
+	POWER_TRACKING_SET_BBSWING_INDEX(h2c_buff,
+					 pwr_tracking_opt->bbswing_index);
+	POWER_TRACKING_SET_ENABLE_A(
+		h2c_buff,
+		pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_A].enable);
+	POWER_TRACKING_SET_TX_PWR_INDEX_A(
+		h2c_buff, pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_A]
+				  .tx_pwr_index);
+	POWER_TRACKING_SET_PWR_TRACKING_OFFSET_VALUE_A(
+		h2c_buff, pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_A]
+				  .pwr_tracking_offset_value);
+	POWER_TRACKING_SET_TSSI_VALUE_A(
+		h2c_buff, pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_A]
+				  .tssi_value);
+	POWER_TRACKING_SET_ENABLE_B(
+		h2c_buff,
+		pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_B].enable);
+	POWER_TRACKING_SET_TX_PWR_INDEX_B(
+		h2c_buff, pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_B]
+				  .tx_pwr_index);
+	POWER_TRACKING_SET_PWR_TRACKING_OFFSET_VALUE_B(
+		h2c_buff, pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_B]
+				  .pwr_tracking_offset_value);
+	POWER_TRACKING_SET_TSSI_VALUE_B(
+		h2c_buff, pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_B]
+				  .tssi_value);
+	POWER_TRACKING_SET_ENABLE_C(
+		h2c_buff,
+		pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_C].enable);
+	POWER_TRACKING_SET_TX_PWR_INDEX_C(
+		h2c_buff, pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_C]
+				  .tx_pwr_index);
+	POWER_TRACKING_SET_PWR_TRACKING_OFFSET_VALUE_C(
+		h2c_buff, pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_C]
+				  .pwr_tracking_offset_value);
+	POWER_TRACKING_SET_TSSI_VALUE_C(
+		h2c_buff, pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_C]
+				  .tssi_value);
+	POWER_TRACKING_SET_ENABLE_D(
+		h2c_buff,
+		pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_D].enable);
+	POWER_TRACKING_SET_TX_PWR_INDEX_D(
+		h2c_buff, pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_D]
+				  .tx_pwr_index);
+	POWER_TRACKING_SET_PWR_TRACKING_OFFSET_VALUE_D(
+		h2c_buff, pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_D]
+				  .pwr_tracking_offset_value);
+	POWER_TRACKING_SET_TSSI_VALUE_D(
+		h2c_buff, pwr_tracking_opt->pwr_tracking_para[HALMAC_RF_PATH_D]
+				  .tssi_value);
+
+	h2c_header_info.sub_cmd_id = SUB_CMD_ID_POWER_TRACKING;
+	h2c_header_info.content_size = 20;
+	h2c_header_info.ack = true;
+	halmac_set_fw_offload_h2c_header_88xx(halmac_adapter, h2c_buff,
+					      &h2c_header_info, &h2c_seq_mum);
+
+	halmac_adapter->halmac_state.power_tracking_set.seq_num = h2c_seq_mum;
+
+	status = halmac_send_h2c_pkt_88xx(halmac_adapter, h2c_buff,
+					  HALMAC_H2C_CMD_SIZE_88XX, true);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_h2c_pkt_88xx Fail = %x!!\n", status);
+		return status;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"halmac_start_iqk_88xx <==========\n");
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_query_status_88xx() -query the offload feature status
+ * @halmac_adapter : the adapter of halmac
+ * @feature_id : feature_id
+ * @process_status : feature_status
+ * @data : data buffer
+ * @size : data size
+ *
+ * Note :
+ * If user wants to know the data size, use can allocate zero
+ * size buffer first. If this size less than the data size, halmac
+ * will return  HALMAC_RET_BUFFER_TOO_SMALL. User need to
+ * re-allocate data buffer with correct data size.
+ *
+ * Author : Ivan Lin/KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_query_status_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_feature_id feature_id,
+			 enum halmac_cmd_process_status *process_status,
+			 u8 *data, u32 *size)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_QUERY_STATE);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	if (!process_status) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+				"null pointer!!\n");
+		return HALMAC_RET_NULL_POINTER;
+	}
+
+	switch (feature_id) {
+	case HALMAC_FEATURE_CFG_PARA:
+		status = halmac_query_cfg_para_status_88xx(
+			halmac_adapter, process_status, data, size);
+		break;
+	case HALMAC_FEATURE_DUMP_PHYSICAL_EFUSE:
+		status = halmac_query_dump_physical_efuse_status_88xx(
+			halmac_adapter, process_status, data, size);
+		break;
+	case HALMAC_FEATURE_DUMP_LOGICAL_EFUSE:
+		status = halmac_query_dump_logical_efuse_status_88xx(
+			halmac_adapter, process_status, data, size);
+		break;
+	case HALMAC_FEATURE_CHANNEL_SWITCH:
+		status = halmac_query_channel_switch_status_88xx(
+			halmac_adapter, process_status, data, size);
+		break;
+	case HALMAC_FEATURE_UPDATE_PACKET:
+		status = halmac_query_update_packet_status_88xx(
+			halmac_adapter, process_status, data, size);
+		break;
+	case HALMAC_FEATURE_IQK:
+		status = halmac_query_iqk_status_88xx(
+			halmac_adapter, process_status, data, size);
+		break;
+	case HALMAC_FEATURE_POWER_TRACKING:
+		status = halmac_query_power_tracking_status_88xx(
+			halmac_adapter, process_status, data, size);
+		break;
+	case HALMAC_FEATURE_PSD:
+		status = halmac_query_psd_status_88xx(
+			halmac_adapter, process_status, data, size);
+		break;
+	default:
+		pr_err("%s invalid feature id %d\n", __func__,
+		       feature_id);
+		return HALMAC_RET_INVALID_FEATURE_ID;
+	}
+
+	return status;
+}
+
+/**
+ * halmac_reset_feature_88xx() -reset async api cmd status
+ * @halmac_adapter : the adapter of halmac
+ * @feature_id : feature_id
+ * Author : Ivan Lin/KaiYuan Chang
+ * Return : enum halmac_ret_status.
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_reset_feature_88xx(struct halmac_adapter *halmac_adapter,
+			  enum halmac_feature_id feature_id)
+{
+	void *driver_adapter = NULL;
+	struct halmac_state *state = &halmac_adapter->halmac_state;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_RESET_FEATURE);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	switch (feature_id) {
+	case HALMAC_FEATURE_CFG_PARA:
+		state->cfg_para_state_set.process_status =
+			HALMAC_CMD_PROCESS_IDLE;
+		state->cfg_para_state_set.cfg_para_cmd_construct_state =
+			HALMAC_CFG_PARA_CMD_CONSTRUCT_IDLE;
+		break;
+	case HALMAC_FEATURE_DUMP_PHYSICAL_EFUSE:
+	case HALMAC_FEATURE_DUMP_LOGICAL_EFUSE:
+		state->efuse_state_set.process_status = HALMAC_CMD_PROCESS_IDLE;
+		state->efuse_state_set.efuse_cmd_construct_state =
+			HALMAC_EFUSE_CMD_CONSTRUCT_IDLE;
+		break;
+	case HALMAC_FEATURE_CHANNEL_SWITCH:
+		state->scan_state_set.process_status = HALMAC_CMD_PROCESS_IDLE;
+		state->scan_state_set.scan_cmd_construct_state =
+			HALMAC_SCAN_CMD_CONSTRUCT_IDLE;
+		break;
+	case HALMAC_FEATURE_UPDATE_PACKET:
+		state->update_packet_set.process_status =
+			HALMAC_CMD_PROCESS_IDLE;
+		break;
+	case HALMAC_FEATURE_ALL:
+		state->cfg_para_state_set.process_status =
+			HALMAC_CMD_PROCESS_IDLE;
+		state->cfg_para_state_set.cfg_para_cmd_construct_state =
+			HALMAC_CFG_PARA_CMD_CONSTRUCT_IDLE;
+		state->efuse_state_set.process_status = HALMAC_CMD_PROCESS_IDLE;
+		state->efuse_state_set.efuse_cmd_construct_state =
+			HALMAC_EFUSE_CMD_CONSTRUCT_IDLE;
+		state->scan_state_set.process_status = HALMAC_CMD_PROCESS_IDLE;
+		state->scan_state_set.scan_cmd_construct_state =
+			HALMAC_SCAN_CMD_CONSTRUCT_IDLE;
+		state->update_packet_set.process_status =
+			HALMAC_CMD_PROCESS_IDLE;
+		break;
+	default:
+		pr_err("%s invalid feature id %d\n", __func__,
+		       feature_id);
+		return HALMAC_RET_INVALID_FEATURE_ID;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_check_fw_status_88xx() -check fw status
+ * @halmac_adapter : the adapter of halmac
+ * @fw_status : fw status
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_check_fw_status_88xx(struct halmac_adapter *halmac_adapter,
+			    bool *fw_status)
+{
+	u32 value32 = 0, value32_backup = 0, i = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CHECK_FW_STATUS);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	value32 = PLATFORM_REG_READ_32(driver_adapter, REG_FW_DBG6);
+
+	if (value32 != 0) {
+		pr_err("halmac_check_fw_status REG_FW_DBG6 !=0\n");
+		*fw_status = false;
+		return status;
+	}
+
+	value32_backup = PLATFORM_REG_READ_32(driver_adapter, REG_FW_DBG7);
+
+	for (i = 0; i <= 10; i++) {
+		value32 = PLATFORM_REG_READ_32(driver_adapter, REG_FW_DBG7);
+		if (value32_backup != value32)
+			break;
+
+		if (i == 10) {
+			pr_err("halmac_check_fw_status Polling FW PC fail\n");
+			*fw_status = false;
+			return status;
+		}
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return status;
+}
+
+enum halmac_ret_status
+halmac_dump_fw_dmem_88xx(struct halmac_adapter *halmac_adapter, u8 *dmem,
+			 u32 *size)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_DUMP_FW_DMEM);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return status;
+}
+
+/**
+ * halmac_cfg_max_dl_size_88xx() - config max download FW size
+ * @halmac_adapter : the adapter of halmac
+ * @size : max download fw size
+ *
+ * Halmac uses this setting to set max packet size for
+ * download FW.
+ * If user has not called this API, halmac use default
+ * setting for download FW
+ * Note1 : size need multiple of 2
+ * Note2 : max size is 31K
+ *
+ * Author : Ivan Lin/KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_max_dl_size_88xx(struct halmac_adapter *halmac_adapter, u32 size)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_MAX_DL_SIZE);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_FW, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (size > HALMAC_FW_CFG_MAX_DL_SIZE_MAX_88XX) {
+		pr_err("size > HALMAC_FW_CFG_MAX_DL_SIZE_MAX!\n");
+		return HALMAC_RET_CFG_DLFW_SIZE_FAIL;
+	}
+
+	if ((size & (2 - 1)) != 0) {
+		pr_err("size is not power of 2!\n");
+		return HALMAC_RET_CFG_DLFW_SIZE_FAIL;
+	}
+
+	halmac_adapter->max_download_size = size;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_FW, DBG_DMESG,
+			"Cfg max size is : %X\n", size);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_FW, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_psd_88xx() - trigger fw psd
+ * @halmac_adapter : the adapter of halmac
+ * @start_psd : start PSD
+ * @end_psd : end PSD
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status halmac_psd_88xx(struct halmac_adapter *halmac_adapter,
+				       u16 start_psd, u16 end_psd)
+{
+	u8 h2c_buff[HALMAC_H2C_CMD_SIZE_88XX] = {0};
+	u16 h2c_seq_mum = 0;
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	struct halmac_h2c_header_info h2c_header_info;
+	enum halmac_cmd_process_status *process_status =
+		&halmac_adapter->halmac_state.psd_set.process_status;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	if (halmac_fw_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_NO_DLFW;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_PSD);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (*process_status == HALMAC_CMD_PROCESS_SENDING) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Wait event(psd)...\n");
+		return HALMAC_RET_BUSY_STATE;
+	}
+
+	kfree(halmac_adapter->halmac_state.psd_set.data);
+	halmac_adapter->halmac_state.psd_set.data = (u8 *)NULL;
+
+	halmac_adapter->halmac_state.psd_set.data_size = 0;
+	halmac_adapter->halmac_state.psd_set.segment_size = 0;
+
+	*process_status = HALMAC_CMD_PROCESS_SENDING;
+
+	PSD_SET_START_PSD(h2c_buff, start_psd);
+	PSD_SET_END_PSD(h2c_buff, end_psd);
+
+	h2c_header_info.sub_cmd_id = SUB_CMD_ID_PSD;
+	h2c_header_info.content_size = 4;
+	h2c_header_info.ack = true;
+	halmac_set_fw_offload_h2c_header_88xx(halmac_adapter, h2c_buff,
+					      &h2c_header_info, &h2c_seq_mum);
+
+	status = halmac_send_h2c_pkt_88xx(halmac_adapter, h2c_buff,
+					  HALMAC_H2C_CMD_SIZE_88XX, true);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_h2c_pkt_88xx Fail = %x!!\n", status);
+		return status;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_la_mode_88xx() - config la mode
+ * @halmac_adapter : the adapter of halmac
+ * @la_mode :
+ *	disable : no TXFF space reserved for LA debug
+ *	partial : partial TXFF space is reserved for LA debug
+ *	full : all TXFF space is reserved for LA debug
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_la_mode_88xx(struct halmac_adapter *halmac_adapter,
+			enum halmac_la_mode la_mode)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_LA_MODE);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>la_mode = %d\n", __func__,
+			la_mode);
+
+	halmac_adapter->txff_allocation.la_mode = la_mode;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_rx_fifo_expanding_mode_88xx() - rx fifo expanding
+ * @halmac_adapter : the adapter of halmac
+ * @la_mode :
+ *	disable : normal mode
+ *	1 block : Rx FIFO + 1 FIFO block; Tx fifo - 1 FIFO block
+ *	2 block : Rx FIFO + 2 FIFO block; Tx fifo - 2 FIFO block
+ *	3 block : Rx FIFO + 3 FIFO block; Tx fifo - 3 FIFO block
+ * Author : Soar
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status halmac_cfg_rx_fifo_expanding_mode_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_rx_fifo_expanding_mode rx_fifo_expanding_mode)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_CFG_RX_FIFO_EXPANDING_MODE);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+		"%s ==========>rx_fifo_expanding_mode = %d\n", __func__,
+		rx_fifo_expanding_mode);
+
+	halmac_adapter->txff_allocation.rx_fifo_expanding_mode =
+		rx_fifo_expanding_mode;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_config_security_88xx(struct halmac_adapter *halmac_adapter,
+			    struct halmac_security_setting *sec_setting)
+{
+	struct halmac_api *halmac_api;
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_COMMON, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_CR,
+			    (u16)(HALMAC_REG_READ_16(halmac_adapter, REG_CR) |
+				  BIT_MAC_SEC_EN));
+
+	if (sec_setting->tx_encryption == 1)
+		HALMAC_REG_WRITE_8(
+			halmac_adapter, REG_SECCFG,
+			HALMAC_REG_READ_8(halmac_adapter, REG_SECCFG) | BIT(2));
+	else
+		HALMAC_REG_WRITE_8(
+			halmac_adapter, REG_SECCFG,
+			HALMAC_REG_READ_8(halmac_adapter, REG_SECCFG) &
+				~(BIT(2)));
+
+	if (sec_setting->rx_decryption == 1)
+		HALMAC_REG_WRITE_8(
+			halmac_adapter, REG_SECCFG,
+			HALMAC_REG_READ_8(halmac_adapter, REG_SECCFG) | BIT(3));
+	else
+		HALMAC_REG_WRITE_8(
+			halmac_adapter, REG_SECCFG,
+			HALMAC_REG_READ_8(halmac_adapter, REG_SECCFG) &
+				~(BIT(3)));
+
+	if (sec_setting->bip_enable == 1) {
+		if (halmac_adapter->chip_id == HALMAC_CHIP_ID_8822B)
+			return HALMAC_RET_BIP_NO_SUPPORT;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_COMMON, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+u8 halmac_get_used_cam_entry_num_88xx(struct halmac_adapter *halmac_adapter,
+				      enum hal_security_type sec_type)
+{
+	u8 entry_num;
+	void *driver_adapter = NULL;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_COMMON, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	switch (sec_type) {
+	case HAL_SECURITY_TYPE_WEP40:
+	case HAL_SECURITY_TYPE_WEP104:
+	case HAL_SECURITY_TYPE_TKIP:
+	case HAL_SECURITY_TYPE_AES128:
+	case HAL_SECURITY_TYPE_GCMP128:
+	case HAL_SECURITY_TYPE_GCMSMS4:
+	case HAL_SECURITY_TYPE_BIP:
+		entry_num = 1;
+		break;
+	case HAL_SECURITY_TYPE_WAPI:
+	case HAL_SECURITY_TYPE_AES256:
+	case HAL_SECURITY_TYPE_GCMP256:
+		entry_num = 2;
+		break;
+	default:
+		entry_num = 0;
+		break;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_COMMON, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return entry_num;
+}
+
+enum halmac_ret_status
+halmac_write_cam_88xx(struct halmac_adapter *halmac_adapter, u32 entry_index,
+		      struct halmac_cam_entry_info *cam_entry_info)
+{
+	u32 i;
+	u32 command = 0x80010000;
+	struct halmac_api *halmac_api;
+	void *driver_adapter = NULL;
+	struct halmac_cam_entry_format *cam_entry_format = NULL;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_COMMON, DBG_DMESG,
+			"[TRACE]%s ==========>\n", __func__);
+
+	if (entry_index >= halmac_adapter->hw_config_info.cam_entry_num)
+		return HALMAC_RET_ENTRY_INDEX_ERROR;
+
+	if (cam_entry_info->key_id > 3)
+		return HALMAC_RET_FAIL;
+
+	cam_entry_format = kzalloc(sizeof(*cam_entry_format), GFP_KERNEL);
+	if (!cam_entry_format)
+		return HALMAC_RET_NULL_POINTER;
+	memset(cam_entry_format, 0x00, sizeof(*cam_entry_format));
+
+	cam_entry_format->key_id = cam_entry_info->key_id;
+	cam_entry_format->valid = cam_entry_info->valid;
+	memcpy(cam_entry_format->mac_address, cam_entry_info->mac_address, 6);
+	memcpy(cam_entry_format->key, cam_entry_info->key, 16);
+
+	switch (cam_entry_info->security_type) {
+	case HAL_SECURITY_TYPE_NONE:
+		cam_entry_format->type = 0;
+		break;
+	case HAL_SECURITY_TYPE_WEP40:
+		cam_entry_format->type = 1;
+		break;
+	case HAL_SECURITY_TYPE_WEP104:
+		cam_entry_format->type = 5;
+		break;
+	case HAL_SECURITY_TYPE_TKIP:
+		cam_entry_format->type = 2;
+		break;
+	case HAL_SECURITY_TYPE_AES128:
+		cam_entry_format->type = 4;
+		break;
+	case HAL_SECURITY_TYPE_WAPI:
+		cam_entry_format->type = 6;
+		break;
+	case HAL_SECURITY_TYPE_AES256:
+		cam_entry_format->type = 4;
+		cam_entry_format->ext_sectype = 1;
+		break;
+	case HAL_SECURITY_TYPE_GCMP128:
+		cam_entry_format->type = 7;
+		break;
+	case HAL_SECURITY_TYPE_GCMP256:
+	case HAL_SECURITY_TYPE_GCMSMS4:
+		cam_entry_format->type = 7;
+		cam_entry_format->ext_sectype = 1;
+		break;
+	case HAL_SECURITY_TYPE_BIP:
+		cam_entry_format->type = cam_entry_info->unicast == 1 ? 4 : 0;
+		cam_entry_format->mgnt = 1;
+		cam_entry_format->grp = cam_entry_info->unicast == 1 ? 0 : 1;
+		break;
+	default:
+		kfree(cam_entry_format);
+		return HALMAC_RET_FAIL;
+	}
+
+	for (i = 0; i < 8; i++) {
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_CAMWRITE,
+				    *((u32 *)cam_entry_format + i));
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_CAMCMD,
+				    command | ((entry_index << 3) + i));
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_COMMON, DBG_DMESG,
+				"[TRACE]1 - CAM entry format : %X\n",
+				*((u32 *)cam_entry_format + i));
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_COMMON, DBG_DMESG,
+				"[TRACE]1 - REG_CAMCMD : %X\n",
+				command | ((entry_index << 3) + i));
+	}
+
+	if (cam_entry_info->security_type == HAL_SECURITY_TYPE_WAPI ||
+	    cam_entry_info->security_type == HAL_SECURITY_TYPE_AES256 ||
+	    cam_entry_info->security_type == HAL_SECURITY_TYPE_GCMP256 ||
+	    cam_entry_info->security_type == HAL_SECURITY_TYPE_GCMSMS4) {
+		cam_entry_format->mic = 1;
+		memcpy(cam_entry_format->key, cam_entry_info->key_ext, 16);
+
+		for (i = 0; i < 8; i++) {
+			HALMAC_REG_WRITE_32(halmac_adapter, REG_CAMWRITE,
+					    *((u32 *)cam_entry_format + i));
+			HALMAC_REG_WRITE_32(
+				halmac_adapter, REG_CAMCMD,
+				command | (((entry_index + 1) << 3) + i));
+			HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_COMMON,
+					DBG_DMESG,
+					"[TRACE]2 - CAM entry format : %X\n",
+					*((u32 *)cam_entry_format + i));
+			HALMAC_RT_TRACE(
+				driver_adapter, HALMAC_MSG_COMMON, DBG_DMESG,
+				"[TRACE]2 - REG_CAMCMD : %X\n",
+				command | (((entry_index + 1) << 3) + i));
+		}
+	}
+
+	kfree(cam_entry_format);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_COMMON, DBG_DMESG,
+			"[TRACE]%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_read_cam_entry_88xx(struct halmac_adapter *halmac_adapter,
+			   u32 entry_index,
+			   struct halmac_cam_entry_format *content)
+{
+	u32 i;
+	u32 command = 0x80000000;
+	struct halmac_api *halmac_api;
+	void *driver_adapter = NULL;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_COMMON, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (entry_index >= halmac_adapter->hw_config_info.cam_entry_num)
+		return HALMAC_RET_ENTRY_INDEX_ERROR;
+
+	for (i = 0; i < 8; i++) {
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_CAMCMD,
+				    command | ((entry_index << 3) + i));
+		*((u32 *)content + i) =
+			HALMAC_REG_READ_32(halmac_adapter, REG_CAMREAD);
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_COMMON, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_clear_cam_entry_88xx(struct halmac_adapter *halmac_adapter,
+			    u32 entry_index)
+{
+	u32 i;
+	u32 command = 0x80010000;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	struct halmac_cam_entry_format *cam_entry_format;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"[TRACE]halmac_clear_security_cam_88xx ==========>\n");
+
+	if (entry_index >= halmac_adapter->hw_config_info.cam_entry_num)
+		return HALMAC_RET_ENTRY_INDEX_ERROR;
+
+	cam_entry_format = kzalloc(sizeof(*cam_entry_format), GFP_KERNEL);
+	if (!cam_entry_format)
+		return HALMAC_RET_NULL_POINTER;
+	memset(cam_entry_format, 0x00, sizeof(*cam_entry_format));
+
+	for (i = 0; i < 8; i++) {
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_CAMWRITE,
+				    *((u32 *)cam_entry_format + i));
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_CAMCMD,
+				    command | ((entry_index << 3) + i));
+	}
+
+	kfree(cam_entry_format);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"[TRACE]halmac_clear_security_cam_88xx <==========\n");
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_get_hw_value_88xx() -get hw config value
+ * @halmac_adapter : the adapter of halmac
+ * @hw_id : hw id for driver to query
+ * @pvalue : hw value, reference table to get data type
+ * Author : KaiYuan Chang / Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_get_hw_value_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_hw_id hw_id, void *pvalue)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_GET_HW_VALUE);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (!pvalue) {
+		pr_err("%s (!pvalue)==========>\n", __func__);
+		return HALMAC_RET_NULL_POINTER;
+	}
+
+	switch (hw_id) {
+	case HALMAC_HW_RQPN_MAPPING:
+		((struct halmac_rqpn_map *)pvalue)->dma_map_vo =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_VO];
+		((struct halmac_rqpn_map *)pvalue)->dma_map_vi =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_VI];
+		((struct halmac_rqpn_map *)pvalue)->dma_map_be =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_BE];
+		((struct halmac_rqpn_map *)pvalue)->dma_map_bk =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_BK];
+		((struct halmac_rqpn_map *)pvalue)->dma_map_mg =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_MG];
+		((struct halmac_rqpn_map *)pvalue)->dma_map_hi =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_HI];
+		break;
+	case HALMAC_HW_EFUSE_SIZE:
+		*(u32 *)pvalue = halmac_adapter->hw_config_info.efuse_size;
+		break;
+	case HALMAC_HW_EEPROM_SIZE:
+		*(u32 *)pvalue = halmac_adapter->hw_config_info.eeprom_size;
+		break;
+	case HALMAC_HW_BT_BANK_EFUSE_SIZE:
+		*(u32 *)pvalue = halmac_adapter->hw_config_info.bt_efuse_size;
+		break;
+	case HALMAC_HW_BT_BANK1_EFUSE_SIZE:
+	case HALMAC_HW_BT_BANK2_EFUSE_SIZE:
+		*(u32 *)pvalue = 0;
+		break;
+	case HALMAC_HW_TXFIFO_SIZE:
+		*(u32 *)pvalue = halmac_adapter->hw_config_info.tx_fifo_size;
+		break;
+	case HALMAC_HW_RSVD_PG_BNDY:
+		*(u16 *)pvalue =
+			halmac_adapter->txff_allocation.rsvd_drv_pg_bndy;
+		break;
+	case HALMAC_HW_CAM_ENTRY_NUM:
+		*(u8 *)pvalue = halmac_adapter->hw_config_info.cam_entry_num;
+		break;
+	case HALMAC_HW_WLAN_EFUSE_AVAILABLE_SIZE: /*Remove later*/
+		status = halmac_dump_logical_efuse_map_88xx(halmac_adapter,
+							    HALMAC_EFUSE_R_DRV);
+		if (status != HALMAC_RET_SUCCESS)
+			return status;
+		*(u32 *)pvalue = halmac_adapter->hw_config_info.efuse_size -
+				 HALMAC_PROTECTED_EFUSE_SIZE_88XX -
+				 halmac_adapter->efuse_end;
+		break;
+	case HALMAC_HW_IC_VERSION:
+		*(u8 *)pvalue = halmac_adapter->chip_version;
+		break;
+	case HALMAC_HW_PAGE_SIZE:
+		*(u32 *)pvalue = halmac_adapter->hw_config_info.page_size;
+		break;
+	case HALMAC_HW_TX_AGG_ALIGN_SIZE:
+		*(u16 *)pvalue = halmac_adapter->hw_config_info.tx_align_size;
+		break;
+	case HALMAC_HW_RX_AGG_ALIGN_SIZE:
+		*(u8 *)pvalue = 8;
+		break;
+	case HALMAC_HW_DRV_INFO_SIZE:
+		*(u8 *)pvalue = halmac_adapter->drv_info_size;
+		break;
+	case HALMAC_HW_TXFF_ALLOCATION:
+		memcpy(pvalue, &halmac_adapter->txff_allocation,
+		       sizeof(struct halmac_txff_allocation));
+		break;
+	case HALMAC_HW_TX_DESC_SIZE:
+		*(u32 *)pvalue = halmac_adapter->hw_config_info.txdesc_size;
+		break;
+	case HALMAC_HW_RX_DESC_SIZE:
+		*(u32 *)pvalue = halmac_adapter->hw_config_info.rxdesc_size;
+		break;
+	default:
+		return HALMAC_RET_PARA_NOT_SUPPORT;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_set_hw_value_88xx() -set hw config value
+ * @halmac_adapter : the adapter of halmac
+ * @hw_id : hw id for driver to config
+ * @pvalue : hw value, reference table to get data type
+ * Author : KaiYuan Chang / Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_set_hw_value_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_hw_id hw_id, void *pvalue)
+{
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_GET_HW_VALUE);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (!pvalue) {
+		pr_err("%s (!pvalue)==========>\n", __func__);
+		return HALMAC_RET_NULL_POINTER;
+	}
+
+	switch (hw_id) {
+	case HALMAC_HW_USB_MODE:
+		status = halmac_set_usb_mode_88xx(
+			halmac_adapter, *(enum halmac_usb_mode *)pvalue);
+		if (status != HALMAC_RET_SUCCESS)
+			return status;
+		break;
+	case HALMAC_HW_SEQ_EN:
+		break;
+	case HALMAC_HW_BANDWIDTH:
+		halmac_cfg_bw_88xx(halmac_adapter, *(enum halmac_bw *)pvalue);
+		break;
+	case HALMAC_HW_CHANNEL:
+		halmac_cfg_ch_88xx(halmac_adapter, *(u8 *)pvalue);
+		break;
+	case HALMAC_HW_PRI_CHANNEL_IDX:
+		halmac_cfg_pri_ch_idx_88xx(halmac_adapter,
+					   *(enum halmac_pri_ch_idx *)pvalue);
+		break;
+	case HALMAC_HW_EN_BB_RF:
+		halmac_enable_bb_rf_88xx(halmac_adapter, *(u8 *)pvalue);
+		break;
+	case HALMAC_HW_SDIO_TX_PAGE_THRESHOLD:
+		halmac_config_sdio_tx_page_threshold_88xx(
+			halmac_adapter,
+			(struct halmac_tx_page_threshold_info *)pvalue);
+		break;
+	case HALMAC_HW_AMPDU_CONFIG:
+		halmac_config_ampdu_88xx(halmac_adapter,
+					 (struct halmac_ampdu_config *)pvalue);
+		break;
+	default:
+		return HALMAC_RET_PARA_NOT_SUPPORT;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_drv_rsvd_pg_num_88xx() -config reserved page number for driver
+ * @halmac_adapter : the adapter of halmac
+ * @pg_num : page number
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_drv_rsvd_pg_num_88xx(struct halmac_adapter *halmac_adapter,
+				enum halmac_drv_rsvd_pg_num pg_num)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_CFG_DRV_RSVD_PG_NUM);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>pg_num = %d\n", __func__,
+			pg_num);
+
+	switch (pg_num) {
+	case HALMAC_RSVD_PG_NUM16:
+		halmac_adapter->txff_allocation.rsvd_drv_pg_num = 16;
+		break;
+	case HALMAC_RSVD_PG_NUM24:
+		halmac_adapter->txff_allocation.rsvd_drv_pg_num = 24;
+		break;
+	case HALMAC_RSVD_PG_NUM32:
+		halmac_adapter->txff_allocation.rsvd_drv_pg_num = 32;
+		break;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_get_chip_version_88xx(struct halmac_adapter *halmac_adapter,
+			     struct halmac_ver *version)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s ==========>\n", __func__);
+	version->major_ver = (u8)HALMAC_MAJOR_VER_88XX;
+	version->prototype_ver = (u8)HALMAC_PROTOTYPE_VER_88XX;
+	version->minor_ver = (u8)HALMAC_MINOR_VER_88XX;
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_chk_txdesc_88xx() -check if the tx packet format is incorrect
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_buf : tx Packet buffer, tx desc is included
+ * @halmac_size : tx packet size
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_chk_txdesc_88xx(struct halmac_adapter *halmac_adapter, u8 *halmac_buf,
+		       u32 halmac_size)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (GET_TX_DESC_BMC(halmac_buf))
+		if (GET_TX_DESC_AGG_EN(halmac_buf))
+			pr_err("TxDesc: Agg should not be set when BMC\n");
+
+	if (halmac_size < (GET_TX_DESC_TXPKTSIZE(halmac_buf) +
+			   GET_TX_DESC_OFFSET(halmac_buf)))
+		pr_err("TxDesc: PktSize too small\n");
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_dl_drv_rsvd_page_88xx() - download packet to rsvd page
+ * @halmac_adapter : the adapter of halmac
+ * @pg_offset : page offset of driver's rsvd page
+ * @halmac_buf : data to be downloaded, tx_desc is not included
+ * @halmac_size : data size to be downloaded
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_dl_drv_rsvd_page_88xx(struct halmac_adapter *halmac_adapter,
+			     u8 pg_offset, u8 *halmac_buf, u32 halmac_size)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status ret_status;
+	u16 drv_pg_bndy = 0;
+	u32 dl_pg_num = 0;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_DL_DRV_RSVD_PG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	/*check boundary and size valid*/
+	dl_pg_num = halmac_size / halmac_adapter->hw_config_info.page_size +
+		    ((halmac_size &
+		      (halmac_adapter->hw_config_info.page_size - 1)) ?
+			     1 :
+			     0);
+	if (pg_offset + dl_pg_num >
+	    halmac_adapter->txff_allocation.rsvd_drv_pg_num) {
+		pr_err("[ERROR] driver download offset or size error ==========>\n");
+		return HALMAC_RET_DRV_DL_ERR;
+	}
+
+	/*update to target download boundary*/
+	drv_pg_bndy =
+		halmac_adapter->txff_allocation.rsvd_drv_pg_bndy + pg_offset;
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_CTRL_2,
+			    (u16)(drv_pg_bndy & BIT_MASK_BCN_HEAD_1_V1));
+
+	ret_status = halmac_download_rsvd_page_88xx(halmac_adapter, halmac_buf,
+						    halmac_size);
+
+	/*restore to original bundary*/
+	if (ret_status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_download_rsvd_page_88xx Fail = %x!!\n",
+		       ret_status);
+		HALMAC_REG_WRITE_16(
+			halmac_adapter, REG_FIFOPAGE_CTRL_2,
+			(u16)(halmac_adapter->txff_allocation.rsvd_pg_bndy &
+			      BIT_MASK_BCN_HEAD_1_V1));
+		return ret_status;
+	}
+
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_CTRL_2,
+			    (u16)(halmac_adapter->txff_allocation.rsvd_pg_bndy &
+				  BIT_MASK_BCN_HEAD_1_V1));
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s < ==========\n", __func__);
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_csi_rate_88xx() - config CSI frame Tx rate
+ * @halmac_adapter : the adapter of halmac
+ * @rssi : rssi in decimal value
+ * @current_rate : current CSI frame rate
+ * @fixrate_en : enable to fix CSI frame in VHT rate, otherwise legacy OFDM rate
+ * @new_rate : API returns the final CSI frame rate
+ * Author : chunchu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_csi_rate_88xx(struct halmac_adapter *halmac_adapter, u8 rssi,
+			 u8 current_rate, u8 fixrate_en, u8 *new_rate)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	u32 temp_csi_setting;
+	u16 current_rrsr;
+	enum halmac_ret_status ret_status;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_CSI_RATE);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_SND, DBG_DMESG,
+			"<%s ==========>\n", __func__);
+
+	temp_csi_setting = HALMAC_REG_READ_32(halmac_adapter, REG_BBPSF_CTRL) &
+			   ~(BIT_MASK_WMAC_CSI_RATE << BIT_SHIFT_WMAC_CSI_RATE);
+
+	current_rrsr = HALMAC_REG_READ_16(halmac_adapter, REG_RRSR);
+
+	if (rssi >= 40) {
+		if (current_rate != HALMAC_OFDM54) {
+			HALMAC_REG_WRITE_16(halmac_adapter, REG_RRSR,
+					    current_rrsr | BIT(HALMAC_OFDM54));
+			HALMAC_REG_WRITE_32(
+				halmac_adapter, REG_BBPSF_CTRL,
+				temp_csi_setting |
+					BIT_WMAC_CSI_RATE(HALMAC_OFDM54));
+		}
+		*new_rate = HALMAC_OFDM54;
+		ret_status = HALMAC_RET_SUCCESS;
+	} else {
+		if (current_rate != HALMAC_OFDM24) {
+			HALMAC_REG_WRITE_16(halmac_adapter, REG_RRSR,
+					    current_rrsr &
+						    ~(BIT(HALMAC_OFDM54)));
+			HALMAC_REG_WRITE_32(
+				halmac_adapter, REG_BBPSF_CTRL,
+				temp_csi_setting |
+					BIT_WMAC_CSI_RATE(HALMAC_OFDM24));
+		}
+		*new_rate = HALMAC_OFDM24;
+		ret_status = HALMAC_RET_SUCCESS;
+	}
+
+	return ret_status;
+}
+
+/**
+ * halmac_sdio_cmd53_4byte_88xx() - cmd53 only for 4byte len register IO
+ * @halmac_adapter : the adapter of halmac
+ * @enable : 1->CMD53 only use in 4byte reg, 0 : No limitation
+ * Author : Ivan Lin/KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_sdio_cmd53_4byte_88xx(struct halmac_adapter *halmac_adapter,
+			     enum halmac_sdio_cmd53_4byte_mode cmd53_4byte_mode)
+{
+	halmac_adapter->sdio_cmd53_4byte = cmd53_4byte_mode;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_txfifo_is_empty_88xx() -check if txfifo is empty
+ * @halmac_adapter : the adapter of halmac
+ * Author : Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_txfifo_is_empty_88xx(struct halmac_adapter *halmac_adapter, u32 chk_num)
+{
+	u32 counter;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_COMMON, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	counter = (chk_num <= 10) ? 10 : chk_num;
+	do {
+		if (HALMAC_REG_READ_8(halmac_adapter, REG_TXPKT_EMPTY) != 0xFF)
+			return HALMAC_RET_TXFIFO_NO_EMPTY;
+
+		if ((HALMAC_REG_READ_8(halmac_adapter, REG_TXPKT_EMPTY + 1) &
+		     0x07) != 0x07)
+			return HALMAC_RET_TXFIFO_NO_EMPTY;
+		counter--;
+
+	} while (counter != 0);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_COMMON, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx.h b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx.h
new file mode 100644
index 000000000000..5debd1ff3abd
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx.h
@@ -0,0 +1,396 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_API_88XX_H_
+#define _HALMAC_API_88XX_H_
+
+#include "../halmac_2_platform.h"
+#include "../halmac_type.h"
+
+void halmac_init_state_machine_88xx(struct halmac_adapter *halmac_adapter);
+
+void halmac_init_adapter_para_88xx(struct halmac_adapter *halmac_adapter);
+
+void halmac_init_adapter_dynamic_para_88xx(
+	struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_mount_api_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_download_firmware_88xx(struct halmac_adapter *halmac_adapter,
+			      u8 *hamacl_fw, u32 halmac_fw_size);
+
+enum halmac_ret_status
+halmac_free_download_firmware_88xx(struct halmac_adapter *halmac_adapter,
+				   enum halmac_dlfw_mem dlfw_mem, u8 *hamacl_fw,
+				   u32 halmac_fw_size);
+
+enum halmac_ret_status
+halmac_get_fw_version_88xx(struct halmac_adapter *halmac_adapter,
+			   struct halmac_fw_version *fw_version);
+
+enum halmac_ret_status
+halmac_cfg_mac_addr_88xx(struct halmac_adapter *halmac_adapter, u8 halmac_port,
+			 union halmac_wlan_addr *hal_address);
+
+enum halmac_ret_status
+halmac_cfg_bssid_88xx(struct halmac_adapter *halmac_adapter, u8 halmac_port,
+		      union halmac_wlan_addr *hal_address);
+
+enum halmac_ret_status
+halmac_cfg_multicast_addr_88xx(struct halmac_adapter *halmac_adapter,
+			       union halmac_wlan_addr *hal_address);
+
+enum halmac_ret_status
+halmac_pre_init_system_cfg_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_init_system_cfg_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_cfg_rx_aggregation_88xx(struct halmac_adapter *halmac_adapter,
+			       struct halmac_rxagg_cfg halmac_rxagg_cfg);
+
+enum halmac_ret_status
+halmac_init_edca_cfg_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_cfg_operation_mode_88xx(struct halmac_adapter *halmac_adapter,
+			       enum halmac_wireless_mode wireless_mode);
+
+enum halmac_ret_status
+halmac_cfg_ch_bw_88xx(struct halmac_adapter *halmac_adapter, u8 channel,
+		      enum halmac_pri_ch_idx pri_ch_idx, enum halmac_bw bw);
+
+enum halmac_ret_status halmac_cfg_ch_88xx(struct halmac_adapter *halmac_adapter,
+					  u8 channel);
+
+enum halmac_ret_status
+halmac_cfg_pri_ch_idx_88xx(struct halmac_adapter *halmac_adapter,
+			   enum halmac_pri_ch_idx pri_ch_idx);
+
+enum halmac_ret_status halmac_cfg_bw_88xx(struct halmac_adapter *halmac_adapter,
+					  enum halmac_bw bw);
+
+enum halmac_ret_status
+halmac_init_wmac_cfg_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_init_mac_cfg_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_trx_mode mode);
+
+enum halmac_ret_status
+halmac_dump_efuse_map_88xx(struct halmac_adapter *halmac_adapter,
+			   enum halmac_efuse_read_cfg cfg);
+
+enum halmac_ret_status
+halmac_dump_efuse_map_bt_88xx(struct halmac_adapter *halmac_adapter,
+			      enum halmac_efuse_bank halmac_efuse_bank,
+			      u32 bt_efuse_map_size, u8 *bt_efuse_map);
+
+enum halmac_ret_status
+halmac_write_efuse_bt_88xx(struct halmac_adapter *halmac_adapter,
+			   u32 halmac_offset, u8 halmac_value,
+			   enum halmac_efuse_bank halmac_efuse_bank);
+
+enum halmac_ret_status
+halmac_pg_efuse_by_map_88xx(struct halmac_adapter *halmac_adapter,
+			    struct halmac_pg_efuse_info *pg_efuse_info,
+			    enum halmac_efuse_read_cfg cfg);
+
+enum halmac_ret_status
+halmac_get_efuse_size_88xx(struct halmac_adapter *halmac_adapter,
+			   u32 *halmac_size);
+
+enum halmac_ret_status
+halmac_get_efuse_available_size_88xx(struct halmac_adapter *halmac_adapter,
+				     u32 *halmac_size);
+
+enum halmac_ret_status
+halmac_get_c2h_info_88xx(struct halmac_adapter *halmac_adapter, u8 *halmac_buf,
+			 u32 halmac_size);
+
+enum halmac_ret_status
+halmac_get_logical_efuse_size_88xx(struct halmac_adapter *halmac_adapter,
+				   u32 *halmac_size);
+
+enum halmac_ret_status
+halmac_dump_logical_efuse_map_88xx(struct halmac_adapter *halmac_adapter,
+				   enum halmac_efuse_read_cfg cfg);
+
+enum halmac_ret_status
+halmac_write_logical_efuse_88xx(struct halmac_adapter *halmac_adapter,
+				u32 halmac_offset, u8 halmac_value);
+
+enum halmac_ret_status
+halmac_read_logical_efuse_88xx(struct halmac_adapter *halmac_adapter,
+			       u32 halmac_offset, u8 *value);
+
+enum halmac_ret_status
+halmac_cfg_fwlps_option_88xx(struct halmac_adapter *halmac_adapter,
+			     struct halmac_fwlps_option *lps_option);
+
+enum halmac_ret_status
+halmac_cfg_fwips_option_88xx(struct halmac_adapter *halmac_adapter,
+			     struct halmac_fwips_option *ips_option);
+
+enum halmac_ret_status
+halmac_enter_wowlan_88xx(struct halmac_adapter *halmac_adapter,
+			 struct halmac_wowlan_option *wowlan_option);
+
+enum halmac_ret_status
+halmac_leave_wowlan_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_enter_ps_88xx(struct halmac_adapter *halmac_adapter,
+		     enum halmac_ps_state ps_state);
+
+enum halmac_ret_status
+halmac_leave_ps_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_h2c_lb_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status halmac_debug_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_cfg_parameter_88xx(struct halmac_adapter *halmac_adapter,
+			  struct halmac_phy_parameter_info *para_info,
+			  u8 full_fifo);
+
+enum halmac_ret_status
+halmac_update_packet_88xx(struct halmac_adapter *halmac_adapter,
+			  enum halmac_packet_id pkt_id, u8 *pkt, u32 pkt_size);
+
+enum halmac_ret_status
+halmac_bcn_ie_filter_88xx(struct halmac_adapter *halmac_adapter,
+			  struct halmac_bcn_ie_info *bcn_ie_info);
+
+enum halmac_ret_status
+halmac_send_original_h2c_88xx(struct halmac_adapter *halmac_adapter,
+			      u8 *original_h2c, u16 *seq, u8 ack);
+
+enum halmac_ret_status
+halmac_update_datapack_88xx(struct halmac_adapter *halmac_adapter,
+			    enum halmac_data_type halmac_data_type,
+			    struct halmac_phy_parameter_info *para_info);
+
+enum halmac_ret_status
+halmac_run_datapack_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_data_type halmac_data_type);
+
+enum halmac_ret_status
+halmac_cfg_drv_info_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_drv_info halmac_drv_info);
+
+enum halmac_ret_status
+halmac_send_bt_coex_88xx(struct halmac_adapter *halmac_adapter, u8 *bt_buf,
+			 u32 bt_size, u8 ack);
+
+enum halmac_ret_status
+halmac_verify_platform_api_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_timer_2s_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_fill_txdesc_check_sum_88xx(struct halmac_adapter *halmac_adapter,
+				  u8 *cur_desc);
+
+enum halmac_ret_status
+halmac_dump_fifo_88xx(struct halmac_adapter *halmac_adapter,
+		      enum hal_fifo_sel halmac_fifo_sel, u32 halmac_start_addr,
+		      u32 halmac_fifo_dump_size, u8 *fifo_map);
+
+u32 halmac_get_fifo_size_88xx(struct halmac_adapter *halmac_adapter,
+			      enum hal_fifo_sel halmac_fifo_sel);
+
+enum halmac_ret_status
+halmac_cfg_txbf_88xx(struct halmac_adapter *halmac_adapter, u8 userid,
+		     enum halmac_bw bw, u8 txbf_en);
+
+enum halmac_ret_status
+halmac_cfg_mumimo_88xx(struct halmac_adapter *halmac_adapter,
+		       struct halmac_cfg_mumimo_para *cfgmu);
+
+enum halmac_ret_status
+halmac_cfg_sounding_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_snd_role role,
+			 enum halmac_data_rate datarate);
+
+enum halmac_ret_status
+halmac_del_sounding_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_snd_role role);
+
+enum halmac_ret_status
+halmac_su_bfee_entry_init_88xx(struct halmac_adapter *halmac_adapter, u8 userid,
+			       u16 paid);
+
+enum halmac_ret_status
+halmac_su_bfer_entry_init_88xx(struct halmac_adapter *halmac_adapter,
+			       struct halmac_su_bfer_init_para *su_bfer_init);
+
+enum halmac_ret_status
+halmac_mu_bfee_entry_init_88xx(struct halmac_adapter *halmac_adapter,
+			       struct halmac_mu_bfee_init_para *mu_bfee_init);
+
+enum halmac_ret_status
+halmac_mu_bfer_entry_init_88xx(struct halmac_adapter *halmac_adapter,
+			       struct halmac_mu_bfer_init_para *mu_bfer_init);
+
+enum halmac_ret_status
+halmac_su_bfee_entry_del_88xx(struct halmac_adapter *halmac_adapter, u8 userid);
+
+enum halmac_ret_status
+halmac_su_bfer_entry_del_88xx(struct halmac_adapter *halmac_adapter, u8 userid);
+
+enum halmac_ret_status
+halmac_mu_bfee_entry_del_88xx(struct halmac_adapter *halmac_adapter, u8 userid);
+
+enum halmac_ret_status
+halmac_mu_bfer_entry_del_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_add_ch_info_88xx(struct halmac_adapter *halmac_adapter,
+			struct halmac_ch_info *ch_info);
+
+enum halmac_ret_status
+halmac_add_extra_ch_info_88xx(struct halmac_adapter *halmac_adapter,
+			      struct halmac_ch_extra_info *ch_extra_info);
+
+enum halmac_ret_status
+halmac_ctrl_ch_switch_88xx(struct halmac_adapter *halmac_adapter,
+			   struct halmac_ch_switch_option *cs_option);
+
+enum halmac_ret_status halmac_p2pps_88xx(struct halmac_adapter *halmac_adapter,
+					 struct halmac_p2pps *p2p_ps);
+
+enum halmac_ret_status
+halmac_func_p2pps_88xx(struct halmac_adapter *halmac_adapter,
+		       struct halmac_p2pps *p2p_ps);
+
+enum halmac_ret_status
+halmac_clear_ch_info_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_send_general_info_88xx(struct halmac_adapter *halmac_adapter,
+			      struct halmac_general_info *general_info);
+
+enum halmac_ret_status
+halmac_start_iqk_88xx(struct halmac_adapter *halmac_adapter,
+		      struct halmac_iqk_para_ *iqk_para);
+
+enum halmac_ret_status halmac_ctrl_pwr_tracking_88xx(
+	struct halmac_adapter *halmac_adapter,
+	struct halmac_pwr_tracking_option *pwr_tracking_opt);
+
+enum halmac_ret_status
+halmac_query_status_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_feature_id feature_id,
+			 enum halmac_cmd_process_status *process_status,
+			 u8 *data, u32 *size);
+
+enum halmac_ret_status
+halmac_reset_feature_88xx(struct halmac_adapter *halmac_adapter,
+			  enum halmac_feature_id feature_id);
+
+enum halmac_ret_status
+halmac_check_fw_status_88xx(struct halmac_adapter *halmac_adapter,
+			    bool *fw_status);
+
+enum halmac_ret_status
+halmac_dump_fw_dmem_88xx(struct halmac_adapter *halmac_adapter, u8 *dmem,
+			 u32 *size);
+
+enum halmac_ret_status
+halmac_cfg_max_dl_size_88xx(struct halmac_adapter *halmac_adapter, u32 size);
+
+enum halmac_ret_status halmac_psd_88xx(struct halmac_adapter *halmac_adapter,
+				       u16 start_psd, u16 end_psd);
+
+enum halmac_ret_status
+halmac_cfg_la_mode_88xx(struct halmac_adapter *halmac_adapter,
+			enum halmac_la_mode la_mode);
+
+enum halmac_ret_status halmac_cfg_rx_fifo_expanding_mode_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_rx_fifo_expanding_mode rx_fifo_expanding_mode);
+
+enum halmac_ret_status
+halmac_config_security_88xx(struct halmac_adapter *halmac_adapter,
+			    struct halmac_security_setting *sec_setting);
+
+u8 halmac_get_used_cam_entry_num_88xx(struct halmac_adapter *halmac_adapter,
+				      enum hal_security_type sec_type);
+
+enum halmac_ret_status
+halmac_write_cam_88xx(struct halmac_adapter *halmac_adapter, u32 entry_index,
+		      struct halmac_cam_entry_info *cam_entry_info);
+
+enum halmac_ret_status
+halmac_read_cam_entry_88xx(struct halmac_adapter *halmac_adapter,
+			   u32 entry_index,
+			   struct halmac_cam_entry_format *content);
+
+enum halmac_ret_status
+halmac_clear_cam_entry_88xx(struct halmac_adapter *halmac_adapter,
+			    u32 entry_index);
+
+enum halmac_ret_status
+halmac_get_hw_value_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_hw_id hw_id, void *pvalue);
+
+enum halmac_ret_status
+halmac_set_hw_value_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_hw_id hw_id, void *pvalue);
+
+enum halmac_ret_status
+halmac_cfg_drv_rsvd_pg_num_88xx(struct halmac_adapter *halmac_adapter,
+				enum halmac_drv_rsvd_pg_num pg_num);
+
+enum halmac_ret_status
+halmac_get_chip_version_88xx(struct halmac_adapter *halmac_adapter,
+			     struct halmac_ver *version);
+
+enum halmac_ret_status
+halmac_chk_txdesc_88xx(struct halmac_adapter *halmac_adapter, u8 *halmac_buf,
+		       u32 halmac_size);
+
+enum halmac_ret_status
+halmac_dl_drv_rsvd_page_88xx(struct halmac_adapter *halmac_adapter,
+			     u8 pg_offset, u8 *halmac_buf, u32 halmac_size);
+
+enum halmac_ret_status
+halmac_cfg_csi_rate_88xx(struct halmac_adapter *halmac_adapter, u8 rssi,
+			 u8 current_rate, u8 fixrate_en, u8 *new_rate);
+
+enum halmac_ret_status halmac_sdio_cmd53_4byte_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_sdio_cmd53_4byte_mode cmd53_4byte_mode);
+
+enum halmac_ret_status
+halmac_txfifo_is_empty_88xx(struct halmac_adapter *halmac_adapter, u32 chk_num);
+
+#endif /* _HALMAC_API_H_ */
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_pcie.c b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_pcie.c
new file mode 100644
index 000000000000..fa97cac34742
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_pcie.c
@@ -0,0 +1,329 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "halmac_88xx_cfg.h"
+
+/**
+ * halmac_init_pcie_cfg_88xx() -  init PCIe
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_init_pcie_cfg_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_INIT_PCIE_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_deinit_pcie_cfg_88xx() - deinit PCIE
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_deinit_pcie_cfg_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_DEINIT_PCIE_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_rx_aggregation_88xx_pcie() - config rx aggregation
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_rx_agg_mode
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_rx_aggregation_88xx_pcie(struct halmac_adapter *halmac_adapter,
+				    struct halmac_rxagg_cfg *phalmac_rxagg_cfg)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_CFG_RX_AGGREGATION);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_reg_read_8_pcie_88xx() - read 1byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+u8 halmac_reg_read_8_pcie_88xx(struct halmac_adapter *halmac_adapter,
+			       u32 halmac_offset)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	return PLATFORM_REG_READ_8(driver_adapter, halmac_offset);
+}
+
+/**
+ * halmac_reg_write_8_pcie_88xx() - write 1byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * @halmac_data : register value
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_reg_write_8_pcie_88xx(struct halmac_adapter *halmac_adapter,
+			     u32 halmac_offset, u8 halmac_data)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	PLATFORM_REG_WRITE_8(driver_adapter, halmac_offset, halmac_data);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_reg_read_16_pcie_88xx() - read 2byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+u16 halmac_reg_read_16_pcie_88xx(struct halmac_adapter *halmac_adapter,
+				 u32 halmac_offset)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	return PLATFORM_REG_READ_16(driver_adapter, halmac_offset);
+}
+
+/**
+ * halmac_reg_write_16_pcie_88xx() - write 2byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * @halmac_data : register value
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_reg_write_16_pcie_88xx(struct halmac_adapter *halmac_adapter,
+			      u32 halmac_offset, u16 halmac_data)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	PLATFORM_REG_WRITE_16(driver_adapter, halmac_offset, halmac_data);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_reg_read_32_pcie_88xx() - read 4byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+u32 halmac_reg_read_32_pcie_88xx(struct halmac_adapter *halmac_adapter,
+				 u32 halmac_offset)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	return PLATFORM_REG_READ_32(driver_adapter, halmac_offset);
+}
+
+/**
+ * halmac_reg_write_32_pcie_88xx() - write 4byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * @halmac_data : register value
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_reg_write_32_pcie_88xx(struct halmac_adapter *halmac_adapter,
+			      u32 halmac_offset, u32 halmac_data)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	PLATFORM_REG_WRITE_32(driver_adapter, halmac_offset, halmac_data);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_tx_agg_align_pcie_88xx() -config sdio bus tx agg alignment
+ * @halmac_adapter : the adapter of halmac
+ * @enable : function enable(1)/disable(0)
+ * @align_size : sdio bus tx agg alignment size (2^n, n = 3~11)
+ * Author : Soar Tu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status halmac_cfg_tx_agg_align_pcie_not_support_88xx(
+	struct halmac_adapter *halmac_adapter, u8 enable, u16 align_size)
+{
+	struct halmac_api *halmac_api;
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_TX_AGG_ALIGN);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+		"%s ==========>\n", __func__);
+
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+		"%s not support\n", __func__);
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+		"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_pcie.h b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_pcie.h
new file mode 100644
index 000000000000..34969fc5c03e
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_pcie.h
@@ -0,0 +1,71 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_API_88XX_PCIE_H_
+#define _HALMAC_API_88XX_PCIE_H_
+
+#include "../halmac_2_platform.h"
+#include "../halmac_type.h"
+
+#define LINK_CTRL2_REG_OFFSET 0xA0
+#define GEN2_CTRL_OFFSET 0x80C
+#define LINK_STATUS_REG_OFFSET 0x82
+#define GEN1_SPEED 0x01
+#define GEN2_SPEED 0x02
+
+enum halmac_ret_status
+halmac_init_pcie_cfg_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_deinit_pcie_cfg_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_cfg_rx_aggregation_88xx_pcie(struct halmac_adapter *halmac_adapter,
+				    struct halmac_rxagg_cfg *phalmac_rxagg_cfg);
+
+u8 halmac_reg_read_8_pcie_88xx(struct halmac_adapter *halmac_adapter,
+			       u32 halmac_offset);
+
+enum halmac_ret_status
+halmac_reg_write_8_pcie_88xx(struct halmac_adapter *halmac_adapter,
+			     u32 halmac_offset, u8 halmac_data);
+
+u16 halmac_reg_read_16_pcie_88xx(struct halmac_adapter *halmac_adapter,
+				 u32 halmac_offset);
+
+enum halmac_ret_status
+halmac_reg_write_16_pcie_88xx(struct halmac_adapter *halmac_adapter,
+			      u32 halmac_offset, u16 halmac_data);
+
+u32 halmac_reg_read_32_pcie_88xx(struct halmac_adapter *halmac_adapter,
+				 u32 halmac_offset);
+
+enum halmac_ret_status
+halmac_reg_write_32_pcie_88xx(struct halmac_adapter *halmac_adapter,
+			      u32 halmac_offset, u32 halmac_data);
+
+enum halmac_ret_status halmac_cfg_tx_agg_align_pcie_not_support_88xx(
+	struct halmac_adapter *halmac_adapter, u8 enable, u16 align_size);
+
+#endif /* _HALMAC_API_88XX_PCIE_H_ */
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_sdio.c b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_sdio.c
new file mode 100644
index 000000000000..69b26a5a3cf3
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_sdio.c
@@ -0,0 +1,974 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "halmac_88xx_cfg.h"
+
+/**
+ * halmac_init_sdio_cfg_88xx() - init SDIO
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_init_sdio_cfg_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_INIT_SDIO_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	HALMAC_REG_READ_32(halmac_adapter, REG_SDIO_FREE_TXPG);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_SDIO_TX_CTRL, 0x00000000);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_deinit_sdio_cfg_88xx() - deinit SDIO
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_deinit_sdio_cfg_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_DEINIT_SDIO_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_rx_aggregation_88xx_sdio() - config rx aggregation
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_rx_agg_mode
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_rx_aggregation_88xx_sdio(struct halmac_adapter *halmac_adapter,
+				    struct halmac_rxagg_cfg *phalmac_rxagg_cfg)
+{
+	u8 value8;
+	u8 size = 0, timeout = 0, agg_enable = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_CFG_RX_AGGREGATION);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	agg_enable = HALMAC_REG_READ_8(halmac_adapter, REG_TXDMA_PQ_MAP);
+
+	switch (phalmac_rxagg_cfg->mode) {
+	case HALMAC_RX_AGG_MODE_NONE:
+		agg_enable &= ~(BIT_RXDMA_AGG_EN);
+		break;
+	case HALMAC_RX_AGG_MODE_DMA:
+	case HALMAC_RX_AGG_MODE_USB:
+		agg_enable |= BIT_RXDMA_AGG_EN;
+		break;
+	default:
+		pr_err("halmac_cfg_rx_aggregation_88xx_usb switch case not support\n");
+		agg_enable &= ~BIT_RXDMA_AGG_EN;
+		break;
+	}
+
+	if (!phalmac_rxagg_cfg->threshold.drv_define) {
+		size = 0xFF;
+		timeout = 0x01;
+	} else {
+		size = phalmac_rxagg_cfg->threshold.size;
+		timeout = phalmac_rxagg_cfg->threshold.timeout;
+	}
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_TXDMA_PQ_MAP, agg_enable);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_RXDMA_AGG_PG_TH,
+			    (u16)(size | (timeout << BIT_SHIFT_DMA_AGG_TO)));
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_RXDMA_MODE);
+	if ((agg_enable & BIT_RXDMA_AGG_EN) != 0)
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_RXDMA_MODE,
+				   value8 | BIT_DMA_MODE);
+	else
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_RXDMA_MODE,
+				   value8 & ~(BIT_DMA_MODE));
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_reg_read_8_sdio_88xx() - read 1byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+u8 halmac_reg_read_8_sdio_88xx(struct halmac_adapter *halmac_adapter,
+			       u32 halmac_offset)
+{
+	u8 value8;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if ((halmac_offset & 0xFFFF0000) == 0)
+		halmac_offset |= WLAN_IOREG_OFFSET;
+
+	status = halmac_convert_to_sdio_bus_offset_88xx(halmac_adapter,
+							&halmac_offset);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("%s error = %x\n", __func__, status);
+		return status;
+	}
+
+	value8 = PLATFORM_SDIO_CMD52_READ(driver_adapter, halmac_offset);
+
+	return value8;
+}
+
+/**
+ * halmac_reg_write_8_sdio_88xx() - write 1byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * @halmac_data : register value
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_reg_write_8_sdio_88xx(struct halmac_adapter *halmac_adapter,
+			     u32 halmac_offset, u8 halmac_data)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if ((halmac_offset & 0xFFFF0000) == 0)
+		halmac_offset |= WLAN_IOREG_OFFSET;
+
+	status = halmac_convert_to_sdio_bus_offset_88xx(halmac_adapter,
+							&halmac_offset);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("%s error = %x\n", __func__, status);
+		return status;
+	}
+
+	PLATFORM_SDIO_CMD52_WRITE(driver_adapter, halmac_offset, halmac_data);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_reg_read_16_sdio_88xx() - read 2byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+u16 halmac_reg_read_16_sdio_88xx(struct halmac_adapter *halmac_adapter,
+				 u32 halmac_offset)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	union {
+		u16 word;
+		u8 byte[2];
+		__le16 le_word;
+	} value16 = {0x0000};
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if ((halmac_offset & 0xFFFF0000) == 0)
+		halmac_offset |= WLAN_IOREG_OFFSET;
+
+	status = halmac_convert_to_sdio_bus_offset_88xx(halmac_adapter,
+							&halmac_offset);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("%s error = %x\n", __func__, status);
+		return status;
+	}
+
+	if (halmac_adapter->halmac_state.mac_power == HALMAC_MAC_POWER_OFF ||
+	    (halmac_offset & (2 - 1)) != 0 ||
+	    halmac_adapter->sdio_cmd53_4byte ==
+		    HALMAC_SDIO_CMD53_4BYTE_MODE_RW ||
+	    halmac_adapter->sdio_cmd53_4byte ==
+		    HALMAC_SDIO_CMD53_4BYTE_MODE_R) {
+		value16.byte[0] =
+			PLATFORM_SDIO_CMD52_READ(driver_adapter, halmac_offset);
+		value16.byte[1] = PLATFORM_SDIO_CMD52_READ(driver_adapter,
+							   halmac_offset + 1);
+		value16.word = le16_to_cpu(value16.le_word);
+	} else {
+#if (PLATFORM_SD_CLK > HALMAC_SD_CLK_THRESHOLD_88XX)
+		if ((halmac_offset & 0xffffef00) == 0x00000000) {
+			value16.byte[0] = PLATFORM_SDIO_CMD52_READ(
+				driver_adapter, halmac_offset);
+			value16.byte[1] = PLATFORM_SDIO_CMD52_READ(
+				driver_adapter, halmac_offset + 1);
+			value16.word = le16_to_cpu(value16.word);
+		} else {
+			value16.word = PLATFORM_SDIO_CMD53_READ_16(
+				driver_adapter, halmac_offset);
+		}
+#else
+		value16.word = PLATFORM_SDIO_CMD53_READ_16(driver_adapter,
+							   halmac_offset);
+#endif
+	}
+
+	return value16.word;
+}
+
+/**
+ * halmac_reg_write_16_sdio_88xx() - write 2byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * @halmac_data : register value
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_reg_write_16_sdio_88xx(struct halmac_adapter *halmac_adapter,
+			      u32 halmac_offset, u16 halmac_data)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if ((halmac_offset & 0xFFFF0000) == 0)
+		halmac_offset |= WLAN_IOREG_OFFSET;
+
+	status = halmac_convert_to_sdio_bus_offset_88xx(halmac_adapter,
+							&halmac_offset);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("%s error = %x\n", __func__, status);
+		return status;
+	}
+
+	if (halmac_adapter->halmac_state.mac_power == HALMAC_MAC_POWER_OFF ||
+	    (halmac_offset & (2 - 1)) != 0 ||
+	    halmac_adapter->sdio_cmd53_4byte ==
+		    HALMAC_SDIO_CMD53_4BYTE_MODE_RW ||
+	    halmac_adapter->sdio_cmd53_4byte ==
+		    HALMAC_SDIO_CMD53_4BYTE_MODE_W) {
+		PLATFORM_SDIO_CMD52_WRITE(driver_adapter, halmac_offset,
+					  (u8)(halmac_data & 0xFF));
+		PLATFORM_SDIO_CMD52_WRITE(driver_adapter, halmac_offset + 1,
+					  (u8)((halmac_data & 0xFF00) >> 8));
+	} else {
+		PLATFORM_SDIO_CMD53_WRITE_16(driver_adapter, halmac_offset,
+					     halmac_data);
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_reg_read_32_sdio_88xx() - read 4byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+u32 halmac_reg_read_32_sdio_88xx(struct halmac_adapter *halmac_adapter,
+				 u32 halmac_offset)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	u32 halmac_offset_old = 0;
+
+	union {
+		u32 dword;
+		u8 byte[4];
+		__le32 le_dword;
+	} value32 = {0x00000000};
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	halmac_offset_old = halmac_offset;
+
+	if ((halmac_offset & 0xFFFF0000) == 0)
+		halmac_offset |= WLAN_IOREG_OFFSET;
+
+	status = halmac_convert_to_sdio_bus_offset_88xx(halmac_adapter,
+							&halmac_offset);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("%s error = %x\n", __func__, status);
+		return status;
+	}
+
+	if (halmac_adapter->halmac_state.mac_power == HALMAC_MAC_POWER_OFF ||
+	    (halmac_offset & (4 - 1)) != 0) {
+		value32.byte[0] =
+			PLATFORM_SDIO_CMD52_READ(driver_adapter, halmac_offset);
+		value32.byte[1] = PLATFORM_SDIO_CMD52_READ(driver_adapter,
+							   halmac_offset + 1);
+		value32.byte[2] = PLATFORM_SDIO_CMD52_READ(driver_adapter,
+							   halmac_offset + 2);
+		value32.byte[3] = PLATFORM_SDIO_CMD52_READ(driver_adapter,
+							   halmac_offset + 3);
+		value32.dword = le32_to_cpu(value32.le_dword);
+	} else {
+#if (PLATFORM_SD_CLK > HALMAC_SD_CLK_THRESHOLD_88XX)
+		if ((halmac_offset_old & 0xffffef00) == 0x00000000) {
+			value32.byte[0] = PLATFORM_SDIO_CMD52_READ(
+				driver_adapter, halmac_offset);
+			value32.byte[1] = PLATFORM_SDIO_CMD52_READ(
+				driver_adapter, halmac_offset + 1);
+			value32.byte[2] = PLATFORM_SDIO_CMD52_READ(
+				driver_adapter, halmac_offset + 2);
+			value32.byte[3] = PLATFORM_SDIO_CMD52_READ(
+				driver_adapter, halmac_offset + 3);
+			value32.dword = le32_to_cpu(value32.dword);
+		} else {
+			value32.dword = PLATFORM_SDIO_CMD53_READ_32(
+				driver_adapter, halmac_offset);
+		}
+#else
+		value32.dword = PLATFORM_SDIO_CMD53_READ_32(driver_adapter,
+							    halmac_offset);
+#endif
+	}
+
+	return value32.dword;
+}
+
+/**
+ * halmac_reg_write_32_sdio_88xx() - write 4byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * @halmac_data : register value
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_reg_write_32_sdio_88xx(struct halmac_adapter *halmac_adapter,
+			      u32 halmac_offset, u32 halmac_data)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if ((halmac_offset & 0xFFFF0000) == 0)
+		halmac_offset |= WLAN_IOREG_OFFSET;
+
+	status = halmac_convert_to_sdio_bus_offset_88xx(halmac_adapter,
+							&halmac_offset);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("%s error = %x\n", __func__, status);
+		return status;
+	}
+
+	if (halmac_adapter->halmac_state.mac_power == HALMAC_MAC_POWER_OFF ||
+	    (halmac_offset & (4 - 1)) != 0) {
+		PLATFORM_SDIO_CMD52_WRITE(driver_adapter, halmac_offset,
+					  (u8)(halmac_data & 0xFF));
+		PLATFORM_SDIO_CMD52_WRITE(driver_adapter, halmac_offset + 1,
+					  (u8)((halmac_data & 0xFF00) >> 8));
+		PLATFORM_SDIO_CMD52_WRITE(driver_adapter, halmac_offset + 2,
+					  (u8)((halmac_data & 0xFF0000) >> 16));
+		PLATFORM_SDIO_CMD52_WRITE(
+			driver_adapter, halmac_offset + 3,
+			(u8)((halmac_data & 0xFF000000) >> 24));
+	} else {
+		PLATFORM_SDIO_CMD53_WRITE_32(driver_adapter, halmac_offset,
+					     halmac_data);
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_reg_read_nbyte_sdio_88xx() - read n byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * @halmac_size : register value size
+ * @halmac_data : register value
+ * Author : Soar
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+u8 halmac_reg_read_nbyte_sdio_88xx(struct halmac_adapter *halmac_adapter,
+				   u32 halmac_offset, u32 halmac_size,
+				   u8 *halmac_data)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if ((halmac_offset & 0xFFFF0000) == 0) {
+		pr_err("halmac_offset error = 0x%x\n", halmac_offset);
+		return HALMAC_RET_FAIL;
+	}
+
+	status = halmac_convert_to_sdio_bus_offset_88xx(halmac_adapter,
+							&halmac_offset);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("%s error = %x\n", __func__, status);
+		return status;
+	}
+
+	if (halmac_adapter->halmac_state.mac_power == HALMAC_MAC_POWER_OFF) {
+		pr_err("halmac_state error = 0x%x\n",
+		       halmac_adapter->halmac_state.mac_power);
+		return HALMAC_RET_FAIL;
+	}
+
+	PLATFORM_SDIO_CMD53_READ_N(driver_adapter, halmac_offset, halmac_size,
+				   halmac_data);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_get_sdio_tx_addr_sdio_88xx() - get CMD53 addr for the TX packet
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_buf : tx packet, include txdesc
+ * @halmac_size : tx packet size
+ * @pcmd53_addr : cmd53 addr value
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_get_sdio_tx_addr_88xx(struct halmac_adapter *halmac_adapter,
+			     u8 *halmac_buf, u32 halmac_size, u32 *pcmd53_addr)
+{
+	u32 four_byte_len;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_queue_select queue_sel;
+	enum halmac_dma_mapping dma_mapping;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_GET_SDIO_TX_ADDR);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (!halmac_buf) {
+		pr_err("halmac_buf is NULL!!\n");
+		return HALMAC_RET_DATA_BUF_NULL;
+	}
+
+	if (halmac_size == 0) {
+		pr_err("halmac_size is 0!!\n");
+		return HALMAC_RET_DATA_SIZE_INCORRECT;
+	}
+
+	queue_sel = (enum halmac_queue_select)GET_TX_DESC_QSEL(halmac_buf);
+
+	switch (queue_sel) {
+	case HALMAC_QUEUE_SELECT_VO:
+	case HALMAC_QUEUE_SELECT_VO_V2:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_VO];
+		break;
+	case HALMAC_QUEUE_SELECT_VI:
+	case HALMAC_QUEUE_SELECT_VI_V2:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_VI];
+		break;
+	case HALMAC_QUEUE_SELECT_BE:
+	case HALMAC_QUEUE_SELECT_BE_V2:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_BE];
+		break;
+	case HALMAC_QUEUE_SELECT_BK:
+	case HALMAC_QUEUE_SELECT_BK_V2:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_BK];
+		break;
+	case HALMAC_QUEUE_SELECT_MGNT:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_MG];
+		break;
+	case HALMAC_QUEUE_SELECT_HIGH:
+	case HALMAC_QUEUE_SELECT_BCN:
+	case HALMAC_QUEUE_SELECT_CMD:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_HI];
+		break;
+	default:
+		pr_err("Qsel is out of range\n");
+		return HALMAC_RET_QSEL_INCORRECT;
+	}
+
+	four_byte_len = (halmac_size >> 2) + ((halmac_size & (4 - 1)) ? 1 : 0);
+
+	switch (dma_mapping) {
+	case HALMAC_DMA_MAPPING_HIGH:
+		*pcmd53_addr = HALMAC_SDIO_CMD_ADDR_TXFF_HIGH;
+		break;
+	case HALMAC_DMA_MAPPING_NORMAL:
+		*pcmd53_addr = HALMAC_SDIO_CMD_ADDR_TXFF_NORMAL;
+		break;
+	case HALMAC_DMA_MAPPING_LOW:
+		*pcmd53_addr = HALMAC_SDIO_CMD_ADDR_TXFF_LOW;
+		break;
+	case HALMAC_DMA_MAPPING_EXTRA:
+		*pcmd53_addr = HALMAC_SDIO_CMD_ADDR_TXFF_EXTRA;
+		break;
+	default:
+		pr_err("DmaMapping is out of range\n");
+		return HALMAC_RET_DMA_MAP_INCORRECT;
+	}
+
+	*pcmd53_addr = (*pcmd53_addr << 13) |
+		       (four_byte_len & HALMAC_SDIO_4BYTE_LEN_MASK);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_tx_agg_align_sdio_88xx() -config sdio bus tx agg alignment
+ * @halmac_adapter : the adapter of halmac
+ * @enable : function enable(1)/disable(0)
+ * @align_size : sdio bus tx agg alignment size (2^n, n = 3~11)
+ * Author : Soar Tu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_tx_agg_align_sdio_88xx(struct halmac_adapter *halmac_adapter,
+				  u8 enable, u16 align_size)
+{
+	struct halmac_api *halmac_api;
+	void *driver_adapter = NULL;
+	u8 i, align_size_ok = 0;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_TX_AGG_ALIGN);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if ((align_size & 0xF000) != 0) {
+		pr_err("Align size is out of range\n");
+		return HALMAC_RET_FAIL;
+	}
+
+	for (i = 3; i <= 11; i++) {
+		if (align_size == 1 << i) {
+			align_size_ok = 1;
+			break;
+		}
+	}
+	if (align_size_ok == 0) {
+		pr_err("Align size is not 2^3 ~ 2^11\n");
+		return HALMAC_RET_FAIL;
+	}
+
+	/*Keep sdio tx agg alignment size for driver query*/
+	halmac_adapter->hw_config_info.tx_align_size = align_size;
+
+	if (enable)
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_RQPN_CTRL_2,
+				    0x8000 | align_size);
+	else
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_RQPN_CTRL_2,
+				    align_size);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status halmac_cfg_tx_agg_align_sdio_not_support_88xx(
+	struct halmac_adapter *halmac_adapter, u8 enable, u16 align_size)
+{
+	struct halmac_api *halmac_api;
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_TX_AGG_ALIGN);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+		"%s ==========>\n", __func__);
+
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+		"%s not support\n", __func__);
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+		"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_tx_allowed_sdio_88xx() - check tx status
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_buf : tx packet, include txdesc
+ * @halmac_size : tx packet size, include txdesc
+ * Author : Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_tx_allowed_sdio_88xx(struct halmac_adapter *halmac_adapter,
+			    u8 *halmac_buf, u32 halmac_size)
+{
+	u8 *curr_packet;
+	u16 *curr_free_space;
+	u32 i, counter;
+	u32 tx_agg_num, packet_size = 0;
+	u32 tx_required_page_num, total_required_page_num = 0;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	void *driver_adapter = NULL;
+	enum halmac_dma_mapping dma_mapping;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_TX_ALLOWED_SDIO);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	tx_agg_num = GET_TX_DESC_DMA_TXAGG_NUM(halmac_buf);
+	curr_packet = halmac_buf;
+
+	tx_agg_num = tx_agg_num == 0 ? 1 : tx_agg_num;
+
+	switch ((enum halmac_queue_select)GET_TX_DESC_QSEL(curr_packet)) {
+	case HALMAC_QUEUE_SELECT_VO:
+	case HALMAC_QUEUE_SELECT_VO_V2:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_VO];
+		break;
+	case HALMAC_QUEUE_SELECT_VI:
+	case HALMAC_QUEUE_SELECT_VI_V2:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_VI];
+		break;
+	case HALMAC_QUEUE_SELECT_BE:
+	case HALMAC_QUEUE_SELECT_BE_V2:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_BE];
+		break;
+	case HALMAC_QUEUE_SELECT_BK:
+	case HALMAC_QUEUE_SELECT_BK_V2:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_BK];
+		break;
+	case HALMAC_QUEUE_SELECT_MGNT:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_MG];
+		break;
+	case HALMAC_QUEUE_SELECT_HIGH:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_HI];
+		break;
+	case HALMAC_QUEUE_SELECT_BCN:
+	case HALMAC_QUEUE_SELECT_CMD:
+		return HALMAC_RET_SUCCESS;
+	default:
+		pr_err("Qsel is out of range\n");
+		return HALMAC_RET_QSEL_INCORRECT;
+	}
+
+	switch (dma_mapping) {
+	case HALMAC_DMA_MAPPING_HIGH:
+		curr_free_space =
+			&halmac_adapter->sdio_free_space.high_queue_number;
+		break;
+	case HALMAC_DMA_MAPPING_NORMAL:
+		curr_free_space =
+			&halmac_adapter->sdio_free_space.normal_queue_number;
+		break;
+	case HALMAC_DMA_MAPPING_LOW:
+		curr_free_space =
+			&halmac_adapter->sdio_free_space.low_queue_number;
+		break;
+	case HALMAC_DMA_MAPPING_EXTRA:
+		curr_free_space =
+			&halmac_adapter->sdio_free_space.extra_queue_number;
+		break;
+	default:
+		pr_err("DmaMapping is out of range\n");
+		return HALMAC_RET_DMA_MAP_INCORRECT;
+	}
+
+	for (i = 0; i < tx_agg_num; i++) {
+		packet_size = GET_TX_DESC_TXPKTSIZE(curr_packet) +
+			      GET_TX_DESC_OFFSET(curr_packet) +
+			      (GET_TX_DESC_PKT_OFFSET(curr_packet) << 3);
+		tx_required_page_num =
+			(packet_size >>
+			 halmac_adapter->hw_config_info.page_size_2_power) +
+			((packet_size &
+			  (halmac_adapter->hw_config_info.page_size - 1)) ?
+				 1 :
+				 0);
+		total_required_page_num += tx_required_page_num;
+
+		packet_size = HALMAC_ALIGN(packet_size, 8);
+
+		curr_packet += packet_size;
+	}
+
+	counter = 10;
+	do {
+		if ((u32)(*curr_free_space +
+			  halmac_adapter->sdio_free_space.public_queue_number) >
+		    total_required_page_num) {
+			if (*curr_free_space >= total_required_page_num) {
+				*curr_free_space -=
+					(u16)total_required_page_num;
+			} else {
+				halmac_adapter->sdio_free_space
+					.public_queue_number -=
+					(u16)(total_required_page_num -
+					      *curr_free_space);
+				*curr_free_space = 0;
+			}
+
+			status = halmac_check_oqt_88xx(halmac_adapter,
+						       tx_agg_num, halmac_buf);
+
+			if (status != HALMAC_RET_SUCCESS)
+				return status;
+
+			break;
+		}
+
+		halmac_update_sdio_free_page_88xx(halmac_adapter);
+
+		counter--;
+		if (counter == 0)
+			return HALMAC_RET_FREE_SPACE_NOT_ENOUGH;
+	} while (1);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_reg_read_indirect_32_sdio_88xx() - read MAC reg by SDIO reg
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * Author : Soar
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+u32 halmac_reg_read_indirect_32_sdio_88xx(struct halmac_adapter *halmac_adapter,
+					  u32 halmac_offset)
+{
+	u8 rtemp;
+	u32 counter = 1000;
+	void *driver_adapter = NULL;
+
+	union {
+		u32 dword;
+		u8 byte[4];
+	} value32 = {0x00000000};
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	PLATFORM_SDIO_CMD53_WRITE_32(
+		driver_adapter,
+		(HALMAC_SDIO_CMD_ADDR_SDIO_REG << 13) |
+			(REG_SDIO_INDIRECT_REG_CFG & HALMAC_SDIO_LOCAL_MSK),
+		halmac_offset | BIT(19) | BIT(17));
+
+	do {
+		rtemp = PLATFORM_SDIO_CMD52_READ(
+			driver_adapter,
+			(HALMAC_SDIO_CMD_ADDR_SDIO_REG << 13) |
+				((REG_SDIO_INDIRECT_REG_CFG + 2) &
+				 HALMAC_SDIO_LOCAL_MSK));
+		counter--;
+	} while ((rtemp & BIT(4)) != 0 && counter > 0);
+
+	value32.dword = PLATFORM_SDIO_CMD53_READ_32(
+		driver_adapter,
+		(HALMAC_SDIO_CMD_ADDR_SDIO_REG << 13) |
+			(REG_SDIO_INDIRECT_REG_DATA & HALMAC_SDIO_LOCAL_MSK));
+
+	return value32.dword;
+}
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_sdio.h b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_sdio.h
new file mode 100644
index 000000000000..ee441eee24d6
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_sdio.h
@@ -0,0 +1,84 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_API_88XX_SDIO_H_
+#define _HALMAC_API_88XX_SDIO_H_
+
+#include "../halmac_2_platform.h"
+#include "../halmac_type.h"
+
+enum halmac_ret_status
+halmac_init_sdio_cfg_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_deinit_sdio_cfg_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_cfg_rx_aggregation_88xx_sdio(struct halmac_adapter *halmac_adapter,
+				    struct halmac_rxagg_cfg *phalmac_rxagg_cfg);
+
+u8 halmac_reg_read_8_sdio_88xx(struct halmac_adapter *halmac_adapter,
+			       u32 halmac_offset);
+
+enum halmac_ret_status
+halmac_reg_write_8_sdio_88xx(struct halmac_adapter *halmac_adapter,
+			     u32 halmac_offset, u8 halmac_data);
+
+u16 halmac_reg_read_16_sdio_88xx(struct halmac_adapter *halmac_adapter,
+				 u32 halmac_offset);
+
+enum halmac_ret_status
+halmac_reg_write_16_sdio_88xx(struct halmac_adapter *halmac_adapter,
+			      u32 halmac_offset, u16 halmac_data);
+
+u32 halmac_reg_read_32_sdio_88xx(struct halmac_adapter *halmac_adapter,
+				 u32 halmac_offset);
+
+enum halmac_ret_status
+halmac_reg_write_32_sdio_88xx(struct halmac_adapter *halmac_adapter,
+			      u32 halmac_offset, u32 halmac_data);
+
+enum halmac_ret_status
+halmac_get_sdio_tx_addr_88xx(struct halmac_adapter *halmac_adapter,
+			     u8 *halmac_buf, u32 halmac_size, u32 *pcmd53_addr);
+
+enum halmac_ret_status
+halmac_cfg_tx_agg_align_sdio_88xx(struct halmac_adapter *halmac_adapter,
+				  u8 enable, u16 align_size);
+
+enum halmac_ret_status halmac_cfg_tx_agg_align_sdio_not_support_88xx(
+	struct halmac_adapter *halmac_adapter, u8 enable, u16 align_size);
+
+enum halmac_ret_status
+halmac_tx_allowed_sdio_88xx(struct halmac_adapter *halmac_adapter,
+			    u8 *halmac_buf, u32 halmac_size);
+
+u32 halmac_reg_read_indirect_32_sdio_88xx(struct halmac_adapter *halmac_adapter,
+					  u32 halmac_offset);
+
+u8 halmac_reg_read_nbyte_sdio_88xx(struct halmac_adapter *halmac_adapter,
+				   u32 halmac_offset, u32 halmac_size,
+				   u8 *halmac_data);
+
+#endif /* _HALMAC_API_88XX_SDIO_H_ */
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_usb.c b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_usb.c
new file mode 100644
index 000000000000..17d7c3cc62ec
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_usb.c
@@ -0,0 +1,554 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "halmac_88xx_cfg.h"
+
+/**
+ * halmac_init_usb_cfg_88xx() - init USB
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_init_usb_cfg_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+	u8 value8 = 0;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_INIT_USB_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	value8 |= (BIT_DMA_MODE |
+		   (0x3 << BIT_SHIFT_BURST_CNT)); /* burst number = 4 */
+
+	if (PLATFORM_REG_READ_8(driver_adapter, REG_SYS_CFG2 + 3) ==
+	    0x20) { /* usb3.0 */
+		value8 |= (HALMAC_USB_BURST_SIZE_3_0 << BIT_SHIFT_BURST_SIZE);
+	} else {
+		if ((PLATFORM_REG_READ_8(driver_adapter, REG_USB_USBSTAT) &
+		     0x3) == 0x1) /* usb2.0 */
+			value8 |= HALMAC_USB_BURST_SIZE_2_0_HSPEED
+				  << BIT_SHIFT_BURST_SIZE;
+		else /* usb1.1 */
+			value8 |= HALMAC_USB_BURST_SIZE_2_0_FSPEED
+				  << BIT_SHIFT_BURST_SIZE;
+	}
+
+	PLATFORM_REG_WRITE_8(driver_adapter, REG_RXDMA_MODE, value8);
+	PLATFORM_REG_WRITE_16(
+		driver_adapter, REG_TXDMA_OFFSET_CHK,
+		PLATFORM_REG_READ_16(driver_adapter, REG_TXDMA_OFFSET_CHK) |
+			BIT_DROP_DATA_EN);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_deinit_usb_cfg_88xx() - deinit USB
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_deinit_usb_cfg_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_DEINIT_USB_CFG);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_rx_aggregation_88xx_usb() - config rx aggregation
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_rx_agg_mode
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_cfg_rx_aggregation_88xx_usb(struct halmac_adapter *halmac_adapter,
+				   struct halmac_rxagg_cfg *phalmac_rxagg_cfg)
+{
+	u8 dma_usb_agg;
+	u8 size = 0, timeout = 0, agg_enable = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_CFG_RX_AGGREGATION);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	dma_usb_agg =
+		HALMAC_REG_READ_8(halmac_adapter, REG_RXDMA_AGG_PG_TH + 3);
+	agg_enable = HALMAC_REG_READ_8(halmac_adapter, REG_TXDMA_PQ_MAP);
+
+	switch (phalmac_rxagg_cfg->mode) {
+	case HALMAC_RX_AGG_MODE_NONE:
+		agg_enable &= ~BIT_RXDMA_AGG_EN;
+		break;
+	case HALMAC_RX_AGG_MODE_DMA:
+		agg_enable |= BIT_RXDMA_AGG_EN;
+		dma_usb_agg |= BIT(7);
+		break;
+
+	case HALMAC_RX_AGG_MODE_USB:
+		agg_enable |= BIT_RXDMA_AGG_EN;
+		dma_usb_agg &= ~BIT(7);
+		break;
+	default:
+		pr_err("%s switch case not support\n", __func__);
+		agg_enable &= ~BIT_RXDMA_AGG_EN;
+		break;
+	}
+
+	if (!phalmac_rxagg_cfg->threshold.drv_define) {
+		if (PLATFORM_REG_READ_8(driver_adapter, REG_SYS_CFG2 + 3) ==
+		    0x20) {
+			/* usb3.0 */
+			size = 0x5;
+			timeout = 0xA;
+		} else {
+			/* usb2.0 */
+			size = 0x5;
+			timeout = 0x20;
+		}
+	} else {
+		size = phalmac_rxagg_cfg->threshold.size;
+		timeout = phalmac_rxagg_cfg->threshold.timeout;
+	}
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_TXDMA_PQ_MAP, agg_enable);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_RXDMA_AGG_PG_TH + 3,
+			   dma_usb_agg);
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_RXDMA_AGG_PG_TH,
+			    (u16)(size | (timeout << BIT_SHIFT_DMA_AGG_TO)));
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_reg_read_8_usb_88xx() - read 1byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+u8 halmac_reg_read_8_usb_88xx(struct halmac_adapter *halmac_adapter,
+			      u32 halmac_offset)
+{
+	u8 value8;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	value8 = PLATFORM_REG_READ_8(driver_adapter, halmac_offset);
+
+	return value8;
+}
+
+/**
+ * halmac_reg_write_8_usb_88xx() - write 1byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * @halmac_data : register value
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_reg_write_8_usb_88xx(struct halmac_adapter *halmac_adapter,
+			    u32 halmac_offset, u8 halmac_data)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	PLATFORM_REG_WRITE_8(driver_adapter, halmac_offset, halmac_data);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_reg_read_16_usb_88xx() - read 2byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+u16 halmac_reg_read_16_usb_88xx(struct halmac_adapter *halmac_adapter,
+				u32 halmac_offset)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	union {
+		u16 word;
+		u8 byte[2];
+	} value16 = {0x0000};
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	value16.word = PLATFORM_REG_READ_16(driver_adapter, halmac_offset);
+
+	return value16.word;
+}
+
+/**
+ * halmac_reg_write_16_usb_88xx() - write 2byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * @halmac_data : register value
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_reg_write_16_usb_88xx(struct halmac_adapter *halmac_adapter,
+			     u32 halmac_offset, u16 halmac_data)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	PLATFORM_REG_WRITE_16(driver_adapter, halmac_offset, halmac_data);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_reg_read_32_usb_88xx() - read 4byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+u32 halmac_reg_read_32_usb_88xx(struct halmac_adapter *halmac_adapter,
+				u32 halmac_offset)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	union {
+		u32 dword;
+		u8 byte[4];
+	} value32 = {0x00000000};
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	value32.dword = PLATFORM_REG_READ_32(driver_adapter, halmac_offset);
+
+	return value32.dword;
+}
+
+/**
+ * halmac_reg_write_32_usb_88xx() - write 4byte register
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_offset : register offset
+ * @halmac_data : register value
+ * Author : KaiYuan Chang/Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_reg_write_32_usb_88xx(struct halmac_adapter *halmac_adapter,
+			     u32 halmac_offset, u32 halmac_data)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	PLATFORM_REG_WRITE_32(driver_adapter, halmac_offset, halmac_data);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_set_bulkout_num_usb_88xx() - inform bulk-out num
+ * @halmac_adapter : the adapter of halmac
+ * @bulkout_num : usb bulk-out number
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_set_bulkout_num_88xx(struct halmac_adapter *halmac_adapter,
+			    u8 bulkout_num)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_SET_BULKOUT_NUM);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	halmac_adapter->halmac_bulkout_num = bulkout_num;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_get_usb_bulkout_id_usb_88xx() - get bulk out id for the TX packet
+ * @halmac_adapter : the adapter of halmac
+ * @halmac_buf : tx packet, include txdesc
+ * @halmac_size : tx packet size
+ * @bulkout_id : usb bulk-out id
+ * Author : KaiYuan Chang
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_get_usb_bulkout_id_88xx(struct halmac_adapter *halmac_adapter,
+			       u8 *halmac_buf, u32 halmac_size, u8 *bulkout_id)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_queue_select queue_sel;
+	enum halmac_dma_mapping dma_mapping;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter,
+				  HALMAC_API_GET_USB_BULKOUT_ID);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	if (!halmac_buf) {
+		pr_err("halmac_buf is NULL!!\n");
+		return HALMAC_RET_DATA_BUF_NULL;
+	}
+
+	if (halmac_size == 0) {
+		pr_err("halmac_size is 0!!\n");
+		return HALMAC_RET_DATA_SIZE_INCORRECT;
+	}
+
+	queue_sel = (enum halmac_queue_select)GET_TX_DESC_QSEL(halmac_buf);
+
+	switch (queue_sel) {
+	case HALMAC_QUEUE_SELECT_VO:
+	case HALMAC_QUEUE_SELECT_VO_V2:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_VO];
+		break;
+	case HALMAC_QUEUE_SELECT_VI:
+	case HALMAC_QUEUE_SELECT_VI_V2:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_VI];
+		break;
+	case HALMAC_QUEUE_SELECT_BE:
+	case HALMAC_QUEUE_SELECT_BE_V2:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_BE];
+		break;
+	case HALMAC_QUEUE_SELECT_BK:
+	case HALMAC_QUEUE_SELECT_BK_V2:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_BK];
+		break;
+	case HALMAC_QUEUE_SELECT_MGNT:
+		dma_mapping =
+			halmac_adapter->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_MG];
+		break;
+	case HALMAC_QUEUE_SELECT_HIGH:
+	case HALMAC_QUEUE_SELECT_BCN:
+	case HALMAC_QUEUE_SELECT_CMD:
+		dma_mapping = HALMAC_DMA_MAPPING_HIGH;
+		break;
+	default:
+		pr_err("Qsel is out of range\n");
+		return HALMAC_RET_QSEL_INCORRECT;
+	}
+
+	switch (dma_mapping) {
+	case HALMAC_DMA_MAPPING_HIGH:
+		*bulkout_id = 0;
+		break;
+	case HALMAC_DMA_MAPPING_NORMAL:
+		*bulkout_id = 1;
+		break;
+	case HALMAC_DMA_MAPPING_LOW:
+		*bulkout_id = 2;
+		break;
+	case HALMAC_DMA_MAPPING_EXTRA:
+		*bulkout_id = 3;
+		break;
+	default:
+		pr_err("DmaMapping is out of range\n");
+		return HALMAC_RET_DMA_MAP_INCORRECT;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_cfg_tx_agg_align_usb_88xx() -config sdio bus tx agg alignment
+ * @halmac_adapter : the adapter of halmac
+ * @enable : function enable(1)/disable(0)
+ * @align_size : sdio bus tx agg alignment size (2^n, n = 3~11)
+ * Author : Soar Tu
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status halmac_cfg_tx_agg_align_usb_not_support_88xx(
+	struct halmac_adapter *halmac_adapter, u8 enable, u16 align_size)
+{
+	struct halmac_api *halmac_api;
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	if (halmac_api_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_API_INVALID;
+
+	halmac_api_record_id_88xx(halmac_adapter, HALMAC_API_CFG_TX_AGG_ALIGN);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+		"%s ==========>\n", __func__);
+
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+		"%s not support\n", __func__);
+	HALMAC_RT_TRACE(
+		driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+		"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_usb.h b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_usb.h
new file mode 100644
index 000000000000..a3d2a6abd91b
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_api_88xx_usb.h
@@ -0,0 +1,73 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_API_88XX_USB_H_
+#define _HALMAC_API_88XX_USB_H_
+
+#include "../halmac_2_platform.h"
+#include "../halmac_type.h"
+
+enum halmac_ret_status
+halmac_init_usb_cfg_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_deinit_usb_cfg_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_cfg_rx_aggregation_88xx_usb(struct halmac_adapter *halmac_adapter,
+				   struct halmac_rxagg_cfg *phalmac_rxagg_cfg);
+
+u8 halmac_reg_read_8_usb_88xx(struct halmac_adapter *halmac_adapter,
+			      u32 halmac_offset);
+
+enum halmac_ret_status
+halmac_reg_write_8_usb_88xx(struct halmac_adapter *halmac_adapter,
+			    u32 halmac_offset, u8 halmac_data);
+
+u16 halmac_reg_read_16_usb_88xx(struct halmac_adapter *halmac_adapter,
+				u32 halmac_offset);
+
+enum halmac_ret_status
+halmac_reg_write_16_usb_88xx(struct halmac_adapter *halmac_adapter,
+			     u32 halmac_offset, u16 halmac_data);
+
+u32 halmac_reg_read_32_usb_88xx(struct halmac_adapter *halmac_adapter,
+				u32 halmac_offset);
+
+enum halmac_ret_status
+halmac_reg_write_32_usb_88xx(struct halmac_adapter *halmac_adapter,
+			     u32 halmac_offset, u32 halmac_data);
+
+enum halmac_ret_status
+halmac_set_bulkout_num_88xx(struct halmac_adapter *halmac_adapter,
+			    u8 bulkout_num);
+
+enum halmac_ret_status
+halmac_get_usb_bulkout_id_88xx(struct halmac_adapter *halmac_adapter,
+			       u8 *halmac_buf, u32 halmac_size, u8 *bulkout_id);
+
+enum halmac_ret_status halmac_cfg_tx_agg_align_usb_not_support_88xx(
+	struct halmac_adapter *halmac_adapter, u8 enable, u16 align_size);
+
+#endif /* _HALMAC_API_88XX_USB_H_ */
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_func_88xx.c b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_func_88xx.c
new file mode 100644
index 000000000000..cc39679aaa64
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_func_88xx.c
@@ -0,0 +1,4499 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "halmac_88xx_cfg.h"
+
+static enum halmac_ret_status
+halmac_dump_efuse_fw_88xx(struct halmac_adapter *halmac_adapter);
+
+static enum halmac_ret_status
+halmac_dump_efuse_drv_88xx(struct halmac_adapter *halmac_adapter);
+
+static enum halmac_ret_status
+halmac_update_eeprom_mask_88xx(struct halmac_adapter *halmac_adapter,
+			       struct halmac_pg_efuse_info *pg_efuse_info,
+			       u8 *eeprom_mask_updated);
+
+static enum halmac_ret_status
+halmac_check_efuse_enough_88xx(struct halmac_adapter *halmac_adapter,
+			       struct halmac_pg_efuse_info *pg_efuse_info,
+			       u8 *eeprom_mask_updated);
+
+static enum halmac_ret_status
+halmac_program_efuse_88xx(struct halmac_adapter *halmac_adapter,
+			  struct halmac_pg_efuse_info *pg_efuse_info,
+			  u8 *eeprom_mask_updated);
+
+static enum halmac_ret_status
+halmac_pwr_sub_seq_parer_88xx(struct halmac_adapter *halmac_adapter, u8 cut,
+			      u8 fab, u8 intf,
+			      struct halmac_wl_pwr_cfg_ *pwr_sub_seq_cfg);
+
+static enum halmac_ret_status
+halmac_parse_c2h_debug_88xx(struct halmac_adapter *halmac_adapter, u8 *c2h_buf,
+			    u32 c2h_size);
+
+static enum halmac_ret_status
+halmac_parse_scan_status_rpt_88xx(struct halmac_adapter *halmac_adapter,
+				  u8 *c2h_buf, u32 c2h_size);
+
+static enum halmac_ret_status
+halmac_parse_psd_data_88xx(struct halmac_adapter *halmac_adapter, u8 *c2h_buf,
+			   u32 c2h_size);
+
+static enum halmac_ret_status
+halmac_parse_efuse_data_88xx(struct halmac_adapter *halmac_adapter, u8 *c2h_buf,
+			     u32 c2h_size);
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_88xx(struct halmac_adapter *halmac_adapter, u8 *c2h_buf,
+			  u32 c2h_size);
+
+static enum halmac_ret_status
+halmac_enqueue_para_buff_88xx(struct halmac_adapter *halmac_adapter,
+			      struct halmac_phy_parameter_info *para_info,
+			      u8 *curr_buff_wptr, bool *end_cmd);
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_phy_efuse_88xx(struct halmac_adapter *halmac_adapter,
+				    u8 *c2h_buf, u32 c2h_size);
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_cfg_para_88xx(struct halmac_adapter *halmac_adapter,
+				   u8 *c2h_buf, u32 c2h_size);
+
+static enum halmac_ret_status
+halmac_gen_cfg_para_h2c_88xx(struct halmac_adapter *halmac_adapter,
+			     u8 *h2c_buff);
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_update_packet_88xx(struct halmac_adapter *halmac_adapter,
+					u8 *c2h_buf, u32 c2h_size);
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_update_datapack_88xx(struct halmac_adapter *halmac_adapter,
+					  u8 *c2h_buf, u32 c2h_size);
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_run_datapack_88xx(struct halmac_adapter *halmac_adapter,
+				       u8 *c2h_buf, u32 c2h_size);
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_channel_switch_88xx(struct halmac_adapter *halmac_adapter,
+					 u8 *c2h_buf, u32 c2h_size);
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_iqk_88xx(struct halmac_adapter *halmac_adapter,
+			      u8 *c2h_buf, u32 c2h_size);
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_power_tracking_88xx(struct halmac_adapter *halmac_adapter,
+					 u8 *c2h_buf, u32 c2h_size);
+
+void halmac_init_offload_feature_state_machine_88xx(
+	struct halmac_adapter *halmac_adapter)
+{
+	struct halmac_state *state = &halmac_adapter->halmac_state;
+
+	state->efuse_state_set.efuse_cmd_construct_state =
+		HALMAC_EFUSE_CMD_CONSTRUCT_IDLE;
+	state->efuse_state_set.process_status = HALMAC_CMD_PROCESS_IDLE;
+	state->efuse_state_set.seq_num = halmac_adapter->h2c_packet_seq;
+
+	state->cfg_para_state_set.cfg_para_cmd_construct_state =
+		HALMAC_CFG_PARA_CMD_CONSTRUCT_IDLE;
+	state->cfg_para_state_set.process_status = HALMAC_CMD_PROCESS_IDLE;
+	state->cfg_para_state_set.seq_num = halmac_adapter->h2c_packet_seq;
+
+	state->scan_state_set.scan_cmd_construct_state =
+		HALMAC_SCAN_CMD_CONSTRUCT_IDLE;
+	state->scan_state_set.process_status = HALMAC_CMD_PROCESS_IDLE;
+	state->scan_state_set.seq_num = halmac_adapter->h2c_packet_seq;
+
+	state->update_packet_set.process_status = HALMAC_CMD_PROCESS_IDLE;
+	state->update_packet_set.seq_num = halmac_adapter->h2c_packet_seq;
+
+	state->iqk_set.process_status = HALMAC_CMD_PROCESS_IDLE;
+	state->iqk_set.seq_num = halmac_adapter->h2c_packet_seq;
+
+	state->power_tracking_set.process_status = HALMAC_CMD_PROCESS_IDLE;
+	state->power_tracking_set.seq_num = halmac_adapter->h2c_packet_seq;
+
+	state->psd_set.process_status = HALMAC_CMD_PROCESS_IDLE;
+	state->psd_set.seq_num = halmac_adapter->h2c_packet_seq;
+	state->psd_set.data_size = 0;
+	state->psd_set.segment_size = 0;
+	state->psd_set.data = NULL;
+}
+
+enum halmac_ret_status
+halmac_dump_efuse_88xx(struct halmac_adapter *halmac_adapter,
+		       enum halmac_efuse_read_cfg cfg)
+{
+	u32 chk_h2c_init;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api =
+		(struct halmac_api *)halmac_adapter->halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	enum halmac_cmd_process_status *process_status =
+		&halmac_adapter->halmac_state.efuse_state_set.process_status;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	*process_status = HALMAC_CMD_PROCESS_SENDING;
+
+	if (halmac_transition_efuse_state_88xx(
+		    halmac_adapter, HALMAC_EFUSE_CMD_CONSTRUCT_H2C_SENT) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	if (cfg == HALMAC_EFUSE_R_AUTO) {
+		chk_h2c_init = HALMAC_REG_READ_32(halmac_adapter,
+						  REG_H2C_PKT_READADDR);
+		if (halmac_adapter->halmac_state.dlfw_state ==
+			    HALMAC_DLFW_NONE ||
+		    chk_h2c_init == 0)
+			status = halmac_dump_efuse_drv_88xx(halmac_adapter);
+		else
+			status = halmac_dump_efuse_fw_88xx(halmac_adapter);
+	} else if (cfg == HALMAC_EFUSE_R_FW) {
+		status = halmac_dump_efuse_fw_88xx(halmac_adapter);
+	} else {
+		status = halmac_dump_efuse_drv_88xx(halmac_adapter);
+	}
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_read_efuse error = %x\n", status);
+		return status;
+	}
+
+	return status;
+}
+
+enum halmac_ret_status
+halmac_func_read_efuse_88xx(struct halmac_adapter *halmac_adapter, u32 offset,
+			    u32 size, u8 *efuse_map)
+{
+	void *driver_adapter = NULL;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	if (!efuse_map) {
+		pr_err("Malloc for dump efuse map error\n");
+		return HALMAC_RET_NULL_POINTER;
+	}
+
+	if (halmac_adapter->hal_efuse_map_valid)
+		memcpy(efuse_map, halmac_adapter->hal_efuse_map + offset, size);
+	else if (halmac_read_hw_efuse_88xx(halmac_adapter, offset, size,
+					   efuse_map) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_EFUSE_R_FAIL;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_read_hw_efuse_88xx(struct halmac_adapter *halmac_adapter, u32 offset,
+			  u32 size, u8 *efuse_map)
+{
+	u8 value8;
+	u32 value32;
+	u32 address;
+	u32 tmp32, counter;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	/* Read efuse no need 2.5V LDO */
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_LDO_EFUSE_CTRL + 3);
+	if (value8 & BIT(7))
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_LDO_EFUSE_CTRL + 3,
+				   (u8)(value8 & ~(BIT(7))));
+
+	value32 = HALMAC_REG_READ_32(halmac_adapter, REG_EFUSE_CTRL);
+
+	for (address = offset; address < offset + size; address++) {
+		value32 = value32 &
+			  ~((BIT_MASK_EF_DATA) |
+			    (BIT_MASK_EF_ADDR << BIT_SHIFT_EF_ADDR));
+		value32 = value32 |
+			  ((address & BIT_MASK_EF_ADDR) << BIT_SHIFT_EF_ADDR);
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_EFUSE_CTRL,
+				    value32 & (~BIT_EF_FLAG));
+
+		counter = 1000000;
+		do {
+			udelay(1);
+			tmp32 = HALMAC_REG_READ_32(halmac_adapter,
+						   REG_EFUSE_CTRL);
+			counter--;
+			if (counter == 0) {
+				pr_err("HALMAC_RET_EFUSE_R_FAIL\n");
+				return HALMAC_RET_EFUSE_R_FAIL;
+			}
+		} while ((tmp32 & BIT_EF_FLAG) == 0);
+
+		*(efuse_map + address - offset) =
+			(u8)(tmp32 & BIT_MASK_EF_DATA);
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_dump_efuse_drv_88xx(struct halmac_adapter *halmac_adapter)
+{
+	u8 *efuse_map = NULL;
+	u32 efuse_size;
+	void *driver_adapter = NULL;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	efuse_size = halmac_adapter->hw_config_info.efuse_size;
+
+	if (!halmac_adapter->hal_efuse_map) {
+		halmac_adapter->hal_efuse_map = kzalloc(efuse_size, GFP_KERNEL);
+		if (!halmac_adapter->hal_efuse_map) {
+			pr_err("[ERR]halmac allocate efuse map Fail!!\n");
+			return HALMAC_RET_MALLOC_FAIL;
+		}
+	}
+
+	efuse_map = kzalloc(efuse_size, GFP_KERNEL);
+	if (!efuse_map) {
+		/* out of memory */
+		return HALMAC_RET_MALLOC_FAIL;
+	}
+
+	if (halmac_read_hw_efuse_88xx(halmac_adapter, 0, efuse_size,
+				      efuse_map) != HALMAC_RET_SUCCESS) {
+		kfree(efuse_map);
+		return HALMAC_RET_EFUSE_R_FAIL;
+	}
+
+	spin_lock(&halmac_adapter->efuse_lock);
+	memcpy(halmac_adapter->hal_efuse_map, efuse_map, efuse_size);
+	halmac_adapter->hal_efuse_map_valid = true;
+	spin_unlock(&halmac_adapter->efuse_lock);
+
+	kfree(efuse_map);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_dump_efuse_fw_88xx(struct halmac_adapter *halmac_adapter)
+{
+	u8 h2c_buff[HALMAC_H2C_CMD_SIZE_88XX] = {0};
+	u16 h2c_seq_mum = 0;
+	void *driver_adapter = NULL;
+	struct halmac_h2c_header_info h2c_header_info;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	h2c_header_info.sub_cmd_id = SUB_CMD_ID_DUMP_PHYSICAL_EFUSE;
+	h2c_header_info.content_size = 0;
+	h2c_header_info.ack = true;
+	halmac_set_fw_offload_h2c_header_88xx(halmac_adapter, h2c_buff,
+					      &h2c_header_info, &h2c_seq_mum);
+	halmac_adapter->halmac_state.efuse_state_set.seq_num = h2c_seq_mum;
+
+	if (!halmac_adapter->hal_efuse_map) {
+		halmac_adapter->hal_efuse_map = kzalloc(
+			halmac_adapter->hw_config_info.efuse_size, GFP_KERNEL);
+		if (!halmac_adapter->hal_efuse_map) {
+			/* out of memory */
+			return HALMAC_RET_MALLOC_FAIL;
+		}
+	}
+
+	if (!halmac_adapter->hal_efuse_map_valid) {
+		status = halmac_send_h2c_pkt_88xx(halmac_adapter, h2c_buff,
+						  HALMAC_H2C_CMD_SIZE_88XX,
+						  true);
+		if (status != HALMAC_RET_SUCCESS) {
+			pr_err("halmac_read_efuse_fw Fail = %x!!\n", status);
+			return status;
+		}
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_func_write_efuse_88xx(struct halmac_adapter *halmac_adapter, u32 offset,
+			     u8 value)
+{
+	const u8 wite_protect_code = 0x69;
+	u32 value32, tmp32, counter;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	spin_lock(&halmac_adapter->efuse_lock);
+	halmac_adapter->hal_efuse_map_valid = false;
+	spin_unlock(&halmac_adapter->efuse_lock);
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_PMC_DBG_CTRL2 + 3,
+			   wite_protect_code);
+
+	/* Enable 2.5V LDO */
+	HALMAC_REG_WRITE_8(
+		halmac_adapter, REG_LDO_EFUSE_CTRL + 3,
+		(u8)(HALMAC_REG_READ_8(halmac_adapter, REG_LDO_EFUSE_CTRL + 3) |
+		     BIT(7)));
+
+	value32 = HALMAC_REG_READ_32(halmac_adapter, REG_EFUSE_CTRL);
+	value32 =
+		value32 &
+		~((BIT_MASK_EF_DATA) | (BIT_MASK_EF_ADDR << BIT_SHIFT_EF_ADDR));
+	value32 = value32 | ((offset & BIT_MASK_EF_ADDR) << BIT_SHIFT_EF_ADDR) |
+		  (value & BIT_MASK_EF_DATA);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_EFUSE_CTRL,
+			    value32 | BIT_EF_FLAG);
+
+	counter = 1000000;
+	do {
+		udelay(1);
+		tmp32 = HALMAC_REG_READ_32(halmac_adapter, REG_EFUSE_CTRL);
+		counter--;
+		if (counter == 0) {
+			pr_err("halmac_write_efuse Fail !!\n");
+			return HALMAC_RET_EFUSE_W_FAIL;
+		}
+	} while ((tmp32 & BIT_EF_FLAG) == BIT_EF_FLAG);
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_PMC_DBG_CTRL2 + 3, 0x00);
+
+	/* Disable 2.5V LDO */
+	HALMAC_REG_WRITE_8(
+		halmac_adapter, REG_LDO_EFUSE_CTRL + 3,
+		(u8)(HALMAC_REG_READ_8(halmac_adapter, REG_LDO_EFUSE_CTRL + 3) &
+		     ~(BIT(7))));
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_func_switch_efuse_bank_88xx(struct halmac_adapter *halmac_adapter,
+				   enum halmac_efuse_bank efuse_bank)
+{
+	u8 reg_value;
+	struct halmac_api *halmac_api;
+
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if (halmac_transition_efuse_state_88xx(
+		    halmac_adapter, HALMAC_EFUSE_CMD_CONSTRUCT_BUSY) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	reg_value = HALMAC_REG_READ_8(halmac_adapter, REG_LDO_EFUSE_CTRL + 1);
+
+	if (efuse_bank == (reg_value & (BIT(0) | BIT(1))))
+		return HALMAC_RET_SUCCESS;
+
+	reg_value &= ~(BIT(0) | BIT(1));
+	reg_value |= efuse_bank;
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_LDO_EFUSE_CTRL + 1, reg_value);
+
+	if ((HALMAC_REG_READ_8(halmac_adapter, REG_LDO_EFUSE_CTRL + 1) &
+	     (BIT(0) | BIT(1))) != efuse_bank)
+		return HALMAC_RET_SWITCH_EFUSE_BANK_FAIL;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_eeprom_parser_88xx(struct halmac_adapter *halmac_adapter,
+			  u8 *physical_efuse_map, u8 *logical_efuse_map)
+{
+	u8 j;
+	u8 value8;
+	u8 block_index;
+	u8 valid_word_enable, word_enable;
+	u8 efuse_read_header, efuse_read_header2 = 0;
+	u32 eeprom_index;
+	u32 efuse_index = 0;
+	u32 eeprom_size = halmac_adapter->hw_config_info.eeprom_size;
+	void *driver_adapter = NULL;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	memset(logical_efuse_map, 0xFF, eeprom_size);
+
+	do {
+		value8 = *(physical_efuse_map + efuse_index);
+		efuse_read_header = value8;
+
+		if ((efuse_read_header & 0x1f) == 0x0f) {
+			efuse_index++;
+			value8 = *(physical_efuse_map + efuse_index);
+			efuse_read_header2 = value8;
+			block_index = ((efuse_read_header2 & 0xF0) >> 1) |
+				      ((efuse_read_header >> 5) & 0x07);
+			word_enable = efuse_read_header2 & 0x0F;
+		} else {
+			block_index = (efuse_read_header & 0xF0) >> 4;
+			word_enable = efuse_read_header & 0x0F;
+		}
+
+		if (efuse_read_header == 0xff)
+			break;
+
+		efuse_index++;
+
+		if (efuse_index >= halmac_adapter->hw_config_info.efuse_size -
+					   HALMAC_PROTECTED_EFUSE_SIZE_88XX - 1)
+			return HALMAC_RET_EEPROM_PARSING_FAIL;
+
+		for (j = 0; j < 4; j++) {
+			valid_word_enable =
+				(u8)((~(word_enable >> j)) & BIT(0));
+			if (valid_word_enable != 1)
+				continue;
+
+			eeprom_index = (block_index << 3) + (j << 1);
+
+			if ((eeprom_index + 1) > eeprom_size) {
+				pr_err("Error: EEPROM addr exceeds eeprom_size:0x%X, at eFuse 0x%X\n",
+				       eeprom_size, efuse_index - 1);
+				if ((efuse_read_header & 0x1f) == 0x0f)
+					pr_err("Error: EEPROM header: 0x%X, 0x%X,\n",
+					       efuse_read_header,
+					       efuse_read_header2);
+				else
+					pr_err("Error: EEPROM header: 0x%X,\n",
+					       efuse_read_header);
+
+				return HALMAC_RET_EEPROM_PARSING_FAIL;
+			}
+
+			value8 = *(physical_efuse_map + efuse_index);
+			*(logical_efuse_map + eeprom_index) = value8;
+
+			eeprom_index++;
+			efuse_index++;
+
+			if (efuse_index >
+			    halmac_adapter->hw_config_info.efuse_size -
+				    HALMAC_PROTECTED_EFUSE_SIZE_88XX - 1)
+				return HALMAC_RET_EEPROM_PARSING_FAIL;
+
+			value8 = *(physical_efuse_map + efuse_index);
+			*(logical_efuse_map + eeprom_index) = value8;
+
+			efuse_index++;
+
+			if (efuse_index >
+			    halmac_adapter->hw_config_info.efuse_size -
+				    HALMAC_PROTECTED_EFUSE_SIZE_88XX)
+				return HALMAC_RET_EEPROM_PARSING_FAIL;
+		}
+	} while (1);
+
+	halmac_adapter->efuse_end = efuse_index;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_read_logical_efuse_map_88xx(struct halmac_adapter *halmac_adapter,
+				   u8 *map)
+{
+	u8 *efuse_map = NULL;
+	u32 efuse_size;
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	efuse_size = halmac_adapter->hw_config_info.efuse_size;
+
+	if (!halmac_adapter->hal_efuse_map_valid) {
+		efuse_map = kzalloc(efuse_size, GFP_KERNEL);
+		if (!efuse_map) {
+			pr_err("[ERR]halmac allocate local efuse map Fail!!\n");
+			return HALMAC_RET_MALLOC_FAIL;
+		}
+
+		status = halmac_func_read_efuse_88xx(halmac_adapter, 0,
+						     efuse_size, efuse_map);
+		if (status != HALMAC_RET_SUCCESS) {
+			pr_err("[ERR]halmac_read_efuse error = %x\n", status);
+			kfree(efuse_map);
+			return status;
+		}
+
+		if (!halmac_adapter->hal_efuse_map) {
+			halmac_adapter->hal_efuse_map =
+				kzalloc(efuse_size, GFP_KERNEL);
+			if (!halmac_adapter->hal_efuse_map) {
+				pr_err("[ERR]halmac allocate efuse map Fail!!\n");
+				kfree(efuse_map);
+				return HALMAC_RET_MALLOC_FAIL;
+			}
+		}
+
+		spin_lock(&halmac_adapter->efuse_lock);
+		memcpy(halmac_adapter->hal_efuse_map, efuse_map, efuse_size);
+		halmac_adapter->hal_efuse_map_valid = true;
+		spin_unlock(&halmac_adapter->efuse_lock);
+
+		kfree(efuse_map);
+	}
+
+	if (halmac_eeprom_parser_88xx(halmac_adapter,
+				      halmac_adapter->hal_efuse_map,
+				      map) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_EEPROM_PARSING_FAIL;
+
+	return status;
+}
+
+enum halmac_ret_status
+halmac_func_write_logical_efuse_88xx(struct halmac_adapter *halmac_adapter,
+				     u32 offset, u8 value)
+{
+	u8 pg_efuse_byte1, pg_efuse_byte2;
+	u8 pg_block, pg_block_index;
+	u8 pg_efuse_header, pg_efuse_header2;
+	u8 *eeprom_map = NULL;
+	u32 eeprom_size = halmac_adapter->hw_config_info.eeprom_size;
+	u32 efuse_end, pg_efuse_num;
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	eeprom_map = kzalloc(eeprom_size, GFP_KERNEL);
+	if (!eeprom_map) {
+		/* out of memory */
+		return HALMAC_RET_MALLOC_FAIL;
+	}
+	memset(eeprom_map, 0xFF, eeprom_size);
+
+	status = halmac_read_logical_efuse_map_88xx(halmac_adapter, eeprom_map);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("[ERR]halmac_read_logical_efuse_map_88xx error = %x\n",
+		       status);
+		kfree(eeprom_map);
+		return status;
+	}
+
+	if (*(eeprom_map + offset) != value) {
+		efuse_end = halmac_adapter->efuse_end;
+		pg_block = (u8)(offset >> 3);
+		pg_block_index = (u8)((offset & (8 - 1)) >> 1);
+
+		if (offset > 0x7f) {
+			pg_efuse_header =
+				(((pg_block & 0x07) << 5) & 0xE0) | 0x0F;
+			pg_efuse_header2 =
+				(u8)(((pg_block & 0x78) << 1) +
+				     ((0x1 << pg_block_index) ^ 0x0F));
+		} else {
+			pg_efuse_header =
+				(u8)((pg_block << 4) +
+				     ((0x01 << pg_block_index) ^ 0x0F));
+		}
+
+		if ((offset & 1) == 0) {
+			pg_efuse_byte1 = value;
+			pg_efuse_byte2 = *(eeprom_map + offset + 1);
+		} else {
+			pg_efuse_byte1 = *(eeprom_map + offset - 1);
+			pg_efuse_byte2 = value;
+		}
+
+		if (offset > 0x7f) {
+			pg_efuse_num = 4;
+			if (halmac_adapter->hw_config_info.efuse_size <=
+			    (pg_efuse_num + HALMAC_PROTECTED_EFUSE_SIZE_88XX +
+			     halmac_adapter->efuse_end)) {
+				kfree(eeprom_map);
+				return HALMAC_RET_EFUSE_NOT_ENOUGH;
+			}
+			halmac_func_write_efuse_88xx(halmac_adapter, efuse_end,
+						     pg_efuse_header);
+			halmac_func_write_efuse_88xx(halmac_adapter,
+						     efuse_end + 1,
+						     pg_efuse_header2);
+			halmac_func_write_efuse_88xx(
+				halmac_adapter, efuse_end + 2, pg_efuse_byte1);
+			status = halmac_func_write_efuse_88xx(
+				halmac_adapter, efuse_end + 3, pg_efuse_byte2);
+		} else {
+			pg_efuse_num = 3;
+			if (halmac_adapter->hw_config_info.efuse_size <=
+			    (pg_efuse_num + HALMAC_PROTECTED_EFUSE_SIZE_88XX +
+			     halmac_adapter->efuse_end)) {
+				kfree(eeprom_map);
+				return HALMAC_RET_EFUSE_NOT_ENOUGH;
+			}
+			halmac_func_write_efuse_88xx(halmac_adapter, efuse_end,
+						     pg_efuse_header);
+			halmac_func_write_efuse_88xx(
+				halmac_adapter, efuse_end + 1, pg_efuse_byte1);
+			status = halmac_func_write_efuse_88xx(
+				halmac_adapter, efuse_end + 2, pg_efuse_byte2);
+		}
+
+		if (status != HALMAC_RET_SUCCESS) {
+			pr_err("[ERR]halmac_write_logical_efuse error = %x\n",
+			       status);
+			kfree(eeprom_map);
+			return status;
+		}
+	}
+
+	kfree(eeprom_map);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_func_pg_efuse_by_map_88xx(struct halmac_adapter *halmac_adapter,
+				 struct halmac_pg_efuse_info *pg_efuse_info,
+				 enum halmac_efuse_read_cfg cfg)
+{
+	u8 *eeprom_mask_updated = NULL;
+	u32 eeprom_mask_size = halmac_adapter->hw_config_info.eeprom_size >> 4;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	eeprom_mask_updated = kzalloc(eeprom_mask_size, GFP_KERNEL);
+	if (!eeprom_mask_updated) {
+		/* out of memory */
+		return HALMAC_RET_MALLOC_FAIL;
+	}
+	memset(eeprom_mask_updated, 0x00, eeprom_mask_size);
+
+	status = halmac_update_eeprom_mask_88xx(halmac_adapter, pg_efuse_info,
+						eeprom_mask_updated);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("[ERR]halmac_update_eeprom_mask_88xx error = %x\n",
+		       status);
+		kfree(eeprom_mask_updated);
+		return status;
+	}
+
+	status = halmac_check_efuse_enough_88xx(halmac_adapter, pg_efuse_info,
+						eeprom_mask_updated);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("[ERR]halmac_check_efuse_enough_88xx error = %x\n",
+		       status);
+		kfree(eeprom_mask_updated);
+		return status;
+	}
+
+	status = halmac_program_efuse_88xx(halmac_adapter, pg_efuse_info,
+					   eeprom_mask_updated);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("[ERR]halmac_program_efuse_88xx error = %x\n", status);
+		kfree(eeprom_mask_updated);
+		return status;
+	}
+
+	kfree(eeprom_mask_updated);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_update_eeprom_mask_88xx(struct halmac_adapter *halmac_adapter,
+			       struct halmac_pg_efuse_info *pg_efuse_info,
+			       u8 *eeprom_mask_updated)
+{
+	u8 *eeprom_map = NULL;
+	u32 eeprom_size = halmac_adapter->hw_config_info.eeprom_size;
+	u8 *eeprom_map_pg, *eeprom_mask;
+	u16 i, j;
+	u16 map_byte_offset, mask_byte_offset;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	void *driver_adapter = NULL;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	eeprom_map = kzalloc(eeprom_size, GFP_KERNEL);
+	if (!eeprom_map) {
+		/* out of memory */
+		return HALMAC_RET_MALLOC_FAIL;
+	}
+	memset(eeprom_map, 0xFF, eeprom_size);
+
+	memset(eeprom_mask_updated, 0x00, pg_efuse_info->efuse_mask_size);
+
+	status = halmac_read_logical_efuse_map_88xx(halmac_adapter, eeprom_map);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		kfree(eeprom_map);
+		return status;
+	}
+
+	eeprom_map_pg = pg_efuse_info->efuse_map;
+	eeprom_mask = pg_efuse_info->efuse_mask;
+
+	for (i = 0; i < pg_efuse_info->efuse_mask_size; i++)
+		*(eeprom_mask_updated + i) = *(eeprom_mask + i);
+
+	for (i = 0; i < pg_efuse_info->efuse_map_size; i = i + 16) {
+		for (j = 0; j < 16; j = j + 2) {
+			map_byte_offset = i + j;
+			mask_byte_offset = i >> 4;
+			if (*(eeprom_map_pg + map_byte_offset) ==
+			    *(eeprom_map + map_byte_offset)) {
+				if (*(eeprom_map_pg + map_byte_offset + 1) ==
+				    *(eeprom_map + map_byte_offset + 1)) {
+					switch (j) {
+					case 0:
+						*(eeprom_mask_updated +
+						  mask_byte_offset) =
+							*(eeprom_mask_updated +
+							  mask_byte_offset) &
+							(BIT(4) ^ 0xFF);
+						break;
+					case 2:
+						*(eeprom_mask_updated +
+						  mask_byte_offset) =
+							*(eeprom_mask_updated +
+							  mask_byte_offset) &
+							(BIT(5) ^ 0xFF);
+						break;
+					case 4:
+						*(eeprom_mask_updated +
+						  mask_byte_offset) =
+							*(eeprom_mask_updated +
+							  mask_byte_offset) &
+							(BIT(6) ^ 0xFF);
+						break;
+					case 6:
+						*(eeprom_mask_updated +
+						  mask_byte_offset) =
+							*(eeprom_mask_updated +
+							  mask_byte_offset) &
+							(BIT(7) ^ 0xFF);
+						break;
+					case 8:
+						*(eeprom_mask_updated +
+						  mask_byte_offset) =
+							*(eeprom_mask_updated +
+							  mask_byte_offset) &
+							(BIT(0) ^ 0xFF);
+						break;
+					case 10:
+						*(eeprom_mask_updated +
+						  mask_byte_offset) =
+							*(eeprom_mask_updated +
+							  mask_byte_offset) &
+							(BIT(1) ^ 0xFF);
+						break;
+					case 12:
+						*(eeprom_mask_updated +
+						  mask_byte_offset) =
+							*(eeprom_mask_updated +
+							  mask_byte_offset) &
+							(BIT(2) ^ 0xFF);
+						break;
+					case 14:
+						*(eeprom_mask_updated +
+						  mask_byte_offset) =
+							*(eeprom_mask_updated +
+							  mask_byte_offset) &
+							(BIT(3) ^ 0xFF);
+						break;
+					default:
+						break;
+					}
+				}
+			}
+		}
+	}
+
+	kfree(eeprom_map);
+
+	return status;
+}
+
+static enum halmac_ret_status
+halmac_check_efuse_enough_88xx(struct halmac_adapter *halmac_adapter,
+			       struct halmac_pg_efuse_info *pg_efuse_info,
+			       u8 *eeprom_mask_updated)
+{
+	u8 pre_word_enb, word_enb;
+	u8 pg_efuse_header, pg_efuse_header2;
+	u8 pg_block;
+	u16 i, j;
+	u32 efuse_end;
+	u32 tmp_eeprom_offset, pg_efuse_num = 0;
+
+	efuse_end = halmac_adapter->efuse_end;
+
+	for (i = 0; i < pg_efuse_info->efuse_map_size; i = i + 8) {
+		tmp_eeprom_offset = i;
+
+		if ((tmp_eeprom_offset & 7) > 0) {
+			pre_word_enb =
+				(*(eeprom_mask_updated + (i >> 4)) & 0x0F);
+			word_enb = pre_word_enb ^ 0x0F;
+		} else {
+			pre_word_enb = (*(eeprom_mask_updated + (i >> 4)) >> 4);
+			word_enb = pre_word_enb ^ 0x0F;
+		}
+
+		pg_block = (u8)(tmp_eeprom_offset >> 3);
+
+		if (pre_word_enb > 0) {
+			if (tmp_eeprom_offset > 0x7f) {
+				pg_efuse_header =
+					(((pg_block & 0x07) << 5) & 0xE0) |
+					0x0F;
+				pg_efuse_header2 = (u8)(
+					((pg_block & 0x78) << 1) + word_enb);
+			} else {
+				pg_efuse_header =
+					(u8)((pg_block << 4) + word_enb);
+			}
+
+			if (tmp_eeprom_offset > 0x7f) {
+				pg_efuse_num++;
+				pg_efuse_num++;
+				efuse_end = efuse_end + 2;
+				for (j = 0; j < 4; j++) {
+					if (((pre_word_enb >> j) & 0x1) > 0) {
+						pg_efuse_num++;
+						pg_efuse_num++;
+						efuse_end = efuse_end + 2;
+					}
+				}
+			} else {
+				pg_efuse_num++;
+				efuse_end = efuse_end + 1;
+				for (j = 0; j < 4; j++) {
+					if (((pre_word_enb >> j) & 0x1) > 0) {
+						pg_efuse_num++;
+						pg_efuse_num++;
+						efuse_end = efuse_end + 2;
+					}
+				}
+			}
+		}
+	}
+
+	if (halmac_adapter->hw_config_info.efuse_size <=
+	    (pg_efuse_num + HALMAC_PROTECTED_EFUSE_SIZE_88XX +
+	     halmac_adapter->efuse_end))
+		return HALMAC_RET_EFUSE_NOT_ENOUGH;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_program_efuse_88xx(struct halmac_adapter *halmac_adapter,
+			  struct halmac_pg_efuse_info *pg_efuse_info,
+			  u8 *eeprom_mask_updated)
+{
+	u8 pre_word_enb, word_enb;
+	u8 pg_efuse_header, pg_efuse_header2;
+	u8 pg_block;
+	u16 i, j;
+	u32 efuse_end;
+	u32 tmp_eeprom_offset;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	efuse_end = halmac_adapter->efuse_end;
+
+	for (i = 0; i < pg_efuse_info->efuse_map_size; i = i + 8) {
+		tmp_eeprom_offset = i;
+
+		if (((tmp_eeprom_offset >> 3) & 1) > 0) {
+			pre_word_enb =
+				(*(eeprom_mask_updated + (i >> 4)) & 0x0F);
+			word_enb = pre_word_enb ^ 0x0F;
+		} else {
+			pre_word_enb = (*(eeprom_mask_updated + (i >> 4)) >> 4);
+			word_enb = pre_word_enb ^ 0x0F;
+		}
+
+		pg_block = (u8)(tmp_eeprom_offset >> 3);
+
+		if (pre_word_enb <= 0)
+			continue;
+
+		if (tmp_eeprom_offset > 0x7f) {
+			pg_efuse_header =
+				(((pg_block & 0x07) << 5) & 0xE0) | 0x0F;
+			pg_efuse_header2 =
+				(u8)(((pg_block & 0x78) << 1) + word_enb);
+		} else {
+			pg_efuse_header = (u8)((pg_block << 4) + word_enb);
+		}
+
+		if (tmp_eeprom_offset > 0x7f) {
+			halmac_func_write_efuse_88xx(halmac_adapter, efuse_end,
+						     pg_efuse_header);
+			status = halmac_func_write_efuse_88xx(halmac_adapter,
+							      efuse_end + 1,
+							      pg_efuse_header2);
+			efuse_end = efuse_end + 2;
+			for (j = 0; j < 4; j++) {
+				if (((pre_word_enb >> j) & 0x1) > 0) {
+					halmac_func_write_efuse_88xx(
+						halmac_adapter, efuse_end,
+						*(pg_efuse_info->efuse_map +
+						  tmp_eeprom_offset +
+						  (j << 1)));
+					status = halmac_func_write_efuse_88xx(
+						halmac_adapter, efuse_end + 1,
+						*(pg_efuse_info->efuse_map +
+						  tmp_eeprom_offset + (j << 1) +
+						  1));
+					efuse_end = efuse_end + 2;
+				}
+			}
+		} else {
+			status = halmac_func_write_efuse_88xx(
+				halmac_adapter, efuse_end, pg_efuse_header);
+			efuse_end = efuse_end + 1;
+			for (j = 0; j < 4; j++) {
+				if (((pre_word_enb >> j) & 0x1) > 0) {
+					halmac_func_write_efuse_88xx(
+						halmac_adapter, efuse_end,
+						*(pg_efuse_info->efuse_map +
+						  tmp_eeprom_offset +
+						  (j << 1)));
+					status = halmac_func_write_efuse_88xx(
+						halmac_adapter, efuse_end + 1,
+						*(pg_efuse_info->efuse_map +
+						  tmp_eeprom_offset + (j << 1) +
+						  1));
+					efuse_end = efuse_end + 2;
+				}
+			}
+		}
+	}
+
+	return status;
+}
+
+enum halmac_ret_status
+halmac_dlfw_to_mem_88xx(struct halmac_adapter *halmac_adapter, u8 *ram_code,
+			u32 dest, u32 code_size)
+{
+	u8 *code_ptr;
+	u8 first_part;
+	u32 mem_offset;
+	u32 pkt_size_tmp, send_pkt_size;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	code_ptr = ram_code;
+	mem_offset = 0;
+	first_part = 1;
+	pkt_size_tmp = code_size;
+
+	HALMAC_REG_WRITE_32(
+		halmac_adapter, REG_DDMA_CH0CTRL,
+		HALMAC_REG_READ_32(halmac_adapter, REG_DDMA_CH0CTRL) |
+			BIT_DDMACH0_RESET_CHKSUM_STS);
+
+	while (pkt_size_tmp != 0) {
+		if (pkt_size_tmp >= halmac_adapter->max_download_size)
+			send_pkt_size = halmac_adapter->max_download_size;
+		else
+			send_pkt_size = pkt_size_tmp;
+
+		if (halmac_send_fwpkt_88xx(
+			    halmac_adapter, code_ptr + mem_offset,
+			    send_pkt_size) != HALMAC_RET_SUCCESS) {
+			pr_err("halmac_send_fwpkt_88xx fail!!");
+			return HALMAC_RET_DLFW_FAIL;
+		}
+
+		if (halmac_iddma_dlfw_88xx(
+			    halmac_adapter,
+			    HALMAC_OCPBASE_TXBUF_88XX +
+				    halmac_adapter->hw_config_info.txdesc_size,
+			    dest + mem_offset, send_pkt_size,
+			    first_part) != HALMAC_RET_SUCCESS) {
+			pr_err("halmac_iddma_dlfw_88xx fail!!");
+			return HALMAC_RET_DLFW_FAIL;
+		}
+
+		first_part = 0;
+		mem_offset += send_pkt_size;
+		pkt_size_tmp -= send_pkt_size;
+	}
+
+	if (halmac_check_fw_chksum_88xx(halmac_adapter, dest) !=
+	    HALMAC_RET_SUCCESS) {
+		pr_err("halmac_check_fw_chksum_88xx fail!!");
+		return HALMAC_RET_DLFW_FAIL;
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_send_fwpkt_88xx(struct halmac_adapter *halmac_adapter, u8 *ram_code,
+		       u32 code_size)
+{
+	if (halmac_download_rsvd_page_88xx(halmac_adapter, ram_code,
+					   code_size) != HALMAC_RET_SUCCESS) {
+		pr_err("PLATFORM_SEND_RSVD_PAGE 0 error!!\n");
+		return HALMAC_RET_DL_RSVD_PAGE_FAIL;
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_iddma_dlfw_88xx(struct halmac_adapter *halmac_adapter, u32 source,
+		       u32 dest, u32 length, u8 first)
+{
+	u32 counter;
+	u32 ch0_control = (u32)(BIT_DDMACH0_CHKSUM_EN | BIT_DDMACH0_OWN);
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	counter = HALMC_DDMA_POLLING_COUNT;
+	while (HALMAC_REG_READ_32(halmac_adapter, REG_DDMA_CH0CTRL) &
+	       BIT_DDMACH0_OWN) {
+		counter--;
+		if (counter == 0) {
+			pr_err("%s error-1!!\n", __func__);
+			return HALMAC_RET_DDMA_FAIL;
+		}
+	}
+
+	ch0_control |= (length & BIT_MASK_DDMACH0_DLEN);
+	if (first == 0)
+		ch0_control |= BIT_DDMACH0_CHKSUM_CONT;
+
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_DDMA_CH0SA, source);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_DDMA_CH0DA, dest);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_DDMA_CH0CTRL, ch0_control);
+
+	counter = HALMC_DDMA_POLLING_COUNT;
+	while (HALMAC_REG_READ_32(halmac_adapter, REG_DDMA_CH0CTRL) &
+	       BIT_DDMACH0_OWN) {
+		counter--;
+		if (counter == 0) {
+			pr_err("%s error-2!!\n", __func__);
+			return HALMAC_RET_DDMA_FAIL;
+		}
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_check_fw_chksum_88xx(struct halmac_adapter *halmac_adapter,
+			    u32 memory_address)
+{
+	u8 mcu_fw_ctrl;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	mcu_fw_ctrl = HALMAC_REG_READ_8(halmac_adapter, REG_MCUFW_CTRL);
+
+	if (HALMAC_REG_READ_32(halmac_adapter, REG_DDMA_CH0CTRL) &
+	    BIT_DDMACH0_CHKSUM_STS) {
+		if (memory_address < HALMAC_OCPBASE_DMEM_88XX) {
+			mcu_fw_ctrl |= BIT_IMEM_DW_OK;
+			HALMAC_REG_WRITE_8(
+				halmac_adapter, REG_MCUFW_CTRL,
+				(u8)(mcu_fw_ctrl & ~(BIT_IMEM_CHKSUM_OK)));
+		} else {
+			mcu_fw_ctrl |= BIT_DMEM_DW_OK;
+			HALMAC_REG_WRITE_8(
+				halmac_adapter, REG_MCUFW_CTRL,
+				(u8)(mcu_fw_ctrl & ~(BIT_DMEM_CHKSUM_OK)));
+		}
+
+		pr_err("%s error!!\n", __func__);
+
+		status = HALMAC_RET_FW_CHECKSUM_FAIL;
+	} else {
+		if (memory_address < HALMAC_OCPBASE_DMEM_88XX) {
+			mcu_fw_ctrl |= BIT_IMEM_DW_OK;
+			HALMAC_REG_WRITE_8(
+				halmac_adapter, REG_MCUFW_CTRL,
+				(u8)(mcu_fw_ctrl | BIT_IMEM_CHKSUM_OK));
+		} else {
+			mcu_fw_ctrl |= BIT_DMEM_DW_OK;
+			HALMAC_REG_WRITE_8(
+				halmac_adapter, REG_MCUFW_CTRL,
+				(u8)(mcu_fw_ctrl | BIT_DMEM_CHKSUM_OK));
+		}
+
+		status = HALMAC_RET_SUCCESS;
+	}
+
+	return status;
+}
+
+enum halmac_ret_status
+halmac_dlfw_end_flow_88xx(struct halmac_adapter *halmac_adapter)
+{
+	u8 value8;
+	u32 counter;
+	void *driver_adapter = halmac_adapter->driver_adapter;
+	struct halmac_api *halmac_api =
+		(struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_TXDMA_STATUS, BIT(2));
+
+	/* Check IMEM & DMEM checksum is OK or not */
+	if ((HALMAC_REG_READ_8(halmac_adapter, REG_MCUFW_CTRL) & 0x50) == 0x50)
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_MCUFW_CTRL,
+				    (u16)(HALMAC_REG_READ_16(halmac_adapter,
+							     REG_MCUFW_CTRL) |
+					  BIT_FW_DW_RDY));
+	else
+		return HALMAC_RET_DLFW_FAIL;
+
+	HALMAC_REG_WRITE_8(
+		halmac_adapter, REG_MCUFW_CTRL,
+		(u8)(HALMAC_REG_READ_8(halmac_adapter, REG_MCUFW_CTRL) &
+		     ~(BIT(0))));
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_RSV_CTRL + 1);
+	value8 = (u8)(value8 | BIT(0));
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_RSV_CTRL + 1, value8);
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_SYS_FUNC_EN + 1);
+	value8 = (u8)(value8 | BIT(2));
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_SYS_FUNC_EN + 1,
+			   value8); /* Release MCU reset */
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"Download Finish, Reset CPU\n");
+
+	counter = 10000;
+	while (HALMAC_REG_READ_16(halmac_adapter, REG_MCUFW_CTRL) != 0xC078) {
+		if (counter == 0) {
+			pr_err("Check 0x80 = 0xC078 fail\n");
+			if ((HALMAC_REG_READ_32(halmac_adapter, REG_FW_DBG7) &
+			     0xFFFFFF00) == 0xFAAAAA00)
+				pr_err("Key fail\n");
+			return HALMAC_RET_DLFW_FAIL;
+		}
+		counter--;
+		usleep_range(50, 60);
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"Check 0x80 = 0xC078 counter = %d\n", counter);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_free_dl_fw_end_flow_88xx(struct halmac_adapter *halmac_adapter)
+{
+	u32 counter;
+	struct halmac_api *halmac_api =
+		(struct halmac_api *)halmac_adapter->halmac_api;
+
+	counter = 100;
+	while (HALMAC_REG_READ_8(halmac_adapter, REG_HMETFR + 3) != 0) {
+		counter--;
+		if (counter == 0) {
+			pr_err("[ERR]0x1CF != 0\n");
+			return HALMAC_RET_DLFW_FAIL;
+		}
+		usleep_range(50, 60);
+	}
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_HMETFR + 3,
+			   ID_INFORM_DLEMEM_RDY);
+
+	counter = 10000;
+	while (HALMAC_REG_READ_8(halmac_adapter, REG_C2HEVT_3 + 3) !=
+	       ID_INFORM_DLEMEM_RDY) {
+		counter--;
+		if (counter == 0) {
+			pr_err("[ERR]0x1AF != 0x80\n");
+			return HALMAC_RET_DLFW_FAIL;
+		}
+		usleep_range(50, 60);
+	}
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_C2HEVT_3 + 3, 0);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_pwr_seq_parser_88xx(struct halmac_adapter *halmac_adapter, u8 cut,
+			   u8 fab, u8 intf,
+			   struct halmac_wl_pwr_cfg_ **pp_pwr_seq_cfg)
+{
+	u32 seq_idx = 0;
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	struct halmac_wl_pwr_cfg_ *seq_cmd;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	do {
+		seq_cmd = pp_pwr_seq_cfg[seq_idx];
+
+		if (!seq_cmd)
+			break;
+
+		status = halmac_pwr_sub_seq_parer_88xx(halmac_adapter, cut, fab,
+						       intf, seq_cmd);
+		if (status != HALMAC_RET_SUCCESS) {
+			pr_err("[Err]pwr sub seq parser fail, status = 0x%X!\n",
+			       status);
+			return status;
+		}
+
+		seq_idx++;
+	} while (1);
+
+	return status;
+}
+
+static enum halmac_ret_status
+halmac_pwr_sub_seq_parer_do_cmd_88xx(struct halmac_adapter *halmac_adapter,
+				     struct halmac_wl_pwr_cfg_ *sub_seq_cmd,
+				     bool *reti)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	u8 value, flag;
+	u8 polling_bit;
+	u32 polling_count;
+	static u32 poll_to_static;
+	u32 offset;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+	*reti = true;
+
+	switch (sub_seq_cmd->cmd) {
+	case HALMAC_PWR_CMD_WRITE:
+		if (sub_seq_cmd->base == HALMAC_PWR_BASEADDR_SDIO)
+			offset = sub_seq_cmd->offset | SDIO_LOCAL_OFFSET;
+		else
+			offset = sub_seq_cmd->offset;
+
+		value = HALMAC_REG_READ_8(halmac_adapter, offset);
+		value = (u8)(value & (u8)(~(sub_seq_cmd->msk)));
+		value = (u8)(value |
+			     (u8)(sub_seq_cmd->value & sub_seq_cmd->msk));
+
+		HALMAC_REG_WRITE_8(halmac_adapter, offset, value);
+		break;
+	case HALMAC_PWR_CMD_POLLING:
+		polling_bit = 0;
+		polling_count = HALMAC_POLLING_READY_TIMEOUT_COUNT;
+		flag = 0;
+
+		if (sub_seq_cmd->base == HALMAC_PWR_BASEADDR_SDIO)
+			offset = sub_seq_cmd->offset | SDIO_LOCAL_OFFSET;
+		else
+			offset = sub_seq_cmd->offset;
+
+		do {
+			polling_count--;
+			value = HALMAC_REG_READ_8(halmac_adapter, offset);
+			value = (u8)(value & sub_seq_cmd->msk);
+
+			if (value == (sub_seq_cmd->value & sub_seq_cmd->msk)) {
+				polling_bit = 1;
+				continue;
+			}
+
+			if (polling_count != 0) {
+				usleep_range(50, 60);
+				continue;
+			}
+
+			if (halmac_adapter->halmac_interface ==
+				    HALMAC_INTERFACE_PCIE &&
+			    flag == 0) {
+				/* For PCIE + USB package poll power bit
+				 * timeout issue
+				 */
+				poll_to_static++;
+				HALMAC_RT_TRACE(
+					driver_adapter, HALMAC_MSG_PWR,
+					DBG_WARNING,
+					"[WARN]PCIE polling timeout : %d!!\n",
+					poll_to_static);
+				HALMAC_REG_WRITE_8(
+					halmac_adapter, REG_SYS_PW_CTRL,
+					HALMAC_REG_READ_8(halmac_adapter,
+							  REG_SYS_PW_CTRL) |
+						BIT(3));
+				HALMAC_REG_WRITE_8(
+					halmac_adapter, REG_SYS_PW_CTRL,
+					HALMAC_REG_READ_8(halmac_adapter,
+							  REG_SYS_PW_CTRL) &
+						~BIT(3));
+				polling_bit = 0;
+				polling_count =
+					HALMAC_POLLING_READY_TIMEOUT_COUNT;
+				flag = 1;
+			} else {
+				pr_err("[ERR]Pwr cmd polling timeout!!\n");
+				pr_err("[ERR]Pwr cmd offset : %X!!\n",
+				       sub_seq_cmd->offset);
+				pr_err("[ERR]Pwr cmd value : %X!!\n",
+				       sub_seq_cmd->value);
+				pr_err("[ERR]Pwr cmd msk : %X!!\n",
+				       sub_seq_cmd->msk);
+				pr_err("[ERR]Read offset = %X value = %X!!\n",
+				       offset, value);
+				return HALMAC_RET_PWRSEQ_POLLING_FAIL;
+			}
+		} while (!polling_bit);
+		break;
+	case HALMAC_PWR_CMD_DELAY:
+		if (sub_seq_cmd->value == HALMAC_PWRSEQ_DELAY_US)
+			udelay(sub_seq_cmd->offset);
+		else
+			usleep_range(1000 * sub_seq_cmd->offset,
+				     1000 * sub_seq_cmd->offset + 100);
+
+		break;
+	case HALMAC_PWR_CMD_READ:
+		break;
+	case HALMAC_PWR_CMD_END:
+		return HALMAC_RET_SUCCESS;
+	default:
+		return HALMAC_RET_PWRSEQ_CMD_INCORRECT;
+	}
+
+	*reti = false;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_pwr_sub_seq_parer_88xx(struct halmac_adapter *halmac_adapter, u8 cut,
+			      u8 fab, u8 intf,
+			      struct halmac_wl_pwr_cfg_ *pwr_sub_seq_cfg)
+{
+	struct halmac_wl_pwr_cfg_ *sub_seq_cmd;
+	bool reti;
+	enum halmac_ret_status status;
+
+	for (sub_seq_cmd = pwr_sub_seq_cfg;; sub_seq_cmd++) {
+		if ((sub_seq_cmd->interface_msk & intf) &&
+		    (sub_seq_cmd->fab_msk & fab) &&
+		    (sub_seq_cmd->cut_msk & cut)) {
+			status = halmac_pwr_sub_seq_parer_do_cmd_88xx(
+				halmac_adapter, sub_seq_cmd, &reti);
+
+			if (reti)
+				return status;
+		}
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_get_h2c_buff_free_space_88xx(struct halmac_adapter *halmac_adapter)
+{
+	u32 hw_wptr, fw_rptr;
+	struct halmac_api *halmac_api =
+		(struct halmac_api *)halmac_adapter->halmac_api;
+
+	hw_wptr = HALMAC_REG_READ_32(halmac_adapter, REG_H2C_PKT_WRITEADDR) &
+		  BIT_MASK_H2C_WR_ADDR;
+	fw_rptr = HALMAC_REG_READ_32(halmac_adapter, REG_H2C_PKT_READADDR) &
+		  BIT_MASK_H2C_READ_ADDR;
+
+	if (hw_wptr >= fw_rptr)
+		halmac_adapter->h2c_buf_free_space =
+			halmac_adapter->h2c_buff_size - (hw_wptr - fw_rptr);
+	else
+		halmac_adapter->h2c_buf_free_space = fw_rptr - hw_wptr;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_send_h2c_pkt_88xx(struct halmac_adapter *halmac_adapter, u8 *hal_h2c_cmd,
+			 u32 size, bool ack)
+{
+	u32 counter = 100;
+	void *driver_adapter = halmac_adapter->driver_adapter;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	while (halmac_adapter->h2c_buf_free_space <=
+	       HALMAC_H2C_CMD_SIZE_UNIT_88XX) {
+		halmac_get_h2c_buff_free_space_88xx(halmac_adapter);
+		counter--;
+		if (counter == 0) {
+			pr_err("h2c free space is not enough!!\n");
+			return HALMAC_RET_H2C_SPACE_FULL;
+		}
+	}
+
+	/* Send TxDesc + H2C_CMD */
+	if (!PLATFORM_SEND_H2C_PKT(driver_adapter, hal_h2c_cmd, size)) {
+		pr_err("Send H2C_CMD pkt error!!\n");
+		return HALMAC_RET_SEND_H2C_FAIL;
+	}
+
+	halmac_adapter->h2c_buf_free_space -= HALMAC_H2C_CMD_SIZE_UNIT_88XX;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"H2C free space : %d\n",
+			halmac_adapter->h2c_buf_free_space);
+
+	return status;
+}
+
+enum halmac_ret_status
+halmac_download_rsvd_page_88xx(struct halmac_adapter *halmac_adapter,
+			       u8 *hal_buf, u32 size)
+{
+	u8 restore[3];
+	u8 value8;
+	u32 counter;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if (size == 0) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+				"Rsvd page packet size is zero!!\n");
+		return HALMAC_RET_ZERO_LEN_RSVD_PACKET;
+	}
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_FIFOPAGE_CTRL_2 + 1);
+	value8 = (u8)(value8 | BIT(7));
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_FIFOPAGE_CTRL_2 + 1, value8);
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_CR + 1);
+	restore[0] = value8;
+	value8 = (u8)(value8 | BIT(0));
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_CR + 1, value8);
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_BCN_CTRL);
+	restore[1] = value8;
+	value8 = (u8)((value8 & ~(BIT(3))) | BIT(4));
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_BCN_CTRL, value8);
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_FWHW_TXQ_CTRL + 2);
+	restore[2] = value8;
+	value8 = (u8)(value8 & ~(BIT(6)));
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_FWHW_TXQ_CTRL + 2, value8);
+
+	if (!PLATFORM_SEND_RSVD_PAGE(driver_adapter, hal_buf, size)) {
+		pr_err("PLATFORM_SEND_RSVD_PAGE 1 error!!\n");
+		status = HALMAC_RET_DL_RSVD_PAGE_FAIL;
+	}
+
+	/* Check Bcn_Valid_Bit */
+	counter = 1000;
+	while (!(HALMAC_REG_READ_8(halmac_adapter, REG_FIFOPAGE_CTRL_2 + 1) &
+		 BIT(7))) {
+		udelay(10);
+		counter--;
+		if (counter == 0) {
+			pr_err("Polling Bcn_Valid_Fail error!!\n");
+			status = HALMAC_RET_POLLING_BCN_VALID_FAIL;
+			break;
+		}
+	}
+
+	value8 = HALMAC_REG_READ_8(halmac_adapter, REG_FIFOPAGE_CTRL_2 + 1);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_FIFOPAGE_CTRL_2 + 1,
+			   (value8 | BIT(7)));
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_FWHW_TXQ_CTRL + 2, restore[2]);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_BCN_CTRL, restore[1]);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_CR + 1, restore[0]);
+
+	return status;
+}
+
+enum halmac_ret_status
+halmac_set_h2c_header_88xx(struct halmac_adapter *halmac_adapter,
+			   u8 *hal_h2c_hdr, u16 *seq, bool ack)
+{
+	void *driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s!!\n", __func__);
+
+	H2C_CMD_HEADER_SET_CATEGORY(hal_h2c_hdr, 0x00);
+	H2C_CMD_HEADER_SET_TOTAL_LEN(hal_h2c_hdr, 16);
+
+	spin_lock(&halmac_adapter->h2c_seq_lock);
+	H2C_CMD_HEADER_SET_SEQ_NUM(hal_h2c_hdr, halmac_adapter->h2c_packet_seq);
+	*seq = halmac_adapter->h2c_packet_seq;
+	halmac_adapter->h2c_packet_seq++;
+	spin_unlock(&halmac_adapter->h2c_seq_lock);
+
+	if (ack)
+		H2C_CMD_HEADER_SET_ACK(hal_h2c_hdr, 1);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status halmac_set_fw_offload_h2c_header_88xx(
+	struct halmac_adapter *halmac_adapter, u8 *hal_h2c_hdr,
+	struct halmac_h2c_header_info *h2c_header_info, u16 *seq_num)
+{
+	void *driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s!!\n", __func__);
+
+	FW_OFFLOAD_H2C_SET_TOTAL_LEN(hal_h2c_hdr,
+				     8 + h2c_header_info->content_size);
+	FW_OFFLOAD_H2C_SET_SUB_CMD_ID(hal_h2c_hdr, h2c_header_info->sub_cmd_id);
+
+	FW_OFFLOAD_H2C_SET_CATEGORY(hal_h2c_hdr, 0x01);
+	FW_OFFLOAD_H2C_SET_CMD_ID(hal_h2c_hdr, 0xFF);
+
+	spin_lock(&halmac_adapter->h2c_seq_lock);
+	FW_OFFLOAD_H2C_SET_SEQ_NUM(hal_h2c_hdr, halmac_adapter->h2c_packet_seq);
+	*seq_num = halmac_adapter->h2c_packet_seq;
+	halmac_adapter->h2c_packet_seq++;
+	spin_unlock(&halmac_adapter->h2c_seq_lock);
+
+	if (h2c_header_info->ack)
+		FW_OFFLOAD_H2C_SET_ACK(hal_h2c_hdr, 1);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_send_h2c_set_pwr_mode_88xx(struct halmac_adapter *halmac_adapter,
+				  struct halmac_fwlps_option *hal_fw_lps_opt)
+{
+	u8 h2c_buff[HALMAC_H2C_CMD_SIZE_88XX];
+	u8 *h2c_header, *h2c_cmd;
+	u16 seq = 0;
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s!!\n", __func__);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	h2c_header = h2c_buff;
+	h2c_cmd = h2c_header + HALMAC_H2C_CMD_HDR_SIZE_88XX;
+
+	memset(h2c_buff, 0x00, HALMAC_H2C_CMD_SIZE_88XX);
+
+	SET_PWR_MODE_SET_CMD_ID(h2c_cmd, CMD_ID_SET_PWR_MODE);
+	SET_PWR_MODE_SET_CLASS(h2c_cmd, CLASS_SET_PWR_MODE);
+	SET_PWR_MODE_SET_MODE(h2c_cmd, hal_fw_lps_opt->mode);
+	SET_PWR_MODE_SET_CLK_REQUEST(h2c_cmd, hal_fw_lps_opt->clk_request);
+	SET_PWR_MODE_SET_RLBM(h2c_cmd, hal_fw_lps_opt->rlbm);
+	SET_PWR_MODE_SET_SMART_PS(h2c_cmd, hal_fw_lps_opt->smart_ps);
+	SET_PWR_MODE_SET_AWAKE_INTERVAL(h2c_cmd,
+					hal_fw_lps_opt->awake_interval);
+	SET_PWR_MODE_SET_B_ALL_QUEUE_UAPSD(h2c_cmd,
+					   hal_fw_lps_opt->all_queue_uapsd);
+	SET_PWR_MODE_SET_PWR_STATE(h2c_cmd, hal_fw_lps_opt->pwr_state);
+	SET_PWR_MODE_SET_ANT_AUTO_SWITCH(h2c_cmd,
+					 hal_fw_lps_opt->ant_auto_switch);
+	SET_PWR_MODE_SET_PS_ALLOW_BT_HIGH_PRIORITY(
+		h2c_cmd, hal_fw_lps_opt->ps_allow_bt_high_priority);
+	SET_PWR_MODE_SET_PROTECT_BCN(h2c_cmd, hal_fw_lps_opt->protect_bcn);
+	SET_PWR_MODE_SET_SILENCE_PERIOD(h2c_cmd,
+					hal_fw_lps_opt->silence_period);
+	SET_PWR_MODE_SET_FAST_BT_CONNECT(h2c_cmd,
+					 hal_fw_lps_opt->fast_bt_connect);
+	SET_PWR_MODE_SET_TWO_ANTENNA_EN(h2c_cmd,
+					hal_fw_lps_opt->two_antenna_en);
+	SET_PWR_MODE_SET_ADOPT_USER_SETTING(h2c_cmd,
+					    hal_fw_lps_opt->adopt_user_setting);
+	SET_PWR_MODE_SET_DRV_BCN_EARLY_SHIFT(
+		h2c_cmd, hal_fw_lps_opt->drv_bcn_early_shift);
+
+	halmac_set_h2c_header_88xx(halmac_adapter, h2c_header, &seq, true);
+
+	status = halmac_send_h2c_pkt_88xx(halmac_adapter, h2c_buff,
+					  HALMAC_H2C_CMD_SIZE_88XX, true);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("%s Fail = %x!!\n", __func__, status);
+		return status;
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_func_send_original_h2c_88xx(struct halmac_adapter *halmac_adapter,
+				   u8 *original_h2c, u16 *seq, u8 ack)
+{
+	u8 H2c_buff[HALMAC_H2C_CMD_SIZE_88XX] = {0};
+	u8 *h2c_header, *h2c_cmd;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"halmac_send_original_h2c ==========>\n");
+
+	h2c_header = H2c_buff;
+	h2c_cmd = h2c_header + HALMAC_H2C_CMD_HDR_SIZE_88XX;
+	memcpy(h2c_cmd, original_h2c, 8); /* Original H2C 8 byte */
+
+	halmac_set_h2c_header_88xx(halmac_adapter, h2c_header, seq, ack);
+
+	status = halmac_send_h2c_pkt_88xx(halmac_adapter, H2c_buff,
+					  HALMAC_H2C_CMD_SIZE_88XX, ack);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_original_h2c Fail = %x!!\n", status);
+		return status;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"halmac_send_original_h2c <==========\n");
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_media_status_rpt_88xx(struct halmac_adapter *halmac_adapter, u8 op_mode,
+			     u8 mac_id_ind, u8 mac_id, u8 mac_id_end)
+{
+	u8 H2c_buff[HALMAC_H2C_CMD_SIZE_88XX] = {0};
+	u8 *h2c_header, *h2c_cmd;
+	u16 seq = 0;
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"halmac_send_h2c_set_pwr_mode_88xx!!\n");
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	h2c_header = H2c_buff;
+	h2c_cmd = h2c_header + HALMAC_H2C_CMD_HDR_SIZE_88XX;
+
+	memset(H2c_buff, 0x00, HALMAC_H2C_CMD_SIZE_88XX);
+
+	MEDIA_STATUS_RPT_SET_CMD_ID(h2c_cmd, CMD_ID_MEDIA_STATUS_RPT);
+	MEDIA_STATUS_RPT_SET_CLASS(h2c_cmd, CLASS_MEDIA_STATUS_RPT);
+	MEDIA_STATUS_RPT_SET_OP_MODE(h2c_cmd, op_mode);
+	MEDIA_STATUS_RPT_SET_MACID_IN(h2c_cmd, mac_id_ind);
+	MEDIA_STATUS_RPT_SET_MACID(h2c_cmd, mac_id);
+	MEDIA_STATUS_RPT_SET_MACID_END(h2c_cmd, mac_id_end);
+
+	halmac_set_h2c_header_88xx(halmac_adapter, h2c_header, &seq, true);
+
+	status = halmac_send_h2c_pkt_88xx(halmac_adapter, H2c_buff,
+					  HALMAC_H2C_CMD_SIZE_88XX, true);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("%s Fail = %x!!\n", __func__, status);
+		return status;
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_send_h2c_update_packet_88xx(struct halmac_adapter *halmac_adapter,
+				   enum halmac_packet_id pkt_id, u8 *pkt,
+				   u32 pkt_size)
+{
+	u8 h2c_buff[HALMAC_H2C_CMD_SIZE_88XX] = {0};
+	u16 h2c_seq_mum = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	struct halmac_h2c_header_info h2c_header_info;
+	enum halmac_ret_status ret_status = HALMAC_RET_SUCCESS;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_CTRL_2,
+			    (u16)(halmac_adapter->txff_allocation
+					  .rsvd_h2c_extra_info_pg_bndy &
+				  BIT_MASK_BCN_HEAD_1_V1));
+
+	ret_status =
+		halmac_download_rsvd_page_88xx(halmac_adapter, pkt, pkt_size);
+
+	if (ret_status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_download_rsvd_page_88xx Fail = %x!!\n",
+		       ret_status);
+		HALMAC_REG_WRITE_16(
+			halmac_adapter, REG_FIFOPAGE_CTRL_2,
+			(u16)(halmac_adapter->txff_allocation.rsvd_pg_bndy &
+			      BIT_MASK_BCN_HEAD_1_V1));
+		return ret_status;
+	}
+
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_CTRL_2,
+			    (u16)(halmac_adapter->txff_allocation.rsvd_pg_bndy &
+				  BIT_MASK_BCN_HEAD_1_V1));
+
+	UPDATE_PACKET_SET_SIZE(
+		h2c_buff,
+		pkt_size + halmac_adapter->hw_config_info.txdesc_size);
+	UPDATE_PACKET_SET_PACKET_ID(h2c_buff, pkt_id);
+	UPDATE_PACKET_SET_PACKET_LOC(
+		h2c_buff,
+		halmac_adapter->txff_allocation.rsvd_h2c_extra_info_pg_bndy -
+			halmac_adapter->txff_allocation.rsvd_pg_bndy);
+
+	h2c_header_info.sub_cmd_id = SUB_CMD_ID_UPDATE_PACKET;
+	h2c_header_info.content_size = 8;
+	h2c_header_info.ack = true;
+	halmac_set_fw_offload_h2c_header_88xx(halmac_adapter, h2c_buff,
+					      &h2c_header_info, &h2c_seq_mum);
+	halmac_adapter->halmac_state.update_packet_set.seq_num = h2c_seq_mum;
+
+	ret_status = halmac_send_h2c_pkt_88xx(halmac_adapter, h2c_buff,
+					      HALMAC_H2C_CMD_SIZE_88XX, true);
+
+	if (ret_status != HALMAC_RET_SUCCESS) {
+		pr_err("%s Fail = %x!!\n", __func__, ret_status);
+		return ret_status;
+	}
+
+	return ret_status;
+}
+
+enum halmac_ret_status
+halmac_send_h2c_phy_parameter_88xx(struct halmac_adapter *halmac_adapter,
+				   struct halmac_phy_parameter_info *para_info,
+				   bool full_fifo)
+{
+	bool drv_trigger_send = false;
+	u8 h2c_buff[HALMAC_H2C_CMD_SIZE_88XX] = {0};
+	u16 h2c_seq_mum = 0;
+	u32 info_size = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	struct halmac_h2c_header_info h2c_header_info;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	struct halmac_config_para_info *config_para_info;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+	config_para_info = &halmac_adapter->config_para_info;
+
+	if (!config_para_info->cfg_para_buf) {
+		if (full_fifo)
+			config_para_info->para_buf_size =
+				HALMAC_EXTRA_INFO_BUFF_SIZE_FULL_FIFO_88XX;
+		else
+			config_para_info->para_buf_size =
+				HALMAC_EXTRA_INFO_BUFF_SIZE_88XX;
+
+		config_para_info->cfg_para_buf =
+			kzalloc(config_para_info->para_buf_size, GFP_KERNEL);
+
+		if (config_para_info->cfg_para_buf) {
+			memset(config_para_info->cfg_para_buf, 0x00,
+			       config_para_info->para_buf_size);
+			config_para_info->full_fifo_mode = full_fifo;
+			config_para_info->para_buf_w =
+				config_para_info->cfg_para_buf;
+			config_para_info->para_num = 0;
+			config_para_info->avai_para_buf_size =
+				config_para_info->para_buf_size;
+			config_para_info->value_accumulation = 0;
+			config_para_info->offset_accumulation = 0;
+		} else {
+			HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C,
+					DBG_DMESG,
+					"Allocate cfg_para_buf fail!!\n");
+			return HALMAC_RET_MALLOC_FAIL;
+		}
+	}
+
+	if (halmac_transition_cfg_para_state_88xx(
+		    halmac_adapter,
+		    HALMAC_CFG_PARA_CMD_CONSTRUCT_CONSTRUCTING) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	halmac_enqueue_para_buff_88xx(halmac_adapter, para_info,
+				      config_para_info->para_buf_w,
+				      &drv_trigger_send);
+
+	if (para_info->cmd_id != HALMAC_PARAMETER_CMD_END) {
+		config_para_info->para_num++;
+		config_para_info->para_buf_w += HALMAC_FW_OFFLOAD_CMD_SIZE_88XX;
+		config_para_info->avai_para_buf_size =
+			config_para_info->avai_para_buf_size -
+			HALMAC_FW_OFFLOAD_CMD_SIZE_88XX;
+	}
+
+	if ((config_para_info->avai_para_buf_size -
+	     halmac_adapter->hw_config_info.txdesc_size) >
+		    HALMAC_FW_OFFLOAD_CMD_SIZE_88XX &&
+	    !drv_trigger_send)
+		return HALMAC_RET_SUCCESS;
+
+	if (config_para_info->para_num == 0) {
+		kfree(config_para_info->cfg_para_buf);
+		config_para_info->cfg_para_buf = NULL;
+		config_para_info->para_buf_w = NULL;
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_WARNING,
+				"no cfg parameter element!!\n");
+
+		if (halmac_transition_cfg_para_state_88xx(
+			    halmac_adapter,
+			    HALMAC_CFG_PARA_CMD_CONSTRUCT_IDLE) !=
+		    HALMAC_RET_SUCCESS)
+			return HALMAC_RET_ERROR_STATE;
+
+		return HALMAC_RET_SUCCESS;
+	}
+
+	if (halmac_transition_cfg_para_state_88xx(
+		    halmac_adapter, HALMAC_CFG_PARA_CMD_CONSTRUCT_H2C_SENT) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	halmac_adapter->halmac_state.cfg_para_state_set.process_status =
+		HALMAC_CMD_PROCESS_SENDING;
+
+	if (config_para_info->full_fifo_mode)
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_CTRL_2, 0);
+	else
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_CTRL_2,
+				    (u16)(halmac_adapter->txff_allocation
+						  .rsvd_h2c_extra_info_pg_bndy &
+					  BIT_MASK_BCN_HEAD_1_V1));
+
+	info_size =
+		config_para_info->para_num * HALMAC_FW_OFFLOAD_CMD_SIZE_88XX;
+
+	status = halmac_download_rsvd_page_88xx(
+		halmac_adapter, (u8 *)config_para_info->cfg_para_buf,
+		info_size);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_download_rsvd_page_88xx Fail!!\n");
+	} else {
+		halmac_gen_cfg_para_h2c_88xx(halmac_adapter, h2c_buff);
+
+		h2c_header_info.sub_cmd_id = SUB_CMD_ID_CFG_PARAMETER;
+		h2c_header_info.content_size = 4;
+		h2c_header_info.ack = true;
+		halmac_set_fw_offload_h2c_header_88xx(halmac_adapter, h2c_buff,
+						      &h2c_header_info,
+						      &h2c_seq_mum);
+
+		halmac_adapter->halmac_state.cfg_para_state_set.seq_num =
+			h2c_seq_mum;
+
+		status = halmac_send_h2c_pkt_88xx(halmac_adapter, h2c_buff,
+						  HALMAC_H2C_CMD_SIZE_88XX,
+						  true);
+
+		if (status != HALMAC_RET_SUCCESS)
+			pr_err("halmac_send_h2c_pkt_88xx Fail!!\n");
+
+		HALMAC_RT_TRACE(
+			driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"config parameter time = %d\n",
+			HALMAC_REG_READ_32(halmac_adapter, REG_FW_DBG6));
+	}
+
+	kfree(config_para_info->cfg_para_buf);
+	config_para_info->cfg_para_buf = NULL;
+	config_para_info->para_buf_w = NULL;
+
+	/* Restore bcn head */
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_CTRL_2,
+			    (u16)(halmac_adapter->txff_allocation.rsvd_pg_bndy &
+				  BIT_MASK_BCN_HEAD_1_V1));
+
+	if (halmac_transition_cfg_para_state_88xx(
+		    halmac_adapter, HALMAC_CFG_PARA_CMD_CONSTRUCT_IDLE) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	if (!drv_trigger_send) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+				"Buffer full trigger sending H2C!!\n");
+		return HALMAC_RET_PARA_SENDING;
+	}
+
+	return status;
+}
+
+static enum halmac_ret_status
+halmac_enqueue_para_buff_88xx(struct halmac_adapter *halmac_adapter,
+			      struct halmac_phy_parameter_info *para_info,
+			      u8 *curr_buff_wptr, bool *end_cmd)
+{
+	struct halmac_config_para_info *config_para_info =
+		&halmac_adapter->config_para_info;
+
+	*end_cmd = false;
+
+	PHY_PARAMETER_INFO_SET_LENGTH(curr_buff_wptr,
+				      HALMAC_FW_OFFLOAD_CMD_SIZE_88XX);
+	PHY_PARAMETER_INFO_SET_IO_CMD(curr_buff_wptr, para_info->cmd_id);
+
+	switch (para_info->cmd_id) {
+	case HALMAC_PARAMETER_CMD_BB_W8:
+	case HALMAC_PARAMETER_CMD_BB_W16:
+	case HALMAC_PARAMETER_CMD_BB_W32:
+	case HALMAC_PARAMETER_CMD_MAC_W8:
+	case HALMAC_PARAMETER_CMD_MAC_W16:
+	case HALMAC_PARAMETER_CMD_MAC_W32:
+		PHY_PARAMETER_INFO_SET_IO_ADDR(
+			curr_buff_wptr, para_info->content.MAC_REG_W.offset);
+		PHY_PARAMETER_INFO_SET_DATA(curr_buff_wptr,
+					    para_info->content.MAC_REG_W.value);
+		PHY_PARAMETER_INFO_SET_MASK(curr_buff_wptr,
+					    para_info->content.MAC_REG_W.msk);
+		PHY_PARAMETER_INFO_SET_MSK_EN(
+			curr_buff_wptr, para_info->content.MAC_REG_W.msk_en);
+		config_para_info->value_accumulation +=
+			para_info->content.MAC_REG_W.value;
+		config_para_info->offset_accumulation +=
+			para_info->content.MAC_REG_W.offset;
+		break;
+	case HALMAC_PARAMETER_CMD_RF_W:
+		/*In rf register, the address is only 1 byte*/
+		PHY_PARAMETER_INFO_SET_RF_ADDR(
+			curr_buff_wptr, para_info->content.RF_REG_W.offset);
+		PHY_PARAMETER_INFO_SET_RF_PATH(
+			curr_buff_wptr, para_info->content.RF_REG_W.rf_path);
+		PHY_PARAMETER_INFO_SET_DATA(curr_buff_wptr,
+					    para_info->content.RF_REG_W.value);
+		PHY_PARAMETER_INFO_SET_MASK(curr_buff_wptr,
+					    para_info->content.RF_REG_W.msk);
+		PHY_PARAMETER_INFO_SET_MSK_EN(
+			curr_buff_wptr, para_info->content.RF_REG_W.msk_en);
+		config_para_info->value_accumulation +=
+			para_info->content.RF_REG_W.value;
+		config_para_info->offset_accumulation +=
+			(para_info->content.RF_REG_W.offset +
+			 (para_info->content.RF_REG_W.rf_path << 8));
+		break;
+	case HALMAC_PARAMETER_CMD_DELAY_US:
+	case HALMAC_PARAMETER_CMD_DELAY_MS:
+		PHY_PARAMETER_INFO_SET_DELAY_VALUE(
+			curr_buff_wptr,
+			para_info->content.DELAY_TIME.delay_time);
+		break;
+	case HALMAC_PARAMETER_CMD_END:
+		*end_cmd = true;
+		break;
+	default:
+		pr_err(" halmac_send_h2c_phy_parameter_88xx illegal cmd_id!!\n");
+		break;
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_gen_cfg_para_h2c_88xx(struct halmac_adapter *halmac_adapter,
+			     u8 *h2c_buff)
+{
+	struct halmac_config_para_info *config_para_info =
+		&halmac_adapter->config_para_info;
+
+	CFG_PARAMETER_SET_NUM(h2c_buff, config_para_info->para_num);
+
+	if (config_para_info->full_fifo_mode) {
+		CFG_PARAMETER_SET_INIT_CASE(h2c_buff, 0x1);
+		CFG_PARAMETER_SET_PHY_PARAMETER_LOC(h2c_buff, 0);
+	} else {
+		CFG_PARAMETER_SET_INIT_CASE(h2c_buff, 0x0);
+		CFG_PARAMETER_SET_PHY_PARAMETER_LOC(
+			h2c_buff,
+			halmac_adapter->txff_allocation
+					.rsvd_h2c_extra_info_pg_bndy -
+				halmac_adapter->txff_allocation.rsvd_pg_bndy);
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_send_h2c_run_datapack_88xx(struct halmac_adapter *halmac_adapter,
+				  enum halmac_data_type halmac_data_type)
+{
+	u8 h2c_buff[HALMAC_H2C_CMD_SIZE_88XX] = {0};
+	u16 h2c_seq_mum = 0;
+	void *driver_adapter = NULL;
+	struct halmac_h2c_header_info h2c_header_info;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s!!\n", __func__);
+
+	RUN_DATAPACK_SET_DATAPACK_ID(h2c_buff, halmac_data_type);
+
+	h2c_header_info.sub_cmd_id = SUB_CMD_ID_RUN_DATAPACK;
+	h2c_header_info.content_size = 4;
+	h2c_header_info.ack = true;
+	halmac_set_fw_offload_h2c_header_88xx(halmac_adapter, h2c_buff,
+					      &h2c_header_info, &h2c_seq_mum);
+
+	status = halmac_send_h2c_pkt_88xx(halmac_adapter, h2c_buff,
+					  HALMAC_H2C_CMD_SIZE_88XX, true);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_h2c_pkt_88xx Fail = %x!!\n", status);
+		return status;
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_send_bt_coex_cmd_88xx(struct halmac_adapter *halmac_adapter, u8 *bt_buf,
+			     u32 bt_size, u8 ack)
+{
+	u8 h2c_buff[HALMAC_H2C_CMD_SIZE_88XX] = {0};
+	u16 h2c_seq_mum = 0;
+	void *driver_adapter = NULL;
+	struct halmac_h2c_header_info h2c_header_info;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s!!\n", __func__);
+
+	memcpy(h2c_buff + 8, bt_buf, bt_size);
+
+	h2c_header_info.sub_cmd_id = SUB_CMD_ID_BT_COEX;
+	h2c_header_info.content_size = (u16)bt_size;
+	h2c_header_info.ack = ack;
+	halmac_set_fw_offload_h2c_header_88xx(halmac_adapter, h2c_buff,
+					      &h2c_header_info, &h2c_seq_mum);
+
+	status = halmac_send_h2c_pkt_88xx(halmac_adapter, h2c_buff,
+					  HALMAC_H2C_CMD_SIZE_88XX, ack);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_h2c_pkt_88xx Fail = %x!!\n", status);
+		return status;
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_func_ctrl_ch_switch_88xx(struct halmac_adapter *halmac_adapter,
+				struct halmac_ch_switch_option *cs_option)
+{
+	u8 h2c_buff[HALMAC_H2C_CMD_SIZE_88XX] = {0};
+	u16 h2c_seq_mum = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	struct halmac_h2c_header_info h2c_header_info;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	enum halmac_cmd_process_status *process_status =
+		&halmac_adapter->halmac_state.scan_state_set.process_status;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"halmac_ctrl_ch_switch!!\n");
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if (halmac_transition_scan_state_88xx(
+		    halmac_adapter, HALMAC_SCAN_CMD_CONSTRUCT_H2C_SENT) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	*process_status = HALMAC_CMD_PROCESS_SENDING;
+
+	if (cs_option->switch_en != 0) {
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_FIFOPAGE_CTRL_2,
+				    (u16)(halmac_adapter->txff_allocation
+						  .rsvd_h2c_extra_info_pg_bndy &
+					  BIT_MASK_BCN_HEAD_1_V1));
+
+		status = halmac_download_rsvd_page_88xx(
+			halmac_adapter, halmac_adapter->ch_sw_info.ch_info_buf,
+			halmac_adapter->ch_sw_info.total_size);
+
+		if (status != HALMAC_RET_SUCCESS) {
+			pr_err("halmac_download_rsvd_page_88xx Fail = %x!!\n",
+			       status);
+			HALMAC_REG_WRITE_16(
+				halmac_adapter, REG_FIFOPAGE_CTRL_2,
+				(u16)(halmac_adapter->txff_allocation
+					      .rsvd_pg_bndy &
+				      BIT_MASK_BCN_HEAD_1_V1));
+			return status;
+		}
+
+		HALMAC_REG_WRITE_16(
+			halmac_adapter, REG_FIFOPAGE_CTRL_2,
+			(u16)(halmac_adapter->txff_allocation.rsvd_pg_bndy &
+			      BIT_MASK_BCN_HEAD_1_V1));
+	}
+
+	CHANNEL_SWITCH_SET_SWITCH_START(h2c_buff, cs_option->switch_en);
+	CHANNEL_SWITCH_SET_CHANNEL_NUM(h2c_buff,
+				       halmac_adapter->ch_sw_info.ch_num);
+	CHANNEL_SWITCH_SET_CHANNEL_INFO_LOC(
+		h2c_buff,
+		halmac_adapter->txff_allocation.rsvd_h2c_extra_info_pg_bndy -
+			halmac_adapter->txff_allocation.rsvd_pg_bndy);
+	CHANNEL_SWITCH_SET_DEST_CH_EN(h2c_buff, cs_option->dest_ch_en);
+	CHANNEL_SWITCH_SET_DEST_CH(h2c_buff, cs_option->dest_ch);
+	CHANNEL_SWITCH_SET_PRI_CH_IDX(h2c_buff, cs_option->dest_pri_ch_idx);
+	CHANNEL_SWITCH_SET_ABSOLUTE_TIME(h2c_buff, cs_option->absolute_time_en);
+	CHANNEL_SWITCH_SET_TSF_LOW(h2c_buff, cs_option->tsf_low);
+	CHANNEL_SWITCH_SET_PERIODIC_OPTION(h2c_buff,
+					   cs_option->periodic_option);
+	CHANNEL_SWITCH_SET_NORMAL_CYCLE(h2c_buff, cs_option->normal_cycle);
+	CHANNEL_SWITCH_SET_NORMAL_PERIOD(h2c_buff, cs_option->normal_period);
+	CHANNEL_SWITCH_SET_SLOW_PERIOD(h2c_buff, cs_option->phase_2_period);
+	CHANNEL_SWITCH_SET_CHANNEL_INFO_SIZE(
+		h2c_buff, halmac_adapter->ch_sw_info.total_size);
+
+	h2c_header_info.sub_cmd_id = SUB_CMD_ID_CHANNEL_SWITCH;
+	h2c_header_info.content_size = 20;
+	h2c_header_info.ack = true;
+	halmac_set_fw_offload_h2c_header_88xx(halmac_adapter, h2c_buff,
+					      &h2c_header_info, &h2c_seq_mum);
+	halmac_adapter->halmac_state.scan_state_set.seq_num = h2c_seq_mum;
+
+	status = halmac_send_h2c_pkt_88xx(halmac_adapter, h2c_buff,
+					  HALMAC_H2C_CMD_SIZE_88XX, true);
+
+	if (status != HALMAC_RET_SUCCESS)
+		pr_err("halmac_send_h2c_pkt_88xx Fail = %x!!\n", status);
+
+	kfree(halmac_adapter->ch_sw_info.ch_info_buf);
+	halmac_adapter->ch_sw_info.ch_info_buf = NULL;
+	halmac_adapter->ch_sw_info.ch_info_buf_w = NULL;
+	halmac_adapter->ch_sw_info.extra_info_en = 0;
+	halmac_adapter->ch_sw_info.buf_size = 0;
+	halmac_adapter->ch_sw_info.avai_buf_size = 0;
+	halmac_adapter->ch_sw_info.total_size = 0;
+	halmac_adapter->ch_sw_info.ch_num = 0;
+
+	if (halmac_transition_scan_state_88xx(halmac_adapter,
+					      HALMAC_SCAN_CMD_CONSTRUCT_IDLE) !=
+	    HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ERROR_STATE;
+
+	return status;
+}
+
+enum halmac_ret_status
+halmac_func_send_general_info_88xx(struct halmac_adapter *halmac_adapter,
+				   struct halmac_general_info *general_info)
+{
+	u8 h2c_buff[HALMAC_H2C_CMD_SIZE_88XX] = {0};
+	u16 h2c_seq_mum = 0;
+	void *driver_adapter = NULL;
+	struct halmac_h2c_header_info h2c_header_info;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"halmac_send_general_info!!\n");
+
+	GENERAL_INFO_SET_REF_TYPE(h2c_buff, general_info->rfe_type);
+	GENERAL_INFO_SET_RF_TYPE(h2c_buff, general_info->rf_type);
+	GENERAL_INFO_SET_FW_TX_BOUNDARY(
+		h2c_buff,
+		halmac_adapter->txff_allocation.rsvd_fw_txbuff_pg_bndy -
+			halmac_adapter->txff_allocation.rsvd_pg_bndy);
+
+	h2c_header_info.sub_cmd_id = SUB_CMD_ID_GENERAL_INFO;
+	h2c_header_info.content_size = 4;
+	h2c_header_info.ack = false;
+	halmac_set_fw_offload_h2c_header_88xx(halmac_adapter, h2c_buff,
+					      &h2c_header_info, &h2c_seq_mum);
+
+	status = halmac_send_h2c_pkt_88xx(halmac_adapter, h2c_buff,
+					  HALMAC_H2C_CMD_SIZE_88XX, true);
+
+	if (status != HALMAC_RET_SUCCESS)
+		pr_err("halmac_send_h2c_pkt_88xx Fail = %x!!\n", status);
+
+	return status;
+}
+
+enum halmac_ret_status halmac_send_h2c_update_bcn_parse_info_88xx(
+	struct halmac_adapter *halmac_adapter,
+	struct halmac_bcn_ie_info *bcn_ie_info)
+{
+	u8 h2c_buff[HALMAC_H2C_CMD_SIZE_88XX] = {0};
+	u16 h2c_seq_mum = 0;
+	void *driver_adapter = NULL;
+	struct halmac_h2c_header_info h2c_header_info;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s!!\n", __func__);
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	UPDATE_BEACON_PARSING_INFO_SET_FUNC_EN(h2c_buff, bcn_ie_info->func_en);
+	UPDATE_BEACON_PARSING_INFO_SET_SIZE_TH(h2c_buff, bcn_ie_info->size_th);
+	UPDATE_BEACON_PARSING_INFO_SET_TIMEOUT(h2c_buff, bcn_ie_info->timeout);
+
+	UPDATE_BEACON_PARSING_INFO_SET_IE_ID_BMP_0(
+		h2c_buff, (u32)(bcn_ie_info->ie_bmp[0]));
+	UPDATE_BEACON_PARSING_INFO_SET_IE_ID_BMP_1(
+		h2c_buff, (u32)(bcn_ie_info->ie_bmp[1]));
+	UPDATE_BEACON_PARSING_INFO_SET_IE_ID_BMP_2(
+		h2c_buff, (u32)(bcn_ie_info->ie_bmp[2]));
+	UPDATE_BEACON_PARSING_INFO_SET_IE_ID_BMP_3(
+		h2c_buff, (u32)(bcn_ie_info->ie_bmp[3]));
+	UPDATE_BEACON_PARSING_INFO_SET_IE_ID_BMP_4(
+		h2c_buff, (u32)(bcn_ie_info->ie_bmp[4]));
+
+	h2c_header_info.sub_cmd_id = SUB_CMD_ID_UPDATE_BEACON_PARSING_INFO;
+	h2c_header_info.content_size = 24;
+	h2c_header_info.ack = true;
+	halmac_set_fw_offload_h2c_header_88xx(halmac_adapter, h2c_buff,
+					      &h2c_header_info, &h2c_seq_mum);
+
+	status = halmac_send_h2c_pkt_88xx(halmac_adapter, h2c_buff,
+					  HALMAC_H2C_CMD_SIZE_88XX, true);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_h2c_pkt_88xx Fail =%x !!\n", status);
+		return status;
+	}
+
+	return status;
+}
+
+enum halmac_ret_status
+halmac_send_h2c_ps_tuning_para_88xx(struct halmac_adapter *halmac_adapter)
+{
+	u8 h2c_buff[HALMAC_H2C_CMD_SIZE_88XX] = {0};
+	u8 *h2c_header, *h2c_cmd;
+	u16 seq = 0;
+	void *driver_adapter = NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"%s!!\n", __func__);
+
+	h2c_header = h2c_buff;
+	h2c_cmd = h2c_header + HALMAC_H2C_CMD_HDR_SIZE_88XX;
+
+	halmac_set_h2c_header_88xx(halmac_adapter, h2c_header, &seq, false);
+
+	status = halmac_send_h2c_pkt_88xx(halmac_adapter, h2c_buff,
+					  HALMAC_H2C_CMD_SIZE_88XX, false);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_send_h2c_pkt_88xx Fail = %x!!\n", status);
+		return status;
+	}
+
+	return status;
+}
+
+enum halmac_ret_status
+halmac_parse_c2h_packet_88xx(struct halmac_adapter *halmac_adapter,
+			     u8 *halmac_buf, u32 halmac_size)
+{
+	u8 c2h_cmd, c2h_sub_cmd_id;
+	u8 *c2h_buf = halmac_buf + halmac_adapter->hw_config_info.rxdesc_size;
+	u32 c2h_size = halmac_size - halmac_adapter->hw_config_info.rxdesc_size;
+	void *driver_adapter = halmac_adapter->driver_adapter;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	c2h_cmd = (u8)C2H_HDR_GET_CMD_ID(c2h_buf);
+
+	/* FW offload C2H cmd is 0xFF */
+	if (c2h_cmd != 0xFF) {
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+				"C2H_PKT not for FwOffloadC2HFormat!!\n");
+		return HALMAC_RET_C2H_NOT_HANDLED;
+	}
+
+	/* Get C2H sub cmd ID */
+	c2h_sub_cmd_id = (u8)C2H_HDR_GET_C2H_SUB_CMD_ID(c2h_buf);
+
+	switch (c2h_sub_cmd_id) {
+	case C2H_SUB_CMD_ID_C2H_DBG:
+		status = halmac_parse_c2h_debug_88xx(halmac_adapter, c2h_buf,
+						     c2h_size);
+		break;
+	case C2H_SUB_CMD_ID_H2C_ACK_HDR:
+		status = halmac_parse_h2c_ack_88xx(halmac_adapter, c2h_buf,
+						   c2h_size);
+		break;
+	case C2H_SUB_CMD_ID_BT_COEX_INFO:
+		status = HALMAC_RET_C2H_NOT_HANDLED;
+		break;
+	case C2H_SUB_CMD_ID_SCAN_STATUS_RPT:
+		status = halmac_parse_scan_status_rpt_88xx(halmac_adapter,
+							   c2h_buf, c2h_size);
+		break;
+	case C2H_SUB_CMD_ID_PSD_DATA:
+		status = halmac_parse_psd_data_88xx(halmac_adapter, c2h_buf,
+						    c2h_size);
+		break;
+
+	case C2H_SUB_CMD_ID_EFUSE_DATA:
+		status = halmac_parse_efuse_data_88xx(halmac_adapter, c2h_buf,
+						      c2h_size);
+		break;
+	default:
+		pr_err("c2h_sub_cmd_id switch case out of boundary!!\n");
+		pr_err("[ERR]c2h pkt : %.8X %.8X!!\n", *(u32 *)c2h_buf,
+		       *(u32 *)(c2h_buf + 4));
+		status = HALMAC_RET_C2H_NOT_HANDLED;
+		break;
+	}
+
+	return status;
+}
+
+static enum halmac_ret_status
+halmac_parse_c2h_debug_88xx(struct halmac_adapter *halmac_adapter, u8 *c2h_buf,
+			    u32 c2h_size)
+{
+	void *driver_adapter = NULL;
+	u8 *c2h_buf_local = (u8 *)NULL;
+	u32 c2h_size_local = 0;
+	u8 dbg_content_length = 0;
+	u8 dbg_seq_num = 0;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	c2h_buf_local = c2h_buf;
+	c2h_size_local = c2h_size;
+
+	dbg_content_length = (u8)C2H_HDR_GET_LEN((u8 *)c2h_buf_local);
+
+	if (dbg_content_length > C2H_DBG_CONTENT_MAX_LENGTH)
+		return HALMAC_RET_SUCCESS;
+
+	*(c2h_buf_local + C2H_DBG_HEADER_LENGTH + dbg_content_length - 2) =
+		'\n';
+	dbg_seq_num = (u8)(*(c2h_buf_local + C2H_DBG_HEADER_LENGTH));
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"[RTKFW, SEQ=%d]: %s", dbg_seq_num,
+			(char *)(c2h_buf_local + C2H_DBG_HEADER_LENGTH + 1));
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_parse_scan_status_rpt_88xx(struct halmac_adapter *halmac_adapter,
+				  u8 *c2h_buf, u32 c2h_size)
+{
+	u8 h2c_return_code;
+	void *driver_adapter = halmac_adapter->driver_adapter;
+	enum halmac_cmd_process_status process_status;
+
+	h2c_return_code = (u8)SCAN_STATUS_RPT_GET_H2C_RETURN_CODE(c2h_buf);
+	process_status = (enum halmac_h2c_return_code)h2c_return_code ==
+					 HALMAC_H2C_RETURN_SUCCESS ?
+				 HALMAC_CMD_PROCESS_DONE :
+				 HALMAC_CMD_PROCESS_ERROR;
+
+	PLATFORM_EVENT_INDICATION(driver_adapter, HALMAC_FEATURE_CHANNEL_SWITCH,
+				  process_status, NULL, 0);
+
+	halmac_adapter->halmac_state.scan_state_set.process_status =
+		process_status;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"[TRACE]scan status : %X\n", process_status);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_parse_psd_data_88xx(struct halmac_adapter *halmac_adapter, u8 *c2h_buf,
+			   u32 c2h_size)
+{
+	u8 segment_id = 0, segment_size = 0, h2c_seq = 0;
+	u16 total_size;
+	void *driver_adapter = halmac_adapter->driver_adapter;
+	enum halmac_cmd_process_status process_status;
+	struct halmac_psd_state_set *psd_set =
+		&halmac_adapter->halmac_state.psd_set;
+
+	h2c_seq = (u8)PSD_DATA_GET_H2C_SEQ(c2h_buf);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"[TRACE]Seq num : h2c -> %d c2h -> %d\n",
+			psd_set->seq_num, h2c_seq);
+	if (h2c_seq != psd_set->seq_num) {
+		pr_err("[ERR]Seq num mismactch : h2c -> %d c2h -> %d\n",
+		       psd_set->seq_num, h2c_seq);
+		return HALMAC_RET_SUCCESS;
+	}
+
+	if (psd_set->process_status != HALMAC_CMD_PROCESS_SENDING) {
+		pr_err("[ERR]Not in HALMAC_CMD_PROCESS_SENDING\n");
+		return HALMAC_RET_SUCCESS;
+	}
+
+	total_size = (u16)PSD_DATA_GET_TOTAL_SIZE(c2h_buf);
+	segment_id = (u8)PSD_DATA_GET_SEGMENT_ID(c2h_buf);
+	segment_size = (u8)PSD_DATA_GET_SEGMENT_SIZE(c2h_buf);
+	psd_set->data_size = total_size;
+
+	if (!psd_set->data)
+		psd_set->data = kzalloc(psd_set->data_size, GFP_KERNEL);
+
+	if (segment_id == 0)
+		psd_set->segment_size = segment_size;
+
+	memcpy(psd_set->data + segment_id * psd_set->segment_size,
+	       c2h_buf + HALMAC_C2H_DATA_OFFSET_88XX, segment_size);
+
+	if (!PSD_DATA_GET_END_SEGMENT(c2h_buf))
+		return HALMAC_RET_SUCCESS;
+
+	process_status = HALMAC_CMD_PROCESS_DONE;
+	psd_set->process_status = process_status;
+
+	PLATFORM_EVENT_INDICATION(driver_adapter, HALMAC_FEATURE_PSD,
+				  process_status, psd_set->data,
+				  psd_set->data_size);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_parse_efuse_data_88xx(struct halmac_adapter *halmac_adapter, u8 *c2h_buf,
+			     u32 c2h_size)
+{
+	u8 segment_id = 0, segment_size = 0, h2c_seq = 0;
+	u8 *eeprom_map = NULL;
+	u32 eeprom_size = halmac_adapter->hw_config_info.eeprom_size;
+	u8 h2c_return_code = 0;
+	void *driver_adapter = halmac_adapter->driver_adapter;
+	enum halmac_cmd_process_status process_status;
+
+	h2c_seq = (u8)EFUSE_DATA_GET_H2C_SEQ(c2h_buf);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"[TRACE]Seq num : h2c -> %d c2h -> %d\n",
+			halmac_adapter->halmac_state.efuse_state_set.seq_num,
+			h2c_seq);
+	if (h2c_seq != halmac_adapter->halmac_state.efuse_state_set.seq_num) {
+		pr_err("[ERR]Seq num mismactch : h2c -> %d c2h -> %d\n",
+		       halmac_adapter->halmac_state.efuse_state_set.seq_num,
+		       h2c_seq);
+		return HALMAC_RET_SUCCESS;
+	}
+
+	if (halmac_adapter->halmac_state.efuse_state_set.process_status !=
+	    HALMAC_CMD_PROCESS_SENDING) {
+		pr_err("[ERR]Not in HALMAC_CMD_PROCESS_SENDING\n");
+		return HALMAC_RET_SUCCESS;
+	}
+
+	segment_id = (u8)EFUSE_DATA_GET_SEGMENT_ID(c2h_buf);
+	segment_size = (u8)EFUSE_DATA_GET_SEGMENT_SIZE(c2h_buf);
+	if (segment_id == 0)
+		halmac_adapter->efuse_segment_size = segment_size;
+
+	eeprom_map = kzalloc(eeprom_size, GFP_KERNEL);
+	if (!eeprom_map) {
+		/* out of memory */
+		return HALMAC_RET_MALLOC_FAIL;
+	}
+	memset(eeprom_map, 0xFF, eeprom_size);
+
+	spin_lock(&halmac_adapter->efuse_lock);
+	memcpy(halmac_adapter->hal_efuse_map +
+		       segment_id * halmac_adapter->efuse_segment_size,
+	       c2h_buf + HALMAC_C2H_DATA_OFFSET_88XX, segment_size);
+	spin_unlock(&halmac_adapter->efuse_lock);
+
+	if (!EFUSE_DATA_GET_END_SEGMENT(c2h_buf)) {
+		kfree(eeprom_map);
+		return HALMAC_RET_SUCCESS;
+	}
+
+	h2c_return_code =
+		halmac_adapter->halmac_state.efuse_state_set.fw_return_code;
+
+	if ((enum halmac_h2c_return_code)h2c_return_code ==
+	    HALMAC_H2C_RETURN_SUCCESS) {
+		process_status = HALMAC_CMD_PROCESS_DONE;
+		halmac_adapter->halmac_state.efuse_state_set.process_status =
+			process_status;
+
+		spin_lock(&halmac_adapter->efuse_lock);
+		halmac_adapter->hal_efuse_map_valid = true;
+		spin_unlock(&halmac_adapter->efuse_lock);
+
+		if (halmac_adapter->event_trigger.physical_efuse_map == 1) {
+			PLATFORM_EVENT_INDICATION(
+				driver_adapter,
+				HALMAC_FEATURE_DUMP_PHYSICAL_EFUSE,
+				process_status, halmac_adapter->hal_efuse_map,
+				halmac_adapter->hw_config_info.efuse_size);
+			halmac_adapter->event_trigger.physical_efuse_map = 0;
+		}
+
+		if (halmac_adapter->event_trigger.logical_efuse_map == 1) {
+			if (halmac_eeprom_parser_88xx(
+				    halmac_adapter,
+				    halmac_adapter->hal_efuse_map,
+				    eeprom_map) != HALMAC_RET_SUCCESS) {
+				kfree(eeprom_map);
+				return HALMAC_RET_EEPROM_PARSING_FAIL;
+			}
+			PLATFORM_EVENT_INDICATION(
+				driver_adapter,
+				HALMAC_FEATURE_DUMP_LOGICAL_EFUSE,
+				process_status, eeprom_map, eeprom_size);
+			halmac_adapter->event_trigger.logical_efuse_map = 0;
+		}
+	} else {
+		process_status = HALMAC_CMD_PROCESS_ERROR;
+		halmac_adapter->halmac_state.efuse_state_set.process_status =
+			process_status;
+
+		if (halmac_adapter->event_trigger.physical_efuse_map == 1) {
+			PLATFORM_EVENT_INDICATION(
+				driver_adapter,
+				HALMAC_FEATURE_DUMP_PHYSICAL_EFUSE,
+				process_status,
+				&halmac_adapter->halmac_state.efuse_state_set
+					 .fw_return_code,
+				1);
+			halmac_adapter->event_trigger.physical_efuse_map = 0;
+		}
+
+		if (halmac_adapter->event_trigger.logical_efuse_map == 1) {
+			if (halmac_eeprom_parser_88xx(
+				    halmac_adapter,
+				    halmac_adapter->hal_efuse_map,
+				    eeprom_map) != HALMAC_RET_SUCCESS) {
+				kfree(eeprom_map);
+				return HALMAC_RET_EEPROM_PARSING_FAIL;
+			}
+			PLATFORM_EVENT_INDICATION(
+				driver_adapter,
+				HALMAC_FEATURE_DUMP_LOGICAL_EFUSE,
+				process_status,
+				&halmac_adapter->halmac_state.efuse_state_set
+					 .fw_return_code,
+				1);
+			halmac_adapter->event_trigger.logical_efuse_map = 0;
+		}
+	}
+
+	kfree(eeprom_map);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_88xx(struct halmac_adapter *halmac_adapter, u8 *c2h_buf,
+			  u32 c2h_size)
+{
+	u8 h2c_cmd_id, h2c_sub_cmd_id;
+	u8 h2c_return_code;
+	void *driver_adapter = halmac_adapter->driver_adapter;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"Ack for C2H!!\n");
+
+	h2c_return_code = (u8)H2C_ACK_HDR_GET_H2C_RETURN_CODE(c2h_buf);
+	if ((enum halmac_h2c_return_code)h2c_return_code !=
+	    HALMAC_H2C_RETURN_SUCCESS)
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+				"C2H_PKT Status Error!! Status = %d\n",
+				h2c_return_code);
+
+	h2c_cmd_id = (u8)H2C_ACK_HDR_GET_H2C_CMD_ID(c2h_buf);
+
+	if (h2c_cmd_id != 0xFF) {
+		pr_err("original h2c ack is not handled!!\n");
+		status = HALMAC_RET_C2H_NOT_HANDLED;
+	} else {
+		h2c_sub_cmd_id = (u8)H2C_ACK_HDR_GET_H2C_SUB_CMD_ID(c2h_buf);
+
+		switch (h2c_sub_cmd_id) {
+		case H2C_SUB_CMD_ID_DUMP_PHYSICAL_EFUSE_ACK:
+			status = halmac_parse_h2c_ack_phy_efuse_88xx(
+				halmac_adapter, c2h_buf, c2h_size);
+			break;
+		case H2C_SUB_CMD_ID_CFG_PARAMETER_ACK:
+			status = halmac_parse_h2c_ack_cfg_para_88xx(
+				halmac_adapter, c2h_buf, c2h_size);
+			break;
+		case H2C_SUB_CMD_ID_UPDATE_PACKET_ACK:
+			status = halmac_parse_h2c_ack_update_packet_88xx(
+				halmac_adapter, c2h_buf, c2h_size);
+			break;
+		case H2C_SUB_CMD_ID_UPDATE_DATAPACK_ACK:
+			status = halmac_parse_h2c_ack_update_datapack_88xx(
+				halmac_adapter, c2h_buf, c2h_size);
+			break;
+		case H2C_SUB_CMD_ID_RUN_DATAPACK_ACK:
+			status = halmac_parse_h2c_ack_run_datapack_88xx(
+				halmac_adapter, c2h_buf, c2h_size);
+			break;
+		case H2C_SUB_CMD_ID_CHANNEL_SWITCH_ACK:
+			status = halmac_parse_h2c_ack_channel_switch_88xx(
+				halmac_adapter, c2h_buf, c2h_size);
+			break;
+		case H2C_SUB_CMD_ID_IQK_ACK:
+			status = halmac_parse_h2c_ack_iqk_88xx(
+				halmac_adapter, c2h_buf, c2h_size);
+			break;
+		case H2C_SUB_CMD_ID_POWER_TRACKING_ACK:
+			status = halmac_parse_h2c_ack_power_tracking_88xx(
+				halmac_adapter, c2h_buf, c2h_size);
+			break;
+		case H2C_SUB_CMD_ID_PSD_ACK:
+			break;
+		default:
+			pr_err("h2c_sub_cmd_id switch case out of boundary!!\n");
+			status = HALMAC_RET_C2H_NOT_HANDLED;
+			break;
+		}
+	}
+
+	return status;
+}
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_phy_efuse_88xx(struct halmac_adapter *halmac_adapter,
+				    u8 *c2h_buf, u32 c2h_size)
+{
+	u8 h2c_seq = 0;
+	u8 h2c_return_code;
+	void *driver_adapter = halmac_adapter->driver_adapter;
+
+	h2c_seq = (u8)H2C_ACK_HDR_GET_H2C_SEQ(c2h_buf);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"[TRACE]Seq num : h2c -> %d c2h -> %d\n",
+			halmac_adapter->halmac_state.efuse_state_set.seq_num,
+			h2c_seq);
+	if (h2c_seq != halmac_adapter->halmac_state.efuse_state_set.seq_num) {
+		pr_err("[ERR]Seq num mismactch : h2c -> %d c2h -> %d\n",
+		       halmac_adapter->halmac_state.efuse_state_set.seq_num,
+		       h2c_seq);
+		return HALMAC_RET_SUCCESS;
+	}
+
+	if (halmac_adapter->halmac_state.efuse_state_set.process_status !=
+	    HALMAC_CMD_PROCESS_SENDING) {
+		pr_err("[ERR]Not in HALMAC_CMD_PROCESS_SENDING\n");
+		return HALMAC_RET_SUCCESS;
+	}
+
+	h2c_return_code = (u8)H2C_ACK_HDR_GET_H2C_RETURN_CODE(c2h_buf);
+	halmac_adapter->halmac_state.efuse_state_set.fw_return_code =
+		h2c_return_code;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_cfg_para_88xx(struct halmac_adapter *halmac_adapter,
+				   u8 *c2h_buf, u32 c2h_size)
+{
+	u8 h2c_seq = 0;
+	u8 h2c_return_code;
+	u32 offset_accu = 0, value_accu = 0;
+	void *driver_adapter = halmac_adapter->driver_adapter;
+	enum halmac_cmd_process_status process_status =
+		HALMAC_CMD_PROCESS_UNDEFINE;
+
+	h2c_seq = (u8)H2C_ACK_HDR_GET_H2C_SEQ(c2h_buf);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"Seq num : h2c -> %d c2h -> %d\n",
+			halmac_adapter->halmac_state.cfg_para_state_set.seq_num,
+			h2c_seq);
+	if (h2c_seq !=
+	    halmac_adapter->halmac_state.cfg_para_state_set.seq_num) {
+		pr_err("Seq num mismactch : h2c -> %d c2h -> %d\n",
+		       halmac_adapter->halmac_state.cfg_para_state_set.seq_num,
+		       h2c_seq);
+		return HALMAC_RET_SUCCESS;
+	}
+
+	if (halmac_adapter->halmac_state.cfg_para_state_set.process_status !=
+	    HALMAC_CMD_PROCESS_SENDING) {
+		pr_err("Not in HALMAC_CMD_PROCESS_SENDING\n");
+		return HALMAC_RET_SUCCESS;
+	}
+
+	h2c_return_code = (u8)H2C_ACK_HDR_GET_H2C_RETURN_CODE(c2h_buf);
+	halmac_adapter->halmac_state.cfg_para_state_set.fw_return_code =
+		h2c_return_code;
+	offset_accu = CFG_PARAMETER_ACK_GET_OFFSET_ACCUMULATION(c2h_buf);
+	value_accu = CFG_PARAMETER_ACK_GET_VALUE_ACCUMULATION(c2h_buf);
+
+	if ((offset_accu !=
+	     halmac_adapter->config_para_info.offset_accumulation) ||
+	    (value_accu !=
+	     halmac_adapter->config_para_info.value_accumulation)) {
+		pr_err("[C2H]offset_accu : %x, value_accu : %x!!\n",
+		       offset_accu, value_accu);
+		pr_err("[Adapter]offset_accu : %x, value_accu : %x!!\n",
+		       halmac_adapter->config_para_info.offset_accumulation,
+		       halmac_adapter->config_para_info.value_accumulation);
+		process_status = HALMAC_CMD_PROCESS_ERROR;
+	}
+
+	if ((enum halmac_h2c_return_code)h2c_return_code ==
+		    HALMAC_H2C_RETURN_SUCCESS &&
+	    process_status != HALMAC_CMD_PROCESS_ERROR) {
+		process_status = HALMAC_CMD_PROCESS_DONE;
+		halmac_adapter->halmac_state.cfg_para_state_set.process_status =
+			process_status;
+		PLATFORM_EVENT_INDICATION(driver_adapter,
+					  HALMAC_FEATURE_CFG_PARA,
+					  process_status, NULL, 0);
+	} else {
+		process_status = HALMAC_CMD_PROCESS_ERROR;
+		halmac_adapter->halmac_state.cfg_para_state_set.process_status =
+			process_status;
+		PLATFORM_EVENT_INDICATION(
+			driver_adapter, HALMAC_FEATURE_CFG_PARA, process_status,
+			&halmac_adapter->halmac_state.cfg_para_state_set
+				 .fw_return_code,
+			1);
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_update_packet_88xx(struct halmac_adapter *halmac_adapter,
+					u8 *c2h_buf, u32 c2h_size)
+{
+	u8 h2c_seq = 0;
+	u8 h2c_return_code;
+	void *driver_adapter = halmac_adapter->driver_adapter;
+	enum halmac_cmd_process_status process_status;
+
+	h2c_seq = (u8)H2C_ACK_HDR_GET_H2C_SEQ(c2h_buf);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"[TRACE]Seq num : h2c -> %d c2h -> %d\n",
+			halmac_adapter->halmac_state.update_packet_set.seq_num,
+			h2c_seq);
+	if (h2c_seq != halmac_adapter->halmac_state.update_packet_set.seq_num) {
+		pr_err("[ERR]Seq num mismactch : h2c -> %d c2h -> %d\n",
+		       halmac_adapter->halmac_state.update_packet_set.seq_num,
+		       h2c_seq);
+		return HALMAC_RET_SUCCESS;
+	}
+
+	if (halmac_adapter->halmac_state.update_packet_set.process_status !=
+	    HALMAC_CMD_PROCESS_SENDING) {
+		pr_err("[ERR]Not in HALMAC_CMD_PROCESS_SENDING\n");
+		return HALMAC_RET_SUCCESS;
+	}
+
+	h2c_return_code = (u8)H2C_ACK_HDR_GET_H2C_RETURN_CODE(c2h_buf);
+	halmac_adapter->halmac_state.update_packet_set.fw_return_code =
+		h2c_return_code;
+
+	if ((enum halmac_h2c_return_code)h2c_return_code ==
+	    HALMAC_H2C_RETURN_SUCCESS) {
+		process_status = HALMAC_CMD_PROCESS_DONE;
+		halmac_adapter->halmac_state.update_packet_set.process_status =
+			process_status;
+		PLATFORM_EVENT_INDICATION(driver_adapter,
+					  HALMAC_FEATURE_UPDATE_PACKET,
+					  process_status, NULL, 0);
+	} else {
+		process_status = HALMAC_CMD_PROCESS_ERROR;
+		halmac_adapter->halmac_state.update_packet_set.process_status =
+			process_status;
+		PLATFORM_EVENT_INDICATION(
+			driver_adapter, HALMAC_FEATURE_UPDATE_PACKET,
+			process_status,
+			&halmac_adapter->halmac_state.update_packet_set
+				 .fw_return_code,
+			1);
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_update_datapack_88xx(struct halmac_adapter *halmac_adapter,
+					  u8 *c2h_buf, u32 c2h_size)
+{
+	void *driver_adapter = halmac_adapter->driver_adapter;
+	enum halmac_cmd_process_status process_status =
+		HALMAC_CMD_PROCESS_UNDEFINE;
+
+	PLATFORM_EVENT_INDICATION(driver_adapter,
+				  HALMAC_FEATURE_UPDATE_DATAPACK,
+				  process_status, NULL, 0);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_run_datapack_88xx(struct halmac_adapter *halmac_adapter,
+				       u8 *c2h_buf, u32 c2h_size)
+{
+	void *driver_adapter = halmac_adapter->driver_adapter;
+	enum halmac_cmd_process_status process_status =
+		HALMAC_CMD_PROCESS_UNDEFINE;
+
+	PLATFORM_EVENT_INDICATION(driver_adapter, HALMAC_FEATURE_RUN_DATAPACK,
+				  process_status, NULL, 0);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_channel_switch_88xx(struct halmac_adapter *halmac_adapter,
+					 u8 *c2h_buf, u32 c2h_size)
+{
+	u8 h2c_seq = 0;
+	u8 h2c_return_code;
+	void *driver_adapter = halmac_adapter->driver_adapter;
+	enum halmac_cmd_process_status process_status;
+
+	h2c_seq = (u8)H2C_ACK_HDR_GET_H2C_SEQ(c2h_buf);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"[TRACE]Seq num : h2c -> %d c2h -> %d\n",
+			halmac_adapter->halmac_state.scan_state_set.seq_num,
+			h2c_seq);
+	if (h2c_seq != halmac_adapter->halmac_state.scan_state_set.seq_num) {
+		pr_err("[ERR]Seq num mismactch : h2c -> %d c2h -> %d\n",
+		       halmac_adapter->halmac_state.scan_state_set.seq_num,
+		       h2c_seq);
+		return HALMAC_RET_SUCCESS;
+	}
+
+	if (halmac_adapter->halmac_state.scan_state_set.process_status !=
+	    HALMAC_CMD_PROCESS_SENDING) {
+		pr_err("[ERR]Not in HALMAC_CMD_PROCESS_SENDING\n");
+		return HALMAC_RET_SUCCESS;
+	}
+
+	h2c_return_code = (u8)H2C_ACK_HDR_GET_H2C_RETURN_CODE(c2h_buf);
+	halmac_adapter->halmac_state.scan_state_set.fw_return_code =
+		h2c_return_code;
+
+	if ((enum halmac_h2c_return_code)h2c_return_code ==
+	    HALMAC_H2C_RETURN_SUCCESS) {
+		process_status = HALMAC_CMD_PROCESS_RCVD;
+		halmac_adapter->halmac_state.scan_state_set.process_status =
+			process_status;
+		PLATFORM_EVENT_INDICATION(driver_adapter,
+					  HALMAC_FEATURE_CHANNEL_SWITCH,
+					  process_status, NULL, 0);
+	} else {
+		process_status = HALMAC_CMD_PROCESS_ERROR;
+		halmac_adapter->halmac_state.scan_state_set.process_status =
+			process_status;
+		PLATFORM_EVENT_INDICATION(
+			driver_adapter, HALMAC_FEATURE_CHANNEL_SWITCH,
+			process_status, &halmac_adapter->halmac_state
+						 .scan_state_set.fw_return_code,
+			1);
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_iqk_88xx(struct halmac_adapter *halmac_adapter,
+			      u8 *c2h_buf, u32 c2h_size)
+{
+	u8 h2c_seq = 0;
+	u8 h2c_return_code;
+	void *driver_adapter = halmac_adapter->driver_adapter;
+	enum halmac_cmd_process_status process_status;
+
+	h2c_seq = (u8)H2C_ACK_HDR_GET_H2C_SEQ(c2h_buf);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"[TRACE]Seq num : h2c -> %d c2h -> %d\n",
+			halmac_adapter->halmac_state.iqk_set.seq_num, h2c_seq);
+	if (h2c_seq != halmac_adapter->halmac_state.iqk_set.seq_num) {
+		pr_err("[ERR]Seq num mismactch : h2c -> %d c2h -> %d\n",
+		       halmac_adapter->halmac_state.iqk_set.seq_num, h2c_seq);
+		return HALMAC_RET_SUCCESS;
+	}
+
+	if (halmac_adapter->halmac_state.iqk_set.process_status !=
+	    HALMAC_CMD_PROCESS_SENDING) {
+		pr_err("[ERR]Not in HALMAC_CMD_PROCESS_SENDING\n");
+		return HALMAC_RET_SUCCESS;
+	}
+
+	h2c_return_code = (u8)H2C_ACK_HDR_GET_H2C_RETURN_CODE(c2h_buf);
+	halmac_adapter->halmac_state.iqk_set.fw_return_code = h2c_return_code;
+
+	if ((enum halmac_h2c_return_code)h2c_return_code ==
+	    HALMAC_H2C_RETURN_SUCCESS) {
+		process_status = HALMAC_CMD_PROCESS_DONE;
+		halmac_adapter->halmac_state.iqk_set.process_status =
+			process_status;
+		PLATFORM_EVENT_INDICATION(driver_adapter, HALMAC_FEATURE_IQK,
+					  process_status, NULL, 0);
+	} else {
+		process_status = HALMAC_CMD_PROCESS_ERROR;
+		halmac_adapter->halmac_state.iqk_set.process_status =
+			process_status;
+		PLATFORM_EVENT_INDICATION(
+			driver_adapter, HALMAC_FEATURE_IQK, process_status,
+			&halmac_adapter->halmac_state.iqk_set.fw_return_code,
+			1);
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_parse_h2c_ack_power_tracking_88xx(struct halmac_adapter *halmac_adapter,
+					 u8 *c2h_buf, u32 c2h_size)
+{
+	u8 h2c_seq = 0;
+	u8 h2c_return_code;
+	void *driver_adapter = halmac_adapter->driver_adapter;
+	enum halmac_cmd_process_status process_status;
+
+	h2c_seq = (u8)H2C_ACK_HDR_GET_H2C_SEQ(c2h_buf);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_H2C, DBG_DMESG,
+			"[TRACE]Seq num : h2c -> %d c2h -> %d\n",
+			halmac_adapter->halmac_state.power_tracking_set.seq_num,
+			h2c_seq);
+	if (h2c_seq !=
+	    halmac_adapter->halmac_state.power_tracking_set.seq_num) {
+		pr_err("[ERR]Seq num mismactch : h2c -> %d c2h -> %d\n",
+		       halmac_adapter->halmac_state.power_tracking_set.seq_num,
+		       h2c_seq);
+		return HALMAC_RET_SUCCESS;
+	}
+
+	if (halmac_adapter->halmac_state.power_tracking_set.process_status !=
+	    HALMAC_CMD_PROCESS_SENDING) {
+		pr_err("[ERR]Not in HALMAC_CMD_PROCESS_SENDING\n");
+		return HALMAC_RET_SUCCESS;
+	}
+
+	h2c_return_code = (u8)H2C_ACK_HDR_GET_H2C_RETURN_CODE(c2h_buf);
+	halmac_adapter->halmac_state.power_tracking_set.fw_return_code =
+		h2c_return_code;
+
+	if ((enum halmac_h2c_return_code)h2c_return_code ==
+	    HALMAC_H2C_RETURN_SUCCESS) {
+		process_status = HALMAC_CMD_PROCESS_DONE;
+		halmac_adapter->halmac_state.power_tracking_set.process_status =
+			process_status;
+		PLATFORM_EVENT_INDICATION(driver_adapter,
+					  HALMAC_FEATURE_POWER_TRACKING,
+					  process_status, NULL, 0);
+	} else {
+		process_status = HALMAC_CMD_PROCESS_ERROR;
+		halmac_adapter->halmac_state.power_tracking_set.process_status =
+			process_status;
+		PLATFORM_EVENT_INDICATION(
+			driver_adapter, HALMAC_FEATURE_POWER_TRACKING,
+			process_status,
+			&halmac_adapter->halmac_state.power_tracking_set
+				 .fw_return_code,
+			1);
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_convert_to_sdio_bus_offset_88xx(struct halmac_adapter *halmac_adapter,
+				       u32 *halmac_offset)
+{
+	void *driver_adapter = NULL;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	switch ((*halmac_offset) & 0xFFFF0000) {
+	case WLAN_IOREG_OFFSET:
+		*halmac_offset = (HALMAC_SDIO_CMD_ADDR_MAC_REG << 13) |
+				 (*halmac_offset & HALMAC_WLAN_MAC_REG_MSK);
+		break;
+	case SDIO_LOCAL_OFFSET:
+		*halmac_offset = (HALMAC_SDIO_CMD_ADDR_SDIO_REG << 13) |
+				 (*halmac_offset & HALMAC_SDIO_LOCAL_MSK);
+		break;
+	default:
+		*halmac_offset = 0xFFFFFFFF;
+		pr_err("Unknown base address!!\n");
+		return HALMAC_RET_CONVERT_SDIO_OFFSET_FAIL;
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_update_sdio_free_page_88xx(struct halmac_adapter *halmac_adapter)
+{
+	u32 free_page = 0, free_page2 = 0, free_page3 = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	struct halmac_sdio_free_space *sdio_free_space;
+	u8 data[12] = {0};
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	sdio_free_space = &halmac_adapter->sdio_free_space;
+	/*need to use HALMAC_REG_READ_N, 20160316, Soar*/
+	HALMAC_REG_SDIO_CMD53_READ_N(halmac_adapter, REG_SDIO_FREE_TXPG, 12,
+				     data);
+	free_page =
+		data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);
+	free_page2 =
+		data[4] | (data[5] << 8) | (data[6] << 16) | (data[7] << 24);
+	free_page3 =
+		data[8] | (data[9] << 8) | (data[10] << 16) | (data[11] << 24);
+
+	sdio_free_space->high_queue_number =
+		(u16)BIT_GET_HIQ_FREEPG_V1(free_page);
+	sdio_free_space->normal_queue_number =
+		(u16)BIT_GET_MID_FREEPG_V1(free_page);
+	sdio_free_space->low_queue_number =
+		(u16)BIT_GET_LOW_FREEPG_V1(free_page2);
+	sdio_free_space->public_queue_number =
+		(u16)BIT_GET_PUB_FREEPG_V1(free_page2);
+	sdio_free_space->extra_queue_number =
+		(u16)BIT_GET_EXQ_FREEPG_V1(free_page3);
+	sdio_free_space->ac_oqt_number = (u8)((free_page3 >> 16) & 0xFF);
+	sdio_free_space->non_ac_oqt_number = (u8)((free_page3 >> 24) & 0xFF);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_update_oqt_free_space_88xx(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	struct halmac_sdio_free_space *sdio_free_space;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	sdio_free_space = &halmac_adapter->sdio_free_space;
+
+	sdio_free_space->ac_oqt_number = HALMAC_REG_READ_8(
+		halmac_adapter, REG_SDIO_OQT_FREE_TXPG_V1 + 2);
+	sdio_free_space->ac_empty =
+		HALMAC_REG_READ_8(halmac_adapter, REG_TXPKT_EMPTY);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s <==========\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_efuse_cmd_construct_state
+halmac_query_efuse_curr_state_88xx(struct halmac_adapter *halmac_adapter)
+{
+	return halmac_adapter->halmac_state.efuse_state_set
+		.efuse_cmd_construct_state;
+}
+
+enum halmac_ret_status halmac_transition_efuse_state_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_efuse_cmd_construct_state dest_state)
+{
+	struct halmac_efuse_state_set *efuse_state =
+		&halmac_adapter->halmac_state.efuse_state_set;
+
+	if (efuse_state->efuse_cmd_construct_state !=
+		    HALMAC_EFUSE_CMD_CONSTRUCT_IDLE &&
+	    efuse_state->efuse_cmd_construct_state !=
+		    HALMAC_EFUSE_CMD_CONSTRUCT_BUSY &&
+	    efuse_state->efuse_cmd_construct_state !=
+		    HALMAC_EFUSE_CMD_CONSTRUCT_H2C_SENT)
+		return HALMAC_RET_ERROR_STATE;
+
+	if (efuse_state->efuse_cmd_construct_state == dest_state)
+		return HALMAC_RET_ERROR_STATE;
+
+	if (dest_state == HALMAC_EFUSE_CMD_CONSTRUCT_BUSY) {
+		if (efuse_state->efuse_cmd_construct_state ==
+		    HALMAC_EFUSE_CMD_CONSTRUCT_H2C_SENT)
+			return HALMAC_RET_ERROR_STATE;
+	} else if (dest_state == HALMAC_EFUSE_CMD_CONSTRUCT_H2C_SENT) {
+		if (efuse_state->efuse_cmd_construct_state ==
+		    HALMAC_EFUSE_CMD_CONSTRUCT_IDLE)
+			return HALMAC_RET_ERROR_STATE;
+	}
+
+	efuse_state->efuse_cmd_construct_state = dest_state;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_cfg_para_cmd_construct_state
+halmac_query_cfg_para_curr_state_88xx(struct halmac_adapter *halmac_adapter)
+{
+	return halmac_adapter->halmac_state.cfg_para_state_set
+		.cfg_para_cmd_construct_state;
+}
+
+enum halmac_ret_status halmac_transition_cfg_para_state_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_cfg_para_cmd_construct_state dest_state)
+{
+	struct halmac_cfg_para_state_set *cfg_para =
+		&halmac_adapter->halmac_state.cfg_para_state_set;
+
+	if (cfg_para->cfg_para_cmd_construct_state !=
+		    HALMAC_CFG_PARA_CMD_CONSTRUCT_IDLE &&
+	    cfg_para->cfg_para_cmd_construct_state !=
+		    HALMAC_CFG_PARA_CMD_CONSTRUCT_CONSTRUCTING &&
+	    cfg_para->cfg_para_cmd_construct_state !=
+		    HALMAC_CFG_PARA_CMD_CONSTRUCT_H2C_SENT)
+		return HALMAC_RET_ERROR_STATE;
+
+	if (dest_state == HALMAC_CFG_PARA_CMD_CONSTRUCT_IDLE) {
+		if (cfg_para->cfg_para_cmd_construct_state ==
+		    HALMAC_CFG_PARA_CMD_CONSTRUCT_CONSTRUCTING)
+			return HALMAC_RET_ERROR_STATE;
+	} else if (dest_state == HALMAC_CFG_PARA_CMD_CONSTRUCT_CONSTRUCTING) {
+		if (cfg_para->cfg_para_cmd_construct_state ==
+		    HALMAC_CFG_PARA_CMD_CONSTRUCT_H2C_SENT)
+			return HALMAC_RET_ERROR_STATE;
+	} else if (dest_state == HALMAC_CFG_PARA_CMD_CONSTRUCT_H2C_SENT) {
+		if (cfg_para->cfg_para_cmd_construct_state ==
+			    HALMAC_CFG_PARA_CMD_CONSTRUCT_IDLE ||
+		    cfg_para->cfg_para_cmd_construct_state ==
+			    HALMAC_CFG_PARA_CMD_CONSTRUCT_H2C_SENT)
+			return HALMAC_RET_ERROR_STATE;
+	}
+
+	cfg_para->cfg_para_cmd_construct_state = dest_state;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_scan_cmd_construct_state
+halmac_query_scan_curr_state_88xx(struct halmac_adapter *halmac_adapter)
+{
+	return halmac_adapter->halmac_state.scan_state_set
+		.scan_cmd_construct_state;
+}
+
+enum halmac_ret_status halmac_transition_scan_state_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_scan_cmd_construct_state dest_state)
+{
+	struct halmac_scan_state_set *scan =
+		&halmac_adapter->halmac_state.scan_state_set;
+
+	if (scan->scan_cmd_construct_state > HALMAC_SCAN_CMD_CONSTRUCT_H2C_SENT)
+		return HALMAC_RET_ERROR_STATE;
+
+	if (dest_state == HALMAC_SCAN_CMD_CONSTRUCT_IDLE) {
+		if (scan->scan_cmd_construct_state ==
+			    HALMAC_SCAN_CMD_CONSTRUCT_BUFFER_CLEARED ||
+		    scan->scan_cmd_construct_state ==
+			    HALMAC_SCAN_CMD_CONSTRUCT_CONSTRUCTING)
+			return HALMAC_RET_ERROR_STATE;
+	} else if (dest_state == HALMAC_SCAN_CMD_CONSTRUCT_BUFFER_CLEARED) {
+		if (scan->scan_cmd_construct_state ==
+		    HALMAC_SCAN_CMD_CONSTRUCT_H2C_SENT)
+			return HALMAC_RET_ERROR_STATE;
+	} else if (dest_state == HALMAC_SCAN_CMD_CONSTRUCT_CONSTRUCTING) {
+		if (scan->scan_cmd_construct_state ==
+			    HALMAC_SCAN_CMD_CONSTRUCT_IDLE ||
+		    scan->scan_cmd_construct_state ==
+			    HALMAC_SCAN_CMD_CONSTRUCT_H2C_SENT)
+			return HALMAC_RET_ERROR_STATE;
+	} else if (dest_state == HALMAC_SCAN_CMD_CONSTRUCT_H2C_SENT) {
+		if (scan->scan_cmd_construct_state !=
+			    HALMAC_SCAN_CMD_CONSTRUCT_CONSTRUCTING &&
+		    scan->scan_cmd_construct_state !=
+			    HALMAC_SCAN_CMD_CONSTRUCT_BUFFER_CLEARED)
+			return HALMAC_RET_ERROR_STATE;
+	}
+
+	scan->scan_cmd_construct_state = dest_state;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status halmac_query_cfg_para_status_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_cmd_process_status *process_status, u8 *data, u32 *size)
+{
+	struct halmac_cfg_para_state_set *cfg_para_state_set =
+		&halmac_adapter->halmac_state.cfg_para_state_set;
+
+	*process_status = cfg_para_state_set->process_status;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status halmac_query_dump_physical_efuse_status_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_cmd_process_status *process_status, u8 *data, u32 *size)
+{
+	void *driver_adapter = NULL;
+	struct halmac_efuse_state_set *efuse_state_set =
+		&halmac_adapter->halmac_state.efuse_state_set;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	*process_status = efuse_state_set->process_status;
+
+	if (!data)
+		return HALMAC_RET_NULL_POINTER;
+
+	if (!size)
+		return HALMAC_RET_NULL_POINTER;
+
+	if (*process_status == HALMAC_CMD_PROCESS_DONE) {
+		if (*size < halmac_adapter->hw_config_info.efuse_size) {
+			*size = halmac_adapter->hw_config_info.efuse_size;
+			return HALMAC_RET_BUFFER_TOO_SMALL;
+		}
+
+		*size = halmac_adapter->hw_config_info.efuse_size;
+		memcpy(data, halmac_adapter->hal_efuse_map, *size);
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status halmac_query_dump_logical_efuse_status_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_cmd_process_status *process_status, u8 *data, u32 *size)
+{
+	u8 *eeprom_map = NULL;
+	u32 eeprom_size = halmac_adapter->hw_config_info.eeprom_size;
+	void *driver_adapter = NULL;
+	struct halmac_efuse_state_set *efuse_state_set =
+		&halmac_adapter->halmac_state.efuse_state_set;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	*process_status = efuse_state_set->process_status;
+
+	if (!data)
+		return HALMAC_RET_NULL_POINTER;
+
+	if (!size)
+		return HALMAC_RET_NULL_POINTER;
+
+	if (*process_status == HALMAC_CMD_PROCESS_DONE) {
+		if (*size < eeprom_size) {
+			*size = eeprom_size;
+			return HALMAC_RET_BUFFER_TOO_SMALL;
+		}
+
+		*size = eeprom_size;
+
+		eeprom_map = kzalloc(eeprom_size, GFP_KERNEL);
+		if (!eeprom_map) {
+			/* out of memory */
+			return HALMAC_RET_MALLOC_FAIL;
+		}
+		memset(eeprom_map, 0xFF, eeprom_size);
+
+		if (halmac_eeprom_parser_88xx(
+			    halmac_adapter, halmac_adapter->hal_efuse_map,
+			    eeprom_map) != HALMAC_RET_SUCCESS) {
+			kfree(eeprom_map);
+			return HALMAC_RET_EEPROM_PARSING_FAIL;
+		}
+
+		memcpy(data, eeprom_map, *size);
+
+		kfree(eeprom_map);
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status halmac_query_channel_switch_status_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_cmd_process_status *process_status, u8 *data, u32 *size)
+{
+	struct halmac_scan_state_set *scan_state_set =
+		&halmac_adapter->halmac_state.scan_state_set;
+
+	*process_status = scan_state_set->process_status;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status halmac_query_update_packet_status_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_cmd_process_status *process_status, u8 *data, u32 *size)
+{
+	struct halmac_update_packet_state_set *update_packet_set =
+		&halmac_adapter->halmac_state.update_packet_set;
+
+	*process_status = update_packet_set->process_status;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_query_iqk_status_88xx(struct halmac_adapter *halmac_adapter,
+			     enum halmac_cmd_process_status *process_status,
+			     u8 *data, u32 *size)
+{
+	struct halmac_iqk_state_set *iqk_set =
+		&halmac_adapter->halmac_state.iqk_set;
+
+	*process_status = iqk_set->process_status;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status halmac_query_power_tracking_status_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_cmd_process_status *process_status, u8 *data, u32 *size)
+{
+	struct halmac_power_tracking_state_set *power_tracking_state_set =
+		&halmac_adapter->halmac_state.power_tracking_set;
+	;
+
+	*process_status = power_tracking_state_set->process_status;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_query_psd_status_88xx(struct halmac_adapter *halmac_adapter,
+			     enum halmac_cmd_process_status *process_status,
+			     u8 *data, u32 *size)
+{
+	void *driver_adapter = NULL;
+	struct halmac_psd_state_set *psd_set =
+		&halmac_adapter->halmac_state.psd_set;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	*process_status = psd_set->process_status;
+
+	if (!data)
+		return HALMAC_RET_NULL_POINTER;
+
+	if (!size)
+		return HALMAC_RET_NULL_POINTER;
+
+	if (*process_status == HALMAC_CMD_PROCESS_DONE) {
+		if (*size < psd_set->data_size) {
+			*size = psd_set->data_size;
+			return HALMAC_RET_BUFFER_TOO_SMALL;
+		}
+
+		*size = psd_set->data_size;
+		memcpy(data, psd_set->data, *size);
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_verify_io_88xx(struct halmac_adapter *halmac_adapter)
+{
+	u8 value8, wvalue8;
+	u32 value32, value32_2, wvalue32;
+	u32 halmac_offset;
+	void *driver_adapter = NULL;
+	enum halmac_ret_status ret_status = HALMAC_RET_SUCCESS;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_SDIO) {
+		halmac_offset = REG_PAGE5_DUMMY;
+		if ((halmac_offset & 0xFFFF0000) == 0)
+			halmac_offset |= WLAN_IOREG_OFFSET;
+
+		ret_status = halmac_convert_to_sdio_bus_offset_88xx(
+			halmac_adapter, &halmac_offset);
+
+		/* Verify CMD52 R/W */
+		wvalue8 = 0xab;
+		PLATFORM_SDIO_CMD52_WRITE(driver_adapter, halmac_offset,
+					  wvalue8);
+
+		value8 =
+			PLATFORM_SDIO_CMD52_READ(driver_adapter, halmac_offset);
+
+		if (value8 != wvalue8) {
+			pr_err("cmd52 r/w fail write = %X read = %X\n", wvalue8,
+			       value8);
+			ret_status = HALMAC_RET_PLATFORM_API_INCORRECT;
+		} else {
+			HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT,
+					DBG_DMESG, "cmd52 r/w ok\n");
+		}
+
+		/* Verify CMD53 R/W */
+		PLATFORM_SDIO_CMD52_WRITE(driver_adapter, halmac_offset, 0xaa);
+		PLATFORM_SDIO_CMD52_WRITE(driver_adapter, halmac_offset + 1,
+					  0xbb);
+		PLATFORM_SDIO_CMD52_WRITE(driver_adapter, halmac_offset + 2,
+					  0xcc);
+		PLATFORM_SDIO_CMD52_WRITE(driver_adapter, halmac_offset + 3,
+					  0xdd);
+
+		value32 = PLATFORM_SDIO_CMD53_READ_32(driver_adapter,
+						      halmac_offset);
+
+		if (value32 != 0xddccbbaa) {
+			pr_err("cmd53 r fail : read = %X\n", value32);
+			ret_status = HALMAC_RET_PLATFORM_API_INCORRECT;
+		} else {
+			HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT,
+					DBG_DMESG, "cmd53 r ok\n");
+		}
+
+		wvalue32 = 0x11223344;
+		PLATFORM_SDIO_CMD53_WRITE_32(driver_adapter, halmac_offset,
+					     wvalue32);
+
+		value32 = PLATFORM_SDIO_CMD53_READ_32(driver_adapter,
+						      halmac_offset);
+
+		if (value32 != wvalue32) {
+			pr_err("cmd53 w fail\n");
+			ret_status = HALMAC_RET_PLATFORM_API_INCORRECT;
+		} else {
+			HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT,
+					DBG_DMESG, "cmd53 w ok\n");
+		}
+
+		value32 = PLATFORM_SDIO_CMD53_READ_32(
+			driver_adapter,
+			halmac_offset + 2); /* value32 should be 0x33441122 */
+
+		wvalue32 = 0x11225566;
+		PLATFORM_SDIO_CMD53_WRITE_32(driver_adapter, halmac_offset,
+					     wvalue32);
+
+		value32_2 = PLATFORM_SDIO_CMD53_READ_32(
+			driver_adapter,
+			halmac_offset + 2); /* value32 should be 0x55661122 */
+		if (value32_2 == value32) {
+			pr_err("cmd52 is used for HAL_SDIO_CMD53_READ_32\n");
+			ret_status = HALMAC_RET_PLATFORM_API_INCORRECT;
+		} else {
+			HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT,
+					DBG_DMESG, "cmd53 is correctly used\n");
+		}
+	} else {
+		wvalue32 = 0x77665511;
+		PLATFORM_REG_WRITE_32(driver_adapter, REG_PAGE5_DUMMY,
+				      wvalue32);
+
+		value32 = PLATFORM_REG_READ_32(driver_adapter, REG_PAGE5_DUMMY);
+		if (value32 != wvalue32) {
+			pr_err("reg rw\n");
+			ret_status = HALMAC_RET_PLATFORM_API_INCORRECT;
+		} else {
+			HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT,
+					DBG_DMESG, "reg rw ok\n");
+		}
+	}
+
+	return ret_status;
+}
+
+enum halmac_ret_status
+halmac_verify_send_rsvd_page_88xx(struct halmac_adapter *halmac_adapter)
+{
+	u8 *rsvd_buf = NULL;
+	u8 *rsvd_page = NULL;
+	u32 i;
+	u32 h2c_pkt_verify_size = 64, h2c_pkt_verify_payload = 0xab;
+	void *driver_adapter = NULL;
+	enum halmac_ret_status ret_status = HALMAC_RET_SUCCESS;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	rsvd_buf = kzalloc(h2c_pkt_verify_size, GFP_KERNEL);
+
+	if (!rsvd_buf) {
+		/*pr_err("[ERR]rsvd buffer malloc fail!!\n");*/
+		return HALMAC_RET_MALLOC_FAIL;
+	}
+
+	memset(rsvd_buf, (u8)h2c_pkt_verify_payload, h2c_pkt_verify_size);
+
+	ret_status = halmac_download_rsvd_page_88xx(halmac_adapter, rsvd_buf,
+						    h2c_pkt_verify_size);
+
+	if (ret_status != HALMAC_RET_SUCCESS) {
+		kfree(rsvd_buf);
+		return ret_status;
+	}
+
+	rsvd_page = kzalloc(h2c_pkt_verify_size +
+				    halmac_adapter->hw_config_info.txdesc_size,
+			    GFP_KERNEL);
+
+	if (!rsvd_page) {
+		pr_err("[ERR]rsvd page malloc fail!!\n");
+		kfree(rsvd_buf);
+		return HALMAC_RET_MALLOC_FAIL;
+	}
+
+	memset(rsvd_page, 0x00,
+	       h2c_pkt_verify_size +
+		       halmac_adapter->hw_config_info.txdesc_size);
+
+	ret_status = halmac_dump_fifo_88xx(
+		halmac_adapter, HAL_FIFO_SEL_RSVD_PAGE, 0,
+		h2c_pkt_verify_size +
+			halmac_adapter->hw_config_info.txdesc_size,
+		rsvd_page);
+
+	if (ret_status != HALMAC_RET_SUCCESS) {
+		kfree(rsvd_buf);
+		kfree(rsvd_page);
+		return ret_status;
+	}
+
+	for (i = 0; i < h2c_pkt_verify_size; i++) {
+		if (*(rsvd_buf + i) !=
+		    *(rsvd_page +
+		      (i + halmac_adapter->hw_config_info.txdesc_size))) {
+			pr_err("[ERR]Compare RSVD page Fail\n");
+			ret_status = HALMAC_RET_PLATFORM_API_INCORRECT;
+		}
+	}
+
+	kfree(rsvd_buf);
+	kfree(rsvd_page);
+
+	return ret_status;
+}
+
+void halmac_power_save_cb_88xx(void *cb_data)
+{
+	void *driver_adapter = NULL;
+	struct halmac_adapter *halmac_adapter = (struct halmac_adapter *)NULL;
+
+	halmac_adapter = (struct halmac_adapter *)cb_data;
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_PWR, DBG_DMESG,
+			"%s\n", __func__);
+}
+
+enum halmac_ret_status
+halmac_buffer_read_88xx(struct halmac_adapter *halmac_adapter, u32 offset,
+			u32 size, enum hal_fifo_sel halmac_fifo_sel,
+			u8 *fifo_map)
+{
+	u32 start_page, value_read;
+	u32 i, counter = 0, residue;
+	struct halmac_api *halmac_api;
+
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if (halmac_fifo_sel == HAL_FIFO_SEL_RSVD_PAGE)
+		offset = offset +
+			 (halmac_adapter->txff_allocation.rsvd_pg_bndy << 7);
+
+	start_page = offset >> 12;
+	residue = offset & (4096 - 1);
+
+	if (halmac_fifo_sel == HAL_FIFO_SEL_TX ||
+	    halmac_fifo_sel == HAL_FIFO_SEL_RSVD_PAGE)
+		start_page += 0x780;
+	else if (halmac_fifo_sel == HAL_FIFO_SEL_RX)
+		start_page += 0x700;
+	else if (halmac_fifo_sel == HAL_FIFO_SEL_REPORT)
+		start_page += 0x660;
+	else if (halmac_fifo_sel == HAL_FIFO_SEL_LLT)
+		start_page += 0x650;
+	else
+		return HALMAC_RET_NOT_SUPPORT;
+
+	value_read = HALMAC_REG_READ_16(halmac_adapter, REG_PKTBUF_DBG_CTRL);
+
+	do {
+		HALMAC_REG_WRITE_16(halmac_adapter, REG_PKTBUF_DBG_CTRL,
+				    (u16)(start_page | (value_read & 0xF000)));
+
+		for (i = 0x8000 + residue; i <= 0x8FFF; i += 4) {
+			*(u32 *)(fifo_map + counter) =
+				HALMAC_REG_READ_32(halmac_adapter, i);
+			*(u32 *)(fifo_map + counter) =
+				le32_to_cpu(*(__le32 *)(fifo_map + counter));
+			counter += 4;
+			if (size == counter)
+				goto HALMAC_BUF_READ_OK;
+		}
+
+		residue = 0;
+		start_page++;
+	} while (1);
+
+HALMAC_BUF_READ_OK:
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_PKTBUF_DBG_CTRL,
+			    (u16)value_read);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+void halmac_restore_mac_register_88xx(struct halmac_adapter *halmac_adapter,
+				      struct halmac_restore_info *restore_info,
+				      u32 restore_num)
+{
+	u8 value_length;
+	u32 i;
+	u32 mac_register;
+	u32 mac_value;
+	struct halmac_api *halmac_api;
+	struct halmac_restore_info *curr_restore_info = restore_info;
+
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	for (i = 0; i < restore_num; i++) {
+		mac_register = curr_restore_info->mac_register;
+		mac_value = curr_restore_info->value;
+		value_length = curr_restore_info->length;
+
+		if (value_length == 1)
+			HALMAC_REG_WRITE_8(halmac_adapter, mac_register,
+					   (u8)mac_value);
+		else if (value_length == 2)
+			HALMAC_REG_WRITE_16(halmac_adapter, mac_register,
+					    (u16)mac_value);
+		else if (value_length == 4)
+			HALMAC_REG_WRITE_32(halmac_adapter, mac_register,
+					    mac_value);
+
+		curr_restore_info++;
+	}
+}
+
+void halmac_api_record_id_88xx(struct halmac_adapter *halmac_adapter,
+			       enum halmac_api_id api_id)
+{
+}
+
+enum halmac_ret_status
+halmac_set_usb_mode_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_usb_mode usb_mode)
+{
+	u32 usb_temp;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	enum halmac_usb_mode current_usb_mode;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	current_usb_mode =
+		HALMAC_REG_READ_8(halmac_adapter, REG_SYS_CFG2 + 3) == 0x20 ?
+			HALMAC_USB_MODE_U3 :
+			HALMAC_USB_MODE_U2;
+
+	/*check if HW supports usb2_usb3 swtich*/
+	usb_temp = HALMAC_REG_READ_32(halmac_adapter, REG_PAD_CTRL2);
+	if (!BIT_GET_USB23_SW_MODE_V1(usb_temp) &&
+	    !(usb_temp & BIT_USB3_USB2_TRANSITION)) {
+		pr_err("HALMAC_HW_USB_MODE usb mode HW unsupport\n");
+		return HALMAC_RET_USB2_3_SWITCH_UNSUPPORT;
+	}
+
+	if (usb_mode == current_usb_mode) {
+		pr_err("HALMAC_HW_USB_MODE usb mode unchange\n");
+		return HALMAC_RET_USB_MODE_UNCHANGE;
+	}
+
+	usb_temp &= ~(BIT_USB23_SW_MODE_V1(0x3));
+
+	if (usb_mode == HALMAC_USB_MODE_U2) {
+		/* usb3 to usb2 */
+		HALMAC_REG_WRITE_32(
+			halmac_adapter, REG_PAD_CTRL2,
+			usb_temp | BIT_USB23_SW_MODE_V1(HALMAC_USB_MODE_U2) |
+				BIT_RSM_EN_V1);
+	} else {
+		/* usb2 to usb3 */
+		HALMAC_REG_WRITE_32(
+			halmac_adapter, REG_PAD_CTRL2,
+			usb_temp | BIT_USB23_SW_MODE_V1(HALMAC_USB_MODE_U3) |
+				BIT_RSM_EN_V1);
+	}
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_PAD_CTRL2 + 1,
+			   4); /* set counter down timer 4x64 ms */
+	HALMAC_REG_WRITE_16(
+		halmac_adapter, REG_SYS_PW_CTRL,
+		HALMAC_REG_READ_16(halmac_adapter, REG_SYS_PW_CTRL) |
+			BIT_APFM_OFFMAC);
+	usleep_range(1000, 1100);
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_PAD_CTRL2,
+			    HALMAC_REG_READ_32(halmac_adapter, REG_PAD_CTRL2) |
+				    BIT_NO_PDN_CHIPOFF_V1);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+void halmac_enable_bb_rf_88xx(struct halmac_adapter *halmac_adapter, u8 enable)
+{
+	u8 value8;
+	u32 value32;
+	struct halmac_api *halmac_api;
+
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if (enable == 1) {
+		value8 = HALMAC_REG_READ_8(halmac_adapter, REG_SYS_FUNC_EN);
+		value8 = value8 | BIT(0) | BIT(1);
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_SYS_FUNC_EN, value8);
+
+		value8 = HALMAC_REG_READ_8(halmac_adapter, REG_RF_CTRL);
+		value8 = value8 | BIT(0) | BIT(1) | BIT(2);
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_RF_CTRL, value8);
+
+		value32 = HALMAC_REG_READ_32(halmac_adapter, REG_WLRF1);
+		value32 = value32 | BIT(24) | BIT(25) | BIT(26);
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_WLRF1, value32);
+	} else {
+		value8 = HALMAC_REG_READ_8(halmac_adapter, REG_SYS_FUNC_EN);
+		value8 = value8 & (~(BIT(0) | BIT(1)));
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_SYS_FUNC_EN, value8);
+
+		value8 = HALMAC_REG_READ_8(halmac_adapter, REG_RF_CTRL);
+		value8 = value8 & (~(BIT(0) | BIT(1) | BIT(2)));
+		HALMAC_REG_WRITE_8(halmac_adapter, REG_RF_CTRL, value8);
+
+		value32 = HALMAC_REG_READ_32(halmac_adapter, REG_WLRF1);
+		value32 = value32 & (~(BIT(24) | BIT(25) | BIT(26)));
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_WLRF1, value32);
+	}
+}
+
+void halmac_config_sdio_tx_page_threshold_88xx(
+	struct halmac_adapter *halmac_adapter,
+	struct halmac_tx_page_threshold_info *threshold_info)
+{
+	struct halmac_api *halmac_api;
+
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	switch (threshold_info->dma_queue_sel) {
+	case HALMAC_MAP2_HQ:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_TQPNT1,
+				    threshold_info->threshold);
+		break;
+	case HALMAC_MAP2_NQ:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_TQPNT2,
+				    threshold_info->threshold);
+		break;
+	case HALMAC_MAP2_LQ:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_TQPNT3,
+				    threshold_info->threshold);
+		break;
+	case HALMAC_MAP2_EXQ:
+		HALMAC_REG_WRITE_32(halmac_adapter, REG_TQPNT4,
+				    threshold_info->threshold);
+		break;
+	default:
+		break;
+	}
+}
+
+void halmac_config_ampdu_88xx(struct halmac_adapter *halmac_adapter,
+			      struct halmac_ampdu_config *ampdu_config)
+{
+	struct halmac_api *halmac_api;
+
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_PROT_MODE_CTRL + 2,
+			   ampdu_config->max_agg_num);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_PROT_MODE_CTRL + 3,
+			   ampdu_config->max_agg_num);
+};
+
+enum halmac_ret_status
+halmac_check_oqt_88xx(struct halmac_adapter *halmac_adapter, u32 tx_agg_num,
+		      u8 *halmac_buf)
+{
+	u32 counter = 10;
+
+	/*S0, S1 are not allowed to use, 0x4E4[0] should be 0. Soar 20160323*/
+	/*no need to check non_ac_oqt_number. HI and MGQ blocked will cause
+	 *protocal issue before H_OQT being full
+	 */
+	switch ((enum halmac_queue_select)GET_TX_DESC_QSEL(halmac_buf)) {
+	case HALMAC_QUEUE_SELECT_VO:
+	case HALMAC_QUEUE_SELECT_VO_V2:
+	case HALMAC_QUEUE_SELECT_VI:
+	case HALMAC_QUEUE_SELECT_VI_V2:
+	case HALMAC_QUEUE_SELECT_BE:
+	case HALMAC_QUEUE_SELECT_BE_V2:
+	case HALMAC_QUEUE_SELECT_BK:
+	case HALMAC_QUEUE_SELECT_BK_V2:
+		counter = 10;
+		do {
+			if (halmac_adapter->sdio_free_space.ac_empty > 0) {
+				halmac_adapter->sdio_free_space.ac_empty -= 1;
+				break;
+			}
+
+			if (halmac_adapter->sdio_free_space.ac_oqt_number >=
+			    tx_agg_num) {
+				halmac_adapter->sdio_free_space.ac_oqt_number -=
+					(u8)tx_agg_num;
+				break;
+			}
+
+			halmac_update_oqt_free_space_88xx(halmac_adapter);
+
+			counter--;
+			if (counter == 0)
+				return HALMAC_RET_OQT_NOT_ENOUGH;
+		} while (1);
+		break;
+	default:
+		break;
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_rqpn_parser_88xx(struct halmac_adapter *halmac_adapter,
+			enum halmac_trx_mode halmac_trx_mode,
+			struct halmac_rqpn_ *rqpn_table)
+{
+	u8 search_flag;
+	u32 i;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	search_flag = 0;
+	for (i = 0; i < HALMAC_TRX_MODE_MAX; i++) {
+		if (halmac_trx_mode == rqpn_table[i].mode) {
+			halmac_adapter
+				->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_VO] =
+				rqpn_table[i].dma_map_vo;
+			halmac_adapter
+				->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_VI] =
+				rqpn_table[i].dma_map_vi;
+			halmac_adapter
+				->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_BE] =
+				rqpn_table[i].dma_map_be;
+			halmac_adapter
+				->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_BK] =
+				rqpn_table[i].dma_map_bk;
+			halmac_adapter
+				->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_MG] =
+				rqpn_table[i].dma_map_mg;
+			halmac_adapter
+				->halmac_ptcl_queue[HALMAC_PTCL_QUEUE_HI] =
+				rqpn_table[i].dma_map_hi;
+			search_flag = 1;
+			HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT,
+					DBG_DMESG, "%s done\n", __func__);
+			break;
+		}
+	}
+
+	if (search_flag == 0) {
+		pr_err("HALMAC_RET_TRX_MODE_NOT_SUPPORT 1 switch case not support\n");
+		return HALMAC_RET_TRX_MODE_NOT_SUPPORT;
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_pg_num_parser_88xx(struct halmac_adapter *halmac_adapter,
+			  enum halmac_trx_mode halmac_trx_mode,
+			  struct halmac_pg_num_ *pg_num_table)
+{
+	u8 search_flag;
+	u16 HPQ_num = 0, lpq_nnum = 0, NPQ_num = 0, GAPQ_num = 0;
+	u16 EXPQ_num = 0, PUBQ_num = 0;
+	u32 i = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	search_flag = 0;
+	for (i = 0; i < HALMAC_TRX_MODE_MAX; i++) {
+		if (halmac_trx_mode == pg_num_table[i].mode) {
+			HPQ_num = pg_num_table[i].hq_num;
+			lpq_nnum = pg_num_table[i].lq_num;
+			NPQ_num = pg_num_table[i].nq_num;
+			EXPQ_num = pg_num_table[i].exq_num;
+			GAPQ_num = pg_num_table[i].gap_num;
+			PUBQ_num = halmac_adapter->txff_allocation.ac_q_pg_num -
+				   HPQ_num - lpq_nnum - NPQ_num - EXPQ_num -
+				   GAPQ_num;
+			search_flag = 1;
+			HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT,
+					DBG_DMESG, "%s done\n", __func__);
+			break;
+		}
+	}
+
+	if (search_flag == 0) {
+		pr_err("HALMAC_RET_TRX_MODE_NOT_SUPPORT 1 switch case not support\n");
+		return HALMAC_RET_TRX_MODE_NOT_SUPPORT;
+	}
+
+	if (halmac_adapter->txff_allocation.ac_q_pg_num <
+	    HPQ_num + lpq_nnum + NPQ_num + EXPQ_num + GAPQ_num)
+		return HALMAC_RET_CFG_TXFIFO_PAGE_FAIL;
+
+	halmac_adapter->txff_allocation.high_queue_pg_num = HPQ_num;
+	halmac_adapter->txff_allocation.low_queue_pg_num = lpq_nnum;
+	halmac_adapter->txff_allocation.normal_queue_pg_num = NPQ_num;
+	halmac_adapter->txff_allocation.extra_queue_pg_num = EXPQ_num;
+	halmac_adapter->txff_allocation.pub_queue_pg_num = PUBQ_num;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_parse_intf_phy_88xx(struct halmac_adapter *halmac_adapter,
+			   struct halmac_intf_phy_para_ *intf_phy_para,
+			   enum halmac_intf_phy_platform platform,
+			   enum hal_intf_phy intf_phy)
+{
+	u16 value;
+	u16 curr_cut;
+	u16 offset;
+	u16 ip_sel;
+	struct halmac_intf_phy_para_ *curr_phy_para;
+	struct halmac_api *halmac_api;
+	void *driver_adapter = NULL;
+	u8 result = HALMAC_RET_SUCCESS;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	switch (halmac_adapter->chip_version) {
+	case HALMAC_CHIP_VER_A_CUT:
+		curr_cut = (u16)HALMAC_INTF_PHY_CUT_A;
+		break;
+	case HALMAC_CHIP_VER_B_CUT:
+		curr_cut = (u16)HALMAC_INTF_PHY_CUT_B;
+		break;
+	case HALMAC_CHIP_VER_C_CUT:
+		curr_cut = (u16)HALMAC_INTF_PHY_CUT_C;
+		break;
+	case HALMAC_CHIP_VER_D_CUT:
+		curr_cut = (u16)HALMAC_INTF_PHY_CUT_D;
+		break;
+	case HALMAC_CHIP_VER_E_CUT:
+		curr_cut = (u16)HALMAC_INTF_PHY_CUT_E;
+		break;
+	case HALMAC_CHIP_VER_F_CUT:
+		curr_cut = (u16)HALMAC_INTF_PHY_CUT_F;
+		break;
+	case HALMAC_CHIP_VER_TEST:
+		curr_cut = (u16)HALMAC_INTF_PHY_CUT_TESTCHIP;
+		break;
+	default:
+		return HALMAC_RET_FAIL;
+	}
+
+	for (curr_phy_para = intf_phy_para;; curr_phy_para++) {
+		if (!(curr_phy_para->cut & curr_cut) ||
+		    !(curr_phy_para->plaform & (u16)platform))
+			continue;
+
+		offset = curr_phy_para->offset;
+		value = curr_phy_para->value;
+		ip_sel = curr_phy_para->ip_sel;
+
+		if (offset == 0xFFFF)
+			break;
+
+		if (ip_sel == HALMAC_IP_SEL_MAC) {
+			HALMAC_REG_WRITE_8(halmac_adapter, (u32)offset,
+					   (u8)value);
+		} else if (intf_phy == HAL_INTF_PHY_USB2) {
+			result = halmac_usbphy_write_88xx(halmac_adapter,
+							  (u8)offset, value,
+							  HAL_INTF_PHY_USB2);
+
+			if (result != HALMAC_RET_SUCCESS)
+				pr_err("[ERR]Write USB2PHY fail!\n");
+
+		} else if (intf_phy == HAL_INTF_PHY_USB3) {
+			result = halmac_usbphy_write_88xx(halmac_adapter,
+							  (u8)offset, value,
+							  HAL_INTF_PHY_USB3);
+
+			if (result != HALMAC_RET_SUCCESS)
+				pr_err("[ERR]Write USB3PHY fail!\n");
+
+		} else if (intf_phy == HAL_INTF_PHY_PCIE_GEN1) {
+			if (ip_sel == HALMAC_IP_SEL_INTF_PHY)
+				result = halmac_mdio_write_88xx(
+					halmac_adapter, (u8)offset, value,
+					HAL_INTF_PHY_PCIE_GEN1);
+			else
+				result = halmac_dbi_write8_88xx(
+					halmac_adapter, offset, (u8)value);
+
+			if (result != HALMAC_RET_SUCCESS)
+				pr_err("[ERR]MDIO write GEN1 fail!\n");
+
+		} else if (intf_phy == HAL_INTF_PHY_PCIE_GEN2) {
+			if (ip_sel == HALMAC_IP_SEL_INTF_PHY)
+				result = halmac_mdio_write_88xx(
+					halmac_adapter, (u8)offset, value,
+					HAL_INTF_PHY_PCIE_GEN2);
+			else
+				result = halmac_dbi_write8_88xx(
+					halmac_adapter, offset, (u8)value);
+
+			if (result != HALMAC_RET_SUCCESS)
+				pr_err("[ERR]MDIO write GEN2 fail!\n");
+		} else {
+			pr_err("[ERR]Parse intf phy cfg error!\n");
+		}
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+enum halmac_ret_status
+halmac_dbi_write32_88xx(struct halmac_adapter *halmac_adapter, u16 addr,
+			u32 data)
+{
+	u8 tmp_u1b = 0;
+	u32 count = 0;
+	u16 write_addr = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_REG_WRITE_32(halmac_adapter, REG_DBI_WDATA_V1, data);
+
+	write_addr = ((addr & 0x0ffc) | (0x000F << 12));
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_DBI_FLAG_V1, write_addr);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_DBI, DBG_DMESG,
+			"WriteAddr = %x\n", write_addr);
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_DBI_FLAG_V1 + 2, 0x01);
+	tmp_u1b = HALMAC_REG_READ_8(halmac_adapter, REG_DBI_FLAG_V1 + 2);
+
+	count = 20;
+	while (tmp_u1b && count != 0) {
+		udelay(10);
+		tmp_u1b =
+			HALMAC_REG_READ_8(halmac_adapter, REG_DBI_FLAG_V1 + 2);
+		count--;
+	}
+
+	if (tmp_u1b) {
+		pr_err("DBI write fail!\n");
+		return HALMAC_RET_FAIL;
+	} else {
+		return HALMAC_RET_SUCCESS;
+	}
+}
+
+u32 halmac_dbi_read32_88xx(struct halmac_adapter *halmac_adapter, u16 addr)
+{
+	u16 read_addr = addr & 0x0ffc;
+	u8 tmp_u1b = 0;
+	u32 count = 0;
+	u32 ret = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_DBI_FLAG_V1, read_addr);
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_DBI_FLAG_V1 + 2, 0x2);
+	tmp_u1b = HALMAC_REG_READ_8(halmac_adapter, REG_DBI_FLAG_V1 + 2);
+
+	count = 20;
+	while (tmp_u1b && count != 0) {
+		udelay(10);
+		tmp_u1b =
+			HALMAC_REG_READ_8(halmac_adapter, REG_DBI_FLAG_V1 + 2);
+		count--;
+	}
+
+	if (tmp_u1b) {
+		ret = 0xFFFF;
+		pr_err("DBI read fail!\n");
+	} else {
+		ret = HALMAC_REG_READ_32(halmac_adapter, REG_DBI_RDATA_V1);
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_DBI, DBG_DMESG,
+				"Read Value = %x\n", ret);
+	}
+
+	return ret;
+}
+
+enum halmac_ret_status
+halmac_dbi_write8_88xx(struct halmac_adapter *halmac_adapter, u16 addr, u8 data)
+{
+	u8 tmp_u1b = 0;
+	u32 count = 0;
+	u16 write_addr = 0;
+	u16 remainder = addr & (4 - 1);
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_DBI_WDATA_V1 + remainder, data);
+
+	write_addr = ((addr & 0x0ffc) | (BIT(0) << (remainder + 12)));
+
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_DBI_FLAG_V1, write_addr);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_DBI, DBG_DMESG,
+			"WriteAddr = %x\n", write_addr);
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_DBI_FLAG_V1 + 2, 0x01);
+
+	tmp_u1b = HALMAC_REG_READ_8(halmac_adapter, REG_DBI_FLAG_V1 + 2);
+
+	count = 20;
+	while (tmp_u1b && count != 0) {
+		udelay(10);
+		tmp_u1b =
+			HALMAC_REG_READ_8(halmac_adapter, REG_DBI_FLAG_V1 + 2);
+		count--;
+	}
+
+	if (tmp_u1b) {
+		pr_err("DBI write fail!\n");
+		return HALMAC_RET_FAIL;
+	} else {
+		return HALMAC_RET_SUCCESS;
+	}
+}
+
+u8 halmac_dbi_read8_88xx(struct halmac_adapter *halmac_adapter, u16 addr)
+{
+	u16 read_addr = addr & 0x0ffc;
+	u8 tmp_u1b = 0;
+	u32 count = 0;
+	u8 ret = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_DBI_FLAG_V1, read_addr);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_DBI_FLAG_V1 + 2, 0x2);
+
+	tmp_u1b = HALMAC_REG_READ_8(halmac_adapter, REG_DBI_FLAG_V1 + 2);
+
+	count = 20;
+	while (tmp_u1b && count != 0) {
+		udelay(10);
+		tmp_u1b =
+			HALMAC_REG_READ_8(halmac_adapter, REG_DBI_FLAG_V1 + 2);
+		count--;
+	}
+
+	if (tmp_u1b) {
+		ret = 0xFF;
+		pr_err("DBI read fail!\n");
+	} else {
+		ret = HALMAC_REG_READ_8(halmac_adapter,
+					REG_DBI_RDATA_V1 + (addr & (4 - 1)));
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_DBI, DBG_DMESG,
+				"Read Value = %x\n", ret);
+	}
+
+	return ret;
+}
+
+enum halmac_ret_status
+halmac_mdio_write_88xx(struct halmac_adapter *halmac_adapter, u8 addr, u16 data,
+		       u8 speed)
+{
+	u8 tmp_u1b = 0;
+	u32 count = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	u8 real_addr = 0;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_REG_WRITE_16(halmac_adapter, REG_MDIO_V1, data);
+
+	/* address : 5bit */
+	real_addr = (addr & 0x1F);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_PCIE_MIX_CFG, real_addr);
+
+	if (speed == HAL_INTF_PHY_PCIE_GEN1) {
+		/* GEN1 page 0 */
+		if (addr < 0x20) {
+			/* select MDIO PHY Addr : reg 0x3F8[28:24]=5'b00 */
+			HALMAC_REG_WRITE_8(halmac_adapter, REG_PCIE_MIX_CFG + 3,
+					   0x00);
+
+			/* GEN1 page 1 */
+		} else {
+			/* select MDIO PHY Addr : reg 0x3F8[28:24]=5'b01 */
+			HALMAC_REG_WRITE_8(halmac_adapter, REG_PCIE_MIX_CFG + 3,
+					   0x01);
+		}
+
+	} else if (speed == HAL_INTF_PHY_PCIE_GEN2) {
+		/* GEN2 page 0 */
+		if (addr < 0x20) {
+			/* select MDIO PHY Addr : reg 0x3F8[28:24]=5'b10 */
+			HALMAC_REG_WRITE_8(halmac_adapter, REG_PCIE_MIX_CFG + 3,
+					   0x02);
+
+			/* GEN2 page 1 */
+		} else {
+			/* select MDIO PHY Addr : reg 0x3F8[28:24]=5'b11 */
+			HALMAC_REG_WRITE_8(halmac_adapter, REG_PCIE_MIX_CFG + 3,
+					   0x03);
+		}
+	} else {
+		pr_err("Error Speed !\n");
+	}
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_PCIE_MIX_CFG,
+			   HALMAC_REG_READ_8(halmac_adapter, REG_PCIE_MIX_CFG) |
+				   BIT_MDIO_WFLAG_V1);
+
+	tmp_u1b = HALMAC_REG_READ_8(halmac_adapter, REG_PCIE_MIX_CFG) &
+		  BIT_MDIO_WFLAG_V1;
+	count = 20;
+
+	while (tmp_u1b && count != 0) {
+		udelay(10);
+		tmp_u1b = HALMAC_REG_READ_8(halmac_adapter, REG_PCIE_MIX_CFG) &
+			  BIT_MDIO_WFLAG_V1;
+		count--;
+	}
+
+	if (tmp_u1b) {
+		pr_err("MDIO write fail!\n");
+		return HALMAC_RET_FAIL;
+	} else {
+		return HALMAC_RET_SUCCESS;
+	}
+}
+
+u16 halmac_mdio_read_88xx(struct halmac_adapter *halmac_adapter, u8 addr,
+			  u8 speed
+
+			  )
+{
+	u16 ret = 0;
+	u8 tmp_u1b = 0;
+	u32 count = 0;
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	u8 real_addr = 0;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	/* address : 5bit */
+	real_addr = (addr & 0x1F);
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_PCIE_MIX_CFG, real_addr);
+
+	if (speed == HAL_INTF_PHY_PCIE_GEN1) {
+		/* GEN1 page 0 */
+		if (addr < 0x20) {
+			/* select MDIO PHY Addr : reg 0x3F8[28:24]=5'b00 */
+			HALMAC_REG_WRITE_8(halmac_adapter, REG_PCIE_MIX_CFG + 3,
+					   0x00);
+
+			/* GEN1 page 1 */
+		} else {
+			/* select MDIO PHY Addr : reg 0x3F8[28:24]=5'b01 */
+			HALMAC_REG_WRITE_8(halmac_adapter, REG_PCIE_MIX_CFG + 3,
+					   0x01);
+		}
+
+	} else if (speed == HAL_INTF_PHY_PCIE_GEN2) {
+		/* GEN2 page 0 */
+		if (addr < 0x20) {
+			/* select MDIO PHY Addr : reg 0x3F8[28:24]=5'b10 */
+			HALMAC_REG_WRITE_8(halmac_adapter, REG_PCIE_MIX_CFG + 3,
+					   0x02);
+
+			/* GEN2 page 1 */
+		} else {
+			/* select MDIO PHY Addr : reg 0x3F8[28:24]=5'b11 */
+			HALMAC_REG_WRITE_8(halmac_adapter, REG_PCIE_MIX_CFG + 3,
+					   0x03);
+		}
+	} else {
+		pr_err("Error Speed !\n");
+	}
+
+	HALMAC_REG_WRITE_8(halmac_adapter, REG_PCIE_MIX_CFG,
+			   HALMAC_REG_READ_8(halmac_adapter, REG_PCIE_MIX_CFG) |
+				   BIT_MDIO_RFLAG_V1);
+
+	tmp_u1b = HALMAC_REG_READ_8(halmac_adapter, REG_PCIE_MIX_CFG) &
+		  BIT_MDIO_RFLAG_V1;
+	count = 20;
+
+	while (tmp_u1b && count != 0) {
+		udelay(10);
+		tmp_u1b = HALMAC_REG_READ_8(halmac_adapter, REG_PCIE_MIX_CFG) &
+			  BIT_MDIO_RFLAG_V1;
+		count--;
+	}
+
+	if (tmp_u1b) {
+		ret = 0xFFFF;
+		pr_err("MDIO read fail!\n");
+
+	} else {
+		ret = HALMAC_REG_READ_16(halmac_adapter, REG_MDIO_V1 + 2);
+		HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_MDIO, DBG_DMESG,
+				"Read Value = %x\n", ret);
+	}
+
+	return ret;
+}
+
+enum halmac_ret_status
+halmac_usbphy_write_88xx(struct halmac_adapter *halmac_adapter, u8 addr,
+			 u16 data, u8 speed)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if (speed == HAL_INTF_PHY_USB3) {
+		HALMAC_REG_WRITE_8(halmac_adapter, 0xff0d, (u8)data);
+		HALMAC_REG_WRITE_8(halmac_adapter, 0xff0e, (u8)(data >> 8));
+		HALMAC_REG_WRITE_8(halmac_adapter, 0xff0c, addr | BIT(7));
+	} else if (speed == HAL_INTF_PHY_USB2) {
+		HALMAC_REG_WRITE_8(halmac_adapter, 0xfe41, (u8)data);
+		HALMAC_REG_WRITE_8(halmac_adapter, 0xfe40, addr);
+		HALMAC_REG_WRITE_8(halmac_adapter, 0xfe42, 0x81);
+	} else {
+		pr_err("[ERR]Error USB Speed !\n");
+		return HALMAC_RET_NOT_SUPPORT;
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+u16 halmac_usbphy_read_88xx(struct halmac_adapter *halmac_adapter, u8 addr,
+			    u8 speed)
+{
+	void *driver_adapter = NULL;
+	struct halmac_api *halmac_api;
+	u16 value = 0;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	if (speed == HAL_INTF_PHY_USB3) {
+		HALMAC_REG_WRITE_8(halmac_adapter, 0xff0c, addr | BIT(6));
+		value = (u16)(HALMAC_REG_READ_32(halmac_adapter, 0xff0c) >> 8);
+	} else if (speed == HAL_INTF_PHY_USB2) {
+		if ((addr >= 0xE0) /*&& (addr <= 0xFF)*/)
+			addr -= 0x20;
+		if ((addr >= 0xC0) && (addr <= 0xDF)) {
+			HALMAC_REG_WRITE_8(halmac_adapter, 0xfe40, addr);
+			HALMAC_REG_WRITE_8(halmac_adapter, 0xfe42, 0x81);
+			value = HALMAC_REG_READ_8(halmac_adapter, 0xfe43);
+		} else {
+			pr_err("[ERR]Error USB2PHY offset!\n");
+			return HALMAC_RET_NOT_SUPPORT;
+		}
+	} else {
+		pr_err("[ERR]Error USB Speed !\n");
+		return HALMAC_RET_NOT_SUPPORT;
+	}
+
+	return value;
+}
diff --git a/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_func_88xx.h b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_func_88xx.h
new file mode 100644
index 000000000000..1b59301d1158
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_88xx/halmac_func_88xx.h
@@ -0,0 +1,321 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_FUNC_88XX_H_
+#define _HALMAC_FUNC_88XX_H_
+
+#include "../halmac_type.h"
+
+void halmac_init_offload_feature_state_machine_88xx(
+	struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_send_h2c_pkt_88xx(struct halmac_adapter *halmac_adapter, u8 *hal_buff,
+			 u32 size, bool ack);
+
+enum halmac_ret_status
+halmac_download_rsvd_page_88xx(struct halmac_adapter *halmac_adapter,
+			       u8 *hal_buf, u32 size);
+
+enum halmac_ret_status
+halmac_set_h2c_header_88xx(struct halmac_adapter *halmac_adapter,
+			   u8 *hal_h2c_hdr, u16 *seq, bool ack);
+
+enum halmac_ret_status halmac_set_fw_offload_h2c_header_88xx(
+	struct halmac_adapter *halmac_adapter, u8 *hal_h2c_hdr,
+	struct halmac_h2c_header_info *h2c_header_info, u16 *seq_num);
+
+enum halmac_ret_status
+halmac_dump_efuse_88xx(struct halmac_adapter *halmac_adapter,
+		       enum halmac_efuse_read_cfg cfg);
+
+enum halmac_ret_status
+halmac_func_read_efuse_88xx(struct halmac_adapter *halmac_adapter, u32 offset,
+			    u32 size, u8 *efuse_map);
+
+enum halmac_ret_status
+halmac_func_write_efuse_88xx(struct halmac_adapter *halmac_adapter, u32 offset,
+			     u8 value);
+
+enum halmac_ret_status
+halmac_func_switch_efuse_bank_88xx(struct halmac_adapter *halmac_adapter,
+				   enum halmac_efuse_bank efuse_bank);
+
+enum halmac_ret_status
+halmac_read_logical_efuse_map_88xx(struct halmac_adapter *halmac_adapter,
+				   u8 *map);
+
+enum halmac_ret_status
+halmac_func_write_logical_efuse_88xx(struct halmac_adapter *halmac_adapter,
+				     u32 offset, u8 value);
+
+enum halmac_ret_status
+halmac_func_pg_efuse_by_map_88xx(struct halmac_adapter *halmac_adapter,
+				 struct halmac_pg_efuse_info *pg_efuse_info,
+				 enum halmac_efuse_read_cfg cfg);
+
+enum halmac_ret_status
+halmac_eeprom_parser_88xx(struct halmac_adapter *halmac_adapter,
+			  u8 *physical_efuse_map, u8 *logical_efuse_map);
+
+enum halmac_ret_status
+halmac_read_hw_efuse_88xx(struct halmac_adapter *halmac_adapter, u32 offset,
+			  u32 size, u8 *efuse_map);
+
+enum halmac_ret_status
+halmac_dlfw_to_mem_88xx(struct halmac_adapter *halmac_adapter, u8 *ram_code,
+			u32 dest, u32 code_size);
+
+enum halmac_ret_status
+halmac_send_fwpkt_88xx(struct halmac_adapter *halmac_adapter, u8 *ram_code,
+		       u32 code_size);
+
+enum halmac_ret_status
+halmac_iddma_dlfw_88xx(struct halmac_adapter *halmac_adapter, u32 source,
+		       u32 dest, u32 length, u8 first);
+
+enum halmac_ret_status
+halmac_check_fw_chksum_88xx(struct halmac_adapter *halmac_adapter,
+			    u32 memory_address);
+
+enum halmac_ret_status
+halmac_dlfw_end_flow_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_free_dl_fw_end_flow_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_pwr_seq_parser_88xx(struct halmac_adapter *halmac_adapter, u8 cut,
+			   u8 fab, u8 intf,
+			   struct halmac_wl_pwr_cfg_ **pp_pwr_seq_cfg
+
+			   );
+
+enum halmac_ret_status
+halmac_get_h2c_buff_free_space_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_send_h2c_set_pwr_mode_88xx(struct halmac_adapter *halmac_adapter,
+				  struct halmac_fwlps_option *hal_fw_lps_opt);
+
+enum halmac_ret_status
+halmac_func_send_original_h2c_88xx(struct halmac_adapter *halmac_adapter,
+				   u8 *original_h2c, u16 *seq, u8 ack);
+
+enum halmac_ret_status
+halmac_media_status_rpt_88xx(struct halmac_adapter *halmac_adapter, u8 op_mode,
+			     u8 mac_id_ind, u8 mac_id, u8 mac_id_end);
+
+enum halmac_ret_status halmac_send_h2c_update_datapack_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_data_type halmac_data_type,
+	struct halmac_phy_parameter_info *para_info);
+
+enum halmac_ret_status
+halmac_send_h2c_run_datapack_88xx(struct halmac_adapter *halmac_adapter,
+				  enum halmac_data_type halmac_data_type);
+
+enum halmac_ret_status
+halmac_send_bt_coex_cmd_88xx(struct halmac_adapter *halmac_adapter, u8 *bt_buf,
+			     u32 bt_size, u8 ack);
+
+enum halmac_ret_status
+halmac_func_ctrl_ch_switch_88xx(struct halmac_adapter *halmac_adapter,
+				struct halmac_ch_switch_option *cs_option);
+
+enum halmac_ret_status
+halmac_func_send_general_info_88xx(struct halmac_adapter *halmac_adapter,
+				   struct halmac_general_info *general_info);
+
+enum halmac_ret_status
+halmac_send_h2c_ps_tuning_para_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_parse_c2h_packet_88xx(struct halmac_adapter *halmac_adapter,
+			     u8 *halmac_buf, u32 halmac_size);
+
+enum halmac_ret_status
+halmac_send_h2c_update_packet_88xx(struct halmac_adapter *halmac_adapter,
+				   enum halmac_packet_id pkt_id, u8 *pkt,
+				   u32 pkt_size);
+
+enum halmac_ret_status
+halmac_send_h2c_phy_parameter_88xx(struct halmac_adapter *halmac_adapter,
+				   struct halmac_phy_parameter_info *para_info,
+				   bool full_fifo);
+
+enum halmac_ret_status
+halmac_dump_physical_efuse_fw_88xx(struct halmac_adapter *halmac_adapter,
+				   u32 offset, u32 size, u8 *efuse_map);
+
+enum halmac_ret_status halmac_send_h2c_update_bcn_parse_info_88xx(
+	struct halmac_adapter *halmac_adapter,
+	struct halmac_bcn_ie_info *bcn_ie_info);
+
+enum halmac_ret_status
+halmac_convert_to_sdio_bus_offset_88xx(struct halmac_adapter *halmac_adapter,
+				       u32 *halmac_offset);
+
+enum halmac_ret_status
+halmac_update_sdio_free_page_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_update_oqt_free_space_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_efuse_cmd_construct_state
+halmac_query_efuse_curr_state_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status halmac_transition_efuse_state_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_efuse_cmd_construct_state dest_state);
+
+enum halmac_cfg_para_cmd_construct_state
+halmac_query_cfg_para_curr_state_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status halmac_transition_cfg_para_state_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_cfg_para_cmd_construct_state dest_state);
+
+enum halmac_scan_cmd_construct_state
+halmac_query_scan_curr_state_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status halmac_transition_scan_state_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_scan_cmd_construct_state dest_state);
+
+enum halmac_ret_status halmac_query_cfg_para_status_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_cmd_process_status *process_status, u8 *data, u32 *size);
+
+enum halmac_ret_status halmac_query_dump_physical_efuse_status_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_cmd_process_status *process_status, u8 *data, u32 *size);
+
+enum halmac_ret_status halmac_query_dump_logical_efuse_status_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_cmd_process_status *process_status, u8 *data, u32 *size);
+
+enum halmac_ret_status halmac_query_channel_switch_status_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_cmd_process_status *process_status, u8 *data, u32 *size);
+
+enum halmac_ret_status halmac_query_update_packet_status_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_cmd_process_status *process_status, u8 *data, u32 *size);
+
+enum halmac_ret_status
+halmac_query_iqk_status_88xx(struct halmac_adapter *halmac_adapter,
+			     enum halmac_cmd_process_status *process_status,
+			     u8 *data, u32 *size);
+
+enum halmac_ret_status halmac_query_power_tracking_status_88xx(
+	struct halmac_adapter *halmac_adapter,
+	enum halmac_cmd_process_status *process_status, u8 *data, u32 *size);
+
+enum halmac_ret_status
+halmac_query_psd_status_88xx(struct halmac_adapter *halmac_adapter,
+			     enum halmac_cmd_process_status *process_status,
+			     u8 *data, u32 *size);
+
+enum halmac_ret_status
+halmac_verify_io_88xx(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status
+halmac_verify_send_rsvd_page_88xx(struct halmac_adapter *halmac_adapter);
+
+void halmac_power_save_cb_88xx(void *cb_data);
+
+enum halmac_ret_status
+halmac_buffer_read_88xx(struct halmac_adapter *halmac_adapter, u32 offset,
+			u32 size, enum hal_fifo_sel halmac_fifo_sel,
+			u8 *fifo_map);
+
+void halmac_restore_mac_register_88xx(struct halmac_adapter *halmac_adapter,
+				      struct halmac_restore_info *restore_info,
+				      u32 restore_num);
+
+void halmac_api_record_id_88xx(struct halmac_adapter *halmac_adapter,
+			       enum halmac_api_id api_id);
+
+enum halmac_ret_status
+halmac_set_usb_mode_88xx(struct halmac_adapter *halmac_adapter,
+			 enum halmac_usb_mode usb_mode);
+
+void halmac_enable_bb_rf_88xx(struct halmac_adapter *halmac_adapter, u8 enable);
+
+void halmac_config_sdio_tx_page_threshold_88xx(
+	struct halmac_adapter *halmac_adapter,
+	struct halmac_tx_page_threshold_info *threshold_info);
+
+enum halmac_ret_status
+halmac_rqpn_parser_88xx(struct halmac_adapter *halmac_adapter,
+			enum halmac_trx_mode halmac_trx_mode,
+			struct halmac_rqpn_ *pwr_seq_cfg);
+
+enum halmac_ret_status
+halmac_check_oqt_88xx(struct halmac_adapter *halmac_adapter, u32 tx_agg_num,
+		      u8 *halmac_buf);
+
+enum halmac_ret_status
+halmac_pg_num_parser_88xx(struct halmac_adapter *halmac_adapter,
+			  enum halmac_trx_mode halmac_trx_mode,
+			  struct halmac_pg_num_ *pg_num_table);
+
+enum halmac_ret_status
+halmac_parse_intf_phy_88xx(struct halmac_adapter *halmac_adapter,
+			   struct halmac_intf_phy_para_ *intf_phy_para,
+			   enum halmac_intf_phy_platform platform,
+			   enum hal_intf_phy intf_phy);
+
+enum halmac_ret_status
+halmac_dbi_write32_88xx(struct halmac_adapter *halmac_adapter, u16 addr,
+			u32 data);
+
+u32 halmac_dbi_read32_88xx(struct halmac_adapter *halmac_adapter, u16 addr);
+
+enum halmac_ret_status
+halmac_dbi_write8_88xx(struct halmac_adapter *halmac_adapter, u16 addr,
+		       u8 data);
+
+u8 halmac_dbi_read8_88xx(struct halmac_adapter *halmac_adapter, u16 addr);
+
+u16 halmac_mdio_read_88xx(struct halmac_adapter *halmac_adapter, u8 addr,
+			  u8 speed
+
+			  );
+
+enum halmac_ret_status
+halmac_mdio_write_88xx(struct halmac_adapter *halmac_adapter, u8 addr, u16 data,
+		       u8 speed);
+
+void halmac_config_ampdu_88xx(struct halmac_adapter *halmac_adapter,
+			      struct halmac_ampdu_config *ampdu_config);
+
+enum halmac_ret_status
+halmac_usbphy_write_88xx(struct halmac_adapter *halmac_adapter, u8 addr,
+			 u16 data, u8 speed);
+
+u16 halmac_usbphy_read_88xx(struct halmac_adapter *halmac_adapter, u8 addr,
+			    u8 speed);
+#endif /* _HALMAC_FUNC_88XX_H_ */
diff --git a/drivers/staging/rtlwifi/halmac/halmac_api.c b/drivers/staging/rtlwifi/halmac/halmac_api.c
new file mode 100644
index 000000000000..0886a4611da0
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_api.c
@@ -0,0 +1,426 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#include "halmac_2_platform.h"
+#include "halmac_type.h"
+#include "halmac_88xx/halmac_api_88xx.h"
+#include "halmac_88xx/halmac_88xx_cfg.h"
+
+#include "halmac_88xx/halmac_8822b/halmac_8822b_cfg.h"
+
+static enum halmac_ret_status
+halmac_check_platform_api(void *driver_adapter,
+			  enum halmac_interface halmac_interface,
+			  struct halmac_platform_api *halmac_platform_api)
+{
+	void *adapter_local = NULL;
+
+	adapter_local = driver_adapter;
+
+	if (!halmac_platform_api)
+		return HALMAC_RET_PLATFORM_API_NULL;
+
+	if (halmac_interface == HALMAC_INTERFACE_SDIO) {
+		if (!halmac_platform_api->SDIO_CMD52_READ) {
+			pr_err("(!halmac_platform_api->SDIO_CMD52_READ)\n");
+			return HALMAC_RET_PLATFORM_API_NULL;
+		}
+		if (!halmac_platform_api->SDIO_CMD53_READ_8) {
+			pr_err("(!halmac_platform_api->SDIO_CMD53_READ_8)\n");
+			return HALMAC_RET_PLATFORM_API_NULL;
+		}
+		if (!halmac_platform_api->SDIO_CMD53_READ_16) {
+			pr_err("(!halmac_platform_api->SDIO_CMD53_READ_16)\n");
+			return HALMAC_RET_PLATFORM_API_NULL;
+		}
+		if (!halmac_platform_api->SDIO_CMD53_READ_32) {
+			pr_err("(!halmac_platform_api->SDIO_CMD53_READ_32)\n");
+			return HALMAC_RET_PLATFORM_API_NULL;
+		}
+		if (!halmac_platform_api->SDIO_CMD53_READ_N) {
+			pr_err("(!halmac_platform_api->SDIO_CMD53_READ_N)\n");
+			return HALMAC_RET_PLATFORM_API_NULL;
+		}
+		if (!halmac_platform_api->SDIO_CMD52_WRITE) {
+			pr_err("(!halmac_platform_api->SDIO_CMD52_WRITE)\n");
+			return HALMAC_RET_PLATFORM_API_NULL;
+		}
+		if (!halmac_platform_api->SDIO_CMD53_WRITE_8) {
+			pr_err("(!halmac_platform_api->SDIO_CMD53_WRITE_8)\n");
+			return HALMAC_RET_PLATFORM_API_NULL;
+		}
+		if (!halmac_platform_api->SDIO_CMD53_WRITE_16) {
+			pr_err("(!halmac_platform_api->SDIO_CMD53_WRITE_16)\n");
+			return HALMAC_RET_PLATFORM_API_NULL;
+		}
+		if (!halmac_platform_api->SDIO_CMD53_WRITE_32) {
+			pr_err("(!halmac_platform_api->SDIO_CMD53_WRITE_32)\n");
+			return HALMAC_RET_PLATFORM_API_NULL;
+		}
+	}
+
+	if (halmac_interface == HALMAC_INTERFACE_USB ||
+	    halmac_interface == HALMAC_INTERFACE_PCIE) {
+		if (!halmac_platform_api->REG_READ_8) {
+			pr_err("(!halmac_platform_api->REG_READ_8)\n");
+			return HALMAC_RET_PLATFORM_API_NULL;
+		}
+		if (!halmac_platform_api->REG_READ_16) {
+			pr_err("(!halmac_platform_api->REG_READ_16)\n");
+			return HALMAC_RET_PLATFORM_API_NULL;
+		}
+		if (!halmac_platform_api->REG_READ_32) {
+			pr_err("(!halmac_platform_api->REG_READ_32)\n");
+			return HALMAC_RET_PLATFORM_API_NULL;
+		}
+		if (!halmac_platform_api->REG_WRITE_8) {
+			pr_err("(!halmac_platform_api->REG_WRITE_8)\n");
+			return HALMAC_RET_PLATFORM_API_NULL;
+		}
+		if (!halmac_platform_api->REG_WRITE_16) {
+			pr_err("(!halmac_platform_api->REG_WRITE_16)\n");
+			return HALMAC_RET_PLATFORM_API_NULL;
+		}
+		if (!halmac_platform_api->REG_WRITE_32) {
+			pr_err("(!halmac_platform_api->REG_WRITE_32)\n");
+			return HALMAC_RET_PLATFORM_API_NULL;
+		}
+	}
+
+	if (!halmac_platform_api->EVENT_INDICATION) {
+		pr_err("(!halmac_platform_api->EVENT_INDICATION)\n");
+		return HALMAC_RET_PLATFORM_API_NULL;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_convert_to_sdio_bus_offset(u32 *halmac_offset)
+{
+	switch ((*halmac_offset) & 0xFFFF0000) {
+	case WLAN_IOREG_OFFSET:
+		*halmac_offset = (HALMAC_SDIO_CMD_ADDR_MAC_REG << 13) |
+				 (*halmac_offset & HALMAC_WLAN_MAC_REG_MSK);
+		break;
+	case SDIO_LOCAL_OFFSET:
+		*halmac_offset = (HALMAC_SDIO_CMD_ADDR_SDIO_REG << 13) |
+				 (*halmac_offset & HALMAC_SDIO_LOCAL_MSK);
+		break;
+	default:
+		*halmac_offset = 0xFFFFFFFF;
+		return HALMAC_RET_CONVERT_SDIO_OFFSET_FAIL;
+	}
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static u8
+platform_reg_read_8_sdio(void *driver_adapter,
+			 struct halmac_platform_api *halmac_platform_api,
+			 u32 offset)
+{
+	u8 value8;
+	u32 halmac_offset = offset;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	if ((halmac_offset & 0xFFFF0000) == 0)
+		halmac_offset |= WLAN_IOREG_OFFSET;
+
+	status = halmac_convert_to_sdio_bus_offset(&halmac_offset);
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("%s error = %x\n", __func__, status);
+		return status;
+	}
+
+	value8 = halmac_platform_api->SDIO_CMD52_READ(driver_adapter,
+						      halmac_offset);
+
+	return value8;
+}
+
+static enum halmac_ret_status
+platform_reg_write_8_sdio(void *driver_adapter,
+			  struct halmac_platform_api *halmac_platform_api,
+			  u32 offset, u8 data)
+{
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+	u32 halmac_offset = offset;
+
+	if ((halmac_offset & 0xFFFF0000) == 0)
+		halmac_offset |= WLAN_IOREG_OFFSET;
+
+	status = halmac_convert_to_sdio_bus_offset(&halmac_offset);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		pr_err("halmac_reg_write_8_sdio_88xx error = %x\n", status);
+		return status;
+	}
+	halmac_platform_api->SDIO_CMD52_WRITE(driver_adapter, halmac_offset,
+					      data);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static enum halmac_ret_status
+halmac_get_chip_info(void *driver_adapter,
+		     struct halmac_platform_api *halmac_platform_api,
+		     enum halmac_interface halmac_interface,
+		     struct halmac_adapter *halmac_adapter)
+{
+	struct halmac_api *halmac_api = (struct halmac_api *)NULL;
+	u8 chip_id, chip_version;
+	u32 polling_count;
+
+	halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	/* Get Chip_id and Chip_version */
+	if (halmac_adapter->halmac_interface == HALMAC_INTERFACE_SDIO) {
+		platform_reg_write_8_sdio(
+			driver_adapter, halmac_platform_api, REG_SDIO_HSUS_CTRL,
+			platform_reg_read_8_sdio(driver_adapter,
+						 halmac_platform_api,
+						 REG_SDIO_HSUS_CTRL) &
+				~(BIT(0)));
+
+		polling_count = 10000;
+		while (!(platform_reg_read_8_sdio(driver_adapter,
+						  halmac_platform_api,
+						  REG_SDIO_HSUS_CTRL) &
+			 0x02)) {
+			polling_count--;
+			if (polling_count == 0)
+				return HALMAC_RET_SDIO_LEAVE_SUSPEND_FAIL;
+		}
+
+		chip_id = platform_reg_read_8_sdio(
+			driver_adapter, halmac_platform_api, REG_SYS_CFG2);
+		chip_version = platform_reg_read_8_sdio(driver_adapter,
+							halmac_platform_api,
+							REG_SYS_CFG1 + 1) >>
+			       4;
+	} else {
+		chip_id = halmac_platform_api->REG_READ_8(driver_adapter,
+							  REG_SYS_CFG2);
+		chip_version = halmac_platform_api->REG_READ_8(
+				       driver_adapter, REG_SYS_CFG1 + 1) >>
+			       4;
+	}
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"[TRACE]Chip id : 0x%X\n", chip_id);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"[TRACE]Chip version : 0x%X\n", chip_version);
+
+	halmac_adapter->chip_version = (enum halmac_chip_ver)chip_version;
+
+	if (chip_id == HALMAC_CHIP_ID_HW_DEF_8822B)
+		halmac_adapter->chip_id = HALMAC_CHIP_ID_8822B;
+	else if (chip_id == HALMAC_CHIP_ID_HW_DEF_8821C)
+		halmac_adapter->chip_id = HALMAC_CHIP_ID_8821C;
+	else if (chip_id == HALMAC_CHIP_ID_HW_DEF_8814B)
+		halmac_adapter->chip_id = HALMAC_CHIP_ID_8814B;
+	else if (chip_id == HALMAC_CHIP_ID_HW_DEF_8197F)
+		halmac_adapter->chip_id = HALMAC_CHIP_ID_8197F;
+	else
+		halmac_adapter->chip_id = HALMAC_CHIP_ID_UNDEFINE;
+
+	if (halmac_adapter->chip_id == HALMAC_CHIP_ID_UNDEFINE)
+		return HALMAC_RET_CHIP_NOT_SUPPORT;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_init_adapter() - init halmac_adapter
+ * @driver_adapter : the adapter of caller
+ * @halmac_platform_api : the platform APIs which is used in halmac APIs
+ * @halmac_interface : bus interface
+ * @pp_halmac_adapter : the adapter of halmac
+ * @pp_halmac_api : the function pointer of APIs, caller shall call APIs by
+ *                 function pointer
+ * Author : KaiYuan Chang / Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_init_adapter(void *driver_adapter,
+		    struct halmac_platform_api *halmac_platform_api,
+		    enum halmac_interface halmac_interface,
+		    struct halmac_adapter **pp_halmac_adapter,
+		    struct halmac_api **pp_halmac_api)
+{
+	struct halmac_adapter *halmac_adapter = (struct halmac_adapter *)NULL;
+	enum halmac_ret_status status = HALMAC_RET_SUCCESS;
+
+	union {
+		u32 i;
+		u8 x[4];
+	} ENDIAN_CHECK = {0x01000000};
+
+	status = halmac_check_platform_api(driver_adapter, halmac_interface,
+					   halmac_platform_api);
+	if (status != HALMAC_RET_SUCCESS)
+		return status;
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			HALMAC_SVN_VER "\n");
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"HALMAC_MAJOR_VER = %x\n", HALMAC_MAJOR_VER);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"HALMAC_PROTOTYPE_VER = %x\n", HALMAC_PROTOTYPE_VER);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"HALMAC_MINOR_VER = %x\n", HALMAC_MINOR_VER);
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"HALMAC_PATCH_VER = %x\n", HALMAC_PATCH_VER);
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"halmac_init_adapter_88xx ==========>\n");
+
+	/* Check endian setting - Little endian : 1, Big endian : 0*/
+	if (ENDIAN_CHECK.x[0] == HALMAC_SYSTEM_ENDIAN) {
+		pr_err("Endian setting Err!!\n");
+		return HALMAC_RET_ENDIAN_ERR;
+	}
+
+	halmac_adapter = kzalloc(sizeof(*halmac_adapter), GFP_KERNEL);
+	if (!halmac_adapter) {
+		/* out of memory */
+		return HALMAC_RET_MALLOC_FAIL;
+	}
+
+	/* return halmac adapter address to caller */
+	*pp_halmac_adapter = halmac_adapter;
+
+	/* Record caller info */
+	halmac_adapter->halmac_platform_api = halmac_platform_api;
+	halmac_adapter->driver_adapter = driver_adapter;
+	halmac_interface = halmac_interface == HALMAC_INTERFACE_AXI ?
+				   HALMAC_INTERFACE_PCIE :
+				   halmac_interface;
+	halmac_adapter->halmac_interface = halmac_interface;
+
+	spin_lock_init(&halmac_adapter->efuse_lock);
+	spin_lock_init(&halmac_adapter->h2c_seq_lock);
+
+	/*Get Chip*/
+	if (halmac_get_chip_info(driver_adapter, halmac_platform_api,
+				 halmac_interface,
+				 halmac_adapter) != HALMAC_RET_SUCCESS) {
+		pr_err("HALMAC_RET_CHIP_NOT_SUPPORT\n");
+		return HALMAC_RET_CHIP_NOT_SUPPORT;
+	}
+
+	/* Assign function pointer to halmac API */
+	halmac_init_adapter_para_88xx(halmac_adapter);
+	status = halmac_mount_api_88xx(halmac_adapter);
+
+	/* Return halmac API function pointer */
+	*pp_halmac_api = (struct halmac_api *)halmac_adapter->halmac_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"halmac_init_adapter_88xx <==========\n");
+
+	return status;
+}
+
+/**
+ * halmac_halt_api() - stop halmac_api action
+ * @halmac_adapter : the adapter of halmac
+ * Author : Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status halmac_halt_api(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+	struct halmac_platform_api *halmac_platform_api =
+		(struct halmac_platform_api *)NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+	halmac_platform_api = halmac_adapter->halmac_platform_api;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+	halmac_adapter->halmac_state.api_state = HALMAC_API_STATE_HALT;
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"%s ==========>\n", __func__);
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_deinit_adapter() - deinit halmac adapter
+ * @halmac_adapter : the adapter of halmac
+ * Author : KaiYuan Chang / Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status
+halmac_deinit_adapter(struct halmac_adapter *halmac_adapter)
+{
+	void *driver_adapter = NULL;
+
+	if (halmac_adapter_validate(halmac_adapter) != HALMAC_RET_SUCCESS)
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	driver_adapter = halmac_adapter->driver_adapter;
+
+	HALMAC_RT_TRACE(driver_adapter, HALMAC_MSG_INIT, DBG_DMESG,
+			"[TRACE]halmac_deinit_adapter_88xx ==========>\n");
+
+	kfree(halmac_adapter->hal_efuse_map);
+	halmac_adapter->hal_efuse_map = (u8 *)NULL;
+
+	kfree(halmac_adapter->halmac_state.psd_set.data);
+	halmac_adapter->halmac_state.psd_set.data = (u8 *)NULL;
+
+	kfree(halmac_adapter->halmac_api);
+	halmac_adapter->halmac_api = NULL;
+
+	halmac_adapter->hal_adapter_backup = NULL;
+	kfree(halmac_adapter);
+
+	return HALMAC_RET_SUCCESS;
+}
+
+/**
+ * halmac_get_version() - get HALMAC version
+ * @version : return version of major, prototype and minor information
+ * Author : KaiYuan Chang / Ivan Lin
+ * Return : enum halmac_ret_status
+ * More details of status code can be found in prototype document
+ */
+enum halmac_ret_status halmac_get_version(struct halmac_ver *version)
+{
+	version->major_ver = (u8)HALMAC_MAJOR_VER;
+	version->prototype_ver = (u8)HALMAC_PROTOTYPE_VER;
+	version->minor_ver = (u8)HALMAC_MINOR_VER;
+
+	return HALMAC_RET_SUCCESS;
+}
diff --git a/drivers/staging/rtlwifi/halmac/halmac_api.h b/drivers/staging/rtlwifi/halmac/halmac_api.h
new file mode 100644
index 000000000000..917a64601053
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_api.h
@@ -0,0 +1,82 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_API_H_
+#define _HALMAC_API_H_
+
+#define HALMAC_SVN_VER "13348M"
+
+#define HALMAC_MAJOR_VER 0x0001 /* major version, ver_1 for async_api */
+/* For halmac_api num change or prototype change, increment prototype version.
+ * Otherwise, increase minor version
+ */
+#define HALMAC_PROTOTYPE_VER 0x0003 /* prototype version */
+#define HALMAC_MINOR_VER 0x0005 /* minor version */
+#define HALMAC_PATCH_VER 0x0000 /* patch version */
+
+#include "halmac_2_platform.h"
+#include "halmac_type.h"
+
+#include "halmac_usb_reg.h"
+#include "halmac_sdio_reg.h"
+#include "halmac_pcie_reg.h"
+
+#include "halmac_bit2.h"
+#include "halmac_reg2.h"
+
+#include "halmac_tx_desc_nic.h"
+#include "halmac_rx_desc_nic.h"
+#include "halmac_tx_bd_nic.h"
+#include "halmac_rx_bd_nic.h"
+#include "halmac_fw_offload_c2h_nic.h"
+#include "halmac_fw_offload_h2c_nic.h"
+#include "halmac_h2c_extra_info_nic.h"
+#include "halmac_original_c2h_nic.h"
+#include "halmac_original_h2c_nic.h"
+
+#include "halmac_tx_desc_chip.h"
+#include "halmac_rx_desc_chip.h"
+#include "halmac_tx_bd_chip.h"
+#include "halmac_rx_bd_chip.h"
+#include "halmac_88xx/halmac_88xx_cfg.h"
+
+#include "halmac_88xx/halmac_8822b/halmac_8822b_cfg.h"
+#include "halmac_reg_8822b.h"
+#include "halmac_bit_8822b.h"
+
+enum halmac_ret_status
+halmac_init_adapter(void *driver_adapter,
+		    struct halmac_platform_api *halmac_platform_api,
+		    enum halmac_interface halmac_interface,
+		    struct halmac_adapter **pp_halmac_adapter,
+		    struct halmac_api **pp_halmac_api);
+
+enum halmac_ret_status
+halmac_deinit_adapter(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status halmac_halt_api(struct halmac_adapter *halmac_adapter);
+
+enum halmac_ret_status halmac_get_version(struct halmac_ver *version);
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_bit2.h b/drivers/staging/rtlwifi/halmac/halmac_bit2.h
new file mode 100644
index 000000000000..1c7fe5d7df64
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_bit2.h
@@ -0,0 +1,13407 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __RTL_WLAN_BITDEF_H__
+#define __RTL_WLAN_BITDEF_H__
+
+/*-------------------------Modification Log-----------------------------------
+ *	Base on MAC_Register.doc SVN391
+ *-------------------------Modification Log-----------------------------------
+ */
+
+/*--------------------------Include File--------------------------------------*/
+/*--------------------------Include File--------------------------------------*/
+
+/* 3 ============Programming guide Start===================== */
+/*
+ *	1. For all bit define, it should be prefixed by "BIT_"
+ *	2. For all bit mask, it should be prefixed by "BIT_MASK_"
+ *	3. For all bit shift, it should be prefixed by "BIT_SHIFT_"
+ *	4. For other case, prefix is not needed
+ *
+ * Example:
+ * #define BIT_SHIFT_MAX_TXDMA		16
+ * #define BIT_MASK_MAX_TXDMA		0x7
+ * #define BIT_MAX_TXDMA(x)		\
+ *			(((x) & BIT_MASK_MAX_TXDMA) << BIT_SHIFT_MAX_TXDMA)
+ * #define BIT_GET_MAX_TXDMA(x)		\
+ *			(((x) >> BIT_SHIFT_MAX_TXDMA) & BIT_MASK_MAX_TXDMA)
+ *
+ */
+/* 3 ============Programming guide End===================== */
+
+#define CPU_OPT_WIDTH 0x1F
+
+#define BIT_SHIFT_WATCH_DOG_RECORD_V1 10
+#define BIT_MASK_WATCH_DOG_RECORD_V1 0x3fff
+#define BIT_WATCH_DOG_RECORD_V1(x)                                             \
+	(((x) & BIT_MASK_WATCH_DOG_RECORD_V1) << BIT_SHIFT_WATCH_DOG_RECORD_V1)
+#define BIT_GET_WATCH_DOG_RECORD_V1(x)                                         \
+	(((x) >> BIT_SHIFT_WATCH_DOG_RECORD_V1) & BIT_MASK_WATCH_DOG_RECORD_V1)
+
+#define BIT_R_IO_TIMEOUT_FLAG_V1 BIT(9)
+
+#define BIT_ISO_MD2PP BIT(0)
+
+#define BIT_SHIFT_R_WMAC_IPV6_MYIPAD 0
+#define BIT_MASK_R_WMAC_IPV6_MYIPAD 0xffffffffffffffffffffffffffffffffL
+#define BIT_R_WMAC_IPV6_MYIPAD(x)                                              \
+	(((x) & BIT_MASK_R_WMAC_IPV6_MYIPAD) << BIT_SHIFT_R_WMAC_IPV6_MYIPAD)
+#define BIT_GET_R_WMAC_IPV6_MYIPAD(x)                                          \
+	(((x) >> BIT_SHIFT_R_WMAC_IPV6_MYIPAD) & BIT_MASK_R_WMAC_IPV6_MYIPAD)
+
+/* 2 REG_SDIO_TX_CTRL			(Offset 0x10250000) */
+
+#define BIT_SHIFT_SDIO_INT_TIMEOUT 16
+#define BIT_MASK_SDIO_INT_TIMEOUT 0xffff
+#define BIT_SDIO_INT_TIMEOUT(x)                                                \
+	(((x) & BIT_MASK_SDIO_INT_TIMEOUT) << BIT_SHIFT_SDIO_INT_TIMEOUT)
+#define BIT_GET_SDIO_INT_TIMEOUT(x)                                            \
+	(((x) >> BIT_SHIFT_SDIO_INT_TIMEOUT) & BIT_MASK_SDIO_INT_TIMEOUT)
+
+/* 2 REG_SYS_ISO_CTRL			(Offset 0x0000) */
+
+#define BIT_PWC_EV12V BIT(15)
+
+/* 2 REG_SDIO_TX_CTRL			(Offset 0x10250000) */
+
+#define BIT_IO_ERR_STATUS BIT(15)
+
+/* 2 REG_SYS_ISO_CTRL			(Offset 0x0000) */
+
+#define BIT_PWC_EV25V BIT(14)
+
+/* 2 REG_SYS_ISO_CTRL			(Offset 0x0000) */
+
+#define BIT_PA33V_EN BIT(13)
+#define BIT_PA12V_EN BIT(12)
+
+/* 2 REG_SYS_ISO_CTRL			(Offset 0x0000) */
+
+#define BIT_UA33V_EN BIT(11)
+#define BIT_UA12V_EN BIT(10)
+
+/* 2 REG_SYS_ISO_CTRL			(Offset 0x0000) */
+
+#define BIT_ISO_RFDIO BIT(9)
+
+/* 2 REG_SDIO_TX_CTRL			(Offset 0x10250000) */
+
+#define BIT_REPLY_ERRCRC_IN_DATA BIT(9)
+
+/* 2 REG_SYS_ISO_CTRL			(Offset 0x0000) */
+
+#define BIT_ISO_EB2CORE BIT(8)
+
+/* 2 REG_SDIO_TX_CTRL			(Offset 0x10250000) */
+
+#define BIT_EN_CMD53_OVERLAP BIT(8)
+
+/* 2 REG_SYS_ISO_CTRL			(Offset 0x0000) */
+
+#define BIT_ISO_DIOE BIT(7)
+
+/* 2 REG_SDIO_TX_CTRL			(Offset 0x10250000) */
+
+#define BIT_REPLY_ERR_IN_R5 BIT(7)
+
+/* 2 REG_SYS_ISO_CTRL			(Offset 0x0000) */
+
+#define BIT_ISO_WLPON2PP BIT(6)
+
+/* 2 REG_SDIO_TX_CTRL			(Offset 0x10250000) */
+
+#define BIT_R18A_EN BIT(6)
+
+/* 2 REG_SYS_ISO_CTRL			(Offset 0x0000) */
+
+#define BIT_ISO_IP2MAC_WA2PP BIT(5)
+
+/* 2 REG_SDIO_TX_CTRL			(Offset 0x10250000) */
+
+#define BIT_INIT_CMD_EN BIT(5)
+
+/* 2 REG_SYS_ISO_CTRL			(Offset 0x0000) */
+
+#define BIT_ISO_PD2CORE BIT(4)
+
+/* 2 REG_SYS_ISO_CTRL			(Offset 0x0000) */
+
+#define BIT_ISO_PA2PCIE BIT(3)
+
+/* 2 REG_SYS_ISO_CTRL			(Offset 0x0000) */
+
+#define BIT_ISO_UD2CORE BIT(2)
+
+/* 2 REG_SDIO_TX_CTRL			(Offset 0x10250000) */
+
+#define BIT_EN_RXDMA_MASK_INT BIT(2)
+
+/* 2 REG_SYS_ISO_CTRL			(Offset 0x0000) */
+
+#define BIT_ISO_UA2USB BIT(1)
+
+/* 2 REG_SDIO_TX_CTRL			(Offset 0x10250000) */
+
+#define BIT_EN_MASK_TIMER BIT(1)
+
+/* 2 REG_SYS_ISO_CTRL			(Offset 0x0000) */
+
+#define BIT_ISO_WD2PP BIT(0)
+
+/* 2 REG_SDIO_TX_CTRL			(Offset 0x10250000) */
+
+#define BIT_CMD_ERR_STOP_INT_EN BIT(0)
+
+/* 2 REG_SYS_FUNC_EN				(Offset 0x0002) */
+
+#define BIT_FEN_MREGEN BIT(15)
+#define BIT_FEN_HWPDN BIT(14)
+
+/* 2 REG_SYS_FUNC_EN				(Offset 0x0002) */
+
+#define BIT_EN_25_1 BIT(13)
+
+/* 2 REG_SYS_FUNC_EN				(Offset 0x0002) */
+
+#define BIT_FEN_ELDR BIT(12)
+#define BIT_FEN_DCORE BIT(11)
+#define BIT_FEN_CPUEN BIT(10)
+#define BIT_FEN_DIOE BIT(9)
+#define BIT_FEN_PCIED BIT(8)
+#define BIT_FEN_PPLL BIT(7)
+#define BIT_FEN_PCIEA BIT(6)
+#define BIT_FEN_DIO_PCIE BIT(5)
+#define BIT_FEN_USBD BIT(4)
+#define BIT_FEN_UPLL BIT(3)
+#define BIT_FEN_USBA BIT(2)
+
+/* 2 REG_SYS_FUNC_EN				(Offset 0x0002) */
+
+#define BIT_FEN_BB_GLB_RSTN BIT(1)
+#define BIT_FEN_BBRSTB BIT(0)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_SOP_EABM BIT(31)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_SOP_ACKF BIT(30)
+#define BIT_SOP_ERCK BIT(29)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_SOP_ESWR BIT(28)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_SOP_PWMM BIT(27)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_SOP_EECK BIT(26)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_SOP_EXTL BIT(24)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_SYM_OP_RING_12M BIT(22)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_ROP_SWPR BIT(21)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_DIS_HW_LPLDM BIT(20)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_OPT_SWRST_WLMCU BIT(19)
+#define BIT_RDY_SYSPWR BIT(17)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_EN_WLON BIT(16)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_APDM_HPDN BIT(15)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_AFSM_PCIE_SUS_EN BIT(12)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_AFSM_WLSUS_EN BIT(11)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_APFM_SWLPS BIT(10)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_APFM_OFFMAC BIT(9)
+#define BIT_APFN_ONMAC BIT(8)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_CHIP_PDN_EN BIT(7)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_RDY_MACDIS BIT(6)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_RING_CLK_12M_EN BIT(4)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_PFM_WOWL BIT(3)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_PFM_LDKP BIT(2)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_WL_HCI_ALD BIT(1)
+
+/* 2 REG_SYS_PW_CTRL				(Offset 0x0004) */
+
+#define BIT_PFM_LDALL BIT(0)
+
+/* 2 REG_SYS_CLK_CTRL			(Offset 0x0008) */
+
+#define BIT_LDO_DUMMY BIT(15)
+
+/* 2 REG_SYS_CLK_CTRL			(Offset 0x0008) */
+
+#define BIT_CPU_CLK_EN BIT(14)
+
+/* 2 REG_SYS_CLK_CTRL			(Offset 0x0008) */
+
+#define BIT_SYMREG_CLK_EN BIT(13)
+
+/* 2 REG_SYS_CLK_CTRL			(Offset 0x0008) */
+
+#define BIT_HCI_CLK_EN BIT(12)
+
+/* 2 REG_SYS_CLK_CTRL			(Offset 0x0008) */
+
+#define BIT_MAC_CLK_EN BIT(11)
+#define BIT_SEC_CLK_EN BIT(10)
+
+/* 2 REG_SYS_CLK_CTRL			(Offset 0x0008) */
+
+#define BIT_PHY_SSC_RSTB BIT(9)
+#define BIT_EXT_32K_EN BIT(8)
+
+/* 2 REG_SYS_CLK_CTRL			(Offset 0x0008) */
+
+#define BIT_WL_CLK_TEST BIT(7)
+#define BIT_OP_SPS_PWM_EN BIT(6)
+
+/* 2 REG_SYS_CLK_CTRL			(Offset 0x0008) */
+
+#define BIT_LOADER_CLK_EN BIT(5)
+#define BIT_MACSLP BIT(4)
+#define BIT_WAKEPAD_EN BIT(3)
+#define BIT_ROMD16V_EN BIT(2)
+
+/* 2 REG_SYS_CLK_CTRL			(Offset 0x0008) */
+
+#define BIT_CKANA12M_EN BIT(1)
+
+/* 2 REG_SYS_CLK_CTRL			(Offset 0x0008) */
+
+#define BIT_CNTD16V_EN BIT(0)
+
+/* 2 REG_SYS_EEPROM_CTRL			(Offset 0x000A) */
+
+#define BIT_SHIFT_VPDIDX 8
+#define BIT_MASK_VPDIDX 0xff
+#define BIT_VPDIDX(x) (((x) & BIT_MASK_VPDIDX) << BIT_SHIFT_VPDIDX)
+#define BIT_GET_VPDIDX(x) (((x) >> BIT_SHIFT_VPDIDX) & BIT_MASK_VPDIDX)
+
+#define BIT_SHIFT_EEM1_0 6
+#define BIT_MASK_EEM1_0 0x3
+#define BIT_EEM1_0(x) (((x) & BIT_MASK_EEM1_0) << BIT_SHIFT_EEM1_0)
+#define BIT_GET_EEM1_0(x) (((x) >> BIT_SHIFT_EEM1_0) & BIT_MASK_EEM1_0)
+
+#define BIT_AUTOLOAD_SUS BIT(5)
+
+/* 2 REG_SYS_EEPROM_CTRL			(Offset 0x000A) */
+
+#define BIT_EERPOMSEL BIT(4)
+
+/* 2 REG_SYS_EEPROM_CTRL			(Offset 0x000A) */
+
+#define BIT_EECS_V1 BIT(3)
+#define BIT_EESK_V1 BIT(2)
+#define BIT_EEDI_V1 BIT(1)
+#define BIT_EEDO_V1 BIT(0)
+
+/* 2 REG_EE_VPD				(Offset 0x000C) */
+
+#define BIT_SHIFT_VPD_DATA 0
+#define BIT_MASK_VPD_DATA 0xffffffffL
+#define BIT_VPD_DATA(x) (((x) & BIT_MASK_VPD_DATA) << BIT_SHIFT_VPD_DATA)
+#define BIT_GET_VPD_DATA(x) (((x) >> BIT_SHIFT_VPD_DATA) & BIT_MASK_VPD_DATA)
+
+/* 2 REG_SYS_SWR_CTRL1			(Offset 0x0010) */
+
+#define BIT_C2_L_BIT0 BIT(31)
+
+/* 2 REG_SYS_SWR_CTRL1			(Offset 0x0010) */
+
+#define BIT_SHIFT_C1_L 29
+#define BIT_MASK_C1_L 0x3
+#define BIT_C1_L(x) (((x) & BIT_MASK_C1_L) << BIT_SHIFT_C1_L)
+#define BIT_GET_C1_L(x) (((x) >> BIT_SHIFT_C1_L) & BIT_MASK_C1_L)
+
+/* 2 REG_SYS_SWR_CTRL1			(Offset 0x0010) */
+
+#define BIT_SHIFT_REG_FREQ_L 25
+#define BIT_MASK_REG_FREQ_L 0x7
+#define BIT_REG_FREQ_L(x) (((x) & BIT_MASK_REG_FREQ_L) << BIT_SHIFT_REG_FREQ_L)
+#define BIT_GET_REG_FREQ_L(x)                                                  \
+	(((x) >> BIT_SHIFT_REG_FREQ_L) & BIT_MASK_REG_FREQ_L)
+
+#define BIT_REG_EN_DUTY BIT(24)
+
+/* 2 REG_SYS_SWR_CTRL1			(Offset 0x0010) */
+
+#define BIT_SHIFT_REG_MODE 22
+#define BIT_MASK_REG_MODE 0x3
+#define BIT_REG_MODE(x) (((x) & BIT_MASK_REG_MODE) << BIT_SHIFT_REG_MODE)
+#define BIT_GET_REG_MODE(x) (((x) >> BIT_SHIFT_REG_MODE) & BIT_MASK_REG_MODE)
+
+/* 2 REG_SYS_SWR_CTRL1			(Offset 0x0010) */
+
+#define BIT_REG_EN_SP BIT(21)
+#define BIT_REG_AUTO_L BIT(20)
+
+/* 2 REG_SYS_SWR_CTRL1			(Offset 0x0010) */
+
+#define BIT_SW18_SELD_BIT0 BIT(19)
+
+/* 2 REG_SYS_SWR_CTRL1			(Offset 0x0010) */
+
+#define BIT_SW18_POWOCP BIT(18)
+
+/* 2 REG_SYS_SWR_CTRL1			(Offset 0x0010) */
+
+#define BIT_SHIFT_OCP_L1 15
+#define BIT_MASK_OCP_L1 0x7
+#define BIT_OCP_L1(x) (((x) & BIT_MASK_OCP_L1) << BIT_SHIFT_OCP_L1)
+#define BIT_GET_OCP_L1(x) (((x) >> BIT_SHIFT_OCP_L1) & BIT_MASK_OCP_L1)
+
+/* 2 REG_SYS_SWR_CTRL1			(Offset 0x0010) */
+
+#define BIT_SHIFT_CF_L 13
+#define BIT_MASK_CF_L 0x3
+#define BIT_CF_L(x) (((x) & BIT_MASK_CF_L) << BIT_SHIFT_CF_L)
+#define BIT_GET_CF_L(x) (((x) >> BIT_SHIFT_CF_L) & BIT_MASK_CF_L)
+
+/* 2 REG_SYS_SWR_CTRL1			(Offset 0x0010) */
+
+#define BIT_SW18_FPWM BIT(11)
+
+/* 2 REG_SYS_SWR_CTRL1			(Offset 0x0010) */
+
+#define BIT_SW18_SWEN BIT(9)
+#define BIT_SW18_LDEN BIT(8)
+#define BIT_MAC_ID_EN BIT(7)
+
+/* 2 REG_SYS_SWR_CTRL1			(Offset 0x0010) */
+
+#define BIT_AFE_BGEN BIT(0)
+
+/* 2 REG_SYS_SWR_CTRL2			(Offset 0x0014) */
+
+#define BIT_POW_ZCD_L BIT(31)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_CRCERR_MSK BIT(31)
+
+/* 2 REG_SYS_SWR_CTRL2			(Offset 0x0014) */
+
+#define BIT_AUTOZCD_L BIT(30)
+#define BIT_SDIO_HSISR3_IND_MSK BIT(30)
+#define BIT_SDIO_HSISR2_IND_MSK BIT(29)
+
+/* 2 REG_SYS_SWR_CTRL2			(Offset 0x0014) */
+
+#define BIT_SHIFT_REG_DELAY 28
+#define BIT_MASK_REG_DELAY 0x3
+#define BIT_REG_DELAY(x) (((x) & BIT_MASK_REG_DELAY) << BIT_SHIFT_REG_DELAY)
+#define BIT_GET_REG_DELAY(x) (((x) >> BIT_SHIFT_REG_DELAY) & BIT_MASK_REG_DELAY)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_HEISR_IND_MSK BIT(28)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_CTWEND_MSK BIT(27)
+#define BIT_SDIO_ATIMEND_E_MSK BIT(26)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIIO_ATIMEND_MSK BIT(25)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_OCPINT_MSK BIT(24)
+
+/* 2 REG_SYS_SWR_CTRL2			(Offset 0x0014) */
+
+#define BIT_SHIFT_V15ADJ_L1_V1 24
+#define BIT_MASK_V15ADJ_L1_V1 0x7
+#define BIT_V15ADJ_L1_V1(x)                                                    \
+	(((x) & BIT_MASK_V15ADJ_L1_V1) << BIT_SHIFT_V15ADJ_L1_V1)
+#define BIT_GET_V15ADJ_L1_V1(x)                                                \
+	(((x) >> BIT_SHIFT_V15ADJ_L1_V1) & BIT_MASK_V15ADJ_L1_V1)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_PSTIMEOUT_MSK BIT(23)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_GTINT4_MSK BIT(22)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_GTINT3_MSK BIT(21)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_HSISR_IND_MSK BIT(20)
+
+/* 2 REG_SYS_SWR_CTRL2			(Offset 0x0014) */
+
+#define BIT_SHIFT_VOL_L1_V1 20
+#define BIT_MASK_VOL_L1_V1 0xf
+#define BIT_VOL_L1_V1(x) (((x) & BIT_MASK_VOL_L1_V1) << BIT_SHIFT_VOL_L1_V1)
+#define BIT_GET_VOL_L1_V1(x) (((x) >> BIT_SHIFT_VOL_L1_V1) & BIT_MASK_VOL_L1_V1)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_CPWM2_MSK BIT(19)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_CPWM1_MSK BIT(18)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_C2HCMD_INT_MSK BIT(17)
+
+/* 2 REG_SYS_SWR_CTRL2			(Offset 0x0014) */
+
+#define BIT_SHIFT_IN_L1_V1 17
+#define BIT_MASK_IN_L1_V1 0x7
+#define BIT_IN_L1_V1(x) (((x) & BIT_MASK_IN_L1_V1) << BIT_SHIFT_IN_L1_V1)
+#define BIT_GET_IN_L1_V1(x) (((x) >> BIT_SHIFT_IN_L1_V1) & BIT_MASK_IN_L1_V1)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_BCNERLY_INT_MSK BIT(16)
+
+/* 2 REG_SYS_SWR_CTRL2			(Offset 0x0014) */
+
+#define BIT_SHIFT_TBOX_L1 15
+#define BIT_MASK_TBOX_L1 0x3
+#define BIT_TBOX_L1(x) (((x) & BIT_MASK_TBOX_L1) << BIT_SHIFT_TBOX_L1)
+#define BIT_GET_TBOX_L1(x) (((x) >> BIT_SHIFT_TBOX_L1) & BIT_MASK_TBOX_L1)
+
+/* 2 REG_SYS_SWR_CTRL2			(Offset 0x0014) */
+
+#define BIT_SW18_SEL BIT(13)
+
+/* 2 REG_SYS_SWR_CTRL2			(Offset 0x0014) */
+
+#define BIT_SW18_SD BIT(10)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_TXBCNERR_MSK BIT(7)
+
+/* 2 REG_SYS_SWR_CTRL2			(Offset 0x0014) */
+
+#define BIT_SHIFT_R3_L 7
+#define BIT_MASK_R3_L 0x3
+#define BIT_R3_L(x) (((x) & BIT_MASK_R3_L) << BIT_SHIFT_R3_L)
+#define BIT_GET_R3_L(x) (((x) >> BIT_SHIFT_R3_L) & BIT_MASK_R3_L)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_TXBCNOK_MSK BIT(6)
+
+/* 2 REG_SYS_SWR_CTRL2			(Offset 0x0014) */
+
+#define BIT_SHIFT_SW18_R2 5
+#define BIT_MASK_SW18_R2 0x3
+#define BIT_SW18_R2(x) (((x) & BIT_MASK_SW18_R2) << BIT_SHIFT_SW18_R2)
+#define BIT_GET_SW18_R2(x) (((x) >> BIT_SHIFT_SW18_R2) & BIT_MASK_SW18_R2)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_RXFOVW_MSK BIT(5)
+#define BIT_SDIO_TXFOVW_MSK BIT(4)
+
+/* 2 REG_SYS_SWR_CTRL2			(Offset 0x0014) */
+
+#define BIT_SHIFT_SW18_R1 3
+#define BIT_MASK_SW18_R1 0x3
+#define BIT_SW18_R1(x) (((x) & BIT_MASK_SW18_R1) << BIT_SHIFT_SW18_R1)
+#define BIT_GET_SW18_R1(x) (((x) >> BIT_SHIFT_SW18_R1) & BIT_MASK_SW18_R1)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_RXERR_MSK BIT(3)
+#define BIT_SDIO_TXERR_MSK BIT(2)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_SDIO_AVAL_MSK BIT(1)
+
+/* 2 REG_SYS_SWR_CTRL2			(Offset 0x0014) */
+
+#define BIT_SHIFT_C3_L_C3 1
+#define BIT_MASK_C3_L_C3 0x3
+#define BIT_C3_L_C3(x) (((x) & BIT_MASK_C3_L_C3) << BIT_SHIFT_C3_L_C3)
+#define BIT_GET_C3_L_C3(x) (((x) >> BIT_SHIFT_C3_L_C3) & BIT_MASK_C3_L_C3)
+
+/* 2 REG_SDIO_HIMR				(Offset 0x10250014) */
+
+#define BIT_RX_REQUEST_MSK BIT(0)
+
+/* 2 REG_SYS_SWR_CTRL2			(Offset 0x0014) */
+
+#define BIT_C2_L_BIT1 BIT(0)
+
+/* 2 REG_SYS_SWR_CTRL3			(Offset 0x0018) */
+
+#define BIT_SPS18_OCP_DIS BIT(31)
+
+/* 2 REG_SDIO_HISR				(Offset 0x10250018) */
+
+#define BIT_SDIO_CRCERR BIT(31)
+
+/* 2 REG_SDIO_HISR				(Offset 0x10250018) */
+
+#define BIT_SDIO_HSISR3_IND BIT(30)
+#define BIT_SDIO_HSISR2_IND BIT(29)
+#define BIT_SDIO_HEISR_IND BIT(28)
+
+/* 2 REG_SDIO_HISR				(Offset 0x10250018) */
+
+#define BIT_SDIO_CTWEND BIT(27)
+#define BIT_SDIO_ATIMEND_E BIT(26)
+#define BIT_SDIO_ATIMEND BIT(25)
+#define BIT_SDIO_OCPINT BIT(24)
+#define BIT_SDIO_PSTIMEOUT BIT(23)
+#define BIT_SDIO_GTINT4 BIT(22)
+#define BIT_SDIO_GTINT3 BIT(21)
+#define BIT_SDIO_HSISR_IND BIT(20)
+#define BIT_SDIO_CPWM2 BIT(19)
+#define BIT_SDIO_CPWM1 BIT(18)
+#define BIT_SDIO_C2HCMD_INT BIT(17)
+
+/* 2 REG_SYS_SWR_CTRL3			(Offset 0x0018) */
+
+#define BIT_SHIFT_SPS18_OCP_TH 16
+#define BIT_MASK_SPS18_OCP_TH 0x7fff
+#define BIT_SPS18_OCP_TH(x)                                                    \
+	(((x) & BIT_MASK_SPS18_OCP_TH) << BIT_SHIFT_SPS18_OCP_TH)
+#define BIT_GET_SPS18_OCP_TH(x)                                                \
+	(((x) >> BIT_SHIFT_SPS18_OCP_TH) & BIT_MASK_SPS18_OCP_TH)
+
+/* 2 REG_SDIO_HISR				(Offset 0x10250018) */
+
+#define BIT_SDIO_BCNERLY_INT BIT(16)
+#define BIT_SDIO_TXBCNERR BIT(7)
+#define BIT_SDIO_TXBCNOK BIT(6)
+#define BIT_SDIO_RXFOVW BIT(5)
+#define BIT_SDIO_TXFOVW BIT(4)
+#define BIT_SDIO_RXERR BIT(3)
+#define BIT_SDIO_TXERR BIT(2)
+#define BIT_SDIO_AVAL BIT(1)
+
+/* 2 REG_SYS_SWR_CTRL3			(Offset 0x0018) */
+
+#define BIT_SHIFT_OCP_WINDOW 0
+#define BIT_MASK_OCP_WINDOW 0xffff
+#define BIT_OCP_WINDOW(x) (((x) & BIT_MASK_OCP_WINDOW) << BIT_SHIFT_OCP_WINDOW)
+#define BIT_GET_OCP_WINDOW(x)                                                  \
+	(((x) >> BIT_SHIFT_OCP_WINDOW) & BIT_MASK_OCP_WINDOW)
+
+/* 2 REG_SDIO_HISR				(Offset 0x10250018) */
+
+#define BIT_RX_REQUEST BIT(0)
+
+/* 2 REG_RSV_CTRL				(Offset 0x001C) */
+
+#define BIT_HREG_DBG BIT(23)
+
+/* 2 REG_RSV_CTRL				(Offset 0x001C) */
+
+#define BIT_WLMCUIOIF BIT(8)
+
+/* 2 REG_RSV_CTRL				(Offset 0x001C) */
+
+#define BIT_LOCK_ALL_EN BIT(7)
+
+/* 2 REG_RSV_CTRL				(Offset 0x001C) */
+
+#define BIT_R_DIS_PRST BIT(6)
+
+/* 2 REG_RSV_CTRL				(Offset 0x001C) */
+
+#define BIT_WLOCK_1C_B6 BIT(5)
+
+/* 2 REG_RSV_CTRL				(Offset 0x001C) */
+
+#define BIT_WLOCK_40 BIT(4)
+#define BIT_WLOCK_08 BIT(3)
+#define BIT_WLOCK_04 BIT(2)
+#define BIT_WLOCK_00 BIT(1)
+#define BIT_WLOCK_ALL BIT(0)
+
+/* 2 REG_SDIO_RX_REQ_LEN			(Offset 0x1025001C) */
+
+#define BIT_SHIFT_RX_REQ_LEN_V1 0
+#define BIT_MASK_RX_REQ_LEN_V1 0x3ffff
+#define BIT_RX_REQ_LEN_V1(x)                                                   \
+	(((x) & BIT_MASK_RX_REQ_LEN_V1) << BIT_SHIFT_RX_REQ_LEN_V1)
+#define BIT_GET_RX_REQ_LEN_V1(x)                                               \
+	(((x) >> BIT_SHIFT_RX_REQ_LEN_V1) & BIT_MASK_RX_REQ_LEN_V1)
+
+/* 2 REG_RF_CTRL				(Offset 0x001F) */
+
+#define BIT_RF_SDMRSTB BIT(2)
+
+/* 2 REG_RF_CTRL				(Offset 0x001F) */
+
+#define BIT_RF_RSTB BIT(1)
+
+/* 2 REG_RF_CTRL				(Offset 0x001F) */
+
+#define BIT_RF_EN BIT(0)
+
+/* 2 REG_SDIO_FREE_TXPG_SEQ_V1		(Offset 0x1025001F) */
+
+#define BIT_SHIFT_FREE_TXPG_SEQ 0
+#define BIT_MASK_FREE_TXPG_SEQ 0xff
+#define BIT_FREE_TXPG_SEQ(x)                                                   \
+	(((x) & BIT_MASK_FREE_TXPG_SEQ) << BIT_SHIFT_FREE_TXPG_SEQ)
+#define BIT_GET_FREE_TXPG_SEQ(x)                                               \
+	(((x) >> BIT_SHIFT_FREE_TXPG_SEQ) & BIT_MASK_FREE_TXPG_SEQ)
+
+/* 2 REG_AFE_LDO_CTRL			(Offset 0x0020) */
+
+#define BIT_SHIFT_LPLDH12_RSV 29
+#define BIT_MASK_LPLDH12_RSV 0x7
+#define BIT_LPLDH12_RSV(x)                                                     \
+	(((x) & BIT_MASK_LPLDH12_RSV) << BIT_SHIFT_LPLDH12_RSV)
+#define BIT_GET_LPLDH12_RSV(x)                                                 \
+	(((x) >> BIT_SHIFT_LPLDH12_RSV) & BIT_MASK_LPLDH12_RSV)
+
+/* 2 REG_AFE_LDO_CTRL			(Offset 0x0020) */
+
+#define BIT_LPLDH12_SLP BIT(28)
+
+#define BIT_SHIFT_LPLDH12_VADJ 24
+#define BIT_MASK_LPLDH12_VADJ 0xf
+#define BIT_LPLDH12_VADJ(x)                                                    \
+	(((x) & BIT_MASK_LPLDH12_VADJ) << BIT_SHIFT_LPLDH12_VADJ)
+#define BIT_GET_LPLDH12_VADJ(x)                                                \
+	(((x) >> BIT_SHIFT_LPLDH12_VADJ) & BIT_MASK_LPLDH12_VADJ)
+
+/* 2 REG_AFE_LDO_CTRL			(Offset 0x0020) */
+
+#define BIT_LDH12_EN BIT(16)
+
+/* 2 REG_SDIO_FREE_TXPG			(Offset 0x10250020) */
+
+#define BIT_SHIFT_MID_FREEPG_V1 16
+#define BIT_MASK_MID_FREEPG_V1 0xfff
+#define BIT_MID_FREEPG_V1(x)                                                   \
+	(((x) & BIT_MASK_MID_FREEPG_V1) << BIT_SHIFT_MID_FREEPG_V1)
+#define BIT_GET_MID_FREEPG_V1(x)                                               \
+	(((x) >> BIT_SHIFT_MID_FREEPG_V1) & BIT_MASK_MID_FREEPG_V1)
+
+/* 2 REG_AFE_LDO_CTRL			(Offset 0x0020) */
+
+#define BIT_WLBBOFF_BIG_PWC_EN BIT(14)
+#define BIT_WLBBOFF_SMALL_PWC_EN BIT(13)
+#define BIT_WLMACOFF_BIG_PWC_EN BIT(12)
+#define BIT_WLPON_PWC_EN BIT(11)
+
+/* 2 REG_AFE_LDO_CTRL			(Offset 0x0020) */
+
+#define BIT_POW_REGU_P1 BIT(10)
+
+/* 2 REG_AFE_LDO_CTRL			(Offset 0x0020) */
+
+#define BIT_LDOV12W_EN BIT(8)
+
+/* 2 REG_AFE_LDO_CTRL			(Offset 0x0020) */
+
+#define BIT_EX_XTAL_DRV_DIGI BIT(7)
+#define BIT_EX_XTAL_DRV_USB BIT(6)
+#define BIT_EX_XTAL_DRV_AFE BIT(5)
+
+/* 2 REG_AFE_LDO_CTRL			(Offset 0x0020) */
+
+#define BIT_EX_XTAL_DRV_RF2 BIT(4)
+
+/* 2 REG_AFE_LDO_CTRL			(Offset 0x0020) */
+
+#define BIT_EX_XTAL_DRV_RF1 BIT(3)
+#define BIT_POW_REGU_P0 BIT(2)
+
+/* 2 REG_AFE_LDO_CTRL			(Offset 0x0020) */
+
+#define BIT_POW_PLL_LDO BIT(0)
+
+/* 2 REG_SDIO_FREE_TXPG			(Offset 0x10250020) */
+
+#define BIT_SHIFT_HIQ_FREEPG_V1 0
+#define BIT_MASK_HIQ_FREEPG_V1 0xfff
+#define BIT_HIQ_FREEPG_V1(x)                                                   \
+	(((x) & BIT_MASK_HIQ_FREEPG_V1) << BIT_SHIFT_HIQ_FREEPG_V1)
+#define BIT_GET_HIQ_FREEPG_V1(x)                                               \
+	(((x) >> BIT_SHIFT_HIQ_FREEPG_V1) & BIT_MASK_HIQ_FREEPG_V1)
+
+/* 2 REG_AFE_CTRL1				(Offset 0x0024) */
+
+#define BIT_AGPIO_GPE BIT(31)
+
+/* 2 REG_AFE_CTRL1				(Offset 0x0024) */
+
+#define BIT_SHIFT_XTAL_CAP_XI 25
+#define BIT_MASK_XTAL_CAP_XI 0x3f
+#define BIT_XTAL_CAP_XI(x)                                                     \
+	(((x) & BIT_MASK_XTAL_CAP_XI) << BIT_SHIFT_XTAL_CAP_XI)
+#define BIT_GET_XTAL_CAP_XI(x)                                                 \
+	(((x) >> BIT_SHIFT_XTAL_CAP_XI) & BIT_MASK_XTAL_CAP_XI)
+
+/* 2 REG_AFE_CTRL1				(Offset 0x0024) */
+
+#define BIT_SHIFT_XTAL_DRV_DIGI 23
+#define BIT_MASK_XTAL_DRV_DIGI 0x3
+#define BIT_XTAL_DRV_DIGI(x)                                                   \
+	(((x) & BIT_MASK_XTAL_DRV_DIGI) << BIT_SHIFT_XTAL_DRV_DIGI)
+#define BIT_GET_XTAL_DRV_DIGI(x)                                               \
+	(((x) >> BIT_SHIFT_XTAL_DRV_DIGI) & BIT_MASK_XTAL_DRV_DIGI)
+
+#define BIT_XTAL_DRV_USB_BIT1 BIT(22)
+
+/* 2 REG_AFE_CTRL1				(Offset 0x0024) */
+
+#define BIT_SHIFT_MAC_CLK_SEL 20
+#define BIT_MASK_MAC_CLK_SEL 0x3
+#define BIT_MAC_CLK_SEL(x)                                                     \
+	(((x) & BIT_MASK_MAC_CLK_SEL) << BIT_SHIFT_MAC_CLK_SEL)
+#define BIT_GET_MAC_CLK_SEL(x)                                                 \
+	(((x) >> BIT_SHIFT_MAC_CLK_SEL) & BIT_MASK_MAC_CLK_SEL)
+
+/* 2 REG_AFE_CTRL1				(Offset 0x0024) */
+
+#define BIT_XTAL_DRV_USB_BIT0 BIT(19)
+
+/* 2 REG_AFE_CTRL1				(Offset 0x0024) */
+
+#define BIT_SHIFT_XTAL_DRV_AFE 17
+#define BIT_MASK_XTAL_DRV_AFE 0x3
+#define BIT_XTAL_DRV_AFE(x)                                                    \
+	(((x) & BIT_MASK_XTAL_DRV_AFE) << BIT_SHIFT_XTAL_DRV_AFE)
+#define BIT_GET_XTAL_DRV_AFE(x)                                                \
+	(((x) >> BIT_SHIFT_XTAL_DRV_AFE) & BIT_MASK_XTAL_DRV_AFE)
+
+/* 2 REG_SDIO_FREE_TXPG2			(Offset 0x10250024) */
+
+#define BIT_SHIFT_PUB_FREEPG_V1 16
+#define BIT_MASK_PUB_FREEPG_V1 0xfff
+#define BIT_PUB_FREEPG_V1(x)                                                   \
+	(((x) & BIT_MASK_PUB_FREEPG_V1) << BIT_SHIFT_PUB_FREEPG_V1)
+#define BIT_GET_PUB_FREEPG_V1(x)                                               \
+	(((x) >> BIT_SHIFT_PUB_FREEPG_V1) & BIT_MASK_PUB_FREEPG_V1)
+
+/* 2 REG_AFE_CTRL1				(Offset 0x0024) */
+
+#define BIT_SHIFT_XTAL_DRV_RF2 15
+#define BIT_MASK_XTAL_DRV_RF2 0x3
+#define BIT_XTAL_DRV_RF2(x)                                                    \
+	(((x) & BIT_MASK_XTAL_DRV_RF2) << BIT_SHIFT_XTAL_DRV_RF2)
+#define BIT_GET_XTAL_DRV_RF2(x)                                                \
+	(((x) >> BIT_SHIFT_XTAL_DRV_RF2) & BIT_MASK_XTAL_DRV_RF2)
+
+/* 2 REG_AFE_CTRL1				(Offset 0x0024) */
+
+#define BIT_SHIFT_XTAL_DRV_RF1 13
+#define BIT_MASK_XTAL_DRV_RF1 0x3
+#define BIT_XTAL_DRV_RF1(x)                                                    \
+	(((x) & BIT_MASK_XTAL_DRV_RF1) << BIT_SHIFT_XTAL_DRV_RF1)
+#define BIT_GET_XTAL_DRV_RF1(x)                                                \
+	(((x) >> BIT_SHIFT_XTAL_DRV_RF1) & BIT_MASK_XTAL_DRV_RF1)
+
+/* 2 REG_AFE_CTRL1				(Offset 0x0024) */
+
+#define BIT_XTAL_DELAY_DIGI BIT(12)
+
+/* 2 REG_AFE_CTRL1				(Offset 0x0024) */
+
+#define BIT_XTAL_DELAY_USB BIT(11)
+#define BIT_XTAL_DELAY_AFE BIT(10)
+
+/* 2 REG_AFE_CTRL1				(Offset 0x0024) */
+
+#define BIT_SHIFT_XTAL_LDO_VREF 7
+#define BIT_MASK_XTAL_LDO_VREF 0x7
+#define BIT_XTAL_LDO_VREF(x)                                                   \
+	(((x) & BIT_MASK_XTAL_LDO_VREF) << BIT_SHIFT_XTAL_LDO_VREF)
+#define BIT_GET_XTAL_LDO_VREF(x)                                               \
+	(((x) >> BIT_SHIFT_XTAL_LDO_VREF) & BIT_MASK_XTAL_LDO_VREF)
+
+/* 2 REG_AFE_CTRL1				(Offset 0x0024) */
+
+#define BIT_XTAL_XQSEL_RF BIT(6)
+#define BIT_XTAL_XQSEL BIT(5)
+
+/* 2 REG_AFE_CTRL1				(Offset 0x0024) */
+
+#define BIT_SHIFT_XTAL_GMN_V2 3
+#define BIT_MASK_XTAL_GMN_V2 0x3
+#define BIT_XTAL_GMN_V2(x)                                                     \
+	(((x) & BIT_MASK_XTAL_GMN_V2) << BIT_SHIFT_XTAL_GMN_V2)
+#define BIT_GET_XTAL_GMN_V2(x)                                                 \
+	(((x) >> BIT_SHIFT_XTAL_GMN_V2) & BIT_MASK_XTAL_GMN_V2)
+
+/* 2 REG_AFE_CTRL1				(Offset 0x0024) */
+
+#define BIT_SHIFT_XTAL_GMP_V2 1
+#define BIT_MASK_XTAL_GMP_V2 0x3
+#define BIT_XTAL_GMP_V2(x)                                                     \
+	(((x) & BIT_MASK_XTAL_GMP_V2) << BIT_SHIFT_XTAL_GMP_V2)
+#define BIT_GET_XTAL_GMP_V2(x)                                                 \
+	(((x) >> BIT_SHIFT_XTAL_GMP_V2) & BIT_MASK_XTAL_GMP_V2)
+
+/* 2 REG_AFE_CTRL1				(Offset 0x0024) */
+
+#define BIT_XTAL_EN BIT(0)
+
+/* 2 REG_SDIO_FREE_TXPG2			(Offset 0x10250024) */
+
+#define BIT_SHIFT_LOW_FREEPG_V1 0
+#define BIT_MASK_LOW_FREEPG_V1 0xfff
+#define BIT_LOW_FREEPG_V1(x)                                                   \
+	(((x) & BIT_MASK_LOW_FREEPG_V1) << BIT_SHIFT_LOW_FREEPG_V1)
+#define BIT_GET_LOW_FREEPG_V1(x)                                               \
+	(((x) >> BIT_SHIFT_LOW_FREEPG_V1) & BIT_MASK_LOW_FREEPG_V1)
+
+/* 2 REG_AFE_CTRL2				(Offset 0x0028) */
+
+#define BIT_SHIFT_REG_C3_V4 30
+#define BIT_MASK_REG_C3_V4 0x3
+#define BIT_REG_C3_V4(x) (((x) & BIT_MASK_REG_C3_V4) << BIT_SHIFT_REG_C3_V4)
+#define BIT_GET_REG_C3_V4(x) (((x) >> BIT_SHIFT_REG_C3_V4) & BIT_MASK_REG_C3_V4)
+
+#define BIT_REG_CP_BIT1 BIT(29)
+
+/* 2 REG_AFE_CTRL2				(Offset 0x0028) */
+
+#define BIT_SHIFT_REG_RS_V4 26
+#define BIT_MASK_REG_RS_V4 0x7
+#define BIT_REG_RS_V4(x) (((x) & BIT_MASK_REG_RS_V4) << BIT_SHIFT_REG_RS_V4)
+#define BIT_GET_REG_RS_V4(x) (((x) >> BIT_SHIFT_REG_RS_V4) & BIT_MASK_REG_RS_V4)
+
+/* 2 REG_SDIO_OQT_FREE_TXPG_V1		(Offset 0x10250028) */
+
+#define BIT_SHIFT_NOAC_OQT_FREEPG_V1 24
+#define BIT_MASK_NOAC_OQT_FREEPG_V1 0xff
+#define BIT_NOAC_OQT_FREEPG_V1(x)                                              \
+	(((x) & BIT_MASK_NOAC_OQT_FREEPG_V1) << BIT_SHIFT_NOAC_OQT_FREEPG_V1)
+#define BIT_GET_NOAC_OQT_FREEPG_V1(x)                                          \
+	(((x) >> BIT_SHIFT_NOAC_OQT_FREEPG_V1) & BIT_MASK_NOAC_OQT_FREEPG_V1)
+
+/* 2 REG_AFE_CTRL2				(Offset 0x0028) */
+
+#define BIT_SHIFT_REG__CS 24
+#define BIT_MASK_REG__CS 0x3
+#define BIT_REG__CS(x) (((x) & BIT_MASK_REG__CS) << BIT_SHIFT_REG__CS)
+#define BIT_GET_REG__CS(x) (((x) >> BIT_SHIFT_REG__CS) & BIT_MASK_REG__CS)
+
+/* 2 REG_AFE_CTRL2				(Offset 0x0028) */
+
+#define BIT_SHIFT_REG_CP_OFFSET 21
+#define BIT_MASK_REG_CP_OFFSET 0x7
+#define BIT_REG_CP_OFFSET(x)                                                   \
+	(((x) & BIT_MASK_REG_CP_OFFSET) << BIT_SHIFT_REG_CP_OFFSET)
+#define BIT_GET_REG_CP_OFFSET(x)                                               \
+	(((x) >> BIT_SHIFT_REG_CP_OFFSET) & BIT_MASK_REG_CP_OFFSET)
+
+/* 2 REG_AFE_CTRL2				(Offset 0x0028) */
+
+#define BIT_SHIFT_CP_BIAS 18
+#define BIT_MASK_CP_BIAS 0x7
+#define BIT_CP_BIAS(x) (((x) & BIT_MASK_CP_BIAS) << BIT_SHIFT_CP_BIAS)
+#define BIT_GET_CP_BIAS(x) (((x) >> BIT_SHIFT_CP_BIAS) & BIT_MASK_CP_BIAS)
+
+/* 2 REG_AFE_CTRL2				(Offset 0x0028) */
+
+#define BIT_REG_IDOUBLE_V2 BIT(17)
+
+/* 2 REG_AFE_CTRL2				(Offset 0x0028) */
+
+#define BIT_EN_SYN BIT(16)
+
+#define BIT_SHIFT_AC_OQT_FREEPG_V1 16
+#define BIT_MASK_AC_OQT_FREEPG_V1 0xff
+#define BIT_AC_OQT_FREEPG_V1(x)                                                \
+	(((x) & BIT_MASK_AC_OQT_FREEPG_V1) << BIT_SHIFT_AC_OQT_FREEPG_V1)
+#define BIT_GET_AC_OQT_FREEPG_V1(x)                                            \
+	(((x) >> BIT_SHIFT_AC_OQT_FREEPG_V1) & BIT_MASK_AC_OQT_FREEPG_V1)
+
+/* 2 REG_AFE_CTRL2				(Offset 0x0028) */
+
+#define BIT_SHIFT_MCCO 14
+#define BIT_MASK_MCCO 0x3
+#define BIT_MCCO(x) (((x) & BIT_MASK_MCCO) << BIT_SHIFT_MCCO)
+#define BIT_GET_MCCO(x) (((x) >> BIT_SHIFT_MCCO) & BIT_MASK_MCCO)
+
+/* 2 REG_AFE_CTRL2				(Offset 0x0028) */
+
+#define BIT_SHIFT_REG_LDO_SEL 12
+#define BIT_MASK_REG_LDO_SEL 0x3
+#define BIT_REG_LDO_SEL(x)                                                     \
+	(((x) & BIT_MASK_REG_LDO_SEL) << BIT_SHIFT_REG_LDO_SEL)
+#define BIT_GET_REG_LDO_SEL(x)                                                 \
+	(((x) >> BIT_SHIFT_REG_LDO_SEL) & BIT_MASK_REG_LDO_SEL)
+
+#define BIT_REG_KVCO_V2 BIT(10)
+
+/* 2 REG_AFE_CTRL2				(Offset 0x0028) */
+
+#define BIT_AGPIO_GPO BIT(9)
+
+/* 2 REG_AFE_CTRL2				(Offset 0x0028) */
+
+#define BIT_SHIFT_AGPIO_DRV 7
+#define BIT_MASK_AGPIO_DRV 0x3
+#define BIT_AGPIO_DRV(x) (((x) & BIT_MASK_AGPIO_DRV) << BIT_SHIFT_AGPIO_DRV)
+#define BIT_GET_AGPIO_DRV(x) (((x) >> BIT_SHIFT_AGPIO_DRV) & BIT_MASK_AGPIO_DRV)
+
+/* 2 REG_AFE_CTRL2				(Offset 0x0028) */
+
+#define BIT_SHIFT_XTAL_CAP_XO 1
+#define BIT_MASK_XTAL_CAP_XO 0x3f
+#define BIT_XTAL_CAP_XO(x)                                                     \
+	(((x) & BIT_MASK_XTAL_CAP_XO) << BIT_SHIFT_XTAL_CAP_XO)
+#define BIT_GET_XTAL_CAP_XO(x)                                                 \
+	(((x) >> BIT_SHIFT_XTAL_CAP_XO) & BIT_MASK_XTAL_CAP_XO)
+
+/* 2 REG_AFE_CTRL2				(Offset 0x0028) */
+
+#define BIT_POW_PLL BIT(0)
+
+/* 2 REG_SDIO_OQT_FREE_TXPG_V1		(Offset 0x10250028) */
+
+#define BIT_SHIFT_EXQ_FREEPG_V1 0
+#define BIT_MASK_EXQ_FREEPG_V1 0xfff
+#define BIT_EXQ_FREEPG_V1(x)                                                   \
+	(((x) & BIT_MASK_EXQ_FREEPG_V1) << BIT_SHIFT_EXQ_FREEPG_V1)
+#define BIT_GET_EXQ_FREEPG_V1(x)                                               \
+	(((x) >> BIT_SHIFT_EXQ_FREEPG_V1) & BIT_MASK_EXQ_FREEPG_V1)
+
+/* 2 REG_AFE_CTRL3				(Offset 0x002C) */
+
+#define BIT_SHIFT_PS 7
+#define BIT_MASK_PS 0x7
+#define BIT_PS(x) (((x) & BIT_MASK_PS) << BIT_SHIFT_PS)
+#define BIT_GET_PS(x) (((x) >> BIT_SHIFT_PS) & BIT_MASK_PS)
+
+/* 2 REG_AFE_CTRL3				(Offset 0x002C) */
+
+#define BIT_PSEN BIT(6)
+#define BIT_DOGENB BIT(5)
+
+/* 2 REG_AFE_CTRL3				(Offset 0x002C) */
+
+#define BIT_REG_MBIAS BIT(4)
+
+/* 2 REG_AFE_CTRL3				(Offset 0x002C) */
+
+#define BIT_SHIFT_REG_R3_V4 1
+#define BIT_MASK_REG_R3_V4 0x7
+#define BIT_REG_R3_V4(x) (((x) & BIT_MASK_REG_R3_V4) << BIT_SHIFT_REG_R3_V4)
+#define BIT_GET_REG_R3_V4(x) (((x) >> BIT_SHIFT_REG_R3_V4) & BIT_MASK_REG_R3_V4)
+
+/* 2 REG_AFE_CTRL3				(Offset 0x002C) */
+
+#define BIT_REG_CP_BIT0 BIT(0)
+
+/* 2 REG_EFUSE_CTRL				(Offset 0x0030) */
+
+#define BIT_EF_FLAG BIT(31)
+
+#define BIT_SHIFT_EF_PGPD 28
+#define BIT_MASK_EF_PGPD 0x7
+#define BIT_EF_PGPD(x) (((x) & BIT_MASK_EF_PGPD) << BIT_SHIFT_EF_PGPD)
+#define BIT_GET_EF_PGPD(x) (((x) >> BIT_SHIFT_EF_PGPD) & BIT_MASK_EF_PGPD)
+
+#define BIT_SHIFT_EF_RDT 24
+#define BIT_MASK_EF_RDT 0xf
+#define BIT_EF_RDT(x) (((x) & BIT_MASK_EF_RDT) << BIT_SHIFT_EF_RDT)
+#define BIT_GET_EF_RDT(x) (((x) >> BIT_SHIFT_EF_RDT) & BIT_MASK_EF_RDT)
+
+#define BIT_SHIFT_EF_PGTS 20
+#define BIT_MASK_EF_PGTS 0xf
+#define BIT_EF_PGTS(x) (((x) & BIT_MASK_EF_PGTS) << BIT_SHIFT_EF_PGTS)
+#define BIT_GET_EF_PGTS(x) (((x) >> BIT_SHIFT_EF_PGTS) & BIT_MASK_EF_PGTS)
+
+/* 2 REG_EFUSE_CTRL				(Offset 0x0030) */
+
+#define BIT_EF_PDWN BIT(19)
+
+/* 2 REG_EFUSE_CTRL				(Offset 0x0030) */
+
+#define BIT_EF_ALDEN BIT(18)
+
+/* 2 REG_SDIO_HTSFR_INFO			(Offset 0x10250030) */
+
+#define BIT_SHIFT_HTSFR1 16
+#define BIT_MASK_HTSFR1 0xffff
+#define BIT_HTSFR1(x) (((x) & BIT_MASK_HTSFR1) << BIT_SHIFT_HTSFR1)
+#define BIT_GET_HTSFR1(x) (((x) >> BIT_SHIFT_HTSFR1) & BIT_MASK_HTSFR1)
+
+/* 2 REG_EFUSE_CTRL				(Offset 0x0030) */
+
+#define BIT_SHIFT_EF_ADDR 8
+#define BIT_MASK_EF_ADDR 0x3ff
+#define BIT_EF_ADDR(x) (((x) & BIT_MASK_EF_ADDR) << BIT_SHIFT_EF_ADDR)
+#define BIT_GET_EF_ADDR(x) (((x) >> BIT_SHIFT_EF_ADDR) & BIT_MASK_EF_ADDR)
+
+#define BIT_SHIFT_EF_DATA 0
+#define BIT_MASK_EF_DATA 0xff
+#define BIT_EF_DATA(x) (((x) & BIT_MASK_EF_DATA) << BIT_SHIFT_EF_DATA)
+#define BIT_GET_EF_DATA(x) (((x) >> BIT_SHIFT_EF_DATA) & BIT_MASK_EF_DATA)
+
+/* 2 REG_SDIO_HTSFR_INFO			(Offset 0x10250030) */
+
+#define BIT_SHIFT_HTSFR0 0
+#define BIT_MASK_HTSFR0 0xffff
+#define BIT_HTSFR0(x) (((x) & BIT_MASK_HTSFR0) << BIT_SHIFT_HTSFR0)
+#define BIT_GET_HTSFR0(x) (((x) >> BIT_SHIFT_HTSFR0) & BIT_MASK_HTSFR0)
+
+/* 2 REG_LDO_EFUSE_CTRL			(Offset 0x0034) */
+
+#define BIT_LDOE25_EN BIT(31)
+
+/* 2 REG_LDO_EFUSE_CTRL			(Offset 0x0034) */
+
+#define BIT_SHIFT_LDOE25_V12ADJ_L 27
+#define BIT_MASK_LDOE25_V12ADJ_L 0xf
+#define BIT_LDOE25_V12ADJ_L(x)                                                 \
+	(((x) & BIT_MASK_LDOE25_V12ADJ_L) << BIT_SHIFT_LDOE25_V12ADJ_L)
+#define BIT_GET_LDOE25_V12ADJ_L(x)                                             \
+	(((x) >> BIT_SHIFT_LDOE25_V12ADJ_L) & BIT_MASK_LDOE25_V12ADJ_L)
+
+/* 2 REG_LDO_EFUSE_CTRL			(Offset 0x0034) */
+
+#define BIT_EF_CRES_SEL BIT(26)
+
+/* 2 REG_LDO_EFUSE_CTRL			(Offset 0x0034) */
+
+#define BIT_SHIFT_EF_SCAN_START_V1 16
+#define BIT_MASK_EF_SCAN_START_V1 0x3ff
+#define BIT_EF_SCAN_START_V1(x)                                                \
+	(((x) & BIT_MASK_EF_SCAN_START_V1) << BIT_SHIFT_EF_SCAN_START_V1)
+#define BIT_GET_EF_SCAN_START_V1(x)                                            \
+	(((x) >> BIT_SHIFT_EF_SCAN_START_V1) & BIT_MASK_EF_SCAN_START_V1)
+
+/* 2 REG_LDO_EFUSE_CTRL			(Offset 0x0034) */
+
+#define BIT_SHIFT_EF_SCAN_END 12
+#define BIT_MASK_EF_SCAN_END 0xf
+#define BIT_EF_SCAN_END(x)                                                     \
+	(((x) & BIT_MASK_EF_SCAN_END) << BIT_SHIFT_EF_SCAN_END)
+#define BIT_GET_EF_SCAN_END(x)                                                 \
+	(((x) >> BIT_SHIFT_EF_SCAN_END) & BIT_MASK_EF_SCAN_END)
+
+/* 2 REG_LDO_EFUSE_CTRL			(Offset 0x0034) */
+
+#define BIT_EF_PD_DIS BIT(11)
+
+/* 2 REG_LDO_EFUSE_CTRL			(Offset 0x0034) */
+
+#define BIT_SHIFT_EF_CELL_SEL 8
+#define BIT_MASK_EF_CELL_SEL 0x3
+#define BIT_EF_CELL_SEL(x)                                                     \
+	(((x) & BIT_MASK_EF_CELL_SEL) << BIT_SHIFT_EF_CELL_SEL)
+#define BIT_GET_EF_CELL_SEL(x)                                                 \
+	(((x) >> BIT_SHIFT_EF_CELL_SEL) & BIT_MASK_EF_CELL_SEL)
+
+/* 2 REG_LDO_EFUSE_CTRL			(Offset 0x0034) */
+
+#define BIT_EF_TRPT BIT(7)
+
+#define BIT_SHIFT_EF_TTHD 0
+#define BIT_MASK_EF_TTHD 0x7f
+#define BIT_EF_TTHD(x) (((x) & BIT_MASK_EF_TTHD) << BIT_SHIFT_EF_TTHD)
+#define BIT_GET_EF_TTHD(x) (((x) >> BIT_SHIFT_EF_TTHD) & BIT_MASK_EF_TTHD)
+
+/* 2 REG_PWR_OPTION_CTRL			(Offset 0x0038) */
+
+#define BIT_SHIFT_DBG_SEL_V1 16
+#define BIT_MASK_DBG_SEL_V1 0xff
+#define BIT_DBG_SEL_V1(x) (((x) & BIT_MASK_DBG_SEL_V1) << BIT_SHIFT_DBG_SEL_V1)
+#define BIT_GET_DBG_SEL_V1(x)                                                  \
+	(((x) >> BIT_SHIFT_DBG_SEL_V1) & BIT_MASK_DBG_SEL_V1)
+
+/* 2 REG_PWR_OPTION_CTRL			(Offset 0x0038) */
+
+#define BIT_SHIFT_DBG_SEL_BYTE 14
+#define BIT_MASK_DBG_SEL_BYTE 0x3
+#define BIT_DBG_SEL_BYTE(x)                                                    \
+	(((x) & BIT_MASK_DBG_SEL_BYTE) << BIT_SHIFT_DBG_SEL_BYTE)
+#define BIT_GET_DBG_SEL_BYTE(x)                                                \
+	(((x) >> BIT_SHIFT_DBG_SEL_BYTE) & BIT_MASK_DBG_SEL_BYTE)
+
+/* 2 REG_PWR_OPTION_CTRL			(Offset 0x0038) */
+
+#define BIT_SHIFT_STD_L1_V1 12
+#define BIT_MASK_STD_L1_V1 0x3
+#define BIT_STD_L1_V1(x) (((x) & BIT_MASK_STD_L1_V1) << BIT_SHIFT_STD_L1_V1)
+#define BIT_GET_STD_L1_V1(x) (((x) >> BIT_SHIFT_STD_L1_V1) & BIT_MASK_STD_L1_V1)
+
+/* 2 REG_PWR_OPTION_CTRL			(Offset 0x0038) */
+
+#define BIT_SYSON_DBG_PAD_E2 BIT(11)
+
+/* 2 REG_PWR_OPTION_CTRL			(Offset 0x0038) */
+
+#define BIT_SYSON_LED_PAD_E2 BIT(10)
+
+/* 2 REG_PWR_OPTION_CTRL			(Offset 0x0038) */
+
+#define BIT_SYSON_GPEE_PAD_E2 BIT(9)
+
+/* 2 REG_PWR_OPTION_CTRL			(Offset 0x0038) */
+
+#define BIT_SYSON_PCI_PAD_E2 BIT(8)
+
+#define BIT_SHIFT_MATCH_CNT 8
+#define BIT_MASK_MATCH_CNT 0xff
+#define BIT_MATCH_CNT(x) (((x) & BIT_MASK_MATCH_CNT) << BIT_SHIFT_MATCH_CNT)
+#define BIT_GET_MATCH_CNT(x) (((x) >> BIT_SHIFT_MATCH_CNT) & BIT_MASK_MATCH_CNT)
+
+/* 2 REG_PWR_OPTION_CTRL			(Offset 0x0038) */
+
+#define BIT_AUTO_SW_LDO_VOL_EN BIT(7)
+
+/* 2 REG_PWR_OPTION_CTRL			(Offset 0x0038) */
+
+#define BIT_SHIFT_SYSON_SPS0WWV_WT 4
+#define BIT_MASK_SYSON_SPS0WWV_WT 0x3
+#define BIT_SYSON_SPS0WWV_WT(x)                                                \
+	(((x) & BIT_MASK_SYSON_SPS0WWV_WT) << BIT_SHIFT_SYSON_SPS0WWV_WT)
+#define BIT_GET_SYSON_SPS0WWV_WT(x)                                            \
+	(((x) >> BIT_SHIFT_SYSON_SPS0WWV_WT) & BIT_MASK_SYSON_SPS0WWV_WT)
+
+/* 2 REG_PWR_OPTION_CTRL			(Offset 0x0038) */
+
+#define BIT_SHIFT_SYSON_SPS0LDO_WT 2
+#define BIT_MASK_SYSON_SPS0LDO_WT 0x3
+#define BIT_SYSON_SPS0LDO_WT(x)                                                \
+	(((x) & BIT_MASK_SYSON_SPS0LDO_WT) << BIT_SHIFT_SYSON_SPS0LDO_WT)
+#define BIT_GET_SYSON_SPS0LDO_WT(x)                                            \
+	(((x) >> BIT_SHIFT_SYSON_SPS0LDO_WT) & BIT_MASK_SYSON_SPS0LDO_WT)
+
+/* 2 REG_PWR_OPTION_CTRL			(Offset 0x0038) */
+
+#define BIT_SHIFT_SYSON_RCLK_SCALE 0
+#define BIT_MASK_SYSON_RCLK_SCALE 0x3
+#define BIT_SYSON_RCLK_SCALE(x)                                                \
+	(((x) & BIT_MASK_SYSON_RCLK_SCALE) << BIT_SHIFT_SYSON_RCLK_SCALE)
+#define BIT_GET_SYSON_RCLK_SCALE(x)                                            \
+	(((x) >> BIT_SHIFT_SYSON_RCLK_SCALE) & BIT_MASK_SYSON_RCLK_SCALE)
+
+/* 2 REG_SDIO_HCPWM1_V2			(Offset 0x10250038) */
+
+#define BIT_SYS_CLK BIT(0)
+
+/* 2 REG_CAL_TIMER				(Offset 0x003C) */
+
+#define BIT_SHIFT_CAL_SCAL 0
+#define BIT_MASK_CAL_SCAL 0xff
+#define BIT_CAL_SCAL(x) (((x) & BIT_MASK_CAL_SCAL) << BIT_SHIFT_CAL_SCAL)
+#define BIT_GET_CAL_SCAL(x) (((x) >> BIT_SHIFT_CAL_SCAL) & BIT_MASK_CAL_SCAL)
+
+/* 2 REG_ACLK_MON				(Offset 0x003E) */
+
+#define BIT_SHIFT_RCLK_MON 5
+#define BIT_MASK_RCLK_MON 0x7ff
+#define BIT_RCLK_MON(x) (((x) & BIT_MASK_RCLK_MON) << BIT_SHIFT_RCLK_MON)
+#define BIT_GET_RCLK_MON(x) (((x) >> BIT_SHIFT_RCLK_MON) & BIT_MASK_RCLK_MON)
+
+#define BIT_CAL_EN BIT(4)
+
+#define BIT_SHIFT_DPSTU 2
+#define BIT_MASK_DPSTU 0x3
+#define BIT_DPSTU(x) (((x) & BIT_MASK_DPSTU) << BIT_SHIFT_DPSTU)
+#define BIT_GET_DPSTU(x) (((x) >> BIT_SHIFT_DPSTU) & BIT_MASK_DPSTU)
+
+#define BIT_SUS_16X BIT(1)
+
+/* 2 REG_SDIO_INDIRECT_REG_CFG		(Offset 0x10250040) */
+
+#define BIT_INDIRECT_REG_RDY BIT(20)
+
+/* 2 REG_GPIO_MUXCFG				(Offset 0x0040) */
+
+#define BIT_FSPI_EN BIT(19)
+
+/* 2 REG_SDIO_INDIRECT_REG_CFG		(Offset 0x10250040) */
+
+#define BIT_INDIRECT_REG_R BIT(19)
+
+/* 2 REG_GPIO_MUXCFG				(Offset 0x0040) */
+
+#define BIT_WL_RTS_EXT_32K_SEL BIT(18)
+
+/* 2 REG_SDIO_INDIRECT_REG_CFG		(Offset 0x10250040) */
+
+#define BIT_INDIRECT_REG_W BIT(18)
+
+/* 2 REG_GPIO_MUXCFG				(Offset 0x0040) */
+
+#define BIT_WLGP_SPI_EN BIT(16)
+
+/* 2 REG_SDIO_INDIRECT_REG_CFG		(Offset 0x10250040) */
+
+#define BIT_SHIFT_INDIRECT_REG_SIZE 16
+#define BIT_MASK_INDIRECT_REG_SIZE 0x3
+#define BIT_INDIRECT_REG_SIZE(x)                                               \
+	(((x) & BIT_MASK_INDIRECT_REG_SIZE) << BIT_SHIFT_INDIRECT_REG_SIZE)
+#define BIT_GET_INDIRECT_REG_SIZE(x)                                           \
+	(((x) >> BIT_SHIFT_INDIRECT_REG_SIZE) & BIT_MASK_INDIRECT_REG_SIZE)
+
+/* 2 REG_GPIO_MUXCFG				(Offset 0x0040) */
+
+#define BIT_SIC_LBK BIT(15)
+#define BIT_ENHTP BIT(14)
+
+/* 2 REG_GPIO_MUXCFG				(Offset 0x0040) */
+
+#define BIT_ENSIC BIT(12)
+#define BIT_SIC_SWRST BIT(11)
+
+/* 2 REG_GPIO_MUXCFG				(Offset 0x0040) */
+
+#define BIT_PO_WIFI_PTA_PINS BIT(10)
+
+/* 2 REG_GPIO_MUXCFG				(Offset 0x0040) */
+
+#define BIT_PO_BT_PTA_PINS BIT(9)
+
+/* 2 REG_GPIO_MUXCFG				(Offset 0x0040) */
+
+#define BIT_ENUART BIT(8)
+
+#define BIT_SHIFT_BTMODE 6
+#define BIT_MASK_BTMODE 0x3
+#define BIT_BTMODE(x) (((x) & BIT_MASK_BTMODE) << BIT_SHIFT_BTMODE)
+#define BIT_GET_BTMODE(x) (((x) >> BIT_SHIFT_BTMODE) & BIT_MASK_BTMODE)
+
+#define BIT_ENBT BIT(5)
+#define BIT_EROM_EN BIT(4)
+
+/* 2 REG_GPIO_MUXCFG				(Offset 0x0040) */
+
+#define BIT_WLRFE_6_7_EN BIT(3)
+
+/* 2 REG_GPIO_MUXCFG				(Offset 0x0040) */
+
+#define BIT_WLRFE_4_5_EN BIT(2)
+
+/* 2 REG_GPIO_MUXCFG				(Offset 0x0040) */
+
+#define BIT_SHIFT_GPIOSEL 0
+#define BIT_MASK_GPIOSEL 0x3
+#define BIT_GPIOSEL(x) (((x) & BIT_MASK_GPIOSEL) << BIT_SHIFT_GPIOSEL)
+#define BIT_GET_GPIOSEL(x) (((x) >> BIT_SHIFT_GPIOSEL) & BIT_MASK_GPIOSEL)
+
+/* 2 REG_SDIO_INDIRECT_REG_CFG		(Offset 0x10250040) */
+
+#define BIT_SHIFT_INDIRECT_REG_ADDR 0
+#define BIT_MASK_INDIRECT_REG_ADDR 0xffff
+#define BIT_INDIRECT_REG_ADDR(x)                                               \
+	(((x) & BIT_MASK_INDIRECT_REG_ADDR) << BIT_SHIFT_INDIRECT_REG_ADDR)
+#define BIT_GET_INDIRECT_REG_ADDR(x)                                           \
+	(((x) >> BIT_SHIFT_INDIRECT_REG_ADDR) & BIT_MASK_INDIRECT_REG_ADDR)
+
+/* 2 REG_GPIO_PIN_CTRL			(Offset 0x0044) */
+
+#define BIT_SHIFT_GPIO_MOD_7_TO_0 24
+#define BIT_MASK_GPIO_MOD_7_TO_0 0xff
+#define BIT_GPIO_MOD_7_TO_0(x)                                                 \
+	(((x) & BIT_MASK_GPIO_MOD_7_TO_0) << BIT_SHIFT_GPIO_MOD_7_TO_0)
+#define BIT_GET_GPIO_MOD_7_TO_0(x)                                             \
+	(((x) >> BIT_SHIFT_GPIO_MOD_7_TO_0) & BIT_MASK_GPIO_MOD_7_TO_0)
+
+#define BIT_SHIFT_GPIO_IO_SEL_7_TO_0 16
+#define BIT_MASK_GPIO_IO_SEL_7_TO_0 0xff
+#define BIT_GPIO_IO_SEL_7_TO_0(x)                                              \
+	(((x) & BIT_MASK_GPIO_IO_SEL_7_TO_0) << BIT_SHIFT_GPIO_IO_SEL_7_TO_0)
+#define BIT_GET_GPIO_IO_SEL_7_TO_0(x)                                          \
+	(((x) >> BIT_SHIFT_GPIO_IO_SEL_7_TO_0) & BIT_MASK_GPIO_IO_SEL_7_TO_0)
+
+#define BIT_SHIFT_GPIO_OUT_7_TO_0 8
+#define BIT_MASK_GPIO_OUT_7_TO_0 0xff
+#define BIT_GPIO_OUT_7_TO_0(x)                                                 \
+	(((x) & BIT_MASK_GPIO_OUT_7_TO_0) << BIT_SHIFT_GPIO_OUT_7_TO_0)
+#define BIT_GET_GPIO_OUT_7_TO_0(x)                                             \
+	(((x) >> BIT_SHIFT_GPIO_OUT_7_TO_0) & BIT_MASK_GPIO_OUT_7_TO_0)
+
+#define BIT_SHIFT_GPIO_IN_7_TO_0 0
+#define BIT_MASK_GPIO_IN_7_TO_0 0xff
+#define BIT_GPIO_IN_7_TO_0(x)                                                  \
+	(((x) & BIT_MASK_GPIO_IN_7_TO_0) << BIT_SHIFT_GPIO_IN_7_TO_0)
+#define BIT_GET_GPIO_IN_7_TO_0(x)                                              \
+	(((x) >> BIT_SHIFT_GPIO_IN_7_TO_0) & BIT_MASK_GPIO_IN_7_TO_0)
+
+/* 2 REG_SDIO_INDIRECT_REG_DATA		(Offset 0x10250044) */
+
+#define BIT_SHIFT_INDIRECT_REG_DATA 0
+#define BIT_MASK_INDIRECT_REG_DATA 0xffffffffL
+#define BIT_INDIRECT_REG_DATA(x)                                               \
+	(((x) & BIT_MASK_INDIRECT_REG_DATA) << BIT_SHIFT_INDIRECT_REG_DATA)
+#define BIT_GET_INDIRECT_REG_DATA(x)                                           \
+	(((x) >> BIT_SHIFT_INDIRECT_REG_DATA) & BIT_MASK_INDIRECT_REG_DATA)
+
+/* 2 REG_GPIO_INTM				(Offset 0x0048) */
+
+#define BIT_SHIFT_MUXDBG_SEL 30
+#define BIT_MASK_MUXDBG_SEL 0x3
+#define BIT_MUXDBG_SEL(x) (((x) & BIT_MASK_MUXDBG_SEL) << BIT_SHIFT_MUXDBG_SEL)
+#define BIT_GET_MUXDBG_SEL(x)                                                  \
+	(((x) >> BIT_SHIFT_MUXDBG_SEL) & BIT_MASK_MUXDBG_SEL)
+
+/* 2 REG_GPIO_INTM				(Offset 0x0048) */
+
+#define BIT_EXTWOL_SEL BIT(17)
+
+/* 2 REG_GPIO_INTM				(Offset 0x0048) */
+
+#define BIT_EXTWOL_EN BIT(16)
+
+/* 2 REG_GPIO_INTM				(Offset 0x0048) */
+
+#define BIT_GPIOF_INT_MD BIT(15)
+#define BIT_GPIOE_INT_MD BIT(14)
+#define BIT_GPIOD_INT_MD BIT(13)
+#define BIT_GPIOC_INT_MD BIT(12)
+#define BIT_GPIOB_INT_MD BIT(11)
+#define BIT_GPIOA_INT_MD BIT(10)
+#define BIT_GPIO9_INT_MD BIT(9)
+#define BIT_GPIO8_INT_MD BIT(8)
+#define BIT_GPIO7_INT_MD BIT(7)
+#define BIT_GPIO6_INT_MD BIT(6)
+#define BIT_GPIO5_INT_MD BIT(5)
+#define BIT_GPIO4_INT_MD BIT(4)
+#define BIT_GPIO3_INT_MD BIT(3)
+#define BIT_GPIO2_INT_MD BIT(2)
+#define BIT_GPIO1_INT_MD BIT(1)
+#define BIT_GPIO0_INT_MD BIT(0)
+
+/* 2 REG_LED_CFG				(Offset 0x004C) */
+
+#define BIT_GPIO3_WL_CTRL_EN BIT(27)
+
+/* 2 REG_LED_CFG				(Offset 0x004C) */
+
+#define BIT_LNAON_SEL_EN BIT(26)
+
+/* 2 REG_LED_CFG				(Offset 0x004C) */
+
+#define BIT_PAPE_SEL_EN BIT(25)
+
+/* 2 REG_LED_CFG				(Offset 0x004C) */
+
+#define BIT_DPDT_WLBT_SEL BIT(24)
+
+/* 2 REG_LED_CFG				(Offset 0x004C) */
+
+#define BIT_DPDT_SEL_EN BIT(23)
+
+/* 2 REG_LED_CFG				(Offset 0x004C) */
+
+#define BIT_GPIO13_14_WL_CTRL_EN BIT(22)
+
+/* 2 REG_LED_CFG				(Offset 0x004C) */
+
+#define BIT_LED2DIS BIT(21)
+
+/* 2 REG_LED_CFG				(Offset 0x004C) */
+
+#define BIT_LED2PL BIT(20)
+#define BIT_LED2SV BIT(19)
+
+#define BIT_SHIFT_LED2CM 16
+#define BIT_MASK_LED2CM 0x7
+#define BIT_LED2CM(x) (((x) & BIT_MASK_LED2CM) << BIT_SHIFT_LED2CM)
+#define BIT_GET_LED2CM(x) (((x) >> BIT_SHIFT_LED2CM) & BIT_MASK_LED2CM)
+
+#define BIT_LED1DIS BIT(15)
+#define BIT_LED1PL BIT(12)
+#define BIT_LED1SV BIT(11)
+
+#define BIT_SHIFT_LED1CM 8
+#define BIT_MASK_LED1CM 0x7
+#define BIT_LED1CM(x) (((x) & BIT_MASK_LED1CM) << BIT_SHIFT_LED1CM)
+#define BIT_GET_LED1CM(x) (((x) >> BIT_SHIFT_LED1CM) & BIT_MASK_LED1CM)
+
+#define BIT_LED0DIS BIT(7)
+
+/* 2 REG_LED_CFG				(Offset 0x004C) */
+
+#define BIT_SHIFT_AFE_LDO_SWR_CHECK 5
+#define BIT_MASK_AFE_LDO_SWR_CHECK 0x3
+#define BIT_AFE_LDO_SWR_CHECK(x)                                               \
+	(((x) & BIT_MASK_AFE_LDO_SWR_CHECK) << BIT_SHIFT_AFE_LDO_SWR_CHECK)
+#define BIT_GET_AFE_LDO_SWR_CHECK(x)                                           \
+	(((x) >> BIT_SHIFT_AFE_LDO_SWR_CHECK) & BIT_MASK_AFE_LDO_SWR_CHECK)
+
+/* 2 REG_LED_CFG				(Offset 0x004C) */
+
+#define BIT_LED0PL BIT(4)
+#define BIT_LED0SV BIT(3)
+
+#define BIT_SHIFT_LED0CM 0
+#define BIT_MASK_LED0CM 0x7
+#define BIT_LED0CM(x) (((x) & BIT_MASK_LED0CM) << BIT_SHIFT_LED0CM)
+#define BIT_GET_LED0CM(x) (((x) >> BIT_SHIFT_LED0CM) & BIT_MASK_LED0CM)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_PDNINT_EN BIT(31)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_NFC_INT_PAD_EN BIT(30)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_SPS_OCP_INT_EN BIT(29)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_PWMERR_INT_EN BIT(28)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_GPIOF_INT_EN BIT(27)
+#define BIT_FS_GPIOE_INT_EN BIT(26)
+#define BIT_FS_GPIOD_INT_EN BIT(25)
+#define BIT_FS_GPIOC_INT_EN BIT(24)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_GPIOB_INT_EN BIT(23)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_GPIOA_INT_EN BIT(22)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_GPIO9_INT_EN BIT(21)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_GPIO8_INT_EN BIT(20)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_GPIO7_INT_EN BIT(19)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_GPIO6_INT_EN BIT(18)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_GPIO5_INT_EN BIT(17)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_GPIO4_INT_EN BIT(16)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_GPIO3_INT_EN BIT(15)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_GPIO2_INT_EN BIT(14)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_GPIO1_INT_EN BIT(13)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_GPIO0_INT_EN BIT(12)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_HCI_SUS_EN BIT(11)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_HCI_RES_EN BIT(10)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_HCI_RESET_EN BIT(9)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_BTON_STS_UPDATE_MSK_EN BIT(7)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_ACT2RECOVERY_INT_EN_V1 BIT(6)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_GEN1GEN2_SWITCH BIT(5)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_HCI_TXDMA_REQ_HIMR BIT(4)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_32K_LEAVE_SETTING_MAK BIT(3)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_32K_ENTER_SETTING_MAK BIT(2)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_USB_LPMRSM_MSK BIT(1)
+
+/* 2 REG_FSIMR				(Offset 0x0050) */
+
+#define BIT_FS_USB_LPMINT_MSK BIT(0)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_PDNINT BIT(31)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_SPS_OCP_INT BIT(29)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_PWMERR_INT BIT(28)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_GPIOF_INT BIT(27)
+#define BIT_FS_GPIOE_INT BIT(26)
+#define BIT_FS_GPIOD_INT BIT(25)
+#define BIT_FS_GPIOC_INT BIT(24)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_GPIOB_INT BIT(23)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_GPIOA_INT BIT(22)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_GPIO9_INT BIT(21)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_GPIO8_INT BIT(20)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_GPIO7_INT BIT(19)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_GPIO6_INT BIT(18)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_GPIO5_INT BIT(17)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_GPIO4_INT BIT(16)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_GPIO3_INT BIT(15)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_GPIO2_INT BIT(14)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_GPIO1_INT BIT(13)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_GPIO0_INT BIT(12)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_HCI_SUS_INT BIT(11)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_HCI_RES_INT BIT(10)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_HCI_RESET_INT BIT(9)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_ACT2RECOVERY BIT(6)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_HCI_TXDMA_REQ_HISR BIT(4)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_32K_LEAVE_SETTING_INT BIT(3)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_32K_ENTER_SETTING_INT BIT(2)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_USB_LPMRSM_INT BIT(1)
+
+/* 2 REG_FSISR				(Offset 0x0054) */
+
+#define BIT_FS_USB_LPMINT_INT BIT(0)
+
+/* 2 REG_HSIMR				(Offset 0x0058) */
+
+#define BIT_GPIOF_INT_EN BIT(31)
+#define BIT_GPIOE_INT_EN BIT(30)
+#define BIT_GPIOD_INT_EN BIT(29)
+#define BIT_GPIOC_INT_EN BIT(28)
+#define BIT_GPIOB_INT_EN BIT(27)
+#define BIT_GPIOA_INT_EN BIT(26)
+#define BIT_GPIO9_INT_EN BIT(25)
+#define BIT_GPIO8_INT_EN BIT(24)
+#define BIT_GPIO7_INT_EN BIT(23)
+#define BIT_GPIO6_INT_EN BIT(22)
+#define BIT_GPIO5_INT_EN BIT(21)
+#define BIT_GPIO4_INT_EN BIT(20)
+#define BIT_GPIO3_INT_EN BIT(19)
+
+/* 2 REG_HSIMR				(Offset 0x0058) */
+
+#define BIT_GPIO1_INT_EN BIT(17)
+#define BIT_GPIO0_INT_EN BIT(16)
+
+/* 2 REG_HSIMR				(Offset 0x0058) */
+
+#define BIT_GPIO2_INT_EN_V1 BIT(16)
+
+/* 2 REG_HSIMR				(Offset 0x0058) */
+
+#define BIT_PDNINT_EN BIT(7)
+
+/* 2 REG_HSIMR				(Offset 0x0058) */
+
+#define BIT_RON_INT_EN BIT(6)
+
+/* 2 REG_HSIMR				(Offset 0x0058) */
+
+#define BIT_SPS_OCP_INT_EN BIT(5)
+
+/* 2 REG_HSIMR				(Offset 0x0058) */
+
+#define BIT_GPIO15_0_INT_EN BIT(0)
+
+/* 2 REG_HSISR				(Offset 0x005C) */
+
+#define BIT_GPIOF_INT BIT(31)
+#define BIT_GPIOE_INT BIT(30)
+#define BIT_GPIOD_INT BIT(29)
+#define BIT_GPIOC_INT BIT(28)
+#define BIT_GPIOB_INT BIT(27)
+#define BIT_GPIOA_INT BIT(26)
+#define BIT_GPIO9_INT BIT(25)
+#define BIT_GPIO8_INT BIT(24)
+#define BIT_GPIO7_INT BIT(23)
+
+/* 2 REG_HSISR				(Offset 0x005C) */
+
+#define BIT_GPIO6_INT BIT(22)
+#define BIT_GPIO5_INT BIT(21)
+#define BIT_GPIO4_INT BIT(20)
+#define BIT_GPIO3_INT BIT(19)
+
+/* 2 REG_HSISR				(Offset 0x005C) */
+
+#define BIT_GPIO1_INT BIT(17)
+#define BIT_GPIO0_INT BIT(16)
+
+/* 2 REG_HSISR				(Offset 0x005C) */
+
+#define BIT_GPIO2_INT_V1 BIT(16)
+
+/* 2 REG_HSISR				(Offset 0x005C) */
+
+#define BIT_PDNINT BIT(7)
+
+/* 2 REG_HSISR				(Offset 0x005C) */
+
+#define BIT_RON_INT BIT(6)
+
+/* 2 REG_HSISR				(Offset 0x005C) */
+
+#define BIT_SPS_OCP_INT BIT(5)
+
+/* 2 REG_HSISR				(Offset 0x005C) */
+
+#define BIT_GPIO15_0_INT BIT(0)
+#define BIT_MCUFWDL_EN BIT(0)
+
+/* 2 REG_GPIO_EXT_CTRL			(Offset 0x0060) */
+
+#define BIT_SHIFT_GPIO_MOD_15_TO_8 24
+#define BIT_MASK_GPIO_MOD_15_TO_8 0xff
+#define BIT_GPIO_MOD_15_TO_8(x)                                                \
+	(((x) & BIT_MASK_GPIO_MOD_15_TO_8) << BIT_SHIFT_GPIO_MOD_15_TO_8)
+#define BIT_GET_GPIO_MOD_15_TO_8(x)                                            \
+	(((x) >> BIT_SHIFT_GPIO_MOD_15_TO_8) & BIT_MASK_GPIO_MOD_15_TO_8)
+
+#define BIT_SHIFT_GPIO_IO_SEL_15_TO_8 16
+#define BIT_MASK_GPIO_IO_SEL_15_TO_8 0xff
+#define BIT_GPIO_IO_SEL_15_TO_8(x)                                             \
+	(((x) & BIT_MASK_GPIO_IO_SEL_15_TO_8) << BIT_SHIFT_GPIO_IO_SEL_15_TO_8)
+#define BIT_GET_GPIO_IO_SEL_15_TO_8(x)                                         \
+	(((x) >> BIT_SHIFT_GPIO_IO_SEL_15_TO_8) & BIT_MASK_GPIO_IO_SEL_15_TO_8)
+
+#define BIT_SHIFT_GPIO_OUT_15_TO_8 8
+#define BIT_MASK_GPIO_OUT_15_TO_8 0xff
+#define BIT_GPIO_OUT_15_TO_8(x)                                                \
+	(((x) & BIT_MASK_GPIO_OUT_15_TO_8) << BIT_SHIFT_GPIO_OUT_15_TO_8)
+#define BIT_GET_GPIO_OUT_15_TO_8(x)                                            \
+	(((x) >> BIT_SHIFT_GPIO_OUT_15_TO_8) & BIT_MASK_GPIO_OUT_15_TO_8)
+
+#define BIT_SHIFT_GPIO_IN_15_TO_8 0
+#define BIT_MASK_GPIO_IN_15_TO_8 0xff
+#define BIT_GPIO_IN_15_TO_8(x)                                                 \
+	(((x) & BIT_MASK_GPIO_IN_15_TO_8) << BIT_SHIFT_GPIO_IN_15_TO_8)
+#define BIT_GET_GPIO_IN_15_TO_8(x)                                             \
+	(((x) >> BIT_SHIFT_GPIO_IN_15_TO_8) & BIT_MASK_GPIO_IN_15_TO_8)
+
+/* 2 REG_SDIO_H2C				(Offset 0x10250060) */
+
+#define BIT_SHIFT_SDIO_H2C_MSG 0
+#define BIT_MASK_SDIO_H2C_MSG 0xffffffffL
+#define BIT_SDIO_H2C_MSG(x)                                                    \
+	(((x) & BIT_MASK_SDIO_H2C_MSG) << BIT_SHIFT_SDIO_H2C_MSG)
+#define BIT_GET_SDIO_H2C_MSG(x)                                                \
+	(((x) >> BIT_SHIFT_SDIO_H2C_MSG) & BIT_MASK_SDIO_H2C_MSG)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_PAPE_WLBT_SEL BIT(29)
+#define BIT_LNAON_WLBT_SEL BIT(28)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_BTGP_GPG3_FEN BIT(26)
+#define BIT_BTGP_GPG2_FEN BIT(25)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_BTGP_JTAG_EN BIT(24)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_XTAL_CLK_EXTARNAL_EN BIT(23)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_BTGP_UART0_EN BIT(22)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_BTGP_UART1_EN BIT(21)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_BTGP_SPI_EN BIT(20)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_BTGP_GPIO_E2 BIT(19)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_BTGP_GPIO_EN BIT(18)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_SHIFT_BTGP_GPIO_SL 16
+#define BIT_MASK_BTGP_GPIO_SL 0x3
+#define BIT_BTGP_GPIO_SL(x)                                                    \
+	(((x) & BIT_MASK_BTGP_GPIO_SL) << BIT_SHIFT_BTGP_GPIO_SL)
+#define BIT_GET_BTGP_GPIO_SL(x)                                                \
+	(((x) >> BIT_SHIFT_BTGP_GPIO_SL) & BIT_MASK_BTGP_GPIO_SL)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_PAD_SDIO_SR BIT(14)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_GPIO14_OUTPUT_PL BIT(13)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_HOST_WAKE_PAD_PULL_EN BIT(12)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_HOST_WAKE_PAD_SL BIT(11)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_PAD_LNAON_SR BIT(10)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_PAD_LNAON_E2 BIT(9)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_SW_LNAON_G_SEL_DATA BIT(8)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_SW_LNAON_A_SEL_DATA BIT(7)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_PAD_PAPE_SR BIT(6)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_PAD_PAPE_E2 BIT(5)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_SW_PAPE_G_SEL_DATA BIT(4)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_SW_PAPE_A_SEL_DATA BIT(3)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_PAD_DPDT_SR BIT(2)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_PAD_DPDT_PAD_E2 BIT(1)
+
+/* 2 REG_PAD_CTRL1				(Offset 0x0064) */
+
+#define BIT_SW_DPDT_SEL_DATA BIT(0)
+
+/* 2 REG_SDIO_C2H				(Offset 0x10250064) */
+
+#define BIT_SHIFT_SDIO_C2H_MSG 0
+#define BIT_MASK_SDIO_C2H_MSG 0xffffffffL
+#define BIT_SDIO_C2H_MSG(x)                                                    \
+	(((x) & BIT_MASK_SDIO_C2H_MSG) << BIT_SHIFT_SDIO_C2H_MSG)
+#define BIT_GET_SDIO_C2H_MSG(x)                                                \
+	(((x) >> BIT_SHIFT_SDIO_C2H_MSG) & BIT_MASK_SDIO_C2H_MSG)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_ISO_BD2PP BIT(31)
+#define BIT_LDOV12B_EN BIT(30)
+#define BIT_CKEN_BTGPS BIT(29)
+#define BIT_FEN_BTGPS BIT(28)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_MULRW BIT(27)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_BTCPU_BOOTSEL BIT(27)
+#define BIT_SPI_SPEEDUP BIT(26)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_DEVWAKE_PAD_TYPE_SEL BIT(24)
+#define BIT_CLKREQ_PAD_TYPE_SEL BIT(23)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_EN_CPL_TIMEOUT_PS BIT(22)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_ISO_BTPON2PP BIT(22)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_REG_TXDMA_FAIL_PS BIT(21)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_EN_HWENTR_L1 BIT(19)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_BT_HWROF_EN BIT(19)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_EN_ADV_CLKGATE BIT(18)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_BT_FUNC_EN BIT(18)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_BT_HWPDN_SL BIT(17)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_BT_DISN_EN BIT(16)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_BT_PDN_PULL_EN BIT(15)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_WL_PDN_PULL_EN BIT(14)
+#define BIT_EXTERNAL_REQUEST_PL BIT(13)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_GPIO0_2_3_PULL_LOW_EN BIT(12)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_ISO_BA2PP BIT(11)
+#define BIT_BT_AFE_LDO_EN BIT(10)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_BT_AFE_PLL_EN BIT(9)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_BT_DIG_CLK_EN BIT(8)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_WL_DRV_EXIST_IDX BIT(5)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_DOP_EHPAD BIT(4)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_WL_HWROF_EN BIT(3)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_WL_FUNC_EN BIT(2)
+
+/* 2 REG_WL_BT_PWR_CTRL			(Offset 0x0068) */
+
+#define BIT_WL_HWPDN_SL BIT(1)
+#define BIT_WL_HWPDN_EN BIT(0)
+
+/* 2 REG_SDM_DEBUG				(Offset 0x006C) */
+
+#define BIT_SHIFT_WLCLK_PHASE 0
+#define BIT_MASK_WLCLK_PHASE 0x1f
+#define BIT_WLCLK_PHASE(x)                                                     \
+	(((x) & BIT_MASK_WLCLK_PHASE) << BIT_SHIFT_WLCLK_PHASE)
+#define BIT_GET_WLCLK_PHASE(x)                                                 \
+	(((x) >> BIT_SHIFT_WLCLK_PHASE) & BIT_MASK_WLCLK_PHASE)
+
+/* 2 REG_SYS_SDIO_CTRL			(Offset 0x0070) */
+
+#define BIT_DBG_GNT_WL_BT BIT(27)
+
+/* 2 REG_SYS_SDIO_CTRL			(Offset 0x0070) */
+
+#define BIT_LTE_MUX_CTRL_PATH BIT(26)
+
+/* 2 REG_SYS_SDIO_CTRL			(Offset 0x0070) */
+
+#define BIT_LTE_COEX_UART BIT(25)
+
+/* 2 REG_SYS_SDIO_CTRL			(Offset 0x0070) */
+
+#define BIT_3W_LTE_WL_GPIO BIT(24)
+
+/* 2 REG_SYS_SDIO_CTRL			(Offset 0x0070) */
+
+#define BIT_SDIO_INT_POLARITY BIT(19)
+#define BIT_SDIO_INT BIT(18)
+
+/* 2 REG_SYS_SDIO_CTRL			(Offset 0x0070) */
+
+#define BIT_SDIO_OFF_EN BIT(17)
+
+/* 2 REG_SYS_SDIO_CTRL			(Offset 0x0070) */
+
+#define BIT_SDIO_ON_EN BIT(16)
+
+/* 2 REG_SYS_SDIO_CTRL			(Offset 0x0070) */
+
+#define BIT_PCIE_WAIT_TIMEOUT_EVENT BIT(10)
+#define BIT_PCIE_WAIT_TIME BIT(9)
+
+/* 2 REG_SYS_SDIO_CTRL			(Offset 0x0070) */
+
+#define BIT_MPCIE_REFCLK_XTAL_SEL BIT(8)
+
+/* 2 REG_HCI_OPT_CTRL			(Offset 0x0074) */
+
+#define BIT_SHIFT_TSFT_SEL 29
+#define BIT_MASK_TSFT_SEL 0x7
+#define BIT_TSFT_SEL(x) (((x) & BIT_MASK_TSFT_SEL) << BIT_SHIFT_TSFT_SEL)
+#define BIT_GET_TSFT_SEL(x) (((x) >> BIT_SHIFT_TSFT_SEL) & BIT_MASK_TSFT_SEL)
+
+/* 2 REG_HCI_OPT_CTRL			(Offset 0x0074) */
+
+#define BIT_SHIFT_RPWM 24
+#define BIT_MASK_RPWM 0xff
+#define BIT_RPWM(x) (((x) & BIT_MASK_RPWM) << BIT_SHIFT_RPWM)
+#define BIT_GET_RPWM(x) (((x) >> BIT_SHIFT_RPWM) & BIT_MASK_RPWM)
+
+#define BIT_ROM_DLEN BIT(19)
+
+#define BIT_SHIFT_ROM_PGE 16
+#define BIT_MASK_ROM_PGE 0x7
+#define BIT_ROM_PGE(x) (((x) & BIT_MASK_ROM_PGE) << BIT_SHIFT_ROM_PGE)
+#define BIT_GET_ROM_PGE(x) (((x) >> BIT_SHIFT_ROM_PGE) & BIT_MASK_ROM_PGE)
+
+/* 2 REG_HCI_OPT_CTRL			(Offset 0x0074) */
+
+#define BIT_USB_HOST_PWR_OFF_EN BIT(12)
+
+/* 2 REG_HCI_OPT_CTRL			(Offset 0x0074) */
+
+#define BIT_SYM_LPS_BLOCK_EN BIT(11)
+
+/* 2 REG_HCI_OPT_CTRL			(Offset 0x0074) */
+
+#define BIT_USB_LPM_ACT_EN BIT(10)
+
+/* 2 REG_HCI_OPT_CTRL			(Offset 0x0074) */
+
+#define BIT_USB_LPM_NY BIT(9)
+
+/* 2 REG_HCI_OPT_CTRL			(Offset 0x0074) */
+
+#define BIT_USB_SUS_DIS BIT(8)
+
+/* 2 REG_HCI_OPT_CTRL			(Offset 0x0074) */
+
+#define BIT_SHIFT_SDIO_PAD_E 5
+#define BIT_MASK_SDIO_PAD_E 0x7
+#define BIT_SDIO_PAD_E(x) (((x) & BIT_MASK_SDIO_PAD_E) << BIT_SHIFT_SDIO_PAD_E)
+#define BIT_GET_SDIO_PAD_E(x)                                                  \
+	(((x) >> BIT_SHIFT_SDIO_PAD_E) & BIT_MASK_SDIO_PAD_E)
+
+/* 2 REG_HCI_OPT_CTRL			(Offset 0x0074) */
+
+#define BIT_USB_LPPLL_EN BIT(4)
+
+/* 2 REG_HCI_OPT_CTRL			(Offset 0x0074) */
+
+#define BIT_ROP_SW15 BIT(2)
+
+/* 2 REG_HCI_OPT_CTRL			(Offset 0x0074) */
+
+#define BIT_PCI_CKRDY_OPT BIT(1)
+
+/* 2 REG_HCI_OPT_CTRL			(Offset 0x0074) */
+
+#define BIT_PCI_VAUX_EN BIT(0)
+
+/* 2 REG_LDO_SWR_CTRL			(Offset 0x007C) */
+
+#define BIT_ZCD_HW_AUTO_EN BIT(27)
+#define BIT_ZCD_REGSEL BIT(26)
+
+/* 2 REG_LDO_SWR_CTRL			(Offset 0x007C) */
+
+#define BIT_SHIFT_AUTO_ZCD_IN_CODE 21
+#define BIT_MASK_AUTO_ZCD_IN_CODE 0x1f
+#define BIT_AUTO_ZCD_IN_CODE(x)                                                \
+	(((x) & BIT_MASK_AUTO_ZCD_IN_CODE) << BIT_SHIFT_AUTO_ZCD_IN_CODE)
+#define BIT_GET_AUTO_ZCD_IN_CODE(x)                                            \
+	(((x) >> BIT_SHIFT_AUTO_ZCD_IN_CODE) & BIT_MASK_AUTO_ZCD_IN_CODE)
+
+/* 2 REG_LDO_SWR_CTRL			(Offset 0x007C) */
+
+#define BIT_SHIFT_ZCD_CODE_IN_L 16
+#define BIT_MASK_ZCD_CODE_IN_L 0x1f
+#define BIT_ZCD_CODE_IN_L(x)                                                   \
+	(((x) & BIT_MASK_ZCD_CODE_IN_L) << BIT_SHIFT_ZCD_CODE_IN_L)
+#define BIT_GET_ZCD_CODE_IN_L(x)                                               \
+	(((x) >> BIT_SHIFT_ZCD_CODE_IN_L) & BIT_MASK_ZCD_CODE_IN_L)
+
+/* 2 REG_LDO_SWR_CTRL			(Offset 0x007C) */
+
+#define BIT_SHIFT_LDO_HV5_DUMMY 14
+#define BIT_MASK_LDO_HV5_DUMMY 0x3
+#define BIT_LDO_HV5_DUMMY(x)                                                   \
+	(((x) & BIT_MASK_LDO_HV5_DUMMY) << BIT_SHIFT_LDO_HV5_DUMMY)
+#define BIT_GET_LDO_HV5_DUMMY(x)                                               \
+	(((x) >> BIT_SHIFT_LDO_HV5_DUMMY) & BIT_MASK_LDO_HV5_DUMMY)
+
+/* 2 REG_LDO_SWR_CTRL			(Offset 0x007C) */
+
+#define BIT_SHIFT_REG_VTUNE33_BIT0_TO_BIT1 12
+#define BIT_MASK_REG_VTUNE33_BIT0_TO_BIT1 0x3
+#define BIT_REG_VTUNE33_BIT0_TO_BIT1(x)                                        \
+	(((x) & BIT_MASK_REG_VTUNE33_BIT0_TO_BIT1)                             \
+	 << BIT_SHIFT_REG_VTUNE33_BIT0_TO_BIT1)
+#define BIT_GET_REG_VTUNE33_BIT0_TO_BIT1(x)                                    \
+	(((x) >> BIT_SHIFT_REG_VTUNE33_BIT0_TO_BIT1) &                         \
+	 BIT_MASK_REG_VTUNE33_BIT0_TO_BIT1)
+
+/* 2 REG_LDO_SWR_CTRL			(Offset 0x007C) */
+
+#define BIT_SHIFT_REG_STANDBY33_BIT0_TO_BIT1 10
+#define BIT_MASK_REG_STANDBY33_BIT0_TO_BIT1 0x3
+#define BIT_REG_STANDBY33_BIT0_TO_BIT1(x)                                      \
+	(((x) & BIT_MASK_REG_STANDBY33_BIT0_TO_BIT1)                           \
+	 << BIT_SHIFT_REG_STANDBY33_BIT0_TO_BIT1)
+#define BIT_GET_REG_STANDBY33_BIT0_TO_BIT1(x)                                  \
+	(((x) >> BIT_SHIFT_REG_STANDBY33_BIT0_TO_BIT1) &                       \
+	 BIT_MASK_REG_STANDBY33_BIT0_TO_BIT1)
+
+/* 2 REG_LDO_SWR_CTRL			(Offset 0x007C) */
+
+#define BIT_SHIFT_REG_LOAD33_BIT0_TO_BIT1 8
+#define BIT_MASK_REG_LOAD33_BIT0_TO_BIT1 0x3
+#define BIT_REG_LOAD33_BIT0_TO_BIT1(x)                                         \
+	(((x) & BIT_MASK_REG_LOAD33_BIT0_TO_BIT1)                              \
+	 << BIT_SHIFT_REG_LOAD33_BIT0_TO_BIT1)
+#define BIT_GET_REG_LOAD33_BIT0_TO_BIT1(x)                                     \
+	(((x) >> BIT_SHIFT_REG_LOAD33_BIT0_TO_BIT1) &                          \
+	 BIT_MASK_REG_LOAD33_BIT0_TO_BIT1)
+
+/* 2 REG_LDO_SWR_CTRL			(Offset 0x007C) */
+
+#define BIT_REG_BYPASS_L BIT(7)
+
+/* 2 REG_LDO_SWR_CTRL			(Offset 0x007C) */
+
+#define BIT_REG_LDOF_L BIT(6)
+
+/* 2 REG_LDO_SWR_CTRL			(Offset 0x007C) */
+
+#define BIT_REG_TYPE_L_V1 BIT(5)
+
+/* 2 REG_LDO_SWR_CTRL			(Offset 0x007C) */
+
+#define BIT_ARENB_L BIT(3)
+
+/* 2 REG_LDO_SWR_CTRL			(Offset 0x007C) */
+
+#define BIT_SHIFT_CFC_L 1
+#define BIT_MASK_CFC_L 0x3
+#define BIT_CFC_L(x) (((x) & BIT_MASK_CFC_L) << BIT_SHIFT_CFC_L)
+#define BIT_GET_CFC_L(x) (((x) >> BIT_SHIFT_CFC_L) & BIT_MASK_CFC_L)
+
+/* 2 REG_LDO_SWR_CTRL			(Offset 0x007C) */
+
+#define BIT_REG_OCPS_L_V1 BIT(0)
+
+/* 2 REG_MCUFW_CTRL				(Offset 0x0080) */
+
+#define BIT_ANA_PORT_EN BIT(22)
+#define BIT_MAC_PORT_EN BIT(21)
+#define BIT_BOOT_FSPI_EN BIT(20)
+#define BIT_FW_INIT_RDY BIT(15)
+#define BIT_FW_DW_RDY BIT(14)
+
+/* 2 REG_MCUFW_CTRL				(Offset 0x0080) */
+
+#define BIT_SHIFT_CPU_CLK_SEL 12
+#define BIT_MASK_CPU_CLK_SEL 0x3
+#define BIT_CPU_CLK_SEL(x)                                                     \
+	(((x) & BIT_MASK_CPU_CLK_SEL) << BIT_SHIFT_CPU_CLK_SEL)
+#define BIT_GET_CPU_CLK_SEL(x)                                                 \
+	(((x) >> BIT_SHIFT_CPU_CLK_SEL) & BIT_MASK_CPU_CLK_SEL)
+
+/* 2 REG_MCUFW_CTRL				(Offset 0x0080) */
+
+#define BIT_CCLK_CHG_MASK BIT(11)
+
+/* 2 REG_MCUFW_CTRL				(Offset 0x0080) */
+
+#define BIT_EMEM__TXBUF_CHKSUM_OK BIT(10)
+
+/* 2 REG_MCUFW_CTRL				(Offset 0x0080) */
+
+#define BIT_EMEM_TXBUF_DW_RDY BIT(9)
+
+/* 2 REG_MCUFW_CTRL				(Offset 0x0080) */
+
+#define BIT_EMEM_CHKSUM_OK BIT(8)
+#define BIT_EMEM_DW_OK BIT(7)
+#define BIT_TOGGLING BIT(7)
+#define BIT_DMEM_CHKSUM_OK BIT(6)
+#define BIT_ACK BIT(6)
+
+/* 2 REG_MCUFW_CTRL				(Offset 0x0080) */
+
+#define BIT_DMEM_DW_OK BIT(5)
+
+/* 2 REG_MCUFW_CTRL				(Offset 0x0080) */
+
+#define BIT_IMEM_CHKSUM_OK BIT(4)
+
+/* 2 REG_MCUFW_CTRL				(Offset 0x0080) */
+
+#define BIT_IMEM_DW_OK BIT(3)
+
+/* 2 REG_MCUFW_CTRL				(Offset 0x0080) */
+
+#define BIT_IMEM_BOOT_LOAD_CHKSUM_OK BIT(2)
+
+/* 2 REG_MCUFW_CTRL				(Offset 0x0080) */
+
+#define BIT_IMEM_BOOT_LOAD_DW_OK BIT(1)
+
+/* 2 REG_SDIO_HRPWM1				(Offset 0x10250080) */
+
+#define BIT_32K_PERMISSION BIT(0)
+
+/* 2 REG_MCU_TST_CFG				(Offset 0x0084) */
+
+#define BIT_SHIFT_LBKTST 0
+#define BIT_MASK_LBKTST 0xffff
+#define BIT_LBKTST(x) (((x) & BIT_MASK_LBKTST) << BIT_SHIFT_LBKTST)
+#define BIT_GET_LBKTST(x) (((x) >> BIT_SHIFT_LBKTST) & BIT_MASK_LBKTST)
+
+/* 2 REG_SDIO_BUS_CTRL			(Offset 0x10250085) */
+
+#define BIT_PAD_CLK_XHGE_EN BIT(3)
+#define BIT_INTER_CLK_EN BIT(2)
+#define BIT_EN_RPT_TXCRC BIT(1)
+#define BIT_DIS_RXDMA_STS BIT(0)
+
+/* 2 REG_SDIO_HSUS_CTRL			(Offset 0x10250086) */
+
+#define BIT_INTR_CTRL BIT(4)
+#define BIT_SDIO_VOLTAGE BIT(3)
+#define BIT_BYPASS_INIT BIT(2)
+
+/* 2 REG_SDIO_HSUS_CTRL			(Offset 0x10250086) */
+
+#define BIT_HCI_RESUME_RDY BIT(1)
+#define BIT_HCI_SUS_REQ BIT(0)
+
+/* 2 REG_HMEBOX_E0_E1			(Offset 0x0088) */
+
+#define BIT_SHIFT_HOST_MSG_E1 16
+#define BIT_MASK_HOST_MSG_E1 0xffff
+#define BIT_HOST_MSG_E1(x)                                                     \
+	(((x) & BIT_MASK_HOST_MSG_E1) << BIT_SHIFT_HOST_MSG_E1)
+#define BIT_GET_HOST_MSG_E1(x)                                                 \
+	(((x) >> BIT_SHIFT_HOST_MSG_E1) & BIT_MASK_HOST_MSG_E1)
+
+#define BIT_SHIFT_HOST_MSG_E0 0
+#define BIT_MASK_HOST_MSG_E0 0xffff
+#define BIT_HOST_MSG_E0(x)                                                     \
+	(((x) & BIT_MASK_HOST_MSG_E0) << BIT_SHIFT_HOST_MSG_E0)
+#define BIT_GET_HOST_MSG_E0(x)                                                 \
+	(((x) >> BIT_SHIFT_HOST_MSG_E0) & BIT_MASK_HOST_MSG_E0)
+
+/* 2 REG_SDIO_RESPONSE_TIMER			(Offset 0x10250088) */
+
+#define BIT_SHIFT_CMDIN_2RESP_TIMER 0
+#define BIT_MASK_CMDIN_2RESP_TIMER 0xffff
+#define BIT_CMDIN_2RESP_TIMER(x)                                               \
+	(((x) & BIT_MASK_CMDIN_2RESP_TIMER) << BIT_SHIFT_CMDIN_2RESP_TIMER)
+#define BIT_GET_CMDIN_2RESP_TIMER(x)                                           \
+	(((x) >> BIT_SHIFT_CMDIN_2RESP_TIMER) & BIT_MASK_CMDIN_2RESP_TIMER)
+
+/* 2 REG_SDIO_CMD_CRC			(Offset 0x1025008A) */
+
+#define BIT_SHIFT_SDIO_CMD_CRC_V1 0
+#define BIT_MASK_SDIO_CMD_CRC_V1 0xff
+#define BIT_SDIO_CMD_CRC_V1(x)                                                 \
+	(((x) & BIT_MASK_SDIO_CMD_CRC_V1) << BIT_SHIFT_SDIO_CMD_CRC_V1)
+#define BIT_GET_SDIO_CMD_CRC_V1(x)                                             \
+	(((x) >> BIT_SHIFT_SDIO_CMD_CRC_V1) & BIT_MASK_SDIO_CMD_CRC_V1)
+
+/* 2 REG_HMEBOX_E2_E3			(Offset 0x008C) */
+
+#define BIT_SHIFT_HOST_MSG_E3 16
+#define BIT_MASK_HOST_MSG_E3 0xffff
+#define BIT_HOST_MSG_E3(x)                                                     \
+	(((x) & BIT_MASK_HOST_MSG_E3) << BIT_SHIFT_HOST_MSG_E3)
+#define BIT_GET_HOST_MSG_E3(x)                                                 \
+	(((x) >> BIT_SHIFT_HOST_MSG_E3) & BIT_MASK_HOST_MSG_E3)
+
+#define BIT_SHIFT_HOST_MSG_E2 0
+#define BIT_MASK_HOST_MSG_E2 0xffff
+#define BIT_HOST_MSG_E2(x)                                                     \
+	(((x) & BIT_MASK_HOST_MSG_E2) << BIT_SHIFT_HOST_MSG_E2)
+#define BIT_GET_HOST_MSG_E2(x)                                                 \
+	(((x) >> BIT_SHIFT_HOST_MSG_E2) & BIT_MASK_HOST_MSG_E2)
+
+/* 2 REG_WLLPS_CTRL				(Offset 0x0090) */
+
+#define BIT_WLLPSOP_EABM BIT(31)
+
+/* 2 REG_WLLPS_CTRL				(Offset 0x0090) */
+
+#define BIT_WLLPSOP_ACKF BIT(30)
+
+/* 2 REG_WLLPS_CTRL				(Offset 0x0090) */
+
+#define BIT_WLLPSOP_DLDM BIT(29)
+
+/* 2 REG_WLLPS_CTRL				(Offset 0x0090) */
+
+#define BIT_WLLPSOP_ESWR BIT(28)
+
+/* 2 REG_WLLPS_CTRL				(Offset 0x0090) */
+
+#define BIT_WLLPSOP_PWMM BIT(27)
+#define BIT_WLLPSOP_EECK BIT(26)
+
+/* 2 REG_WLLPS_CTRL				(Offset 0x0090) */
+
+#define BIT_WLLPSOP_WLMACOFF BIT(25)
+
+/* 2 REG_WLLPS_CTRL				(Offset 0x0090) */
+
+#define BIT_WLLPSOP_EXTAL BIT(24)
+
+/* 2 REG_WLLPS_CTRL				(Offset 0x0090) */
+
+#define BIT_WL_SYNPON_VOLTSPDN BIT(23)
+
+/* 2 REG_WLLPS_CTRL				(Offset 0x0090) */
+
+#define BIT_WLLPSOP_WLBBOFF BIT(22)
+
+/* 2 REG_WLLPS_CTRL				(Offset 0x0090) */
+
+#define BIT_WLLPSOP_WLMEM_DS BIT(21)
+
+/* 2 REG_WLLPS_CTRL				(Offset 0x0090) */
+
+#define BIT_SHIFT_LPLDH12_VADJ_STEP_DN 12
+#define BIT_MASK_LPLDH12_VADJ_STEP_DN 0xf
+#define BIT_LPLDH12_VADJ_STEP_DN(x)                                            \
+	(((x) & BIT_MASK_LPLDH12_VADJ_STEP_DN)                                 \
+	 << BIT_SHIFT_LPLDH12_VADJ_STEP_DN)
+#define BIT_GET_LPLDH12_VADJ_STEP_DN(x)                                        \
+	(((x) >> BIT_SHIFT_LPLDH12_VADJ_STEP_DN) &                             \
+	 BIT_MASK_LPLDH12_VADJ_STEP_DN)
+
+/* 2 REG_WLLPS_CTRL				(Offset 0x0090) */
+
+#define BIT_SHIFT_V15ADJ_L1_STEP_DN 8
+#define BIT_MASK_V15ADJ_L1_STEP_DN 0x7
+#define BIT_V15ADJ_L1_STEP_DN(x)                                               \
+	(((x) & BIT_MASK_V15ADJ_L1_STEP_DN) << BIT_SHIFT_V15ADJ_L1_STEP_DN)
+#define BIT_GET_V15ADJ_L1_STEP_DN(x)                                           \
+	(((x) >> BIT_SHIFT_V15ADJ_L1_STEP_DN) & BIT_MASK_V15ADJ_L1_STEP_DN)
+
+#define BIT_REGU_32K_CLK_EN BIT(1)
+#define BIT_DRV_WLAN_INT_CLR BIT(1)
+
+/* 2 REG_WLLPS_CTRL				(Offset 0x0090) */
+
+#define BIT_WL_LPS_EN BIT(0)
+
+/* 2 REG_SDIO_HSISR				(Offset 0x10250090) */
+
+#define BIT_DRV_WLAN_INT BIT(0)
+
+/* 2 REG_SDIO_HSIMR				(Offset 0x10250091) */
+
+#define BIT_HISR_MASK BIT(0)
+
+/* 2 REG_AFE_CTRL5				(Offset 0x0094) */
+
+#define BIT_BB_DBG_SEL_AFE_SDM_BIT0 BIT(31)
+
+/* 2 REG_AFE_CTRL5				(Offset 0x0094) */
+
+#define BIT_ORDER_SDM BIT(30)
+#define BIT_RFE_SEL_SDM BIT(29)
+
+#define BIT_SHIFT_REF_SEL 25
+#define BIT_MASK_REF_SEL 0xf
+#define BIT_REF_SEL(x) (((x) & BIT_MASK_REF_SEL) << BIT_SHIFT_REF_SEL)
+#define BIT_GET_REF_SEL(x) (((x) >> BIT_SHIFT_REF_SEL) & BIT_MASK_REF_SEL)
+
+/* 2 REG_AFE_CTRL5				(Offset 0x0094) */
+
+#define BIT_SHIFT_F0F_SDM 12
+#define BIT_MASK_F0F_SDM 0x1fff
+#define BIT_F0F_SDM(x) (((x) & BIT_MASK_F0F_SDM) << BIT_SHIFT_F0F_SDM)
+#define BIT_GET_F0F_SDM(x) (((x) >> BIT_SHIFT_F0F_SDM) & BIT_MASK_F0F_SDM)
+
+/* 2 REG_AFE_CTRL5				(Offset 0x0094) */
+
+#define BIT_SHIFT_F0N_SDM 9
+#define BIT_MASK_F0N_SDM 0x7
+#define BIT_F0N_SDM(x) (((x) & BIT_MASK_F0N_SDM) << BIT_SHIFT_F0N_SDM)
+#define BIT_GET_F0N_SDM(x) (((x) >> BIT_SHIFT_F0N_SDM) & BIT_MASK_F0N_SDM)
+
+/* 2 REG_AFE_CTRL5				(Offset 0x0094) */
+
+#define BIT_SHIFT_DIVN_SDM 3
+#define BIT_MASK_DIVN_SDM 0x3f
+#define BIT_DIVN_SDM(x) (((x) & BIT_MASK_DIVN_SDM) << BIT_SHIFT_DIVN_SDM)
+#define BIT_GET_DIVN_SDM(x) (((x) >> BIT_SHIFT_DIVN_SDM) & BIT_MASK_DIVN_SDM)
+
+/* 2 REG_GPIO_DEBOUNCE_CTRL			(Offset 0x0098) */
+
+#define BIT_WLGP_DBC1EN BIT(15)
+
+#define BIT_SHIFT_WLGP_DBC1 8
+#define BIT_MASK_WLGP_DBC1 0xf
+#define BIT_WLGP_DBC1(x) (((x) & BIT_MASK_WLGP_DBC1) << BIT_SHIFT_WLGP_DBC1)
+#define BIT_GET_WLGP_DBC1(x) (((x) >> BIT_SHIFT_WLGP_DBC1) & BIT_MASK_WLGP_DBC1)
+
+#define BIT_WLGP_DBC0EN BIT(7)
+
+#define BIT_SHIFT_WLGP_DBC0 0
+#define BIT_MASK_WLGP_DBC0 0xf
+#define BIT_WLGP_DBC0(x) (((x) & BIT_MASK_WLGP_DBC0) << BIT_SHIFT_WLGP_DBC0)
+#define BIT_GET_WLGP_DBC0(x) (((x) >> BIT_SHIFT_WLGP_DBC0) & BIT_MASK_WLGP_DBC0)
+
+/* 2 REG_RPWM2				(Offset 0x009C) */
+
+#define BIT_SHIFT_RPWM2 16
+#define BIT_MASK_RPWM2 0xffff
+#define BIT_RPWM2(x) (((x) & BIT_MASK_RPWM2) << BIT_SHIFT_RPWM2)
+#define BIT_GET_RPWM2(x) (((x) >> BIT_SHIFT_RPWM2) & BIT_MASK_RPWM2)
+
+/* 2 REG_SYSON_FSM_MON			(Offset 0x00A0) */
+
+#define BIT_SHIFT_FSM_MON_SEL 24
+#define BIT_MASK_FSM_MON_SEL 0x7
+#define BIT_FSM_MON_SEL(x)                                                     \
+	(((x) & BIT_MASK_FSM_MON_SEL) << BIT_SHIFT_FSM_MON_SEL)
+#define BIT_GET_FSM_MON_SEL(x)                                                 \
+	(((x) >> BIT_SHIFT_FSM_MON_SEL) & BIT_MASK_FSM_MON_SEL)
+
+#define BIT_DOP_ELDO BIT(23)
+#define BIT_FSM_MON_UPD BIT(15)
+
+#define BIT_SHIFT_FSM_PAR 0
+#define BIT_MASK_FSM_PAR 0x7fff
+#define BIT_FSM_PAR(x) (((x) & BIT_MASK_FSM_PAR) << BIT_SHIFT_FSM_PAR)
+#define BIT_GET_FSM_PAR(x) (((x) >> BIT_SHIFT_FSM_PAR) & BIT_MASK_FSM_PAR)
+
+/* 2 REG_AFE_CTRL6				(Offset 0x00A4) */
+
+#define BIT_SHIFT_BB_DBG_SEL_AFE_SDM_BIT3_1 0
+#define BIT_MASK_BB_DBG_SEL_AFE_SDM_BIT3_1 0x7
+#define BIT_BB_DBG_SEL_AFE_SDM_BIT3_1(x)                                       \
+	(((x) & BIT_MASK_BB_DBG_SEL_AFE_SDM_BIT3_1)                            \
+	 << BIT_SHIFT_BB_DBG_SEL_AFE_SDM_BIT3_1)
+#define BIT_GET_BB_DBG_SEL_AFE_SDM_BIT3_1(x)                                   \
+	(((x) >> BIT_SHIFT_BB_DBG_SEL_AFE_SDM_BIT3_1) &                        \
+	 BIT_MASK_BB_DBG_SEL_AFE_SDM_BIT3_1)
+
+/* 2 REG_PMC_DBG_CTRL1			(Offset 0x00A8) */
+
+#define BIT_BT_INT_EN BIT(31)
+
+#define BIT_SHIFT_RD_WR_WIFI_BT_INFO 16
+#define BIT_MASK_RD_WR_WIFI_BT_INFO 0x7fff
+#define BIT_RD_WR_WIFI_BT_INFO(x)                                              \
+	(((x) & BIT_MASK_RD_WR_WIFI_BT_INFO) << BIT_SHIFT_RD_WR_WIFI_BT_INFO)
+#define BIT_GET_RD_WR_WIFI_BT_INFO(x)                                          \
+	(((x) >> BIT_SHIFT_RD_WR_WIFI_BT_INFO) & BIT_MASK_RD_WR_WIFI_BT_INFO)
+
+/* 2 REG_PMC_DBG_CTRL1			(Offset 0x00A8) */
+
+#define BIT_PMC_WR_OVF BIT(8)
+
+#define BIT_SHIFT_WLPMC_ERRINT 0
+#define BIT_MASK_WLPMC_ERRINT 0xff
+#define BIT_WLPMC_ERRINT(x)                                                    \
+	(((x) & BIT_MASK_WLPMC_ERRINT) << BIT_SHIFT_WLPMC_ERRINT)
+#define BIT_GET_WLPMC_ERRINT(x)                                                \
+	(((x) >> BIT_SHIFT_WLPMC_ERRINT) & BIT_MASK_WLPMC_ERRINT)
+
+/* 2 REG_AFE_CTRL7				(Offset 0x00AC) */
+
+#define BIT_SHIFT_SEL_V 30
+#define BIT_MASK_SEL_V 0x3
+#define BIT_SEL_V(x) (((x) & BIT_MASK_SEL_V) << BIT_SHIFT_SEL_V)
+#define BIT_GET_SEL_V(x) (((x) >> BIT_SHIFT_SEL_V) & BIT_MASK_SEL_V)
+
+/* 2 REG_AFE_CTRL7				(Offset 0x00AC) */
+
+#define BIT_TXFIFO_TH_INT BIT(30)
+
+/* 2 REG_AFE_CTRL7				(Offset 0x00AC) */
+
+#define BIT_SEL_LDO_PC BIT(29)
+
+/* 2 REG_AFE_CTRL7				(Offset 0x00AC) */
+
+#define BIT_SHIFT_CK_MON_SEL 26
+#define BIT_MASK_CK_MON_SEL 0x7
+#define BIT_CK_MON_SEL(x) (((x) & BIT_MASK_CK_MON_SEL) << BIT_SHIFT_CK_MON_SEL)
+#define BIT_GET_CK_MON_SEL(x)                                                  \
+	(((x) >> BIT_SHIFT_CK_MON_SEL) & BIT_MASK_CK_MON_SEL)
+
+/* 2 REG_AFE_CTRL7				(Offset 0x00AC) */
+
+#define BIT_CK_MON_EN BIT(25)
+#define BIT_FREF_EDGE BIT(24)
+#define BIT_CK320M_EN BIT(23)
+#define BIT_CK_5M_EN BIT(22)
+#define BIT_TESTEN BIT(21)
+
+/* 2 REG_HIMR0				(Offset 0x00B0) */
+
+#define BIT_TIMEOUT_INTERRUPT2_MASK BIT(31)
+#define BIT_TIMEOUT_INTERRUTP1_MASK BIT(30)
+#define BIT_PSTIMEOUT_MSK BIT(29)
+#define BIT_GTINT4_MSK BIT(28)
+#define BIT_GTINT3_MSK BIT(27)
+#define BIT_TXBCN0ERR_MSK BIT(26)
+#define BIT_TXBCN0OK_MSK BIT(25)
+#define BIT_TSF_BIT32_TOGGLE_MSK BIT(24)
+#define BIT_BCNDMAINT0_MSK BIT(20)
+#define BIT_BCNDERR0_MSK BIT(16)
+#define BIT_HSISR_IND_ON_INT_MSK BIT(15)
+
+/* 2 REG_HIMR0				(Offset 0x00B0) */
+
+#define BIT_BCNDMAINT_E_MSK BIT(14)
+
+/* 2 REG_HIMR0				(Offset 0x00B0) */
+
+#define BIT_CTWEND_MSK BIT(12)
+#define BIT_HISR1_IND_MSK BIT(11)
+
+/* 2 REG_HIMR0				(Offset 0x00B0) */
+
+#define BIT_C2HCMD_MSK BIT(10)
+#define BIT_CPWM2_MSK BIT(9)
+#define BIT_CPWM_MSK BIT(8)
+#define BIT_HIGHDOK_MSK BIT(7)
+#define BIT_MGTDOK_MSK BIT(6)
+#define BIT_BKDOK_MSK BIT(5)
+#define BIT_BEDOK_MSK BIT(4)
+#define BIT_VIDOK_MSK BIT(3)
+#define BIT_VODOK_MSK BIT(2)
+#define BIT_RDU_MSK BIT(1)
+#define BIT_RXOK_MSK BIT(0)
+
+/* 2 REG_HISR0				(Offset 0x00B4) */
+
+#define BIT_TIMEOUT_INTERRUPT2 BIT(31)
+
+/* 2 REG_HISR0				(Offset 0x00B4) */
+
+#define BIT_TIMEOUT_INTERRUTP1 BIT(30)
+
+/* 2 REG_HISR0				(Offset 0x00B4) */
+
+#define BIT_PSTIMEOUT BIT(29)
+#define BIT_GTINT4 BIT(28)
+#define BIT_GTINT3 BIT(27)
+#define BIT_TXBCN0ERR BIT(26)
+#define BIT_TXBCN0OK BIT(25)
+#define BIT_TSF_BIT32_TOGGLE BIT(24)
+#define BIT_BCNDMAINT0 BIT(20)
+#define BIT_BCNDERR0 BIT(16)
+#define BIT_HSISR_IND_ON_INT BIT(15)
+
+/* 2 REG_HISR0				(Offset 0x00B4) */
+
+#define BIT_BCNDMAINT_E BIT(14)
+
+/* 2 REG_HISR0				(Offset 0x00B4) */
+
+#define BIT_CTWEND BIT(12)
+
+/* 2 REG_HISR0				(Offset 0x00B4) */
+
+#define BIT_HISR1_IND_INT BIT(11)
+#define BIT_C2HCMD BIT(10)
+#define BIT_CPWM2 BIT(9)
+#define BIT_CPWM BIT(8)
+#define BIT_HIGHDOK BIT(7)
+#define BIT_MGTDOK BIT(6)
+#define BIT_BKDOK BIT(5)
+#define BIT_BEDOK BIT(4)
+#define BIT_VIDOK BIT(3)
+#define BIT_VODOK BIT(2)
+#define BIT_RDU BIT(1)
+#define BIT_RXOK BIT(0)
+
+/* 2 REG_HIMR1				(Offset 0x00B8) */
+
+#define BIT_BTON_STS_UPDATE_MASK BIT(29)
+
+/* 2 REG_HIMR1				(Offset 0x00B8) */
+
+#define BIT_MCU_ERR_MASK BIT(28)
+
+/* 2 REG_HIMR1				(Offset 0x00B8) */
+
+#define BIT_BCNDMAINT7__MSK BIT(27)
+
+/* 2 REG_HIMR1				(Offset 0x00B8) */
+
+#define BIT_BCNDMAINT6__MSK BIT(26)
+
+/* 2 REG_HIMR1				(Offset 0x00B8) */
+
+#define BIT_BCNDMAINT5__MSK BIT(25)
+
+/* 2 REG_HIMR1				(Offset 0x00B8) */
+
+#define BIT_BCNDMAINT4__MSK BIT(24)
+
+/* 2 REG_HIMR1				(Offset 0x00B8) */
+
+#define BIT_BCNDMAINT3_MSK BIT(23)
+#define BIT_BCNDMAINT2_MSK BIT(22)
+#define BIT_BCNDMAINT1_MSK BIT(21)
+#define BIT_BCNDERR7_MSK BIT(20)
+#define BIT_BCNDERR6_MSK BIT(19)
+#define BIT_BCNDERR5_MSK BIT(18)
+#define BIT_BCNDERR4_MSK BIT(17)
+#define BIT_BCNDERR3_MSK BIT(16)
+#define BIT_BCNDERR2_MSK BIT(15)
+#define BIT_BCNDERR1_MSK BIT(14)
+
+/* 2 REG_HIMR1				(Offset 0x00B8) */
+
+#define BIT_ATIMEND_E_MSK BIT(13)
+
+/* 2 REG_HIMR1				(Offset 0x00B8) */
+
+#define BIT_ATIMEND__MSK BIT(12)
+
+/* 2 REG_HIMR1				(Offset 0x00B8) */
+
+#define BIT_TXERR_MSK BIT(11)
+#define BIT_RXERR_MSK BIT(10)
+#define BIT_TXFOVW_MSK BIT(9)
+#define BIT_FOVW_MSK BIT(8)
+
+/* 2 REG_HIMR1				(Offset 0x00B8) */
+
+#define BIT_CPU_MGQ_TXDONE_MSK BIT(5)
+#define BIT_PS_TIMER_C_MSK BIT(4)
+#define BIT_PS_TIMER_B_MSK BIT(3)
+#define BIT_PS_TIMER_A_MSK BIT(2)
+#define BIT_CPUMGQ_TX_TIMER_MSK BIT(1)
+
+/* 2 REG_HISR1				(Offset 0x00BC) */
+
+#define BIT_BTON_STS_UPDATE_INT BIT(29)
+
+/* 2 REG_HISR1				(Offset 0x00BC) */
+
+#define BIT_MCU_ERR BIT(28)
+
+/* 2 REG_HISR1				(Offset 0x00BC) */
+
+#define BIT_BCNDMAINT7 BIT(27)
+#define BIT_BCNDMAINT6 BIT(26)
+#define BIT_BCNDMAINT5 BIT(25)
+#define BIT_BCNDMAINT4 BIT(24)
+#define BIT_BCNDMAINT3 BIT(23)
+#define BIT_BCNDMAINT2 BIT(22)
+#define BIT_BCNDMAINT1 BIT(21)
+#define BIT_BCNDERR7 BIT(20)
+#define BIT_BCNDERR6 BIT(19)
+#define BIT_BCNDERR5 BIT(18)
+#define BIT_BCNDERR4 BIT(17)
+#define BIT_BCNDERR3 BIT(16)
+#define BIT_BCNDERR2 BIT(15)
+#define BIT_BCNDERR1 BIT(14)
+
+/* 2 REG_HISR1				(Offset 0x00BC) */
+
+#define BIT_ATIMEND_E BIT(13)
+
+/* 2 REG_HISR1				(Offset 0x00BC) */
+
+#define BIT_ATIMEND BIT(12)
+#define BIT_TXERR_INT BIT(11)
+#define BIT_RXERR_INT BIT(10)
+#define BIT_TXFOVW BIT(9)
+#define BIT_FOVW BIT(8)
+
+/* 2 REG_HISR1				(Offset 0x00BC) */
+
+#define BIT_CPU_MGQ_TXDONE BIT(5)
+#define BIT_PS_TIMER_C BIT(4)
+#define BIT_PS_TIMER_B BIT(3)
+#define BIT_PS_TIMER_A BIT(2)
+#define BIT_CPUMGQ_TX_TIMER BIT(1)
+
+/* 2 REG_SDIO_ERR_RPT			(Offset 0x102500C0) */
+
+#define BIT_HR_FF_OVF BIT(6)
+#define BIT_HR_FF_UDN BIT(5)
+#define BIT_TXDMA_BUSY_ERR BIT(4)
+#define BIT_TXDMA_VLD_ERR BIT(3)
+#define BIT_QSEL_UNKNOWN_ERR BIT(2)
+#define BIT_QSEL_MIS_ERR BIT(1)
+
+/* 2 REG_DBG_PORT_SEL			(Offset 0x00C0) */
+
+#define BIT_SHIFT_DEBUG_ST 0
+#define BIT_MASK_DEBUG_ST 0xffffffffL
+#define BIT_DEBUG_ST(x) (((x) & BIT_MASK_DEBUG_ST) << BIT_SHIFT_DEBUG_ST)
+#define BIT_GET_DEBUG_ST(x) (((x) >> BIT_SHIFT_DEBUG_ST) & BIT_MASK_DEBUG_ST)
+
+/* 2 REG_SDIO_ERR_RPT			(Offset 0x102500C0) */
+
+#define BIT_SDIO_OVERRD_ERR BIT(0)
+
+/* 2 REG_SDIO_CMD_ERRCNT			(Offset 0x102500C1) */
+
+#define BIT_SHIFT_CMD_CRC_ERR_CNT 0
+#define BIT_MASK_CMD_CRC_ERR_CNT 0xff
+#define BIT_CMD_CRC_ERR_CNT(x)                                                 \
+	(((x) & BIT_MASK_CMD_CRC_ERR_CNT) << BIT_SHIFT_CMD_CRC_ERR_CNT)
+#define BIT_GET_CMD_CRC_ERR_CNT(x)                                             \
+	(((x) >> BIT_SHIFT_CMD_CRC_ERR_CNT) & BIT_MASK_CMD_CRC_ERR_CNT)
+
+/* 2 REG_SDIO_DATA_ERRCNT			(Offset 0x102500C2) */
+
+#define BIT_SHIFT_DATA_CRC_ERR_CNT 0
+#define BIT_MASK_DATA_CRC_ERR_CNT 0xff
+#define BIT_DATA_CRC_ERR_CNT(x)                                                \
+	(((x) & BIT_MASK_DATA_CRC_ERR_CNT) << BIT_SHIFT_DATA_CRC_ERR_CNT)
+#define BIT_GET_DATA_CRC_ERR_CNT(x)                                            \
+	(((x) >> BIT_SHIFT_DATA_CRC_ERR_CNT) & BIT_MASK_DATA_CRC_ERR_CNT)
+
+/* 2 REG_PAD_CTRL2				(Offset 0x00C4) */
+
+#define BIT_USB3_USB2_TRANSITION BIT(20)
+
+/* 2 REG_PAD_CTRL2				(Offset 0x00C4) */
+
+#define BIT_SHIFT_USB23_SW_MODE_V1 18
+#define BIT_MASK_USB23_SW_MODE_V1 0x3
+#define BIT_USB23_SW_MODE_V1(x)                                                \
+	(((x) & BIT_MASK_USB23_SW_MODE_V1) << BIT_SHIFT_USB23_SW_MODE_V1)
+#define BIT_GET_USB23_SW_MODE_V1(x)                                            \
+	(((x) >> BIT_SHIFT_USB23_SW_MODE_V1) & BIT_MASK_USB23_SW_MODE_V1)
+
+/* 2 REG_PAD_CTRL2				(Offset 0x00C4) */
+
+#define BIT_NO_PDN_CHIPOFF_V1 BIT(17)
+
+/* 2 REG_PAD_CTRL2				(Offset 0x00C4) */
+
+#define BIT_RSM_EN_V1 BIT(16)
+
+/* 2 REG_PAD_CTRL2				(Offset 0x00C4) */
+
+#define BIT_LD_B12V_EN BIT(7)
+
+/* 2 REG_PAD_CTRL2				(Offset 0x00C4) */
+
+#define BIT_EECS_IOSEL_V1 BIT(6)
+
+/* 2 REG_PAD_CTRL2				(Offset 0x00C4) */
+
+#define BIT_EECS_DATA_O_V1 BIT(5)
+
+/* 2 REG_PAD_CTRL2				(Offset 0x00C4) */
+
+#define BIT_EECS_DATA_I_V1 BIT(4)
+
+/* 2 REG_PAD_CTRL2				(Offset 0x00C4) */
+
+#define BIT_EESK_IOSEL_V1 BIT(2)
+
+/* 2 REG_PAD_CTRL2				(Offset 0x00C4) */
+
+#define BIT_EESK_DATA_O_V1 BIT(1)
+
+/* 2 REG_PAD_CTRL2				(Offset 0x00C4) */
+
+#define BIT_EESK_DATA_I_V1 BIT(0)
+
+/* 2 REG_SDIO_CMD_ERR_CONTENT		(Offset 0x102500C4) */
+
+#define BIT_SHIFT_SDIO_CMD_ERR_CONTENT 0
+#define BIT_MASK_SDIO_CMD_ERR_CONTENT 0xffffffffffL
+#define BIT_SDIO_CMD_ERR_CONTENT(x)                                            \
+	(((x) & BIT_MASK_SDIO_CMD_ERR_CONTENT)                                 \
+	 << BIT_SHIFT_SDIO_CMD_ERR_CONTENT)
+#define BIT_GET_SDIO_CMD_ERR_CONTENT(x)                                        \
+	(((x) >> BIT_SHIFT_SDIO_CMD_ERR_CONTENT) &                             \
+	 BIT_MASK_SDIO_CMD_ERR_CONTENT)
+
+/* 2 REG_SDIO_CRC_ERR_IDX			(Offset 0x102500C9) */
+
+#define BIT_D3_CRC_ERR BIT(4)
+#define BIT_D2_CRC_ERR BIT(3)
+#define BIT_D1_CRC_ERR BIT(2)
+#define BIT_D0_CRC_ERR BIT(1)
+#define BIT_CMD_CRC_ERR BIT(0)
+
+/* 2 REG_SDIO_DATA_CRC			(Offset 0x102500CA) */
+
+#define BIT_SHIFT_SDIO_DATA_CRC 0
+#define BIT_MASK_SDIO_DATA_CRC 0xff
+#define BIT_SDIO_DATA_CRC(x)                                                   \
+	(((x) & BIT_MASK_SDIO_DATA_CRC) << BIT_SHIFT_SDIO_DATA_CRC)
+#define BIT_GET_SDIO_DATA_CRC(x)                                               \
+	(((x) >> BIT_SHIFT_SDIO_DATA_CRC) & BIT_MASK_SDIO_DATA_CRC)
+
+/* 2 REG_SDIO_DATA_REPLY_TIME		(Offset 0x102500CB) */
+
+#define BIT_SHIFT_SDIO_DATA_REPLY_TIME 0
+#define BIT_MASK_SDIO_DATA_REPLY_TIME 0x7
+#define BIT_SDIO_DATA_REPLY_TIME(x)                                            \
+	(((x) & BIT_MASK_SDIO_DATA_REPLY_TIME)                                 \
+	 << BIT_SHIFT_SDIO_DATA_REPLY_TIME)
+#define BIT_GET_SDIO_DATA_REPLY_TIME(x)                                        \
+	(((x) >> BIT_SHIFT_SDIO_DATA_REPLY_TIME) &                             \
+	 BIT_MASK_SDIO_DATA_REPLY_TIME)
+
+/* 2 REG_PMC_DBG_CTRL2			(Offset 0x00CC) */
+
+#define BIT_SHIFT_EFUSE_BURN_GNT 24
+#define BIT_MASK_EFUSE_BURN_GNT 0xff
+#define BIT_EFUSE_BURN_GNT(x)                                                  \
+	(((x) & BIT_MASK_EFUSE_BURN_GNT) << BIT_SHIFT_EFUSE_BURN_GNT)
+#define BIT_GET_EFUSE_BURN_GNT(x)                                              \
+	(((x) >> BIT_SHIFT_EFUSE_BURN_GNT) & BIT_MASK_EFUSE_BURN_GNT)
+
+/* 2 REG_PMC_DBG_CTRL2			(Offset 0x00CC) */
+
+#define BIT_STOP_WL_PMC BIT(9)
+#define BIT_STOP_SYM_PMC BIT(8)
+
+/* 2 REG_PMC_DBG_CTRL2			(Offset 0x00CC) */
+
+#define BIT_REG_RST_WLPMC BIT(5)
+#define BIT_REG_RST_PD12N BIT(4)
+#define BIT_SYSON_DIS_WLREG_WRMSK BIT(3)
+#define BIT_SYSON_DIS_PMCREG_WRMSK BIT(2)
+
+#define BIT_SHIFT_SYSON_REG_ARB 0
+#define BIT_MASK_SYSON_REG_ARB 0x3
+#define BIT_SYSON_REG_ARB(x)                                                   \
+	(((x) & BIT_MASK_SYSON_REG_ARB) << BIT_SHIFT_SYSON_REG_ARB)
+#define BIT_GET_SYSON_REG_ARB(x)                                               \
+	(((x) >> BIT_SHIFT_SYSON_REG_ARB) & BIT_MASK_SYSON_REG_ARB)
+
+/* 2 REG_BIST_CTRL				(Offset 0x00D0) */
+
+#define BIT_BIST_USB_DIS BIT(27)
+
+/* 2 REG_BIST_CTRL				(Offset 0x00D0) */
+
+#define BIT_BIST_PCI_DIS BIT(26)
+
+/* 2 REG_BIST_CTRL				(Offset 0x00D0) */
+
+#define BIT_BIST_BT_DIS BIT(25)
+
+/* 2 REG_BIST_CTRL				(Offset 0x00D0) */
+
+#define BIT_BIST_WL_DIS BIT(24)
+
+/* 2 REG_BIST_CTRL				(Offset 0x00D0) */
+
+#define BIT_SHIFT_BIST_RPT_SEL 16
+#define BIT_MASK_BIST_RPT_SEL 0xf
+#define BIT_BIST_RPT_SEL(x)                                                    \
+	(((x) & BIT_MASK_BIST_RPT_SEL) << BIT_SHIFT_BIST_RPT_SEL)
+#define BIT_GET_BIST_RPT_SEL(x)                                                \
+	(((x) >> BIT_SHIFT_BIST_RPT_SEL) & BIT_MASK_BIST_RPT_SEL)
+
+/* 2 REG_BIST_CTRL				(Offset 0x00D0) */
+
+#define BIT_BIST_RESUME_PS BIT(4)
+
+/* 2 REG_BIST_CTRL				(Offset 0x00D0) */
+
+#define BIT_BIST_RESUME BIT(3)
+#define BIT_BIST_NORMAL BIT(2)
+
+/* 2 REG_BIST_CTRL				(Offset 0x00D0) */
+
+#define BIT_BIST_RSTN BIT(1)
+#define BIT_BIST_CLK_EN BIT(0)
+
+/* 2 REG_BIST_RPT				(Offset 0x00D4) */
+
+#define BIT_SHIFT_MBIST_REPORT 0
+#define BIT_MASK_MBIST_REPORT 0xffffffffL
+#define BIT_MBIST_REPORT(x)                                                    \
+	(((x) & BIT_MASK_MBIST_REPORT) << BIT_SHIFT_MBIST_REPORT)
+#define BIT_GET_MBIST_REPORT(x)                                                \
+	(((x) >> BIT_SHIFT_MBIST_REPORT) & BIT_MASK_MBIST_REPORT)
+
+/* 2 REG_MEM_CTRL				(Offset 0x00D8) */
+
+#define BIT_UMEM_RME BIT(31)
+
+/* 2 REG_MEM_CTRL				(Offset 0x00D8) */
+
+#define BIT_SHIFT_BT_SPRAM 28
+#define BIT_MASK_BT_SPRAM 0x3
+#define BIT_BT_SPRAM(x) (((x) & BIT_MASK_BT_SPRAM) << BIT_SHIFT_BT_SPRAM)
+#define BIT_GET_BT_SPRAM(x) (((x) >> BIT_SHIFT_BT_SPRAM) & BIT_MASK_BT_SPRAM)
+
+/* 2 REG_MEM_CTRL				(Offset 0x00D8) */
+
+#define BIT_SHIFT_BT_ROM 24
+#define BIT_MASK_BT_ROM 0xf
+#define BIT_BT_ROM(x) (((x) & BIT_MASK_BT_ROM) << BIT_SHIFT_BT_ROM)
+#define BIT_GET_BT_ROM(x) (((x) >> BIT_SHIFT_BT_ROM) & BIT_MASK_BT_ROM)
+
+#define BIT_SHIFT_PCI_DPRAM 10
+#define BIT_MASK_PCI_DPRAM 0x3
+#define BIT_PCI_DPRAM(x) (((x) & BIT_MASK_PCI_DPRAM) << BIT_SHIFT_PCI_DPRAM)
+#define BIT_GET_PCI_DPRAM(x) (((x) >> BIT_SHIFT_PCI_DPRAM) & BIT_MASK_PCI_DPRAM)
+
+/* 2 REG_MEM_CTRL				(Offset 0x00D8) */
+
+#define BIT_SHIFT_PCI_SPRAM 8
+#define BIT_MASK_PCI_SPRAM 0x3
+#define BIT_PCI_SPRAM(x) (((x) & BIT_MASK_PCI_SPRAM) << BIT_SHIFT_PCI_SPRAM)
+#define BIT_GET_PCI_SPRAM(x) (((x) >> BIT_SHIFT_PCI_SPRAM) & BIT_MASK_PCI_SPRAM)
+
+#define BIT_SHIFT_USB_SPRAM 6
+#define BIT_MASK_USB_SPRAM 0x3
+#define BIT_USB_SPRAM(x) (((x) & BIT_MASK_USB_SPRAM) << BIT_SHIFT_USB_SPRAM)
+#define BIT_GET_USB_SPRAM(x) (((x) >> BIT_SHIFT_USB_SPRAM) & BIT_MASK_USB_SPRAM)
+
+/* 2 REG_MEM_CTRL				(Offset 0x00D8) */
+
+#define BIT_SHIFT_USB_SPRF 4
+#define BIT_MASK_USB_SPRF 0x3
+#define BIT_USB_SPRF(x) (((x) & BIT_MASK_USB_SPRF) << BIT_SHIFT_USB_SPRF)
+#define BIT_GET_USB_SPRF(x) (((x) >> BIT_SHIFT_USB_SPRF) & BIT_MASK_USB_SPRF)
+
+/* 2 REG_MEM_CTRL				(Offset 0x00D8) */
+
+#define BIT_SHIFT_MCU_ROM 0
+#define BIT_MASK_MCU_ROM 0xf
+#define BIT_MCU_ROM(x) (((x) & BIT_MASK_MCU_ROM) << BIT_SHIFT_MCU_ROM)
+#define BIT_GET_MCU_ROM(x) (((x) >> BIT_SHIFT_MCU_ROM) & BIT_MASK_MCU_ROM)
+
+/* 2 REG_AFE_CTRL8				(Offset 0x00DC) */
+
+#define BIT_SYN_AGPIO BIT(20)
+
+/* 2 REG_AFE_CTRL8				(Offset 0x00DC) */
+
+#define BIT_XTAL_LP BIT(4)
+#define BIT_XTAL_GM_SEP BIT(3)
+
+/* 2 REG_AFE_CTRL8				(Offset 0x00DC) */
+
+#define BIT_SHIFT_XTAL_SEL_TOK 0
+#define BIT_MASK_XTAL_SEL_TOK 0x7
+#define BIT_XTAL_SEL_TOK(x)                                                    \
+	(((x) & BIT_MASK_XTAL_SEL_TOK) << BIT_SHIFT_XTAL_SEL_TOK)
+#define BIT_GET_XTAL_SEL_TOK(x)                                                \
+	(((x) >> BIT_SHIFT_XTAL_SEL_TOK) & BIT_MASK_XTAL_SEL_TOK)
+
+/* 2 REG_USB_SIE_INTF			(Offset 0x00E0) */
+
+#define BIT_RD_SEL BIT(31)
+
+/* 2 REG_USB_SIE_INTF			(Offset 0x00E0) */
+
+#define BIT_USB_SIE_INTF_WE_V1 BIT(30)
+#define BIT_USB_SIE_INTF_BYIOREG_V1 BIT(29)
+#define BIT_USB_SIE_SELECT BIT(28)
+
+/* 2 REG_USB_SIE_INTF			(Offset 0x00E0) */
+
+#define BIT_SHIFT_USB_SIE_INTF_ADDR_V1 16
+#define BIT_MASK_USB_SIE_INTF_ADDR_V1 0x1ff
+#define BIT_USB_SIE_INTF_ADDR_V1(x)                                            \
+	(((x) & BIT_MASK_USB_SIE_INTF_ADDR_V1)                                 \
+	 << BIT_SHIFT_USB_SIE_INTF_ADDR_V1)
+#define BIT_GET_USB_SIE_INTF_ADDR_V1(x)                                        \
+	(((x) >> BIT_SHIFT_USB_SIE_INTF_ADDR_V1) &                             \
+	 BIT_MASK_USB_SIE_INTF_ADDR_V1)
+
+/* 2 REG_USB_SIE_INTF			(Offset 0x00E0) */
+
+#define BIT_SHIFT_USB_SIE_INTF_RD 8
+#define BIT_MASK_USB_SIE_INTF_RD 0xff
+#define BIT_USB_SIE_INTF_RD(x)                                                 \
+	(((x) & BIT_MASK_USB_SIE_INTF_RD) << BIT_SHIFT_USB_SIE_INTF_RD)
+#define BIT_GET_USB_SIE_INTF_RD(x)                                             \
+	(((x) >> BIT_SHIFT_USB_SIE_INTF_RD) & BIT_MASK_USB_SIE_INTF_RD)
+
+#define BIT_SHIFT_USB_SIE_INTF_WD 0
+#define BIT_MASK_USB_SIE_INTF_WD 0xff
+#define BIT_USB_SIE_INTF_WD(x)                                                 \
+	(((x) & BIT_MASK_USB_SIE_INTF_WD) << BIT_SHIFT_USB_SIE_INTF_WD)
+#define BIT_GET_USB_SIE_INTF_WD(x)                                             \
+	(((x) >> BIT_SHIFT_USB_SIE_INTF_WD) & BIT_MASK_USB_SIE_INTF_WD)
+
+/* 2 REG_PCIE_MIO_INTF			(Offset 0x00E4) */
+
+#define BIT_PCIE_MIO_BYIOREG BIT(13)
+#define BIT_PCIE_MIO_RE BIT(12)
+
+#define BIT_SHIFT_PCIE_MIO_WE 8
+#define BIT_MASK_PCIE_MIO_WE 0xf
+#define BIT_PCIE_MIO_WE(x)                                                     \
+	(((x) & BIT_MASK_PCIE_MIO_WE) << BIT_SHIFT_PCIE_MIO_WE)
+#define BIT_GET_PCIE_MIO_WE(x)                                                 \
+	(((x) >> BIT_SHIFT_PCIE_MIO_WE) & BIT_MASK_PCIE_MIO_WE)
+
+#define BIT_SHIFT_PCIE_MIO_ADDR 0
+#define BIT_MASK_PCIE_MIO_ADDR 0xff
+#define BIT_PCIE_MIO_ADDR(x)                                                   \
+	(((x) & BIT_MASK_PCIE_MIO_ADDR) << BIT_SHIFT_PCIE_MIO_ADDR)
+#define BIT_GET_PCIE_MIO_ADDR(x)                                               \
+	(((x) >> BIT_SHIFT_PCIE_MIO_ADDR) & BIT_MASK_PCIE_MIO_ADDR)
+
+/* 2 REG_PCIE_MIO_INTD			(Offset 0x00E8) */
+
+#define BIT_SHIFT_PCIE_MIO_DATA 0
+#define BIT_MASK_PCIE_MIO_DATA 0xffffffffL
+#define BIT_PCIE_MIO_DATA(x)                                                   \
+	(((x) & BIT_MASK_PCIE_MIO_DATA) << BIT_SHIFT_PCIE_MIO_DATA)
+#define BIT_GET_PCIE_MIO_DATA(x)                                               \
+	(((x) >> BIT_SHIFT_PCIE_MIO_DATA) & BIT_MASK_PCIE_MIO_DATA)
+
+/* 2 REG_WLRF1				(Offset 0x00EC) */
+
+#define BIT_SHIFT_WLRF1_CTRL 24
+#define BIT_MASK_WLRF1_CTRL 0xff
+#define BIT_WLRF1_CTRL(x) (((x) & BIT_MASK_WLRF1_CTRL) << BIT_SHIFT_WLRF1_CTRL)
+#define BIT_GET_WLRF1_CTRL(x)                                                  \
+	(((x) >> BIT_SHIFT_WLRF1_CTRL) & BIT_MASK_WLRF1_CTRL)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_SHIFT_TRP_ICFG 28
+#define BIT_MASK_TRP_ICFG 0xf
+#define BIT_TRP_ICFG(x) (((x) & BIT_MASK_TRP_ICFG) << BIT_SHIFT_TRP_ICFG)
+#define BIT_GET_TRP_ICFG(x) (((x) >> BIT_SHIFT_TRP_ICFG) & BIT_MASK_TRP_ICFG)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_RF_TYPE_ID BIT(27)
+#define BIT_BD_HCI_SEL BIT(26)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_BD_PKG_SEL BIT(25)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_SPSLDO_SEL BIT(24)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_RTL_ID BIT(23)
+#define BIT_PAD_HWPD_IDN BIT(22)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_TESTMODE BIT(20)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_SHIFT_VENDOR_ID 16
+#define BIT_MASK_VENDOR_ID 0xf
+#define BIT_VENDOR_ID(x) (((x) & BIT_MASK_VENDOR_ID) << BIT_SHIFT_VENDOR_ID)
+#define BIT_GET_VENDOR_ID(x) (((x) >> BIT_SHIFT_VENDOR_ID) & BIT_MASK_VENDOR_ID)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_SHIFT_CHIP_VER 12
+#define BIT_MASK_CHIP_VER 0xf
+#define BIT_CHIP_VER(x) (((x) & BIT_MASK_CHIP_VER) << BIT_SHIFT_CHIP_VER)
+#define BIT_GET_CHIP_VER(x) (((x) >> BIT_SHIFT_CHIP_VER) & BIT_MASK_CHIP_VER)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_BD_MAC3 BIT(11)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_BD_MAC1 BIT(10)
+#define BIT_BD_MAC2 BIT(9)
+#define BIT_SIC_IDLE BIT(8)
+#define BIT_SW_OFFLOAD_EN BIT(7)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_OCP_SHUTDN BIT(6)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_V15_VLD BIT(5)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_PCIRSTB BIT(4)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_PCLK_VLD BIT(3)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_UCLK_VLD BIT(2)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_ACLK_VLD BIT(1)
+
+/* 2 REG_SYS_CFG1				(Offset 0x00F0) */
+
+#define BIT_XCLK_VLD BIT(0)
+
+/* 2 REG_SYS_STATUS1				(Offset 0x00F4) */
+
+#define BIT_SHIFT_RF_RL_ID 28
+#define BIT_MASK_RF_RL_ID 0xf
+#define BIT_RF_RL_ID(x) (((x) & BIT_MASK_RF_RL_ID) << BIT_SHIFT_RF_RL_ID)
+#define BIT_GET_RF_RL_ID(x) (((x) >> BIT_SHIFT_RF_RL_ID) & BIT_MASK_RF_RL_ID)
+
+/* 2 REG_SYS_STATUS1				(Offset 0x00F4) */
+
+#define BIT_HPHY_ICFG BIT(19)
+
+/* 2 REG_SYS_STATUS1				(Offset 0x00F4) */
+
+#define BIT_SHIFT_SEL_0XC0 16
+#define BIT_MASK_SEL_0XC0 0x3
+#define BIT_SEL_0XC0(x) (((x) & BIT_MASK_SEL_0XC0) << BIT_SHIFT_SEL_0XC0)
+#define BIT_GET_SEL_0XC0(x) (((x) >> BIT_SHIFT_SEL_0XC0) & BIT_MASK_SEL_0XC0)
+
+/* 2 REG_SYS_STATUS1				(Offset 0x00F4) */
+
+#define BIT_SHIFT_HCI_SEL_V3 12
+#define BIT_MASK_HCI_SEL_V3 0x7
+#define BIT_HCI_SEL_V3(x) (((x) & BIT_MASK_HCI_SEL_V3) << BIT_SHIFT_HCI_SEL_V3)
+#define BIT_GET_HCI_SEL_V3(x)                                                  \
+	(((x) >> BIT_SHIFT_HCI_SEL_V3) & BIT_MASK_HCI_SEL_V3)
+
+/* 2 REG_SYS_STATUS1				(Offset 0x00F4) */
+
+#define BIT_USB_OPERATION_MODE BIT(10)
+#define BIT_BT_PDN BIT(9)
+#define BIT_AUTO_WLPON BIT(8)
+
+/* 2 REG_SYS_STATUS1				(Offset 0x00F4) */
+
+#define BIT_WL_MODE BIT(7)
+
+/* 2 REG_SYS_STATUS1				(Offset 0x00F4) */
+
+#define BIT_PKG_SEL_HCI BIT(6)
+
+/* 2 REG_SYS_STATUS1				(Offset 0x00F4) */
+
+#define BIT_SHIFT_PAD_HCI_SEL_V1 3
+#define BIT_MASK_PAD_HCI_SEL_V1 0x7
+#define BIT_PAD_HCI_SEL_V1(x)                                                  \
+	(((x) & BIT_MASK_PAD_HCI_SEL_V1) << BIT_SHIFT_PAD_HCI_SEL_V1)
+#define BIT_GET_PAD_HCI_SEL_V1(x)                                              \
+	(((x) >> BIT_SHIFT_PAD_HCI_SEL_V1) & BIT_MASK_PAD_HCI_SEL_V1)
+
+/* 2 REG_SYS_STATUS1				(Offset 0x00F4) */
+
+#define BIT_SHIFT_EFS_HCI_SEL_V1 0
+#define BIT_MASK_EFS_HCI_SEL_V1 0x7
+#define BIT_EFS_HCI_SEL_V1(x)                                                  \
+	(((x) & BIT_MASK_EFS_HCI_SEL_V1) << BIT_SHIFT_EFS_HCI_SEL_V1)
+#define BIT_GET_EFS_HCI_SEL_V1(x)                                              \
+	(((x) >> BIT_SHIFT_EFS_HCI_SEL_V1) & BIT_MASK_EFS_HCI_SEL_V1)
+
+/* 2 REG_SYS_STATUS2				(Offset 0x00F8) */
+
+#define BIT_SIO_ALDN BIT(19)
+#define BIT_USB_ALDN BIT(18)
+#define BIT_PCI_ALDN BIT(17)
+#define BIT_SYS_ALDN BIT(16)
+
+#define BIT_SHIFT_EPVID1 8
+#define BIT_MASK_EPVID1 0xff
+#define BIT_EPVID1(x) (((x) & BIT_MASK_EPVID1) << BIT_SHIFT_EPVID1)
+#define BIT_GET_EPVID1(x) (((x) >> BIT_SHIFT_EPVID1) & BIT_MASK_EPVID1)
+
+#define BIT_SHIFT_EPVID0 0
+#define BIT_MASK_EPVID0 0xff
+#define BIT_EPVID0(x) (((x) & BIT_MASK_EPVID0) << BIT_SHIFT_EPVID0)
+#define BIT_GET_EPVID0(x) (((x) >> BIT_SHIFT_EPVID0) & BIT_MASK_EPVID0)
+
+/* 2 REG_SYS_CFG2				(Offset 0x00FC) */
+
+#define BIT_HCI_SEL_EMBEDDED BIT(8)
+
+/* 2 REG_SYS_CFG2				(Offset 0x00FC) */
+
+#define BIT_SHIFT_HW_ID 0
+#define BIT_MASK_HW_ID 0xff
+#define BIT_HW_ID(x) (((x) & BIT_MASK_HW_ID) << BIT_SHIFT_HW_ID)
+#define BIT_GET_HW_ID(x) (((x) >> BIT_SHIFT_HW_ID) & BIT_MASK_HW_ID)
+
+/* 2 REG_CR					(Offset 0x0100) */
+
+#define BIT_SHIFT_LBMODE 24
+#define BIT_MASK_LBMODE 0x1f
+#define BIT_LBMODE(x) (((x) & BIT_MASK_LBMODE) << BIT_SHIFT_LBMODE)
+#define BIT_GET_LBMODE(x) (((x) >> BIT_SHIFT_LBMODE) & BIT_MASK_LBMODE)
+
+#define BIT_SHIFT_NETYPE1 18
+#define BIT_MASK_NETYPE1 0x3
+#define BIT_NETYPE1(x) (((x) & BIT_MASK_NETYPE1) << BIT_SHIFT_NETYPE1)
+#define BIT_GET_NETYPE1(x) (((x) >> BIT_SHIFT_NETYPE1) & BIT_MASK_NETYPE1)
+
+#define BIT_SHIFT_NETYPE0 16
+#define BIT_MASK_NETYPE0 0x3
+#define BIT_NETYPE0(x) (((x) & BIT_MASK_NETYPE0) << BIT_SHIFT_NETYPE0)
+#define BIT_GET_NETYPE0(x) (((x) >> BIT_SHIFT_NETYPE0) & BIT_MASK_NETYPE0)
+
+/* 2 REG_CR					(Offset 0x0100) */
+
+#define BIT_I2C_MAILBOX_EN BIT(12)
+#define BIT_SHCUT_EN BIT(11)
+
+/* 2 REG_CR					(Offset 0x0100) */
+
+#define BIT_32K_CAL_TMR_EN BIT(10)
+#define BIT_MAC_SEC_EN BIT(9)
+#define BIT_ENSWBCN BIT(8)
+#define BIT_MACRXEN BIT(7)
+#define BIT_MACTXEN BIT(6)
+#define BIT_SCHEDULE_EN BIT(5)
+#define BIT_PROTOCOL_EN BIT(4)
+#define BIT_RXDMA_EN BIT(3)
+#define BIT_TXDMA_EN BIT(2)
+#define BIT_HCI_RXDMA_EN BIT(1)
+#define BIT_HCI_TXDMA_EN BIT(0)
+
+/* 2 REG_PKT_BUFF_ACCESS_CTRL		(Offset 0x0106) */
+
+#define BIT_SHIFT_PKT_BUFF_ACCESS_CTRL 0
+#define BIT_MASK_PKT_BUFF_ACCESS_CTRL 0xff
+#define BIT_PKT_BUFF_ACCESS_CTRL(x)                                            \
+	(((x) & BIT_MASK_PKT_BUFF_ACCESS_CTRL)                                 \
+	 << BIT_SHIFT_PKT_BUFF_ACCESS_CTRL)
+#define BIT_GET_PKT_BUFF_ACCESS_CTRL(x)                                        \
+	(((x) >> BIT_SHIFT_PKT_BUFF_ACCESS_CTRL) &                             \
+	 BIT_MASK_PKT_BUFF_ACCESS_CTRL)
+
+/* 2 REG_TSF_CLK_STATE			(Offset 0x0108) */
+
+#define BIT_TSF_CLK_STABLE BIT(15)
+
+#define BIT_SHIFT_I2C_M_BUS_GNT_FW 4
+#define BIT_MASK_I2C_M_BUS_GNT_FW 0x7
+#define BIT_I2C_M_BUS_GNT_FW(x)                                                \
+	(((x) & BIT_MASK_I2C_M_BUS_GNT_FW) << BIT_SHIFT_I2C_M_BUS_GNT_FW)
+#define BIT_GET_I2C_M_BUS_GNT_FW(x)                                            \
+	(((x) >> BIT_SHIFT_I2C_M_BUS_GNT_FW) & BIT_MASK_I2C_M_BUS_GNT_FW)
+
+#define BIT_I2C_M_GNT_FW BIT(3)
+
+#define BIT_SHIFT_I2C_M_SPEED 1
+#define BIT_MASK_I2C_M_SPEED 0x3
+#define BIT_I2C_M_SPEED(x)                                                     \
+	(((x) & BIT_MASK_I2C_M_SPEED) << BIT_SHIFT_I2C_M_SPEED)
+#define BIT_GET_I2C_M_SPEED(x)                                                 \
+	(((x) >> BIT_SHIFT_I2C_M_SPEED) & BIT_MASK_I2C_M_SPEED)
+
+#define BIT_I2C_M_UNLOCK BIT(0)
+
+/* 2 REG_TXDMA_PQ_MAP			(Offset 0x010C) */
+
+#define BIT_SHIFT_TXDMA_HIQ_MAP 14
+#define BIT_MASK_TXDMA_HIQ_MAP 0x3
+#define BIT_TXDMA_HIQ_MAP(x)                                                   \
+	(((x) & BIT_MASK_TXDMA_HIQ_MAP) << BIT_SHIFT_TXDMA_HIQ_MAP)
+#define BIT_GET_TXDMA_HIQ_MAP(x)                                               \
+	(((x) >> BIT_SHIFT_TXDMA_HIQ_MAP) & BIT_MASK_TXDMA_HIQ_MAP)
+
+#define BIT_SHIFT_TXDMA_MGQ_MAP 12
+#define BIT_MASK_TXDMA_MGQ_MAP 0x3
+#define BIT_TXDMA_MGQ_MAP(x)                                                   \
+	(((x) & BIT_MASK_TXDMA_MGQ_MAP) << BIT_SHIFT_TXDMA_MGQ_MAP)
+#define BIT_GET_TXDMA_MGQ_MAP(x)                                               \
+	(((x) >> BIT_SHIFT_TXDMA_MGQ_MAP) & BIT_MASK_TXDMA_MGQ_MAP)
+
+#define BIT_SHIFT_TXDMA_BKQ_MAP 10
+#define BIT_MASK_TXDMA_BKQ_MAP 0x3
+#define BIT_TXDMA_BKQ_MAP(x)                                                   \
+	(((x) & BIT_MASK_TXDMA_BKQ_MAP) << BIT_SHIFT_TXDMA_BKQ_MAP)
+#define BIT_GET_TXDMA_BKQ_MAP(x)                                               \
+	(((x) >> BIT_SHIFT_TXDMA_BKQ_MAP) & BIT_MASK_TXDMA_BKQ_MAP)
+
+#define BIT_SHIFT_TXDMA_BEQ_MAP 8
+#define BIT_MASK_TXDMA_BEQ_MAP 0x3
+#define BIT_TXDMA_BEQ_MAP(x)                                                   \
+	(((x) & BIT_MASK_TXDMA_BEQ_MAP) << BIT_SHIFT_TXDMA_BEQ_MAP)
+#define BIT_GET_TXDMA_BEQ_MAP(x)                                               \
+	(((x) >> BIT_SHIFT_TXDMA_BEQ_MAP) & BIT_MASK_TXDMA_BEQ_MAP)
+
+#define BIT_SHIFT_TXDMA_VIQ_MAP 6
+#define BIT_MASK_TXDMA_VIQ_MAP 0x3
+#define BIT_TXDMA_VIQ_MAP(x)                                                   \
+	(((x) & BIT_MASK_TXDMA_VIQ_MAP) << BIT_SHIFT_TXDMA_VIQ_MAP)
+#define BIT_GET_TXDMA_VIQ_MAP(x)                                               \
+	(((x) >> BIT_SHIFT_TXDMA_VIQ_MAP) & BIT_MASK_TXDMA_VIQ_MAP)
+
+#define BIT_SHIFT_TXDMA_VOQ_MAP 4
+#define BIT_MASK_TXDMA_VOQ_MAP 0x3
+#define BIT_TXDMA_VOQ_MAP(x)                                                   \
+	(((x) & BIT_MASK_TXDMA_VOQ_MAP) << BIT_SHIFT_TXDMA_VOQ_MAP)
+#define BIT_GET_TXDMA_VOQ_MAP(x)                                               \
+	(((x) >> BIT_SHIFT_TXDMA_VOQ_MAP) & BIT_MASK_TXDMA_VOQ_MAP)
+
+#define BIT_RXDMA_AGG_EN BIT(2)
+#define BIT_RXSHFT_EN BIT(1)
+#define BIT_RXDMA_ARBBW_EN BIT(0)
+
+/* 2 REG_TRXFF_BNDY				(Offset 0x0114) */
+
+#define BIT_SHIFT_RXFFOVFL_RSV_V2 8
+#define BIT_MASK_RXFFOVFL_RSV_V2 0xf
+#define BIT_RXFFOVFL_RSV_V2(x)                                                 \
+	(((x) & BIT_MASK_RXFFOVFL_RSV_V2) << BIT_SHIFT_RXFFOVFL_RSV_V2)
+#define BIT_GET_RXFFOVFL_RSV_V2(x)                                             \
+	(((x) >> BIT_SHIFT_RXFFOVFL_RSV_V2) & BIT_MASK_RXFFOVFL_RSV_V2)
+
+/* 2 REG_TRXFF_BNDY				(Offset 0x0114) */
+
+#define BIT_SHIFT_TXPKTBUF_PGBNDY 0
+#define BIT_MASK_TXPKTBUF_PGBNDY 0xff
+#define BIT_TXPKTBUF_PGBNDY(x)                                                 \
+	(((x) & BIT_MASK_TXPKTBUF_PGBNDY) << BIT_SHIFT_TXPKTBUF_PGBNDY)
+#define BIT_GET_TXPKTBUF_PGBNDY(x)                                             \
+	(((x) >> BIT_SHIFT_TXPKTBUF_PGBNDY) & BIT_MASK_TXPKTBUF_PGBNDY)
+
+/* 2 REG_TRXFF_BNDY				(Offset 0x0114) */
+
+#define BIT_SHIFT_RXFF0_BNDY_V2 0
+#define BIT_MASK_RXFF0_BNDY_V2 0x3ffff
+#define BIT_RXFF0_BNDY_V2(x)                                                   \
+	(((x) & BIT_MASK_RXFF0_BNDY_V2) << BIT_SHIFT_RXFF0_BNDY_V2)
+#define BIT_GET_RXFF0_BNDY_V2(x)                                               \
+	(((x) >> BIT_SHIFT_RXFF0_BNDY_V2) & BIT_MASK_RXFF0_BNDY_V2)
+
+#define BIT_SHIFT_RXFF0_RDPTR_V2 0
+#define BIT_MASK_RXFF0_RDPTR_V2 0x3ffff
+#define BIT_RXFF0_RDPTR_V2(x)                                                  \
+	(((x) & BIT_MASK_RXFF0_RDPTR_V2) << BIT_SHIFT_RXFF0_RDPTR_V2)
+#define BIT_GET_RXFF0_RDPTR_V2(x)                                              \
+	(((x) >> BIT_SHIFT_RXFF0_RDPTR_V2) & BIT_MASK_RXFF0_RDPTR_V2)
+
+#define BIT_SHIFT_RXFF0_WTPTR_V2 0
+#define BIT_MASK_RXFF0_WTPTR_V2 0x3ffff
+#define BIT_RXFF0_WTPTR_V2(x)                                                  \
+	(((x) & BIT_MASK_RXFF0_WTPTR_V2) << BIT_SHIFT_RXFF0_WTPTR_V2)
+#define BIT_GET_RXFF0_WTPTR_V2(x)                                              \
+	(((x) >> BIT_SHIFT_RXFF0_WTPTR_V2) & BIT_MASK_RXFF0_WTPTR_V2)
+
+/* 2 REG_PTA_I2C_MBOX			(Offset 0x0118) */
+
+#define BIT_SHIFT_I2C_M_STATUS 8
+#define BIT_MASK_I2C_M_STATUS 0xf
+#define BIT_I2C_M_STATUS(x)                                                    \
+	(((x) & BIT_MASK_I2C_M_STATUS) << BIT_SHIFT_I2C_M_STATUS)
+#define BIT_GET_I2C_M_STATUS(x)                                                \
+	(((x) >> BIT_SHIFT_I2C_M_STATUS) & BIT_MASK_I2C_M_STATUS)
+
+/* 2 REG_FE1IMR				(Offset 0x0120) */
+
+#define BIT_FS_RXDMA2_DONE_INT_EN BIT(28)
+#define BIT_FS_RXDONE3_INT_EN BIT(27)
+#define BIT_FS_RXDONE2_INT_EN BIT(26)
+#define BIT_FS_RX_BCN_P4_INT_EN BIT(25)
+#define BIT_FS_RX_BCN_P3_INT_EN BIT(24)
+#define BIT_FS_RX_BCN_P2_INT_EN BIT(23)
+#define BIT_FS_RX_BCN_P1_INT_EN BIT(22)
+#define BIT_FS_RX_BCN_P0_INT_EN BIT(21)
+#define BIT_FS_RX_UMD0_INT_EN BIT(20)
+#define BIT_FS_RX_UMD1_INT_EN BIT(19)
+#define BIT_FS_RX_BMD0_INT_EN BIT(18)
+#define BIT_FS_RX_BMD1_INT_EN BIT(17)
+#define BIT_FS_RXDONE_INT_EN BIT(16)
+#define BIT_FS_WWLAN_INT_EN BIT(15)
+#define BIT_FS_SOUND_DONE_INT_EN BIT(14)
+#define BIT_FS_LP_STBY_INT_EN BIT(13)
+#define BIT_FS_TRL_MTR_INT_EN BIT(12)
+#define BIT_FS_BF1_PRETO_INT_EN BIT(11)
+#define BIT_FS_BF0_PRETO_INT_EN BIT(10)
+#define BIT_FS_PTCL_RELEASE_MACID_INT_EN BIT(9)
+
+/* 2 REG_FE1IMR				(Offset 0x0120) */
+
+#define BIT_FS_LTE_COEX_EN BIT(6)
+
+/* 2 REG_FE1IMR				(Offset 0x0120) */
+
+#define BIT_FS_WLACTOFF_INT_EN BIT(5)
+#define BIT_FS_WLACTON_INT_EN BIT(4)
+#define BIT_FS_BTCMD_INT_EN BIT(3)
+
+/* 2 REG_FE1IMR				(Offset 0x0120) */
+
+#define BIT_FS_REG_MAILBOX_TO_I2C_INT_EN BIT(2)
+
+/* 2 REG_FE1IMR				(Offset 0x0120) */
+
+#define BIT_FS_TRPC_TO_INT_EN_V1 BIT(1)
+
+/* 2 REG_FE1IMR				(Offset 0x0120) */
+
+#define BIT_FS_RPC_O_T_INT_EN_V1 BIT(0)
+
+/* 2 REG_FE1ISR				(Offset 0x0124) */
+
+#define BIT_FS_RXDMA2_DONE_INT BIT(28)
+#define BIT_FS_RXDONE3_INT BIT(27)
+#define BIT_FS_RXDONE2_INT BIT(26)
+#define BIT_FS_RX_BCN_P4_INT BIT(25)
+#define BIT_FS_RX_BCN_P3_INT BIT(24)
+#define BIT_FS_RX_BCN_P2_INT BIT(23)
+#define BIT_FS_RX_BCN_P1_INT BIT(22)
+#define BIT_FS_RX_BCN_P0_INT BIT(21)
+#define BIT_FS_RX_UMD0_INT BIT(20)
+#define BIT_FS_RX_UMD1_INT BIT(19)
+#define BIT_FS_RX_BMD0_INT BIT(18)
+#define BIT_FS_RX_BMD1_INT BIT(17)
+#define BIT_FS_RXDONE_INT BIT(16)
+#define BIT_FS_WWLAN_INT BIT(15)
+#define BIT_FS_SOUND_DONE_INT BIT(14)
+#define BIT_FS_LP_STBY_INT BIT(13)
+#define BIT_FS_TRL_MTR_INT BIT(12)
+#define BIT_FS_BF1_PRETO_INT BIT(11)
+#define BIT_FS_BF0_PRETO_INT BIT(10)
+#define BIT_FS_PTCL_RELEASE_MACID_INT BIT(9)
+
+/* 2 REG_FE1ISR				(Offset 0x0124) */
+
+#define BIT_FS_LTE_COEX_INT BIT(6)
+
+/* 2 REG_FE1ISR				(Offset 0x0124) */
+
+#define BIT_FS_WLACTOFF_INT BIT(5)
+#define BIT_FS_WLACTON_INT BIT(4)
+#define BIT_FS_BCN_RX_INT_INT BIT(3)
+
+/* 2 REG_FE1ISR				(Offset 0x0124) */
+
+#define BIT_FS_MAILBOX_TO_I2C_INT BIT(2)
+
+/* 2 REG_FE1ISR				(Offset 0x0124) */
+
+#define BIT_FS_TRPC_TO_INT BIT(1)
+
+/* 2 REG_FE1ISR				(Offset 0x0124) */
+
+#define BIT_FS_RPC_O_T_INT BIT(0)
+
+/* 2 REG_CPWM				(Offset 0x012C) */
+
+#define BIT_CPWM_TOGGLING BIT(31)
+
+#define BIT_SHIFT_CPWM_MOD 24
+#define BIT_MASK_CPWM_MOD 0x7f
+#define BIT_CPWM_MOD(x) (((x) & BIT_MASK_CPWM_MOD) << BIT_SHIFT_CPWM_MOD)
+#define BIT_GET_CPWM_MOD(x) (((x) >> BIT_SHIFT_CPWM_MOD) & BIT_MASK_CPWM_MOD)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNOK_MB7_INT_EN BIT(31)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNOK_MB6_INT_EN BIT(30)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNOK_MB5_INT_EN BIT(29)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNOK_MB4_INT_EN BIT(28)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNOK_MB3_INT_EN BIT(27)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNOK_MB2_INT_EN BIT(26)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNOK_MB1_INT_EN BIT(25)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNOK_MB0_INT_EN BIT(24)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNERR_MB7_INT_EN BIT(23)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNERR_MB6_INT_EN BIT(22)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNERR_MB5_INT_EN BIT(21)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNERR_MB4_INT_EN BIT(20)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNERR_MB3_INT_EN BIT(19)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNERR_MB2_INT_EN BIT(18)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNERR_MB1_INT_EN BIT(17)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXBCNERR_MB0_INT_EN BIT(16)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_CPU_MGQ_TXDONE_INT_EN BIT(15)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_SIFS_OVERSPEC_INT_EN BIT(14)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_MGNTQ_RPTR_RELEASE_INT_EN BIT(13)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_MGNTQFF_TO_INT_EN BIT(12)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_DDMA1_LP_INT_EN BIT(11)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_DDMA1_HP_INT_EN BIT(10)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_DDMA0_LP_INT_EN BIT(9)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_DDMA0_HP_INT_EN BIT(8)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TRXRPT_INT_EN BIT(7)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_C2H_W_READY_INT_EN BIT(6)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_HRCV_INT_EN BIT(5)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_H2CCMD_INT_EN BIT(4)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXPKTIN_INT_EN BIT(3)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_ERRORHDL_INT_EN BIT(2)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXCCX_INT_EN BIT(1)
+
+/* 2 REG_FWIMR				(Offset 0x0130) */
+
+#define BIT_FS_TXCLOSE_INT_EN BIT(0)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNOK_MB7_INT BIT(31)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNOK_MB6_INT BIT(30)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNOK_MB5_INT BIT(29)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNOK_MB4_INT BIT(28)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNOK_MB3_INT BIT(27)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNOK_MB2_INT BIT(26)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNOK_MB1_INT BIT(25)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNOK_MB0_INT BIT(24)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNERR_MB7_INT BIT(23)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNERR_MB6_INT BIT(22)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNERR_MB5_INT BIT(21)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNERR_MB4_INT BIT(20)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNERR_MB3_INT BIT(19)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNERR_MB2_INT BIT(18)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNERR_MB1_INT BIT(17)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXBCNERR_MB0_INT BIT(16)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_CPU_MGQ_TXDONE_INT BIT(15)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_SIFS_OVERSPEC_INT BIT(14)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_MGNTQ_RPTR_RELEASE_INT BIT(13)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_MGNTQFF_TO_INT BIT(12)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_DDMA1_LP_INT BIT(11)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_DDMA1_HP_INT BIT(10)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_DDMA0_LP_INT BIT(9)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_DDMA0_HP_INT BIT(8)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TRXRPT_INT BIT(7)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_C2H_W_READY_INT BIT(6)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_HRCV_INT BIT(5)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_H2CCMD_INT BIT(4)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXPKTIN_INT BIT(3)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_ERRORHDL_INT BIT(2)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXCCX_INT BIT(1)
+
+/* 2 REG_FWISR				(Offset 0x0134) */
+
+#define BIT_FS_TXCLOSE_INT BIT(0)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_PS_TIMER_C_EARLY_INT_EN BIT(23)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_PS_TIMER_B_EARLY_INT_EN BIT(22)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_PS_TIMER_A_EARLY_INT_EN BIT(21)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_CPUMGQ_TX_TIMER_EARLY_INT_EN BIT(20)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_PS_TIMER_C_INT_EN BIT(19)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_PS_TIMER_B_INT_EN BIT(18)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_PS_TIMER_A_INT_EN BIT(17)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_CPUMGQ_TX_TIMER_INT_EN BIT(16)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_FS_PS_TIMEOUT2_EN BIT(15)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_FS_PS_TIMEOUT1_EN BIT(14)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_FS_PS_TIMEOUT0_EN BIT(13)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_FS_GTINT8_EN BIT(8)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_FS_GTINT7_EN BIT(7)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_FS_GTINT6_EN BIT(6)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_FS_GTINT5_EN BIT(5)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_FS_GTINT4_EN BIT(4)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_FS_GTINT3_EN BIT(3)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_FS_GTINT2_EN BIT(2)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_FS_GTINT1_EN BIT(1)
+
+/* 2 REG_FTIMR				(Offset 0x0138) */
+
+#define BIT_FS_GTINT0_EN BIT(0)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_PS_TIMER_C_EARLY__INT BIT(23)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_PS_TIMER_B_EARLY__INT BIT(22)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_PS_TIMER_A_EARLY__INT BIT(21)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_CPUMGQ_TX_TIMER_EARLY_INT BIT(20)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_PS_TIMER_C_INT BIT(19)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_PS_TIMER_B_INT BIT(18)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_PS_TIMER_A_INT BIT(17)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_CPUMGQ_TX_TIMER_INT BIT(16)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_FS_PS_TIMEOUT2_INT BIT(15)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_FS_PS_TIMEOUT1_INT BIT(14)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_FS_PS_TIMEOUT0_INT BIT(13)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_FS_GTINT8_INT BIT(8)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_FS_GTINT7_INT BIT(7)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_FS_GTINT6_INT BIT(6)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_FS_GTINT5_INT BIT(5)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_FS_GTINT4_INT BIT(4)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_FS_GTINT3_INT BIT(3)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_FS_GTINT2_INT BIT(2)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_FS_GTINT1_INT BIT(1)
+
+/* 2 REG_FTISR				(Offset 0x013C) */
+
+#define BIT_FS_GTINT0_INT BIT(0)
+
+/* 2 REG_PKTBUF_DBG_CTRL			(Offset 0x0140) */
+
+#define BIT_SHIFT_PKTBUF_WRITE_EN 24
+#define BIT_MASK_PKTBUF_WRITE_EN 0xff
+#define BIT_PKTBUF_WRITE_EN(x)                                                 \
+	(((x) & BIT_MASK_PKTBUF_WRITE_EN) << BIT_SHIFT_PKTBUF_WRITE_EN)
+#define BIT_GET_PKTBUF_WRITE_EN(x)                                             \
+	(((x) >> BIT_SHIFT_PKTBUF_WRITE_EN) & BIT_MASK_PKTBUF_WRITE_EN)
+
+/* 2 REG_PKTBUF_DBG_CTRL			(Offset 0x0140) */
+
+#define BIT_TXRPTBUF_DBG BIT(23)
+
+/* 2 REG_PKTBUF_DBG_CTRL			(Offset 0x0140) */
+
+#define BIT_TXPKTBUF_DBG_V2 BIT(20)
+
+/* 2 REG_PKTBUF_DBG_CTRL			(Offset 0x0140) */
+
+#define BIT_RXPKTBUF_DBG BIT(16)
+
+/* 2 REG_PKTBUF_DBG_CTRL			(Offset 0x0140) */
+
+#define BIT_SHIFT_PKTBUF_DBG_ADDR 0
+#define BIT_MASK_PKTBUF_DBG_ADDR 0x1fff
+#define BIT_PKTBUF_DBG_ADDR(x)                                                 \
+	(((x) & BIT_MASK_PKTBUF_DBG_ADDR) << BIT_SHIFT_PKTBUF_DBG_ADDR)
+#define BIT_GET_PKTBUF_DBG_ADDR(x)                                             \
+	(((x) >> BIT_SHIFT_PKTBUF_DBG_ADDR) & BIT_MASK_PKTBUF_DBG_ADDR)
+
+/* 2 REG_PKTBUF_DBG_DATA_L			(Offset 0x0144) */
+
+#define BIT_SHIFT_PKTBUF_DBG_DATA_L 0
+#define BIT_MASK_PKTBUF_DBG_DATA_L 0xffffffffL
+#define BIT_PKTBUF_DBG_DATA_L(x)                                               \
+	(((x) & BIT_MASK_PKTBUF_DBG_DATA_L) << BIT_SHIFT_PKTBUF_DBG_DATA_L)
+#define BIT_GET_PKTBUF_DBG_DATA_L(x)                                           \
+	(((x) >> BIT_SHIFT_PKTBUF_DBG_DATA_L) & BIT_MASK_PKTBUF_DBG_DATA_L)
+
+/* 2 REG_PKTBUF_DBG_DATA_H			(Offset 0x0148) */
+
+#define BIT_SHIFT_PKTBUF_DBG_DATA_H 0
+#define BIT_MASK_PKTBUF_DBG_DATA_H 0xffffffffL
+#define BIT_PKTBUF_DBG_DATA_H(x)                                               \
+	(((x) & BIT_MASK_PKTBUF_DBG_DATA_H) << BIT_SHIFT_PKTBUF_DBG_DATA_H)
+#define BIT_GET_PKTBUF_DBG_DATA_H(x)                                           \
+	(((x) >> BIT_SHIFT_PKTBUF_DBG_DATA_H) & BIT_MASK_PKTBUF_DBG_DATA_H)
+
+/* 2 REG_CPWM2				(Offset 0x014C) */
+
+#define BIT_SHIFT_L0S_TO_RCVY_NUM 16
+#define BIT_MASK_L0S_TO_RCVY_NUM 0xff
+#define BIT_L0S_TO_RCVY_NUM(x)                                                 \
+	(((x) & BIT_MASK_L0S_TO_RCVY_NUM) << BIT_SHIFT_L0S_TO_RCVY_NUM)
+#define BIT_GET_L0S_TO_RCVY_NUM(x)                                             \
+	(((x) >> BIT_SHIFT_L0S_TO_RCVY_NUM) & BIT_MASK_L0S_TO_RCVY_NUM)
+
+#define BIT_CPWM2_TOGGLING BIT(15)
+
+#define BIT_SHIFT_CPWM2_MOD 0
+#define BIT_MASK_CPWM2_MOD 0x7fff
+#define BIT_CPWM2_MOD(x) (((x) & BIT_MASK_CPWM2_MOD) << BIT_SHIFT_CPWM2_MOD)
+#define BIT_GET_CPWM2_MOD(x) (((x) >> BIT_SHIFT_CPWM2_MOD) & BIT_MASK_CPWM2_MOD)
+
+/* 2 REG_TC0_CTRL				(Offset 0x0150) */
+
+#define BIT_TC0INT_EN BIT(26)
+#define BIT_TC0MODE BIT(25)
+#define BIT_TC0EN BIT(24)
+
+#define BIT_SHIFT_TC0DATA 0
+#define BIT_MASK_TC0DATA 0xffffff
+#define BIT_TC0DATA(x) (((x) & BIT_MASK_TC0DATA) << BIT_SHIFT_TC0DATA)
+#define BIT_GET_TC0DATA(x) (((x) >> BIT_SHIFT_TC0DATA) & BIT_MASK_TC0DATA)
+
+/* 2 REG_TC1_CTRL				(Offset 0x0154) */
+
+#define BIT_TC1INT_EN BIT(26)
+#define BIT_TC1MODE BIT(25)
+#define BIT_TC1EN BIT(24)
+
+#define BIT_SHIFT_TC1DATA 0
+#define BIT_MASK_TC1DATA 0xffffff
+#define BIT_TC1DATA(x) (((x) & BIT_MASK_TC1DATA) << BIT_SHIFT_TC1DATA)
+#define BIT_GET_TC1DATA(x) (((x) >> BIT_SHIFT_TC1DATA) & BIT_MASK_TC1DATA)
+
+/* 2 REG_TC2_CTRL				(Offset 0x0158) */
+
+#define BIT_TC2INT_EN BIT(26)
+#define BIT_TC2MODE BIT(25)
+#define BIT_TC2EN BIT(24)
+
+#define BIT_SHIFT_TC2DATA 0
+#define BIT_MASK_TC2DATA 0xffffff
+#define BIT_TC2DATA(x) (((x) & BIT_MASK_TC2DATA) << BIT_SHIFT_TC2DATA)
+#define BIT_GET_TC2DATA(x) (((x) >> BIT_SHIFT_TC2DATA) & BIT_MASK_TC2DATA)
+
+/* 2 REG_TC3_CTRL				(Offset 0x015C) */
+
+#define BIT_TC3INT_EN BIT(26)
+#define BIT_TC3MODE BIT(25)
+#define BIT_TC3EN BIT(24)
+
+#define BIT_SHIFT_TC3DATA 0
+#define BIT_MASK_TC3DATA 0xffffff
+#define BIT_TC3DATA(x) (((x) & BIT_MASK_TC3DATA) << BIT_SHIFT_TC3DATA)
+#define BIT_GET_TC3DATA(x) (((x) >> BIT_SHIFT_TC3DATA) & BIT_MASK_TC3DATA)
+
+/* 2 REG_TC4_CTRL				(Offset 0x0160) */
+
+#define BIT_TC4INT_EN BIT(26)
+#define BIT_TC4MODE BIT(25)
+#define BIT_TC4EN BIT(24)
+
+#define BIT_SHIFT_TC4DATA 0
+#define BIT_MASK_TC4DATA 0xffffff
+#define BIT_TC4DATA(x) (((x) & BIT_MASK_TC4DATA) << BIT_SHIFT_TC4DATA)
+#define BIT_GET_TC4DATA(x) (((x) >> BIT_SHIFT_TC4DATA) & BIT_MASK_TC4DATA)
+
+/* 2 REG_TCUNIT_BASE				(Offset 0x0164) */
+
+#define BIT_SHIFT_TCUNIT_BASE 0
+#define BIT_MASK_TCUNIT_BASE 0x3fff
+#define BIT_TCUNIT_BASE(x)                                                     \
+	(((x) & BIT_MASK_TCUNIT_BASE) << BIT_SHIFT_TCUNIT_BASE)
+#define BIT_GET_TCUNIT_BASE(x)                                                 \
+	(((x) >> BIT_SHIFT_TCUNIT_BASE) & BIT_MASK_TCUNIT_BASE)
+
+/* 2 REG_TC5_CTRL				(Offset 0x0168) */
+
+#define BIT_TC5INT_EN BIT(26)
+
+/* 2 REG_TC5_CTRL				(Offset 0x0168) */
+
+#define BIT_TC5MODE BIT(25)
+#define BIT_TC5EN BIT(24)
+
+#define BIT_SHIFT_TC5DATA 0
+#define BIT_MASK_TC5DATA 0xffffff
+#define BIT_TC5DATA(x) (((x) & BIT_MASK_TC5DATA) << BIT_SHIFT_TC5DATA)
+#define BIT_GET_TC5DATA(x) (((x) >> BIT_SHIFT_TC5DATA) & BIT_MASK_TC5DATA)
+
+/* 2 REG_TC6_CTRL				(Offset 0x016C) */
+
+#define BIT_TC6INT_EN BIT(26)
+
+/* 2 REG_TC6_CTRL				(Offset 0x016C) */
+
+#define BIT_TC6MODE BIT(25)
+#define BIT_TC6EN BIT(24)
+
+#define BIT_SHIFT_TC6DATA 0
+#define BIT_MASK_TC6DATA 0xffffff
+#define BIT_TC6DATA(x) (((x) & BIT_MASK_TC6DATA) << BIT_SHIFT_TC6DATA)
+#define BIT_GET_TC6DATA(x) (((x) >> BIT_SHIFT_TC6DATA) & BIT_MASK_TC6DATA)
+
+/* 2 REG_MBIST_FAIL				(Offset 0x0170) */
+
+#define BIT_SHIFT_8051_MBIST_FAIL 26
+#define BIT_MASK_8051_MBIST_FAIL 0x7
+#define BIT_8051_MBIST_FAIL(x)                                                 \
+	(((x) & BIT_MASK_8051_MBIST_FAIL) << BIT_SHIFT_8051_MBIST_FAIL)
+#define BIT_GET_8051_MBIST_FAIL(x)                                             \
+	(((x) >> BIT_SHIFT_8051_MBIST_FAIL) & BIT_MASK_8051_MBIST_FAIL)
+
+#define BIT_SHIFT_USB_MBIST_FAIL 24
+#define BIT_MASK_USB_MBIST_FAIL 0x3
+#define BIT_USB_MBIST_FAIL(x)                                                  \
+	(((x) & BIT_MASK_USB_MBIST_FAIL) << BIT_SHIFT_USB_MBIST_FAIL)
+#define BIT_GET_USB_MBIST_FAIL(x)                                              \
+	(((x) >> BIT_SHIFT_USB_MBIST_FAIL) & BIT_MASK_USB_MBIST_FAIL)
+
+#define BIT_SHIFT_PCIE_MBIST_FAIL 16
+#define BIT_MASK_PCIE_MBIST_FAIL 0x3f
+#define BIT_PCIE_MBIST_FAIL(x)                                                 \
+	(((x) & BIT_MASK_PCIE_MBIST_FAIL) << BIT_SHIFT_PCIE_MBIST_FAIL)
+#define BIT_GET_PCIE_MBIST_FAIL(x)                                             \
+	(((x) >> BIT_SHIFT_PCIE_MBIST_FAIL) & BIT_MASK_PCIE_MBIST_FAIL)
+
+/* 2 REG_MBIST_FAIL				(Offset 0x0170) */
+
+#define BIT_SHIFT_MAC_MBIST_FAIL 0
+#define BIT_MASK_MAC_MBIST_FAIL 0xfff
+#define BIT_MAC_MBIST_FAIL(x)                                                  \
+	(((x) & BIT_MASK_MAC_MBIST_FAIL) << BIT_SHIFT_MAC_MBIST_FAIL)
+#define BIT_GET_MAC_MBIST_FAIL(x)                                              \
+	(((x) >> BIT_SHIFT_MAC_MBIST_FAIL) & BIT_MASK_MAC_MBIST_FAIL)
+
+/* 2 REG_MBIST_START_PAUSE			(Offset 0x0174) */
+
+#define BIT_SHIFT_8051_MBIST_START_PAUSE 26
+#define BIT_MASK_8051_MBIST_START_PAUSE 0x7
+#define BIT_8051_MBIST_START_PAUSE(x)                                          \
+	(((x) & BIT_MASK_8051_MBIST_START_PAUSE)                               \
+	 << BIT_SHIFT_8051_MBIST_START_PAUSE)
+#define BIT_GET_8051_MBIST_START_PAUSE(x)                                      \
+	(((x) >> BIT_SHIFT_8051_MBIST_START_PAUSE) &                           \
+	 BIT_MASK_8051_MBIST_START_PAUSE)
+
+#define BIT_SHIFT_USB_MBIST_START_PAUSE 24
+#define BIT_MASK_USB_MBIST_START_PAUSE 0x3
+#define BIT_USB_MBIST_START_PAUSE(x)                                           \
+	(((x) & BIT_MASK_USB_MBIST_START_PAUSE)                                \
+	 << BIT_SHIFT_USB_MBIST_START_PAUSE)
+#define BIT_GET_USB_MBIST_START_PAUSE(x)                                       \
+	(((x) >> BIT_SHIFT_USB_MBIST_START_PAUSE) &                            \
+	 BIT_MASK_USB_MBIST_START_PAUSE)
+
+#define BIT_SHIFT_PCIE_MBIST_START_PAUSE 16
+#define BIT_MASK_PCIE_MBIST_START_PAUSE 0x3f
+#define BIT_PCIE_MBIST_START_PAUSE(x)                                          \
+	(((x) & BIT_MASK_PCIE_MBIST_START_PAUSE)                               \
+	 << BIT_SHIFT_PCIE_MBIST_START_PAUSE)
+#define BIT_GET_PCIE_MBIST_START_PAUSE(x)                                      \
+	(((x) >> BIT_SHIFT_PCIE_MBIST_START_PAUSE) &                           \
+	 BIT_MASK_PCIE_MBIST_START_PAUSE)
+
+/* 2 REG_MBIST_START_PAUSE			(Offset 0x0174) */
+
+#define BIT_SHIFT_MAC_MBIST_START_PAUSE 0
+#define BIT_MASK_MAC_MBIST_START_PAUSE 0xfff
+#define BIT_MAC_MBIST_START_PAUSE(x)                                           \
+	(((x) & BIT_MASK_MAC_MBIST_START_PAUSE)                                \
+	 << BIT_SHIFT_MAC_MBIST_START_PAUSE)
+#define BIT_GET_MAC_MBIST_START_PAUSE(x)                                       \
+	(((x) >> BIT_SHIFT_MAC_MBIST_START_PAUSE) &                            \
+	 BIT_MASK_MAC_MBIST_START_PAUSE)
+
+/* 2 REG_MBIST_DONE				(Offset 0x0178) */
+
+#define BIT_SHIFT_8051_MBIST_DONE 26
+#define BIT_MASK_8051_MBIST_DONE 0x7
+#define BIT_8051_MBIST_DONE(x)                                                 \
+	(((x) & BIT_MASK_8051_MBIST_DONE) << BIT_SHIFT_8051_MBIST_DONE)
+#define BIT_GET_8051_MBIST_DONE(x)                                             \
+	(((x) >> BIT_SHIFT_8051_MBIST_DONE) & BIT_MASK_8051_MBIST_DONE)
+
+#define BIT_SHIFT_USB_MBIST_DONE 24
+#define BIT_MASK_USB_MBIST_DONE 0x3
+#define BIT_USB_MBIST_DONE(x)                                                  \
+	(((x) & BIT_MASK_USB_MBIST_DONE) << BIT_SHIFT_USB_MBIST_DONE)
+#define BIT_GET_USB_MBIST_DONE(x)                                              \
+	(((x) >> BIT_SHIFT_USB_MBIST_DONE) & BIT_MASK_USB_MBIST_DONE)
+
+#define BIT_SHIFT_PCIE_MBIST_DONE 16
+#define BIT_MASK_PCIE_MBIST_DONE 0x3f
+#define BIT_PCIE_MBIST_DONE(x)                                                 \
+	(((x) & BIT_MASK_PCIE_MBIST_DONE) << BIT_SHIFT_PCIE_MBIST_DONE)
+#define BIT_GET_PCIE_MBIST_DONE(x)                                             \
+	(((x) >> BIT_SHIFT_PCIE_MBIST_DONE) & BIT_MASK_PCIE_MBIST_DONE)
+
+/* 2 REG_MBIST_DONE				(Offset 0x0178) */
+
+#define BIT_SHIFT_MAC_MBIST_DONE 0
+#define BIT_MASK_MAC_MBIST_DONE 0xfff
+#define BIT_MAC_MBIST_DONE(x)                                                  \
+	(((x) & BIT_MASK_MAC_MBIST_DONE) << BIT_SHIFT_MAC_MBIST_DONE)
+#define BIT_GET_MAC_MBIST_DONE(x)                                              \
+	(((x) >> BIT_SHIFT_MAC_MBIST_DONE) & BIT_MASK_MAC_MBIST_DONE)
+
+/* 2 REG_MBIST_FAIL_NRML			(Offset 0x017C) */
+
+#define BIT_SHIFT_MBIST_FAIL_NRML 0
+#define BIT_MASK_MBIST_FAIL_NRML 0xffffffffL
+#define BIT_MBIST_FAIL_NRML(x)                                                 \
+	(((x) & BIT_MASK_MBIST_FAIL_NRML) << BIT_SHIFT_MBIST_FAIL_NRML)
+#define BIT_GET_MBIST_FAIL_NRML(x)                                             \
+	(((x) >> BIT_SHIFT_MBIST_FAIL_NRML) & BIT_MASK_MBIST_FAIL_NRML)
+
+/* 2 REG_AES_DECRPT_DATA			(Offset 0x0180) */
+
+#define BIT_SHIFT_IPS_CFG_ADDR 0
+#define BIT_MASK_IPS_CFG_ADDR 0xff
+#define BIT_IPS_CFG_ADDR(x)                                                    \
+	(((x) & BIT_MASK_IPS_CFG_ADDR) << BIT_SHIFT_IPS_CFG_ADDR)
+#define BIT_GET_IPS_CFG_ADDR(x)                                                \
+	(((x) >> BIT_SHIFT_IPS_CFG_ADDR) & BIT_MASK_IPS_CFG_ADDR)
+
+/* 2 REG_AES_DECRPT_CFG			(Offset 0x0184) */
+
+#define BIT_SHIFT_IPS_CFG_DATA 0
+#define BIT_MASK_IPS_CFG_DATA 0xffffffffL
+#define BIT_IPS_CFG_DATA(x)                                                    \
+	(((x) & BIT_MASK_IPS_CFG_DATA) << BIT_SHIFT_IPS_CFG_DATA)
+#define BIT_GET_IPS_CFG_DATA(x)                                                \
+	(((x) >> BIT_SHIFT_IPS_CFG_DATA) & BIT_MASK_IPS_CFG_DATA)
+
+/* 2 REG_TMETER				(Offset 0x0190) */
+
+#define BIT_TEMP_VALID BIT(31)
+
+#define BIT_SHIFT_TEMP_VALUE 24
+#define BIT_MASK_TEMP_VALUE 0x3f
+#define BIT_TEMP_VALUE(x) (((x) & BIT_MASK_TEMP_VALUE) << BIT_SHIFT_TEMP_VALUE)
+#define BIT_GET_TEMP_VALUE(x)                                                  \
+	(((x) >> BIT_SHIFT_TEMP_VALUE) & BIT_MASK_TEMP_VALUE)
+
+#define BIT_SHIFT_REG_TMETER_TIMER 8
+#define BIT_MASK_REG_TMETER_TIMER 0xfff
+#define BIT_REG_TMETER_TIMER(x)                                                \
+	(((x) & BIT_MASK_REG_TMETER_TIMER) << BIT_SHIFT_REG_TMETER_TIMER)
+#define BIT_GET_REG_TMETER_TIMER(x)                                            \
+	(((x) >> BIT_SHIFT_REG_TMETER_TIMER) & BIT_MASK_REG_TMETER_TIMER)
+
+#define BIT_SHIFT_REG_TEMP_DELTA 2
+#define BIT_MASK_REG_TEMP_DELTA 0x3f
+#define BIT_REG_TEMP_DELTA(x)                                                  \
+	(((x) & BIT_MASK_REG_TEMP_DELTA) << BIT_SHIFT_REG_TEMP_DELTA)
+#define BIT_GET_REG_TEMP_DELTA(x)                                              \
+	(((x) >> BIT_SHIFT_REG_TEMP_DELTA) & BIT_MASK_REG_TEMP_DELTA)
+
+#define BIT_REG_TMETER_EN BIT(0)
+
+/* 2 REG_OSC_32K_CTRL			(Offset 0x0194) */
+
+#define BIT_SHIFT_OSC_32K_CLKGEN_0 16
+#define BIT_MASK_OSC_32K_CLKGEN_0 0xffff
+#define BIT_OSC_32K_CLKGEN_0(x)                                                \
+	(((x) & BIT_MASK_OSC_32K_CLKGEN_0) << BIT_SHIFT_OSC_32K_CLKGEN_0)
+#define BIT_GET_OSC_32K_CLKGEN_0(x)                                            \
+	(((x) >> BIT_SHIFT_OSC_32K_CLKGEN_0) & BIT_MASK_OSC_32K_CLKGEN_0)
+
+/* 2 REG_OSC_32K_CTRL			(Offset 0x0194) */
+
+#define BIT_SHIFT_OSC_32K_RES_COMP 4
+#define BIT_MASK_OSC_32K_RES_COMP 0x3
+#define BIT_OSC_32K_RES_COMP(x)                                                \
+	(((x) & BIT_MASK_OSC_32K_RES_COMP) << BIT_SHIFT_OSC_32K_RES_COMP)
+#define BIT_GET_OSC_32K_RES_COMP(x)                                            \
+	(((x) >> BIT_SHIFT_OSC_32K_RES_COMP) & BIT_MASK_OSC_32K_RES_COMP)
+
+#define BIT_OSC_32K_OUT_SEL BIT(3)
+
+/* 2 REG_OSC_32K_CTRL			(Offset 0x0194) */
+
+#define BIT_ISO_WL_2_OSC_32K BIT(1)
+
+/* 2 REG_OSC_32K_CTRL			(Offset 0x0194) */
+
+#define BIT_POW_CKGEN BIT(0)
+
+/* 2 REG_32K_CAL_REG1			(Offset 0x0198) */
+
+#define BIT_CAL_32K_REG_WR BIT(31)
+#define BIT_CAL_32K_DBG_SEL BIT(22)
+
+#define BIT_SHIFT_CAL_32K_REG_ADDR 16
+#define BIT_MASK_CAL_32K_REG_ADDR 0x3f
+#define BIT_CAL_32K_REG_ADDR(x)                                                \
+	(((x) & BIT_MASK_CAL_32K_REG_ADDR) << BIT_SHIFT_CAL_32K_REG_ADDR)
+#define BIT_GET_CAL_32K_REG_ADDR(x)                                            \
+	(((x) >> BIT_SHIFT_CAL_32K_REG_ADDR) & BIT_MASK_CAL_32K_REG_ADDR)
+
+/* 2 REG_32K_CAL_REG1			(Offset 0x0198) */
+
+#define BIT_SHIFT_CAL_32K_REG_DATA 0
+#define BIT_MASK_CAL_32K_REG_DATA 0xffff
+#define BIT_CAL_32K_REG_DATA(x)                                                \
+	(((x) & BIT_MASK_CAL_32K_REG_DATA) << BIT_SHIFT_CAL_32K_REG_DATA)
+#define BIT_GET_CAL_32K_REG_DATA(x)                                            \
+	(((x) >> BIT_SHIFT_CAL_32K_REG_DATA) & BIT_MASK_CAL_32K_REG_DATA)
+
+/* 2 REG_C2HEVT				(Offset 0x01A0) */
+
+#define BIT_SHIFT_C2HEVT_MSG 0
+#define BIT_MASK_C2HEVT_MSG 0xffffffffffffffffffffffffffffffffL
+#define BIT_C2HEVT_MSG(x) (((x) & BIT_MASK_C2HEVT_MSG) << BIT_SHIFT_C2HEVT_MSG)
+#define BIT_GET_C2HEVT_MSG(x)                                                  \
+	(((x) >> BIT_SHIFT_C2HEVT_MSG) & BIT_MASK_C2HEVT_MSG)
+
+/* 2 REG_SW_DEFINED_PAGE1			(Offset 0x01B8) */
+
+#define BIT_SHIFT_SW_DEFINED_PAGE1 0
+#define BIT_MASK_SW_DEFINED_PAGE1 0xffffffffffffffffL
+#define BIT_SW_DEFINED_PAGE1(x)                                                \
+	(((x) & BIT_MASK_SW_DEFINED_PAGE1) << BIT_SHIFT_SW_DEFINED_PAGE1)
+#define BIT_GET_SW_DEFINED_PAGE1(x)                                            \
+	(((x) >> BIT_SHIFT_SW_DEFINED_PAGE1) & BIT_MASK_SW_DEFINED_PAGE1)
+
+/* 2 REG_MCUTST_I				(Offset 0x01C0) */
+
+#define BIT_SHIFT_MCUDMSG_I 0
+#define BIT_MASK_MCUDMSG_I 0xffffffffL
+#define BIT_MCUDMSG_I(x) (((x) & BIT_MASK_MCUDMSG_I) << BIT_SHIFT_MCUDMSG_I)
+#define BIT_GET_MCUDMSG_I(x) (((x) >> BIT_SHIFT_MCUDMSG_I) & BIT_MASK_MCUDMSG_I)
+
+/* 2 REG_MCUTST_II				(Offset 0x01C4) */
+
+#define BIT_SHIFT_MCUDMSG_II 0
+#define BIT_MASK_MCUDMSG_II 0xffffffffL
+#define BIT_MCUDMSG_II(x) (((x) & BIT_MASK_MCUDMSG_II) << BIT_SHIFT_MCUDMSG_II)
+#define BIT_GET_MCUDMSG_II(x)                                                  \
+	(((x) >> BIT_SHIFT_MCUDMSG_II) & BIT_MASK_MCUDMSG_II)
+
+/* 2 REG_FMETHR				(Offset 0x01C8) */
+
+#define BIT_FMSG_INT BIT(31)
+
+#define BIT_SHIFT_FW_MSG 0
+#define BIT_MASK_FW_MSG 0xffffffffL
+#define BIT_FW_MSG(x) (((x) & BIT_MASK_FW_MSG) << BIT_SHIFT_FW_MSG)
+#define BIT_GET_FW_MSG(x) (((x) >> BIT_SHIFT_FW_MSG) & BIT_MASK_FW_MSG)
+
+/* 2 REG_HMETFR				(Offset 0x01CC) */
+
+#define BIT_SHIFT_HRCV_MSG 24
+#define BIT_MASK_HRCV_MSG 0xff
+#define BIT_HRCV_MSG(x) (((x) & BIT_MASK_HRCV_MSG) << BIT_SHIFT_HRCV_MSG)
+#define BIT_GET_HRCV_MSG(x) (((x) >> BIT_SHIFT_HRCV_MSG) & BIT_MASK_HRCV_MSG)
+
+#define BIT_INT_BOX3 BIT(3)
+#define BIT_INT_BOX2 BIT(2)
+#define BIT_INT_BOX1 BIT(1)
+#define BIT_INT_BOX0 BIT(0)
+
+/* 2 REG_HMEBOX0				(Offset 0x01D0) */
+
+#define BIT_SHIFT_HOST_MSG_0 0
+#define BIT_MASK_HOST_MSG_0 0xffffffffL
+#define BIT_HOST_MSG_0(x) (((x) & BIT_MASK_HOST_MSG_0) << BIT_SHIFT_HOST_MSG_0)
+#define BIT_GET_HOST_MSG_0(x)                                                  \
+	(((x) >> BIT_SHIFT_HOST_MSG_0) & BIT_MASK_HOST_MSG_0)
+
+/* 2 REG_HMEBOX1				(Offset 0x01D4) */
+
+#define BIT_SHIFT_HOST_MSG_1 0
+#define BIT_MASK_HOST_MSG_1 0xffffffffL
+#define BIT_HOST_MSG_1(x) (((x) & BIT_MASK_HOST_MSG_1) << BIT_SHIFT_HOST_MSG_1)
+#define BIT_GET_HOST_MSG_1(x)                                                  \
+	(((x) >> BIT_SHIFT_HOST_MSG_1) & BIT_MASK_HOST_MSG_1)
+
+/* 2 REG_HMEBOX2				(Offset 0x01D8) */
+
+#define BIT_SHIFT_HOST_MSG_2 0
+#define BIT_MASK_HOST_MSG_2 0xffffffffL
+#define BIT_HOST_MSG_2(x) (((x) & BIT_MASK_HOST_MSG_2) << BIT_SHIFT_HOST_MSG_2)
+#define BIT_GET_HOST_MSG_2(x)                                                  \
+	(((x) >> BIT_SHIFT_HOST_MSG_2) & BIT_MASK_HOST_MSG_2)
+
+/* 2 REG_HMEBOX3				(Offset 0x01DC) */
+
+#define BIT_SHIFT_HOST_MSG_3 0
+#define BIT_MASK_HOST_MSG_3 0xffffffffL
+#define BIT_HOST_MSG_3(x) (((x) & BIT_MASK_HOST_MSG_3) << BIT_SHIFT_HOST_MSG_3)
+#define BIT_GET_HOST_MSG_3(x)                                                  \
+	(((x) >> BIT_SHIFT_HOST_MSG_3) & BIT_MASK_HOST_MSG_3)
+
+/* 2 REG_LLT_INIT				(Offset 0x01E0) */
+
+#define BIT_SHIFT_LLTE_RWM 30
+#define BIT_MASK_LLTE_RWM 0x3
+#define BIT_LLTE_RWM(x) (((x) & BIT_MASK_LLTE_RWM) << BIT_SHIFT_LLTE_RWM)
+#define BIT_GET_LLTE_RWM(x) (((x) >> BIT_SHIFT_LLTE_RWM) & BIT_MASK_LLTE_RWM)
+
+/* 2 REG_LLT_INIT				(Offset 0x01E0) */
+
+#define BIT_SHIFT_LLTINI_PDATA_V1 16
+#define BIT_MASK_LLTINI_PDATA_V1 0xfff
+#define BIT_LLTINI_PDATA_V1(x)                                                 \
+	(((x) & BIT_MASK_LLTINI_PDATA_V1) << BIT_SHIFT_LLTINI_PDATA_V1)
+#define BIT_GET_LLTINI_PDATA_V1(x)                                             \
+	(((x) >> BIT_SHIFT_LLTINI_PDATA_V1) & BIT_MASK_LLTINI_PDATA_V1)
+
+/* 2 REG_LLT_INIT				(Offset 0x01E0) */
+
+#define BIT_SHIFT_LLTINI_HDATA_V1 0
+#define BIT_MASK_LLTINI_HDATA_V1 0xfff
+#define BIT_LLTINI_HDATA_V1(x)                                                 \
+	(((x) & BIT_MASK_LLTINI_HDATA_V1) << BIT_SHIFT_LLTINI_HDATA_V1)
+#define BIT_GET_LLTINI_HDATA_V1(x)                                             \
+	(((x) >> BIT_SHIFT_LLTINI_HDATA_V1) & BIT_MASK_LLTINI_HDATA_V1)
+
+/* 2 REG_LLT_INIT_ADDR			(Offset 0x01E4) */
+
+#define BIT_SHIFT_LLTINI_ADDR_V1 0
+#define BIT_MASK_LLTINI_ADDR_V1 0xfff
+#define BIT_LLTINI_ADDR_V1(x)                                                  \
+	(((x) & BIT_MASK_LLTINI_ADDR_V1) << BIT_SHIFT_LLTINI_ADDR_V1)
+#define BIT_GET_LLTINI_ADDR_V1(x)                                              \
+	(((x) >> BIT_SHIFT_LLTINI_ADDR_V1) & BIT_MASK_LLTINI_ADDR_V1)
+
+/* 2 REG_BB_ACCESS_CTRL			(Offset 0x01E8) */
+
+#define BIT_SHIFT_BB_WRITE_READ 30
+#define BIT_MASK_BB_WRITE_READ 0x3
+#define BIT_BB_WRITE_READ(x)                                                   \
+	(((x) & BIT_MASK_BB_WRITE_READ) << BIT_SHIFT_BB_WRITE_READ)
+#define BIT_GET_BB_WRITE_READ(x)                                               \
+	(((x) >> BIT_SHIFT_BB_WRITE_READ) & BIT_MASK_BB_WRITE_READ)
+
+/* 2 REG_BB_ACCESS_CTRL			(Offset 0x01E8) */
+
+#define BIT_SHIFT_BB_WRITE_EN 12
+#define BIT_MASK_BB_WRITE_EN 0xf
+#define BIT_BB_WRITE_EN(x)                                                     \
+	(((x) & BIT_MASK_BB_WRITE_EN) << BIT_SHIFT_BB_WRITE_EN)
+#define BIT_GET_BB_WRITE_EN(x)                                                 \
+	(((x) >> BIT_SHIFT_BB_WRITE_EN) & BIT_MASK_BB_WRITE_EN)
+
+#define BIT_SHIFT_BB_ADDR 2
+#define BIT_MASK_BB_ADDR 0x1ff
+#define BIT_BB_ADDR(x) (((x) & BIT_MASK_BB_ADDR) << BIT_SHIFT_BB_ADDR)
+#define BIT_GET_BB_ADDR(x) (((x) >> BIT_SHIFT_BB_ADDR) & BIT_MASK_BB_ADDR)
+
+/* 2 REG_BB_ACCESS_CTRL			(Offset 0x01E8) */
+
+#define BIT_BB_ERRACC BIT(0)
+
+/* 2 REG_BB_ACCESS_DATA			(Offset 0x01EC) */
+
+#define BIT_SHIFT_BB_DATA 0
+#define BIT_MASK_BB_DATA 0xffffffffL
+#define BIT_BB_DATA(x) (((x) & BIT_MASK_BB_DATA) << BIT_SHIFT_BB_DATA)
+#define BIT_GET_BB_DATA(x) (((x) >> BIT_SHIFT_BB_DATA) & BIT_MASK_BB_DATA)
+
+/* 2 REG_HMEBOX_E0				(Offset 0x01F0) */
+
+#define BIT_SHIFT_HMEBOX_E0 0
+#define BIT_MASK_HMEBOX_E0 0xffffffffL
+#define BIT_HMEBOX_E0(x) (((x) & BIT_MASK_HMEBOX_E0) << BIT_SHIFT_HMEBOX_E0)
+#define BIT_GET_HMEBOX_E0(x) (((x) >> BIT_SHIFT_HMEBOX_E0) & BIT_MASK_HMEBOX_E0)
+
+/* 2 REG_HMEBOX_E1				(Offset 0x01F4) */
+
+#define BIT_SHIFT_HMEBOX_E1 0
+#define BIT_MASK_HMEBOX_E1 0xffffffffL
+#define BIT_HMEBOX_E1(x) (((x) & BIT_MASK_HMEBOX_E1) << BIT_SHIFT_HMEBOX_E1)
+#define BIT_GET_HMEBOX_E1(x) (((x) >> BIT_SHIFT_HMEBOX_E1) & BIT_MASK_HMEBOX_E1)
+
+/* 2 REG_HMEBOX_E2				(Offset 0x01F8) */
+
+#define BIT_SHIFT_HMEBOX_E2 0
+#define BIT_MASK_HMEBOX_E2 0xffffffffL
+#define BIT_HMEBOX_E2(x) (((x) & BIT_MASK_HMEBOX_E2) << BIT_SHIFT_HMEBOX_E2)
+#define BIT_GET_HMEBOX_E2(x) (((x) >> BIT_SHIFT_HMEBOX_E2) & BIT_MASK_HMEBOX_E2)
+
+/* 2 REG_HMEBOX_E3				(Offset 0x01FC) */
+
+#define BIT_LD_RQPN BIT(31)
+
+#define BIT_SHIFT_HMEBOX_E3 0
+#define BIT_MASK_HMEBOX_E3 0xffffffffL
+#define BIT_HMEBOX_E3(x) (((x) & BIT_MASK_HMEBOX_E3) << BIT_SHIFT_HMEBOX_E3)
+#define BIT_GET_HMEBOX_E3(x) (((x) >> BIT_SHIFT_HMEBOX_E3) & BIT_MASK_HMEBOX_E3)
+
+/* 2 REG_FIFOPAGE_CTRL_1			(Offset 0x0200) */
+
+#define BIT_SHIFT_TX_OQT_HE_FREE_SPACE_V1 16
+#define BIT_MASK_TX_OQT_HE_FREE_SPACE_V1 0xff
+#define BIT_TX_OQT_HE_FREE_SPACE_V1(x)                                         \
+	(((x) & BIT_MASK_TX_OQT_HE_FREE_SPACE_V1)                              \
+	 << BIT_SHIFT_TX_OQT_HE_FREE_SPACE_V1)
+#define BIT_GET_TX_OQT_HE_FREE_SPACE_V1(x)                                     \
+	(((x) >> BIT_SHIFT_TX_OQT_HE_FREE_SPACE_V1) &                          \
+	 BIT_MASK_TX_OQT_HE_FREE_SPACE_V1)
+
+/* 2 REG_FIFOPAGE_CTRL_1			(Offset 0x0200) */
+
+#define BIT_SHIFT_TX_OQT_NL_FREE_SPACE_V1 0
+#define BIT_MASK_TX_OQT_NL_FREE_SPACE_V1 0xff
+#define BIT_TX_OQT_NL_FREE_SPACE_V1(x)                                         \
+	(((x) & BIT_MASK_TX_OQT_NL_FREE_SPACE_V1)                              \
+	 << BIT_SHIFT_TX_OQT_NL_FREE_SPACE_V1)
+#define BIT_GET_TX_OQT_NL_FREE_SPACE_V1(x)                                     \
+	(((x) >> BIT_SHIFT_TX_OQT_NL_FREE_SPACE_V1) &                          \
+	 BIT_MASK_TX_OQT_NL_FREE_SPACE_V1)
+
+/* 2 REG_FIFOPAGE_CTRL_2			(Offset 0x0204) */
+
+#define BIT_BCN_VALID_1_V1 BIT(31)
+
+/* 2 REG_FIFOPAGE_CTRL_2			(Offset 0x0204) */
+
+#define BIT_SHIFT_BCN_HEAD_1_V1 16
+#define BIT_MASK_BCN_HEAD_1_V1 0xfff
+#define BIT_BCN_HEAD_1_V1(x)                                                   \
+	(((x) & BIT_MASK_BCN_HEAD_1_V1) << BIT_SHIFT_BCN_HEAD_1_V1)
+#define BIT_GET_BCN_HEAD_1_V1(x)                                               \
+	(((x) >> BIT_SHIFT_BCN_HEAD_1_V1) & BIT_MASK_BCN_HEAD_1_V1)
+
+#define BIT_BCN_VALID_V1 BIT(15)
+
+/* 2 REG_FIFOPAGE_CTRL_2			(Offset 0x0204) */
+
+#define BIT_SHIFT_BCN_HEAD_V1 0
+#define BIT_MASK_BCN_HEAD_V1 0xfff
+#define BIT_BCN_HEAD_V1(x)                                                     \
+	(((x) & BIT_MASK_BCN_HEAD_V1) << BIT_SHIFT_BCN_HEAD_V1)
+#define BIT_GET_BCN_HEAD_V1(x)                                                 \
+	(((x) >> BIT_SHIFT_BCN_HEAD_V1) & BIT_MASK_BCN_HEAD_V1)
+
+/* 2 REG_AUTO_LLT_V1				(Offset 0x0208) */
+
+#define BIT_SHIFT_MAX_TX_PKT_FOR_USB_AND_SDIO_V1 24
+#define BIT_MASK_MAX_TX_PKT_FOR_USB_AND_SDIO_V1 0xff
+#define BIT_MAX_TX_PKT_FOR_USB_AND_SDIO_V1(x)                                  \
+	(((x) & BIT_MASK_MAX_TX_PKT_FOR_USB_AND_SDIO_V1)                       \
+	 << BIT_SHIFT_MAX_TX_PKT_FOR_USB_AND_SDIO_V1)
+#define BIT_GET_MAX_TX_PKT_FOR_USB_AND_SDIO_V1(x)                              \
+	(((x) >> BIT_SHIFT_MAX_TX_PKT_FOR_USB_AND_SDIO_V1) &                   \
+	 BIT_MASK_MAX_TX_PKT_FOR_USB_AND_SDIO_V1)
+
+/* 2 REG_AUTO_LLT_V1				(Offset 0x0208) */
+
+#define BIT_SHIFT_LLT_FREE_PAGE_V1 8
+#define BIT_MASK_LLT_FREE_PAGE_V1 0xffff
+#define BIT_LLT_FREE_PAGE_V1(x)                                                \
+	(((x) & BIT_MASK_LLT_FREE_PAGE_V1) << BIT_SHIFT_LLT_FREE_PAGE_V1)
+#define BIT_GET_LLT_FREE_PAGE_V1(x)                                            \
+	(((x) >> BIT_SHIFT_LLT_FREE_PAGE_V1) & BIT_MASK_LLT_FREE_PAGE_V1)
+
+/* 2 REG_DWBCN0_CTRL				(Offset 0x0208) */
+
+#define BIT_SHIFT_BLK_DESC_NUM 4
+#define BIT_MASK_BLK_DESC_NUM 0xf
+#define BIT_BLK_DESC_NUM(x)                                                    \
+	(((x) & BIT_MASK_BLK_DESC_NUM) << BIT_SHIFT_BLK_DESC_NUM)
+#define BIT_GET_BLK_DESC_NUM(x)                                                \
+	(((x) >> BIT_SHIFT_BLK_DESC_NUM) & BIT_MASK_BLK_DESC_NUM)
+
+/* 2 REG_AUTO_LLT_V1				(Offset 0x0208) */
+
+#define BIT_R_BCN_HEAD_SEL BIT(3)
+#define BIT_R_EN_BCN_SW_HEAD_SEL BIT(2)
+#define BIT_LLT_DBG_SEL BIT(1)
+#define BIT_AUTO_INIT_LLT_V1 BIT(0)
+
+/* 2 REG_TXDMA_OFFSET_CHK			(Offset 0x020C) */
+
+#define BIT_EM_CHKSUM_FIN BIT(31)
+#define BIT_EMN_PCIE_DMA_MOD BIT(30)
+
+/* 2 REG_TXDMA_OFFSET_CHK			(Offset 0x020C) */
+
+#define BIT_EN_TXQUE_CLR BIT(29)
+#define BIT_EN_PCIE_FIFO_MODE BIT(28)
+
+/* 2 REG_TXDMA_OFFSET_CHK			(Offset 0x020C) */
+
+#define BIT_SHIFT_PG_UNDER_TH_V1 16
+#define BIT_MASK_PG_UNDER_TH_V1 0xfff
+#define BIT_PG_UNDER_TH_V1(x)                                                  \
+	(((x) & BIT_MASK_PG_UNDER_TH_V1) << BIT_SHIFT_PG_UNDER_TH_V1)
+#define BIT_GET_PG_UNDER_TH_V1(x)                                              \
+	(((x) >> BIT_SHIFT_PG_UNDER_TH_V1) & BIT_MASK_PG_UNDER_TH_V1)
+
+/* 2 REG_TXDMA_OFFSET_CHK			(Offset 0x020C) */
+
+#define BIT_RESTORE_H2C_ADDRESS BIT(15)
+
+/* 2 REG_TXDMA_OFFSET_CHK			(Offset 0x020C) */
+
+#define BIT_SDIO_TXDESC_CHKSUM_EN BIT(13)
+#define BIT_RST_RDPTR BIT(12)
+#define BIT_RST_WRPTR BIT(11)
+#define BIT_CHK_PG_TH_EN BIT(10)
+#define BIT_DROP_DATA_EN BIT(9)
+#define BIT_CHECK_OFFSET_EN BIT(8)
+
+#define BIT_SHIFT_CHECK_OFFSET 0
+#define BIT_MASK_CHECK_OFFSET 0xff
+#define BIT_CHECK_OFFSET(x)                                                    \
+	(((x) & BIT_MASK_CHECK_OFFSET) << BIT_SHIFT_CHECK_OFFSET)
+#define BIT_GET_CHECK_OFFSET(x)                                                \
+	(((x) >> BIT_SHIFT_CHECK_OFFSET) & BIT_MASK_CHECK_OFFSET)
+
+/* 2 REG_TXDMA_STATUS			(Offset 0x0210) */
+
+#define BIT_HI_OQT_UDN BIT(17)
+#define BIT_HI_OQT_OVF BIT(16)
+#define BIT_PAYLOAD_CHKSUM_ERR BIT(15)
+#define BIT_PAYLOAD_UDN BIT(14)
+#define BIT_PAYLOAD_OVF BIT(13)
+#define BIT_DSC_CHKSUM_FAIL BIT(12)
+#define BIT_UNKNOWN_QSEL BIT(11)
+#define BIT_EP_QSEL_DIFF BIT(10)
+#define BIT_TX_OFFS_UNMATCH BIT(9)
+#define BIT_TXOQT_UDN BIT(8)
+#define BIT_TXOQT_OVF BIT(7)
+#define BIT_TXDMA_SFF_UDN BIT(6)
+#define BIT_TXDMA_SFF_OVF BIT(5)
+#define BIT_LLT_NULL_PG BIT(4)
+#define BIT_PAGE_UDN BIT(3)
+#define BIT_PAGE_OVF BIT(2)
+#define BIT_TXFF_PG_UDN BIT(1)
+#define BIT_TXFF_PG_OVF BIT(0)
+
+/* 2 REG_TQPNT1				(Offset 0x0218) */
+
+#define BIT_SHIFT_HPQ_HIGH_TH_V1 16
+#define BIT_MASK_HPQ_HIGH_TH_V1 0xfff
+#define BIT_HPQ_HIGH_TH_V1(x)                                                  \
+	(((x) & BIT_MASK_HPQ_HIGH_TH_V1) << BIT_SHIFT_HPQ_HIGH_TH_V1)
+#define BIT_GET_HPQ_HIGH_TH_V1(x)                                              \
+	(((x) >> BIT_SHIFT_HPQ_HIGH_TH_V1) & BIT_MASK_HPQ_HIGH_TH_V1)
+
+/* 2 REG_TQPNT1				(Offset 0x0218) */
+
+#define BIT_SHIFT_HPQ_LOW_TH_V1 0
+#define BIT_MASK_HPQ_LOW_TH_V1 0xfff
+#define BIT_HPQ_LOW_TH_V1(x)                                                   \
+	(((x) & BIT_MASK_HPQ_LOW_TH_V1) << BIT_SHIFT_HPQ_LOW_TH_V1)
+#define BIT_GET_HPQ_LOW_TH_V1(x)                                               \
+	(((x) >> BIT_SHIFT_HPQ_LOW_TH_V1) & BIT_MASK_HPQ_LOW_TH_V1)
+
+/* 2 REG_TQPNT2				(Offset 0x021C) */
+
+#define BIT_SHIFT_NPQ_HIGH_TH_V1 16
+#define BIT_MASK_NPQ_HIGH_TH_V1 0xfff
+#define BIT_NPQ_HIGH_TH_V1(x)                                                  \
+	(((x) & BIT_MASK_NPQ_HIGH_TH_V1) << BIT_SHIFT_NPQ_HIGH_TH_V1)
+#define BIT_GET_NPQ_HIGH_TH_V1(x)                                              \
+	(((x) >> BIT_SHIFT_NPQ_HIGH_TH_V1) & BIT_MASK_NPQ_HIGH_TH_V1)
+
+/* 2 REG_TQPNT2				(Offset 0x021C) */
+
+#define BIT_SHIFT_NPQ_LOW_TH_V1 0
+#define BIT_MASK_NPQ_LOW_TH_V1 0xfff
+#define BIT_NPQ_LOW_TH_V1(x)                                                   \
+	(((x) & BIT_MASK_NPQ_LOW_TH_V1) << BIT_SHIFT_NPQ_LOW_TH_V1)
+#define BIT_GET_NPQ_LOW_TH_V1(x)                                               \
+	(((x) >> BIT_SHIFT_NPQ_LOW_TH_V1) & BIT_MASK_NPQ_LOW_TH_V1)
+
+/* 2 REG_TQPNT3				(Offset 0x0220) */
+
+#define BIT_SHIFT_LPQ_HIGH_TH_V1 16
+#define BIT_MASK_LPQ_HIGH_TH_V1 0xfff
+#define BIT_LPQ_HIGH_TH_V1(x)                                                  \
+	(((x) & BIT_MASK_LPQ_HIGH_TH_V1) << BIT_SHIFT_LPQ_HIGH_TH_V1)
+#define BIT_GET_LPQ_HIGH_TH_V1(x)                                              \
+	(((x) >> BIT_SHIFT_LPQ_HIGH_TH_V1) & BIT_MASK_LPQ_HIGH_TH_V1)
+
+/* 2 REG_TQPNT3				(Offset 0x0220) */
+
+#define BIT_SHIFT_LPQ_LOW_TH_V1 0
+#define BIT_MASK_LPQ_LOW_TH_V1 0xfff
+#define BIT_LPQ_LOW_TH_V1(x)                                                   \
+	(((x) & BIT_MASK_LPQ_LOW_TH_V1) << BIT_SHIFT_LPQ_LOW_TH_V1)
+#define BIT_GET_LPQ_LOW_TH_V1(x)                                               \
+	(((x) >> BIT_SHIFT_LPQ_LOW_TH_V1) & BIT_MASK_LPQ_LOW_TH_V1)
+
+/* 2 REG_TQPNT4				(Offset 0x0224) */
+
+#define BIT_SHIFT_EXQ_HIGH_TH_V1 16
+#define BIT_MASK_EXQ_HIGH_TH_V1 0xfff
+#define BIT_EXQ_HIGH_TH_V1(x)                                                  \
+	(((x) & BIT_MASK_EXQ_HIGH_TH_V1) << BIT_SHIFT_EXQ_HIGH_TH_V1)
+#define BIT_GET_EXQ_HIGH_TH_V1(x)                                              \
+	(((x) >> BIT_SHIFT_EXQ_HIGH_TH_V1) & BIT_MASK_EXQ_HIGH_TH_V1)
+
+/* 2 REG_TQPNT4				(Offset 0x0224) */
+
+#define BIT_SHIFT_EXQ_LOW_TH_V1 0
+#define BIT_MASK_EXQ_LOW_TH_V1 0xfff
+#define BIT_EXQ_LOW_TH_V1(x)                                                   \
+	(((x) & BIT_MASK_EXQ_LOW_TH_V1) << BIT_SHIFT_EXQ_LOW_TH_V1)
+#define BIT_GET_EXQ_LOW_TH_V1(x)                                               \
+	(((x) >> BIT_SHIFT_EXQ_LOW_TH_V1) & BIT_MASK_EXQ_LOW_TH_V1)
+
+/* 2 REG_RQPN_CTRL_1				(Offset 0x0228) */
+
+#define BIT_SHIFT_TXPKTNUM_H 16
+#define BIT_MASK_TXPKTNUM_H 0xffff
+#define BIT_TXPKTNUM_H(x) (((x) & BIT_MASK_TXPKTNUM_H) << BIT_SHIFT_TXPKTNUM_H)
+#define BIT_GET_TXPKTNUM_H(x)                                                  \
+	(((x) >> BIT_SHIFT_TXPKTNUM_H) & BIT_MASK_TXPKTNUM_H)
+
+/* 2 REG_RQPN_CTRL_1				(Offset 0x0228) */
+
+#define BIT_SHIFT_TXPKTNUM_V2 0
+#define BIT_MASK_TXPKTNUM_V2 0xffff
+#define BIT_TXPKTNUM_V2(x)                                                     \
+	(((x) & BIT_MASK_TXPKTNUM_V2) << BIT_SHIFT_TXPKTNUM_V2)
+#define BIT_GET_TXPKTNUM_V2(x)                                                 \
+	(((x) >> BIT_SHIFT_TXPKTNUM_V2) & BIT_MASK_TXPKTNUM_V2)
+
+/* 2 REG_RQPN_CTRL_2				(Offset 0x022C) */
+
+#define BIT_EXQ_PUBLIC_DIS_V1 BIT(19)
+#define BIT_NPQ_PUBLIC_DIS_V1 BIT(18)
+#define BIT_LPQ_PUBLIC_DIS_V1 BIT(17)
+#define BIT_HPQ_PUBLIC_DIS_V1 BIT(16)
+
+/* 2 REG_FIFOPAGE_INFO_1			(Offset 0x0230) */
+
+#define BIT_SHIFT_HPQ_AVAL_PG_V1 16
+#define BIT_MASK_HPQ_AVAL_PG_V1 0xfff
+#define BIT_HPQ_AVAL_PG_V1(x)                                                  \
+	(((x) & BIT_MASK_HPQ_AVAL_PG_V1) << BIT_SHIFT_HPQ_AVAL_PG_V1)
+#define BIT_GET_HPQ_AVAL_PG_V1(x)                                              \
+	(((x) >> BIT_SHIFT_HPQ_AVAL_PG_V1) & BIT_MASK_HPQ_AVAL_PG_V1)
+
+#define BIT_SHIFT_HPQ_V1 0
+#define BIT_MASK_HPQ_V1 0xfff
+#define BIT_HPQ_V1(x) (((x) & BIT_MASK_HPQ_V1) << BIT_SHIFT_HPQ_V1)
+#define BIT_GET_HPQ_V1(x) (((x) >> BIT_SHIFT_HPQ_V1) & BIT_MASK_HPQ_V1)
+
+/* 2 REG_FIFOPAGE_INFO_2			(Offset 0x0234) */
+
+#define BIT_SHIFT_LPQ_AVAL_PG_V1 16
+#define BIT_MASK_LPQ_AVAL_PG_V1 0xfff
+#define BIT_LPQ_AVAL_PG_V1(x)                                                  \
+	(((x) & BIT_MASK_LPQ_AVAL_PG_V1) << BIT_SHIFT_LPQ_AVAL_PG_V1)
+#define BIT_GET_LPQ_AVAL_PG_V1(x)                                              \
+	(((x) >> BIT_SHIFT_LPQ_AVAL_PG_V1) & BIT_MASK_LPQ_AVAL_PG_V1)
+
+#define BIT_SHIFT_LPQ_V1 0
+#define BIT_MASK_LPQ_V1 0xfff
+#define BIT_LPQ_V1(x) (((x) & BIT_MASK_LPQ_V1) << BIT_SHIFT_LPQ_V1)
+#define BIT_GET_LPQ_V1(x) (((x) >> BIT_SHIFT_LPQ_V1) & BIT_MASK_LPQ_V1)
+
+/* 2 REG_FIFOPAGE_INFO_3			(Offset 0x0238) */
+
+#define BIT_SHIFT_NPQ_AVAL_PG_V1 16
+#define BIT_MASK_NPQ_AVAL_PG_V1 0xfff
+#define BIT_NPQ_AVAL_PG_V1(x)                                                  \
+	(((x) & BIT_MASK_NPQ_AVAL_PG_V1) << BIT_SHIFT_NPQ_AVAL_PG_V1)
+#define BIT_GET_NPQ_AVAL_PG_V1(x)                                              \
+	(((x) >> BIT_SHIFT_NPQ_AVAL_PG_V1) & BIT_MASK_NPQ_AVAL_PG_V1)
+
+/* 2 REG_FIFOPAGE_INFO_3			(Offset 0x0238) */
+
+#define BIT_SHIFT_NPQ_V1 0
+#define BIT_MASK_NPQ_V1 0xfff
+#define BIT_NPQ_V1(x) (((x) & BIT_MASK_NPQ_V1) << BIT_SHIFT_NPQ_V1)
+#define BIT_GET_NPQ_V1(x) (((x) >> BIT_SHIFT_NPQ_V1) & BIT_MASK_NPQ_V1)
+
+/* 2 REG_FIFOPAGE_INFO_4			(Offset 0x023C) */
+
+#define BIT_SHIFT_EXQ_AVAL_PG_V1 16
+#define BIT_MASK_EXQ_AVAL_PG_V1 0xfff
+#define BIT_EXQ_AVAL_PG_V1(x)                                                  \
+	(((x) & BIT_MASK_EXQ_AVAL_PG_V1) << BIT_SHIFT_EXQ_AVAL_PG_V1)
+#define BIT_GET_EXQ_AVAL_PG_V1(x)                                              \
+	(((x) >> BIT_SHIFT_EXQ_AVAL_PG_V1) & BIT_MASK_EXQ_AVAL_PG_V1)
+
+#define BIT_SHIFT_EXQ_V1 0
+#define BIT_MASK_EXQ_V1 0xfff
+#define BIT_EXQ_V1(x) (((x) & BIT_MASK_EXQ_V1) << BIT_SHIFT_EXQ_V1)
+#define BIT_GET_EXQ_V1(x) (((x) >> BIT_SHIFT_EXQ_V1) & BIT_MASK_EXQ_V1)
+
+/* 2 REG_FIFOPAGE_INFO_5			(Offset 0x0240) */
+
+#define BIT_SHIFT_PUBQ_AVAL_PG_V1 16
+#define BIT_MASK_PUBQ_AVAL_PG_V1 0xfff
+#define BIT_PUBQ_AVAL_PG_V1(x)                                                 \
+	(((x) & BIT_MASK_PUBQ_AVAL_PG_V1) << BIT_SHIFT_PUBQ_AVAL_PG_V1)
+#define BIT_GET_PUBQ_AVAL_PG_V1(x)                                             \
+	(((x) >> BIT_SHIFT_PUBQ_AVAL_PG_V1) & BIT_MASK_PUBQ_AVAL_PG_V1)
+
+#define BIT_SHIFT_PUBQ_V1 0
+#define BIT_MASK_PUBQ_V1 0xfff
+#define BIT_PUBQ_V1(x) (((x) & BIT_MASK_PUBQ_V1) << BIT_SHIFT_PUBQ_V1)
+#define BIT_GET_PUBQ_V1(x) (((x) >> BIT_SHIFT_PUBQ_V1) & BIT_MASK_PUBQ_V1)
+
+/* 2 REG_H2C_HEAD				(Offset 0x0244) */
+
+#define BIT_SHIFT_H2C_HEAD 0
+#define BIT_MASK_H2C_HEAD 0x3ffff
+#define BIT_H2C_HEAD(x) (((x) & BIT_MASK_H2C_HEAD) << BIT_SHIFT_H2C_HEAD)
+#define BIT_GET_H2C_HEAD(x) (((x) >> BIT_SHIFT_H2C_HEAD) & BIT_MASK_H2C_HEAD)
+
+/* 2 REG_H2C_TAIL				(Offset 0x0248) */
+
+#define BIT_SHIFT_H2C_TAIL 0
+#define BIT_MASK_H2C_TAIL 0x3ffff
+#define BIT_H2C_TAIL(x) (((x) & BIT_MASK_H2C_TAIL) << BIT_SHIFT_H2C_TAIL)
+#define BIT_GET_H2C_TAIL(x) (((x) >> BIT_SHIFT_H2C_TAIL) & BIT_MASK_H2C_TAIL)
+
+/* 2 REG_H2C_READ_ADDR			(Offset 0x024C) */
+
+#define BIT_SHIFT_H2C_READ_ADDR 0
+#define BIT_MASK_H2C_READ_ADDR 0x3ffff
+#define BIT_H2C_READ_ADDR(x)                                                   \
+	(((x) & BIT_MASK_H2C_READ_ADDR) << BIT_SHIFT_H2C_READ_ADDR)
+#define BIT_GET_H2C_READ_ADDR(x)                                               \
+	(((x) >> BIT_SHIFT_H2C_READ_ADDR) & BIT_MASK_H2C_READ_ADDR)
+
+/* 2 REG_H2C_WR_ADDR				(Offset 0x0250) */
+
+#define BIT_SHIFT_H2C_WR_ADDR 0
+#define BIT_MASK_H2C_WR_ADDR 0x3ffff
+#define BIT_H2C_WR_ADDR(x)                                                     \
+	(((x) & BIT_MASK_H2C_WR_ADDR) << BIT_SHIFT_H2C_WR_ADDR)
+#define BIT_GET_H2C_WR_ADDR(x)                                                 \
+	(((x) >> BIT_SHIFT_H2C_WR_ADDR) & BIT_MASK_H2C_WR_ADDR)
+
+/* 2 REG_H2C_INFO				(Offset 0x0254) */
+
+#define BIT_H2C_SPACE_VLD BIT(3)
+#define BIT_H2C_WR_ADDR_RST BIT(2)
+
+#define BIT_SHIFT_H2C_LEN_SEL 0
+#define BIT_MASK_H2C_LEN_SEL 0x3
+#define BIT_H2C_LEN_SEL(x)                                                     \
+	(((x) & BIT_MASK_H2C_LEN_SEL) << BIT_SHIFT_H2C_LEN_SEL)
+#define BIT_GET_H2C_LEN_SEL(x)                                                 \
+	(((x) >> BIT_SHIFT_H2C_LEN_SEL) & BIT_MASK_H2C_LEN_SEL)
+
+/* 2 REG_RXDMA_AGG_PG_TH			(Offset 0x0280) */
+
+#define BIT_SHIFT_RXDMA_AGG_OLD_MOD 24
+#define BIT_MASK_RXDMA_AGG_OLD_MOD 0xff
+#define BIT_RXDMA_AGG_OLD_MOD(x)                                               \
+	(((x) & BIT_MASK_RXDMA_AGG_OLD_MOD) << BIT_SHIFT_RXDMA_AGG_OLD_MOD)
+#define BIT_GET_RXDMA_AGG_OLD_MOD(x)                                           \
+	(((x) >> BIT_SHIFT_RXDMA_AGG_OLD_MOD) & BIT_MASK_RXDMA_AGG_OLD_MOD)
+
+/* 2 REG_RXDMA_AGG_PG_TH			(Offset 0x0280) */
+
+#define BIT_SHIFT_PKT_NUM_WOL 16
+#define BIT_MASK_PKT_NUM_WOL 0xff
+#define BIT_PKT_NUM_WOL(x)                                                     \
+	(((x) & BIT_MASK_PKT_NUM_WOL) << BIT_SHIFT_PKT_NUM_WOL)
+#define BIT_GET_PKT_NUM_WOL(x)                                                 \
+	(((x) >> BIT_SHIFT_PKT_NUM_WOL) & BIT_MASK_PKT_NUM_WOL)
+
+/* 2 REG_RXDMA_AGG_PG_TH			(Offset 0x0280) */
+
+#define BIT_SHIFT_DMA_AGG_TO 8
+#define BIT_MASK_DMA_AGG_TO 0xf
+#define BIT_DMA_AGG_TO(x) (((x) & BIT_MASK_DMA_AGG_TO) << BIT_SHIFT_DMA_AGG_TO)
+#define BIT_GET_DMA_AGG_TO(x)                                                  \
+	(((x) >> BIT_SHIFT_DMA_AGG_TO) & BIT_MASK_DMA_AGG_TO)
+
+/* 2 REG_RXDMA_AGG_PG_TH			(Offset 0x0280) */
+
+#define BIT_SHIFT_RXDMA_AGG_PG_TH_V1 0
+#define BIT_MASK_RXDMA_AGG_PG_TH_V1 0xf
+#define BIT_RXDMA_AGG_PG_TH_V1(x)                                              \
+	(((x) & BIT_MASK_RXDMA_AGG_PG_TH_V1) << BIT_SHIFT_RXDMA_AGG_PG_TH_V1)
+#define BIT_GET_RXDMA_AGG_PG_TH_V1(x)                                          \
+	(((x) >> BIT_SHIFT_RXDMA_AGG_PG_TH_V1) & BIT_MASK_RXDMA_AGG_PG_TH_V1)
+
+/* 2 REG_RXPKT_NUM				(Offset 0x0284) */
+
+#define BIT_SHIFT_RXPKT_NUM 24
+#define BIT_MASK_RXPKT_NUM 0xff
+#define BIT_RXPKT_NUM(x) (((x) & BIT_MASK_RXPKT_NUM) << BIT_SHIFT_RXPKT_NUM)
+#define BIT_GET_RXPKT_NUM(x) (((x) >> BIT_SHIFT_RXPKT_NUM) & BIT_MASK_RXPKT_NUM)
+
+/* 2 REG_RXPKT_NUM				(Offset 0x0284) */
+
+#define BIT_SHIFT_FW_UPD_RDPTR19_TO_16 20
+#define BIT_MASK_FW_UPD_RDPTR19_TO_16 0xf
+#define BIT_FW_UPD_RDPTR19_TO_16(x)                                            \
+	(((x) & BIT_MASK_FW_UPD_RDPTR19_TO_16)                                 \
+	 << BIT_SHIFT_FW_UPD_RDPTR19_TO_16)
+#define BIT_GET_FW_UPD_RDPTR19_TO_16(x)                                        \
+	(((x) >> BIT_SHIFT_FW_UPD_RDPTR19_TO_16) &                             \
+	 BIT_MASK_FW_UPD_RDPTR19_TO_16)
+
+/* 2 REG_RXPKT_NUM				(Offset 0x0284) */
+
+#define BIT_RXDMA_REQ BIT(19)
+#define BIT_RW_RELEASE_EN BIT(18)
+#define BIT_RXDMA_IDLE BIT(17)
+#define BIT_RXPKT_RELEASE_POLL BIT(16)
+
+#define BIT_SHIFT_FW_UPD_RDPTR 0
+#define BIT_MASK_FW_UPD_RDPTR 0xffff
+#define BIT_FW_UPD_RDPTR(x)                                                    \
+	(((x) & BIT_MASK_FW_UPD_RDPTR) << BIT_SHIFT_FW_UPD_RDPTR)
+#define BIT_GET_FW_UPD_RDPTR(x)                                                \
+	(((x) >> BIT_SHIFT_FW_UPD_RDPTR) & BIT_MASK_FW_UPD_RDPTR)
+
+/* 2 REG_RXDMA_STATUS			(Offset 0x0288) */
+
+#define BIT_C2H_PKT_OVF BIT(7)
+
+/* 2 REG_RXDMA_STATUS			(Offset 0x0288) */
+
+#define BIT_AGG_CONFGI_ISSUE BIT(6)
+
+/* 2 REG_RXDMA_STATUS			(Offset 0x0288) */
+
+#define BIT_FW_POLL_ISSUE BIT(5)
+#define BIT_RX_DATA_UDN BIT(4)
+#define BIT_RX_SFF_UDN BIT(3)
+#define BIT_RX_SFF_OVF BIT(2)
+
+/* 2 REG_RXDMA_STATUS			(Offset 0x0288) */
+
+#define BIT_RXPKT_OVF BIT(0)
+
+/* 2 REG_RXDMA_DPR				(Offset 0x028C) */
+
+#define BIT_SHIFT_RDE_DEBUG 0
+#define BIT_MASK_RDE_DEBUG 0xffffffffL
+#define BIT_RDE_DEBUG(x) (((x) & BIT_MASK_RDE_DEBUG) << BIT_SHIFT_RDE_DEBUG)
+#define BIT_GET_RDE_DEBUG(x) (((x) >> BIT_SHIFT_RDE_DEBUG) & BIT_MASK_RDE_DEBUG)
+
+/* 2 REG_RXDMA_MODE				(Offset 0x0290) */
+
+#define BIT_SHIFT_PKTNUM_TH_V2 24
+#define BIT_MASK_PKTNUM_TH_V2 0x1f
+#define BIT_PKTNUM_TH_V2(x)                                                    \
+	(((x) & BIT_MASK_PKTNUM_TH_V2) << BIT_SHIFT_PKTNUM_TH_V2)
+#define BIT_GET_PKTNUM_TH_V2(x)                                                \
+	(((x) >> BIT_SHIFT_PKTNUM_TH_V2) & BIT_MASK_PKTNUM_TH_V2)
+
+#define BIT_TXBA_BREAK_USBAGG BIT(23)
+
+#define BIT_SHIFT_PKTLEN_PARA 16
+#define BIT_MASK_PKTLEN_PARA 0x7
+#define BIT_PKTLEN_PARA(x)                                                     \
+	(((x) & BIT_MASK_PKTLEN_PARA) << BIT_SHIFT_PKTLEN_PARA)
+#define BIT_GET_PKTLEN_PARA(x)                                                 \
+	(((x) >> BIT_SHIFT_PKTLEN_PARA) & BIT_MASK_PKTLEN_PARA)
+
+/* 2 REG_RXDMA_MODE				(Offset 0x0290) */
+
+#define BIT_SHIFT_BURST_SIZE 4
+#define BIT_MASK_BURST_SIZE 0x3
+#define BIT_BURST_SIZE(x) (((x) & BIT_MASK_BURST_SIZE) << BIT_SHIFT_BURST_SIZE)
+#define BIT_GET_BURST_SIZE(x)                                                  \
+	(((x) >> BIT_SHIFT_BURST_SIZE) & BIT_MASK_BURST_SIZE)
+
+#define BIT_SHIFT_BURST_CNT 2
+#define BIT_MASK_BURST_CNT 0x3
+#define BIT_BURST_CNT(x) (((x) & BIT_MASK_BURST_CNT) << BIT_SHIFT_BURST_CNT)
+#define BIT_GET_BURST_CNT(x) (((x) >> BIT_SHIFT_BURST_CNT) & BIT_MASK_BURST_CNT)
+
+/* 2 REG_RXDMA_MODE				(Offset 0x0290) */
+
+#define BIT_DMA_MODE BIT(1)
+
+/* 2 REG_C2H_PKT				(Offset 0x0294) */
+
+#define BIT_SHIFT_R_C2H_STR_ADDR_16_TO_19 24
+#define BIT_MASK_R_C2H_STR_ADDR_16_TO_19 0xf
+#define BIT_R_C2H_STR_ADDR_16_TO_19(x)                                         \
+	(((x) & BIT_MASK_R_C2H_STR_ADDR_16_TO_19)                              \
+	 << BIT_SHIFT_R_C2H_STR_ADDR_16_TO_19)
+#define BIT_GET_R_C2H_STR_ADDR_16_TO_19(x)                                     \
+	(((x) >> BIT_SHIFT_R_C2H_STR_ADDR_16_TO_19) &                          \
+	 BIT_MASK_R_C2H_STR_ADDR_16_TO_19)
+
+#define BIT_SHIFT_MDIO_PHY_ADDR 24
+#define BIT_MASK_MDIO_PHY_ADDR 0x1f
+#define BIT_MDIO_PHY_ADDR(x)                                                   \
+	(((x) & BIT_MASK_MDIO_PHY_ADDR) << BIT_SHIFT_MDIO_PHY_ADDR)
+#define BIT_GET_MDIO_PHY_ADDR(x)                                               \
+	(((x) >> BIT_SHIFT_MDIO_PHY_ADDR) & BIT_MASK_MDIO_PHY_ADDR)
+
+/* 2 REG_C2H_PKT				(Offset 0x0294) */
+
+#define BIT_R_C2H_PKT_REQ BIT(16)
+#define BIT_RX_CLOSE_EN BIT(15)
+#define BIT_STOP_BCNQ BIT(14)
+#define BIT_STOP_MGQ BIT(13)
+#define BIT_STOP_VOQ BIT(12)
+#define BIT_STOP_VIQ BIT(11)
+#define BIT_STOP_BEQ BIT(10)
+#define BIT_STOP_BKQ BIT(9)
+#define BIT_STOP_RXQ BIT(8)
+#define BIT_STOP_HI7Q BIT(7)
+#define BIT_STOP_HI6Q BIT(6)
+#define BIT_STOP_HI5Q BIT(5)
+#define BIT_STOP_HI4Q BIT(4)
+#define BIT_STOP_HI3Q BIT(3)
+#define BIT_STOP_HI2Q BIT(2)
+#define BIT_STOP_HI1Q BIT(1)
+
+#define BIT_SHIFT_R_C2H_STR_ADDR 0
+#define BIT_MASK_R_C2H_STR_ADDR 0xffff
+#define BIT_R_C2H_STR_ADDR(x)                                                  \
+	(((x) & BIT_MASK_R_C2H_STR_ADDR) << BIT_SHIFT_R_C2H_STR_ADDR)
+#define BIT_GET_R_C2H_STR_ADDR(x)                                              \
+	(((x) >> BIT_SHIFT_R_C2H_STR_ADDR) & BIT_MASK_R_C2H_STR_ADDR)
+
+#define BIT_STOP_HI0Q BIT(0)
+
+/* 2 REG_FWFF_C2H				(Offset 0x0298) */
+
+#define BIT_SHIFT_C2H_DMA_ADDR 0
+#define BIT_MASK_C2H_DMA_ADDR 0x3ffff
+#define BIT_C2H_DMA_ADDR(x)                                                    \
+	(((x) & BIT_MASK_C2H_DMA_ADDR) << BIT_SHIFT_C2H_DMA_ADDR)
+#define BIT_GET_C2H_DMA_ADDR(x)                                                \
+	(((x) >> BIT_SHIFT_C2H_DMA_ADDR) & BIT_MASK_C2H_DMA_ADDR)
+
+/* 2 REG_FWFF_CTRL				(Offset 0x029C) */
+
+#define BIT_FWFF_DMAPKT_REQ BIT(31)
+
+#define BIT_SHIFT_FWFF_DMA_PKT_NUM 16
+#define BIT_MASK_FWFF_DMA_PKT_NUM 0xff
+#define BIT_FWFF_DMA_PKT_NUM(x)                                                \
+	(((x) & BIT_MASK_FWFF_DMA_PKT_NUM) << BIT_SHIFT_FWFF_DMA_PKT_NUM)
+#define BIT_GET_FWFF_DMA_PKT_NUM(x)                                            \
+	(((x) >> BIT_SHIFT_FWFF_DMA_PKT_NUM) & BIT_MASK_FWFF_DMA_PKT_NUM)
+
+#define BIT_SHIFT_FWFF_STR_ADDR 0
+#define BIT_MASK_FWFF_STR_ADDR 0xffff
+#define BIT_FWFF_STR_ADDR(x)                                                   \
+	(((x) & BIT_MASK_FWFF_STR_ADDR) << BIT_SHIFT_FWFF_STR_ADDR)
+#define BIT_GET_FWFF_STR_ADDR(x)                                               \
+	(((x) >> BIT_SHIFT_FWFF_STR_ADDR) & BIT_MASK_FWFF_STR_ADDR)
+
+/* 2 REG_FWFF_PKT_INFO			(Offset 0x02A0) */
+
+#define BIT_SHIFT_FWFF_PKT_QUEUED 16
+#define BIT_MASK_FWFF_PKT_QUEUED 0xff
+#define BIT_FWFF_PKT_QUEUED(x)                                                 \
+	(((x) & BIT_MASK_FWFF_PKT_QUEUED) << BIT_SHIFT_FWFF_PKT_QUEUED)
+#define BIT_GET_FWFF_PKT_QUEUED(x)                                             \
+	(((x) >> BIT_SHIFT_FWFF_PKT_QUEUED) & BIT_MASK_FWFF_PKT_QUEUED)
+
+/* 2 REG_FWFF_PKT_INFO			(Offset 0x02A0) */
+
+#define BIT_SHIFT_FWFF_PKT_STR_ADDR 0
+#define BIT_MASK_FWFF_PKT_STR_ADDR 0xffff
+#define BIT_FWFF_PKT_STR_ADDR(x)                                               \
+	(((x) & BIT_MASK_FWFF_PKT_STR_ADDR) << BIT_SHIFT_FWFF_PKT_STR_ADDR)
+#define BIT_GET_FWFF_PKT_STR_ADDR(x)                                           \
+	(((x) >> BIT_SHIFT_FWFF_PKT_STR_ADDR) & BIT_MASK_FWFF_PKT_STR_ADDR)
+
+/* 2 REG_PCIE_CTRL				(Offset 0x0300) */
+
+#define BIT_PCIEIO_PERSTB_SEL BIT(31)
+
+/* 2 REG_PCIE_CTRL				(Offset 0x0300) */
+
+#define BIT_SHIFT_PCIE_MAX_RXDMA 28
+#define BIT_MASK_PCIE_MAX_RXDMA 0x7
+#define BIT_PCIE_MAX_RXDMA(x)                                                  \
+	(((x) & BIT_MASK_PCIE_MAX_RXDMA) << BIT_SHIFT_PCIE_MAX_RXDMA)
+#define BIT_GET_PCIE_MAX_RXDMA(x)                                              \
+	(((x) >> BIT_SHIFT_PCIE_MAX_RXDMA) & BIT_MASK_PCIE_MAX_RXDMA)
+
+/* 2 REG_PCIE_CTRL				(Offset 0x0300) */
+
+#define BIT_SHIFT_PCIE_MAX_TXDMA 24
+#define BIT_MASK_PCIE_MAX_TXDMA 0x7
+#define BIT_PCIE_MAX_TXDMA(x)                                                  \
+	(((x) & BIT_MASK_PCIE_MAX_TXDMA) << BIT_SHIFT_PCIE_MAX_TXDMA)
+#define BIT_GET_PCIE_MAX_TXDMA(x)                                              \
+	(((x) >> BIT_SHIFT_PCIE_MAX_TXDMA) & BIT_MASK_PCIE_MAX_TXDMA)
+
+/* 2 REG_PCIE_CTRL				(Offset 0x0300) */
+
+#define BIT_PCIE_RST_TRXDMA_INTF BIT(20)
+
+/* 2 REG_PCIE_CTRL				(Offset 0x0300) */
+
+#define BIT_PCIE_EN_SWENT_L23 BIT(17)
+
+/* 2 REG_PCIE_CTRL				(Offset 0x0300) */
+
+#define BIT_PCIE_EN_HWEXT_L1 BIT(16)
+
+/* 2 REG_INT_MIG				(Offset 0x0304) */
+
+#define BIT_SHIFT_TXTTIMER_MATCH_NUM 28
+#define BIT_MASK_TXTTIMER_MATCH_NUM 0xf
+#define BIT_TXTTIMER_MATCH_NUM(x)                                              \
+	(((x) & BIT_MASK_TXTTIMER_MATCH_NUM) << BIT_SHIFT_TXTTIMER_MATCH_NUM)
+#define BIT_GET_TXTTIMER_MATCH_NUM(x)                                          \
+	(((x) >> BIT_SHIFT_TXTTIMER_MATCH_NUM) & BIT_MASK_TXTTIMER_MATCH_NUM)
+
+#define BIT_SHIFT_TXPKT_NUM_MATCH 24
+#define BIT_MASK_TXPKT_NUM_MATCH 0xf
+#define BIT_TXPKT_NUM_MATCH(x)                                                 \
+	(((x) & BIT_MASK_TXPKT_NUM_MATCH) << BIT_SHIFT_TXPKT_NUM_MATCH)
+#define BIT_GET_TXPKT_NUM_MATCH(x)                                             \
+	(((x) >> BIT_SHIFT_TXPKT_NUM_MATCH) & BIT_MASK_TXPKT_NUM_MATCH)
+
+#define BIT_SHIFT_RXTTIMER_MATCH_NUM 20
+#define BIT_MASK_RXTTIMER_MATCH_NUM 0xf
+#define BIT_RXTTIMER_MATCH_NUM(x)                                              \
+	(((x) & BIT_MASK_RXTTIMER_MATCH_NUM) << BIT_SHIFT_RXTTIMER_MATCH_NUM)
+#define BIT_GET_RXTTIMER_MATCH_NUM(x)                                          \
+	(((x) >> BIT_SHIFT_RXTTIMER_MATCH_NUM) & BIT_MASK_RXTTIMER_MATCH_NUM)
+
+#define BIT_SHIFT_RXPKT_NUM_MATCH 16
+#define BIT_MASK_RXPKT_NUM_MATCH 0xf
+#define BIT_RXPKT_NUM_MATCH(x)                                                 \
+	(((x) & BIT_MASK_RXPKT_NUM_MATCH) << BIT_SHIFT_RXPKT_NUM_MATCH)
+#define BIT_GET_RXPKT_NUM_MATCH(x)                                             \
+	(((x) >> BIT_SHIFT_RXPKT_NUM_MATCH) & BIT_MASK_RXPKT_NUM_MATCH)
+
+#define BIT_SHIFT_MIGRATE_TIMER 0
+#define BIT_MASK_MIGRATE_TIMER 0xffff
+#define BIT_MIGRATE_TIMER(x)                                                   \
+	(((x) & BIT_MASK_MIGRATE_TIMER) << BIT_SHIFT_MIGRATE_TIMER)
+#define BIT_GET_MIGRATE_TIMER(x)                                               \
+	(((x) >> BIT_SHIFT_MIGRATE_TIMER) & BIT_MASK_MIGRATE_TIMER)
+
+/* 2 REG_BCNQ_TXBD_DESA			(Offset 0x0308) */
+
+#define BIT_SHIFT_BCNQ_TXBD_DESA 0
+#define BIT_MASK_BCNQ_TXBD_DESA 0xffffffffffffffffL
+#define BIT_BCNQ_TXBD_DESA(x)                                                  \
+	(((x) & BIT_MASK_BCNQ_TXBD_DESA) << BIT_SHIFT_BCNQ_TXBD_DESA)
+#define BIT_GET_BCNQ_TXBD_DESA(x)                                              \
+	(((x) >> BIT_SHIFT_BCNQ_TXBD_DESA) & BIT_MASK_BCNQ_TXBD_DESA)
+
+/* 2 REG_MGQ_TXBD_DESA			(Offset 0x0310) */
+
+#define BIT_SHIFT_MGQ_TXBD_DESA 0
+#define BIT_MASK_MGQ_TXBD_DESA 0xffffffffffffffffL
+#define BIT_MGQ_TXBD_DESA(x)                                                   \
+	(((x) & BIT_MASK_MGQ_TXBD_DESA) << BIT_SHIFT_MGQ_TXBD_DESA)
+#define BIT_GET_MGQ_TXBD_DESA(x)                                               \
+	(((x) >> BIT_SHIFT_MGQ_TXBD_DESA) & BIT_MASK_MGQ_TXBD_DESA)
+
+/* 2 REG_VOQ_TXBD_DESA			(Offset 0x0318) */
+
+#define BIT_SHIFT_VOQ_TXBD_DESA 0
+#define BIT_MASK_VOQ_TXBD_DESA 0xffffffffffffffffL
+#define BIT_VOQ_TXBD_DESA(x)                                                   \
+	(((x) & BIT_MASK_VOQ_TXBD_DESA) << BIT_SHIFT_VOQ_TXBD_DESA)
+#define BIT_GET_VOQ_TXBD_DESA(x)                                               \
+	(((x) >> BIT_SHIFT_VOQ_TXBD_DESA) & BIT_MASK_VOQ_TXBD_DESA)
+
+/* 2 REG_VIQ_TXBD_DESA			(Offset 0x0320) */
+
+#define BIT_SHIFT_VIQ_TXBD_DESA 0
+#define BIT_MASK_VIQ_TXBD_DESA 0xffffffffffffffffL
+#define BIT_VIQ_TXBD_DESA(x)                                                   \
+	(((x) & BIT_MASK_VIQ_TXBD_DESA) << BIT_SHIFT_VIQ_TXBD_DESA)
+#define BIT_GET_VIQ_TXBD_DESA(x)                                               \
+	(((x) >> BIT_SHIFT_VIQ_TXBD_DESA) & BIT_MASK_VIQ_TXBD_DESA)
+
+/* 2 REG_BEQ_TXBD_DESA			(Offset 0x0328) */
+
+#define BIT_SHIFT_BEQ_TXBD_DESA 0
+#define BIT_MASK_BEQ_TXBD_DESA 0xffffffffffffffffL
+#define BIT_BEQ_TXBD_DESA(x)                                                   \
+	(((x) & BIT_MASK_BEQ_TXBD_DESA) << BIT_SHIFT_BEQ_TXBD_DESA)
+#define BIT_GET_BEQ_TXBD_DESA(x)                                               \
+	(((x) >> BIT_SHIFT_BEQ_TXBD_DESA) & BIT_MASK_BEQ_TXBD_DESA)
+
+/* 2 REG_BKQ_TXBD_DESA			(Offset 0x0330) */
+
+#define BIT_SHIFT_BKQ_TXBD_DESA 0
+#define BIT_MASK_BKQ_TXBD_DESA 0xffffffffffffffffL
+#define BIT_BKQ_TXBD_DESA(x)                                                   \
+	(((x) & BIT_MASK_BKQ_TXBD_DESA) << BIT_SHIFT_BKQ_TXBD_DESA)
+#define BIT_GET_BKQ_TXBD_DESA(x)                                               \
+	(((x) >> BIT_SHIFT_BKQ_TXBD_DESA) & BIT_MASK_BKQ_TXBD_DESA)
+
+/* 2 REG_RXQ_RXBD_DESA			(Offset 0x0338) */
+
+#define BIT_SHIFT_RXQ_RXBD_DESA 0
+#define BIT_MASK_RXQ_RXBD_DESA 0xffffffffffffffffL
+#define BIT_RXQ_RXBD_DESA(x)                                                   \
+	(((x) & BIT_MASK_RXQ_RXBD_DESA) << BIT_SHIFT_RXQ_RXBD_DESA)
+#define BIT_GET_RXQ_RXBD_DESA(x)                                               \
+	(((x) >> BIT_SHIFT_RXQ_RXBD_DESA) & BIT_MASK_RXQ_RXBD_DESA)
+
+/* 2 REG_HI0Q_TXBD_DESA			(Offset 0x0340) */
+
+#define BIT_SHIFT_HI0Q_TXBD_DESA 0
+#define BIT_MASK_HI0Q_TXBD_DESA 0xffffffffffffffffL
+#define BIT_HI0Q_TXBD_DESA(x)                                                  \
+	(((x) & BIT_MASK_HI0Q_TXBD_DESA) << BIT_SHIFT_HI0Q_TXBD_DESA)
+#define BIT_GET_HI0Q_TXBD_DESA(x)                                              \
+	(((x) >> BIT_SHIFT_HI0Q_TXBD_DESA) & BIT_MASK_HI0Q_TXBD_DESA)
+
+/* 2 REG_HI1Q_TXBD_DESA			(Offset 0x0348) */
+
+#define BIT_SHIFT_HI1Q_TXBD_DESA 0
+#define BIT_MASK_HI1Q_TXBD_DESA 0xffffffffffffffffL
+#define BIT_HI1Q_TXBD_DESA(x)                                                  \
+	(((x) & BIT_MASK_HI1Q_TXBD_DESA) << BIT_SHIFT_HI1Q_TXBD_DESA)
+#define BIT_GET_HI1Q_TXBD_DESA(x)                                              \
+	(((x) >> BIT_SHIFT_HI1Q_TXBD_DESA) & BIT_MASK_HI1Q_TXBD_DESA)
+
+/* 2 REG_HI2Q_TXBD_DESA			(Offset 0x0350) */
+
+#define BIT_SHIFT_HI2Q_TXBD_DESA 0
+#define BIT_MASK_HI2Q_TXBD_DESA 0xffffffffffffffffL
+#define BIT_HI2Q_TXBD_DESA(x)                                                  \
+	(((x) & BIT_MASK_HI2Q_TXBD_DESA) << BIT_SHIFT_HI2Q_TXBD_DESA)
+#define BIT_GET_HI2Q_TXBD_DESA(x)                                              \
+	(((x) >> BIT_SHIFT_HI2Q_TXBD_DESA) & BIT_MASK_HI2Q_TXBD_DESA)
+
+/* 2 REG_HI3Q_TXBD_DESA			(Offset 0x0358) */
+
+#define BIT_SHIFT_HI3Q_TXBD_DESA 0
+#define BIT_MASK_HI3Q_TXBD_DESA 0xffffffffffffffffL
+#define BIT_HI3Q_TXBD_DESA(x)                                                  \
+	(((x) & BIT_MASK_HI3Q_TXBD_DESA) << BIT_SHIFT_HI3Q_TXBD_DESA)
+#define BIT_GET_HI3Q_TXBD_DESA(x)                                              \
+	(((x) >> BIT_SHIFT_HI3Q_TXBD_DESA) & BIT_MASK_HI3Q_TXBD_DESA)
+
+/* 2 REG_HI4Q_TXBD_DESA			(Offset 0x0360) */
+
+#define BIT_SHIFT_HI4Q_TXBD_DESA 0
+#define BIT_MASK_HI4Q_TXBD_DESA 0xffffffffffffffffL
+#define BIT_HI4Q_TXBD_DESA(x)                                                  \
+	(((x) & BIT_MASK_HI4Q_TXBD_DESA) << BIT_SHIFT_HI4Q_TXBD_DESA)
+#define BIT_GET_HI4Q_TXBD_DESA(x)                                              \
+	(((x) >> BIT_SHIFT_HI4Q_TXBD_DESA) & BIT_MASK_HI4Q_TXBD_DESA)
+
+/* 2 REG_HI5Q_TXBD_DESA			(Offset 0x0368) */
+
+#define BIT_SHIFT_HI5Q_TXBD_DESA 0
+#define BIT_MASK_HI5Q_TXBD_DESA 0xffffffffffffffffL
+#define BIT_HI5Q_TXBD_DESA(x)                                                  \
+	(((x) & BIT_MASK_HI5Q_TXBD_DESA) << BIT_SHIFT_HI5Q_TXBD_DESA)
+#define BIT_GET_HI5Q_TXBD_DESA(x)                                              \
+	(((x) >> BIT_SHIFT_HI5Q_TXBD_DESA) & BIT_MASK_HI5Q_TXBD_DESA)
+
+/* 2 REG_HI6Q_TXBD_DESA			(Offset 0x0370) */
+
+#define BIT_SHIFT_HI6Q_TXBD_DESA 0
+#define BIT_MASK_HI6Q_TXBD_DESA 0xffffffffffffffffL
+#define BIT_HI6Q_TXBD_DESA(x)                                                  \
+	(((x) & BIT_MASK_HI6Q_TXBD_DESA) << BIT_SHIFT_HI6Q_TXBD_DESA)
+#define BIT_GET_HI6Q_TXBD_DESA(x)                                              \
+	(((x) >> BIT_SHIFT_HI6Q_TXBD_DESA) & BIT_MASK_HI6Q_TXBD_DESA)
+
+/* 2 REG_HI7Q_TXBD_DESA			(Offset 0x0378) */
+
+#define BIT_SHIFT_HI7Q_TXBD_DESA 0
+#define BIT_MASK_HI7Q_TXBD_DESA 0xffffffffffffffffL
+#define BIT_HI7Q_TXBD_DESA(x)                                                  \
+	(((x) & BIT_MASK_HI7Q_TXBD_DESA) << BIT_SHIFT_HI7Q_TXBD_DESA)
+#define BIT_GET_HI7Q_TXBD_DESA(x)                                              \
+	(((x) >> BIT_SHIFT_HI7Q_TXBD_DESA) & BIT_MASK_HI7Q_TXBD_DESA)
+
+/* 2 REG_MGQ_TXBD_NUM			(Offset 0x0380) */
+
+#define BIT_PCIE_MGQ_FLAG BIT(14)
+
+/* 2 REG_MGQ_TXBD_NUM			(Offset 0x0380) */
+
+#define BIT_SHIFT_MGQ_DESC_MODE 12
+#define BIT_MASK_MGQ_DESC_MODE 0x3
+#define BIT_MGQ_DESC_MODE(x)                                                   \
+	(((x) & BIT_MASK_MGQ_DESC_MODE) << BIT_SHIFT_MGQ_DESC_MODE)
+#define BIT_GET_MGQ_DESC_MODE(x)                                               \
+	(((x) >> BIT_SHIFT_MGQ_DESC_MODE) & BIT_MASK_MGQ_DESC_MODE)
+
+#define BIT_SHIFT_MGQ_DESC_NUM 0
+#define BIT_MASK_MGQ_DESC_NUM 0xfff
+#define BIT_MGQ_DESC_NUM(x)                                                    \
+	(((x) & BIT_MASK_MGQ_DESC_NUM) << BIT_SHIFT_MGQ_DESC_NUM)
+#define BIT_GET_MGQ_DESC_NUM(x)                                                \
+	(((x) >> BIT_SHIFT_MGQ_DESC_NUM) & BIT_MASK_MGQ_DESC_NUM)
+
+/* 2 REG_RX_RXBD_NUM				(Offset 0x0382) */
+
+#define BIT_SYS_32_64 BIT(15)
+
+#define BIT_SHIFT_BCNQ_DESC_MODE 13
+#define BIT_MASK_BCNQ_DESC_MODE 0x3
+#define BIT_BCNQ_DESC_MODE(x)                                                  \
+	(((x) & BIT_MASK_BCNQ_DESC_MODE) << BIT_SHIFT_BCNQ_DESC_MODE)
+#define BIT_GET_BCNQ_DESC_MODE(x)                                              \
+	(((x) >> BIT_SHIFT_BCNQ_DESC_MODE) & BIT_MASK_BCNQ_DESC_MODE)
+
+/* 2 REG_RX_RXBD_NUM				(Offset 0x0382) */
+
+#define BIT_PCIE_BCNQ_FLAG BIT(12)
+
+/* 2 REG_RX_RXBD_NUM				(Offset 0x0382) */
+
+#define BIT_SHIFT_RXQ_DESC_NUM 0
+#define BIT_MASK_RXQ_DESC_NUM 0xfff
+#define BIT_RXQ_DESC_NUM(x)                                                    \
+	(((x) & BIT_MASK_RXQ_DESC_NUM) << BIT_SHIFT_RXQ_DESC_NUM)
+#define BIT_GET_RXQ_DESC_NUM(x)                                                \
+	(((x) >> BIT_SHIFT_RXQ_DESC_NUM) & BIT_MASK_RXQ_DESC_NUM)
+
+/* 2 REG_VOQ_TXBD_NUM			(Offset 0x0384) */
+
+#define BIT_PCIE_VOQ_FLAG BIT(14)
+
+/* 2 REG_VOQ_TXBD_NUM			(Offset 0x0384) */
+
+#define BIT_SHIFT_VOQ_DESC_MODE 12
+#define BIT_MASK_VOQ_DESC_MODE 0x3
+#define BIT_VOQ_DESC_MODE(x)                                                   \
+	(((x) & BIT_MASK_VOQ_DESC_MODE) << BIT_SHIFT_VOQ_DESC_MODE)
+#define BIT_GET_VOQ_DESC_MODE(x)                                               \
+	(((x) >> BIT_SHIFT_VOQ_DESC_MODE) & BIT_MASK_VOQ_DESC_MODE)
+
+#define BIT_SHIFT_VOQ_DESC_NUM 0
+#define BIT_MASK_VOQ_DESC_NUM 0xfff
+#define BIT_VOQ_DESC_NUM(x)                                                    \
+	(((x) & BIT_MASK_VOQ_DESC_NUM) << BIT_SHIFT_VOQ_DESC_NUM)
+#define BIT_GET_VOQ_DESC_NUM(x)                                                \
+	(((x) >> BIT_SHIFT_VOQ_DESC_NUM) & BIT_MASK_VOQ_DESC_NUM)
+
+/* 2 REG_VIQ_TXBD_NUM			(Offset 0x0386) */
+
+#define BIT_PCIE_VIQ_FLAG BIT(14)
+
+/* 2 REG_VIQ_TXBD_NUM			(Offset 0x0386) */
+
+#define BIT_SHIFT_VIQ_DESC_MODE 12
+#define BIT_MASK_VIQ_DESC_MODE 0x3
+#define BIT_VIQ_DESC_MODE(x)                                                   \
+	(((x) & BIT_MASK_VIQ_DESC_MODE) << BIT_SHIFT_VIQ_DESC_MODE)
+#define BIT_GET_VIQ_DESC_MODE(x)                                               \
+	(((x) >> BIT_SHIFT_VIQ_DESC_MODE) & BIT_MASK_VIQ_DESC_MODE)
+
+#define BIT_SHIFT_VIQ_DESC_NUM 0
+#define BIT_MASK_VIQ_DESC_NUM 0xfff
+#define BIT_VIQ_DESC_NUM(x)                                                    \
+	(((x) & BIT_MASK_VIQ_DESC_NUM) << BIT_SHIFT_VIQ_DESC_NUM)
+#define BIT_GET_VIQ_DESC_NUM(x)                                                \
+	(((x) >> BIT_SHIFT_VIQ_DESC_NUM) & BIT_MASK_VIQ_DESC_NUM)
+
+/* 2 REG_BEQ_TXBD_NUM			(Offset 0x0388) */
+
+#define BIT_PCIE_BEQ_FLAG BIT(14)
+
+/* 2 REG_BEQ_TXBD_NUM			(Offset 0x0388) */
+
+#define BIT_SHIFT_BEQ_DESC_MODE 12
+#define BIT_MASK_BEQ_DESC_MODE 0x3
+#define BIT_BEQ_DESC_MODE(x)                                                   \
+	(((x) & BIT_MASK_BEQ_DESC_MODE) << BIT_SHIFT_BEQ_DESC_MODE)
+#define BIT_GET_BEQ_DESC_MODE(x)                                               \
+	(((x) >> BIT_SHIFT_BEQ_DESC_MODE) & BIT_MASK_BEQ_DESC_MODE)
+
+#define BIT_SHIFT_BEQ_DESC_NUM 0
+#define BIT_MASK_BEQ_DESC_NUM 0xfff
+#define BIT_BEQ_DESC_NUM(x)                                                    \
+	(((x) & BIT_MASK_BEQ_DESC_NUM) << BIT_SHIFT_BEQ_DESC_NUM)
+#define BIT_GET_BEQ_DESC_NUM(x)                                                \
+	(((x) >> BIT_SHIFT_BEQ_DESC_NUM) & BIT_MASK_BEQ_DESC_NUM)
+
+/* 2 REG_BKQ_TXBD_NUM			(Offset 0x038A) */
+
+#define BIT_PCIE_BKQ_FLAG BIT(14)
+
+/* 2 REG_BKQ_TXBD_NUM			(Offset 0x038A) */
+
+#define BIT_SHIFT_BKQ_DESC_MODE 12
+#define BIT_MASK_BKQ_DESC_MODE 0x3
+#define BIT_BKQ_DESC_MODE(x)                                                   \
+	(((x) & BIT_MASK_BKQ_DESC_MODE) << BIT_SHIFT_BKQ_DESC_MODE)
+#define BIT_GET_BKQ_DESC_MODE(x)                                               \
+	(((x) >> BIT_SHIFT_BKQ_DESC_MODE) & BIT_MASK_BKQ_DESC_MODE)
+
+#define BIT_SHIFT_BKQ_DESC_NUM 0
+#define BIT_MASK_BKQ_DESC_NUM 0xfff
+#define BIT_BKQ_DESC_NUM(x)                                                    \
+	(((x) & BIT_MASK_BKQ_DESC_NUM) << BIT_SHIFT_BKQ_DESC_NUM)
+#define BIT_GET_BKQ_DESC_NUM(x)                                                \
+	(((x) >> BIT_SHIFT_BKQ_DESC_NUM) & BIT_MASK_BKQ_DESC_NUM)
+
+/* 2 REG_HI0Q_TXBD_NUM			(Offset 0x038C) */
+
+#define BIT_HI0Q_FLAG BIT(14)
+
+#define BIT_SHIFT_HI0Q_DESC_MODE 12
+#define BIT_MASK_HI0Q_DESC_MODE 0x3
+#define BIT_HI0Q_DESC_MODE(x)                                                  \
+	(((x) & BIT_MASK_HI0Q_DESC_MODE) << BIT_SHIFT_HI0Q_DESC_MODE)
+#define BIT_GET_HI0Q_DESC_MODE(x)                                              \
+	(((x) >> BIT_SHIFT_HI0Q_DESC_MODE) & BIT_MASK_HI0Q_DESC_MODE)
+
+#define BIT_SHIFT_HI0Q_DESC_NUM 0
+#define BIT_MASK_HI0Q_DESC_NUM 0xfff
+#define BIT_HI0Q_DESC_NUM(x)                                                   \
+	(((x) & BIT_MASK_HI0Q_DESC_NUM) << BIT_SHIFT_HI0Q_DESC_NUM)
+#define BIT_GET_HI0Q_DESC_NUM(x)                                               \
+	(((x) >> BIT_SHIFT_HI0Q_DESC_NUM) & BIT_MASK_HI0Q_DESC_NUM)
+
+/* 2 REG_HI1Q_TXBD_NUM			(Offset 0x038E) */
+
+#define BIT_HI1Q_FLAG BIT(14)
+
+#define BIT_SHIFT_HI1Q_DESC_MODE 12
+#define BIT_MASK_HI1Q_DESC_MODE 0x3
+#define BIT_HI1Q_DESC_MODE(x)                                                  \
+	(((x) & BIT_MASK_HI1Q_DESC_MODE) << BIT_SHIFT_HI1Q_DESC_MODE)
+#define BIT_GET_HI1Q_DESC_MODE(x)                                              \
+	(((x) >> BIT_SHIFT_HI1Q_DESC_MODE) & BIT_MASK_HI1Q_DESC_MODE)
+
+#define BIT_SHIFT_HI1Q_DESC_NUM 0
+#define BIT_MASK_HI1Q_DESC_NUM 0xfff
+#define BIT_HI1Q_DESC_NUM(x)                                                   \
+	(((x) & BIT_MASK_HI1Q_DESC_NUM) << BIT_SHIFT_HI1Q_DESC_NUM)
+#define BIT_GET_HI1Q_DESC_NUM(x)                                               \
+	(((x) >> BIT_SHIFT_HI1Q_DESC_NUM) & BIT_MASK_HI1Q_DESC_NUM)
+
+/* 2 REG_HI2Q_TXBD_NUM			(Offset 0x0390) */
+
+#define BIT_HI2Q_FLAG BIT(14)
+
+#define BIT_SHIFT_HI2Q_DESC_MODE 12
+#define BIT_MASK_HI2Q_DESC_MODE 0x3
+#define BIT_HI2Q_DESC_MODE(x)                                                  \
+	(((x) & BIT_MASK_HI2Q_DESC_MODE) << BIT_SHIFT_HI2Q_DESC_MODE)
+#define BIT_GET_HI2Q_DESC_MODE(x)                                              \
+	(((x) >> BIT_SHIFT_HI2Q_DESC_MODE) & BIT_MASK_HI2Q_DESC_MODE)
+
+#define BIT_SHIFT_HI2Q_DESC_NUM 0
+#define BIT_MASK_HI2Q_DESC_NUM 0xfff
+#define BIT_HI2Q_DESC_NUM(x)                                                   \
+	(((x) & BIT_MASK_HI2Q_DESC_NUM) << BIT_SHIFT_HI2Q_DESC_NUM)
+#define BIT_GET_HI2Q_DESC_NUM(x)                                               \
+	(((x) >> BIT_SHIFT_HI2Q_DESC_NUM) & BIT_MASK_HI2Q_DESC_NUM)
+
+/* 2 REG_HI3Q_TXBD_NUM			(Offset 0x0392) */
+
+#define BIT_HI3Q_FLAG BIT(14)
+
+#define BIT_SHIFT_HI3Q_DESC_MODE 12
+#define BIT_MASK_HI3Q_DESC_MODE 0x3
+#define BIT_HI3Q_DESC_MODE(x)                                                  \
+	(((x) & BIT_MASK_HI3Q_DESC_MODE) << BIT_SHIFT_HI3Q_DESC_MODE)
+#define BIT_GET_HI3Q_DESC_MODE(x)                                              \
+	(((x) >> BIT_SHIFT_HI3Q_DESC_MODE) & BIT_MASK_HI3Q_DESC_MODE)
+
+#define BIT_SHIFT_HI3Q_DESC_NUM 0
+#define BIT_MASK_HI3Q_DESC_NUM 0xfff
+#define BIT_HI3Q_DESC_NUM(x)                                                   \
+	(((x) & BIT_MASK_HI3Q_DESC_NUM) << BIT_SHIFT_HI3Q_DESC_NUM)
+#define BIT_GET_HI3Q_DESC_NUM(x)                                               \
+	(((x) >> BIT_SHIFT_HI3Q_DESC_NUM) & BIT_MASK_HI3Q_DESC_NUM)
+
+/* 2 REG_HI4Q_TXBD_NUM			(Offset 0x0394) */
+
+#define BIT_HI4Q_FLAG BIT(14)
+
+#define BIT_SHIFT_HI4Q_DESC_MODE 12
+#define BIT_MASK_HI4Q_DESC_MODE 0x3
+#define BIT_HI4Q_DESC_MODE(x)                                                  \
+	(((x) & BIT_MASK_HI4Q_DESC_MODE) << BIT_SHIFT_HI4Q_DESC_MODE)
+#define BIT_GET_HI4Q_DESC_MODE(x)                                              \
+	(((x) >> BIT_SHIFT_HI4Q_DESC_MODE) & BIT_MASK_HI4Q_DESC_MODE)
+
+#define BIT_SHIFT_HI4Q_DESC_NUM 0
+#define BIT_MASK_HI4Q_DESC_NUM 0xfff
+#define BIT_HI4Q_DESC_NUM(x)                                                   \
+	(((x) & BIT_MASK_HI4Q_DESC_NUM) << BIT_SHIFT_HI4Q_DESC_NUM)
+#define BIT_GET_HI4Q_DESC_NUM(x)                                               \
+	(((x) >> BIT_SHIFT_HI4Q_DESC_NUM) & BIT_MASK_HI4Q_DESC_NUM)
+
+/* 2 REG_HI5Q_TXBD_NUM			(Offset 0x0396) */
+
+#define BIT_HI5Q_FLAG BIT(14)
+
+#define BIT_SHIFT_HI5Q_DESC_MODE 12
+#define BIT_MASK_HI5Q_DESC_MODE 0x3
+#define BIT_HI5Q_DESC_MODE(x)                                                  \
+	(((x) & BIT_MASK_HI5Q_DESC_MODE) << BIT_SHIFT_HI5Q_DESC_MODE)
+#define BIT_GET_HI5Q_DESC_MODE(x)                                              \
+	(((x) >> BIT_SHIFT_HI5Q_DESC_MODE) & BIT_MASK_HI5Q_DESC_MODE)
+
+#define BIT_SHIFT_HI5Q_DESC_NUM 0
+#define BIT_MASK_HI5Q_DESC_NUM 0xfff
+#define BIT_HI5Q_DESC_NUM(x)                                                   \
+	(((x) & BIT_MASK_HI5Q_DESC_NUM) << BIT_SHIFT_HI5Q_DESC_NUM)
+#define BIT_GET_HI5Q_DESC_NUM(x)                                               \
+	(((x) >> BIT_SHIFT_HI5Q_DESC_NUM) & BIT_MASK_HI5Q_DESC_NUM)
+
+/* 2 REG_HI6Q_TXBD_NUM			(Offset 0x0398) */
+
+#define BIT_HI6Q_FLAG BIT(14)
+
+#define BIT_SHIFT_HI6Q_DESC_MODE 12
+#define BIT_MASK_HI6Q_DESC_MODE 0x3
+#define BIT_HI6Q_DESC_MODE(x)                                                  \
+	(((x) & BIT_MASK_HI6Q_DESC_MODE) << BIT_SHIFT_HI6Q_DESC_MODE)
+#define BIT_GET_HI6Q_DESC_MODE(x)                                              \
+	(((x) >> BIT_SHIFT_HI6Q_DESC_MODE) & BIT_MASK_HI6Q_DESC_MODE)
+
+#define BIT_SHIFT_HI6Q_DESC_NUM 0
+#define BIT_MASK_HI6Q_DESC_NUM 0xfff
+#define BIT_HI6Q_DESC_NUM(x)                                                   \
+	(((x) & BIT_MASK_HI6Q_DESC_NUM) << BIT_SHIFT_HI6Q_DESC_NUM)
+#define BIT_GET_HI6Q_DESC_NUM(x)                                               \
+	(((x) >> BIT_SHIFT_HI6Q_DESC_NUM) & BIT_MASK_HI6Q_DESC_NUM)
+
+/* 2 REG_HI7Q_TXBD_NUM			(Offset 0x039A) */
+
+#define BIT_HI7Q_FLAG BIT(14)
+
+#define BIT_SHIFT_HI7Q_DESC_MODE 12
+#define BIT_MASK_HI7Q_DESC_MODE 0x3
+#define BIT_HI7Q_DESC_MODE(x)                                                  \
+	(((x) & BIT_MASK_HI7Q_DESC_MODE) << BIT_SHIFT_HI7Q_DESC_MODE)
+#define BIT_GET_HI7Q_DESC_MODE(x)                                              \
+	(((x) >> BIT_SHIFT_HI7Q_DESC_MODE) & BIT_MASK_HI7Q_DESC_MODE)
+
+#define BIT_SHIFT_HI7Q_DESC_NUM 0
+#define BIT_MASK_HI7Q_DESC_NUM 0xfff
+#define BIT_HI7Q_DESC_NUM(x)                                                   \
+	(((x) & BIT_MASK_HI7Q_DESC_NUM) << BIT_SHIFT_HI7Q_DESC_NUM)
+#define BIT_GET_HI7Q_DESC_NUM(x)                                               \
+	(((x) >> BIT_SHIFT_HI7Q_DESC_NUM) & BIT_MASK_HI7Q_DESC_NUM)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_HI7Q_HW_IDX BIT(29)
+#define BIT_CLR_HI6Q_HW_IDX BIT(28)
+#define BIT_CLR_HI5Q_HW_IDX BIT(27)
+#define BIT_CLR_HI4Q_HW_IDX BIT(26)
+#define BIT_CLR_HI3Q_HW_IDX BIT(25)
+#define BIT_CLR_HI2Q_HW_IDX BIT(24)
+#define BIT_CLR_HI1Q_HW_IDX BIT(23)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_HI0Q_HW_IDX BIT(22)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_BKQ_HW_IDX BIT(21)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_BEQ_HW_IDX BIT(20)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_VIQ_HW_IDX BIT(19)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_VOQ_HW_IDX BIT(18)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_MGQ_HW_IDX BIT(17)
+
+/* 2 REG_TSFTIMER_HCI			(Offset 0x039C) */
+
+#define BIT_SHIFT_TSFT2_HCI 16
+#define BIT_MASK_TSFT2_HCI 0xffff
+#define BIT_TSFT2_HCI(x) (((x) & BIT_MASK_TSFT2_HCI) << BIT_SHIFT_TSFT2_HCI)
+#define BIT_GET_TSFT2_HCI(x) (((x) >> BIT_SHIFT_TSFT2_HCI) & BIT_MASK_TSFT2_HCI)
+
+#define BIT_CLR_RXQ_HW_IDX BIT(16)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_HI7Q_HOST_IDX BIT(13)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_HI6Q_HOST_IDX BIT(12)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_HI5Q_HOST_IDX BIT(11)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_HI4Q_HOST_IDX BIT(10)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_HI3Q_HOST_IDX BIT(9)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_HI2Q_HOST_IDX BIT(8)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_HI1Q_HOST_IDX BIT(7)
+#define BIT_CLR_HI0Q_HOST_IDX BIT(6)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_BKQ_HOST_IDX BIT(5)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_BEQ_HOST_IDX BIT(4)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_VIQ_HOST_IDX BIT(3)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_VOQ_HOST_IDX BIT(2)
+
+/* 2 REG_BD_RWPTR_CLR			(Offset 0x039C) */
+
+#define BIT_CLR_MGQ_HOST_IDX BIT(1)
+
+/* 2 REG_TSFTIMER_HCI			(Offset 0x039C) */
+
+#define BIT_SHIFT_TSFT1_HCI 0
+#define BIT_MASK_TSFT1_HCI 0xffff
+#define BIT_TSFT1_HCI(x) (((x) & BIT_MASK_TSFT1_HCI) << BIT_SHIFT_TSFT1_HCI)
+#define BIT_GET_TSFT1_HCI(x) (((x) >> BIT_SHIFT_TSFT1_HCI) & BIT_MASK_TSFT1_HCI)
+
+#define BIT_CLR_RXQ_HOST_IDX BIT(0)
+
+/* 2 REG_VOQ_TXBD_IDX			(Offset 0x03A0) */
+
+#define BIT_SHIFT_VOQ_HW_IDX 16
+#define BIT_MASK_VOQ_HW_IDX 0xfff
+#define BIT_VOQ_HW_IDX(x) (((x) & BIT_MASK_VOQ_HW_IDX) << BIT_SHIFT_VOQ_HW_IDX)
+#define BIT_GET_VOQ_HW_IDX(x)                                                  \
+	(((x) >> BIT_SHIFT_VOQ_HW_IDX) & BIT_MASK_VOQ_HW_IDX)
+
+#define BIT_SHIFT_VOQ_HOST_IDX 0
+#define BIT_MASK_VOQ_HOST_IDX 0xfff
+#define BIT_VOQ_HOST_IDX(x)                                                    \
+	(((x) & BIT_MASK_VOQ_HOST_IDX) << BIT_SHIFT_VOQ_HOST_IDX)
+#define BIT_GET_VOQ_HOST_IDX(x)                                                \
+	(((x) >> BIT_SHIFT_VOQ_HOST_IDX) & BIT_MASK_VOQ_HOST_IDX)
+
+/* 2 REG_VIQ_TXBD_IDX			(Offset 0x03A4) */
+
+#define BIT_SHIFT_VIQ_HW_IDX 16
+#define BIT_MASK_VIQ_HW_IDX 0xfff
+#define BIT_VIQ_HW_IDX(x) (((x) & BIT_MASK_VIQ_HW_IDX) << BIT_SHIFT_VIQ_HW_IDX)
+#define BIT_GET_VIQ_HW_IDX(x)                                                  \
+	(((x) >> BIT_SHIFT_VIQ_HW_IDX) & BIT_MASK_VIQ_HW_IDX)
+
+#define BIT_SHIFT_VIQ_HOST_IDX 0
+#define BIT_MASK_VIQ_HOST_IDX 0xfff
+#define BIT_VIQ_HOST_IDX(x)                                                    \
+	(((x) & BIT_MASK_VIQ_HOST_IDX) << BIT_SHIFT_VIQ_HOST_IDX)
+#define BIT_GET_VIQ_HOST_IDX(x)                                                \
+	(((x) >> BIT_SHIFT_VIQ_HOST_IDX) & BIT_MASK_VIQ_HOST_IDX)
+
+/* 2 REG_BEQ_TXBD_IDX			(Offset 0x03A8) */
+
+#define BIT_SHIFT_BEQ_HW_IDX 16
+#define BIT_MASK_BEQ_HW_IDX 0xfff
+#define BIT_BEQ_HW_IDX(x) (((x) & BIT_MASK_BEQ_HW_IDX) << BIT_SHIFT_BEQ_HW_IDX)
+#define BIT_GET_BEQ_HW_IDX(x)                                                  \
+	(((x) >> BIT_SHIFT_BEQ_HW_IDX) & BIT_MASK_BEQ_HW_IDX)
+
+#define BIT_SHIFT_BEQ_HOST_IDX 0
+#define BIT_MASK_BEQ_HOST_IDX 0xfff
+#define BIT_BEQ_HOST_IDX(x)                                                    \
+	(((x) & BIT_MASK_BEQ_HOST_IDX) << BIT_SHIFT_BEQ_HOST_IDX)
+#define BIT_GET_BEQ_HOST_IDX(x)                                                \
+	(((x) >> BIT_SHIFT_BEQ_HOST_IDX) & BIT_MASK_BEQ_HOST_IDX)
+
+/* 2 REG_BKQ_TXBD_IDX			(Offset 0x03AC) */
+
+#define BIT_SHIFT_BKQ_HW_IDX 16
+#define BIT_MASK_BKQ_HW_IDX 0xfff
+#define BIT_BKQ_HW_IDX(x) (((x) & BIT_MASK_BKQ_HW_IDX) << BIT_SHIFT_BKQ_HW_IDX)
+#define BIT_GET_BKQ_HW_IDX(x)                                                  \
+	(((x) >> BIT_SHIFT_BKQ_HW_IDX) & BIT_MASK_BKQ_HW_IDX)
+
+#define BIT_SHIFT_BKQ_HOST_IDX 0
+#define BIT_MASK_BKQ_HOST_IDX 0xfff
+#define BIT_BKQ_HOST_IDX(x)                                                    \
+	(((x) & BIT_MASK_BKQ_HOST_IDX) << BIT_SHIFT_BKQ_HOST_IDX)
+#define BIT_GET_BKQ_HOST_IDX(x)                                                \
+	(((x) >> BIT_SHIFT_BKQ_HOST_IDX) & BIT_MASK_BKQ_HOST_IDX)
+
+/* 2 REG_MGQ_TXBD_IDX			(Offset 0x03B0) */
+
+#define BIT_SHIFT_MGQ_HW_IDX 16
+#define BIT_MASK_MGQ_HW_IDX 0xfff
+#define BIT_MGQ_HW_IDX(x) (((x) & BIT_MASK_MGQ_HW_IDX) << BIT_SHIFT_MGQ_HW_IDX)
+#define BIT_GET_MGQ_HW_IDX(x)                                                  \
+	(((x) >> BIT_SHIFT_MGQ_HW_IDX) & BIT_MASK_MGQ_HW_IDX)
+
+#define BIT_SHIFT_MGQ_HOST_IDX 0
+#define BIT_MASK_MGQ_HOST_IDX 0xfff
+#define BIT_MGQ_HOST_IDX(x)                                                    \
+	(((x) & BIT_MASK_MGQ_HOST_IDX) << BIT_SHIFT_MGQ_HOST_IDX)
+#define BIT_GET_MGQ_HOST_IDX(x)                                                \
+	(((x) >> BIT_SHIFT_MGQ_HOST_IDX) & BIT_MASK_MGQ_HOST_IDX)
+
+/* 2 REG_RXQ_RXBD_IDX			(Offset 0x03B4) */
+
+#define BIT_SHIFT_RXQ_HW_IDX 16
+#define BIT_MASK_RXQ_HW_IDX 0xfff
+#define BIT_RXQ_HW_IDX(x) (((x) & BIT_MASK_RXQ_HW_IDX) << BIT_SHIFT_RXQ_HW_IDX)
+#define BIT_GET_RXQ_HW_IDX(x)                                                  \
+	(((x) >> BIT_SHIFT_RXQ_HW_IDX) & BIT_MASK_RXQ_HW_IDX)
+
+#define BIT_SHIFT_RXQ_HOST_IDX 0
+#define BIT_MASK_RXQ_HOST_IDX 0xfff
+#define BIT_RXQ_HOST_IDX(x)                                                    \
+	(((x) & BIT_MASK_RXQ_HOST_IDX) << BIT_SHIFT_RXQ_HOST_IDX)
+#define BIT_GET_RXQ_HOST_IDX(x)                                                \
+	(((x) >> BIT_SHIFT_RXQ_HOST_IDX) & BIT_MASK_RXQ_HOST_IDX)
+
+/* 2 REG_HI0Q_TXBD_IDX			(Offset 0x03B8) */
+
+#define BIT_SHIFT_HI0Q_HW_IDX 16
+#define BIT_MASK_HI0Q_HW_IDX 0xfff
+#define BIT_HI0Q_HW_IDX(x)                                                     \
+	(((x) & BIT_MASK_HI0Q_HW_IDX) << BIT_SHIFT_HI0Q_HW_IDX)
+#define BIT_GET_HI0Q_HW_IDX(x)                                                 \
+	(((x) >> BIT_SHIFT_HI0Q_HW_IDX) & BIT_MASK_HI0Q_HW_IDX)
+
+#define BIT_SHIFT_HI0Q_HOST_IDX 0
+#define BIT_MASK_HI0Q_HOST_IDX 0xfff
+#define BIT_HI0Q_HOST_IDX(x)                                                   \
+	(((x) & BIT_MASK_HI0Q_HOST_IDX) << BIT_SHIFT_HI0Q_HOST_IDX)
+#define BIT_GET_HI0Q_HOST_IDX(x)                                               \
+	(((x) >> BIT_SHIFT_HI0Q_HOST_IDX) & BIT_MASK_HI0Q_HOST_IDX)
+
+/* 2 REG_HI1Q_TXBD_IDX			(Offset 0x03BC) */
+
+#define BIT_SHIFT_HI1Q_HW_IDX 16
+#define BIT_MASK_HI1Q_HW_IDX 0xfff
+#define BIT_HI1Q_HW_IDX(x)                                                     \
+	(((x) & BIT_MASK_HI1Q_HW_IDX) << BIT_SHIFT_HI1Q_HW_IDX)
+#define BIT_GET_HI1Q_HW_IDX(x)                                                 \
+	(((x) >> BIT_SHIFT_HI1Q_HW_IDX) & BIT_MASK_HI1Q_HW_IDX)
+
+#define BIT_SHIFT_HI1Q_HOST_IDX 0
+#define BIT_MASK_HI1Q_HOST_IDX 0xfff
+#define BIT_HI1Q_HOST_IDX(x)                                                   \
+	(((x) & BIT_MASK_HI1Q_HOST_IDX) << BIT_SHIFT_HI1Q_HOST_IDX)
+#define BIT_GET_HI1Q_HOST_IDX(x)                                               \
+	(((x) >> BIT_SHIFT_HI1Q_HOST_IDX) & BIT_MASK_HI1Q_HOST_IDX)
+
+/* 2 REG_HI2Q_TXBD_IDX			(Offset 0x03C0) */
+
+#define BIT_SHIFT_HI2Q_HW_IDX 16
+#define BIT_MASK_HI2Q_HW_IDX 0xfff
+#define BIT_HI2Q_HW_IDX(x)                                                     \
+	(((x) & BIT_MASK_HI2Q_HW_IDX) << BIT_SHIFT_HI2Q_HW_IDX)
+#define BIT_GET_HI2Q_HW_IDX(x)                                                 \
+	(((x) >> BIT_SHIFT_HI2Q_HW_IDX) & BIT_MASK_HI2Q_HW_IDX)
+
+#define BIT_SHIFT_HI2Q_HOST_IDX 0
+#define BIT_MASK_HI2Q_HOST_IDX 0xfff
+#define BIT_HI2Q_HOST_IDX(x)                                                   \
+	(((x) & BIT_MASK_HI2Q_HOST_IDX) << BIT_SHIFT_HI2Q_HOST_IDX)
+#define BIT_GET_HI2Q_HOST_IDX(x)                                               \
+	(((x) >> BIT_SHIFT_HI2Q_HOST_IDX) & BIT_MASK_HI2Q_HOST_IDX)
+
+/* 2 REG_HI3Q_TXBD_IDX			(Offset 0x03C4) */
+
+#define BIT_SHIFT_HI3Q_HW_IDX 16
+#define BIT_MASK_HI3Q_HW_IDX 0xfff
+#define BIT_HI3Q_HW_IDX(x)                                                     \
+	(((x) & BIT_MASK_HI3Q_HW_IDX) << BIT_SHIFT_HI3Q_HW_IDX)
+#define BIT_GET_HI3Q_HW_IDX(x)                                                 \
+	(((x) >> BIT_SHIFT_HI3Q_HW_IDX) & BIT_MASK_HI3Q_HW_IDX)
+
+#define BIT_SHIFT_HI3Q_HOST_IDX 0
+#define BIT_MASK_HI3Q_HOST_IDX 0xfff
+#define BIT_HI3Q_HOST_IDX(x)                                                   \
+	(((x) & BIT_MASK_HI3Q_HOST_IDX) << BIT_SHIFT_HI3Q_HOST_IDX)
+#define BIT_GET_HI3Q_HOST_IDX(x)                                               \
+	(((x) >> BIT_SHIFT_HI3Q_HOST_IDX) & BIT_MASK_HI3Q_HOST_IDX)
+
+/* 2 REG_HI4Q_TXBD_IDX			(Offset 0x03C8) */
+
+#define BIT_SHIFT_HI4Q_HW_IDX 16
+#define BIT_MASK_HI4Q_HW_IDX 0xfff
+#define BIT_HI4Q_HW_IDX(x)                                                     \
+	(((x) & BIT_MASK_HI4Q_HW_IDX) << BIT_SHIFT_HI4Q_HW_IDX)
+#define BIT_GET_HI4Q_HW_IDX(x)                                                 \
+	(((x) >> BIT_SHIFT_HI4Q_HW_IDX) & BIT_MASK_HI4Q_HW_IDX)
+
+#define BIT_SHIFT_HI4Q_HOST_IDX 0
+#define BIT_MASK_HI4Q_HOST_IDX 0xfff
+#define BIT_HI4Q_HOST_IDX(x)                                                   \
+	(((x) & BIT_MASK_HI4Q_HOST_IDX) << BIT_SHIFT_HI4Q_HOST_IDX)
+#define BIT_GET_HI4Q_HOST_IDX(x)                                               \
+	(((x) >> BIT_SHIFT_HI4Q_HOST_IDX) & BIT_MASK_HI4Q_HOST_IDX)
+
+/* 2 REG_HI5Q_TXBD_IDX			(Offset 0x03CC) */
+
+#define BIT_SHIFT_HI5Q_HW_IDX 16
+#define BIT_MASK_HI5Q_HW_IDX 0xfff
+#define BIT_HI5Q_HW_IDX(x)                                                     \
+	(((x) & BIT_MASK_HI5Q_HW_IDX) << BIT_SHIFT_HI5Q_HW_IDX)
+#define BIT_GET_HI5Q_HW_IDX(x)                                                 \
+	(((x) >> BIT_SHIFT_HI5Q_HW_IDX) & BIT_MASK_HI5Q_HW_IDX)
+
+#define BIT_SHIFT_HI5Q_HOST_IDX 0
+#define BIT_MASK_HI5Q_HOST_IDX 0xfff
+#define BIT_HI5Q_HOST_IDX(x)                                                   \
+	(((x) & BIT_MASK_HI5Q_HOST_IDX) << BIT_SHIFT_HI5Q_HOST_IDX)
+#define BIT_GET_HI5Q_HOST_IDX(x)                                               \
+	(((x) >> BIT_SHIFT_HI5Q_HOST_IDX) & BIT_MASK_HI5Q_HOST_IDX)
+
+/* 2 REG_HI6Q_TXBD_IDX			(Offset 0x03D0) */
+
+#define BIT_SHIFT_HI6Q_HW_IDX 16
+#define BIT_MASK_HI6Q_HW_IDX 0xfff
+#define BIT_HI6Q_HW_IDX(x)                                                     \
+	(((x) & BIT_MASK_HI6Q_HW_IDX) << BIT_SHIFT_HI6Q_HW_IDX)
+#define BIT_GET_HI6Q_HW_IDX(x)                                                 \
+	(((x) >> BIT_SHIFT_HI6Q_HW_IDX) & BIT_MASK_HI6Q_HW_IDX)
+
+#define BIT_SHIFT_HI6Q_HOST_IDX 0
+#define BIT_MASK_HI6Q_HOST_IDX 0xfff
+#define BIT_HI6Q_HOST_IDX(x)                                                   \
+	(((x) & BIT_MASK_HI6Q_HOST_IDX) << BIT_SHIFT_HI6Q_HOST_IDX)
+#define BIT_GET_HI6Q_HOST_IDX(x)                                               \
+	(((x) >> BIT_SHIFT_HI6Q_HOST_IDX) & BIT_MASK_HI6Q_HOST_IDX)
+
+/* 2 REG_HI7Q_TXBD_IDX			(Offset 0x03D4) */
+
+#define BIT_SHIFT_HI7Q_HW_IDX 16
+#define BIT_MASK_HI7Q_HW_IDX 0xfff
+#define BIT_HI7Q_HW_IDX(x)                                                     \
+	(((x) & BIT_MASK_HI7Q_HW_IDX) << BIT_SHIFT_HI7Q_HW_IDX)
+#define BIT_GET_HI7Q_HW_IDX(x)                                                 \
+	(((x) >> BIT_SHIFT_HI7Q_HW_IDX) & BIT_MASK_HI7Q_HW_IDX)
+
+#define BIT_SHIFT_HI7Q_HOST_IDX 0
+#define BIT_MASK_HI7Q_HOST_IDX 0xfff
+#define BIT_HI7Q_HOST_IDX(x)                                                   \
+	(((x) & BIT_MASK_HI7Q_HOST_IDX) << BIT_SHIFT_HI7Q_HOST_IDX)
+#define BIT_GET_HI7Q_HOST_IDX(x)                                               \
+	(((x) >> BIT_SHIFT_HI7Q_HOST_IDX) & BIT_MASK_HI7Q_HOST_IDX)
+
+/* 2 REG_DBG_SEL_V1				(Offset 0x03D8) */
+
+#define BIT_DIS_TXDMA_PRE BIT(7)
+#define BIT_DIS_RXDMA_PRE BIT(6)
+#define BIT_TXFLAG_EXIT_L1_EN BIT(2)
+
+#define BIT_SHIFT_DBG_SEL 0
+#define BIT_MASK_DBG_SEL 0xff
+#define BIT_DBG_SEL(x) (((x) & BIT_MASK_DBG_SEL) << BIT_SHIFT_DBG_SEL)
+#define BIT_GET_DBG_SEL(x) (((x) >> BIT_SHIFT_DBG_SEL) & BIT_MASK_DBG_SEL)
+
+/* 2 REG_PCIE_HRPWM1_V1			(Offset 0x03D9) */
+
+#define BIT_SHIFT_PCIE_HRPWM 0
+#define BIT_MASK_PCIE_HRPWM 0xff
+#define BIT_PCIE_HRPWM(x) (((x) & BIT_MASK_PCIE_HRPWM) << BIT_SHIFT_PCIE_HRPWM)
+#define BIT_GET_PCIE_HRPWM(x)                                                  \
+	(((x) >> BIT_SHIFT_PCIE_HRPWM) & BIT_MASK_PCIE_HRPWM)
+
+/* 2 REG_PCIE_HCPWM1_V1			(Offset 0x03DA) */
+
+#define BIT_SHIFT_PCIE_HCPWM 0
+#define BIT_MASK_PCIE_HCPWM 0xff
+#define BIT_PCIE_HCPWM(x) (((x) & BIT_MASK_PCIE_HCPWM) << BIT_SHIFT_PCIE_HCPWM)
+#define BIT_GET_PCIE_HCPWM(x)                                                  \
+	(((x) >> BIT_SHIFT_PCIE_HCPWM) & BIT_MASK_PCIE_HCPWM)
+
+/* 2 REG_PCIE_CTRL2				(Offset 0x03DB) */
+
+#define BIT_SHIFT_HPS_CLKR_PCIE 4
+#define BIT_MASK_HPS_CLKR_PCIE 0x3
+#define BIT_HPS_CLKR_PCIE(x)                                                   \
+	(((x) & BIT_MASK_HPS_CLKR_PCIE) << BIT_SHIFT_HPS_CLKR_PCIE)
+#define BIT_GET_HPS_CLKR_PCIE(x)                                               \
+	(((x) >> BIT_SHIFT_HPS_CLKR_PCIE) & BIT_MASK_HPS_CLKR_PCIE)
+
+/* 2 REG_PCIE_CTRL2				(Offset 0x03DB) */
+
+#define BIT_PCIE_INT BIT(3)
+
+/* 2 REG_PCIE_CTRL2				(Offset 0x03DB) */
+
+#define BIT_EN_RXDMA_ALIGN BIT(1)
+#define BIT_EN_TXDMA_ALIGN BIT(0)
+
+/* 2 REG_PCIE_HRPWM2_V1			(Offset 0x03DC) */
+
+#define BIT_SHIFT_PCIE_HRPWM2 0
+#define BIT_MASK_PCIE_HRPWM2 0xffff
+#define BIT_PCIE_HRPWM2(x)                                                     \
+	(((x) & BIT_MASK_PCIE_HRPWM2) << BIT_SHIFT_PCIE_HRPWM2)
+#define BIT_GET_PCIE_HRPWM2(x)                                                 \
+	(((x) >> BIT_SHIFT_PCIE_HRPWM2) & BIT_MASK_PCIE_HRPWM2)
+
+/* 2 REG_PCIE_HCPWM2_V1			(Offset 0x03DE) */
+
+#define BIT_SHIFT_PCIE_HCPWM2 0
+#define BIT_MASK_PCIE_HCPWM2 0xffff
+#define BIT_PCIE_HCPWM2(x)                                                     \
+	(((x) & BIT_MASK_PCIE_HCPWM2) << BIT_SHIFT_PCIE_HCPWM2)
+#define BIT_GET_PCIE_HCPWM2(x)                                                 \
+	(((x) >> BIT_SHIFT_PCIE_HCPWM2) & BIT_MASK_PCIE_HCPWM2)
+
+/* 2 REG_PCIE_H2C_MSG_V1			(Offset 0x03E0) */
+
+#define BIT_SHIFT_DRV2FW_INFO 0
+#define BIT_MASK_DRV2FW_INFO 0xffffffffL
+#define BIT_DRV2FW_INFO(x)                                                     \
+	(((x) & BIT_MASK_DRV2FW_INFO) << BIT_SHIFT_DRV2FW_INFO)
+#define BIT_GET_DRV2FW_INFO(x)                                                 \
+	(((x) >> BIT_SHIFT_DRV2FW_INFO) & BIT_MASK_DRV2FW_INFO)
+
+/* 2 REG_PCIE_C2H_MSG_V1			(Offset 0x03E4) */
+
+#define BIT_SHIFT_HCI_PCIE_C2H_MSG 0
+#define BIT_MASK_HCI_PCIE_C2H_MSG 0xffffffffL
+#define BIT_HCI_PCIE_C2H_MSG(x)                                                \
+	(((x) & BIT_MASK_HCI_PCIE_C2H_MSG) << BIT_SHIFT_HCI_PCIE_C2H_MSG)
+#define BIT_GET_HCI_PCIE_C2H_MSG(x)                                            \
+	(((x) >> BIT_SHIFT_HCI_PCIE_C2H_MSG) & BIT_MASK_HCI_PCIE_C2H_MSG)
+
+/* 2 REG_DBI_WDATA_V1			(Offset 0x03E8) */
+
+#define BIT_SHIFT_DBI_WDATA 0
+#define BIT_MASK_DBI_WDATA 0xffffffffL
+#define BIT_DBI_WDATA(x) (((x) & BIT_MASK_DBI_WDATA) << BIT_SHIFT_DBI_WDATA)
+#define BIT_GET_DBI_WDATA(x) (((x) >> BIT_SHIFT_DBI_WDATA) & BIT_MASK_DBI_WDATA)
+
+/* 2 REG_DBI_RDATA_V1			(Offset 0x03EC) */
+
+#define BIT_SHIFT_DBI_RDATA 0
+#define BIT_MASK_DBI_RDATA 0xffffffffL
+#define BIT_DBI_RDATA(x) (((x) & BIT_MASK_DBI_RDATA) << BIT_SHIFT_DBI_RDATA)
+#define BIT_GET_DBI_RDATA(x) (((x) >> BIT_SHIFT_DBI_RDATA) & BIT_MASK_DBI_RDATA)
+
+/* 2 REG_DBI_FLAG_V1				(Offset 0x03F0) */
+
+#define BIT_EN_STUCK_DBG BIT(26)
+#define BIT_RX_STUCK BIT(25)
+#define BIT_TX_STUCK BIT(24)
+#define BIT_DBI_RFLAG BIT(17)
+#define BIT_DBI_WFLAG BIT(16)
+
+#define BIT_SHIFT_DBI_WREN 12
+#define BIT_MASK_DBI_WREN 0xf
+#define BIT_DBI_WREN(x) (((x) & BIT_MASK_DBI_WREN) << BIT_SHIFT_DBI_WREN)
+#define BIT_GET_DBI_WREN(x) (((x) >> BIT_SHIFT_DBI_WREN) & BIT_MASK_DBI_WREN)
+
+#define BIT_SHIFT_DBI_ADDR 0
+#define BIT_MASK_DBI_ADDR 0xfff
+#define BIT_DBI_ADDR(x) (((x) & BIT_MASK_DBI_ADDR) << BIT_SHIFT_DBI_ADDR)
+#define BIT_GET_DBI_ADDR(x) (((x) >> BIT_SHIFT_DBI_ADDR) & BIT_MASK_DBI_ADDR)
+
+/* 2 REG_MDIO_V1				(Offset 0x03F4) */
+
+#define BIT_SHIFT_MDIO_RDATA 16
+#define BIT_MASK_MDIO_RDATA 0xffff
+#define BIT_MDIO_RDATA(x) (((x) & BIT_MASK_MDIO_RDATA) << BIT_SHIFT_MDIO_RDATA)
+#define BIT_GET_MDIO_RDATA(x)                                                  \
+	(((x) >> BIT_SHIFT_MDIO_RDATA) & BIT_MASK_MDIO_RDATA)
+
+#define BIT_SHIFT_MDIO_WDATA 0
+#define BIT_MASK_MDIO_WDATA 0xffff
+#define BIT_MDIO_WDATA(x) (((x) & BIT_MASK_MDIO_WDATA) << BIT_SHIFT_MDIO_WDATA)
+#define BIT_GET_MDIO_WDATA(x)                                                  \
+	(((x) >> BIT_SHIFT_MDIO_WDATA) & BIT_MASK_MDIO_WDATA)
+
+/* 2 REG_PCIE_MIX_CFG			(Offset 0x03F8) */
+
+#define BIT_EN_WATCH_DOG BIT(8)
+
+/* 2 REG_PCIE_MIX_CFG			(Offset 0x03F8) */
+
+#define BIT_SHIFT_MDIO_REG_ADDR_V1 0
+#define BIT_MASK_MDIO_REG_ADDR_V1 0x1f
+#define BIT_MDIO_REG_ADDR_V1(x)                                                \
+	(((x) & BIT_MASK_MDIO_REG_ADDR_V1) << BIT_SHIFT_MDIO_REG_ADDR_V1)
+#define BIT_GET_MDIO_REG_ADDR_V1(x)                                            \
+	(((x) >> BIT_SHIFT_MDIO_REG_ADDR_V1) & BIT_MASK_MDIO_REG_ADDR_V1)
+
+/* 2 REG_HCI_MIX_CFG				(Offset 0x03FC) */
+
+#define BIT_HOST_GEN2_SUPPORT BIT(20)
+
+#define BIT_SHIFT_TXDMA_ERR_FLAG 16
+#define BIT_MASK_TXDMA_ERR_FLAG 0xf
+#define BIT_TXDMA_ERR_FLAG(x)                                                  \
+	(((x) & BIT_MASK_TXDMA_ERR_FLAG) << BIT_SHIFT_TXDMA_ERR_FLAG)
+#define BIT_GET_TXDMA_ERR_FLAG(x)                                              \
+	(((x) >> BIT_SHIFT_TXDMA_ERR_FLAG) & BIT_MASK_TXDMA_ERR_FLAG)
+
+#define BIT_SHIFT_EARLY_MODE_SEL 12
+#define BIT_MASK_EARLY_MODE_SEL 0xf
+#define BIT_EARLY_MODE_SEL(x)                                                  \
+	(((x) & BIT_MASK_EARLY_MODE_SEL) << BIT_SHIFT_EARLY_MODE_SEL)
+#define BIT_GET_EARLY_MODE_SEL(x)                                              \
+	(((x) >> BIT_SHIFT_EARLY_MODE_SEL) & BIT_MASK_EARLY_MODE_SEL)
+
+#define BIT_EPHY_RX50_EN BIT(11)
+
+#define BIT_SHIFT_MSI_TIMEOUT_ID_V1 8
+#define BIT_MASK_MSI_TIMEOUT_ID_V1 0x7
+#define BIT_MSI_TIMEOUT_ID_V1(x)                                               \
+	(((x) & BIT_MASK_MSI_TIMEOUT_ID_V1) << BIT_SHIFT_MSI_TIMEOUT_ID_V1)
+#define BIT_GET_MSI_TIMEOUT_ID_V1(x)                                           \
+	(((x) >> BIT_SHIFT_MSI_TIMEOUT_ID_V1) & BIT_MASK_MSI_TIMEOUT_ID_V1)
+
+#define BIT_RADDR_RD BIT(7)
+#define BIT_EN_MUL_TAG BIT(6)
+#define BIT_EN_EARLY_MODE BIT(5)
+#define BIT_L0S_LINK_OFF BIT(4)
+#define BIT_ACT_LINK_OFF BIT(3)
+
+/* 2 REG_HCI_MIX_CFG				(Offset 0x03FC) */
+
+#define BIT_EN_SLOW_MAC_TX BIT(2)
+#define BIT_EN_SLOW_MAC_RX BIT(1)
+
+/* 2 REG_Q0_INFO				(Offset 0x0400) */
+
+#define BIT_SHIFT_QUEUEMACID_Q0_V1 25
+#define BIT_MASK_QUEUEMACID_Q0_V1 0x7f
+#define BIT_QUEUEMACID_Q0_V1(x)                                                \
+	(((x) & BIT_MASK_QUEUEMACID_Q0_V1) << BIT_SHIFT_QUEUEMACID_Q0_V1)
+#define BIT_GET_QUEUEMACID_Q0_V1(x)                                            \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q0_V1) & BIT_MASK_QUEUEMACID_Q0_V1)
+
+#define BIT_SHIFT_QUEUEAC_Q0_V1 23
+#define BIT_MASK_QUEUEAC_Q0_V1 0x3
+#define BIT_QUEUEAC_Q0_V1(x)                                                   \
+	(((x) & BIT_MASK_QUEUEAC_Q0_V1) << BIT_SHIFT_QUEUEAC_Q0_V1)
+#define BIT_GET_QUEUEAC_Q0_V1(x)                                               \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q0_V1) & BIT_MASK_QUEUEAC_Q0_V1)
+
+/* 2 REG_Q0_INFO				(Offset 0x0400) */
+
+#define BIT_TIDEMPTY_Q0_V1 BIT(22)
+
+/* 2 REG_Q0_INFO				(Offset 0x0400) */
+
+#define BIT_SHIFT_TAIL_PKT_Q0_V2 11
+#define BIT_MASK_TAIL_PKT_Q0_V2 0x7ff
+#define BIT_TAIL_PKT_Q0_V2(x)                                                  \
+	(((x) & BIT_MASK_TAIL_PKT_Q0_V2) << BIT_SHIFT_TAIL_PKT_Q0_V2)
+#define BIT_GET_TAIL_PKT_Q0_V2(x)                                              \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q0_V2) & BIT_MASK_TAIL_PKT_Q0_V2)
+
+/* 2 REG_Q0_INFO				(Offset 0x0400) */
+
+#define BIT_SHIFT_HEAD_PKT_Q0_V1 0
+#define BIT_MASK_HEAD_PKT_Q0_V1 0x7ff
+#define BIT_HEAD_PKT_Q0_V1(x)                                                  \
+	(((x) & BIT_MASK_HEAD_PKT_Q0_V1) << BIT_SHIFT_HEAD_PKT_Q0_V1)
+#define BIT_GET_HEAD_PKT_Q0_V1(x)                                              \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q0_V1) & BIT_MASK_HEAD_PKT_Q0_V1)
+
+/* 2 REG_Q1_INFO				(Offset 0x0404) */
+
+#define BIT_SHIFT_QUEUEMACID_Q1_V1 25
+#define BIT_MASK_QUEUEMACID_Q1_V1 0x7f
+#define BIT_QUEUEMACID_Q1_V1(x)                                                \
+	(((x) & BIT_MASK_QUEUEMACID_Q1_V1) << BIT_SHIFT_QUEUEMACID_Q1_V1)
+#define BIT_GET_QUEUEMACID_Q1_V1(x)                                            \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q1_V1) & BIT_MASK_QUEUEMACID_Q1_V1)
+
+#define BIT_SHIFT_QUEUEAC_Q1_V1 23
+#define BIT_MASK_QUEUEAC_Q1_V1 0x3
+#define BIT_QUEUEAC_Q1_V1(x)                                                   \
+	(((x) & BIT_MASK_QUEUEAC_Q1_V1) << BIT_SHIFT_QUEUEAC_Q1_V1)
+#define BIT_GET_QUEUEAC_Q1_V1(x)                                               \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q1_V1) & BIT_MASK_QUEUEAC_Q1_V1)
+
+/* 2 REG_Q1_INFO				(Offset 0x0404) */
+
+#define BIT_TIDEMPTY_Q1_V1 BIT(22)
+
+/* 2 REG_Q1_INFO				(Offset 0x0404) */
+
+#define BIT_SHIFT_TAIL_PKT_Q1_V2 11
+#define BIT_MASK_TAIL_PKT_Q1_V2 0x7ff
+#define BIT_TAIL_PKT_Q1_V2(x)                                                  \
+	(((x) & BIT_MASK_TAIL_PKT_Q1_V2) << BIT_SHIFT_TAIL_PKT_Q1_V2)
+#define BIT_GET_TAIL_PKT_Q1_V2(x)                                              \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q1_V2) & BIT_MASK_TAIL_PKT_Q1_V2)
+
+/* 2 REG_Q1_INFO				(Offset 0x0404) */
+
+#define BIT_SHIFT_HEAD_PKT_Q1_V1 0
+#define BIT_MASK_HEAD_PKT_Q1_V1 0x7ff
+#define BIT_HEAD_PKT_Q1_V1(x)                                                  \
+	(((x) & BIT_MASK_HEAD_PKT_Q1_V1) << BIT_SHIFT_HEAD_PKT_Q1_V1)
+#define BIT_GET_HEAD_PKT_Q1_V1(x)                                              \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q1_V1) & BIT_MASK_HEAD_PKT_Q1_V1)
+
+/* 2 REG_Q2_INFO				(Offset 0x0408) */
+
+#define BIT_SHIFT_QUEUEMACID_Q2_V1 25
+#define BIT_MASK_QUEUEMACID_Q2_V1 0x7f
+#define BIT_QUEUEMACID_Q2_V1(x)                                                \
+	(((x) & BIT_MASK_QUEUEMACID_Q2_V1) << BIT_SHIFT_QUEUEMACID_Q2_V1)
+#define BIT_GET_QUEUEMACID_Q2_V1(x)                                            \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q2_V1) & BIT_MASK_QUEUEMACID_Q2_V1)
+
+#define BIT_SHIFT_QUEUEAC_Q2_V1 23
+#define BIT_MASK_QUEUEAC_Q2_V1 0x3
+#define BIT_QUEUEAC_Q2_V1(x)                                                   \
+	(((x) & BIT_MASK_QUEUEAC_Q2_V1) << BIT_SHIFT_QUEUEAC_Q2_V1)
+#define BIT_GET_QUEUEAC_Q2_V1(x)                                               \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q2_V1) & BIT_MASK_QUEUEAC_Q2_V1)
+
+/* 2 REG_Q2_INFO				(Offset 0x0408) */
+
+#define BIT_TIDEMPTY_Q2_V1 BIT(22)
+
+/* 2 REG_Q2_INFO				(Offset 0x0408) */
+
+#define BIT_SHIFT_TAIL_PKT_Q2_V2 11
+#define BIT_MASK_TAIL_PKT_Q2_V2 0x7ff
+#define BIT_TAIL_PKT_Q2_V2(x)                                                  \
+	(((x) & BIT_MASK_TAIL_PKT_Q2_V2) << BIT_SHIFT_TAIL_PKT_Q2_V2)
+#define BIT_GET_TAIL_PKT_Q2_V2(x)                                              \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q2_V2) & BIT_MASK_TAIL_PKT_Q2_V2)
+
+/* 2 REG_Q2_INFO				(Offset 0x0408) */
+
+#define BIT_SHIFT_HEAD_PKT_Q2_V1 0
+#define BIT_MASK_HEAD_PKT_Q2_V1 0x7ff
+#define BIT_HEAD_PKT_Q2_V1(x)                                                  \
+	(((x) & BIT_MASK_HEAD_PKT_Q2_V1) << BIT_SHIFT_HEAD_PKT_Q2_V1)
+#define BIT_GET_HEAD_PKT_Q2_V1(x)                                              \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q2_V1) & BIT_MASK_HEAD_PKT_Q2_V1)
+
+/* 2 REG_Q3_INFO				(Offset 0x040C) */
+
+#define BIT_SHIFT_QUEUEMACID_Q3_V1 25
+#define BIT_MASK_QUEUEMACID_Q3_V1 0x7f
+#define BIT_QUEUEMACID_Q3_V1(x)                                                \
+	(((x) & BIT_MASK_QUEUEMACID_Q3_V1) << BIT_SHIFT_QUEUEMACID_Q3_V1)
+#define BIT_GET_QUEUEMACID_Q3_V1(x)                                            \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q3_V1) & BIT_MASK_QUEUEMACID_Q3_V1)
+
+#define BIT_SHIFT_QUEUEAC_Q3_V1 23
+#define BIT_MASK_QUEUEAC_Q3_V1 0x3
+#define BIT_QUEUEAC_Q3_V1(x)                                                   \
+	(((x) & BIT_MASK_QUEUEAC_Q3_V1) << BIT_SHIFT_QUEUEAC_Q3_V1)
+#define BIT_GET_QUEUEAC_Q3_V1(x)                                               \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q3_V1) & BIT_MASK_QUEUEAC_Q3_V1)
+
+/* 2 REG_Q3_INFO				(Offset 0x040C) */
+
+#define BIT_TIDEMPTY_Q3_V1 BIT(22)
+
+/* 2 REG_Q3_INFO				(Offset 0x040C) */
+
+#define BIT_SHIFT_TAIL_PKT_Q3_V2 11
+#define BIT_MASK_TAIL_PKT_Q3_V2 0x7ff
+#define BIT_TAIL_PKT_Q3_V2(x)                                                  \
+	(((x) & BIT_MASK_TAIL_PKT_Q3_V2) << BIT_SHIFT_TAIL_PKT_Q3_V2)
+#define BIT_GET_TAIL_PKT_Q3_V2(x)                                              \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q3_V2) & BIT_MASK_TAIL_PKT_Q3_V2)
+
+/* 2 REG_Q3_INFO				(Offset 0x040C) */
+
+#define BIT_SHIFT_HEAD_PKT_Q3_V1 0
+#define BIT_MASK_HEAD_PKT_Q3_V1 0x7ff
+#define BIT_HEAD_PKT_Q3_V1(x)                                                  \
+	(((x) & BIT_MASK_HEAD_PKT_Q3_V1) << BIT_SHIFT_HEAD_PKT_Q3_V1)
+#define BIT_GET_HEAD_PKT_Q3_V1(x)                                              \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q3_V1) & BIT_MASK_HEAD_PKT_Q3_V1)
+
+/* 2 REG_MGQ_INFO				(Offset 0x0410) */
+
+#define BIT_SHIFT_QUEUEMACID_MGQ_V1 25
+#define BIT_MASK_QUEUEMACID_MGQ_V1 0x7f
+#define BIT_QUEUEMACID_MGQ_V1(x)                                               \
+	(((x) & BIT_MASK_QUEUEMACID_MGQ_V1) << BIT_SHIFT_QUEUEMACID_MGQ_V1)
+#define BIT_GET_QUEUEMACID_MGQ_V1(x)                                           \
+	(((x) >> BIT_SHIFT_QUEUEMACID_MGQ_V1) & BIT_MASK_QUEUEMACID_MGQ_V1)
+
+#define BIT_SHIFT_QUEUEAC_MGQ_V1 23
+#define BIT_MASK_QUEUEAC_MGQ_V1 0x3
+#define BIT_QUEUEAC_MGQ_V1(x)                                                  \
+	(((x) & BIT_MASK_QUEUEAC_MGQ_V1) << BIT_SHIFT_QUEUEAC_MGQ_V1)
+#define BIT_GET_QUEUEAC_MGQ_V1(x)                                              \
+	(((x) >> BIT_SHIFT_QUEUEAC_MGQ_V1) & BIT_MASK_QUEUEAC_MGQ_V1)
+
+/* 2 REG_MGQ_INFO				(Offset 0x0410) */
+
+#define BIT_TIDEMPTY_MGQ_V1 BIT(22)
+
+/* 2 REG_MGQ_INFO				(Offset 0x0410) */
+
+#define BIT_SHIFT_TAIL_PKT_MGQ_V2 11
+#define BIT_MASK_TAIL_PKT_MGQ_V2 0x7ff
+#define BIT_TAIL_PKT_MGQ_V2(x)                                                 \
+	(((x) & BIT_MASK_TAIL_PKT_MGQ_V2) << BIT_SHIFT_TAIL_PKT_MGQ_V2)
+#define BIT_GET_TAIL_PKT_MGQ_V2(x)                                             \
+	(((x) >> BIT_SHIFT_TAIL_PKT_MGQ_V2) & BIT_MASK_TAIL_PKT_MGQ_V2)
+
+/* 2 REG_MGQ_INFO				(Offset 0x0410) */
+
+#define BIT_SHIFT_HEAD_PKT_MGQ_V1 0
+#define BIT_MASK_HEAD_PKT_MGQ_V1 0x7ff
+#define BIT_HEAD_PKT_MGQ_V1(x)                                                 \
+	(((x) & BIT_MASK_HEAD_PKT_MGQ_V1) << BIT_SHIFT_HEAD_PKT_MGQ_V1)
+#define BIT_GET_HEAD_PKT_MGQ_V1(x)                                             \
+	(((x) >> BIT_SHIFT_HEAD_PKT_MGQ_V1) & BIT_MASK_HEAD_PKT_MGQ_V1)
+
+/* 2 REG_HIQ_INFO				(Offset 0x0414) */
+
+#define BIT_SHIFT_QUEUEMACID_HIQ_V1 25
+#define BIT_MASK_QUEUEMACID_HIQ_V1 0x7f
+#define BIT_QUEUEMACID_HIQ_V1(x)                                               \
+	(((x) & BIT_MASK_QUEUEMACID_HIQ_V1) << BIT_SHIFT_QUEUEMACID_HIQ_V1)
+#define BIT_GET_QUEUEMACID_HIQ_V1(x)                                           \
+	(((x) >> BIT_SHIFT_QUEUEMACID_HIQ_V1) & BIT_MASK_QUEUEMACID_HIQ_V1)
+
+#define BIT_SHIFT_QUEUEAC_HIQ_V1 23
+#define BIT_MASK_QUEUEAC_HIQ_V1 0x3
+#define BIT_QUEUEAC_HIQ_V1(x)                                                  \
+	(((x) & BIT_MASK_QUEUEAC_HIQ_V1) << BIT_SHIFT_QUEUEAC_HIQ_V1)
+#define BIT_GET_QUEUEAC_HIQ_V1(x)                                              \
+	(((x) >> BIT_SHIFT_QUEUEAC_HIQ_V1) & BIT_MASK_QUEUEAC_HIQ_V1)
+
+/* 2 REG_HIQ_INFO				(Offset 0x0414) */
+
+#define BIT_TIDEMPTY_HIQ_V1 BIT(22)
+
+/* 2 REG_HIQ_INFO				(Offset 0x0414) */
+
+#define BIT_SHIFT_TAIL_PKT_HIQ_V2 11
+#define BIT_MASK_TAIL_PKT_HIQ_V2 0x7ff
+#define BIT_TAIL_PKT_HIQ_V2(x)                                                 \
+	(((x) & BIT_MASK_TAIL_PKT_HIQ_V2) << BIT_SHIFT_TAIL_PKT_HIQ_V2)
+#define BIT_GET_TAIL_PKT_HIQ_V2(x)                                             \
+	(((x) >> BIT_SHIFT_TAIL_PKT_HIQ_V2) & BIT_MASK_TAIL_PKT_HIQ_V2)
+
+/* 2 REG_HIQ_INFO				(Offset 0x0414) */
+
+#define BIT_SHIFT_HEAD_PKT_HIQ_V1 0
+#define BIT_MASK_HEAD_PKT_HIQ_V1 0x7ff
+#define BIT_HEAD_PKT_HIQ_V1(x)                                                 \
+	(((x) & BIT_MASK_HEAD_PKT_HIQ_V1) << BIT_SHIFT_HEAD_PKT_HIQ_V1)
+#define BIT_GET_HEAD_PKT_HIQ_V1(x)                                             \
+	(((x) >> BIT_SHIFT_HEAD_PKT_HIQ_V1) & BIT_MASK_HEAD_PKT_HIQ_V1)
+
+/* 2 REG_BCNQ_INFO				(Offset 0x0418) */
+
+#define BIT_SHIFT_BCNQ_HEAD_PG_V1 0
+#define BIT_MASK_BCNQ_HEAD_PG_V1 0xfff
+#define BIT_BCNQ_HEAD_PG_V1(x)                                                 \
+	(((x) & BIT_MASK_BCNQ_HEAD_PG_V1) << BIT_SHIFT_BCNQ_HEAD_PG_V1)
+#define BIT_GET_BCNQ_HEAD_PG_V1(x)                                             \
+	(((x) >> BIT_SHIFT_BCNQ_HEAD_PG_V1) & BIT_MASK_BCNQ_HEAD_PG_V1)
+
+/* 2 REG_TXPKT_EMPTY				(Offset 0x041A) */
+
+#define BIT_BCNQ_EMPTY BIT(11)
+#define BIT_HQQ_EMPTY BIT(10)
+#define BIT_MQQ_EMPTY BIT(9)
+#define BIT_MGQ_CPU_EMPTY BIT(8)
+#define BIT_AC7Q_EMPTY BIT(7)
+#define BIT_AC6Q_EMPTY BIT(6)
+#define BIT_AC5Q_EMPTY BIT(5)
+#define BIT_AC4Q_EMPTY BIT(4)
+#define BIT_AC3Q_EMPTY BIT(3)
+#define BIT_AC2Q_EMPTY BIT(2)
+#define BIT_AC1Q_EMPTY BIT(1)
+#define BIT_AC0Q_EMPTY BIT(0)
+
+/* 2 REG_CPU_MGQ_INFO			(Offset 0x041C) */
+
+#define BIT_BCN1_POLL BIT(30)
+
+/* 2 REG_CPU_MGQ_INFO			(Offset 0x041C) */
+
+#define BIT_CPUMGT_POLL BIT(29)
+#define BIT_BCN_POLL BIT(28)
+
+/* 2 REG_CPU_MGQ_INFO			(Offset 0x041C) */
+
+#define BIT_CPUMGQ_FW_NUM_V1 BIT(12)
+
+/* 2 REG_CPU_MGQ_INFO			(Offset 0x041C) */
+
+#define BIT_SHIFT_FW_FREE_TAIL_V1 0
+#define BIT_MASK_FW_FREE_TAIL_V1 0xfff
+#define BIT_FW_FREE_TAIL_V1(x)                                                 \
+	(((x) & BIT_MASK_FW_FREE_TAIL_V1) << BIT_SHIFT_FW_FREE_TAIL_V1)
+#define BIT_GET_FW_FREE_TAIL_V1(x)                                             \
+	(((x) >> BIT_SHIFT_FW_FREE_TAIL_V1) & BIT_MASK_FW_FREE_TAIL_V1)
+
+/* 2 REG_FWHW_TXQ_CTRL			(Offset 0x0420) */
+
+#define BIT_RTS_LIMIT_IN_OFDM BIT(23)
+#define BIT_EN_BCNQ_DL BIT(22)
+#define BIT_EN_RD_RESP_NAV_BK BIT(21)
+#define BIT_EN_WR_FREE_TAIL BIT(20)
+
+#define BIT_SHIFT_EN_QUEUE_RPT 8
+#define BIT_MASK_EN_QUEUE_RPT 0xff
+#define BIT_EN_QUEUE_RPT(x)                                                    \
+	(((x) & BIT_MASK_EN_QUEUE_RPT) << BIT_SHIFT_EN_QUEUE_RPT)
+#define BIT_GET_EN_QUEUE_RPT(x)                                                \
+	(((x) >> BIT_SHIFT_EN_QUEUE_RPT) & BIT_MASK_EN_QUEUE_RPT)
+
+#define BIT_EN_RTY_BK BIT(7)
+#define BIT_EN_USE_INI_RAT BIT(6)
+#define BIT_EN_RTS_NAV_BK BIT(5)
+#define BIT_DIS_SSN_CHECK BIT(4)
+#define BIT_MACID_MATCH_RTS BIT(3)
+
+/* 2 REG_FWHW_TXQ_CTRL			(Offset 0x0420) */
+
+#define BIT_EN_BCN_TRXRPT_V1 BIT(2)
+
+/* 2 REG_FWHW_TXQ_CTRL			(Offset 0x0420) */
+
+#define BIT_EN_FTMACKRPT BIT(1)
+
+/* 2 REG_FWHW_TXQ_CTRL			(Offset 0x0420) */
+
+#define BIT_EN_FTMRPT BIT(0)
+
+/* 2 REG_DATAFB_SEL				(Offset 0x0423) */
+
+#define BIT__R_EN_RTY_BK_COD BIT(2)
+
+/* 2 REG_DATAFB_SEL				(Offset 0x0423) */
+
+#define BIT_SHIFT__R_DATA_FALLBACK_SEL 0
+#define BIT_MASK__R_DATA_FALLBACK_SEL 0x3
+#define BIT__R_DATA_FALLBACK_SEL(x)                                            \
+	(((x) & BIT_MASK__R_DATA_FALLBACK_SEL)                                 \
+	 << BIT_SHIFT__R_DATA_FALLBACK_SEL)
+#define BIT_GET__R_DATA_FALLBACK_SEL(x)                                        \
+	(((x) >> BIT_SHIFT__R_DATA_FALLBACK_SEL) &                             \
+	 BIT_MASK__R_DATA_FALLBACK_SEL)
+
+/* 2 REG_BCNQ_BDNY_V1			(Offset 0x0424) */
+
+#define BIT_SHIFT_BCNQ_PGBNDY_V1 0
+#define BIT_MASK_BCNQ_PGBNDY_V1 0xfff
+#define BIT_BCNQ_PGBNDY_V1(x)                                                  \
+	(((x) & BIT_MASK_BCNQ_PGBNDY_V1) << BIT_SHIFT_BCNQ_PGBNDY_V1)
+#define BIT_GET_BCNQ_PGBNDY_V1(x)                                              \
+	(((x) >> BIT_SHIFT_BCNQ_PGBNDY_V1) & BIT_MASK_BCNQ_PGBNDY_V1)
+
+/* 2 REG_LIFETIME_EN				(Offset 0x0426) */
+
+#define BIT_BT_INT_CPU BIT(7)
+#define BIT_BT_INT_PTA BIT(6)
+
+/* 2 REG_LIFETIME_EN				(Offset 0x0426) */
+
+#define BIT_EN_CTRL_RTYBIT BIT(4)
+
+/* 2 REG_LIFETIME_EN				(Offset 0x0426) */
+
+#define BIT_LIFETIME_BK_EN BIT(3)
+#define BIT_LIFETIME_BE_EN BIT(2)
+#define BIT_LIFETIME_VI_EN BIT(1)
+#define BIT_LIFETIME_VO_EN BIT(0)
+
+/* 2 REG_SPEC_SIFS				(Offset 0x0428) */
+
+#define BIT_SHIFT_SPEC_SIFS_OFDM_PTCL 8
+#define BIT_MASK_SPEC_SIFS_OFDM_PTCL 0xff
+#define BIT_SPEC_SIFS_OFDM_PTCL(x)                                             \
+	(((x) & BIT_MASK_SPEC_SIFS_OFDM_PTCL) << BIT_SHIFT_SPEC_SIFS_OFDM_PTCL)
+#define BIT_GET_SPEC_SIFS_OFDM_PTCL(x)                                         \
+	(((x) >> BIT_SHIFT_SPEC_SIFS_OFDM_PTCL) & BIT_MASK_SPEC_SIFS_OFDM_PTCL)
+
+#define BIT_SHIFT_SPEC_SIFS_CCK_PTCL 0
+#define BIT_MASK_SPEC_SIFS_CCK_PTCL 0xff
+#define BIT_SPEC_SIFS_CCK_PTCL(x)                                              \
+	(((x) & BIT_MASK_SPEC_SIFS_CCK_PTCL) << BIT_SHIFT_SPEC_SIFS_CCK_PTCL)
+#define BIT_GET_SPEC_SIFS_CCK_PTCL(x)                                          \
+	(((x) >> BIT_SHIFT_SPEC_SIFS_CCK_PTCL) & BIT_MASK_SPEC_SIFS_CCK_PTCL)
+
+/* 2 REG_RETRY_LIMIT				(Offset 0x042A) */
+
+#define BIT_SHIFT_SRL 8
+#define BIT_MASK_SRL 0x3f
+#define BIT_SRL(x) (((x) & BIT_MASK_SRL) << BIT_SHIFT_SRL)
+#define BIT_GET_SRL(x) (((x) >> BIT_SHIFT_SRL) & BIT_MASK_SRL)
+
+#define BIT_SHIFT_LRL 0
+#define BIT_MASK_LRL 0x3f
+#define BIT_LRL(x) (((x) & BIT_MASK_LRL) << BIT_SHIFT_LRL)
+#define BIT_GET_LRL(x) (((x) >> BIT_SHIFT_LRL) & BIT_MASK_LRL)
+
+/* 2 REG_TXBF_CTRL				(Offset 0x042C) */
+
+#define BIT_R_ENABLE_NDPA BIT(31)
+#define BIT_USE_NDPA_PARAMETER BIT(30)
+#define BIT_R_PROP_TXBF BIT(29)
+#define BIT_R_EN_NDPA_INT BIT(28)
+#define BIT_R_TXBF1_80M BIT(27)
+#define BIT_R_TXBF1_40M BIT(26)
+#define BIT_R_TXBF1_20M BIT(25)
+
+#define BIT_SHIFT_R_TXBF1_AID 16
+#define BIT_MASK_R_TXBF1_AID 0x1ff
+#define BIT_R_TXBF1_AID(x)                                                     \
+	(((x) & BIT_MASK_R_TXBF1_AID) << BIT_SHIFT_R_TXBF1_AID)
+#define BIT_GET_R_TXBF1_AID(x)                                                 \
+	(((x) >> BIT_SHIFT_R_TXBF1_AID) & BIT_MASK_R_TXBF1_AID)
+
+/* 2 REG_TXBF_CTRL				(Offset 0x042C) */
+
+#define BIT_DIS_NDP_BFEN BIT(15)
+
+/* 2 REG_TXBF_CTRL				(Offset 0x042C) */
+
+#define BIT_R_TXBCN_NOBLOCK_NDP BIT(14)
+
+/* 2 REG_TXBF_CTRL				(Offset 0x042C) */
+
+#define BIT_R_TXBF0_80M BIT(11)
+#define BIT_R_TXBF0_40M BIT(10)
+#define BIT_R_TXBF0_20M BIT(9)
+
+#define BIT_SHIFT_R_TXBF0_AID 0
+#define BIT_MASK_R_TXBF0_AID 0x1ff
+#define BIT_R_TXBF0_AID(x)                                                     \
+	(((x) & BIT_MASK_R_TXBF0_AID) << BIT_SHIFT_R_TXBF0_AID)
+#define BIT_GET_R_TXBF0_AID(x)                                                 \
+	(((x) >> BIT_SHIFT_R_TXBF0_AID) & BIT_MASK_R_TXBF0_AID)
+
+/* 2 REG_DARFRC				(Offset 0x0430) */
+
+#define BIT_SHIFT_DARF_RC8 (56 & CPU_OPT_WIDTH)
+#define BIT_MASK_DARF_RC8 0x1f
+#define BIT_DARF_RC8(x) (((x) & BIT_MASK_DARF_RC8) << BIT_SHIFT_DARF_RC8)
+#define BIT_GET_DARF_RC8(x) (((x) >> BIT_SHIFT_DARF_RC8) & BIT_MASK_DARF_RC8)
+
+#define BIT_SHIFT_DARF_RC7 (48 & CPU_OPT_WIDTH)
+#define BIT_MASK_DARF_RC7 0x1f
+#define BIT_DARF_RC7(x) (((x) & BIT_MASK_DARF_RC7) << BIT_SHIFT_DARF_RC7)
+#define BIT_GET_DARF_RC7(x) (((x) >> BIT_SHIFT_DARF_RC7) & BIT_MASK_DARF_RC7)
+
+#define BIT_SHIFT_DARF_RC6 (40 & CPU_OPT_WIDTH)
+#define BIT_MASK_DARF_RC6 0x1f
+#define BIT_DARF_RC6(x) (((x) & BIT_MASK_DARF_RC6) << BIT_SHIFT_DARF_RC6)
+#define BIT_GET_DARF_RC6(x) (((x) >> BIT_SHIFT_DARF_RC6) & BIT_MASK_DARF_RC6)
+
+#define BIT_SHIFT_DARF_RC5 (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_DARF_RC5 0x1f
+#define BIT_DARF_RC5(x) (((x) & BIT_MASK_DARF_RC5) << BIT_SHIFT_DARF_RC5)
+#define BIT_GET_DARF_RC5(x) (((x) >> BIT_SHIFT_DARF_RC5) & BIT_MASK_DARF_RC5)
+
+#define BIT_SHIFT_DARF_RC4 24
+#define BIT_MASK_DARF_RC4 0x1f
+#define BIT_DARF_RC4(x) (((x) & BIT_MASK_DARF_RC4) << BIT_SHIFT_DARF_RC4)
+#define BIT_GET_DARF_RC4(x) (((x) >> BIT_SHIFT_DARF_RC4) & BIT_MASK_DARF_RC4)
+
+#define BIT_SHIFT_DARF_RC3 16
+#define BIT_MASK_DARF_RC3 0x1f
+#define BIT_DARF_RC3(x) (((x) & BIT_MASK_DARF_RC3) << BIT_SHIFT_DARF_RC3)
+#define BIT_GET_DARF_RC3(x) (((x) >> BIT_SHIFT_DARF_RC3) & BIT_MASK_DARF_RC3)
+
+#define BIT_SHIFT_DARF_RC2 8
+#define BIT_MASK_DARF_RC2 0x1f
+#define BIT_DARF_RC2(x) (((x) & BIT_MASK_DARF_RC2) << BIT_SHIFT_DARF_RC2)
+#define BIT_GET_DARF_RC2(x) (((x) >> BIT_SHIFT_DARF_RC2) & BIT_MASK_DARF_RC2)
+
+#define BIT_SHIFT_DARF_RC1 0
+#define BIT_MASK_DARF_RC1 0x1f
+#define BIT_DARF_RC1(x) (((x) & BIT_MASK_DARF_RC1) << BIT_SHIFT_DARF_RC1)
+#define BIT_GET_DARF_RC1(x) (((x) >> BIT_SHIFT_DARF_RC1) & BIT_MASK_DARF_RC1)
+
+/* 2 REG_RARFRC				(Offset 0x0438) */
+
+#define BIT_SHIFT_RARF_RC8 (56 & CPU_OPT_WIDTH)
+#define BIT_MASK_RARF_RC8 0x1f
+#define BIT_RARF_RC8(x) (((x) & BIT_MASK_RARF_RC8) << BIT_SHIFT_RARF_RC8)
+#define BIT_GET_RARF_RC8(x) (((x) >> BIT_SHIFT_RARF_RC8) & BIT_MASK_RARF_RC8)
+
+#define BIT_SHIFT_RARF_RC7 (48 & CPU_OPT_WIDTH)
+#define BIT_MASK_RARF_RC7 0x1f
+#define BIT_RARF_RC7(x) (((x) & BIT_MASK_RARF_RC7) << BIT_SHIFT_RARF_RC7)
+#define BIT_GET_RARF_RC7(x) (((x) >> BIT_SHIFT_RARF_RC7) & BIT_MASK_RARF_RC7)
+
+#define BIT_SHIFT_RARF_RC6 (40 & CPU_OPT_WIDTH)
+#define BIT_MASK_RARF_RC6 0x1f
+#define BIT_RARF_RC6(x) (((x) & BIT_MASK_RARF_RC6) << BIT_SHIFT_RARF_RC6)
+#define BIT_GET_RARF_RC6(x) (((x) >> BIT_SHIFT_RARF_RC6) & BIT_MASK_RARF_RC6)
+
+#define BIT_SHIFT_RARF_RC5 (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_RARF_RC5 0x1f
+#define BIT_RARF_RC5(x) (((x) & BIT_MASK_RARF_RC5) << BIT_SHIFT_RARF_RC5)
+#define BIT_GET_RARF_RC5(x) (((x) >> BIT_SHIFT_RARF_RC5) & BIT_MASK_RARF_RC5)
+
+#define BIT_SHIFT_RARF_RC4 24
+#define BIT_MASK_RARF_RC4 0x1f
+#define BIT_RARF_RC4(x) (((x) & BIT_MASK_RARF_RC4) << BIT_SHIFT_RARF_RC4)
+#define BIT_GET_RARF_RC4(x) (((x) >> BIT_SHIFT_RARF_RC4) & BIT_MASK_RARF_RC4)
+
+#define BIT_SHIFT_RARF_RC3 16
+#define BIT_MASK_RARF_RC3 0x1f
+#define BIT_RARF_RC3(x) (((x) & BIT_MASK_RARF_RC3) << BIT_SHIFT_RARF_RC3)
+#define BIT_GET_RARF_RC3(x) (((x) >> BIT_SHIFT_RARF_RC3) & BIT_MASK_RARF_RC3)
+
+#define BIT_SHIFT_RARF_RC2 8
+#define BIT_MASK_RARF_RC2 0x1f
+#define BIT_RARF_RC2(x) (((x) & BIT_MASK_RARF_RC2) << BIT_SHIFT_RARF_RC2)
+#define BIT_GET_RARF_RC2(x) (((x) >> BIT_SHIFT_RARF_RC2) & BIT_MASK_RARF_RC2)
+
+#define BIT_SHIFT_RARF_RC1 0
+#define BIT_MASK_RARF_RC1 0x1f
+#define BIT_RARF_RC1(x) (((x) & BIT_MASK_RARF_RC1) << BIT_SHIFT_RARF_RC1)
+#define BIT_GET_RARF_RC1(x) (((x) >> BIT_SHIFT_RARF_RC1) & BIT_MASK_RARF_RC1)
+
+/* 2 REG_RRSR				(Offset 0x0440) */
+
+#define BIT_SHIFT_RRSR_RSC 21
+#define BIT_MASK_RRSR_RSC 0x3
+#define BIT_RRSR_RSC(x) (((x) & BIT_MASK_RRSR_RSC) << BIT_SHIFT_RRSR_RSC)
+#define BIT_GET_RRSR_RSC(x) (((x) >> BIT_SHIFT_RRSR_RSC) & BIT_MASK_RRSR_RSC)
+
+#define BIT_RRSR_BW BIT(20)
+
+#define BIT_SHIFT_RRSC_BITMAP 0
+#define BIT_MASK_RRSC_BITMAP 0xfffff
+#define BIT_RRSC_BITMAP(x)                                                     \
+	(((x) & BIT_MASK_RRSC_BITMAP) << BIT_SHIFT_RRSC_BITMAP)
+#define BIT_GET_RRSC_BITMAP(x)                                                 \
+	(((x) >> BIT_SHIFT_RRSC_BITMAP) & BIT_MASK_RRSC_BITMAP)
+
+/* 2 REG_ARFR0				(Offset 0x0444) */
+
+#define BIT_SHIFT_ARFR0_V1 0
+#define BIT_MASK_ARFR0_V1 0xffffffffffffffffL
+#define BIT_ARFR0_V1(x) (((x) & BIT_MASK_ARFR0_V1) << BIT_SHIFT_ARFR0_V1)
+#define BIT_GET_ARFR0_V1(x) (((x) >> BIT_SHIFT_ARFR0_V1) & BIT_MASK_ARFR0_V1)
+
+/* 2 REG_ARFR1_V1				(Offset 0x044C) */
+
+#define BIT_SHIFT_ARFR1_V1 0
+#define BIT_MASK_ARFR1_V1 0xffffffffffffffffL
+#define BIT_ARFR1_V1(x) (((x) & BIT_MASK_ARFR1_V1) << BIT_SHIFT_ARFR1_V1)
+#define BIT_GET_ARFR1_V1(x) (((x) >> BIT_SHIFT_ARFR1_V1) & BIT_MASK_ARFR1_V1)
+
+/* 2 REG_CCK_CHECK				(Offset 0x0454) */
+
+#define BIT_CHECK_CCK_EN BIT(7)
+#define BIT_EN_BCN_PKT_REL BIT(6)
+#define BIT_BCN_PORT_SEL BIT(5)
+#define BIT_MOREDATA_BYPASS BIT(4)
+#define BIT_EN_CLR_CMD_REL_BCN_PKT BIT(3)
+
+/* 2 REG_CCK_CHECK				(Offset 0x0454) */
+
+#define BIT_R_EN_SET_MOREDATA BIT(2)
+#define BIT__R_DIS_CLEAR_MACID_RELEASE BIT(1)
+#define BIT__R_MACID_RELEASE_EN BIT(0)
+
+/* 2 REG_AMPDU_MAX_TIME			(Offset 0x0456) */
+
+#define BIT_SHIFT_AMPDU_MAX_TIME 0
+#define BIT_MASK_AMPDU_MAX_TIME 0xff
+#define BIT_AMPDU_MAX_TIME(x)                                                  \
+	(((x) & BIT_MASK_AMPDU_MAX_TIME) << BIT_SHIFT_AMPDU_MAX_TIME)
+#define BIT_GET_AMPDU_MAX_TIME(x)                                              \
+	(((x) >> BIT_SHIFT_AMPDU_MAX_TIME) & BIT_MASK_AMPDU_MAX_TIME)
+
+/* 2 REG_BCNQ1_BDNY_V1			(Offset 0x0456) */
+
+#define BIT_SHIFT_BCNQ1_PGBNDY_V1 0
+#define BIT_MASK_BCNQ1_PGBNDY_V1 0xfff
+#define BIT_BCNQ1_PGBNDY_V1(x)                                                 \
+	(((x) & BIT_MASK_BCNQ1_PGBNDY_V1) << BIT_SHIFT_BCNQ1_PGBNDY_V1)
+#define BIT_GET_BCNQ1_PGBNDY_V1(x)                                             \
+	(((x) >> BIT_SHIFT_BCNQ1_PGBNDY_V1) & BIT_MASK_BCNQ1_PGBNDY_V1)
+
+/* 2 REG_AMPDU_MAX_LENGTH			(Offset 0x0458) */
+
+#define BIT_SHIFT_AMPDU_MAX_LENGTH 0
+#define BIT_MASK_AMPDU_MAX_LENGTH 0xffffffffL
+#define BIT_AMPDU_MAX_LENGTH(x)                                                \
+	(((x) & BIT_MASK_AMPDU_MAX_LENGTH) << BIT_SHIFT_AMPDU_MAX_LENGTH)
+#define BIT_GET_AMPDU_MAX_LENGTH(x)                                            \
+	(((x) >> BIT_SHIFT_AMPDU_MAX_LENGTH) & BIT_MASK_AMPDU_MAX_LENGTH)
+
+/* 2 REG_ACQ_STOP				(Offset 0x045C) */
+
+#define BIT_AC7Q_STOP BIT(7)
+#define BIT_AC6Q_STOP BIT(6)
+#define BIT_AC5Q_STOP BIT(5)
+#define BIT_AC4Q_STOP BIT(4)
+#define BIT_AC3Q_STOP BIT(3)
+#define BIT_AC2Q_STOP BIT(2)
+#define BIT_AC1Q_STOP BIT(1)
+#define BIT_AC0Q_STOP BIT(0)
+
+/* 2 REG_NDPA_RATE				(Offset 0x045D) */
+
+#define BIT_SHIFT_R_NDPA_RATE_V1 0
+#define BIT_MASK_R_NDPA_RATE_V1 0xff
+#define BIT_R_NDPA_RATE_V1(x)                                                  \
+	(((x) & BIT_MASK_R_NDPA_RATE_V1) << BIT_SHIFT_R_NDPA_RATE_V1)
+#define BIT_GET_R_NDPA_RATE_V1(x)                                              \
+	(((x) >> BIT_SHIFT_R_NDPA_RATE_V1) & BIT_MASK_R_NDPA_RATE_V1)
+
+/* 2 REG_TX_HANG_CTRL			(Offset 0x045E) */
+
+#define BIT_R_EN_GNT_BT_AWAKE BIT(3)
+
+/* 2 REG_TX_HANG_CTRL			(Offset 0x045E) */
+
+#define BIT_EN_EOF_V1 BIT(2)
+
+/* 2 REG_TX_HANG_CTRL			(Offset 0x045E) */
+
+#define BIT_DIS_OQT_BLOCK BIT(1)
+#define BIT_SEARCH_QUEUE_EN BIT(0)
+
+/* 2 REG_NDPA_OPT_CTRL			(Offset 0x045F) */
+
+#define BIT_R_DIS_MACID_RELEASE_RTY BIT(5)
+
+/* 2 REG_NDPA_OPT_CTRL			(Offset 0x045F) */
+
+#define BIT_SHIFT_BW_SIGTA 3
+#define BIT_MASK_BW_SIGTA 0x3
+#define BIT_BW_SIGTA(x) (((x) & BIT_MASK_BW_SIGTA) << BIT_SHIFT_BW_SIGTA)
+#define BIT_GET_BW_SIGTA(x) (((x) >> BIT_SHIFT_BW_SIGTA) & BIT_MASK_BW_SIGTA)
+
+/* 2 REG_NDPA_OPT_CTRL			(Offset 0x045F) */
+
+#define BIT_EN_BAR_SIGTA BIT(2)
+
+/* 2 REG_NDPA_OPT_CTRL			(Offset 0x045F) */
+
+#define BIT_SHIFT_R_NDPA_BW 0
+#define BIT_MASK_R_NDPA_BW 0x3
+#define BIT_R_NDPA_BW(x) (((x) & BIT_MASK_R_NDPA_BW) << BIT_SHIFT_R_NDPA_BW)
+#define BIT_GET_R_NDPA_BW(x) (((x) >> BIT_SHIFT_R_NDPA_BW) & BIT_MASK_R_NDPA_BW)
+
+/* 2 REG_RD_RESP_PKT_TH			(Offset 0x0463) */
+
+#define BIT_SHIFT_RD_RESP_PKT_TH_V1 0
+#define BIT_MASK_RD_RESP_PKT_TH_V1 0x3f
+#define BIT_RD_RESP_PKT_TH_V1(x)                                               \
+	(((x) & BIT_MASK_RD_RESP_PKT_TH_V1) << BIT_SHIFT_RD_RESP_PKT_TH_V1)
+#define BIT_GET_RD_RESP_PKT_TH_V1(x)                                           \
+	(((x) >> BIT_SHIFT_RD_RESP_PKT_TH_V1) & BIT_MASK_RD_RESP_PKT_TH_V1)
+
+/* 2 REG_CMDQ_INFO				(Offset 0x0464) */
+
+#define BIT_SHIFT_QUEUEMACID_CMDQ_V1 25
+#define BIT_MASK_QUEUEMACID_CMDQ_V1 0x7f
+#define BIT_QUEUEMACID_CMDQ_V1(x)                                              \
+	(((x) & BIT_MASK_QUEUEMACID_CMDQ_V1) << BIT_SHIFT_QUEUEMACID_CMDQ_V1)
+#define BIT_GET_QUEUEMACID_CMDQ_V1(x)                                          \
+	(((x) >> BIT_SHIFT_QUEUEMACID_CMDQ_V1) & BIT_MASK_QUEUEMACID_CMDQ_V1)
+
+/* 2 REG_CMDQ_INFO				(Offset 0x0464) */
+
+#define BIT_SHIFT_QUEUEAC_CMDQ_V1 23
+#define BIT_MASK_QUEUEAC_CMDQ_V1 0x3
+#define BIT_QUEUEAC_CMDQ_V1(x)                                                 \
+	(((x) & BIT_MASK_QUEUEAC_CMDQ_V1) << BIT_SHIFT_QUEUEAC_CMDQ_V1)
+#define BIT_GET_QUEUEAC_CMDQ_V1(x)                                             \
+	(((x) >> BIT_SHIFT_QUEUEAC_CMDQ_V1) & BIT_MASK_QUEUEAC_CMDQ_V1)
+
+/* 2 REG_CMDQ_INFO				(Offset 0x0464) */
+
+#define BIT_TIDEMPTY_CMDQ_V1 BIT(22)
+
+/* 2 REG_CMDQ_INFO				(Offset 0x0464) */
+
+#define BIT_SHIFT_TAIL_PKT_CMDQ_V2 11
+#define BIT_MASK_TAIL_PKT_CMDQ_V2 0x7ff
+#define BIT_TAIL_PKT_CMDQ_V2(x)                                                \
+	(((x) & BIT_MASK_TAIL_PKT_CMDQ_V2) << BIT_SHIFT_TAIL_PKT_CMDQ_V2)
+#define BIT_GET_TAIL_PKT_CMDQ_V2(x)                                            \
+	(((x) >> BIT_SHIFT_TAIL_PKT_CMDQ_V2) & BIT_MASK_TAIL_PKT_CMDQ_V2)
+
+/* 2 REG_CMDQ_INFO				(Offset 0x0464) */
+
+#define BIT_SHIFT_HEAD_PKT_CMDQ_V1 0
+#define BIT_MASK_HEAD_PKT_CMDQ_V1 0x7ff
+#define BIT_HEAD_PKT_CMDQ_V1(x)                                                \
+	(((x) & BIT_MASK_HEAD_PKT_CMDQ_V1) << BIT_SHIFT_HEAD_PKT_CMDQ_V1)
+#define BIT_GET_HEAD_PKT_CMDQ_V1(x)                                            \
+	(((x) >> BIT_SHIFT_HEAD_PKT_CMDQ_V1) & BIT_MASK_HEAD_PKT_CMDQ_V1)
+
+/* 2 REG_Q4_INFO				(Offset 0x0468) */
+
+#define BIT_SHIFT_QUEUEMACID_Q4_V1 25
+#define BIT_MASK_QUEUEMACID_Q4_V1 0x7f
+#define BIT_QUEUEMACID_Q4_V1(x)                                                \
+	(((x) & BIT_MASK_QUEUEMACID_Q4_V1) << BIT_SHIFT_QUEUEMACID_Q4_V1)
+#define BIT_GET_QUEUEMACID_Q4_V1(x)                                            \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q4_V1) & BIT_MASK_QUEUEMACID_Q4_V1)
+
+#define BIT_SHIFT_QUEUEAC_Q4_V1 23
+#define BIT_MASK_QUEUEAC_Q4_V1 0x3
+#define BIT_QUEUEAC_Q4_V1(x)                                                   \
+	(((x) & BIT_MASK_QUEUEAC_Q4_V1) << BIT_SHIFT_QUEUEAC_Q4_V1)
+#define BIT_GET_QUEUEAC_Q4_V1(x)                                               \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q4_V1) & BIT_MASK_QUEUEAC_Q4_V1)
+
+/* 2 REG_Q4_INFO				(Offset 0x0468) */
+
+#define BIT_TIDEMPTY_Q4_V1 BIT(22)
+
+/* 2 REG_Q4_INFO				(Offset 0x0468) */
+
+#define BIT_SHIFT_TAIL_PKT_Q4_V2 11
+#define BIT_MASK_TAIL_PKT_Q4_V2 0x7ff
+#define BIT_TAIL_PKT_Q4_V2(x)                                                  \
+	(((x) & BIT_MASK_TAIL_PKT_Q4_V2) << BIT_SHIFT_TAIL_PKT_Q4_V2)
+#define BIT_GET_TAIL_PKT_Q4_V2(x)                                              \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q4_V2) & BIT_MASK_TAIL_PKT_Q4_V2)
+
+/* 2 REG_Q4_INFO				(Offset 0x0468) */
+
+#define BIT_SHIFT_HEAD_PKT_Q4_V1 0
+#define BIT_MASK_HEAD_PKT_Q4_V1 0x7ff
+#define BIT_HEAD_PKT_Q4_V1(x)                                                  \
+	(((x) & BIT_MASK_HEAD_PKT_Q4_V1) << BIT_SHIFT_HEAD_PKT_Q4_V1)
+#define BIT_GET_HEAD_PKT_Q4_V1(x)                                              \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q4_V1) & BIT_MASK_HEAD_PKT_Q4_V1)
+
+/* 2 REG_Q5_INFO				(Offset 0x046C) */
+
+#define BIT_SHIFT_QUEUEMACID_Q5_V1 25
+#define BIT_MASK_QUEUEMACID_Q5_V1 0x7f
+#define BIT_QUEUEMACID_Q5_V1(x)                                                \
+	(((x) & BIT_MASK_QUEUEMACID_Q5_V1) << BIT_SHIFT_QUEUEMACID_Q5_V1)
+#define BIT_GET_QUEUEMACID_Q5_V1(x)                                            \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q5_V1) & BIT_MASK_QUEUEMACID_Q5_V1)
+
+#define BIT_SHIFT_QUEUEAC_Q5_V1 23
+#define BIT_MASK_QUEUEAC_Q5_V1 0x3
+#define BIT_QUEUEAC_Q5_V1(x)                                                   \
+	(((x) & BIT_MASK_QUEUEAC_Q5_V1) << BIT_SHIFT_QUEUEAC_Q5_V1)
+#define BIT_GET_QUEUEAC_Q5_V1(x)                                               \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q5_V1) & BIT_MASK_QUEUEAC_Q5_V1)
+
+/* 2 REG_Q5_INFO				(Offset 0x046C) */
+
+#define BIT_TIDEMPTY_Q5_V1 BIT(22)
+
+/* 2 REG_Q5_INFO				(Offset 0x046C) */
+
+#define BIT_SHIFT_TAIL_PKT_Q5_V2 11
+#define BIT_MASK_TAIL_PKT_Q5_V2 0x7ff
+#define BIT_TAIL_PKT_Q5_V2(x)                                                  \
+	(((x) & BIT_MASK_TAIL_PKT_Q5_V2) << BIT_SHIFT_TAIL_PKT_Q5_V2)
+#define BIT_GET_TAIL_PKT_Q5_V2(x)                                              \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q5_V2) & BIT_MASK_TAIL_PKT_Q5_V2)
+
+/* 2 REG_Q5_INFO				(Offset 0x046C) */
+
+#define BIT_SHIFT_HEAD_PKT_Q5_V1 0
+#define BIT_MASK_HEAD_PKT_Q5_V1 0x7ff
+#define BIT_HEAD_PKT_Q5_V1(x)                                                  \
+	(((x) & BIT_MASK_HEAD_PKT_Q5_V1) << BIT_SHIFT_HEAD_PKT_Q5_V1)
+#define BIT_GET_HEAD_PKT_Q5_V1(x)                                              \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q5_V1) & BIT_MASK_HEAD_PKT_Q5_V1)
+
+/* 2 REG_Q6_INFO				(Offset 0x0470) */
+
+#define BIT_SHIFT_QUEUEMACID_Q6_V1 25
+#define BIT_MASK_QUEUEMACID_Q6_V1 0x7f
+#define BIT_QUEUEMACID_Q6_V1(x)                                                \
+	(((x) & BIT_MASK_QUEUEMACID_Q6_V1) << BIT_SHIFT_QUEUEMACID_Q6_V1)
+#define BIT_GET_QUEUEMACID_Q6_V1(x)                                            \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q6_V1) & BIT_MASK_QUEUEMACID_Q6_V1)
+
+#define BIT_SHIFT_QUEUEAC_Q6_V1 23
+#define BIT_MASK_QUEUEAC_Q6_V1 0x3
+#define BIT_QUEUEAC_Q6_V1(x)                                                   \
+	(((x) & BIT_MASK_QUEUEAC_Q6_V1) << BIT_SHIFT_QUEUEAC_Q6_V1)
+#define BIT_GET_QUEUEAC_Q6_V1(x)                                               \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q6_V1) & BIT_MASK_QUEUEAC_Q6_V1)
+
+/* 2 REG_Q6_INFO				(Offset 0x0470) */
+
+#define BIT_TIDEMPTY_Q6_V1 BIT(22)
+
+/* 2 REG_Q6_INFO				(Offset 0x0470) */
+
+#define BIT_SHIFT_TAIL_PKT_Q6_V2 11
+#define BIT_MASK_TAIL_PKT_Q6_V2 0x7ff
+#define BIT_TAIL_PKT_Q6_V2(x)                                                  \
+	(((x) & BIT_MASK_TAIL_PKT_Q6_V2) << BIT_SHIFT_TAIL_PKT_Q6_V2)
+#define BIT_GET_TAIL_PKT_Q6_V2(x)                                              \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q6_V2) & BIT_MASK_TAIL_PKT_Q6_V2)
+
+/* 2 REG_Q6_INFO				(Offset 0x0470) */
+
+#define BIT_SHIFT_HEAD_PKT_Q6_V1 0
+#define BIT_MASK_HEAD_PKT_Q6_V1 0x7ff
+#define BIT_HEAD_PKT_Q6_V1(x)                                                  \
+	(((x) & BIT_MASK_HEAD_PKT_Q6_V1) << BIT_SHIFT_HEAD_PKT_Q6_V1)
+#define BIT_GET_HEAD_PKT_Q6_V1(x)                                              \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q6_V1) & BIT_MASK_HEAD_PKT_Q6_V1)
+
+/* 2 REG_Q7_INFO				(Offset 0x0474) */
+
+#define BIT_SHIFT_QUEUEMACID_Q7_V1 25
+#define BIT_MASK_QUEUEMACID_Q7_V1 0x7f
+#define BIT_QUEUEMACID_Q7_V1(x)                                                \
+	(((x) & BIT_MASK_QUEUEMACID_Q7_V1) << BIT_SHIFT_QUEUEMACID_Q7_V1)
+#define BIT_GET_QUEUEMACID_Q7_V1(x)                                            \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q7_V1) & BIT_MASK_QUEUEMACID_Q7_V1)
+
+#define BIT_SHIFT_QUEUEAC_Q7_V1 23
+#define BIT_MASK_QUEUEAC_Q7_V1 0x3
+#define BIT_QUEUEAC_Q7_V1(x)                                                   \
+	(((x) & BIT_MASK_QUEUEAC_Q7_V1) << BIT_SHIFT_QUEUEAC_Q7_V1)
+#define BIT_GET_QUEUEAC_Q7_V1(x)                                               \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q7_V1) & BIT_MASK_QUEUEAC_Q7_V1)
+
+/* 2 REG_Q7_INFO				(Offset 0x0474) */
+
+#define BIT_TIDEMPTY_Q7_V1 BIT(22)
+
+/* 2 REG_Q7_INFO				(Offset 0x0474) */
+
+#define BIT_SHIFT_TAIL_PKT_Q7_V2 11
+#define BIT_MASK_TAIL_PKT_Q7_V2 0x7ff
+#define BIT_TAIL_PKT_Q7_V2(x)                                                  \
+	(((x) & BIT_MASK_TAIL_PKT_Q7_V2) << BIT_SHIFT_TAIL_PKT_Q7_V2)
+#define BIT_GET_TAIL_PKT_Q7_V2(x)                                              \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q7_V2) & BIT_MASK_TAIL_PKT_Q7_V2)
+
+/* 2 REG_Q7_INFO				(Offset 0x0474) */
+
+#define BIT_SHIFT_HEAD_PKT_Q7_V1 0
+#define BIT_MASK_HEAD_PKT_Q7_V1 0x7ff
+#define BIT_HEAD_PKT_Q7_V1(x)                                                  \
+	(((x) & BIT_MASK_HEAD_PKT_Q7_V1) << BIT_SHIFT_HEAD_PKT_Q7_V1)
+#define BIT_GET_HEAD_PKT_Q7_V1(x)                                              \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q7_V1) & BIT_MASK_HEAD_PKT_Q7_V1)
+
+/* 2 REG_WMAC_LBK_BUF_HD_V1			(Offset 0x0478) */
+
+#define BIT_SHIFT_WMAC_LBK_BUF_HEAD_V1 0
+#define BIT_MASK_WMAC_LBK_BUF_HEAD_V1 0xfff
+#define BIT_WMAC_LBK_BUF_HEAD_V1(x)                                            \
+	(((x) & BIT_MASK_WMAC_LBK_BUF_HEAD_V1)                                 \
+	 << BIT_SHIFT_WMAC_LBK_BUF_HEAD_V1)
+#define BIT_GET_WMAC_LBK_BUF_HEAD_V1(x)                                        \
+	(((x) >> BIT_SHIFT_WMAC_LBK_BUF_HEAD_V1) &                             \
+	 BIT_MASK_WMAC_LBK_BUF_HEAD_V1)
+
+/* 2 REG_MGQ_BDNY_V1				(Offset 0x047A) */
+
+#define BIT_SHIFT_MGQ_PGBNDY_V1 0
+#define BIT_MASK_MGQ_PGBNDY_V1 0xfff
+#define BIT_MGQ_PGBNDY_V1(x)                                                   \
+	(((x) & BIT_MASK_MGQ_PGBNDY_V1) << BIT_SHIFT_MGQ_PGBNDY_V1)
+#define BIT_GET_MGQ_PGBNDY_V1(x)                                               \
+	(((x) >> BIT_SHIFT_MGQ_PGBNDY_V1) & BIT_MASK_MGQ_PGBNDY_V1)
+
+/* 2 REG_TXRPT_CTRL				(Offset 0x047C) */
+
+#define BIT_SHIFT_TRXRPT_TIMER_TH 24
+#define BIT_MASK_TRXRPT_TIMER_TH 0xff
+#define BIT_TRXRPT_TIMER_TH(x)                                                 \
+	(((x) & BIT_MASK_TRXRPT_TIMER_TH) << BIT_SHIFT_TRXRPT_TIMER_TH)
+#define BIT_GET_TRXRPT_TIMER_TH(x)                                             \
+	(((x) >> BIT_SHIFT_TRXRPT_TIMER_TH) & BIT_MASK_TRXRPT_TIMER_TH)
+
+/* 2 REG_TXRPT_CTRL				(Offset 0x047C) */
+
+#define BIT_SHIFT_TRXRPT_LEN_TH 16
+#define BIT_MASK_TRXRPT_LEN_TH 0xff
+#define BIT_TRXRPT_LEN_TH(x)                                                   \
+	(((x) & BIT_MASK_TRXRPT_LEN_TH) << BIT_SHIFT_TRXRPT_LEN_TH)
+#define BIT_GET_TRXRPT_LEN_TH(x)                                               \
+	(((x) >> BIT_SHIFT_TRXRPT_LEN_TH) & BIT_MASK_TRXRPT_LEN_TH)
+
+/* 2 REG_TXRPT_CTRL				(Offset 0x047C) */
+
+#define BIT_SHIFT_TRXRPT_READ_PTR 8
+#define BIT_MASK_TRXRPT_READ_PTR 0xff
+#define BIT_TRXRPT_READ_PTR(x)                                                 \
+	(((x) & BIT_MASK_TRXRPT_READ_PTR) << BIT_SHIFT_TRXRPT_READ_PTR)
+#define BIT_GET_TRXRPT_READ_PTR(x)                                             \
+	(((x) >> BIT_SHIFT_TRXRPT_READ_PTR) & BIT_MASK_TRXRPT_READ_PTR)
+
+/* 2 REG_TXRPT_CTRL				(Offset 0x047C) */
+
+#define BIT_SHIFT_TRXRPT_WRITE_PTR 0
+#define BIT_MASK_TRXRPT_WRITE_PTR 0xff
+#define BIT_TRXRPT_WRITE_PTR(x)                                                \
+	(((x) & BIT_MASK_TRXRPT_WRITE_PTR) << BIT_SHIFT_TRXRPT_WRITE_PTR)
+#define BIT_GET_TRXRPT_WRITE_PTR(x)                                            \
+	(((x) >> BIT_SHIFT_TRXRPT_WRITE_PTR) & BIT_MASK_TRXRPT_WRITE_PTR)
+
+/* 2 REG_INIRTS_RATE_SEL			(Offset 0x0480) */
+
+#define BIT_LEAG_RTS_BW_DUP BIT(5)
+
+/* 2 REG_BASIC_CFEND_RATE			(Offset 0x0481) */
+
+#define BIT_SHIFT_BASIC_CFEND_RATE 0
+#define BIT_MASK_BASIC_CFEND_RATE 0x1f
+#define BIT_BASIC_CFEND_RATE(x)                                                \
+	(((x) & BIT_MASK_BASIC_CFEND_RATE) << BIT_SHIFT_BASIC_CFEND_RATE)
+#define BIT_GET_BASIC_CFEND_RATE(x)                                            \
+	(((x) >> BIT_SHIFT_BASIC_CFEND_RATE) & BIT_MASK_BASIC_CFEND_RATE)
+
+/* 2 REG_STBC_CFEND_RATE			(Offset 0x0482) */
+
+#define BIT_SHIFT_STBC_CFEND_RATE 0
+#define BIT_MASK_STBC_CFEND_RATE 0x1f
+#define BIT_STBC_CFEND_RATE(x)                                                 \
+	(((x) & BIT_MASK_STBC_CFEND_RATE) << BIT_SHIFT_STBC_CFEND_RATE)
+#define BIT_GET_STBC_CFEND_RATE(x)                                             \
+	(((x) >> BIT_SHIFT_STBC_CFEND_RATE) & BIT_MASK_STBC_CFEND_RATE)
+
+/* 2 REG_DATA_SC				(Offset 0x0483) */
+
+#define BIT_SHIFT_TXSC_40M 4
+#define BIT_MASK_TXSC_40M 0xf
+#define BIT_TXSC_40M(x) (((x) & BIT_MASK_TXSC_40M) << BIT_SHIFT_TXSC_40M)
+#define BIT_GET_TXSC_40M(x) (((x) >> BIT_SHIFT_TXSC_40M) & BIT_MASK_TXSC_40M)
+
+#define BIT_SHIFT_TXSC_20M 0
+#define BIT_MASK_TXSC_20M 0xf
+#define BIT_TXSC_20M(x) (((x) & BIT_MASK_TXSC_20M) << BIT_SHIFT_TXSC_20M)
+#define BIT_GET_TXSC_20M(x) (((x) >> BIT_SHIFT_TXSC_20M) & BIT_MASK_TXSC_20M)
+
+/* 2 REG_MACID_SLEEP3			(Offset 0x0484) */
+
+#define BIT_SHIFT_MACID127_96_PKTSLEEP 0
+#define BIT_MASK_MACID127_96_PKTSLEEP 0xffffffffL
+#define BIT_MACID127_96_PKTSLEEP(x)                                            \
+	(((x) & BIT_MASK_MACID127_96_PKTSLEEP)                                 \
+	 << BIT_SHIFT_MACID127_96_PKTSLEEP)
+#define BIT_GET_MACID127_96_PKTSLEEP(x)                                        \
+	(((x) >> BIT_SHIFT_MACID127_96_PKTSLEEP) &                             \
+	 BIT_MASK_MACID127_96_PKTSLEEP)
+
+/* 2 REG_MACID_SLEEP1			(Offset 0x0488) */
+
+#define BIT_SHIFT_MACID63_32_PKTSLEEP 0
+#define BIT_MASK_MACID63_32_PKTSLEEP 0xffffffffL
+#define BIT_MACID63_32_PKTSLEEP(x)                                             \
+	(((x) & BIT_MASK_MACID63_32_PKTSLEEP) << BIT_SHIFT_MACID63_32_PKTSLEEP)
+#define BIT_GET_MACID63_32_PKTSLEEP(x)                                         \
+	(((x) >> BIT_SHIFT_MACID63_32_PKTSLEEP) & BIT_MASK_MACID63_32_PKTSLEEP)
+
+/* 2 REG_ARFR2_V1				(Offset 0x048C) */
+
+#define BIT_SHIFT_ARFR2_V1 0
+#define BIT_MASK_ARFR2_V1 0xffffffffffffffffL
+#define BIT_ARFR2_V1(x) (((x) & BIT_MASK_ARFR2_V1) << BIT_SHIFT_ARFR2_V1)
+#define BIT_GET_ARFR2_V1(x) (((x) >> BIT_SHIFT_ARFR2_V1) & BIT_MASK_ARFR2_V1)
+
+/* 2 REG_ARFR3_V1				(Offset 0x0494) */
+
+#define BIT_SHIFT_ARFR3_V1 0
+#define BIT_MASK_ARFR3_V1 0xffffffffffffffffL
+#define BIT_ARFR3_V1(x) (((x) & BIT_MASK_ARFR3_V1) << BIT_SHIFT_ARFR3_V1)
+#define BIT_GET_ARFR3_V1(x) (((x) >> BIT_SHIFT_ARFR3_V1) & BIT_MASK_ARFR3_V1)
+
+/* 2 REG_ARFR4				(Offset 0x049C) */
+
+#define BIT_SHIFT_ARFR4 0
+#define BIT_MASK_ARFR4 0xffffffffffffffffL
+#define BIT_ARFR4(x) (((x) & BIT_MASK_ARFR4) << BIT_SHIFT_ARFR4)
+#define BIT_GET_ARFR4(x) (((x) >> BIT_SHIFT_ARFR4) & BIT_MASK_ARFR4)
+
+/* 2 REG_ARFR5				(Offset 0x04A4) */
+
+#define BIT_SHIFT_ARFR5 0
+#define BIT_MASK_ARFR5 0xffffffffffffffffL
+#define BIT_ARFR5(x) (((x) & BIT_MASK_ARFR5) << BIT_SHIFT_ARFR5)
+#define BIT_GET_ARFR5(x) (((x) >> BIT_SHIFT_ARFR5) & BIT_MASK_ARFR5)
+
+/* 2 REG_TXRPT_START_OFFSET			(Offset 0x04AC) */
+
+#define BIT_SHIFT_MACID_MURATE_OFFSET 24
+#define BIT_MASK_MACID_MURATE_OFFSET 0xff
+#define BIT_MACID_MURATE_OFFSET(x)                                             \
+	(((x) & BIT_MASK_MACID_MURATE_OFFSET) << BIT_SHIFT_MACID_MURATE_OFFSET)
+#define BIT_GET_MACID_MURATE_OFFSET(x)                                         \
+	(((x) >> BIT_SHIFT_MACID_MURATE_OFFSET) & BIT_MASK_MACID_MURATE_OFFSET)
+
+/* 2 REG_TXRPT_START_OFFSET			(Offset 0x04AC) */
+
+#define BIT_RPTFIFO_SIZE_OPT BIT(16)
+
+/* 2 REG_TXRPT_START_OFFSET			(Offset 0x04AC) */
+
+#define BIT_SHIFT_MACID_CTRL_OFFSET 8
+#define BIT_MASK_MACID_CTRL_OFFSET 0xff
+#define BIT_MACID_CTRL_OFFSET(x)                                               \
+	(((x) & BIT_MASK_MACID_CTRL_OFFSET) << BIT_SHIFT_MACID_CTRL_OFFSET)
+#define BIT_GET_MACID_CTRL_OFFSET(x)                                           \
+	(((x) >> BIT_SHIFT_MACID_CTRL_OFFSET) & BIT_MASK_MACID_CTRL_OFFSET)
+
+/* 2 REG_TXRPT_START_OFFSET			(Offset 0x04AC) */
+
+#define BIT_SHIFT_AMPDU_TXRPT_OFFSET 0
+#define BIT_MASK_AMPDU_TXRPT_OFFSET 0xff
+#define BIT_AMPDU_TXRPT_OFFSET(x)                                              \
+	(((x) & BIT_MASK_AMPDU_TXRPT_OFFSET) << BIT_SHIFT_AMPDU_TXRPT_OFFSET)
+#define BIT_GET_AMPDU_TXRPT_OFFSET(x)                                          \
+	(((x) >> BIT_SHIFT_AMPDU_TXRPT_OFFSET) & BIT_MASK_AMPDU_TXRPT_OFFSET)
+
+/* 2 REG_POWER_STAGE1			(Offset 0x04B4) */
+
+#define BIT_PTA_WL_PRI_MASK_CPU_MGQ BIT(31)
+#define BIT_PTA_WL_PRI_MASK_BCNQ BIT(30)
+#define BIT_PTA_WL_PRI_MASK_HIQ BIT(29)
+#define BIT_PTA_WL_PRI_MASK_MGQ BIT(28)
+#define BIT_PTA_WL_PRI_MASK_BK BIT(27)
+#define BIT_PTA_WL_PRI_MASK_BE BIT(26)
+#define BIT_PTA_WL_PRI_MASK_VI BIT(25)
+#define BIT_PTA_WL_PRI_MASK_VO BIT(24)
+
+/* 2 REG_POWER_STAGE1			(Offset 0x04B4) */
+
+#define BIT_SHIFT_POWER_STAGE1 0
+#define BIT_MASK_POWER_STAGE1 0xffffff
+#define BIT_POWER_STAGE1(x)                                                    \
+	(((x) & BIT_MASK_POWER_STAGE1) << BIT_SHIFT_POWER_STAGE1)
+#define BIT_GET_POWER_STAGE1(x)                                                \
+	(((x) >> BIT_SHIFT_POWER_STAGE1) & BIT_MASK_POWER_STAGE1)
+
+/* 2 REG_POWER_STAGE2			(Offset 0x04B8) */
+
+#define BIT__R_CTRL_PKT_POW_ADJ BIT(24)
+
+/* 2 REG_POWER_STAGE2			(Offset 0x04B8) */
+
+#define BIT_SHIFT_POWER_STAGE2 0
+#define BIT_MASK_POWER_STAGE2 0xffffff
+#define BIT_POWER_STAGE2(x)                                                    \
+	(((x) & BIT_MASK_POWER_STAGE2) << BIT_SHIFT_POWER_STAGE2)
+#define BIT_GET_POWER_STAGE2(x)                                                \
+	(((x) >> BIT_SHIFT_POWER_STAGE2) & BIT_MASK_POWER_STAGE2)
+
+/* 2 REG_SW_AMPDU_BURST_MODE_CTRL		(Offset 0x04BC) */
+
+#define BIT_SHIFT_PAD_NUM_THRES 24
+#define BIT_MASK_PAD_NUM_THRES 0x3f
+#define BIT_PAD_NUM_THRES(x)                                                   \
+	(((x) & BIT_MASK_PAD_NUM_THRES) << BIT_SHIFT_PAD_NUM_THRES)
+#define BIT_GET_PAD_NUM_THRES(x)                                               \
+	(((x) >> BIT_SHIFT_PAD_NUM_THRES) & BIT_MASK_PAD_NUM_THRES)
+
+/* 2 REG_SW_AMPDU_BURST_MODE_CTRL		(Offset 0x04BC) */
+
+#define BIT_R_DMA_THIS_QUEUE_BK BIT(23)
+#define BIT_R_DMA_THIS_QUEUE_BE BIT(22)
+#define BIT_R_DMA_THIS_QUEUE_VI BIT(21)
+#define BIT_R_DMA_THIS_QUEUE_VO BIT(20)
+
+#define BIT_SHIFT_R_TOTAL_LEN_TH 8
+#define BIT_MASK_R_TOTAL_LEN_TH 0xfff
+#define BIT_R_TOTAL_LEN_TH(x)                                                  \
+	(((x) & BIT_MASK_R_TOTAL_LEN_TH) << BIT_SHIFT_R_TOTAL_LEN_TH)
+#define BIT_GET_R_TOTAL_LEN_TH(x)                                              \
+	(((x) >> BIT_SHIFT_R_TOTAL_LEN_TH) & BIT_MASK_R_TOTAL_LEN_TH)
+
+/* 2 REG_SW_AMPDU_BURST_MODE_CTRL		(Offset 0x04BC) */
+
+#define BIT_EN_NEW_EARLY BIT(7)
+
+/* 2 REG_SW_AMPDU_BURST_MODE_CTRL		(Offset 0x04BC) */
+
+#define BIT_PRE_TX_CMD BIT(6)
+
+#define BIT_SHIFT_NUM_SCL_EN 4
+#define BIT_MASK_NUM_SCL_EN 0x3
+#define BIT_NUM_SCL_EN(x) (((x) & BIT_MASK_NUM_SCL_EN) << BIT_SHIFT_NUM_SCL_EN)
+#define BIT_GET_NUM_SCL_EN(x)                                                  \
+	(((x) >> BIT_SHIFT_NUM_SCL_EN) & BIT_MASK_NUM_SCL_EN)
+
+#define BIT_BK_EN BIT(3)
+#define BIT_BE_EN BIT(2)
+#define BIT_VI_EN BIT(1)
+#define BIT_VO_EN BIT(0)
+
+/* 2 REG_PKT_LIFE_TIME			(Offset 0x04C0) */
+
+#define BIT_SHIFT_PKT_LIFTIME_BEBK 16
+#define BIT_MASK_PKT_LIFTIME_BEBK 0xffff
+#define BIT_PKT_LIFTIME_BEBK(x)                                                \
+	(((x) & BIT_MASK_PKT_LIFTIME_BEBK) << BIT_SHIFT_PKT_LIFTIME_BEBK)
+#define BIT_GET_PKT_LIFTIME_BEBK(x)                                            \
+	(((x) >> BIT_SHIFT_PKT_LIFTIME_BEBK) & BIT_MASK_PKT_LIFTIME_BEBK)
+
+#define BIT_SHIFT_PKT_LIFTIME_VOVI 0
+#define BIT_MASK_PKT_LIFTIME_VOVI 0xffff
+#define BIT_PKT_LIFTIME_VOVI(x)                                                \
+	(((x) & BIT_MASK_PKT_LIFTIME_VOVI) << BIT_SHIFT_PKT_LIFTIME_VOVI)
+#define BIT_GET_PKT_LIFTIME_VOVI(x)                                            \
+	(((x) >> BIT_SHIFT_PKT_LIFTIME_VOVI) & BIT_MASK_PKT_LIFTIME_VOVI)
+
+/* 2 REG_STBC_SETTING			(Offset 0x04C4) */
+
+#define BIT_SHIFT_CDEND_TXTIME_L 4
+#define BIT_MASK_CDEND_TXTIME_L 0xf
+#define BIT_CDEND_TXTIME_L(x)                                                  \
+	(((x) & BIT_MASK_CDEND_TXTIME_L) << BIT_SHIFT_CDEND_TXTIME_L)
+#define BIT_GET_CDEND_TXTIME_L(x)                                              \
+	(((x) >> BIT_SHIFT_CDEND_TXTIME_L) & BIT_MASK_CDEND_TXTIME_L)
+
+#define BIT_SHIFT_NESS 2
+#define BIT_MASK_NESS 0x3
+#define BIT_NESS(x) (((x) & BIT_MASK_NESS) << BIT_SHIFT_NESS)
+#define BIT_GET_NESS(x) (((x) >> BIT_SHIFT_NESS) & BIT_MASK_NESS)
+
+#define BIT_SHIFT_STBC_CFEND 0
+#define BIT_MASK_STBC_CFEND 0x3
+#define BIT_STBC_CFEND(x) (((x) & BIT_MASK_STBC_CFEND) << BIT_SHIFT_STBC_CFEND)
+#define BIT_GET_STBC_CFEND(x)                                                  \
+	(((x) >> BIT_SHIFT_STBC_CFEND) & BIT_MASK_STBC_CFEND)
+
+/* 2 REG_STBC_SETTING2			(Offset 0x04C5) */
+
+#define BIT_SHIFT_CDEND_TXTIME_H 0
+#define BIT_MASK_CDEND_TXTIME_H 0x1f
+#define BIT_CDEND_TXTIME_H(x)                                                  \
+	(((x) & BIT_MASK_CDEND_TXTIME_H) << BIT_SHIFT_CDEND_TXTIME_H)
+#define BIT_GET_CDEND_TXTIME_H(x)                                              \
+	(((x) >> BIT_SHIFT_CDEND_TXTIME_H) & BIT_MASK_CDEND_TXTIME_H)
+
+/* 2 REG_QUEUE_CTRL				(Offset 0x04C6) */
+
+#define BIT_PTA_EDCCA_EN BIT(5)
+#define BIT_PTA_WL_TX_EN BIT(4)
+
+/* 2 REG_QUEUE_CTRL				(Offset 0x04C6) */
+
+#define BIT_R_USE_DATA_BW BIT(3)
+#define BIT_TRI_PKT_INT_MODE1 BIT(2)
+#define BIT_TRI_PKT_INT_MODE0 BIT(1)
+#define BIT_ACQ_MODE_SEL BIT(0)
+
+/* 2 REG_SINGLE_AMPDU_CTRL			(Offset 0x04C7) */
+
+#define BIT_EN_SINGLE_APMDU BIT(7)
+
+/* 2 REG_PROT_MODE_CTRL			(Offset 0x04C8) */
+
+#define BIT_SHIFT_RTS_MAX_AGG_NUM 24
+#define BIT_MASK_RTS_MAX_AGG_NUM 0x3f
+#define BIT_RTS_MAX_AGG_NUM(x)                                                 \
+	(((x) & BIT_MASK_RTS_MAX_AGG_NUM) << BIT_SHIFT_RTS_MAX_AGG_NUM)
+#define BIT_GET_RTS_MAX_AGG_NUM(x)                                             \
+	(((x) >> BIT_SHIFT_RTS_MAX_AGG_NUM) & BIT_MASK_RTS_MAX_AGG_NUM)
+
+#define BIT_SHIFT_MAX_AGG_NUM 16
+#define BIT_MASK_MAX_AGG_NUM 0x3f
+#define BIT_MAX_AGG_NUM(x)                                                     \
+	(((x) & BIT_MASK_MAX_AGG_NUM) << BIT_SHIFT_MAX_AGG_NUM)
+#define BIT_GET_MAX_AGG_NUM(x)                                                 \
+	(((x) >> BIT_SHIFT_MAX_AGG_NUM) & BIT_MASK_MAX_AGG_NUM)
+
+#define BIT_SHIFT_RTS_TXTIME_TH 8
+#define BIT_MASK_RTS_TXTIME_TH 0xff
+#define BIT_RTS_TXTIME_TH(x)                                                   \
+	(((x) & BIT_MASK_RTS_TXTIME_TH) << BIT_SHIFT_RTS_TXTIME_TH)
+#define BIT_GET_RTS_TXTIME_TH(x)                                               \
+	(((x) >> BIT_SHIFT_RTS_TXTIME_TH) & BIT_MASK_RTS_TXTIME_TH)
+
+#define BIT_SHIFT_RTS_LEN_TH 0
+#define BIT_MASK_RTS_LEN_TH 0xff
+#define BIT_RTS_LEN_TH(x) (((x) & BIT_MASK_RTS_LEN_TH) << BIT_SHIFT_RTS_LEN_TH)
+#define BIT_GET_RTS_LEN_TH(x)                                                  \
+	(((x) >> BIT_SHIFT_RTS_LEN_TH) & BIT_MASK_RTS_LEN_TH)
+
+/* 2 REG_BAR_MODE_CTRL			(Offset 0x04CC) */
+
+#define BIT_SHIFT_BAR_RTY_LMT 16
+#define BIT_MASK_BAR_RTY_LMT 0x3
+#define BIT_BAR_RTY_LMT(x)                                                     \
+	(((x) & BIT_MASK_BAR_RTY_LMT) << BIT_SHIFT_BAR_RTY_LMT)
+#define BIT_GET_BAR_RTY_LMT(x)                                                 \
+	(((x) >> BIT_SHIFT_BAR_RTY_LMT) & BIT_MASK_BAR_RTY_LMT)
+
+#define BIT_SHIFT_BAR_PKT_TXTIME_TH 8
+#define BIT_MASK_BAR_PKT_TXTIME_TH 0xff
+#define BIT_BAR_PKT_TXTIME_TH(x)                                               \
+	(((x) & BIT_MASK_BAR_PKT_TXTIME_TH) << BIT_SHIFT_BAR_PKT_TXTIME_TH)
+#define BIT_GET_BAR_PKT_TXTIME_TH(x)                                           \
+	(((x) >> BIT_SHIFT_BAR_PKT_TXTIME_TH) & BIT_MASK_BAR_PKT_TXTIME_TH)
+
+#define BIT_BAR_EN_V1 BIT(6)
+
+#define BIT_SHIFT_BAR_PKTNUM_TH_V1 0
+#define BIT_MASK_BAR_PKTNUM_TH_V1 0x3f
+#define BIT_BAR_PKTNUM_TH_V1(x)                                                \
+	(((x) & BIT_MASK_BAR_PKTNUM_TH_V1) << BIT_SHIFT_BAR_PKTNUM_TH_V1)
+#define BIT_GET_BAR_PKTNUM_TH_V1(x)                                            \
+	(((x) >> BIT_SHIFT_BAR_PKTNUM_TH_V1) & BIT_MASK_BAR_PKTNUM_TH_V1)
+
+/* 2 REG_RA_TRY_RATE_AGG_LMT			(Offset 0x04CF) */
+
+#define BIT_SHIFT_RA_TRY_RATE_AGG_LMT_V1 0
+#define BIT_MASK_RA_TRY_RATE_AGG_LMT_V1 0x3f
+#define BIT_RA_TRY_RATE_AGG_LMT_V1(x)                                          \
+	(((x) & BIT_MASK_RA_TRY_RATE_AGG_LMT_V1)                               \
+	 << BIT_SHIFT_RA_TRY_RATE_AGG_LMT_V1)
+#define BIT_GET_RA_TRY_RATE_AGG_LMT_V1(x)                                      \
+	(((x) >> BIT_SHIFT_RA_TRY_RATE_AGG_LMT_V1) &                           \
+	 BIT_MASK_RA_TRY_RATE_AGG_LMT_V1)
+
+/* 2 REG_MACID_SLEEP2			(Offset 0x04D0) */
+
+#define BIT_SHIFT_MACID95_64PKTSLEEP 0
+#define BIT_MASK_MACID95_64PKTSLEEP 0xffffffffL
+#define BIT_MACID95_64PKTSLEEP(x)                                              \
+	(((x) & BIT_MASK_MACID95_64PKTSLEEP) << BIT_SHIFT_MACID95_64PKTSLEEP)
+#define BIT_GET_MACID95_64PKTSLEEP(x)                                          \
+	(((x) >> BIT_SHIFT_MACID95_64PKTSLEEP) & BIT_MASK_MACID95_64PKTSLEEP)
+
+/* 2 REG_MACID_SLEEP				(Offset 0x04D4) */
+
+#define BIT_SHIFT_MACID31_0_PKTSLEEP 0
+#define BIT_MASK_MACID31_0_PKTSLEEP 0xffffffffL
+#define BIT_MACID31_0_PKTSLEEP(x)                                              \
+	(((x) & BIT_MASK_MACID31_0_PKTSLEEP) << BIT_SHIFT_MACID31_0_PKTSLEEP)
+#define BIT_GET_MACID31_0_PKTSLEEP(x)                                          \
+	(((x) >> BIT_SHIFT_MACID31_0_PKTSLEEP) & BIT_MASK_MACID31_0_PKTSLEEP)
+
+/* 2 REG_HW_SEQ0				(Offset 0x04D8) */
+
+#define BIT_SHIFT_HW_SSN_SEQ0 0
+#define BIT_MASK_HW_SSN_SEQ0 0xfff
+#define BIT_HW_SSN_SEQ0(x)                                                     \
+	(((x) & BIT_MASK_HW_SSN_SEQ0) << BIT_SHIFT_HW_SSN_SEQ0)
+#define BIT_GET_HW_SSN_SEQ0(x)                                                 \
+	(((x) >> BIT_SHIFT_HW_SSN_SEQ0) & BIT_MASK_HW_SSN_SEQ0)
+
+/* 2 REG_HW_SEQ1				(Offset 0x04DA) */
+
+#define BIT_SHIFT_HW_SSN_SEQ1 0
+#define BIT_MASK_HW_SSN_SEQ1 0xfff
+#define BIT_HW_SSN_SEQ1(x)                                                     \
+	(((x) & BIT_MASK_HW_SSN_SEQ1) << BIT_SHIFT_HW_SSN_SEQ1)
+#define BIT_GET_HW_SSN_SEQ1(x)                                                 \
+	(((x) >> BIT_SHIFT_HW_SSN_SEQ1) & BIT_MASK_HW_SSN_SEQ1)
+
+/* 2 REG_HW_SEQ2				(Offset 0x04DC) */
+
+#define BIT_SHIFT_HW_SSN_SEQ2 0
+#define BIT_MASK_HW_SSN_SEQ2 0xfff
+#define BIT_HW_SSN_SEQ2(x)                                                     \
+	(((x) & BIT_MASK_HW_SSN_SEQ2) << BIT_SHIFT_HW_SSN_SEQ2)
+#define BIT_GET_HW_SSN_SEQ2(x)                                                 \
+	(((x) >> BIT_SHIFT_HW_SSN_SEQ2) & BIT_MASK_HW_SSN_SEQ2)
+
+/* 2 REG_HW_SEQ3				(Offset 0x04DE) */
+
+#define BIT_SHIFT_HW_SSN_SEQ3 0
+#define BIT_MASK_HW_SSN_SEQ3 0xfff
+#define BIT_HW_SSN_SEQ3(x)                                                     \
+	(((x) & BIT_MASK_HW_SSN_SEQ3) << BIT_SHIFT_HW_SSN_SEQ3)
+#define BIT_GET_HW_SSN_SEQ3(x)                                                 \
+	(((x) >> BIT_SHIFT_HW_SSN_SEQ3) & BIT_MASK_HW_SSN_SEQ3)
+
+/* 2 REG_NULL_PKT_STATUS_V1			(Offset 0x04E0) */
+
+#define BIT_SHIFT_PTCL_TOTAL_PG_V2 2
+#define BIT_MASK_PTCL_TOTAL_PG_V2 0x3fff
+#define BIT_PTCL_TOTAL_PG_V2(x)                                                \
+	(((x) & BIT_MASK_PTCL_TOTAL_PG_V2) << BIT_SHIFT_PTCL_TOTAL_PG_V2)
+#define BIT_GET_PTCL_TOTAL_PG_V2(x)                                            \
+	(((x) >> BIT_SHIFT_PTCL_TOTAL_PG_V2) & BIT_MASK_PTCL_TOTAL_PG_V2)
+
+/* 2 REG_NULL_PKT_STATUS			(Offset 0x04E0) */
+
+#define BIT_TX_NULL_1 BIT(1)
+#define BIT_TX_NULL_0 BIT(0)
+
+/* 2 REG_PTCL_ERR_STATUS			(Offset 0x04E2) */
+
+#define BIT_PTCL_RATE_TABLE_INVALID BIT(7)
+#define BIT_FTM_T2R_ERROR BIT(6)
+
+/* 2 REG_PTCL_ERR_STATUS			(Offset 0x04E2) */
+
+#define BIT_PTCL_ERR0 BIT(5)
+#define BIT_PTCL_ERR1 BIT(4)
+#define BIT_PTCL_ERR2 BIT(3)
+#define BIT_PTCL_ERR3 BIT(2)
+#define BIT_PTCL_ERR4 BIT(1)
+#define BIT_PTCL_ERR5 BIT(0)
+
+/* 2 REG_NULL_PKT_STATUS_EXTEND		(Offset 0x04E3) */
+
+#define BIT_CLI3_TX_NULL_1 BIT(7)
+#define BIT_CLI3_TX_NULL_0 BIT(6)
+#define BIT_CLI2_TX_NULL_1 BIT(5)
+#define BIT_CLI2_TX_NULL_0 BIT(4)
+#define BIT_CLI1_TX_NULL_1 BIT(3)
+#define BIT_CLI1_TX_NULL_0 BIT(2)
+#define BIT_CLI0_TX_NULL_1 BIT(1)
+
+/* 2 REG_NULL_PKT_STATUS_EXTEND		(Offset 0x04E3) */
+
+#define BIT_CLI0_TX_NULL_0 BIT(0)
+
+/* 2 REG_VIDEO_ENHANCEMENT_FUN		(Offset 0x04E4) */
+
+#define BIT_VIDEO_JUST_DROP BIT(1)
+#define BIT_VIDEO_ENHANCEMENT_FUN_EN BIT(0)
+
+/* 2 REG_BT_POLLUTE_PKT_CNT			(Offset 0x04E8) */
+
+#define BIT_SHIFT_BT_POLLUTE_PKT_CNT 0
+#define BIT_MASK_BT_POLLUTE_PKT_CNT 0xffff
+#define BIT_BT_POLLUTE_PKT_CNT(x)                                              \
+	(((x) & BIT_MASK_BT_POLLUTE_PKT_CNT) << BIT_SHIFT_BT_POLLUTE_PKT_CNT)
+#define BIT_GET_BT_POLLUTE_PKT_CNT(x)                                          \
+	(((x) >> BIT_SHIFT_BT_POLLUTE_PKT_CNT) & BIT_MASK_BT_POLLUTE_PKT_CNT)
+
+/* 2 REG_PTCL_DBG				(Offset 0x04EC) */
+
+#define BIT_SHIFT_PTCL_DBG 0
+#define BIT_MASK_PTCL_DBG 0xffffffffL
+#define BIT_PTCL_DBG(x) (((x) & BIT_MASK_PTCL_DBG) << BIT_SHIFT_PTCL_DBG)
+#define BIT_GET_PTCL_DBG(x) (((x) >> BIT_SHIFT_PTCL_DBG) & BIT_MASK_PTCL_DBG)
+
+/* 2 REG_CPUMGQ_TIMER_CTRL2			(Offset 0x04F4) */
+
+#define BIT_QUEUE_MACID_AC_NOT_THE_SAME BIT(31)
+
+#define BIT_SHIFT_GTAB_ID 28
+#define BIT_MASK_GTAB_ID 0x7
+#define BIT_GTAB_ID(x) (((x) & BIT_MASK_GTAB_ID) << BIT_SHIFT_GTAB_ID)
+#define BIT_GET_GTAB_ID(x) (((x) >> BIT_SHIFT_GTAB_ID) & BIT_MASK_GTAB_ID)
+
+#define BIT_SHIFT_TRI_HEAD_ADDR 16
+#define BIT_MASK_TRI_HEAD_ADDR 0xfff
+#define BIT_TRI_HEAD_ADDR(x)                                                   \
+	(((x) & BIT_MASK_TRI_HEAD_ADDR) << BIT_SHIFT_TRI_HEAD_ADDR)
+#define BIT_GET_TRI_HEAD_ADDR(x)                                               \
+	(((x) >> BIT_SHIFT_TRI_HEAD_ADDR) & BIT_MASK_TRI_HEAD_ADDR)
+
+#define BIT_QUEUE_MACID_AC_NOT_THE_SAME_V1 BIT(15)
+
+#define BIT_SHIFT_GTAB_ID_V1 12
+#define BIT_MASK_GTAB_ID_V1 0x7
+#define BIT_GTAB_ID_V1(x) (((x) & BIT_MASK_GTAB_ID_V1) << BIT_SHIFT_GTAB_ID_V1)
+#define BIT_GET_GTAB_ID_V1(x)                                                  \
+	(((x) >> BIT_SHIFT_GTAB_ID_V1) & BIT_MASK_GTAB_ID_V1)
+
+#define BIT_DROP_TH_EN BIT(8)
+
+#define BIT_SHIFT_DROP_TH 0
+#define BIT_MASK_DROP_TH 0xff
+#define BIT_DROP_TH(x) (((x) & BIT_MASK_DROP_TH) << BIT_SHIFT_DROP_TH)
+#define BIT_GET_DROP_TH(x) (((x) >> BIT_SHIFT_DROP_TH) & BIT_MASK_DROP_TH)
+
+/* 2 REG_DUMMY_PAGE4_V1			(Offset 0x04FC) */
+
+#define BIT_BCN_EN_EXTHWSEQ BIT(1)
+#define BIT_BCN_EN_HWSEQ BIT(0)
+
+/* 2 REG_MOREDATA				(Offset 0x04FE) */
+
+#define BIT_MOREDATA_CTRL2_EN_V1 BIT(3)
+#define BIT_MOREDATA_CTRL1_EN_V1 BIT(2)
+#define BIT_PKTIN_MOREDATA_REPLACE_ENABLE_V1 BIT(0)
+
+/* 2 REG_EDCA_VO_PARAM			(Offset 0x0500) */
+
+#define BIT_SHIFT_TXOPLIMIT 16
+#define BIT_MASK_TXOPLIMIT 0x7ff
+#define BIT_TXOPLIMIT(x) (((x) & BIT_MASK_TXOPLIMIT) << BIT_SHIFT_TXOPLIMIT)
+#define BIT_GET_TXOPLIMIT(x) (((x) >> BIT_SHIFT_TXOPLIMIT) & BIT_MASK_TXOPLIMIT)
+
+#define BIT_SHIFT_CW 8
+#define BIT_MASK_CW 0xff
+#define BIT_CW(x) (((x) & BIT_MASK_CW) << BIT_SHIFT_CW)
+#define BIT_GET_CW(x) (((x) >> BIT_SHIFT_CW) & BIT_MASK_CW)
+
+#define BIT_SHIFT_AIFS 0
+#define BIT_MASK_AIFS 0xff
+#define BIT_AIFS(x) (((x) & BIT_MASK_AIFS) << BIT_SHIFT_AIFS)
+#define BIT_GET_AIFS(x) (((x) >> BIT_SHIFT_AIFS) & BIT_MASK_AIFS)
+
+/* 2 REG_BCNTCFG				(Offset 0x0510) */
+
+#define BIT_SHIFT_BCNCW_MAX 12
+#define BIT_MASK_BCNCW_MAX 0xf
+#define BIT_BCNCW_MAX(x) (((x) & BIT_MASK_BCNCW_MAX) << BIT_SHIFT_BCNCW_MAX)
+#define BIT_GET_BCNCW_MAX(x) (((x) >> BIT_SHIFT_BCNCW_MAX) & BIT_MASK_BCNCW_MAX)
+
+#define BIT_SHIFT_BCNCW_MIN 8
+#define BIT_MASK_BCNCW_MIN 0xf
+#define BIT_BCNCW_MIN(x) (((x) & BIT_MASK_BCNCW_MIN) << BIT_SHIFT_BCNCW_MIN)
+#define BIT_GET_BCNCW_MIN(x) (((x) >> BIT_SHIFT_BCNCW_MIN) & BIT_MASK_BCNCW_MIN)
+
+#define BIT_SHIFT_BCNIFS 0
+#define BIT_MASK_BCNIFS 0xff
+#define BIT_BCNIFS(x) (((x) & BIT_MASK_BCNIFS) << BIT_SHIFT_BCNIFS)
+#define BIT_GET_BCNIFS(x) (((x) >> BIT_SHIFT_BCNIFS) & BIT_MASK_BCNIFS)
+
+/* 2 REG_PIFS				(Offset 0x0512) */
+
+#define BIT_SHIFT_PIFS 0
+#define BIT_MASK_PIFS 0xff
+#define BIT_PIFS(x) (((x) & BIT_MASK_PIFS) << BIT_SHIFT_PIFS)
+#define BIT_GET_PIFS(x) (((x) >> BIT_SHIFT_PIFS) & BIT_MASK_PIFS)
+
+/* 2 REG_RDG_PIFS				(Offset 0x0513) */
+
+#define BIT_SHIFT_RDG_PIFS 0
+#define BIT_MASK_RDG_PIFS 0xff
+#define BIT_RDG_PIFS(x) (((x) & BIT_MASK_RDG_PIFS) << BIT_SHIFT_RDG_PIFS)
+#define BIT_GET_RDG_PIFS(x) (((x) >> BIT_SHIFT_RDG_PIFS) & BIT_MASK_RDG_PIFS)
+
+/* 2 REG_SIFS				(Offset 0x0514) */
+
+#define BIT_SHIFT_SIFS_OFDM_TRX 24
+#define BIT_MASK_SIFS_OFDM_TRX 0xff
+#define BIT_SIFS_OFDM_TRX(x)                                                   \
+	(((x) & BIT_MASK_SIFS_OFDM_TRX) << BIT_SHIFT_SIFS_OFDM_TRX)
+#define BIT_GET_SIFS_OFDM_TRX(x)                                               \
+	(((x) >> BIT_SHIFT_SIFS_OFDM_TRX) & BIT_MASK_SIFS_OFDM_TRX)
+
+#define BIT_SHIFT_SIFS_CCK_TRX 16
+#define BIT_MASK_SIFS_CCK_TRX 0xff
+#define BIT_SIFS_CCK_TRX(x)                                                    \
+	(((x) & BIT_MASK_SIFS_CCK_TRX) << BIT_SHIFT_SIFS_CCK_TRX)
+#define BIT_GET_SIFS_CCK_TRX(x)                                                \
+	(((x) >> BIT_SHIFT_SIFS_CCK_TRX) & BIT_MASK_SIFS_CCK_TRX)
+
+#define BIT_SHIFT_SIFS_OFDM_CTX 8
+#define BIT_MASK_SIFS_OFDM_CTX 0xff
+#define BIT_SIFS_OFDM_CTX(x)                                                   \
+	(((x) & BIT_MASK_SIFS_OFDM_CTX) << BIT_SHIFT_SIFS_OFDM_CTX)
+#define BIT_GET_SIFS_OFDM_CTX(x)                                               \
+	(((x) >> BIT_SHIFT_SIFS_OFDM_CTX) & BIT_MASK_SIFS_OFDM_CTX)
+
+#define BIT_SHIFT_SIFS_CCK_CTX 0
+#define BIT_MASK_SIFS_CCK_CTX 0xff
+#define BIT_SIFS_CCK_CTX(x)                                                    \
+	(((x) & BIT_MASK_SIFS_CCK_CTX) << BIT_SHIFT_SIFS_CCK_CTX)
+#define BIT_GET_SIFS_CCK_CTX(x)                                                \
+	(((x) >> BIT_SHIFT_SIFS_CCK_CTX) & BIT_MASK_SIFS_CCK_CTX)
+
+/* 2 REG_TSFTR_SYN_OFFSET			(Offset 0x0518) */
+
+#define BIT_SHIFT_TSFTR_SNC_OFFSET 0
+#define BIT_MASK_TSFTR_SNC_OFFSET 0xffff
+#define BIT_TSFTR_SNC_OFFSET(x)                                                \
+	(((x) & BIT_MASK_TSFTR_SNC_OFFSET) << BIT_SHIFT_TSFTR_SNC_OFFSET)
+#define BIT_GET_TSFTR_SNC_OFFSET(x)                                            \
+	(((x) >> BIT_SHIFT_TSFTR_SNC_OFFSET) & BIT_MASK_TSFTR_SNC_OFFSET)
+
+/* 2 REG_AGGR_BREAK_TIME			(Offset 0x051A) */
+
+#define BIT_SHIFT_AGGR_BK_TIME 0
+#define BIT_MASK_AGGR_BK_TIME 0xff
+#define BIT_AGGR_BK_TIME(x)                                                    \
+	(((x) & BIT_MASK_AGGR_BK_TIME) << BIT_SHIFT_AGGR_BK_TIME)
+#define BIT_GET_AGGR_BK_TIME(x)                                                \
+	(((x) >> BIT_SHIFT_AGGR_BK_TIME) & BIT_MASK_AGGR_BK_TIME)
+
+/* 2 REG_SLOT				(Offset 0x051B) */
+
+#define BIT_SHIFT_SLOT 0
+#define BIT_MASK_SLOT 0xff
+#define BIT_SLOT(x) (((x) & BIT_MASK_SLOT) << BIT_SHIFT_SLOT)
+#define BIT_GET_SLOT(x) (((x) >> BIT_SHIFT_SLOT) & BIT_MASK_SLOT)
+
+/* 2 REG_TX_PTCL_CTRL			(Offset 0x0520) */
+
+#define BIT_DIS_EDCCA BIT(15)
+#define BIT_DIS_CCA BIT(14)
+#define BIT_LSIG_TXOP_TXCMD_NAV BIT(13)
+#define BIT_SIFS_BK_EN BIT(12)
+
+#define BIT_SHIFT_TXQ_NAV_MSK 8
+#define BIT_MASK_TXQ_NAV_MSK 0xf
+#define BIT_TXQ_NAV_MSK(x)                                                     \
+	(((x) & BIT_MASK_TXQ_NAV_MSK) << BIT_SHIFT_TXQ_NAV_MSK)
+#define BIT_GET_TXQ_NAV_MSK(x)                                                 \
+	(((x) >> BIT_SHIFT_TXQ_NAV_MSK) & BIT_MASK_TXQ_NAV_MSK)
+
+#define BIT_DIS_CW BIT(7)
+#define BIT_NAV_END_TXOP BIT(6)
+#define BIT_RDG_END_TXOP BIT(5)
+#define BIT_AC_INBCN_HOLD BIT(4)
+#define BIT_MGTQ_TXOP_EN BIT(3)
+#define BIT_MGTQ_RTSMF_EN BIT(2)
+#define BIT_HIQ_RTSMF_EN BIT(1)
+#define BIT_BCN_RTSMF_EN BIT(0)
+
+/* 2 REG_TXPAUSE				(Offset 0x0522) */
+
+#define BIT_STOP_BCN_HI_MGT BIT(7)
+#define BIT_MAC_STOPBCNQ BIT(6)
+#define BIT_MAC_STOPHIQ BIT(5)
+#define BIT_MAC_STOPMGQ BIT(4)
+#define BIT_MAC_STOPBK BIT(3)
+#define BIT_MAC_STOPBE BIT(2)
+#define BIT_MAC_STOPVI BIT(1)
+#define BIT_MAC_STOPVO BIT(0)
+
+/* 2 REG_DIS_TXREQ_CLR			(Offset 0x0523) */
+
+#define BIT_DIS_BT_CCA BIT(7)
+
+/* 2 REG_DIS_TXREQ_CLR			(Offset 0x0523) */
+
+#define BIT_DIS_TXREQ_CLR_HI BIT(5)
+#define BIT_DIS_TXREQ_CLR_MGQ BIT(4)
+#define BIT_DIS_TXREQ_CLR_VO BIT(3)
+#define BIT_DIS_TXREQ_CLR_VI BIT(2)
+#define BIT_DIS_TXREQ_CLR_BE BIT(1)
+#define BIT_DIS_TXREQ_CLR_BK BIT(0)
+
+/* 2 REG_RD_CTRL				(Offset 0x0524) */
+
+#define BIT_EN_CLR_TXREQ_INCCA BIT(15)
+#define BIT_DIS_TX_OVER_BCNQ BIT(14)
+
+/* 2 REG_RD_CTRL				(Offset 0x0524) */
+
+#define BIT_EN_BCNERR_INCCCA BIT(13)
+
+/* 2 REG_RD_CTRL				(Offset 0x0524) */
+
+#define BIT_EDCCA_MSK_CNTDOWN_EN BIT(11)
+#define BIT_DIS_TXOP_CFE BIT(10)
+#define BIT_DIS_LSIG_CFE BIT(9)
+#define BIT_DIS_STBC_CFE BIT(8)
+#define BIT_BKQ_RD_INIT_EN BIT(7)
+#define BIT_BEQ_RD_INIT_EN BIT(6)
+#define BIT_VIQ_RD_INIT_EN BIT(5)
+#define BIT_VOQ_RD_INIT_EN BIT(4)
+#define BIT_BKQ_RD_RESP_EN BIT(3)
+#define BIT_BEQ_RD_RESP_EN BIT(2)
+#define BIT_VIQ_RD_RESP_EN BIT(1)
+#define BIT_VOQ_RD_RESP_EN BIT(0)
+
+/* 2 REG_MBSSID_CTRL				(Offset 0x0526) */
+
+#define BIT_MBID_BCNQ7_EN BIT(7)
+#define BIT_MBID_BCNQ6_EN BIT(6)
+#define BIT_MBID_BCNQ5_EN BIT(5)
+#define BIT_MBID_BCNQ4_EN BIT(4)
+#define BIT_MBID_BCNQ3_EN BIT(3)
+#define BIT_MBID_BCNQ2_EN BIT(2)
+#define BIT_MBID_BCNQ1_EN BIT(1)
+#define BIT_MBID_BCNQ0_EN BIT(0)
+
+/* 2 REG_P2PPS_CTRL				(Offset 0x0527) */
+
+#define BIT_P2P_CTW_ALLSTASLEEP BIT(7)
+#define BIT_P2P_OFF_DISTX_EN BIT(6)
+#define BIT_PWR_MGT_EN BIT(5)
+
+/* 2 REG_P2PPS_CTRL				(Offset 0x0527) */
+
+#define BIT_P2P_NOA1_EN BIT(2)
+#define BIT_P2P_NOA0_EN BIT(1)
+
+/* 2 REG_PKT_LIFETIME_CTRL			(Offset 0x0528) */
+
+#define BIT_EN_P2P_CTWND1 BIT(23)
+
+/* 2 REG_PKT_LIFETIME_CTRL			(Offset 0x0528) */
+
+#define BIT_EN_BKF_CLR_TXREQ BIT(22)
+#define BIT_EN_TSFBIT32_RST_P2P BIT(21)
+#define BIT_EN_BCN_TX_BTCCA BIT(20)
+#define BIT_DIS_PKT_TX_ATIM BIT(19)
+#define BIT_DIS_BCN_DIS_CTN BIT(18)
+#define BIT_EN_NAVEND_RST_TXOP BIT(17)
+#define BIT_EN_FILTER_CCA BIT(16)
+
+#define BIT_SHIFT_CCA_FILTER_THRS 8
+#define BIT_MASK_CCA_FILTER_THRS 0xff
+#define BIT_CCA_FILTER_THRS(x)                                                 \
+	(((x) & BIT_MASK_CCA_FILTER_THRS) << BIT_SHIFT_CCA_FILTER_THRS)
+#define BIT_GET_CCA_FILTER_THRS(x)                                             \
+	(((x) >> BIT_SHIFT_CCA_FILTER_THRS) & BIT_MASK_CCA_FILTER_THRS)
+
+#define BIT_SHIFT_EDCCA_THRS 0
+#define BIT_MASK_EDCCA_THRS 0xff
+#define BIT_EDCCA_THRS(x) (((x) & BIT_MASK_EDCCA_THRS) << BIT_SHIFT_EDCCA_THRS)
+#define BIT_GET_EDCCA_THRS(x)                                                  \
+	(((x) >> BIT_SHIFT_EDCCA_THRS) & BIT_MASK_EDCCA_THRS)
+
+/* 2 REG_P2PPS_SPEC_STATE			(Offset 0x052B) */
+
+#define BIT_SPEC_POWER_STATE BIT(7)
+#define BIT_SPEC_CTWINDOW_ON BIT(6)
+#define BIT_SPEC_BEACON_AREA_ON BIT(5)
+#define BIT_SPEC_CTWIN_EARLY_DISTX BIT(4)
+#define BIT_SPEC_NOA1_OFF_PERIOD BIT(3)
+#define BIT_SPEC_FORCE_DOZE1 BIT(2)
+#define BIT_SPEC_NOA0_OFF_PERIOD BIT(1)
+#define BIT_SPEC_FORCE_DOZE0 BIT(0)
+
+/* 2 REG_QUEUE_INCOL_THR			(Offset 0x0538) */
+
+#define BIT_SHIFT_BK_QUEUE_THR 24
+#define BIT_MASK_BK_QUEUE_THR 0xff
+#define BIT_BK_QUEUE_THR(x)                                                    \
+	(((x) & BIT_MASK_BK_QUEUE_THR) << BIT_SHIFT_BK_QUEUE_THR)
+#define BIT_GET_BK_QUEUE_THR(x)                                                \
+	(((x) >> BIT_SHIFT_BK_QUEUE_THR) & BIT_MASK_BK_QUEUE_THR)
+
+#define BIT_SHIFT_BE_QUEUE_THR 16
+#define BIT_MASK_BE_QUEUE_THR 0xff
+#define BIT_BE_QUEUE_THR(x)                                                    \
+	(((x) & BIT_MASK_BE_QUEUE_THR) << BIT_SHIFT_BE_QUEUE_THR)
+#define BIT_GET_BE_QUEUE_THR(x)                                                \
+	(((x) >> BIT_SHIFT_BE_QUEUE_THR) & BIT_MASK_BE_QUEUE_THR)
+
+#define BIT_SHIFT_VI_QUEUE_THR 8
+#define BIT_MASK_VI_QUEUE_THR 0xff
+#define BIT_VI_QUEUE_THR(x)                                                    \
+	(((x) & BIT_MASK_VI_QUEUE_THR) << BIT_SHIFT_VI_QUEUE_THR)
+#define BIT_GET_VI_QUEUE_THR(x)                                                \
+	(((x) >> BIT_SHIFT_VI_QUEUE_THR) & BIT_MASK_VI_QUEUE_THR)
+
+#define BIT_SHIFT_VO_QUEUE_THR 0
+#define BIT_MASK_VO_QUEUE_THR 0xff
+#define BIT_VO_QUEUE_THR(x)                                                    \
+	(((x) & BIT_MASK_VO_QUEUE_THR) << BIT_SHIFT_VO_QUEUE_THR)
+#define BIT_GET_VO_QUEUE_THR(x)                                                \
+	(((x) >> BIT_SHIFT_VO_QUEUE_THR) & BIT_MASK_VO_QUEUE_THR)
+
+/* 2 REG_QUEUE_INCOL_EN			(Offset 0x053C) */
+
+#define BIT_QUEUE_INCOL_EN BIT(16)
+
+/* 2 REG_QUEUE_INCOL_EN			(Offset 0x053C) */
+
+#define BIT_SHIFT_BE_TRIGGER_NUM 12
+#define BIT_MASK_BE_TRIGGER_NUM 0xf
+#define BIT_BE_TRIGGER_NUM(x)                                                  \
+	(((x) & BIT_MASK_BE_TRIGGER_NUM) << BIT_SHIFT_BE_TRIGGER_NUM)
+#define BIT_GET_BE_TRIGGER_NUM(x)                                              \
+	(((x) >> BIT_SHIFT_BE_TRIGGER_NUM) & BIT_MASK_BE_TRIGGER_NUM)
+
+/* 2 REG_QUEUE_INCOL_EN			(Offset 0x053C) */
+
+#define BIT_SHIFT_BK_TRIGGER_NUM 8
+#define BIT_MASK_BK_TRIGGER_NUM 0xf
+#define BIT_BK_TRIGGER_NUM(x)                                                  \
+	(((x) & BIT_MASK_BK_TRIGGER_NUM) << BIT_SHIFT_BK_TRIGGER_NUM)
+#define BIT_GET_BK_TRIGGER_NUM(x)                                              \
+	(((x) >> BIT_SHIFT_BK_TRIGGER_NUM) & BIT_MASK_BK_TRIGGER_NUM)
+
+/* 2 REG_QUEUE_INCOL_EN			(Offset 0x053C) */
+
+#define BIT_SHIFT_VI_TRIGGER_NUM 4
+#define BIT_MASK_VI_TRIGGER_NUM 0xf
+#define BIT_VI_TRIGGER_NUM(x)                                                  \
+	(((x) & BIT_MASK_VI_TRIGGER_NUM) << BIT_SHIFT_VI_TRIGGER_NUM)
+#define BIT_GET_VI_TRIGGER_NUM(x)                                              \
+	(((x) >> BIT_SHIFT_VI_TRIGGER_NUM) & BIT_MASK_VI_TRIGGER_NUM)
+
+#define BIT_SHIFT_VO_TRIGGER_NUM 0
+#define BIT_MASK_VO_TRIGGER_NUM 0xf
+#define BIT_VO_TRIGGER_NUM(x)                                                  \
+	(((x) & BIT_MASK_VO_TRIGGER_NUM) << BIT_SHIFT_VO_TRIGGER_NUM)
+#define BIT_GET_VO_TRIGGER_NUM(x)                                              \
+	(((x) >> BIT_SHIFT_VO_TRIGGER_NUM) & BIT_MASK_VO_TRIGGER_NUM)
+
+/* 2 REG_TBTT_PROHIBIT			(Offset 0x0540) */
+
+#define BIT_SHIFT_TBTT_HOLD_TIME_AP 8
+#define BIT_MASK_TBTT_HOLD_TIME_AP 0xfff
+#define BIT_TBTT_HOLD_TIME_AP(x)                                               \
+	(((x) & BIT_MASK_TBTT_HOLD_TIME_AP) << BIT_SHIFT_TBTT_HOLD_TIME_AP)
+#define BIT_GET_TBTT_HOLD_TIME_AP(x)                                           \
+	(((x) >> BIT_SHIFT_TBTT_HOLD_TIME_AP) & BIT_MASK_TBTT_HOLD_TIME_AP)
+
+/* 2 REG_TBTT_PROHIBIT			(Offset 0x0540) */
+
+#define BIT_SHIFT_TBTT_PROHIBIT_SETUP 0
+#define BIT_MASK_TBTT_PROHIBIT_SETUP 0xf
+#define BIT_TBTT_PROHIBIT_SETUP(x)                                             \
+	(((x) & BIT_MASK_TBTT_PROHIBIT_SETUP) << BIT_SHIFT_TBTT_PROHIBIT_SETUP)
+#define BIT_GET_TBTT_PROHIBIT_SETUP(x)                                         \
+	(((x) >> BIT_SHIFT_TBTT_PROHIBIT_SETUP) & BIT_MASK_TBTT_PROHIBIT_SETUP)
+
+/* 2 REG_P2PPS_STATE				(Offset 0x0543) */
+
+#define BIT_POWER_STATE BIT(7)
+#define BIT_CTWINDOW_ON BIT(6)
+#define BIT_BEACON_AREA_ON BIT(5)
+#define BIT_CTWIN_EARLY_DISTX BIT(4)
+#define BIT_NOA1_OFF_PERIOD BIT(3)
+#define BIT_FORCE_DOZE1 BIT(2)
+#define BIT_NOA0_OFF_PERIOD BIT(1)
+#define BIT_FORCE_DOZE0 BIT(0)
+
+/* 2 REG_RD_NAV_NXT				(Offset 0x0544) */
+
+#define BIT_SHIFT_RD_NAV_PROT_NXT 0
+#define BIT_MASK_RD_NAV_PROT_NXT 0xffff
+#define BIT_RD_NAV_PROT_NXT(x)                                                 \
+	(((x) & BIT_MASK_RD_NAV_PROT_NXT) << BIT_SHIFT_RD_NAV_PROT_NXT)
+#define BIT_GET_RD_NAV_PROT_NXT(x)                                             \
+	(((x) >> BIT_SHIFT_RD_NAV_PROT_NXT) & BIT_MASK_RD_NAV_PROT_NXT)
+
+/* 2 REG_NAV_PROT_LEN			(Offset 0x0546) */
+
+#define BIT_SHIFT_NAV_PROT_LEN 0
+#define BIT_MASK_NAV_PROT_LEN 0xffff
+#define BIT_NAV_PROT_LEN(x)                                                    \
+	(((x) & BIT_MASK_NAV_PROT_LEN) << BIT_SHIFT_NAV_PROT_LEN)
+#define BIT_GET_NAV_PROT_LEN(x)                                                \
+	(((x) >> BIT_SHIFT_NAV_PROT_LEN) & BIT_MASK_NAV_PROT_LEN)
+
+/* 2 REG_BCN_CTRL				(Offset 0x0550) */
+
+#define BIT_DIS_RX_BSSID_FIT BIT(6)
+
+/* 2 REG_BCN_CTRL				(Offset 0x0550) */
+
+#define BIT_P0_EN_TXBCN_RPT BIT(5)
+
+/* 2 REG_BCN_CTRL				(Offset 0x0550) */
+
+#define BIT_DIS_TSF_UDT BIT(4)
+#define BIT_EN_BCN_FUNCTION BIT(3)
+
+/* 2 REG_BCN_CTRL				(Offset 0x0550) */
+
+#define BIT_P0_EN_RXBCN_RPT BIT(2)
+
+/* 2 REG_BCN_CTRL				(Offset 0x0550) */
+
+#define BIT_EN_P2P_CTWINDOW BIT(1)
+#define BIT_EN_P2P_BCNQ_AREA BIT(0)
+
+/* 2 REG_BCN_CTRL_CLINT0			(Offset 0x0551) */
+
+#define BIT_CLI0_DIS_RX_BSSID_FIT BIT(6)
+
+/* 2 REG_BCN_CTRL_CLINT0			(Offset 0x0551) */
+
+#define BIT_CLI0_DIS_TSF_UDT BIT(4)
+
+/* 2 REG_BCN_CTRL_CLINT0			(Offset 0x0551) */
+
+#define BIT_CLI0_EN_BCN_FUNCTION BIT(3)
+
+/* 2 REG_BCN_CTRL_CLINT0			(Offset 0x0551) */
+
+#define BIT_CLI0_EN_RXBCN_RPT BIT(2)
+
+/* 2 REG_BCN_CTRL_CLINT0			(Offset 0x0551) */
+
+#define BIT_CLI0_ENP2P_CTWINDOW BIT(1)
+#define BIT_CLI0_ENP2P_BCNQ_AREA BIT(0)
+
+/* 2 REG_MBID_NUM				(Offset 0x0552) */
+
+#define BIT_EN_PRE_DL_BEACON BIT(3)
+
+#define BIT_SHIFT_MBID_BCN_NUM 0
+#define BIT_MASK_MBID_BCN_NUM 0x7
+#define BIT_MBID_BCN_NUM(x)                                                    \
+	(((x) & BIT_MASK_MBID_BCN_NUM) << BIT_SHIFT_MBID_BCN_NUM)
+#define BIT_GET_MBID_BCN_NUM(x)                                                \
+	(((x) >> BIT_SHIFT_MBID_BCN_NUM) & BIT_MASK_MBID_BCN_NUM)
+
+/* 2 REG_DUAL_TSF_RST			(Offset 0x0553) */
+
+#define BIT_FREECNT_RST BIT(5)
+
+/* 2 REG_DUAL_TSF_RST			(Offset 0x0553) */
+
+#define BIT_TSFTR_CLI3_RST BIT(4)
+
+/* 2 REG_DUAL_TSF_RST			(Offset 0x0553) */
+
+#define BIT_TSFTR_CLI2_RST BIT(3)
+
+/* 2 REG_DUAL_TSF_RST			(Offset 0x0553) */
+
+#define BIT_TSFTR_CLI1_RST BIT(2)
+
+/* 2 REG_DUAL_TSF_RST			(Offset 0x0553) */
+
+#define BIT_TSFTR_CLI0_RST BIT(1)
+
+/* 2 REG_DUAL_TSF_RST			(Offset 0x0553) */
+
+#define BIT_TSFTR_RST BIT(0)
+
+/* 2 REG_MBSSID_BCN_SPACE			(Offset 0x0554) */
+
+#define BIT_SHIFT_BCN_TIMER_SEL_FWRD 28
+#define BIT_MASK_BCN_TIMER_SEL_FWRD 0x7
+#define BIT_BCN_TIMER_SEL_FWRD(x)                                              \
+	(((x) & BIT_MASK_BCN_TIMER_SEL_FWRD) << BIT_SHIFT_BCN_TIMER_SEL_FWRD)
+#define BIT_GET_BCN_TIMER_SEL_FWRD(x)                                          \
+	(((x) >> BIT_SHIFT_BCN_TIMER_SEL_FWRD) & BIT_MASK_BCN_TIMER_SEL_FWRD)
+
+/* 2 REG_MBSSID_BCN_SPACE			(Offset 0x0554) */
+
+#define BIT_SHIFT_BCN_SPACE_CLINT0 16
+#define BIT_MASK_BCN_SPACE_CLINT0 0xfff
+#define BIT_BCN_SPACE_CLINT0(x)                                                \
+	(((x) & BIT_MASK_BCN_SPACE_CLINT0) << BIT_SHIFT_BCN_SPACE_CLINT0)
+#define BIT_GET_BCN_SPACE_CLINT0(x)                                            \
+	(((x) >> BIT_SHIFT_BCN_SPACE_CLINT0) & BIT_MASK_BCN_SPACE_CLINT0)
+
+/* 2 REG_MBSSID_BCN_SPACE			(Offset 0x0554) */
+
+#define BIT_SHIFT_BCN_SPACE0 0
+#define BIT_MASK_BCN_SPACE0 0xffff
+#define BIT_BCN_SPACE0(x) (((x) & BIT_MASK_BCN_SPACE0) << BIT_SHIFT_BCN_SPACE0)
+#define BIT_GET_BCN_SPACE0(x)                                                  \
+	(((x) >> BIT_SHIFT_BCN_SPACE0) & BIT_MASK_BCN_SPACE0)
+
+/* 2 REG_DRVERLYINT				(Offset 0x0558) */
+
+#define BIT_SHIFT_DRVERLYITV 0
+#define BIT_MASK_DRVERLYITV 0xff
+#define BIT_DRVERLYITV(x) (((x) & BIT_MASK_DRVERLYITV) << BIT_SHIFT_DRVERLYITV)
+#define BIT_GET_DRVERLYITV(x)                                                  \
+	(((x) >> BIT_SHIFT_DRVERLYITV) & BIT_MASK_DRVERLYITV)
+
+/* 2 REG_BCNDMATIM				(Offset 0x0559) */
+
+#define BIT_SHIFT_BCNDMATIM 0
+#define BIT_MASK_BCNDMATIM 0xff
+#define BIT_BCNDMATIM(x) (((x) & BIT_MASK_BCNDMATIM) << BIT_SHIFT_BCNDMATIM)
+#define BIT_GET_BCNDMATIM(x) (((x) >> BIT_SHIFT_BCNDMATIM) & BIT_MASK_BCNDMATIM)
+
+/* 2 REG_ATIMWND				(Offset 0x055A) */
+
+#define BIT_SHIFT_ATIMWND0 0
+#define BIT_MASK_ATIMWND0 0xffff
+#define BIT_ATIMWND0(x) (((x) & BIT_MASK_ATIMWND0) << BIT_SHIFT_ATIMWND0)
+#define BIT_GET_ATIMWND0(x) (((x) >> BIT_SHIFT_ATIMWND0) & BIT_MASK_ATIMWND0)
+
+/* 2 REG_USTIME_TSF				(Offset 0x055C) */
+
+#define BIT_SHIFT_USTIME_TSF_V1 0
+#define BIT_MASK_USTIME_TSF_V1 0xff
+#define BIT_USTIME_TSF_V1(x)                                                   \
+	(((x) & BIT_MASK_USTIME_TSF_V1) << BIT_SHIFT_USTIME_TSF_V1)
+#define BIT_GET_USTIME_TSF_V1(x)                                               \
+	(((x) >> BIT_SHIFT_USTIME_TSF_V1) & BIT_MASK_USTIME_TSF_V1)
+
+/* 2 REG_BCN_MAX_ERR				(Offset 0x055D) */
+
+#define BIT_SHIFT_BCN_MAX_ERR 0
+#define BIT_MASK_BCN_MAX_ERR 0xff
+#define BIT_BCN_MAX_ERR(x)                                                     \
+	(((x) & BIT_MASK_BCN_MAX_ERR) << BIT_SHIFT_BCN_MAX_ERR)
+#define BIT_GET_BCN_MAX_ERR(x)                                                 \
+	(((x) >> BIT_SHIFT_BCN_MAX_ERR) & BIT_MASK_BCN_MAX_ERR)
+
+/* 2 REG_RXTSF_OFFSET_CCK			(Offset 0x055E) */
+
+#define BIT_SHIFT_CCK_RXTSF_OFFSET 0
+#define BIT_MASK_CCK_RXTSF_OFFSET 0xff
+#define BIT_CCK_RXTSF_OFFSET(x)                                                \
+	(((x) & BIT_MASK_CCK_RXTSF_OFFSET) << BIT_SHIFT_CCK_RXTSF_OFFSET)
+#define BIT_GET_CCK_RXTSF_OFFSET(x)                                            \
+	(((x) >> BIT_SHIFT_CCK_RXTSF_OFFSET) & BIT_MASK_CCK_RXTSF_OFFSET)
+
+/* 2 REG_RXTSF_OFFSET_OFDM			(Offset 0x055F) */
+
+#define BIT_SHIFT_OFDM_RXTSF_OFFSET 0
+#define BIT_MASK_OFDM_RXTSF_OFFSET 0xff
+#define BIT_OFDM_RXTSF_OFFSET(x)                                               \
+	(((x) & BIT_MASK_OFDM_RXTSF_OFFSET) << BIT_SHIFT_OFDM_RXTSF_OFFSET)
+#define BIT_GET_OFDM_RXTSF_OFFSET(x)                                           \
+	(((x) >> BIT_SHIFT_OFDM_RXTSF_OFFSET) & BIT_MASK_OFDM_RXTSF_OFFSET)
+
+/* 2 REG_TSFTR				(Offset 0x0560) */
+
+#define BIT_SHIFT_TSF_TIMER 0
+#define BIT_MASK_TSF_TIMER 0xffffffffffffffffL
+#define BIT_TSF_TIMER(x) (((x) & BIT_MASK_TSF_TIMER) << BIT_SHIFT_TSF_TIMER)
+#define BIT_GET_TSF_TIMER(x) (((x) >> BIT_SHIFT_TSF_TIMER) & BIT_MASK_TSF_TIMER)
+
+/* 2 REG_FREERUN_CNT				(Offset 0x0568) */
+
+#define BIT_SHIFT_FREERUN_CNT 0
+#define BIT_MASK_FREERUN_CNT 0xffffffffffffffffL
+#define BIT_FREERUN_CNT(x)                                                     \
+	(((x) & BIT_MASK_FREERUN_CNT) << BIT_SHIFT_FREERUN_CNT)
+#define BIT_GET_FREERUN_CNT(x)                                                 \
+	(((x) >> BIT_SHIFT_FREERUN_CNT) & BIT_MASK_FREERUN_CNT)
+
+/* 2 REG_ATIMWND1_V1				(Offset 0x0570) */
+
+#define BIT_SHIFT_ATIMWND1_V1 0
+#define BIT_MASK_ATIMWND1_V1 0xff
+#define BIT_ATIMWND1_V1(x)                                                     \
+	(((x) & BIT_MASK_ATIMWND1_V1) << BIT_SHIFT_ATIMWND1_V1)
+#define BIT_GET_ATIMWND1_V1(x)                                                 \
+	(((x) >> BIT_SHIFT_ATIMWND1_V1) & BIT_MASK_ATIMWND1_V1)
+
+/* 2 REG_TBTT_PROHIBIT_INFRA			(Offset 0x0571) */
+
+#define BIT_SHIFT_TBTT_PROHIBIT_INFRA 0
+#define BIT_MASK_TBTT_PROHIBIT_INFRA 0xff
+#define BIT_TBTT_PROHIBIT_INFRA(x)                                             \
+	(((x) & BIT_MASK_TBTT_PROHIBIT_INFRA) << BIT_SHIFT_TBTT_PROHIBIT_INFRA)
+#define BIT_GET_TBTT_PROHIBIT_INFRA(x)                                         \
+	(((x) >> BIT_SHIFT_TBTT_PROHIBIT_INFRA) & BIT_MASK_TBTT_PROHIBIT_INFRA)
+
+/* 2 REG_CTWND				(Offset 0x0572) */
+
+#define BIT_SHIFT_CTWND 0
+#define BIT_MASK_CTWND 0xff
+#define BIT_CTWND(x) (((x) & BIT_MASK_CTWND) << BIT_SHIFT_CTWND)
+#define BIT_GET_CTWND(x) (((x) >> BIT_SHIFT_CTWND) & BIT_MASK_CTWND)
+
+/* 2 REG_BCNIVLCUNT				(Offset 0x0573) */
+
+#define BIT_SHIFT_BCNIVLCUNT 0
+#define BIT_MASK_BCNIVLCUNT 0x7f
+#define BIT_BCNIVLCUNT(x) (((x) & BIT_MASK_BCNIVLCUNT) << BIT_SHIFT_BCNIVLCUNT)
+#define BIT_GET_BCNIVLCUNT(x)                                                  \
+	(((x) >> BIT_SHIFT_BCNIVLCUNT) & BIT_MASK_BCNIVLCUNT)
+
+/* 2 REG_BCNDROPCTRL				(Offset 0x0574) */
+
+#define BIT_BEACON_DROP_EN BIT(7)
+
+#define BIT_SHIFT_BEACON_DROP_IVL 0
+#define BIT_MASK_BEACON_DROP_IVL 0x7f
+#define BIT_BEACON_DROP_IVL(x)                                                 \
+	(((x) & BIT_MASK_BEACON_DROP_IVL) << BIT_SHIFT_BEACON_DROP_IVL)
+#define BIT_GET_BEACON_DROP_IVL(x)                                             \
+	(((x) >> BIT_SHIFT_BEACON_DROP_IVL) & BIT_MASK_BEACON_DROP_IVL)
+
+/* 2 REG_HGQ_TIMEOUT_PERIOD			(Offset 0x0575) */
+
+#define BIT_SHIFT_HGQ_TIMEOUT_PERIOD 0
+#define BIT_MASK_HGQ_TIMEOUT_PERIOD 0xff
+#define BIT_HGQ_TIMEOUT_PERIOD(x)                                              \
+	(((x) & BIT_MASK_HGQ_TIMEOUT_PERIOD) << BIT_SHIFT_HGQ_TIMEOUT_PERIOD)
+#define BIT_GET_HGQ_TIMEOUT_PERIOD(x)                                          \
+	(((x) >> BIT_SHIFT_HGQ_TIMEOUT_PERIOD) & BIT_MASK_HGQ_TIMEOUT_PERIOD)
+
+/* 2 REG_TXCMD_TIMEOUT_PERIOD		(Offset 0x0576) */
+
+#define BIT_SHIFT_TXCMD_TIMEOUT_PERIOD 0
+#define BIT_MASK_TXCMD_TIMEOUT_PERIOD 0xff
+#define BIT_TXCMD_TIMEOUT_PERIOD(x)                                            \
+	(((x) & BIT_MASK_TXCMD_TIMEOUT_PERIOD)                                 \
+	 << BIT_SHIFT_TXCMD_TIMEOUT_PERIOD)
+#define BIT_GET_TXCMD_TIMEOUT_PERIOD(x)                                        \
+	(((x) >> BIT_SHIFT_TXCMD_TIMEOUT_PERIOD) &                             \
+	 BIT_MASK_TXCMD_TIMEOUT_PERIOD)
+
+/* 2 REG_MISC_CTRL				(Offset 0x0577) */
+
+#define BIT_DIS_TRX_CAL_BCN BIT(5)
+#define BIT_DIS_TX_CAL_TBTT BIT(4)
+#define BIT_EN_FREECNT BIT(3)
+#define BIT_BCN_AGGRESSION BIT(2)
+
+#define BIT_SHIFT_DIS_SECONDARY_CCA 0
+#define BIT_MASK_DIS_SECONDARY_CCA 0x3
+#define BIT_DIS_SECONDARY_CCA(x)                                               \
+	(((x) & BIT_MASK_DIS_SECONDARY_CCA) << BIT_SHIFT_DIS_SECONDARY_CCA)
+#define BIT_GET_DIS_SECONDARY_CCA(x)                                           \
+	(((x) >> BIT_SHIFT_DIS_SECONDARY_CCA) & BIT_MASK_DIS_SECONDARY_CCA)
+
+/* 2 REG_BCN_CTRL_CLINT1			(Offset 0x0578) */
+
+#define BIT_CLI1_DIS_RX_BSSID_FIT BIT(6)
+#define BIT_CLI1_DIS_TSF_UDT BIT(4)
+#define BIT_CLI1_EN_BCN_FUNCTION BIT(3)
+
+/* 2 REG_BCN_CTRL_CLINT1			(Offset 0x0578) */
+
+#define BIT_CLI1_EN_RXBCN_RPT BIT(2)
+
+/* 2 REG_BCN_CTRL_CLINT1			(Offset 0x0578) */
+
+#define BIT_CLI1_ENP2P_CTWINDOW BIT(1)
+#define BIT_CLI1_ENP2P_BCNQ_AREA BIT(0)
+
+/* 2 REG_BCN_CTRL_CLINT2			(Offset 0x0579) */
+
+#define BIT_CLI2_DIS_RX_BSSID_FIT BIT(6)
+#define BIT_CLI2_DIS_TSF_UDT BIT(4)
+#define BIT_CLI2_EN_BCN_FUNCTION BIT(3)
+
+/* 2 REG_BCN_CTRL_CLINT2			(Offset 0x0579) */
+
+#define BIT_CLI2_EN_RXBCN_RPT BIT(2)
+
+/* 2 REG_BCN_CTRL_CLINT2			(Offset 0x0579) */
+
+#define BIT_CLI2_ENP2P_CTWINDOW BIT(1)
+#define BIT_CLI2_ENP2P_BCNQ_AREA BIT(0)
+
+/* 2 REG_BCN_CTRL_CLINT3			(Offset 0x057A) */
+
+#define BIT_CLI3_DIS_RX_BSSID_FIT BIT(6)
+#define BIT_CLI3_DIS_TSF_UDT BIT(4)
+#define BIT_CLI3_EN_BCN_FUNCTION BIT(3)
+
+/* 2 REG_BCN_CTRL_CLINT3			(Offset 0x057A) */
+
+#define BIT_CLI3_EN_RXBCN_RPT BIT(2)
+
+/* 2 REG_BCN_CTRL_CLINT3			(Offset 0x057A) */
+
+#define BIT_CLI3_ENP2P_CTWINDOW BIT(1)
+#define BIT_CLI3_ENP2P_BCNQ_AREA BIT(0)
+
+/* 2 REG_EXTEND_CTRL				(Offset 0x057B) */
+
+#define BIT_EN_TSFBIT32_RST_P2P2 BIT(5)
+#define BIT_EN_TSFBIT32_RST_P2P1 BIT(4)
+
+#define BIT_SHIFT_PORT_SEL 0
+#define BIT_MASK_PORT_SEL 0x7
+#define BIT_PORT_SEL(x) (((x) & BIT_MASK_PORT_SEL) << BIT_SHIFT_PORT_SEL)
+#define BIT_GET_PORT_SEL(x) (((x) >> BIT_SHIFT_PORT_SEL) & BIT_MASK_PORT_SEL)
+
+/* 2 REG_P2PPS1_SPEC_STATE			(Offset 0x057C) */
+
+#define BIT_P2P1_SPEC_POWER_STATE BIT(7)
+#define BIT_P2P1_SPEC_CTWINDOW_ON BIT(6)
+#define BIT_P2P1_SPEC_BCN_AREA_ON BIT(5)
+#define BIT_P2P1_SPEC_CTWIN_EARLY_DISTX BIT(4)
+#define BIT_P2P1_SPEC_NOA1_OFF_PERIOD BIT(3)
+#define BIT_P2P1_SPEC_FORCE_DOZE1 BIT(2)
+#define BIT_P2P1_SPEC_NOA0_OFF_PERIOD BIT(1)
+#define BIT_P2P1_SPEC_FORCE_DOZE0 BIT(0)
+
+/* 2 REG_P2PPS1_STATE			(Offset 0x057D) */
+
+#define BIT_P2P1_POWER_STATE BIT(7)
+#define BIT_P2P1_CTWINDOW_ON BIT(6)
+#define BIT_P2P1_BEACON_AREA_ON BIT(5)
+#define BIT_P2P1_CTWIN_EARLY_DISTX BIT(4)
+#define BIT_P2P1_NOA1_OFF_PERIOD BIT(3)
+#define BIT_P2P1_FORCE_DOZE1 BIT(2)
+#define BIT_P2P1_NOA0_OFF_PERIOD BIT(1)
+#define BIT_P2P1_FORCE_DOZE0 BIT(0)
+
+/* 2 REG_P2PPS2_SPEC_STATE			(Offset 0x057E) */
+
+#define BIT_P2P2_SPEC_POWER_STATE BIT(7)
+#define BIT_P2P2_SPEC_CTWINDOW_ON BIT(6)
+#define BIT_P2P2_SPEC_BCN_AREA_ON BIT(5)
+#define BIT_P2P2_SPEC_CTWIN_EARLY_DISTX BIT(4)
+#define BIT_P2P2_SPEC_NOA1_OFF_PERIOD BIT(3)
+#define BIT_P2P2_SPEC_FORCE_DOZE1 BIT(2)
+#define BIT_P2P2_SPEC_NOA0_OFF_PERIOD BIT(1)
+#define BIT_P2P2_SPEC_FORCE_DOZE0 BIT(0)
+
+/* 2 REG_P2PPS2_STATE			(Offset 0x057F) */
+
+#define BIT_P2P2_POWER_STATE BIT(7)
+#define BIT_P2P2_CTWINDOW_ON BIT(6)
+#define BIT_P2P2_BEACON_AREA_ON BIT(5)
+#define BIT_P2P2_CTWIN_EARLY_DISTX BIT(4)
+#define BIT_P2P2_NOA1_OFF_PERIOD BIT(3)
+#define BIT_P2P2_FORCE_DOZE1 BIT(2)
+#define BIT_P2P2_NOA0_OFF_PERIOD BIT(1)
+#define BIT_P2P2_FORCE_DOZE0 BIT(0)
+
+/* 2 REG_PS_TIMER0				(Offset 0x0580) */
+
+#define BIT_SHIFT_PSTIMER0_INT 5
+#define BIT_MASK_PSTIMER0_INT 0x7ffffff
+#define BIT_PSTIMER0_INT(x)                                                    \
+	(((x) & BIT_MASK_PSTIMER0_INT) << BIT_SHIFT_PSTIMER0_INT)
+#define BIT_GET_PSTIMER0_INT(x)                                                \
+	(((x) >> BIT_SHIFT_PSTIMER0_INT) & BIT_MASK_PSTIMER0_INT)
+
+/* 2 REG_PS_TIMER1				(Offset 0x0584) */
+
+#define BIT_SHIFT_PSTIMER1_INT 5
+#define BIT_MASK_PSTIMER1_INT 0x7ffffff
+#define BIT_PSTIMER1_INT(x)                                                    \
+	(((x) & BIT_MASK_PSTIMER1_INT) << BIT_SHIFT_PSTIMER1_INT)
+#define BIT_GET_PSTIMER1_INT(x)                                                \
+	(((x) >> BIT_SHIFT_PSTIMER1_INT) & BIT_MASK_PSTIMER1_INT)
+
+/* 2 REG_PS_TIMER2				(Offset 0x0588) */
+
+#define BIT_SHIFT_PSTIMER2_INT 5
+#define BIT_MASK_PSTIMER2_INT 0x7ffffff
+#define BIT_PSTIMER2_INT(x)                                                    \
+	(((x) & BIT_MASK_PSTIMER2_INT) << BIT_SHIFT_PSTIMER2_INT)
+#define BIT_GET_PSTIMER2_INT(x)                                                \
+	(((x) >> BIT_SHIFT_PSTIMER2_INT) & BIT_MASK_PSTIMER2_INT)
+
+/* 2 REG_TBTT_CTN_AREA			(Offset 0x058C) */
+
+#define BIT_SHIFT_TBTT_CTN_AREA 0
+#define BIT_MASK_TBTT_CTN_AREA 0xff
+#define BIT_TBTT_CTN_AREA(x)                                                   \
+	(((x) & BIT_MASK_TBTT_CTN_AREA) << BIT_SHIFT_TBTT_CTN_AREA)
+#define BIT_GET_TBTT_CTN_AREA(x)                                               \
+	(((x) >> BIT_SHIFT_TBTT_CTN_AREA) & BIT_MASK_TBTT_CTN_AREA)
+
+/* 2 REG_FORCE_BCN_IFS			(Offset 0x058E) */
+
+#define BIT_SHIFT_FORCE_BCN_IFS 0
+#define BIT_MASK_FORCE_BCN_IFS 0xff
+#define BIT_FORCE_BCN_IFS(x)                                                   \
+	(((x) & BIT_MASK_FORCE_BCN_IFS) << BIT_SHIFT_FORCE_BCN_IFS)
+#define BIT_GET_FORCE_BCN_IFS(x)                                               \
+	(((x) >> BIT_SHIFT_FORCE_BCN_IFS) & BIT_MASK_FORCE_BCN_IFS)
+
+/* 2 REG_TXOP_MIN				(Offset 0x0590) */
+
+#define BIT_SHIFT_TXOP_MIN 0
+#define BIT_MASK_TXOP_MIN 0x3fff
+#define BIT_TXOP_MIN(x) (((x) & BIT_MASK_TXOP_MIN) << BIT_SHIFT_TXOP_MIN)
+#define BIT_GET_TXOP_MIN(x) (((x) >> BIT_SHIFT_TXOP_MIN) & BIT_MASK_TXOP_MIN)
+
+/* 2 REG_PRE_BKF_TIME			(Offset 0x0592) */
+
+#define BIT_SHIFT_PRE_BKF_TIME 0
+#define BIT_MASK_PRE_BKF_TIME 0xff
+#define BIT_PRE_BKF_TIME(x)                                                    \
+	(((x) & BIT_MASK_PRE_BKF_TIME) << BIT_SHIFT_PRE_BKF_TIME)
+#define BIT_GET_PRE_BKF_TIME(x)                                                \
+	(((x) >> BIT_SHIFT_PRE_BKF_TIME) & BIT_MASK_PRE_BKF_TIME)
+
+/* 2 REG_CROSS_TXOP_CTRL			(Offset 0x0593) */
+
+#define BIT_DTIM_BYPASS BIT(2)
+#define BIT_RTS_NAV_TXOP BIT(1)
+#define BIT_NOT_CROSS_TXOP BIT(0)
+
+/* 2 REG_ATIMWND2				(Offset 0x05A0) */
+
+#define BIT_SHIFT_ATIMWND2 0
+#define BIT_MASK_ATIMWND2 0xff
+#define BIT_ATIMWND2(x) (((x) & BIT_MASK_ATIMWND2) << BIT_SHIFT_ATIMWND2)
+#define BIT_GET_ATIMWND2(x) (((x) >> BIT_SHIFT_ATIMWND2) & BIT_MASK_ATIMWND2)
+
+/* 2 REG_ATIMWND3				(Offset 0x05A1) */
+
+#define BIT_SHIFT_ATIMWND3 0
+#define BIT_MASK_ATIMWND3 0xff
+#define BIT_ATIMWND3(x) (((x) & BIT_MASK_ATIMWND3) << BIT_SHIFT_ATIMWND3)
+#define BIT_GET_ATIMWND3(x) (((x) >> BIT_SHIFT_ATIMWND3) & BIT_MASK_ATIMWND3)
+
+/* 2 REG_ATIMWND4				(Offset 0x05A2) */
+
+#define BIT_SHIFT_ATIMWND4 0
+#define BIT_MASK_ATIMWND4 0xff
+#define BIT_ATIMWND4(x) (((x) & BIT_MASK_ATIMWND4) << BIT_SHIFT_ATIMWND4)
+#define BIT_GET_ATIMWND4(x) (((x) >> BIT_SHIFT_ATIMWND4) & BIT_MASK_ATIMWND4)
+
+/* 2 REG_ATIMWND5				(Offset 0x05A3) */
+
+#define BIT_SHIFT_ATIMWND5 0
+#define BIT_MASK_ATIMWND5 0xff
+#define BIT_ATIMWND5(x) (((x) & BIT_MASK_ATIMWND5) << BIT_SHIFT_ATIMWND5)
+#define BIT_GET_ATIMWND5(x) (((x) >> BIT_SHIFT_ATIMWND5) & BIT_MASK_ATIMWND5)
+
+/* 2 REG_ATIMWND6				(Offset 0x05A4) */
+
+#define BIT_SHIFT_ATIMWND6 0
+#define BIT_MASK_ATIMWND6 0xff
+#define BIT_ATIMWND6(x) (((x) & BIT_MASK_ATIMWND6) << BIT_SHIFT_ATIMWND6)
+#define BIT_GET_ATIMWND6(x) (((x) >> BIT_SHIFT_ATIMWND6) & BIT_MASK_ATIMWND6)
+
+/* 2 REG_ATIMWND7				(Offset 0x05A5) */
+
+#define BIT_SHIFT_ATIMWND7 0
+#define BIT_MASK_ATIMWND7 0xff
+#define BIT_ATIMWND7(x) (((x) & BIT_MASK_ATIMWND7) << BIT_SHIFT_ATIMWND7)
+#define BIT_GET_ATIMWND7(x) (((x) >> BIT_SHIFT_ATIMWND7) & BIT_MASK_ATIMWND7)
+
+/* 2 REG_ATIMUGT				(Offset 0x05A6) */
+
+#define BIT_SHIFT_ATIM_URGENT 0
+#define BIT_MASK_ATIM_URGENT 0xff
+#define BIT_ATIM_URGENT(x)                                                     \
+	(((x) & BIT_MASK_ATIM_URGENT) << BIT_SHIFT_ATIM_URGENT)
+#define BIT_GET_ATIM_URGENT(x)                                                 \
+	(((x) >> BIT_SHIFT_ATIM_URGENT) & BIT_MASK_ATIM_URGENT)
+
+/* 2 REG_HIQ_NO_LMT_EN			(Offset 0x05A7) */
+
+#define BIT_HIQ_NO_LMT_EN_VAP7 BIT(7)
+#define BIT_HIQ_NO_LMT_EN_VAP6 BIT(6)
+#define BIT_HIQ_NO_LMT_EN_VAP5 BIT(5)
+#define BIT_HIQ_NO_LMT_EN_VAP4 BIT(4)
+#define BIT_HIQ_NO_LMT_EN_VAP3 BIT(3)
+#define BIT_HIQ_NO_LMT_EN_VAP2 BIT(2)
+#define BIT_HIQ_NO_LMT_EN_VAP1 BIT(1)
+#define BIT_HIQ_NO_LMT_EN_ROOT BIT(0)
+
+/* 2 REG_DTIM_COUNTER_ROOT			(Offset 0x05A8) */
+
+#define BIT_SHIFT_DTIM_COUNT_ROOT 0
+#define BIT_MASK_DTIM_COUNT_ROOT 0xff
+#define BIT_DTIM_COUNT_ROOT(x)                                                 \
+	(((x) & BIT_MASK_DTIM_COUNT_ROOT) << BIT_SHIFT_DTIM_COUNT_ROOT)
+#define BIT_GET_DTIM_COUNT_ROOT(x)                                             \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_ROOT) & BIT_MASK_DTIM_COUNT_ROOT)
+
+/* 2 REG_DTIM_COUNTER_VAP1			(Offset 0x05A9) */
+
+#define BIT_SHIFT_DTIM_COUNT_VAP1 0
+#define BIT_MASK_DTIM_COUNT_VAP1 0xff
+#define BIT_DTIM_COUNT_VAP1(x)                                                 \
+	(((x) & BIT_MASK_DTIM_COUNT_VAP1) << BIT_SHIFT_DTIM_COUNT_VAP1)
+#define BIT_GET_DTIM_COUNT_VAP1(x)                                             \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_VAP1) & BIT_MASK_DTIM_COUNT_VAP1)
+
+/* 2 REG_DTIM_COUNTER_VAP2			(Offset 0x05AA) */
+
+#define BIT_SHIFT_DTIM_COUNT_VAP2 0
+#define BIT_MASK_DTIM_COUNT_VAP2 0xff
+#define BIT_DTIM_COUNT_VAP2(x)                                                 \
+	(((x) & BIT_MASK_DTIM_COUNT_VAP2) << BIT_SHIFT_DTIM_COUNT_VAP2)
+#define BIT_GET_DTIM_COUNT_VAP2(x)                                             \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_VAP2) & BIT_MASK_DTIM_COUNT_VAP2)
+
+/* 2 REG_DTIM_COUNTER_VAP3			(Offset 0x05AB) */
+
+#define BIT_SHIFT_DTIM_COUNT_VAP3 0
+#define BIT_MASK_DTIM_COUNT_VAP3 0xff
+#define BIT_DTIM_COUNT_VAP3(x)                                                 \
+	(((x) & BIT_MASK_DTIM_COUNT_VAP3) << BIT_SHIFT_DTIM_COUNT_VAP3)
+#define BIT_GET_DTIM_COUNT_VAP3(x)                                             \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_VAP3) & BIT_MASK_DTIM_COUNT_VAP3)
+
+/* 2 REG_DTIM_COUNTER_VAP4			(Offset 0x05AC) */
+
+#define BIT_SHIFT_DTIM_COUNT_VAP4 0
+#define BIT_MASK_DTIM_COUNT_VAP4 0xff
+#define BIT_DTIM_COUNT_VAP4(x)                                                 \
+	(((x) & BIT_MASK_DTIM_COUNT_VAP4) << BIT_SHIFT_DTIM_COUNT_VAP4)
+#define BIT_GET_DTIM_COUNT_VAP4(x)                                             \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_VAP4) & BIT_MASK_DTIM_COUNT_VAP4)
+
+/* 2 REG_DTIM_COUNTER_VAP5			(Offset 0x05AD) */
+
+#define BIT_SHIFT_DTIM_COUNT_VAP5 0
+#define BIT_MASK_DTIM_COUNT_VAP5 0xff
+#define BIT_DTIM_COUNT_VAP5(x)                                                 \
+	(((x) & BIT_MASK_DTIM_COUNT_VAP5) << BIT_SHIFT_DTIM_COUNT_VAP5)
+#define BIT_GET_DTIM_COUNT_VAP5(x)                                             \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_VAP5) & BIT_MASK_DTIM_COUNT_VAP5)
+
+/* 2 REG_DTIM_COUNTER_VAP6			(Offset 0x05AE) */
+
+#define BIT_SHIFT_DTIM_COUNT_VAP6 0
+#define BIT_MASK_DTIM_COUNT_VAP6 0xff
+#define BIT_DTIM_COUNT_VAP6(x)                                                 \
+	(((x) & BIT_MASK_DTIM_COUNT_VAP6) << BIT_SHIFT_DTIM_COUNT_VAP6)
+#define BIT_GET_DTIM_COUNT_VAP6(x)                                             \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_VAP6) & BIT_MASK_DTIM_COUNT_VAP6)
+
+/* 2 REG_DTIM_COUNTER_VAP7			(Offset 0x05AF) */
+
+#define BIT_SHIFT_DTIM_COUNT_VAP7 0
+#define BIT_MASK_DTIM_COUNT_VAP7 0xff
+#define BIT_DTIM_COUNT_VAP7(x)                                                 \
+	(((x) & BIT_MASK_DTIM_COUNT_VAP7) << BIT_SHIFT_DTIM_COUNT_VAP7)
+#define BIT_GET_DTIM_COUNT_VAP7(x)                                             \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_VAP7) & BIT_MASK_DTIM_COUNT_VAP7)
+
+/* 2 REG_DIS_ATIM				(Offset 0x05B0) */
+
+#define BIT_DIS_ATIM_VAP7 BIT(7)
+#define BIT_DIS_ATIM_VAP6 BIT(6)
+#define BIT_DIS_ATIM_VAP5 BIT(5)
+#define BIT_DIS_ATIM_VAP4 BIT(4)
+#define BIT_DIS_ATIM_VAP3 BIT(3)
+#define BIT_DIS_ATIM_VAP2 BIT(2)
+#define BIT_DIS_ATIM_VAP1 BIT(1)
+#define BIT_DIS_ATIM_ROOT BIT(0)
+
+/* 2 REG_EARLY_128US				(Offset 0x05B1) */
+
+#define BIT_SHIFT_TSFT_SEL_TIMER1 3
+#define BIT_MASK_TSFT_SEL_TIMER1 0x7
+#define BIT_TSFT_SEL_TIMER1(x)                                                 \
+	(((x) & BIT_MASK_TSFT_SEL_TIMER1) << BIT_SHIFT_TSFT_SEL_TIMER1)
+#define BIT_GET_TSFT_SEL_TIMER1(x)                                             \
+	(((x) >> BIT_SHIFT_TSFT_SEL_TIMER1) & BIT_MASK_TSFT_SEL_TIMER1)
+
+#define BIT_SHIFT_EARLY_128US 0
+#define BIT_MASK_EARLY_128US 0x7
+#define BIT_EARLY_128US(x)                                                     \
+	(((x) & BIT_MASK_EARLY_128US) << BIT_SHIFT_EARLY_128US)
+#define BIT_GET_EARLY_128US(x)                                                 \
+	(((x) >> BIT_SHIFT_EARLY_128US) & BIT_MASK_EARLY_128US)
+
+/* 2 REG_P2PPS1_CTRL				(Offset 0x05B2) */
+
+#define BIT_P2P1_CTW_ALLSTASLEEP BIT(7)
+#define BIT_P2P1_OFF_DISTX_EN BIT(6)
+#define BIT_P2P1_PWR_MGT_EN BIT(5)
+#define BIT_P2P1_NOA1_EN BIT(2)
+#define BIT_P2P1_NOA0_EN BIT(1)
+
+/* 2 REG_P2PPS2_CTRL				(Offset 0x05B3) */
+
+#define BIT_P2P2_CTW_ALLSTASLEEP BIT(7)
+#define BIT_P2P2_OFF_DISTX_EN BIT(6)
+#define BIT_P2P2_PWR_MGT_EN BIT(5)
+#define BIT_P2P2_NOA1_EN BIT(2)
+#define BIT_P2P2_NOA0_EN BIT(1)
+
+/* 2 REG_TIMER0_SRC_SEL			(Offset 0x05B4) */
+
+#define BIT_SHIFT_SYNC_CLI_SEL 4
+#define BIT_MASK_SYNC_CLI_SEL 0x7
+#define BIT_SYNC_CLI_SEL(x)                                                    \
+	(((x) & BIT_MASK_SYNC_CLI_SEL) << BIT_SHIFT_SYNC_CLI_SEL)
+#define BIT_GET_SYNC_CLI_SEL(x)                                                \
+	(((x) >> BIT_SHIFT_SYNC_CLI_SEL) & BIT_MASK_SYNC_CLI_SEL)
+
+#define BIT_SHIFT_TSFT_SEL_TIMER0 0
+#define BIT_MASK_TSFT_SEL_TIMER0 0x7
+#define BIT_TSFT_SEL_TIMER0(x)                                                 \
+	(((x) & BIT_MASK_TSFT_SEL_TIMER0) << BIT_SHIFT_TSFT_SEL_TIMER0)
+#define BIT_GET_TSFT_SEL_TIMER0(x)                                             \
+	(((x) >> BIT_SHIFT_TSFT_SEL_TIMER0) & BIT_MASK_TSFT_SEL_TIMER0)
+
+/* 2 REG_NOA_UNIT_SEL			(Offset 0x05B5) */
+
+#define BIT_SHIFT_NOA_UNIT2_SEL 8
+#define BIT_MASK_NOA_UNIT2_SEL 0x7
+#define BIT_NOA_UNIT2_SEL(x)                                                   \
+	(((x) & BIT_MASK_NOA_UNIT2_SEL) << BIT_SHIFT_NOA_UNIT2_SEL)
+#define BIT_GET_NOA_UNIT2_SEL(x)                                               \
+	(((x) >> BIT_SHIFT_NOA_UNIT2_SEL) & BIT_MASK_NOA_UNIT2_SEL)
+
+#define BIT_SHIFT_NOA_UNIT1_SEL 4
+#define BIT_MASK_NOA_UNIT1_SEL 0x7
+#define BIT_NOA_UNIT1_SEL(x)                                                   \
+	(((x) & BIT_MASK_NOA_UNIT1_SEL) << BIT_SHIFT_NOA_UNIT1_SEL)
+#define BIT_GET_NOA_UNIT1_SEL(x)                                               \
+	(((x) >> BIT_SHIFT_NOA_UNIT1_SEL) & BIT_MASK_NOA_UNIT1_SEL)
+
+#define BIT_SHIFT_NOA_UNIT0_SEL 0
+#define BIT_MASK_NOA_UNIT0_SEL 0x7
+#define BIT_NOA_UNIT0_SEL(x)                                                   \
+	(((x) & BIT_MASK_NOA_UNIT0_SEL) << BIT_SHIFT_NOA_UNIT0_SEL)
+#define BIT_GET_NOA_UNIT0_SEL(x)                                               \
+	(((x) >> BIT_SHIFT_NOA_UNIT0_SEL) & BIT_MASK_NOA_UNIT0_SEL)
+
+/* 2 REG_P2POFF_DIS_TXTIME			(Offset 0x05B7) */
+
+#define BIT_SHIFT_P2POFF_DIS_TXTIME 0
+#define BIT_MASK_P2POFF_DIS_TXTIME 0xff
+#define BIT_P2POFF_DIS_TXTIME(x)                                               \
+	(((x) & BIT_MASK_P2POFF_DIS_TXTIME) << BIT_SHIFT_P2POFF_DIS_TXTIME)
+#define BIT_GET_P2POFF_DIS_TXTIME(x)                                           \
+	(((x) >> BIT_SHIFT_P2POFF_DIS_TXTIME) & BIT_MASK_P2POFF_DIS_TXTIME)
+
+/* 2 REG_MBSSID_BCN_SPACE2			(Offset 0x05B8) */
+
+#define BIT_SHIFT_BCN_SPACE_CLINT2 16
+#define BIT_MASK_BCN_SPACE_CLINT2 0xfff
+#define BIT_BCN_SPACE_CLINT2(x)                                                \
+	(((x) & BIT_MASK_BCN_SPACE_CLINT2) << BIT_SHIFT_BCN_SPACE_CLINT2)
+#define BIT_GET_BCN_SPACE_CLINT2(x)                                            \
+	(((x) >> BIT_SHIFT_BCN_SPACE_CLINT2) & BIT_MASK_BCN_SPACE_CLINT2)
+
+#define BIT_SHIFT_BCN_SPACE_CLINT1 0
+#define BIT_MASK_BCN_SPACE_CLINT1 0xfff
+#define BIT_BCN_SPACE_CLINT1(x)                                                \
+	(((x) & BIT_MASK_BCN_SPACE_CLINT1) << BIT_SHIFT_BCN_SPACE_CLINT1)
+#define BIT_GET_BCN_SPACE_CLINT1(x)                                            \
+	(((x) >> BIT_SHIFT_BCN_SPACE_CLINT1) & BIT_MASK_BCN_SPACE_CLINT1)
+
+/* 2 REG_MBSSID_BCN_SPACE3			(Offset 0x05BC) */
+
+#define BIT_SHIFT_SUB_BCN_SPACE 16
+#define BIT_MASK_SUB_BCN_SPACE 0xff
+#define BIT_SUB_BCN_SPACE(x)                                                   \
+	(((x) & BIT_MASK_SUB_BCN_SPACE) << BIT_SHIFT_SUB_BCN_SPACE)
+#define BIT_GET_SUB_BCN_SPACE(x)                                               \
+	(((x) >> BIT_SHIFT_SUB_BCN_SPACE) & BIT_MASK_SUB_BCN_SPACE)
+
+/* 2 REG_MBSSID_BCN_SPACE3			(Offset 0x05BC) */
+
+#define BIT_SHIFT_BCN_SPACE_CLINT3 0
+#define BIT_MASK_BCN_SPACE_CLINT3 0xfff
+#define BIT_BCN_SPACE_CLINT3(x)                                                \
+	(((x) & BIT_MASK_BCN_SPACE_CLINT3) << BIT_SHIFT_BCN_SPACE_CLINT3)
+#define BIT_GET_BCN_SPACE_CLINT3(x)                                            \
+	(((x) >> BIT_SHIFT_BCN_SPACE_CLINT3) & BIT_MASK_BCN_SPACE_CLINT3)
+
+/* 2 REG_ACMHWCTRL				(Offset 0x05C0) */
+
+#define BIT_BEQ_ACM_STATUS BIT(7)
+#define BIT_VIQ_ACM_STATUS BIT(6)
+#define BIT_VOQ_ACM_STATUS BIT(5)
+#define BIT_BEQ_ACM_EN BIT(3)
+#define BIT_VIQ_ACM_EN BIT(2)
+#define BIT_VOQ_ACM_EN BIT(1)
+#define BIT_ACMHWEN BIT(0)
+
+/* 2 REG_ACMRSTCTRL				(Offset 0x05C1) */
+
+#define BIT_BE_ACM_RESET_USED_TIME BIT(2)
+#define BIT_VI_ACM_RESET_USED_TIME BIT(1)
+#define BIT_VO_ACM_RESET_USED_TIME BIT(0)
+
+/* 2 REG_ACMAVG				(Offset 0x05C2) */
+
+#define BIT_SHIFT_AVGPERIOD 0
+#define BIT_MASK_AVGPERIOD 0xffff
+#define BIT_AVGPERIOD(x) (((x) & BIT_MASK_AVGPERIOD) << BIT_SHIFT_AVGPERIOD)
+#define BIT_GET_AVGPERIOD(x) (((x) >> BIT_SHIFT_AVGPERIOD) & BIT_MASK_AVGPERIOD)
+
+/* 2 REG_VO_ADMTIME				(Offset 0x05C4) */
+
+#define BIT_SHIFT_VO_ADMITTED_TIME 0
+#define BIT_MASK_VO_ADMITTED_TIME 0xffff
+#define BIT_VO_ADMITTED_TIME(x)                                                \
+	(((x) & BIT_MASK_VO_ADMITTED_TIME) << BIT_SHIFT_VO_ADMITTED_TIME)
+#define BIT_GET_VO_ADMITTED_TIME(x)                                            \
+	(((x) >> BIT_SHIFT_VO_ADMITTED_TIME) & BIT_MASK_VO_ADMITTED_TIME)
+
+/* 2 REG_VI_ADMTIME				(Offset 0x05C6) */
+
+#define BIT_SHIFT_VI_ADMITTED_TIME 0
+#define BIT_MASK_VI_ADMITTED_TIME 0xffff
+#define BIT_VI_ADMITTED_TIME(x)                                                \
+	(((x) & BIT_MASK_VI_ADMITTED_TIME) << BIT_SHIFT_VI_ADMITTED_TIME)
+#define BIT_GET_VI_ADMITTED_TIME(x)                                            \
+	(((x) >> BIT_SHIFT_VI_ADMITTED_TIME) & BIT_MASK_VI_ADMITTED_TIME)
+
+/* 2 REG_BE_ADMTIME				(Offset 0x05C8) */
+
+#define BIT_SHIFT_BE_ADMITTED_TIME 0
+#define BIT_MASK_BE_ADMITTED_TIME 0xffff
+#define BIT_BE_ADMITTED_TIME(x)                                                \
+	(((x) & BIT_MASK_BE_ADMITTED_TIME) << BIT_SHIFT_BE_ADMITTED_TIME)
+#define BIT_GET_BE_ADMITTED_TIME(x)                                            \
+	(((x) >> BIT_SHIFT_BE_ADMITTED_TIME) & BIT_MASK_BE_ADMITTED_TIME)
+
+/* 2 REG_EDCA_RANDOM_GEN			(Offset 0x05CC) */
+
+#define BIT_SHIFT_RANDOM_GEN 0
+#define BIT_MASK_RANDOM_GEN 0xffffff
+#define BIT_RANDOM_GEN(x) (((x) & BIT_MASK_RANDOM_GEN) << BIT_SHIFT_RANDOM_GEN)
+#define BIT_GET_RANDOM_GEN(x)                                                  \
+	(((x) >> BIT_SHIFT_RANDOM_GEN) & BIT_MASK_RANDOM_GEN)
+
+/* 2 REG_TXCMD_NOA_SEL			(Offset 0x05CF) */
+
+#define BIT_SHIFT_NOA_SEL 4
+#define BIT_MASK_NOA_SEL 0x7
+#define BIT_NOA_SEL(x) (((x) & BIT_MASK_NOA_SEL) << BIT_SHIFT_NOA_SEL)
+#define BIT_GET_NOA_SEL(x) (((x) >> BIT_SHIFT_NOA_SEL) & BIT_MASK_NOA_SEL)
+
+/* 2 REG_TXCMD_NOA_SEL			(Offset 0x05CF) */
+
+#define BIT_SHIFT_TXCMD_SEG_SEL 0
+#define BIT_MASK_TXCMD_SEG_SEL 0xf
+#define BIT_TXCMD_SEG_SEL(x)                                                   \
+	(((x) & BIT_MASK_TXCMD_SEG_SEL) << BIT_SHIFT_TXCMD_SEG_SEL)
+#define BIT_GET_TXCMD_SEG_SEL(x)                                               \
+	(((x) >> BIT_SHIFT_TXCMD_SEG_SEL) & BIT_MASK_TXCMD_SEG_SEL)
+
+/* 2 REG_NOA_PARAM				(Offset 0x05E0) */
+
+#define BIT_SHIFT_NOA_COUNT (96 & CPU_OPT_WIDTH)
+#define BIT_MASK_NOA_COUNT 0xff
+#define BIT_NOA_COUNT(x) (((x) & BIT_MASK_NOA_COUNT) << BIT_SHIFT_NOA_COUNT)
+#define BIT_GET_NOA_COUNT(x) (((x) >> BIT_SHIFT_NOA_COUNT) & BIT_MASK_NOA_COUNT)
+
+#define BIT_SHIFT_NOA_START_TIME (64 & CPU_OPT_WIDTH)
+#define BIT_MASK_NOA_START_TIME 0xffffffffL
+#define BIT_NOA_START_TIME(x)                                                  \
+	(((x) & BIT_MASK_NOA_START_TIME) << BIT_SHIFT_NOA_START_TIME)
+#define BIT_GET_NOA_START_TIME(x)                                              \
+	(((x) >> BIT_SHIFT_NOA_START_TIME) & BIT_MASK_NOA_START_TIME)
+
+#define BIT_SHIFT_NOA_INTERVAL (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_NOA_INTERVAL 0xffffffffL
+#define BIT_NOA_INTERVAL(x)                                                    \
+	(((x) & BIT_MASK_NOA_INTERVAL) << BIT_SHIFT_NOA_INTERVAL)
+#define BIT_GET_NOA_INTERVAL(x)                                                \
+	(((x) >> BIT_SHIFT_NOA_INTERVAL) & BIT_MASK_NOA_INTERVAL)
+
+#define BIT_SHIFT_NOA_DURATION 0
+#define BIT_MASK_NOA_DURATION 0xffffffffL
+#define BIT_NOA_DURATION(x)                                                    \
+	(((x) & BIT_MASK_NOA_DURATION) << BIT_SHIFT_NOA_DURATION)
+#define BIT_GET_NOA_DURATION(x)                                                \
+	(((x) >> BIT_SHIFT_NOA_DURATION) & BIT_MASK_NOA_DURATION)
+
+/* 2 REG_P2P_RST				(Offset 0x05F0) */
+
+#define BIT_P2P2_PWR_RST1 BIT(5)
+#define BIT_P2P2_PWR_RST0 BIT(4)
+#define BIT_P2P1_PWR_RST1 BIT(3)
+#define BIT_P2P1_PWR_RST0 BIT(2)
+#define BIT_P2P_PWR_RST1_V1 BIT(1)
+#define BIT_P2P_PWR_RST0_V1 BIT(0)
+
+/* 2 REG_SCHEDULER_RST			(Offset 0x05F1) */
+
+#define BIT_SYNC_CLI BIT(1)
+#define BIT_SCHEDULER_RST_V1 BIT(0)
+
+/* 2 REG_SCH_TXCMD				(Offset 0x05F8) */
+
+#define BIT_SHIFT_SCH_TXCMD 0
+#define BIT_MASK_SCH_TXCMD 0xffffffffL
+#define BIT_SCH_TXCMD(x) (((x) & BIT_MASK_SCH_TXCMD) << BIT_SHIFT_SCH_TXCMD)
+#define BIT_GET_SCH_TXCMD(x) (((x) >> BIT_SHIFT_SCH_TXCMD) & BIT_MASK_SCH_TXCMD)
+
+/* 2 REG_WMAC_CR				(Offset 0x0600) */
+
+#define BIT_IC_MACPHY_M BIT(0)
+
+/* 2 REG_WMAC_FWPKT_CR			(Offset 0x0601) */
+
+#define BIT_FWEN BIT(7)
+
+/* 2 REG_WMAC_FWPKT_CR			(Offset 0x0601) */
+
+#define BIT_PHYSTS_PKT_CTRL BIT(6)
+
+/* 2 REG_WMAC_FWPKT_CR			(Offset 0x0601) */
+
+#define BIT_APPHDR_MIDSRCH_FAIL BIT(4)
+#define BIT_FWPARSING_EN BIT(3)
+
+#define BIT_SHIFT_APPEND_MHDR_LEN 0
+#define BIT_MASK_APPEND_MHDR_LEN 0x7
+#define BIT_APPEND_MHDR_LEN(x)                                                 \
+	(((x) & BIT_MASK_APPEND_MHDR_LEN) << BIT_SHIFT_APPEND_MHDR_LEN)
+#define BIT_GET_APPEND_MHDR_LEN(x)                                             \
+	(((x) >> BIT_SHIFT_APPEND_MHDR_LEN) & BIT_MASK_APPEND_MHDR_LEN)
+
+/* 2 REG_TCR					(Offset 0x0604) */
+
+#define BIT_WMAC_EN_RTS_ADDR BIT(31)
+#define BIT_WMAC_DISABLE_CCK BIT(30)
+#define BIT_WMAC_RAW_LEN BIT(29)
+#define BIT_WMAC_NOTX_IN_RXNDP BIT(28)
+#define BIT_WMAC_EN_EOF BIT(27)
+#define BIT_WMAC_BF_SEL BIT(26)
+#define BIT_WMAC_ANTMODE_SEL BIT(25)
+
+/* 2 REG_TCR					(Offset 0x0604) */
+
+#define BIT_WMAC_TCRPWRMGT_HWCTL BIT(24)
+
+/* 2 REG_TCR					(Offset 0x0604) */
+
+#define BIT_WMAC_SMOOTH_VAL BIT(23)
+
+/* 2 REG_TCR					(Offset 0x0604) */
+
+#define BIT_FETCH_MPDU_AFTER_WSEC_RDY BIT(20)
+
+/* 2 REG_TCR					(Offset 0x0604) */
+
+#define BIT_WMAC_TCR_EN_20MST BIT(19)
+#define BIT_WMAC_DIS_SIGTA BIT(18)
+#define BIT_WMAC_DIS_A2B0 BIT(17)
+#define BIT_WMAC_MSK_SIGBCRC BIT(16)
+
+/* 2 REG_TCR					(Offset 0x0604) */
+
+#define BIT_WMAC_TCR_ERRSTEN_3 BIT(15)
+#define BIT_WMAC_TCR_ERRSTEN_2 BIT(14)
+#define BIT_WMAC_TCR_ERRSTEN_1 BIT(13)
+#define BIT_WMAC_TCR_ERRSTEN_0 BIT(12)
+#define BIT_WMAC_TCR_TXSK_PERPKT BIT(11)
+#define BIT_ICV BIT(10)
+#define BIT_CFEND_FORMAT BIT(9)
+#define BIT_CRC BIT(8)
+#define BIT_PWRBIT_OW_EN BIT(7)
+#define BIT_PWR_ST BIT(6)
+#define BIT_WMAC_TCR_UPD_TIMIE BIT(5)
+#define BIT_WMAC_TCR_UPD_HGQMD BIT(4)
+
+/* 2 REG_TCR					(Offset 0x0604) */
+
+#define BIT_VHTSIGA1_TXPS BIT(3)
+
+/* 2 REG_TCR					(Offset 0x0604) */
+
+#define BIT_PAD_SEL BIT(2)
+#define BIT_DIS_GCLK BIT(1)
+
+/* 2 REG_RCR					(Offset 0x0608) */
+
+#define BIT_APP_FCS BIT(31)
+#define BIT_APP_MIC BIT(30)
+#define BIT_APP_ICV BIT(29)
+#define BIT_APP_PHYSTS BIT(28)
+#define BIT_APP_BASSN BIT(27)
+
+/* 2 REG_RCR					(Offset 0x0608) */
+
+#define BIT_VHT_DACK BIT(26)
+
+/* 2 REG_RCR					(Offset 0x0608) */
+
+#define BIT_TCPOFLD_EN BIT(25)
+#define BIT_ENMBID BIT(24)
+#define BIT_LSIGEN BIT(23)
+#define BIT_MFBEN BIT(22)
+#define BIT_DISCHKPPDLLEN BIT(21)
+#define BIT_PKTCTL_DLEN BIT(20)
+#define BIT_TIM_PARSER_EN BIT(18)
+#define BIT_BC_MD_EN BIT(17)
+#define BIT_UC_MD_EN BIT(16)
+#define BIT_RXSK_PERPKT BIT(15)
+#define BIT_HTC_LOC_CTRL BIT(14)
+
+/* 2 REG_RCR					(Offset 0x0608) */
+
+#define BIT_RPFM_CAM_ENABLE BIT(12)
+
+/* 2 REG_RCR					(Offset 0x0608) */
+
+#define BIT_TA_BCN BIT(11)
+
+/* 2 REG_RCR					(Offset 0x0608) */
+
+#define BIT_DISDECMYPKT BIT(10)
+#define BIT_AICV BIT(9)
+#define BIT_ACRC32 BIT(8)
+#define BIT_CBSSID_BCN BIT(7)
+#define BIT_CBSSID_DATA BIT(6)
+#define BIT_APWRMGT BIT(5)
+#define BIT_ADD3 BIT(4)
+#define BIT_AB BIT(3)
+#define BIT_AM BIT(2)
+#define BIT_APM BIT(1)
+#define BIT_AAP BIT(0)
+
+/* 2 REG_RX_PKT_LIMIT			(Offset 0x060C) */
+
+#define BIT_SHIFT_RXPKTLMT 0
+#define BIT_MASK_RXPKTLMT 0x3f
+#define BIT_RXPKTLMT(x) (((x) & BIT_MASK_RXPKTLMT) << BIT_SHIFT_RXPKTLMT)
+#define BIT_GET_RXPKTLMT(x) (((x) >> BIT_SHIFT_RXPKTLMT) & BIT_MASK_RXPKTLMT)
+
+/* 2 REG_RX_DLK_TIME				(Offset 0x060D) */
+
+#define BIT_SHIFT_RX_DLK_TIME 0
+#define BIT_MASK_RX_DLK_TIME 0xff
+#define BIT_RX_DLK_TIME(x)                                                     \
+	(((x) & BIT_MASK_RX_DLK_TIME) << BIT_SHIFT_RX_DLK_TIME)
+#define BIT_GET_RX_DLK_TIME(x)                                                 \
+	(((x) >> BIT_SHIFT_RX_DLK_TIME) & BIT_MASK_RX_DLK_TIME)
+
+/* 2 REG_RX_DRVINFO_SZ			(Offset 0x060F) */
+
+#define BIT_DATA_RPFM15EN BIT(15)
+#define BIT_DATA_RPFM14EN BIT(14)
+#define BIT_DATA_RPFM13EN BIT(13)
+#define BIT_DATA_RPFM12EN BIT(12)
+#define BIT_DATA_RPFM11EN BIT(11)
+#define BIT_DATA_RPFM10EN BIT(10)
+#define BIT_DATA_RPFM9EN BIT(9)
+#define BIT_DATA_RPFM8EN BIT(8)
+
+/* 2 REG_RX_DRVINFO_SZ			(Offset 0x060F) */
+
+#define BIT_PHYSTS_PER_PKT_MODE BIT(7)
+#define BIT_DATA_RPFM7EN BIT(7)
+
+/* 2 REG_RX_DRVINFO_SZ			(Offset 0x060F) */
+
+#define BIT_DATA_RPFM6EN BIT(6)
+
+/* 2 REG_RX_DRVINFO_SZ			(Offset 0x060F) */
+
+#define BIT_DATA_RPFM5EN BIT(5)
+#define BIT_DATA_RPFM4EN BIT(4)
+#define BIT_DATA_RPFM3EN BIT(3)
+#define BIT_DATA_RPFM2EN BIT(2)
+#define BIT_DATA_RPFM1EN BIT(1)
+
+/* 2 REG_RX_DRVINFO_SZ			(Offset 0x060F) */
+
+#define BIT_SHIFT_DRVINFO_SZ_V1 0
+#define BIT_MASK_DRVINFO_SZ_V1 0xf
+#define BIT_DRVINFO_SZ_V1(x)                                                   \
+	(((x) & BIT_MASK_DRVINFO_SZ_V1) << BIT_SHIFT_DRVINFO_SZ_V1)
+#define BIT_GET_DRVINFO_SZ_V1(x)                                               \
+	(((x) >> BIT_SHIFT_DRVINFO_SZ_V1) & BIT_MASK_DRVINFO_SZ_V1)
+
+/* 2 REG_RX_DRVINFO_SZ			(Offset 0x060F) */
+
+#define BIT_DATA_RPFM0EN BIT(0)
+
+/* 2 REG_MACID				(Offset 0x0610) */
+
+#define BIT_SHIFT_MACID 0
+#define BIT_MASK_MACID 0xffffffffffffL
+#define BIT_MACID(x) (((x) & BIT_MASK_MACID) << BIT_SHIFT_MACID)
+#define BIT_GET_MACID(x) (((x) >> BIT_SHIFT_MACID) & BIT_MASK_MACID)
+
+/* 2 REG_BSSID				(Offset 0x0618) */
+
+#define BIT_SHIFT_BSSID 0
+#define BIT_MASK_BSSID 0xffffffffffffL
+#define BIT_BSSID(x) (((x) & BIT_MASK_BSSID) << BIT_SHIFT_BSSID)
+#define BIT_GET_BSSID(x) (((x) >> BIT_SHIFT_BSSID) & BIT_MASK_BSSID)
+
+/* 2 REG_MAR					(Offset 0x0620) */
+
+#define BIT_SHIFT_MAR 0
+#define BIT_MASK_MAR 0xffffffffffffffffL
+#define BIT_MAR(x) (((x) & BIT_MASK_MAR) << BIT_SHIFT_MAR)
+#define BIT_GET_MAR(x) (((x) >> BIT_SHIFT_MAR) & BIT_MASK_MAR)
+
+/* 2 REG_MBIDCAMCFG_1			(Offset 0x0628) */
+
+#define BIT_SHIFT_MBIDCAM_RWDATA_L 0
+#define BIT_MASK_MBIDCAM_RWDATA_L 0xffffffffL
+#define BIT_MBIDCAM_RWDATA_L(x)                                                \
+	(((x) & BIT_MASK_MBIDCAM_RWDATA_L) << BIT_SHIFT_MBIDCAM_RWDATA_L)
+#define BIT_GET_MBIDCAM_RWDATA_L(x)                                            \
+	(((x) >> BIT_SHIFT_MBIDCAM_RWDATA_L) & BIT_MASK_MBIDCAM_RWDATA_L)
+
+/* 2 REG_MBIDCAMCFG_2			(Offset 0x062C) */
+
+#define BIT_MBIDCAM_POLL BIT(31)
+#define BIT_MBIDCAM_WT_EN BIT(30)
+
+#define BIT_SHIFT_MBIDCAM_ADDR 24
+#define BIT_MASK_MBIDCAM_ADDR 0x1f
+#define BIT_MBIDCAM_ADDR(x)                                                    \
+	(((x) & BIT_MASK_MBIDCAM_ADDR) << BIT_SHIFT_MBIDCAM_ADDR)
+#define BIT_GET_MBIDCAM_ADDR(x)                                                \
+	(((x) >> BIT_SHIFT_MBIDCAM_ADDR) & BIT_MASK_MBIDCAM_ADDR)
+
+#define BIT_MBIDCAM_VALID BIT(23)
+#define BIT_LSIC_TXOP_EN BIT(17)
+
+/* 2 REG_MBIDCAMCFG_2			(Offset 0x062C) */
+
+#define BIT_CTS_EN BIT(16)
+
+/* 2 REG_MBIDCAMCFG_2			(Offset 0x062C) */
+
+#define BIT_SHIFT_MBIDCAM_RWDATA_H 0
+#define BIT_MASK_MBIDCAM_RWDATA_H 0xffff
+#define BIT_MBIDCAM_RWDATA_H(x)                                                \
+	(((x) & BIT_MASK_MBIDCAM_RWDATA_H) << BIT_SHIFT_MBIDCAM_RWDATA_H)
+#define BIT_GET_MBIDCAM_RWDATA_H(x)                                            \
+	(((x) >> BIT_SHIFT_MBIDCAM_RWDATA_H) & BIT_MASK_MBIDCAM_RWDATA_H)
+
+/* 2 REG_WMAC_TCR_TSFT_OFS			(Offset 0x0630) */
+
+#define BIT_SHIFT_WMAC_TCR_TSFT_OFS 0
+#define BIT_MASK_WMAC_TCR_TSFT_OFS 0xffff
+#define BIT_WMAC_TCR_TSFT_OFS(x)                                               \
+	(((x) & BIT_MASK_WMAC_TCR_TSFT_OFS) << BIT_SHIFT_WMAC_TCR_TSFT_OFS)
+#define BIT_GET_WMAC_TCR_TSFT_OFS(x)                                           \
+	(((x) >> BIT_SHIFT_WMAC_TCR_TSFT_OFS) & BIT_MASK_WMAC_TCR_TSFT_OFS)
+
+/* 2 REG_UDF_THSD				(Offset 0x0632) */
+
+#define BIT_SHIFT_UDF_THSD 0
+#define BIT_MASK_UDF_THSD 0xff
+#define BIT_UDF_THSD(x) (((x) & BIT_MASK_UDF_THSD) << BIT_SHIFT_UDF_THSD)
+#define BIT_GET_UDF_THSD(x) (((x) >> BIT_SHIFT_UDF_THSD) & BIT_MASK_UDF_THSD)
+
+/* 2 REG_ZLD_NUM				(Offset 0x0633) */
+
+#define BIT_SHIFT_ZLD_NUM 0
+#define BIT_MASK_ZLD_NUM 0xff
+#define BIT_ZLD_NUM(x) (((x) & BIT_MASK_ZLD_NUM) << BIT_SHIFT_ZLD_NUM)
+#define BIT_GET_ZLD_NUM(x) (((x) >> BIT_SHIFT_ZLD_NUM) & BIT_MASK_ZLD_NUM)
+
+/* 2 REG_STMP_THSD				(Offset 0x0634) */
+
+#define BIT_SHIFT_STMP_THSD 0
+#define BIT_MASK_STMP_THSD 0xff
+#define BIT_STMP_THSD(x) (((x) & BIT_MASK_STMP_THSD) << BIT_SHIFT_STMP_THSD)
+#define BIT_GET_STMP_THSD(x) (((x) >> BIT_SHIFT_STMP_THSD) & BIT_MASK_STMP_THSD)
+
+/* 2 REG_WMAC_TXTIMEOUT			(Offset 0x0635) */
+
+#define BIT_SHIFT_WMAC_TXTIMEOUT 0
+#define BIT_MASK_WMAC_TXTIMEOUT 0xff
+#define BIT_WMAC_TXTIMEOUT(x)                                                  \
+	(((x) & BIT_MASK_WMAC_TXTIMEOUT) << BIT_SHIFT_WMAC_TXTIMEOUT)
+#define BIT_GET_WMAC_TXTIMEOUT(x)                                              \
+	(((x) >> BIT_SHIFT_WMAC_TXTIMEOUT) & BIT_MASK_WMAC_TXTIMEOUT)
+
+/* 2 REG_MCU_TEST_2_V1			(Offset 0x0636) */
+
+#define BIT_SHIFT_MCU_RSVD_2_V1 0
+#define BIT_MASK_MCU_RSVD_2_V1 0xffff
+#define BIT_MCU_RSVD_2_V1(x)                                                   \
+	(((x) & BIT_MASK_MCU_RSVD_2_V1) << BIT_SHIFT_MCU_RSVD_2_V1)
+#define BIT_GET_MCU_RSVD_2_V1(x)                                               \
+	(((x) >> BIT_SHIFT_MCU_RSVD_2_V1) & BIT_MASK_MCU_RSVD_2_V1)
+
+/* 2 REG_USTIME_EDCA				(Offset 0x0638) */
+
+#define BIT_SHIFT_USTIME_EDCA_V1 0
+#define BIT_MASK_USTIME_EDCA_V1 0x1ff
+#define BIT_USTIME_EDCA_V1(x)                                                  \
+	(((x) & BIT_MASK_USTIME_EDCA_V1) << BIT_SHIFT_USTIME_EDCA_V1)
+#define BIT_GET_USTIME_EDCA_V1(x)                                              \
+	(((x) >> BIT_SHIFT_USTIME_EDCA_V1) & BIT_MASK_USTIME_EDCA_V1)
+
+/* 2 REG_MAC_SPEC_SIFS			(Offset 0x063A) */
+
+#define BIT_SHIFT_SPEC_SIFS_OFDM 8
+#define BIT_MASK_SPEC_SIFS_OFDM 0xff
+#define BIT_SPEC_SIFS_OFDM(x)                                                  \
+	(((x) & BIT_MASK_SPEC_SIFS_OFDM) << BIT_SHIFT_SPEC_SIFS_OFDM)
+#define BIT_GET_SPEC_SIFS_OFDM(x)                                              \
+	(((x) >> BIT_SHIFT_SPEC_SIFS_OFDM) & BIT_MASK_SPEC_SIFS_OFDM)
+
+#define BIT_SHIFT_SPEC_SIFS_CCK 0
+#define BIT_MASK_SPEC_SIFS_CCK 0xff
+#define BIT_SPEC_SIFS_CCK(x)                                                   \
+	(((x) & BIT_MASK_SPEC_SIFS_CCK) << BIT_SHIFT_SPEC_SIFS_CCK)
+#define BIT_GET_SPEC_SIFS_CCK(x)                                               \
+	(((x) >> BIT_SHIFT_SPEC_SIFS_CCK) & BIT_MASK_SPEC_SIFS_CCK)
+
+/* 2 REG_RESP_SIFS_CCK			(Offset 0x063C) */
+
+#define BIT_SHIFT_SIFS_R2T_CCK 8
+#define BIT_MASK_SIFS_R2T_CCK 0xff
+#define BIT_SIFS_R2T_CCK(x)                                                    \
+	(((x) & BIT_MASK_SIFS_R2T_CCK) << BIT_SHIFT_SIFS_R2T_CCK)
+#define BIT_GET_SIFS_R2T_CCK(x)                                                \
+	(((x) >> BIT_SHIFT_SIFS_R2T_CCK) & BIT_MASK_SIFS_R2T_CCK)
+
+#define BIT_SHIFT_SIFS_T2T_CCK 0
+#define BIT_MASK_SIFS_T2T_CCK 0xff
+#define BIT_SIFS_T2T_CCK(x)                                                    \
+	(((x) & BIT_MASK_SIFS_T2T_CCK) << BIT_SHIFT_SIFS_T2T_CCK)
+#define BIT_GET_SIFS_T2T_CCK(x)                                                \
+	(((x) >> BIT_SHIFT_SIFS_T2T_CCK) & BIT_MASK_SIFS_T2T_CCK)
+
+/* 2 REG_RESP_SIFS_OFDM			(Offset 0x063E) */
+
+#define BIT_SHIFT_SIFS_R2T_OFDM 8
+#define BIT_MASK_SIFS_R2T_OFDM 0xff
+#define BIT_SIFS_R2T_OFDM(x)                                                   \
+	(((x) & BIT_MASK_SIFS_R2T_OFDM) << BIT_SHIFT_SIFS_R2T_OFDM)
+#define BIT_GET_SIFS_R2T_OFDM(x)                                               \
+	(((x) >> BIT_SHIFT_SIFS_R2T_OFDM) & BIT_MASK_SIFS_R2T_OFDM)
+
+#define BIT_SHIFT_SIFS_T2T_OFDM 0
+#define BIT_MASK_SIFS_T2T_OFDM 0xff
+#define BIT_SIFS_T2T_OFDM(x)                                                   \
+	(((x) & BIT_MASK_SIFS_T2T_OFDM) << BIT_SHIFT_SIFS_T2T_OFDM)
+#define BIT_GET_SIFS_T2T_OFDM(x)                                               \
+	(((x) >> BIT_SHIFT_SIFS_T2T_OFDM) & BIT_MASK_SIFS_T2T_OFDM)
+
+/* 2 REG_ACKTO				(Offset 0x0640) */
+
+#define BIT_SHIFT_ACKTO 0
+#define BIT_MASK_ACKTO 0xff
+#define BIT_ACKTO(x) (((x) & BIT_MASK_ACKTO) << BIT_SHIFT_ACKTO)
+#define BIT_GET_ACKTO(x) (((x) >> BIT_SHIFT_ACKTO) & BIT_MASK_ACKTO)
+
+/* 2 REG_CTS2TO				(Offset 0x0641) */
+
+#define BIT_SHIFT_CTS2TO 0
+#define BIT_MASK_CTS2TO 0xff
+#define BIT_CTS2TO(x) (((x) & BIT_MASK_CTS2TO) << BIT_SHIFT_CTS2TO)
+#define BIT_GET_CTS2TO(x) (((x) >> BIT_SHIFT_CTS2TO) & BIT_MASK_CTS2TO)
+
+/* 2 REG_EIFS				(Offset 0x0642) */
+
+#define BIT_SHIFT_EIFS 0
+#define BIT_MASK_EIFS 0xffff
+#define BIT_EIFS(x) (((x) & BIT_MASK_EIFS) << BIT_SHIFT_EIFS)
+#define BIT_GET_EIFS(x) (((x) >> BIT_SHIFT_EIFS) & BIT_MASK_EIFS)
+
+/* 2 REG_NAV_CTRL				(Offset 0x0650) */
+
+#define BIT_SHIFT_NAV_UPPER 16
+#define BIT_MASK_NAV_UPPER 0xff
+#define BIT_NAV_UPPER(x) (((x) & BIT_MASK_NAV_UPPER) << BIT_SHIFT_NAV_UPPER)
+#define BIT_GET_NAV_UPPER(x) (((x) >> BIT_SHIFT_NAV_UPPER) & BIT_MASK_NAV_UPPER)
+
+#define BIT_SHIFT_RXMYRTS_NAV 8
+#define BIT_MASK_RXMYRTS_NAV 0xf
+#define BIT_RXMYRTS_NAV(x)                                                     \
+	(((x) & BIT_MASK_RXMYRTS_NAV) << BIT_SHIFT_RXMYRTS_NAV)
+#define BIT_GET_RXMYRTS_NAV(x)                                                 \
+	(((x) >> BIT_SHIFT_RXMYRTS_NAV) & BIT_MASK_RXMYRTS_NAV)
+
+#define BIT_SHIFT_RTSRST 0
+#define BIT_MASK_RTSRST 0xff
+#define BIT_RTSRST(x) (((x) & BIT_MASK_RTSRST) << BIT_SHIFT_RTSRST)
+#define BIT_GET_RTSRST(x) (((x) >> BIT_SHIFT_RTSRST) & BIT_MASK_RTSRST)
+
+/* 2 REG_BACAMCMD				(Offset 0x0654) */
+
+#define BIT_BACAM_POLL BIT(31)
+#define BIT_BACAM_RST BIT(17)
+#define BIT_BACAM_RW BIT(16)
+
+#define BIT_SHIFT_TXSBM 14
+#define BIT_MASK_TXSBM 0x3
+#define BIT_TXSBM(x) (((x) & BIT_MASK_TXSBM) << BIT_SHIFT_TXSBM)
+#define BIT_GET_TXSBM(x) (((x) >> BIT_SHIFT_TXSBM) & BIT_MASK_TXSBM)
+
+#define BIT_SHIFT_BACAM_ADDR 0
+#define BIT_MASK_BACAM_ADDR 0x3f
+#define BIT_BACAM_ADDR(x) (((x) & BIT_MASK_BACAM_ADDR) << BIT_SHIFT_BACAM_ADDR)
+#define BIT_GET_BACAM_ADDR(x)                                                  \
+	(((x) >> BIT_SHIFT_BACAM_ADDR) & BIT_MASK_BACAM_ADDR)
+
+/* 2 REG_BACAMCONTENT			(Offset 0x0658) */
+
+#define BIT_SHIFT_BA_CONTENT_H (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_BA_CONTENT_H 0xffffffffL
+#define BIT_BA_CONTENT_H(x)                                                    \
+	(((x) & BIT_MASK_BA_CONTENT_H) << BIT_SHIFT_BA_CONTENT_H)
+#define BIT_GET_BA_CONTENT_H(x)                                                \
+	(((x) >> BIT_SHIFT_BA_CONTENT_H) & BIT_MASK_BA_CONTENT_H)
+
+#define BIT_SHIFT_BA_CONTENT_L 0
+#define BIT_MASK_BA_CONTENT_L 0xffffffffL
+#define BIT_BA_CONTENT_L(x)                                                    \
+	(((x) & BIT_MASK_BA_CONTENT_L) << BIT_SHIFT_BA_CONTENT_L)
+#define BIT_GET_BA_CONTENT_L(x)                                                \
+	(((x) >> BIT_SHIFT_BA_CONTENT_L) & BIT_MASK_BA_CONTENT_L)
+
+/* 2 REG_LBDLY				(Offset 0x0660) */
+
+#define BIT_SHIFT_LBDLY 0
+#define BIT_MASK_LBDLY 0x1f
+#define BIT_LBDLY(x) (((x) & BIT_MASK_LBDLY) << BIT_SHIFT_LBDLY)
+#define BIT_GET_LBDLY(x) (((x) >> BIT_SHIFT_LBDLY) & BIT_MASK_LBDLY)
+
+/* 2 REG_WMAC_BACAM_RPMEN			(Offset 0x0661) */
+
+#define BIT_SHIFT_BITMAP_SSNBK_COUNTER 2
+#define BIT_MASK_BITMAP_SSNBK_COUNTER 0x3f
+#define BIT_BITMAP_SSNBK_COUNTER(x)                                            \
+	(((x) & BIT_MASK_BITMAP_SSNBK_COUNTER)                                 \
+	 << BIT_SHIFT_BITMAP_SSNBK_COUNTER)
+#define BIT_GET_BITMAP_SSNBK_COUNTER(x)                                        \
+	(((x) >> BIT_SHIFT_BITMAP_SSNBK_COUNTER) &                             \
+	 BIT_MASK_BITMAP_SSNBK_COUNTER)
+
+#define BIT_BITMAP_EN BIT(1)
+
+/* 2 REG_WMAC_BACAM_RPMEN			(Offset 0x0661) */
+
+#define BIT_WMAC_BACAM_RPMEN BIT(0)
+
+/* 2 REG_TX_RX				(Offset 0x0662) */
+
+#define BIT_SHIFT_RXPKT_TYPE 2
+#define BIT_MASK_RXPKT_TYPE 0x3f
+#define BIT_RXPKT_TYPE(x) (((x) & BIT_MASK_RXPKT_TYPE) << BIT_SHIFT_RXPKT_TYPE)
+#define BIT_GET_RXPKT_TYPE(x)                                                  \
+	(((x) >> BIT_SHIFT_RXPKT_TYPE) & BIT_MASK_RXPKT_TYPE)
+
+#define BIT_TXACT_IND BIT(1)
+#define BIT_RXACT_IND BIT(0)
+
+/* 2 REG_WMAC_BITMAP_CTL			(Offset 0x0663) */
+
+#define BIT_BITMAP_VO BIT(7)
+#define BIT_BITMAP_VI BIT(6)
+#define BIT_BITMAP_BE BIT(5)
+#define BIT_BITMAP_BK BIT(4)
+
+#define BIT_SHIFT_BITMAP_CONDITION 2
+#define BIT_MASK_BITMAP_CONDITION 0x3
+#define BIT_BITMAP_CONDITION(x)                                                \
+	(((x) & BIT_MASK_BITMAP_CONDITION) << BIT_SHIFT_BITMAP_CONDITION)
+#define BIT_GET_BITMAP_CONDITION(x)                                            \
+	(((x) >> BIT_SHIFT_BITMAP_CONDITION) & BIT_MASK_BITMAP_CONDITION)
+
+#define BIT_BITMAP_SSNBK_COUNTER_CLR BIT(1)
+#define BIT_BITMAP_FORCE BIT(0)
+
+/* 2 REG_RXERR_RPT				(Offset 0x0664) */
+
+#define BIT_SHIFT_RXERR_RPT_SEL_V1_3_0 28
+#define BIT_MASK_RXERR_RPT_SEL_V1_3_0 0xf
+#define BIT_RXERR_RPT_SEL_V1_3_0(x)                                            \
+	(((x) & BIT_MASK_RXERR_RPT_SEL_V1_3_0)                                 \
+	 << BIT_SHIFT_RXERR_RPT_SEL_V1_3_0)
+#define BIT_GET_RXERR_RPT_SEL_V1_3_0(x)                                        \
+	(((x) >> BIT_SHIFT_RXERR_RPT_SEL_V1_3_0) &                             \
+	 BIT_MASK_RXERR_RPT_SEL_V1_3_0)
+
+/* 2 REG_RXERR_RPT				(Offset 0x0664) */
+
+#define BIT_RXERR_RPT_RST BIT(27)
+
+/* 2 REG_RXERR_RPT				(Offset 0x0664) */
+
+#define BIT_RXERR_RPT_SEL_V1_4 BIT(26)
+
+/* 2 REG_RXERR_RPT				(Offset 0x0664) */
+
+#define BIT_W1S BIT(23)
+
+/* 2 REG_RXERR_RPT				(Offset 0x0664) */
+
+#define BIT_UD_SELECT_BSSID BIT(22)
+
+/* 2 REG_RXERR_RPT				(Offset 0x0664) */
+
+#define BIT_SHIFT_UD_SUB_TYPE 18
+#define BIT_MASK_UD_SUB_TYPE 0xf
+#define BIT_UD_SUB_TYPE(x)                                                     \
+	(((x) & BIT_MASK_UD_SUB_TYPE) << BIT_SHIFT_UD_SUB_TYPE)
+#define BIT_GET_UD_SUB_TYPE(x)                                                 \
+	(((x) >> BIT_SHIFT_UD_SUB_TYPE) & BIT_MASK_UD_SUB_TYPE)
+
+#define BIT_SHIFT_UD_TYPE 16
+#define BIT_MASK_UD_TYPE 0x3
+#define BIT_UD_TYPE(x) (((x) & BIT_MASK_UD_TYPE) << BIT_SHIFT_UD_TYPE)
+#define BIT_GET_UD_TYPE(x) (((x) >> BIT_SHIFT_UD_TYPE) & BIT_MASK_UD_TYPE)
+
+#define BIT_SHIFT_RPT_COUNTER 0
+#define BIT_MASK_RPT_COUNTER 0xffff
+#define BIT_RPT_COUNTER(x)                                                     \
+	(((x) & BIT_MASK_RPT_COUNTER) << BIT_SHIFT_RPT_COUNTER)
+#define BIT_GET_RPT_COUNTER(x)                                                 \
+	(((x) >> BIT_SHIFT_RPT_COUNTER) & BIT_MASK_RPT_COUNTER)
+
+/* 2 REG_WMAC_TRXPTCL_CTL			(Offset 0x0668) */
+
+#define BIT_SHIFT_ACKBA_TYPSEL (60 & CPU_OPT_WIDTH)
+#define BIT_MASK_ACKBA_TYPSEL 0xf
+#define BIT_ACKBA_TYPSEL(x)                                                    \
+	(((x) & BIT_MASK_ACKBA_TYPSEL) << BIT_SHIFT_ACKBA_TYPSEL)
+#define BIT_GET_ACKBA_TYPSEL(x)                                                \
+	(((x) >> BIT_SHIFT_ACKBA_TYPSEL) & BIT_MASK_ACKBA_TYPSEL)
+
+#define BIT_SHIFT_ACKBA_ACKPCHK (56 & CPU_OPT_WIDTH)
+#define BIT_MASK_ACKBA_ACKPCHK 0xf
+#define BIT_ACKBA_ACKPCHK(x)                                                   \
+	(((x) & BIT_MASK_ACKBA_ACKPCHK) << BIT_SHIFT_ACKBA_ACKPCHK)
+#define BIT_GET_ACKBA_ACKPCHK(x)                                               \
+	(((x) >> BIT_SHIFT_ACKBA_ACKPCHK) & BIT_MASK_ACKBA_ACKPCHK)
+
+#define BIT_SHIFT_ACKBAR_TYPESEL (48 & CPU_OPT_WIDTH)
+#define BIT_MASK_ACKBAR_TYPESEL 0xff
+#define BIT_ACKBAR_TYPESEL(x)                                                  \
+	(((x) & BIT_MASK_ACKBAR_TYPESEL) << BIT_SHIFT_ACKBAR_TYPESEL)
+#define BIT_GET_ACKBAR_TYPESEL(x)                                              \
+	(((x) >> BIT_SHIFT_ACKBAR_TYPESEL) & BIT_MASK_ACKBAR_TYPESEL)
+
+#define BIT_SHIFT_ACKBAR_ACKPCHK (44 & CPU_OPT_WIDTH)
+#define BIT_MASK_ACKBAR_ACKPCHK 0xf
+#define BIT_ACKBAR_ACKPCHK(x)                                                  \
+	(((x) & BIT_MASK_ACKBAR_ACKPCHK) << BIT_SHIFT_ACKBAR_ACKPCHK)
+#define BIT_GET_ACKBAR_ACKPCHK(x)                                              \
+	(((x) >> BIT_SHIFT_ACKBAR_ACKPCHK) & BIT_MASK_ACKBAR_ACKPCHK)
+
+/* 2 REG_WMAC_TRXPTCL_CTL			(Offset 0x0668) */
+
+#define BIT_RXBA_IGNOREA2 BIT(42)
+#define BIT_EN_SAVE_ALL_TXOPADDR BIT(41)
+#define BIT_EN_TXCTS_TO_TXOPOWNER_INRXNAV BIT(40)
+
+/* 2 REG_WMAC_TRXPTCL_CTL			(Offset 0x0668) */
+
+#define BIT_DIS_TXBA_AMPDUFCSERR BIT(39)
+#define BIT_DIS_TXBA_RXBARINFULL BIT(38)
+#define BIT_DIS_TXCFE_INFULL BIT(37)
+#define BIT_DIS_TXCTS_INFULL BIT(36)
+#define BIT_EN_TXACKBA_IN_TX_RDG BIT(35)
+#define BIT_EN_TXACKBA_IN_TXOP BIT(34)
+#define BIT_EN_TXCTS_IN_RXNAV BIT(33)
+#define BIT_EN_TXCTS_INTXOP BIT(32)
+#define BIT_BLK_EDCA_BBSLP BIT(31)
+#define BIT_BLK_EDCA_BBSBY BIT(30)
+#define BIT_ACKTO_BLOCK_SCH_EN BIT(27)
+#define BIT_EIFS_BLOCK_SCH_EN BIT(26)
+#define BIT_PLCPCHK_RST_EIFS BIT(25)
+#define BIT_CCA_RST_EIFS BIT(24)
+#define BIT_DIS_UPD_MYRXPKTNAV BIT(23)
+#define BIT_EARLY_TXBA BIT(22)
+
+#define BIT_SHIFT_RESP_CHNBUSY 20
+#define BIT_MASK_RESP_CHNBUSY 0x3
+#define BIT_RESP_CHNBUSY(x)                                                    \
+	(((x) & BIT_MASK_RESP_CHNBUSY) << BIT_SHIFT_RESP_CHNBUSY)
+#define BIT_GET_RESP_CHNBUSY(x)                                                \
+	(((x) >> BIT_SHIFT_RESP_CHNBUSY) & BIT_MASK_RESP_CHNBUSY)
+
+#define BIT_RESP_DCTS_EN BIT(19)
+#define BIT_RESP_DCFE_EN BIT(18)
+#define BIT_RESP_SPLCPEN BIT(17)
+#define BIT_RESP_SGIEN BIT(16)
+
+/* 2 REG_WMAC_TRXPTCL_CTL			(Offset 0x0668) */
+
+#define BIT_RESP_LDPC_EN BIT(15)
+#define BIT_DIS_RESP_ACKINCCA BIT(14)
+#define BIT_DIS_RESP_CTSINCCA BIT(13)
+
+/* 2 REG_WMAC_TRXPTCL_CTL			(Offset 0x0668) */
+
+#define BIT_SHIFT_R_WMAC_SECOND_CCA_TIMER 10
+#define BIT_MASK_R_WMAC_SECOND_CCA_TIMER 0x7
+#define BIT_R_WMAC_SECOND_CCA_TIMER(x)                                         \
+	(((x) & BIT_MASK_R_WMAC_SECOND_CCA_TIMER)                              \
+	 << BIT_SHIFT_R_WMAC_SECOND_CCA_TIMER)
+#define BIT_GET_R_WMAC_SECOND_CCA_TIMER(x)                                     \
+	(((x) >> BIT_SHIFT_R_WMAC_SECOND_CCA_TIMER) &                          \
+	 BIT_MASK_R_WMAC_SECOND_CCA_TIMER)
+
+/* 2 REG_WMAC_TRXPTCL_CTL			(Offset 0x0668) */
+
+#define BIT_SHIFT_RFMOD 7
+#define BIT_MASK_RFMOD 0x3
+#define BIT_RFMOD(x) (((x) & BIT_MASK_RFMOD) << BIT_SHIFT_RFMOD)
+#define BIT_GET_RFMOD(x) (((x) >> BIT_SHIFT_RFMOD) & BIT_MASK_RFMOD)
+
+/* 2 REG_WMAC_TRXPTCL_CTL			(Offset 0x0668) */
+
+#define BIT_SHIFT_RESP_CTS_DYNBW_SEL 5
+#define BIT_MASK_RESP_CTS_DYNBW_SEL 0x3
+#define BIT_RESP_CTS_DYNBW_SEL(x)                                              \
+	(((x) & BIT_MASK_RESP_CTS_DYNBW_SEL) << BIT_SHIFT_RESP_CTS_DYNBW_SEL)
+#define BIT_GET_RESP_CTS_DYNBW_SEL(x)                                          \
+	(((x) >> BIT_SHIFT_RESP_CTS_DYNBW_SEL) & BIT_MASK_RESP_CTS_DYNBW_SEL)
+
+/* 2 REG_WMAC_TRXPTCL_CTL			(Offset 0x0668) */
+
+#define BIT_DLY_TX_WAIT_RXANTSEL BIT(4)
+
+/* 2 REG_WMAC_TRXPTCL_CTL			(Offset 0x0668) */
+
+#define BIT_TXRESP_BY_RXANTSEL BIT(3)
+
+/* 2 REG_WMAC_TRXPTCL_CTL			(Offset 0x0668) */
+
+#define BIT_SHIFT_ORIG_DCTS_CHK 0
+#define BIT_MASK_ORIG_DCTS_CHK 0x3
+#define BIT_ORIG_DCTS_CHK(x)                                                   \
+	(((x) & BIT_MASK_ORIG_DCTS_CHK) << BIT_SHIFT_ORIG_DCTS_CHK)
+#define BIT_GET_ORIG_DCTS_CHK(x)                                               \
+	(((x) >> BIT_SHIFT_ORIG_DCTS_CHK) & BIT_MASK_ORIG_DCTS_CHK)
+
+/* 2 REG_CAMCMD				(Offset 0x0670) */
+
+#define BIT_SECCAM_POLLING BIT(31)
+#define BIT_SECCAM_CLR BIT(30)
+#define BIT_MFBCAM_CLR BIT(29)
+
+/* 2 REG_CAMCMD				(Offset 0x0670) */
+
+#define BIT_SECCAM_WE BIT(16)
+
+/* 2 REG_CAMCMD				(Offset 0x0670) */
+
+#define BIT_SHIFT_SECCAM_ADDR_V2 0
+#define BIT_MASK_SECCAM_ADDR_V2 0x3ff
+#define BIT_SECCAM_ADDR_V2(x)                                                  \
+	(((x) & BIT_MASK_SECCAM_ADDR_V2) << BIT_SHIFT_SECCAM_ADDR_V2)
+#define BIT_GET_SECCAM_ADDR_V2(x)                                              \
+	(((x) >> BIT_SHIFT_SECCAM_ADDR_V2) & BIT_MASK_SECCAM_ADDR_V2)
+
+/* 2 REG_CAMWRITE				(Offset 0x0674) */
+
+#define BIT_SHIFT_CAMW_DATA 0
+#define BIT_MASK_CAMW_DATA 0xffffffffL
+#define BIT_CAMW_DATA(x) (((x) & BIT_MASK_CAMW_DATA) << BIT_SHIFT_CAMW_DATA)
+#define BIT_GET_CAMW_DATA(x) (((x) >> BIT_SHIFT_CAMW_DATA) & BIT_MASK_CAMW_DATA)
+
+/* 2 REG_CAMREAD				(Offset 0x0678) */
+
+#define BIT_SHIFT_CAMR_DATA 0
+#define BIT_MASK_CAMR_DATA 0xffffffffL
+#define BIT_CAMR_DATA(x) (((x) & BIT_MASK_CAMR_DATA) << BIT_SHIFT_CAMR_DATA)
+#define BIT_GET_CAMR_DATA(x) (((x) >> BIT_SHIFT_CAMR_DATA) & BIT_MASK_CAMR_DATA)
+
+/* 2 REG_CAMDBG				(Offset 0x067C) */
+
+#define BIT_SECCAM_INFO BIT(31)
+#define BIT_SEC_KEYFOUND BIT(15)
+
+#define BIT_SHIFT_CAMDBG_SEC_TYPE 12
+#define BIT_MASK_CAMDBG_SEC_TYPE 0x7
+#define BIT_CAMDBG_SEC_TYPE(x)                                                 \
+	(((x) & BIT_MASK_CAMDBG_SEC_TYPE) << BIT_SHIFT_CAMDBG_SEC_TYPE)
+#define BIT_GET_CAMDBG_SEC_TYPE(x)                                             \
+	(((x) >> BIT_SHIFT_CAMDBG_SEC_TYPE) & BIT_MASK_CAMDBG_SEC_TYPE)
+
+/* 2 REG_CAMDBG				(Offset 0x067C) */
+
+#define BIT_CAMDBG_EXT_SECTYPE BIT(11)
+
+/* 2 REG_CAMDBG				(Offset 0x067C) */
+
+#define BIT_SHIFT_CAMDBG_MIC_KEY_IDX 5
+#define BIT_MASK_CAMDBG_MIC_KEY_IDX 0x1f
+#define BIT_CAMDBG_MIC_KEY_IDX(x)                                              \
+	(((x) & BIT_MASK_CAMDBG_MIC_KEY_IDX) << BIT_SHIFT_CAMDBG_MIC_KEY_IDX)
+#define BIT_GET_CAMDBG_MIC_KEY_IDX(x)                                          \
+	(((x) >> BIT_SHIFT_CAMDBG_MIC_KEY_IDX) & BIT_MASK_CAMDBG_MIC_KEY_IDX)
+
+#define BIT_SHIFT_CAMDBG_SEC_KEY_IDX 0
+#define BIT_MASK_CAMDBG_SEC_KEY_IDX 0x1f
+#define BIT_CAMDBG_SEC_KEY_IDX(x)                                              \
+	(((x) & BIT_MASK_CAMDBG_SEC_KEY_IDX) << BIT_SHIFT_CAMDBG_SEC_KEY_IDX)
+#define BIT_GET_CAMDBG_SEC_KEY_IDX(x)                                          \
+	(((x) >> BIT_SHIFT_CAMDBG_SEC_KEY_IDX) & BIT_MASK_CAMDBG_SEC_KEY_IDX)
+
+/* 2 REG_SECCFG				(Offset 0x0680) */
+
+#define BIT_DIS_GCLK_WAPI BIT(15)
+#define BIT_DIS_GCLK_AES BIT(14)
+#define BIT_DIS_GCLK_TKIP BIT(13)
+
+/* 2 REG_SECCFG				(Offset 0x0680) */
+
+#define BIT_AES_SEL_QC_1 BIT(12)
+#define BIT_AES_SEL_QC_0 BIT(11)
+
+/* 2 REG_SECCFG				(Offset 0x0680) */
+
+#define BIT_CHK_BMC BIT(9)
+
+/* 2 REG_SECCFG				(Offset 0x0680) */
+
+#define BIT_CHK_KEYID BIT(8)
+#define BIT_RXBCUSEDK BIT(7)
+#define BIT_TXBCUSEDK BIT(6)
+#define BIT_NOSKMC BIT(5)
+#define BIT_SKBYA2 BIT(4)
+#define BIT_RXDEC BIT(3)
+#define BIT_TXENC BIT(2)
+#define BIT_RXUHUSEDK BIT(1)
+#define BIT_TXUHUSEDK BIT(0)
+
+/* 2 REG_RXFILTER_CATEGORY_1			(Offset 0x0682) */
+
+#define BIT_SHIFT_RXFILTER_CATEGORY_1 0
+#define BIT_MASK_RXFILTER_CATEGORY_1 0xff
+#define BIT_RXFILTER_CATEGORY_1(x)                                             \
+	(((x) & BIT_MASK_RXFILTER_CATEGORY_1) << BIT_SHIFT_RXFILTER_CATEGORY_1)
+#define BIT_GET_RXFILTER_CATEGORY_1(x)                                         \
+	(((x) >> BIT_SHIFT_RXFILTER_CATEGORY_1) & BIT_MASK_RXFILTER_CATEGORY_1)
+
+/* 2 REG_RXFILTER_ACTION_1			(Offset 0x0683) */
+
+#define BIT_SHIFT_RXFILTER_ACTION_1 0
+#define BIT_MASK_RXFILTER_ACTION_1 0xff
+#define BIT_RXFILTER_ACTION_1(x)                                               \
+	(((x) & BIT_MASK_RXFILTER_ACTION_1) << BIT_SHIFT_RXFILTER_ACTION_1)
+#define BIT_GET_RXFILTER_ACTION_1(x)                                           \
+	(((x) >> BIT_SHIFT_RXFILTER_ACTION_1) & BIT_MASK_RXFILTER_ACTION_1)
+
+/* 2 REG_RXFILTER_CATEGORY_2			(Offset 0x0684) */
+
+#define BIT_SHIFT_RXFILTER_CATEGORY_2 0
+#define BIT_MASK_RXFILTER_CATEGORY_2 0xff
+#define BIT_RXFILTER_CATEGORY_2(x)                                             \
+	(((x) & BIT_MASK_RXFILTER_CATEGORY_2) << BIT_SHIFT_RXFILTER_CATEGORY_2)
+#define BIT_GET_RXFILTER_CATEGORY_2(x)                                         \
+	(((x) >> BIT_SHIFT_RXFILTER_CATEGORY_2) & BIT_MASK_RXFILTER_CATEGORY_2)
+
+/* 2 REG_RXFILTER_ACTION_2			(Offset 0x0685) */
+
+#define BIT_SHIFT_RXFILTER_ACTION_2 0
+#define BIT_MASK_RXFILTER_ACTION_2 0xff
+#define BIT_RXFILTER_ACTION_2(x)                                               \
+	(((x) & BIT_MASK_RXFILTER_ACTION_2) << BIT_SHIFT_RXFILTER_ACTION_2)
+#define BIT_GET_RXFILTER_ACTION_2(x)                                           \
+	(((x) >> BIT_SHIFT_RXFILTER_ACTION_2) & BIT_MASK_RXFILTER_ACTION_2)
+
+/* 2 REG_RXFILTER_CATEGORY_3			(Offset 0x0686) */
+
+#define BIT_SHIFT_RXFILTER_CATEGORY_3 0
+#define BIT_MASK_RXFILTER_CATEGORY_3 0xff
+#define BIT_RXFILTER_CATEGORY_3(x)                                             \
+	(((x) & BIT_MASK_RXFILTER_CATEGORY_3) << BIT_SHIFT_RXFILTER_CATEGORY_3)
+#define BIT_GET_RXFILTER_CATEGORY_3(x)                                         \
+	(((x) >> BIT_SHIFT_RXFILTER_CATEGORY_3) & BIT_MASK_RXFILTER_CATEGORY_3)
+
+/* 2 REG_RXFILTER_ACTION_3			(Offset 0x0687) */
+
+#define BIT_SHIFT_RXFILTER_ACTION_3 0
+#define BIT_MASK_RXFILTER_ACTION_3 0xff
+#define BIT_RXFILTER_ACTION_3(x)                                               \
+	(((x) & BIT_MASK_RXFILTER_ACTION_3) << BIT_SHIFT_RXFILTER_ACTION_3)
+#define BIT_GET_RXFILTER_ACTION_3(x)                                           \
+	(((x) >> BIT_SHIFT_RXFILTER_ACTION_3) & BIT_MASK_RXFILTER_ACTION_3)
+
+/* 2 REG_RXFLTMAP3				(Offset 0x0688) */
+
+#define BIT_MGTFLT15EN_FW BIT(15)
+#define BIT_MGTFLT14EN_FW BIT(14)
+#define BIT_MGTFLT13EN_FW BIT(13)
+#define BIT_MGTFLT12EN_FW BIT(12)
+#define BIT_MGTFLT11EN_FW BIT(11)
+#define BIT_MGTFLT10EN_FW BIT(10)
+#define BIT_MGTFLT9EN_FW BIT(9)
+#define BIT_MGTFLT8EN_FW BIT(8)
+#define BIT_MGTFLT7EN_FW BIT(7)
+#define BIT_MGTFLT6EN_FW BIT(6)
+#define BIT_MGTFLT5EN_FW BIT(5)
+#define BIT_MGTFLT4EN_FW BIT(4)
+#define BIT_MGTFLT3EN_FW BIT(3)
+#define BIT_MGTFLT2EN_FW BIT(2)
+#define BIT_MGTFLT1EN_FW BIT(1)
+#define BIT_MGTFLT0EN_FW BIT(0)
+
+/* 2 REG_RXFLTMAP4				(Offset 0x068A) */
+
+#define BIT_CTRLFLT15EN_FW BIT(15)
+#define BIT_CTRLFLT14EN_FW BIT(14)
+#define BIT_CTRLFLT13EN_FW BIT(13)
+#define BIT_CTRLFLT12EN_FW BIT(12)
+#define BIT_CTRLFLT11EN_FW BIT(11)
+#define BIT_CTRLFLT10EN_FW BIT(10)
+#define BIT_CTRLFLT9EN_FW BIT(9)
+#define BIT_CTRLFLT8EN_FW BIT(8)
+#define BIT_CTRLFLT7EN_FW BIT(7)
+#define BIT_CTRLFLT6EN_FW BIT(6)
+#define BIT_CTRLFLT5EN_FW BIT(5)
+#define BIT_CTRLFLT4EN_FW BIT(4)
+#define BIT_CTRLFLT3EN_FW BIT(3)
+#define BIT_CTRLFLT2EN_FW BIT(2)
+#define BIT_CTRLFLT1EN_FW BIT(1)
+#define BIT_CTRLFLT0EN_FW BIT(0)
+
+/* 2 REG_RXFLTMAP5				(Offset 0x068C) */
+
+#define BIT_DATAFLT15EN_FW BIT(15)
+#define BIT_DATAFLT14EN_FW BIT(14)
+#define BIT_DATAFLT13EN_FW BIT(13)
+#define BIT_DATAFLT12EN_FW BIT(12)
+#define BIT_DATAFLT11EN_FW BIT(11)
+#define BIT_DATAFLT10EN_FW BIT(10)
+#define BIT_DATAFLT9EN_FW BIT(9)
+#define BIT_DATAFLT8EN_FW BIT(8)
+#define BIT_DATAFLT7EN_FW BIT(7)
+#define BIT_DATAFLT6EN_FW BIT(6)
+#define BIT_DATAFLT5EN_FW BIT(5)
+#define BIT_DATAFLT4EN_FW BIT(4)
+#define BIT_DATAFLT3EN_FW BIT(3)
+#define BIT_DATAFLT2EN_FW BIT(2)
+#define BIT_DATAFLT1EN_FW BIT(1)
+#define BIT_DATAFLT0EN_FW BIT(0)
+
+/* 2 REG_RXFLTMAP6				(Offset 0x068E) */
+
+#define BIT_ACTIONFLT15EN_FW BIT(15)
+#define BIT_ACTIONFLT14EN_FW BIT(14)
+#define BIT_ACTIONFLT13EN_FW BIT(13)
+#define BIT_ACTIONFLT12EN_FW BIT(12)
+#define BIT_ACTIONFLT11EN_FW BIT(11)
+#define BIT_ACTIONFLT10EN_FW BIT(10)
+#define BIT_ACTIONFLT9EN_FW BIT(9)
+#define BIT_ACTIONFLT8EN_FW BIT(8)
+#define BIT_ACTIONFLT7EN_FW BIT(7)
+#define BIT_ACTIONFLT6EN_FW BIT(6)
+#define BIT_ACTIONFLT5EN_FW BIT(5)
+#define BIT_ACTIONFLT4EN_FW BIT(4)
+#define BIT_ACTIONFLT3EN_FW BIT(3)
+#define BIT_ACTIONFLT2EN_FW BIT(2)
+#define BIT_ACTIONFLT1EN_FW BIT(1)
+#define BIT_ACTIONFLT0EN_FW BIT(0)
+
+/* 2 REG_WOW_CTRL				(Offset 0x0690) */
+
+#define BIT_SHIFT_PSF_BSSIDSEL_B2B1 6
+#define BIT_MASK_PSF_BSSIDSEL_B2B1 0x3
+#define BIT_PSF_BSSIDSEL_B2B1(x)                                               \
+	(((x) & BIT_MASK_PSF_BSSIDSEL_B2B1) << BIT_SHIFT_PSF_BSSIDSEL_B2B1)
+#define BIT_GET_PSF_BSSIDSEL_B2B1(x)                                           \
+	(((x) >> BIT_SHIFT_PSF_BSSIDSEL_B2B1) & BIT_MASK_PSF_BSSIDSEL_B2B1)
+
+/* 2 REG_WOW_CTRL				(Offset 0x0690) */
+
+#define BIT_WOWHCI BIT(5)
+
+/* 2 REG_WOW_CTRL				(Offset 0x0690) */
+
+#define BIT_PSF_BSSIDSEL_B0 BIT(4)
+
+/* 2 REG_WOW_CTRL				(Offset 0x0690) */
+
+#define BIT_UWF BIT(3)
+#define BIT_MAGIC BIT(2)
+#define BIT_WOWEN BIT(1)
+#define BIT_FORCE_WAKEUP BIT(0)
+
+/* 2 REG_NAN_RX_TSF_FILTER			(Offset 0x0691) */
+
+#define BIT_CHK_TSF_TA BIT(2)
+#define BIT_CHK_TSF_CBSSID BIT(1)
+#define BIT_CHK_TSF_EN BIT(0)
+
+/* 2 REG_PS_RX_INFO				(Offset 0x0692) */
+
+#define BIT_SHIFT_PORTSEL__PS_RX_INFO 5
+#define BIT_MASK_PORTSEL__PS_RX_INFO 0x7
+#define BIT_PORTSEL__PS_RX_INFO(x)                                             \
+	(((x) & BIT_MASK_PORTSEL__PS_RX_INFO) << BIT_SHIFT_PORTSEL__PS_RX_INFO)
+#define BIT_GET_PORTSEL__PS_RX_INFO(x)                                         \
+	(((x) >> BIT_SHIFT_PORTSEL__PS_RX_INFO) & BIT_MASK_PORTSEL__PS_RX_INFO)
+
+/* 2 REG_PS_RX_INFO				(Offset 0x0692) */
+
+#define BIT_RXCTRLIN0 BIT(4)
+#define BIT_RXMGTIN0 BIT(3)
+#define BIT_RXDATAIN2 BIT(2)
+#define BIT_RXDATAIN1 BIT(1)
+#define BIT_RXDATAIN0 BIT(0)
+
+/* 2 REG_WMMPS_UAPSD_TID			(Offset 0x0693) */
+
+#define BIT_WMMPS_UAPSD_TID7 BIT(7)
+#define BIT_WMMPS_UAPSD_TID6 BIT(6)
+#define BIT_WMMPS_UAPSD_TID5 BIT(5)
+#define BIT_WMMPS_UAPSD_TID4 BIT(4)
+#define BIT_WMMPS_UAPSD_TID3 BIT(3)
+#define BIT_WMMPS_UAPSD_TID2 BIT(2)
+#define BIT_WMMPS_UAPSD_TID1 BIT(1)
+#define BIT_WMMPS_UAPSD_TID0 BIT(0)
+
+/* 2 REG_LPNAV_CTRL				(Offset 0x0694) */
+
+#define BIT_LPNAV_EN BIT(31)
+
+#define BIT_SHIFT_LPNAV_EARLY 16
+#define BIT_MASK_LPNAV_EARLY 0x7fff
+#define BIT_LPNAV_EARLY(x)                                                     \
+	(((x) & BIT_MASK_LPNAV_EARLY) << BIT_SHIFT_LPNAV_EARLY)
+#define BIT_GET_LPNAV_EARLY(x)                                                 \
+	(((x) >> BIT_SHIFT_LPNAV_EARLY) & BIT_MASK_LPNAV_EARLY)
+
+#define BIT_SHIFT_LPNAV_TH 0
+#define BIT_MASK_LPNAV_TH 0xffff
+#define BIT_LPNAV_TH(x) (((x) & BIT_MASK_LPNAV_TH) << BIT_SHIFT_LPNAV_TH)
+#define BIT_GET_LPNAV_TH(x) (((x) >> BIT_SHIFT_LPNAV_TH) & BIT_MASK_LPNAV_TH)
+
+/* 2 REG_WKFMCAM_CMD				(Offset 0x0698) */
+
+#define BIT_WKFCAM_POLLING_V1 BIT(31)
+#define BIT_WKFCAM_CLR_V1 BIT(30)
+
+/* 2 REG_WKFMCAM_CMD				(Offset 0x0698) */
+
+#define BIT_WKFCAM_WE BIT(16)
+
+/* 2 REG_WKFMCAM_CMD				(Offset 0x0698) */
+
+#define BIT_SHIFT_WKFCAM_ADDR_V2 8
+#define BIT_MASK_WKFCAM_ADDR_V2 0xff
+#define BIT_WKFCAM_ADDR_V2(x)                                                  \
+	(((x) & BIT_MASK_WKFCAM_ADDR_V2) << BIT_SHIFT_WKFCAM_ADDR_V2)
+#define BIT_GET_WKFCAM_ADDR_V2(x)                                              \
+	(((x) >> BIT_SHIFT_WKFCAM_ADDR_V2) & BIT_MASK_WKFCAM_ADDR_V2)
+
+#define BIT_SHIFT_WKFCAM_CAM_NUM_V1 0
+#define BIT_MASK_WKFCAM_CAM_NUM_V1 0xff
+#define BIT_WKFCAM_CAM_NUM_V1(x)                                               \
+	(((x) & BIT_MASK_WKFCAM_CAM_NUM_V1) << BIT_SHIFT_WKFCAM_CAM_NUM_V1)
+#define BIT_GET_WKFCAM_CAM_NUM_V1(x)                                           \
+	(((x) >> BIT_SHIFT_WKFCAM_CAM_NUM_V1) & BIT_MASK_WKFCAM_CAM_NUM_V1)
+
+/* 2 REG_WKFMCAM_RWD				(Offset 0x069C) */
+
+#define BIT_SHIFT_WKFMCAM_RWD 0
+#define BIT_MASK_WKFMCAM_RWD 0xffffffffL
+#define BIT_WKFMCAM_RWD(x)                                                     \
+	(((x) & BIT_MASK_WKFMCAM_RWD) << BIT_SHIFT_WKFMCAM_RWD)
+#define BIT_GET_WKFMCAM_RWD(x)                                                 \
+	(((x) >> BIT_SHIFT_WKFMCAM_RWD) & BIT_MASK_WKFMCAM_RWD)
+
+/* 2 REG_RXFLTMAP0				(Offset 0x06A0) */
+
+#define BIT_MGTFLT15EN BIT(15)
+#define BIT_MGTFLT14EN BIT(14)
+
+/* 2 REG_RXFLTMAP0				(Offset 0x06A0) */
+
+#define BIT_MGTFLT13EN BIT(13)
+#define BIT_MGTFLT12EN BIT(12)
+#define BIT_MGTFLT11EN BIT(11)
+#define BIT_MGTFLT10EN BIT(10)
+#define BIT_MGTFLT9EN BIT(9)
+#define BIT_MGTFLT8EN BIT(8)
+
+/* 2 REG_RXFLTMAP0				(Offset 0x06A0) */
+
+#define BIT_MGTFLT7EN BIT(7)
+#define BIT_MGTFLT6EN BIT(6)
+
+/* 2 REG_RXFLTMAP0				(Offset 0x06A0) */
+
+#define BIT_MGTFLT5EN BIT(5)
+#define BIT_MGTFLT4EN BIT(4)
+#define BIT_MGTFLT3EN BIT(3)
+#define BIT_MGTFLT2EN BIT(2)
+#define BIT_MGTFLT1EN BIT(1)
+#define BIT_MGTFLT0EN BIT(0)
+
+/* 2 REG_RXFLTMAP1				(Offset 0x06A2) */
+
+#define BIT_CTRLFLT15EN BIT(15)
+#define BIT_CTRLFLT14EN BIT(14)
+#define BIT_CTRLFLT13EN BIT(13)
+#define BIT_CTRLFLT12EN BIT(12)
+#define BIT_CTRLFLT11EN BIT(11)
+#define BIT_CTRLFLT10EN BIT(10)
+#define BIT_CTRLFLT9EN BIT(9)
+#define BIT_CTRLFLT8EN BIT(8)
+#define BIT_CTRLFLT7EN BIT(7)
+#define BIT_CTRLFLT6EN BIT(6)
+
+/* 2 REG_RXFLTMAP1				(Offset 0x06A2) */
+
+#define BIT_CTRLFLT5EN BIT(5)
+#define BIT_CTRLFLT4EN BIT(4)
+#define BIT_CTRLFLT3EN BIT(3)
+#define BIT_CTRLFLT2EN BIT(2)
+#define BIT_CTRLFLT1EN BIT(1)
+#define BIT_CTRLFLT0EN BIT(0)
+
+/* 2 REG_RXFLTMAP				(Offset 0x06A4) */
+
+#define BIT_DATAFLT15EN BIT(15)
+#define BIT_DATAFLT14EN BIT(14)
+#define BIT_DATAFLT13EN BIT(13)
+#define BIT_DATAFLT12EN BIT(12)
+#define BIT_DATAFLT11EN BIT(11)
+#define BIT_DATAFLT10EN BIT(10)
+#define BIT_DATAFLT9EN BIT(9)
+#define BIT_DATAFLT8EN BIT(8)
+#define BIT_DATAFLT7EN BIT(7)
+#define BIT_DATAFLT6EN BIT(6)
+#define BIT_DATAFLT5EN BIT(5)
+#define BIT_DATAFLT4EN BIT(4)
+#define BIT_DATAFLT3EN BIT(3)
+#define BIT_DATAFLT2EN BIT(2)
+#define BIT_DATAFLT1EN BIT(1)
+#define BIT_DATAFLT0EN BIT(0)
+
+/* 2 REG_BCN_PSR_RPT				(Offset 0x06A8) */
+
+#define BIT_SHIFT_DTIM_CNT 24
+#define BIT_MASK_DTIM_CNT 0xff
+#define BIT_DTIM_CNT(x) (((x) & BIT_MASK_DTIM_CNT) << BIT_SHIFT_DTIM_CNT)
+#define BIT_GET_DTIM_CNT(x) (((x) >> BIT_SHIFT_DTIM_CNT) & BIT_MASK_DTIM_CNT)
+
+#define BIT_SHIFT_DTIM_PERIOD 16
+#define BIT_MASK_DTIM_PERIOD 0xff
+#define BIT_DTIM_PERIOD(x)                                                     \
+	(((x) & BIT_MASK_DTIM_PERIOD) << BIT_SHIFT_DTIM_PERIOD)
+#define BIT_GET_DTIM_PERIOD(x)                                                 \
+	(((x) >> BIT_SHIFT_DTIM_PERIOD) & BIT_MASK_DTIM_PERIOD)
+
+#define BIT_DTIM BIT(15)
+#define BIT_TIM BIT(14)
+
+#define BIT_SHIFT_PS_AID_0 0
+#define BIT_MASK_PS_AID_0 0x7ff
+#define BIT_PS_AID_0(x) (((x) & BIT_MASK_PS_AID_0) << BIT_SHIFT_PS_AID_0)
+#define BIT_GET_PS_AID_0(x) (((x) >> BIT_SHIFT_PS_AID_0) & BIT_MASK_PS_AID_0)
+
+/* 2 REG_FLC_RPC				(Offset 0x06AC) */
+
+#define BIT_SHIFT_FLC_RPC 0
+#define BIT_MASK_FLC_RPC 0xff
+#define BIT_FLC_RPC(x) (((x) & BIT_MASK_FLC_RPC) << BIT_SHIFT_FLC_RPC)
+#define BIT_GET_FLC_RPC(x) (((x) >> BIT_SHIFT_FLC_RPC) & BIT_MASK_FLC_RPC)
+
+/* 2 REG_FLC_RPCT				(Offset 0x06AD) */
+
+#define BIT_SHIFT_FLC_RPCT 0
+#define BIT_MASK_FLC_RPCT 0xff
+#define BIT_FLC_RPCT(x) (((x) & BIT_MASK_FLC_RPCT) << BIT_SHIFT_FLC_RPCT)
+#define BIT_GET_FLC_RPCT(x) (((x) >> BIT_SHIFT_FLC_RPCT) & BIT_MASK_FLC_RPCT)
+
+/* 2 REG_FLC_PTS				(Offset 0x06AE) */
+
+#define BIT_CMF BIT(2)
+#define BIT_CCF BIT(1)
+#define BIT_CDF BIT(0)
+
+/* 2 REG_FLC_TRPC				(Offset 0x06AF) */
+
+#define BIT_FLC_RPCT_V1 BIT(7)
+#define BIT_MODE BIT(6)
+
+#define BIT_SHIFT_TRPCD 0
+#define BIT_MASK_TRPCD 0x3f
+#define BIT_TRPCD(x) (((x) & BIT_MASK_TRPCD) << BIT_SHIFT_TRPCD)
+#define BIT_GET_TRPCD(x) (((x) >> BIT_SHIFT_TRPCD) & BIT_MASK_TRPCD)
+
+/* 2 REG_RXPKTMON_CTRL			(Offset 0x06B0) */
+
+#define BIT_SHIFT_RXBKQPKT_SEQ 20
+#define BIT_MASK_RXBKQPKT_SEQ 0xf
+#define BIT_RXBKQPKT_SEQ(x)                                                    \
+	(((x) & BIT_MASK_RXBKQPKT_SEQ) << BIT_SHIFT_RXBKQPKT_SEQ)
+#define BIT_GET_RXBKQPKT_SEQ(x)                                                \
+	(((x) >> BIT_SHIFT_RXBKQPKT_SEQ) & BIT_MASK_RXBKQPKT_SEQ)
+
+#define BIT_SHIFT_RXBEQPKT_SEQ 16
+#define BIT_MASK_RXBEQPKT_SEQ 0xf
+#define BIT_RXBEQPKT_SEQ(x)                                                    \
+	(((x) & BIT_MASK_RXBEQPKT_SEQ) << BIT_SHIFT_RXBEQPKT_SEQ)
+#define BIT_GET_RXBEQPKT_SEQ(x)                                                \
+	(((x) >> BIT_SHIFT_RXBEQPKT_SEQ) & BIT_MASK_RXBEQPKT_SEQ)
+
+#define BIT_SHIFT_RXVIQPKT_SEQ 12
+#define BIT_MASK_RXVIQPKT_SEQ 0xf
+#define BIT_RXVIQPKT_SEQ(x)                                                    \
+	(((x) & BIT_MASK_RXVIQPKT_SEQ) << BIT_SHIFT_RXVIQPKT_SEQ)
+#define BIT_GET_RXVIQPKT_SEQ(x)                                                \
+	(((x) >> BIT_SHIFT_RXVIQPKT_SEQ) & BIT_MASK_RXVIQPKT_SEQ)
+
+#define BIT_SHIFT_RXVOQPKT_SEQ 8
+#define BIT_MASK_RXVOQPKT_SEQ 0xf
+#define BIT_RXVOQPKT_SEQ(x)                                                    \
+	(((x) & BIT_MASK_RXVOQPKT_SEQ) << BIT_SHIFT_RXVOQPKT_SEQ)
+#define BIT_GET_RXVOQPKT_SEQ(x)                                                \
+	(((x) >> BIT_SHIFT_RXVOQPKT_SEQ) & BIT_MASK_RXVOQPKT_SEQ)
+
+#define BIT_RXBKQPKT_ERR BIT(7)
+#define BIT_RXBEQPKT_ERR BIT(6)
+#define BIT_RXVIQPKT_ERR BIT(5)
+#define BIT_RXVOQPKT_ERR BIT(4)
+#define BIT_RXDMA_MON_EN BIT(2)
+#define BIT_RXPKT_MON_RST BIT(1)
+#define BIT_RXPKT_MON_EN BIT(0)
+
+/* 2 REG_STATE_MON				(Offset 0x06B4) */
+
+#define BIT_SHIFT_STATE_SEL 24
+#define BIT_MASK_STATE_SEL 0x1f
+#define BIT_STATE_SEL(x) (((x) & BIT_MASK_STATE_SEL) << BIT_SHIFT_STATE_SEL)
+#define BIT_GET_STATE_SEL(x) (((x) >> BIT_SHIFT_STATE_SEL) & BIT_MASK_STATE_SEL)
+
+#define BIT_SHIFT_STATE_INFO 8
+#define BIT_MASK_STATE_INFO 0xff
+#define BIT_STATE_INFO(x) (((x) & BIT_MASK_STATE_INFO) << BIT_SHIFT_STATE_INFO)
+#define BIT_GET_STATE_INFO(x)                                                  \
+	(((x) >> BIT_SHIFT_STATE_INFO) & BIT_MASK_STATE_INFO)
+
+#define BIT_UPD_NXT_STATE BIT(7)
+
+/* 2 REG_STATE_MON				(Offset 0x06B4) */
+
+#define BIT_SHIFT_CUR_STATE 0
+#define BIT_MASK_CUR_STATE 0x7f
+#define BIT_CUR_STATE(x) (((x) & BIT_MASK_CUR_STATE) << BIT_SHIFT_CUR_STATE)
+#define BIT_GET_CUR_STATE(x) (((x) >> BIT_SHIFT_CUR_STATE) & BIT_MASK_CUR_STATE)
+
+/* 2 REG_ERROR_MON				(Offset 0x06B8) */
+
+#define BIT_MACRX_ERR_1 BIT(17)
+#define BIT_MACRX_ERR_0 BIT(16)
+#define BIT_MACTX_ERR_3 BIT(3)
+#define BIT_MACTX_ERR_2 BIT(2)
+#define BIT_MACTX_ERR_1 BIT(1)
+#define BIT_MACTX_ERR_0 BIT(0)
+
+/* 2 REG_SEARCH_MACID			(Offset 0x06BC) */
+
+#define BIT_EN_TXRPTBUF_CLK BIT(31)
+
+#define BIT_SHIFT_INFO_INDEX_OFFSET 16
+#define BIT_MASK_INFO_INDEX_OFFSET 0x1fff
+#define BIT_INFO_INDEX_OFFSET(x)                                               \
+	(((x) & BIT_MASK_INFO_INDEX_OFFSET) << BIT_SHIFT_INFO_INDEX_OFFSET)
+#define BIT_GET_INFO_INDEX_OFFSET(x)                                           \
+	(((x) >> BIT_SHIFT_INFO_INDEX_OFFSET) & BIT_MASK_INFO_INDEX_OFFSET)
+
+/* 2 REG_SEARCH_MACID			(Offset 0x06BC) */
+
+#define BIT_WMAC_SRCH_FIFOFULL BIT(15)
+
+/* 2 REG_SEARCH_MACID			(Offset 0x06BC) */
+
+#define BIT_DIS_INFOSRCH BIT(14)
+#define BIT_DISABLE_B0 BIT(13)
+
+#define BIT_SHIFT_INFO_ADDR_OFFSET 0
+#define BIT_MASK_INFO_ADDR_OFFSET 0x1fff
+#define BIT_INFO_ADDR_OFFSET(x)                                                \
+	(((x) & BIT_MASK_INFO_ADDR_OFFSET) << BIT_SHIFT_INFO_ADDR_OFFSET)
+#define BIT_GET_INFO_ADDR_OFFSET(x)                                            \
+	(((x) >> BIT_SHIFT_INFO_ADDR_OFFSET) & BIT_MASK_INFO_ADDR_OFFSET)
+
+/* 2 REG_BT_COEX_TABLE			(Offset 0x06C0) */
+
+#define BIT_PRI_MASK_RX_RESP BIT(126)
+#define BIT_PRI_MASK_RXOFDM BIT(125)
+#define BIT_PRI_MASK_RXCCK BIT(124)
+
+#define BIT_SHIFT_PRI_MASK_TXAC (117 & CPU_OPT_WIDTH)
+#define BIT_MASK_PRI_MASK_TXAC 0x7f
+#define BIT_PRI_MASK_TXAC(x)                                                   \
+	(((x) & BIT_MASK_PRI_MASK_TXAC) << BIT_SHIFT_PRI_MASK_TXAC)
+#define BIT_GET_PRI_MASK_TXAC(x)                                               \
+	(((x) >> BIT_SHIFT_PRI_MASK_TXAC) & BIT_MASK_PRI_MASK_TXAC)
+
+#define BIT_SHIFT_PRI_MASK_NAV (109 & CPU_OPT_WIDTH)
+#define BIT_MASK_PRI_MASK_NAV 0xff
+#define BIT_PRI_MASK_NAV(x)                                                    \
+	(((x) & BIT_MASK_PRI_MASK_NAV) << BIT_SHIFT_PRI_MASK_NAV)
+#define BIT_GET_PRI_MASK_NAV(x)                                                \
+	(((x) >> BIT_SHIFT_PRI_MASK_NAV) & BIT_MASK_PRI_MASK_NAV)
+
+#define BIT_PRI_MASK_CCK BIT(108)
+#define BIT_PRI_MASK_OFDM BIT(107)
+#define BIT_PRI_MASK_RTY BIT(106)
+
+#define BIT_SHIFT_PRI_MASK_NUM (102 & CPU_OPT_WIDTH)
+#define BIT_MASK_PRI_MASK_NUM 0xf
+#define BIT_PRI_MASK_NUM(x)                                                    \
+	(((x) & BIT_MASK_PRI_MASK_NUM) << BIT_SHIFT_PRI_MASK_NUM)
+#define BIT_GET_PRI_MASK_NUM(x)                                                \
+	(((x) >> BIT_SHIFT_PRI_MASK_NUM) & BIT_MASK_PRI_MASK_NUM)
+
+#define BIT_SHIFT_PRI_MASK_TYPE (98 & CPU_OPT_WIDTH)
+#define BIT_MASK_PRI_MASK_TYPE 0xf
+#define BIT_PRI_MASK_TYPE(x)                                                   \
+	(((x) & BIT_MASK_PRI_MASK_TYPE) << BIT_SHIFT_PRI_MASK_TYPE)
+#define BIT_GET_PRI_MASK_TYPE(x)                                               \
+	(((x) >> BIT_SHIFT_PRI_MASK_TYPE) & BIT_MASK_PRI_MASK_TYPE)
+
+#define BIT_OOB BIT(97)
+#define BIT_ANT_SEL BIT(96)
+
+#define BIT_SHIFT_BREAK_TABLE_2 (80 & CPU_OPT_WIDTH)
+#define BIT_MASK_BREAK_TABLE_2 0xffff
+#define BIT_BREAK_TABLE_2(x)                                                   \
+	(((x) & BIT_MASK_BREAK_TABLE_2) << BIT_SHIFT_BREAK_TABLE_2)
+#define BIT_GET_BREAK_TABLE_2(x)                                               \
+	(((x) >> BIT_SHIFT_BREAK_TABLE_2) & BIT_MASK_BREAK_TABLE_2)
+
+#define BIT_SHIFT_BREAK_TABLE_1 (64 & CPU_OPT_WIDTH)
+#define BIT_MASK_BREAK_TABLE_1 0xffff
+#define BIT_BREAK_TABLE_1(x)                                                   \
+	(((x) & BIT_MASK_BREAK_TABLE_1) << BIT_SHIFT_BREAK_TABLE_1)
+#define BIT_GET_BREAK_TABLE_1(x)                                               \
+	(((x) >> BIT_SHIFT_BREAK_TABLE_1) & BIT_MASK_BREAK_TABLE_1)
+
+#define BIT_SHIFT_COEX_TABLE_2 (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_COEX_TABLE_2 0xffffffffL
+#define BIT_COEX_TABLE_2(x)                                                    \
+	(((x) & BIT_MASK_COEX_TABLE_2) << BIT_SHIFT_COEX_TABLE_2)
+#define BIT_GET_COEX_TABLE_2(x)                                                \
+	(((x) >> BIT_SHIFT_COEX_TABLE_2) & BIT_MASK_COEX_TABLE_2)
+
+#define BIT_SHIFT_COEX_TABLE_1 0
+#define BIT_MASK_COEX_TABLE_1 0xffffffffL
+#define BIT_COEX_TABLE_1(x)                                                    \
+	(((x) & BIT_MASK_COEX_TABLE_1) << BIT_SHIFT_COEX_TABLE_1)
+#define BIT_GET_COEX_TABLE_1(x)                                                \
+	(((x) >> BIT_SHIFT_COEX_TABLE_1) & BIT_MASK_COEX_TABLE_1)
+
+/* 2 REG_RXCMD_0				(Offset 0x06D0) */
+
+#define BIT_RXCMD_EN BIT(31)
+
+#define BIT_SHIFT_RXCMD_INFO 0
+#define BIT_MASK_RXCMD_INFO 0x7fffffffL
+#define BIT_RXCMD_INFO(x) (((x) & BIT_MASK_RXCMD_INFO) << BIT_SHIFT_RXCMD_INFO)
+#define BIT_GET_RXCMD_INFO(x)                                                  \
+	(((x) >> BIT_SHIFT_RXCMD_INFO) & BIT_MASK_RXCMD_INFO)
+
+/* 2 REG_RXCMD_1				(Offset 0x06D4) */
+
+#define BIT_SHIFT_RXCMD_PRD 0
+#define BIT_MASK_RXCMD_PRD 0xffff
+#define BIT_RXCMD_PRD(x) (((x) & BIT_MASK_RXCMD_PRD) << BIT_SHIFT_RXCMD_PRD)
+#define BIT_GET_RXCMD_PRD(x) (((x) >> BIT_SHIFT_RXCMD_PRD) & BIT_MASK_RXCMD_PRD)
+
+/* 2 REG_WMAC_RESP_TXINFO			(Offset 0x06D8) */
+
+#define BIT_SHIFT_WMAC_RESP_MFB 25
+#define BIT_MASK_WMAC_RESP_MFB 0x7f
+#define BIT_WMAC_RESP_MFB(x)                                                   \
+	(((x) & BIT_MASK_WMAC_RESP_MFB) << BIT_SHIFT_WMAC_RESP_MFB)
+#define BIT_GET_WMAC_RESP_MFB(x)                                               \
+	(((x) >> BIT_SHIFT_WMAC_RESP_MFB) & BIT_MASK_WMAC_RESP_MFB)
+
+#define BIT_SHIFT_WMAC_ANTINF_SEL 23
+#define BIT_MASK_WMAC_ANTINF_SEL 0x3
+#define BIT_WMAC_ANTINF_SEL(x)                                                 \
+	(((x) & BIT_MASK_WMAC_ANTINF_SEL) << BIT_SHIFT_WMAC_ANTINF_SEL)
+#define BIT_GET_WMAC_ANTINF_SEL(x)                                             \
+	(((x) >> BIT_SHIFT_WMAC_ANTINF_SEL) & BIT_MASK_WMAC_ANTINF_SEL)
+
+#define BIT_SHIFT_WMAC_ANTSEL_SEL 21
+#define BIT_MASK_WMAC_ANTSEL_SEL 0x3
+#define BIT_WMAC_ANTSEL_SEL(x)                                                 \
+	(((x) & BIT_MASK_WMAC_ANTSEL_SEL) << BIT_SHIFT_WMAC_ANTSEL_SEL)
+#define BIT_GET_WMAC_ANTSEL_SEL(x)                                             \
+	(((x) >> BIT_SHIFT_WMAC_ANTSEL_SEL) & BIT_MASK_WMAC_ANTSEL_SEL)
+
+/* 2 REG_WMAC_RESP_TXINFO			(Offset 0x06D8) */
+
+#define BIT_SHIFT_R_WMAC_RESP_TXPOWER 18
+#define BIT_MASK_R_WMAC_RESP_TXPOWER 0x7
+#define BIT_R_WMAC_RESP_TXPOWER(x)                                             \
+	(((x) & BIT_MASK_R_WMAC_RESP_TXPOWER) << BIT_SHIFT_R_WMAC_RESP_TXPOWER)
+#define BIT_GET_R_WMAC_RESP_TXPOWER(x)                                         \
+	(((x) >> BIT_SHIFT_R_WMAC_RESP_TXPOWER) & BIT_MASK_R_WMAC_RESP_TXPOWER)
+
+/* 2 REG_WMAC_RESP_TXINFO			(Offset 0x06D8) */
+
+#define BIT_SHIFT_WMAC_RESP_TXANT 0
+#define BIT_MASK_WMAC_RESP_TXANT 0x3ffff
+#define BIT_WMAC_RESP_TXANT(x)                                                 \
+	(((x) & BIT_MASK_WMAC_RESP_TXANT) << BIT_SHIFT_WMAC_RESP_TXANT)
+#define BIT_GET_WMAC_RESP_TXANT(x)                                             \
+	(((x) >> BIT_SHIFT_WMAC_RESP_TXANT) & BIT_MASK_WMAC_RESP_TXANT)
+
+/* 2 REG_BBPSF_CTRL				(Offset 0x06DC) */
+
+#define BIT_CTL_IDLE_CLR_CSI_RPT BIT(31)
+
+/* 2 REG_BBPSF_CTRL				(Offset 0x06DC) */
+
+#define BIT_WMAC_USE_NDPARATE BIT(30)
+
+#define BIT_SHIFT_WMAC_CSI_RATE 24
+#define BIT_MASK_WMAC_CSI_RATE 0x3f
+#define BIT_WMAC_CSI_RATE(x)                                                   \
+	(((x) & BIT_MASK_WMAC_CSI_RATE) << BIT_SHIFT_WMAC_CSI_RATE)
+#define BIT_GET_WMAC_CSI_RATE(x)                                               \
+	(((x) >> BIT_SHIFT_WMAC_CSI_RATE) & BIT_MASK_WMAC_CSI_RATE)
+
+#define BIT_SHIFT_WMAC_RESP_TXRATE 16
+#define BIT_MASK_WMAC_RESP_TXRATE 0xff
+#define BIT_WMAC_RESP_TXRATE(x)                                                \
+	(((x) & BIT_MASK_WMAC_RESP_TXRATE) << BIT_SHIFT_WMAC_RESP_TXRATE)
+#define BIT_GET_WMAC_RESP_TXRATE(x)                                            \
+	(((x) >> BIT_SHIFT_WMAC_RESP_TXRATE) & BIT_MASK_WMAC_RESP_TXRATE)
+
+/* 2 REG_BBPSF_CTRL				(Offset 0x06DC) */
+
+#define BIT_BBPSF_MPDUCHKEN BIT(5)
+
+/* 2 REG_BBPSF_CTRL				(Offset 0x06DC) */
+
+#define BIT_BBPSF_MHCHKEN BIT(4)
+#define BIT_BBPSF_ERRCHKEN BIT(3)
+
+#define BIT_SHIFT_BBPSF_ERRTHR 0
+#define BIT_MASK_BBPSF_ERRTHR 0x7
+#define BIT_BBPSF_ERRTHR(x)                                                    \
+	(((x) & BIT_MASK_BBPSF_ERRTHR) << BIT_SHIFT_BBPSF_ERRTHR)
+#define BIT_GET_BBPSF_ERRTHR(x)                                                \
+	(((x) >> BIT_SHIFT_BBPSF_ERRTHR) & BIT_MASK_BBPSF_ERRTHR)
+
+/* 2 REG_P2P_RX_BCN_NOA			(Offset 0x06E0) */
+
+#define BIT_NOA_PARSER_EN BIT(15)
+
+/* 2 REG_P2P_RX_BCN_NOA			(Offset 0x06E0) */
+
+#define BIT_BSSID_SEL BIT(14)
+
+/* 2 REG_P2P_RX_BCN_NOA			(Offset 0x06E0) */
+
+#define BIT_SHIFT_P2P_OUI_TYPE 0
+#define BIT_MASK_P2P_OUI_TYPE 0xff
+#define BIT_P2P_OUI_TYPE(x)                                                    \
+	(((x) & BIT_MASK_P2P_OUI_TYPE) << BIT_SHIFT_P2P_OUI_TYPE)
+#define BIT_GET_P2P_OUI_TYPE(x)                                                \
+	(((x) >> BIT_SHIFT_P2P_OUI_TYPE) & BIT_MASK_P2P_OUI_TYPE)
+
+/* 2 REG_ASSOCIATED_BFMER0_INFO		(Offset 0x06E4) */
+
+#define BIT_SHIFT_R_WMAC_TXCSI_AID0 (48 & CPU_OPT_WIDTH)
+#define BIT_MASK_R_WMAC_TXCSI_AID0 0x1ff
+#define BIT_R_WMAC_TXCSI_AID0(x)                                               \
+	(((x) & BIT_MASK_R_WMAC_TXCSI_AID0) << BIT_SHIFT_R_WMAC_TXCSI_AID0)
+#define BIT_GET_R_WMAC_TXCSI_AID0(x)                                           \
+	(((x) >> BIT_SHIFT_R_WMAC_TXCSI_AID0) & BIT_MASK_R_WMAC_TXCSI_AID0)
+
+#define BIT_SHIFT_R_WMAC_SOUNDING_RXADD_R0 0
+#define BIT_MASK_R_WMAC_SOUNDING_RXADD_R0 0xffffffffffffL
+#define BIT_R_WMAC_SOUNDING_RXADD_R0(x)                                        \
+	(((x) & BIT_MASK_R_WMAC_SOUNDING_RXADD_R0)                             \
+	 << BIT_SHIFT_R_WMAC_SOUNDING_RXADD_R0)
+#define BIT_GET_R_WMAC_SOUNDING_RXADD_R0(x)                                    \
+	(((x) >> BIT_SHIFT_R_WMAC_SOUNDING_RXADD_R0) &                         \
+	 BIT_MASK_R_WMAC_SOUNDING_RXADD_R0)
+
+/* 2 REG_ASSOCIATED_BFMER1_INFO		(Offset 0x06EC) */
+
+#define BIT_SHIFT_R_WMAC_TXCSI_AID1 (48 & CPU_OPT_WIDTH)
+#define BIT_MASK_R_WMAC_TXCSI_AID1 0x1ff
+#define BIT_R_WMAC_TXCSI_AID1(x)                                               \
+	(((x) & BIT_MASK_R_WMAC_TXCSI_AID1) << BIT_SHIFT_R_WMAC_TXCSI_AID1)
+#define BIT_GET_R_WMAC_TXCSI_AID1(x)                                           \
+	(((x) >> BIT_SHIFT_R_WMAC_TXCSI_AID1) & BIT_MASK_R_WMAC_TXCSI_AID1)
+
+#define BIT_SHIFT_R_WMAC_SOUNDING_RXADD_R1 0
+#define BIT_MASK_R_WMAC_SOUNDING_RXADD_R1 0xffffffffffffL
+#define BIT_R_WMAC_SOUNDING_RXADD_R1(x)                                        \
+	(((x) & BIT_MASK_R_WMAC_SOUNDING_RXADD_R1)                             \
+	 << BIT_SHIFT_R_WMAC_SOUNDING_RXADD_R1)
+#define BIT_GET_R_WMAC_SOUNDING_RXADD_R1(x)                                    \
+	(((x) >> BIT_SHIFT_R_WMAC_SOUNDING_RXADD_R1) &                         \
+	 BIT_MASK_R_WMAC_SOUNDING_RXADD_R1)
+
+/* 2 REG_TX_CSI_RPT_PARAM_BW20		(Offset 0x06F4) */
+
+#define BIT_SHIFT_R_WMAC_BFINFO_20M_1 16
+#define BIT_MASK_R_WMAC_BFINFO_20M_1 0xfff
+#define BIT_R_WMAC_BFINFO_20M_1(x)                                             \
+	(((x) & BIT_MASK_R_WMAC_BFINFO_20M_1) << BIT_SHIFT_R_WMAC_BFINFO_20M_1)
+#define BIT_GET_R_WMAC_BFINFO_20M_1(x)                                         \
+	(((x) >> BIT_SHIFT_R_WMAC_BFINFO_20M_1) & BIT_MASK_R_WMAC_BFINFO_20M_1)
+
+#define BIT_SHIFT_R_WMAC_BFINFO_20M_0 0
+#define BIT_MASK_R_WMAC_BFINFO_20M_0 0xfff
+#define BIT_R_WMAC_BFINFO_20M_0(x)                                             \
+	(((x) & BIT_MASK_R_WMAC_BFINFO_20M_0) << BIT_SHIFT_R_WMAC_BFINFO_20M_0)
+#define BIT_GET_R_WMAC_BFINFO_20M_0(x)                                         \
+	(((x) >> BIT_SHIFT_R_WMAC_BFINFO_20M_0) & BIT_MASK_R_WMAC_BFINFO_20M_0)
+
+/* 2 REG_TX_CSI_RPT_PARAM_BW40		(Offset 0x06F8) */
+
+#define BIT_SHIFT_WMAC_RESP_ANTCD 0
+#define BIT_MASK_WMAC_RESP_ANTCD 0xf
+#define BIT_WMAC_RESP_ANTCD(x)                                                 \
+	(((x) & BIT_MASK_WMAC_RESP_ANTCD) << BIT_SHIFT_WMAC_RESP_ANTCD)
+#define BIT_GET_WMAC_RESP_ANTCD(x)                                             \
+	(((x) >> BIT_SHIFT_WMAC_RESP_ANTCD) & BIT_MASK_WMAC_RESP_ANTCD)
+
+/* 2 REG_MACID1				(Offset 0x0700) */
+
+#define BIT_SHIFT_MACID1 0
+#define BIT_MASK_MACID1 0xffffffffffffL
+#define BIT_MACID1(x) (((x) & BIT_MASK_MACID1) << BIT_SHIFT_MACID1)
+#define BIT_GET_MACID1(x) (((x) >> BIT_SHIFT_MACID1) & BIT_MASK_MACID1)
+
+/* 2 REG_BSSID1				(Offset 0x0708) */
+
+#define BIT_SHIFT_BSSID1 0
+#define BIT_MASK_BSSID1 0xffffffffffffL
+#define BIT_BSSID1(x) (((x) & BIT_MASK_BSSID1) << BIT_SHIFT_BSSID1)
+#define BIT_GET_BSSID1(x) (((x) >> BIT_SHIFT_BSSID1) & BIT_MASK_BSSID1)
+
+/* 2 REG_BCN_PSR_RPT1			(Offset 0x0710) */
+
+#define BIT_SHIFT_DTIM_CNT1 24
+#define BIT_MASK_DTIM_CNT1 0xff
+#define BIT_DTIM_CNT1(x) (((x) & BIT_MASK_DTIM_CNT1) << BIT_SHIFT_DTIM_CNT1)
+#define BIT_GET_DTIM_CNT1(x) (((x) >> BIT_SHIFT_DTIM_CNT1) & BIT_MASK_DTIM_CNT1)
+
+#define BIT_SHIFT_DTIM_PERIOD1 16
+#define BIT_MASK_DTIM_PERIOD1 0xff
+#define BIT_DTIM_PERIOD1(x)                                                    \
+	(((x) & BIT_MASK_DTIM_PERIOD1) << BIT_SHIFT_DTIM_PERIOD1)
+#define BIT_GET_DTIM_PERIOD1(x)                                                \
+	(((x) >> BIT_SHIFT_DTIM_PERIOD1) & BIT_MASK_DTIM_PERIOD1)
+
+#define BIT_DTIM1 BIT(15)
+#define BIT_TIM1 BIT(14)
+
+#define BIT_SHIFT_PS_AID_1 0
+#define BIT_MASK_PS_AID_1 0x7ff
+#define BIT_PS_AID_1(x) (((x) & BIT_MASK_PS_AID_1) << BIT_SHIFT_PS_AID_1)
+#define BIT_GET_PS_AID_1(x) (((x) >> BIT_SHIFT_PS_AID_1) & BIT_MASK_PS_AID_1)
+
+/* 2 REG_ASSOCIATED_BFMEE_SEL		(Offset 0x0714) */
+
+#define BIT_TXUSER_ID1 BIT(25)
+
+#define BIT_SHIFT_AID1 16
+#define BIT_MASK_AID1 0x1ff
+#define BIT_AID1(x) (((x) & BIT_MASK_AID1) << BIT_SHIFT_AID1)
+#define BIT_GET_AID1(x) (((x) >> BIT_SHIFT_AID1) & BIT_MASK_AID1)
+
+#define BIT_TXUSER_ID0 BIT(9)
+
+#define BIT_SHIFT_AID0 0
+#define BIT_MASK_AID0 0x1ff
+#define BIT_AID0(x) (((x) & BIT_MASK_AID0) << BIT_SHIFT_AID0)
+#define BIT_GET_AID0(x) (((x) >> BIT_SHIFT_AID0) & BIT_MASK_AID0)
+
+/* 2 REG_SND_PTCL_CTRL			(Offset 0x0718) */
+
+#define BIT_SHIFT_NDP_RX_STANDBY_TIMER 24
+#define BIT_MASK_NDP_RX_STANDBY_TIMER 0xff
+#define BIT_NDP_RX_STANDBY_TIMER(x)                                            \
+	(((x) & BIT_MASK_NDP_RX_STANDBY_TIMER)                                 \
+	 << BIT_SHIFT_NDP_RX_STANDBY_TIMER)
+#define BIT_GET_NDP_RX_STANDBY_TIMER(x)                                        \
+	(((x) >> BIT_SHIFT_NDP_RX_STANDBY_TIMER) &                             \
+	 BIT_MASK_NDP_RX_STANDBY_TIMER)
+
+#define BIT_SHIFT_CSI_RPT_OFFSET_HT 16
+#define BIT_MASK_CSI_RPT_OFFSET_HT 0xff
+#define BIT_CSI_RPT_OFFSET_HT(x)                                               \
+	(((x) & BIT_MASK_CSI_RPT_OFFSET_HT) << BIT_SHIFT_CSI_RPT_OFFSET_HT)
+#define BIT_GET_CSI_RPT_OFFSET_HT(x)                                           \
+	(((x) >> BIT_SHIFT_CSI_RPT_OFFSET_HT) & BIT_MASK_CSI_RPT_OFFSET_HT)
+
+/* 2 REG_SND_PTCL_CTRL			(Offset 0x0718) */
+
+#define BIT_SHIFT_R_WMAC_VHT_CATEGORY 8
+#define BIT_MASK_R_WMAC_VHT_CATEGORY 0xff
+#define BIT_R_WMAC_VHT_CATEGORY(x)                                             \
+	(((x) & BIT_MASK_R_WMAC_VHT_CATEGORY) << BIT_SHIFT_R_WMAC_VHT_CATEGORY)
+#define BIT_GET_R_WMAC_VHT_CATEGORY(x)                                         \
+	(((x) >> BIT_SHIFT_R_WMAC_VHT_CATEGORY) & BIT_MASK_R_WMAC_VHT_CATEGORY)
+
+/* 2 REG_SND_PTCL_CTRL			(Offset 0x0718) */
+
+#define BIT_R_WMAC_USE_NSTS BIT(7)
+#define BIT_R_DISABLE_CHECK_VHTSIGB_CRC BIT(6)
+#define BIT_R_DISABLE_CHECK_VHTSIGA_CRC BIT(5)
+#define BIT_R_WMAC_BFPARAM_SEL BIT(4)
+#define BIT_R_WMAC_CSISEQ_SEL BIT(3)
+#define BIT_R_WMAC_CSI_WITHHTC_EN BIT(2)
+#define BIT_R_WMAC_HT_NDPA_EN BIT(1)
+#define BIT_R_WMAC_VHT_NDPA_EN BIT(0)
+
+/* 2 REG_NS_ARP_CTRL				(Offset 0x0720) */
+
+#define BIT_R_WMAC_NSARP_RSPEN BIT(15)
+#define BIT_R_WMAC_NSARP_RARP BIT(9)
+#define BIT_R_WMAC_NSARP_RIPV6 BIT(8)
+
+#define BIT_SHIFT_R_WMAC_NSARP_MODEN 6
+#define BIT_MASK_R_WMAC_NSARP_MODEN 0x3
+#define BIT_R_WMAC_NSARP_MODEN(x)                                              \
+	(((x) & BIT_MASK_R_WMAC_NSARP_MODEN) << BIT_SHIFT_R_WMAC_NSARP_MODEN)
+#define BIT_GET_R_WMAC_NSARP_MODEN(x)                                          \
+	(((x) >> BIT_SHIFT_R_WMAC_NSARP_MODEN) & BIT_MASK_R_WMAC_NSARP_MODEN)
+
+#define BIT_SHIFT_R_WMAC_NSARP_RSPFTP 4
+#define BIT_MASK_R_WMAC_NSARP_RSPFTP 0x3
+#define BIT_R_WMAC_NSARP_RSPFTP(x)                                             \
+	(((x) & BIT_MASK_R_WMAC_NSARP_RSPFTP) << BIT_SHIFT_R_WMAC_NSARP_RSPFTP)
+#define BIT_GET_R_WMAC_NSARP_RSPFTP(x)                                         \
+	(((x) >> BIT_SHIFT_R_WMAC_NSARP_RSPFTP) & BIT_MASK_R_WMAC_NSARP_RSPFTP)
+
+#define BIT_SHIFT_R_WMAC_NSARP_RSPSEC 0
+#define BIT_MASK_R_WMAC_NSARP_RSPSEC 0xf
+#define BIT_R_WMAC_NSARP_RSPSEC(x)                                             \
+	(((x) & BIT_MASK_R_WMAC_NSARP_RSPSEC) << BIT_SHIFT_R_WMAC_NSARP_RSPSEC)
+#define BIT_GET_R_WMAC_NSARP_RSPSEC(x)                                         \
+	(((x) >> BIT_SHIFT_R_WMAC_NSARP_RSPSEC) & BIT_MASK_R_WMAC_NSARP_RSPSEC)
+
+/* 2 REG_NS_ARP_INFO				(Offset 0x0724) */
+
+#define BIT_REQ_IS_MCNS BIT(23)
+#define BIT_REQ_IS_UCNS BIT(22)
+#define BIT_REQ_IS_USNS BIT(21)
+#define BIT_REQ_IS_ARP BIT(20)
+#define BIT_EXPRSP_MH_WITHQC BIT(19)
+
+#define BIT_SHIFT_EXPRSP_SECTYPE 16
+#define BIT_MASK_EXPRSP_SECTYPE 0x7
+#define BIT_EXPRSP_SECTYPE(x)                                                  \
+	(((x) & BIT_MASK_EXPRSP_SECTYPE) << BIT_SHIFT_EXPRSP_SECTYPE)
+#define BIT_GET_EXPRSP_SECTYPE(x)                                              \
+	(((x) >> BIT_SHIFT_EXPRSP_SECTYPE) & BIT_MASK_EXPRSP_SECTYPE)
+
+#define BIT_SHIFT_EXPRSP_CHKSM_7_TO_0 8
+#define BIT_MASK_EXPRSP_CHKSM_7_TO_0 0xff
+#define BIT_EXPRSP_CHKSM_7_TO_0(x)                                             \
+	(((x) & BIT_MASK_EXPRSP_CHKSM_7_TO_0) << BIT_SHIFT_EXPRSP_CHKSM_7_TO_0)
+#define BIT_GET_EXPRSP_CHKSM_7_TO_0(x)                                         \
+	(((x) >> BIT_SHIFT_EXPRSP_CHKSM_7_TO_0) & BIT_MASK_EXPRSP_CHKSM_7_TO_0)
+
+#define BIT_SHIFT_EXPRSP_CHKSM_15_TO_8 0
+#define BIT_MASK_EXPRSP_CHKSM_15_TO_8 0xff
+#define BIT_EXPRSP_CHKSM_15_TO_8(x)                                            \
+	(((x) & BIT_MASK_EXPRSP_CHKSM_15_TO_8)                                 \
+	 << BIT_SHIFT_EXPRSP_CHKSM_15_TO_8)
+#define BIT_GET_EXPRSP_CHKSM_15_TO_8(x)                                        \
+	(((x) >> BIT_SHIFT_EXPRSP_CHKSM_15_TO_8) &                             \
+	 BIT_MASK_EXPRSP_CHKSM_15_TO_8)
+
+/* 2 REG_BEAMFORMING_INFO_NSARP_V1		(Offset 0x0728) */
+
+#define BIT_SHIFT_WMAC_ARPIP 0
+#define BIT_MASK_WMAC_ARPIP 0xffffffffL
+#define BIT_WMAC_ARPIP(x) (((x) & BIT_MASK_WMAC_ARPIP) << BIT_SHIFT_WMAC_ARPIP)
+#define BIT_GET_WMAC_ARPIP(x)                                                  \
+	(((x) >> BIT_SHIFT_WMAC_ARPIP) & BIT_MASK_WMAC_ARPIP)
+
+/* 2 REG_BEAMFORMING_INFO_NSARP		(Offset 0x072C) */
+
+#define BIT_SHIFT_BEAMFORMING_INFO 0
+#define BIT_MASK_BEAMFORMING_INFO 0xffffffffL
+#define BIT_BEAMFORMING_INFO(x)                                                \
+	(((x) & BIT_MASK_BEAMFORMING_INFO) << BIT_SHIFT_BEAMFORMING_INFO)
+#define BIT_GET_BEAMFORMING_INFO(x)                                            \
+	(((x) >> BIT_SHIFT_BEAMFORMING_INFO) & BIT_MASK_BEAMFORMING_INFO)
+
+/* 2 REG_WMAC_RTX_CTX_SUBTYPE_CFG		(Offset 0x0750) */
+
+#define BIT_SHIFT_R_WMAC_CTX_SUBTYPE 4
+#define BIT_MASK_R_WMAC_CTX_SUBTYPE 0xf
+#define BIT_R_WMAC_CTX_SUBTYPE(x)                                              \
+	(((x) & BIT_MASK_R_WMAC_CTX_SUBTYPE) << BIT_SHIFT_R_WMAC_CTX_SUBTYPE)
+#define BIT_GET_R_WMAC_CTX_SUBTYPE(x)                                          \
+	(((x) >> BIT_SHIFT_R_WMAC_CTX_SUBTYPE) & BIT_MASK_R_WMAC_CTX_SUBTYPE)
+
+#define BIT_SHIFT_R_WMAC_RTX_SUBTYPE 0
+#define BIT_MASK_R_WMAC_RTX_SUBTYPE 0xf
+#define BIT_R_WMAC_RTX_SUBTYPE(x)                                              \
+	(((x) & BIT_MASK_R_WMAC_RTX_SUBTYPE) << BIT_SHIFT_R_WMAC_RTX_SUBTYPE)
+#define BIT_GET_R_WMAC_RTX_SUBTYPE(x)                                          \
+	(((x) >> BIT_SHIFT_R_WMAC_RTX_SUBTYPE) & BIT_MASK_R_WMAC_RTX_SUBTYPE)
+
+/* 2 REG_BT_COEX_V2				(Offset 0x0762) */
+
+#define BIT_GNT_BT_POLARITY BIT(12)
+#define BIT_GNT_BT_BYPASS_PRIORITY BIT(8)
+
+#define BIT_SHIFT_TIMER 0
+#define BIT_MASK_TIMER 0xff
+#define BIT_TIMER(x) (((x) & BIT_MASK_TIMER) << BIT_SHIFT_TIMER)
+#define BIT_GET_TIMER(x) (((x) >> BIT_SHIFT_TIMER) & BIT_MASK_TIMER)
+
+/* 2 REG_BT_COEX				(Offset 0x0764) */
+
+#define BIT_R_GNT_BT_RFC_SW BIT(12)
+#define BIT_R_GNT_BT_RFC_SW_EN BIT(11)
+#define BIT_R_GNT_BT_BB_SW BIT(10)
+#define BIT_R_GNT_BT_BB_SW_EN BIT(9)
+#define BIT_R_BT_CNT_THREN BIT(8)
+
+#define BIT_SHIFT_R_BT_CNT_THR 0
+#define BIT_MASK_R_BT_CNT_THR 0xff
+#define BIT_R_BT_CNT_THR(x)                                                    \
+	(((x) & BIT_MASK_R_BT_CNT_THR) << BIT_SHIFT_R_BT_CNT_THR)
+#define BIT_GET_R_BT_CNT_THR(x)                                                \
+	(((x) >> BIT_SHIFT_R_BT_CNT_THR) & BIT_MASK_R_BT_CNT_THR)
+
+/* 2 REG_WLAN_ACT_MASK_CTRL			(Offset 0x0768) */
+
+#define BIT_WLRX_TER_BY_CTL BIT(43)
+#define BIT_WLRX_TER_BY_AD BIT(42)
+#define BIT_ANT_DIVERSITY_SEL BIT(41)
+#define BIT_ANTSEL_FOR_BT_CTRL_EN BIT(40)
+#define BIT_WLACT_LOW_GNTWL_EN BIT(34)
+#define BIT_WLACT_HIGH_GNTBT_EN BIT(33)
+
+/* 2 REG_WLAN_ACT_MASK_CTRL			(Offset 0x0768) */
+
+#define BIT_NAV_UPPER_V1 BIT(32)
+
+/* 2 REG_WLAN_ACT_MASK_CTRL			(Offset 0x0768) */
+
+#define BIT_SHIFT_RXMYRTS_NAV_V1 8
+#define BIT_MASK_RXMYRTS_NAV_V1 0xff
+#define BIT_RXMYRTS_NAV_V1(x)                                                  \
+	(((x) & BIT_MASK_RXMYRTS_NAV_V1) << BIT_SHIFT_RXMYRTS_NAV_V1)
+#define BIT_GET_RXMYRTS_NAV_V1(x)                                              \
+	(((x) >> BIT_SHIFT_RXMYRTS_NAV_V1) & BIT_MASK_RXMYRTS_NAV_V1)
+
+#define BIT_SHIFT_RTSRST_V1 0
+#define BIT_MASK_RTSRST_V1 0xff
+#define BIT_RTSRST_V1(x) (((x) & BIT_MASK_RTSRST_V1) << BIT_SHIFT_RTSRST_V1)
+#define BIT_GET_RTSRST_V1(x) (((x) >> BIT_SHIFT_RTSRST_V1) & BIT_MASK_RTSRST_V1)
+
+/* 2 REG_BT_COEX_ENHANCED_INTR_CTRL		(Offset 0x076E) */
+
+#define BIT_SHIFT_BT_STAT_DELAY 12
+#define BIT_MASK_BT_STAT_DELAY 0xf
+#define BIT_BT_STAT_DELAY(x)                                                   \
+	(((x) & BIT_MASK_BT_STAT_DELAY) << BIT_SHIFT_BT_STAT_DELAY)
+#define BIT_GET_BT_STAT_DELAY(x)                                               \
+	(((x) >> BIT_SHIFT_BT_STAT_DELAY) & BIT_MASK_BT_STAT_DELAY)
+
+#define BIT_SHIFT_BT_TRX_INIT_DETECT 8
+#define BIT_MASK_BT_TRX_INIT_DETECT 0xf
+#define BIT_BT_TRX_INIT_DETECT(x)                                              \
+	(((x) & BIT_MASK_BT_TRX_INIT_DETECT) << BIT_SHIFT_BT_TRX_INIT_DETECT)
+#define BIT_GET_BT_TRX_INIT_DETECT(x)                                          \
+	(((x) >> BIT_SHIFT_BT_TRX_INIT_DETECT) & BIT_MASK_BT_TRX_INIT_DETECT)
+
+#define BIT_SHIFT_BT_PRI_DETECT_TO 4
+#define BIT_MASK_BT_PRI_DETECT_TO 0xf
+#define BIT_BT_PRI_DETECT_TO(x)                                                \
+	(((x) & BIT_MASK_BT_PRI_DETECT_TO) << BIT_SHIFT_BT_PRI_DETECT_TO)
+#define BIT_GET_BT_PRI_DETECT_TO(x)                                            \
+	(((x) >> BIT_SHIFT_BT_PRI_DETECT_TO) & BIT_MASK_BT_PRI_DETECT_TO)
+
+#define BIT_R_GRANTALL_WLMASK BIT(3)
+#define BIT_STATIS_BT_EN BIT(2)
+#define BIT_WL_ACT_MASK_ENABLE BIT(1)
+#define BIT_ENHANCED_BT BIT(0)
+
+/* 2 REG_BT_ACT_STATISTICS			(Offset 0x0770) */
+
+#define BIT_SHIFT_STATIS_BT_LO_RX (48 & CPU_OPT_WIDTH)
+#define BIT_MASK_STATIS_BT_LO_RX 0xffff
+#define BIT_STATIS_BT_LO_RX(x)                                                 \
+	(((x) & BIT_MASK_STATIS_BT_LO_RX) << BIT_SHIFT_STATIS_BT_LO_RX)
+#define BIT_GET_STATIS_BT_LO_RX(x)                                             \
+	(((x) >> BIT_SHIFT_STATIS_BT_LO_RX) & BIT_MASK_STATIS_BT_LO_RX)
+
+#define BIT_SHIFT_STATIS_BT_LO_TX (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_STATIS_BT_LO_TX 0xffff
+#define BIT_STATIS_BT_LO_TX(x)                                                 \
+	(((x) & BIT_MASK_STATIS_BT_LO_TX) << BIT_SHIFT_STATIS_BT_LO_TX)
+#define BIT_GET_STATIS_BT_LO_TX(x)                                             \
+	(((x) >> BIT_SHIFT_STATIS_BT_LO_TX) & BIT_MASK_STATIS_BT_LO_TX)
+
+/* 2 REG_BT_ACT_STATISTICS			(Offset 0x0770) */
+
+#define BIT_SHIFT_STATIS_BT_HI_RX 16
+#define BIT_MASK_STATIS_BT_HI_RX 0xffff
+#define BIT_STATIS_BT_HI_RX(x)                                                 \
+	(((x) & BIT_MASK_STATIS_BT_HI_RX) << BIT_SHIFT_STATIS_BT_HI_RX)
+#define BIT_GET_STATIS_BT_HI_RX(x)                                             \
+	(((x) >> BIT_SHIFT_STATIS_BT_HI_RX) & BIT_MASK_STATIS_BT_HI_RX)
+
+#define BIT_SHIFT_STATIS_BT_HI_TX 0
+#define BIT_MASK_STATIS_BT_HI_TX 0xffff
+#define BIT_STATIS_BT_HI_TX(x)                                                 \
+	(((x) & BIT_MASK_STATIS_BT_HI_TX) << BIT_SHIFT_STATIS_BT_HI_TX)
+#define BIT_GET_STATIS_BT_HI_TX(x)                                             \
+	(((x) >> BIT_SHIFT_STATIS_BT_HI_TX) & BIT_MASK_STATIS_BT_HI_TX)
+
+/* 2 REG_BT_STATISTICS_CONTROL_REGISTER	(Offset 0x0778) */
+
+#define BIT_SHIFT_R_BT_CMD_RPT 16
+#define BIT_MASK_R_BT_CMD_RPT 0xffff
+#define BIT_R_BT_CMD_RPT(x)                                                    \
+	(((x) & BIT_MASK_R_BT_CMD_RPT) << BIT_SHIFT_R_BT_CMD_RPT)
+#define BIT_GET_R_BT_CMD_RPT(x)                                                \
+	(((x) >> BIT_SHIFT_R_BT_CMD_RPT) & BIT_MASK_R_BT_CMD_RPT)
+
+#define BIT_SHIFT_R_RPT_FROM_BT 8
+#define BIT_MASK_R_RPT_FROM_BT 0xff
+#define BIT_R_RPT_FROM_BT(x)                                                   \
+	(((x) & BIT_MASK_R_RPT_FROM_BT) << BIT_SHIFT_R_RPT_FROM_BT)
+#define BIT_GET_R_RPT_FROM_BT(x)                                               \
+	(((x) >> BIT_SHIFT_R_RPT_FROM_BT) & BIT_MASK_R_RPT_FROM_BT)
+
+#define BIT_SHIFT_BT_HID_ISR_SET 6
+#define BIT_MASK_BT_HID_ISR_SET 0x3
+#define BIT_BT_HID_ISR_SET(x)                                                  \
+	(((x) & BIT_MASK_BT_HID_ISR_SET) << BIT_SHIFT_BT_HID_ISR_SET)
+#define BIT_GET_BT_HID_ISR_SET(x)                                              \
+	(((x) >> BIT_SHIFT_BT_HID_ISR_SET) & BIT_MASK_BT_HID_ISR_SET)
+
+#define BIT_TDMA_BT_START_NOTIFY BIT(5)
+#define BIT_ENABLE_TDMA_FW_MODE BIT(4)
+#define BIT_ENABLE_PTA_TDMA_MODE BIT(3)
+#define BIT_ENABLE_COEXIST_TAB_IN_TDMA BIT(2)
+#define BIT_GPIO2_GPIO3_EXANGE_OR_NO_BT_CCA BIT(1)
+#define BIT_RTK_BT_ENABLE BIT(0)
+
+/* 2 REG_BT_STATUS_REPORT_REGISTER		(Offset 0x077C) */
+
+#define BIT_SHIFT_BT_PROFILE 24
+#define BIT_MASK_BT_PROFILE 0xff
+#define BIT_BT_PROFILE(x) (((x) & BIT_MASK_BT_PROFILE) << BIT_SHIFT_BT_PROFILE)
+#define BIT_GET_BT_PROFILE(x)                                                  \
+	(((x) >> BIT_SHIFT_BT_PROFILE) & BIT_MASK_BT_PROFILE)
+
+#define BIT_SHIFT_BT_POWER 16
+#define BIT_MASK_BT_POWER 0xff
+#define BIT_BT_POWER(x) (((x) & BIT_MASK_BT_POWER) << BIT_SHIFT_BT_POWER)
+#define BIT_GET_BT_POWER(x) (((x) >> BIT_SHIFT_BT_POWER) & BIT_MASK_BT_POWER)
+
+#define BIT_SHIFT_BT_PREDECT_STATUS 8
+#define BIT_MASK_BT_PREDECT_STATUS 0xff
+#define BIT_BT_PREDECT_STATUS(x)                                               \
+	(((x) & BIT_MASK_BT_PREDECT_STATUS) << BIT_SHIFT_BT_PREDECT_STATUS)
+#define BIT_GET_BT_PREDECT_STATUS(x)                                           \
+	(((x) >> BIT_SHIFT_BT_PREDECT_STATUS) & BIT_MASK_BT_PREDECT_STATUS)
+
+#define BIT_SHIFT_BT_CMD_INFO 0
+#define BIT_MASK_BT_CMD_INFO 0xff
+#define BIT_BT_CMD_INFO(x)                                                     \
+	(((x) & BIT_MASK_BT_CMD_INFO) << BIT_SHIFT_BT_CMD_INFO)
+#define BIT_GET_BT_CMD_INFO(x)                                                 \
+	(((x) >> BIT_SHIFT_BT_CMD_INFO) & BIT_MASK_BT_CMD_INFO)
+
+/* 2 REG_BT_INTERRUPT_CONTROL_REGISTER	(Offset 0x0780) */
+
+#define BIT_EN_MAC_NULL_PKT_NOTIFY BIT(31)
+#define BIT_EN_WLAN_RPT_AND_BT_QUERY BIT(30)
+#define BIT_EN_BT_STSTUS_RPT BIT(29)
+#define BIT_EN_BT_POWER BIT(28)
+#define BIT_EN_BT_CHANNEL BIT(27)
+#define BIT_EN_BT_SLOT_CHANGE BIT(26)
+#define BIT_EN_BT_PROFILE_OR_HID BIT(25)
+#define BIT_WLAN_RPT_NOTIFY BIT(24)
+
+#define BIT_SHIFT_WLAN_RPT_DATA 16
+#define BIT_MASK_WLAN_RPT_DATA 0xff
+#define BIT_WLAN_RPT_DATA(x)                                                   \
+	(((x) & BIT_MASK_WLAN_RPT_DATA) << BIT_SHIFT_WLAN_RPT_DATA)
+#define BIT_GET_WLAN_RPT_DATA(x)                                               \
+	(((x) >> BIT_SHIFT_WLAN_RPT_DATA) & BIT_MASK_WLAN_RPT_DATA)
+
+#define BIT_SHIFT_CMD_ID 8
+#define BIT_MASK_CMD_ID 0xff
+#define BIT_CMD_ID(x) (((x) & BIT_MASK_CMD_ID) << BIT_SHIFT_CMD_ID)
+#define BIT_GET_CMD_ID(x) (((x) >> BIT_SHIFT_CMD_ID) & BIT_MASK_CMD_ID)
+
+#define BIT_SHIFT_BT_DATA 0
+#define BIT_MASK_BT_DATA 0xff
+#define BIT_BT_DATA(x) (((x) & BIT_MASK_BT_DATA) << BIT_SHIFT_BT_DATA)
+#define BIT_GET_BT_DATA(x) (((x) >> BIT_SHIFT_BT_DATA) & BIT_MASK_BT_DATA)
+
+/* 2 REG_WLAN_REPORT_TIME_OUT_CONTROL_REGISTER (Offset 0x0784) */
+
+#define BIT_SHIFT_WLAN_RPT_TO 0
+#define BIT_MASK_WLAN_RPT_TO 0xff
+#define BIT_WLAN_RPT_TO(x)                                                     \
+	(((x) & BIT_MASK_WLAN_RPT_TO) << BIT_SHIFT_WLAN_RPT_TO)
+#define BIT_GET_WLAN_RPT_TO(x)                                                 \
+	(((x) >> BIT_SHIFT_WLAN_RPT_TO) & BIT_MASK_WLAN_RPT_TO)
+
+/* 2 REG_BT_ISOLATION_TABLE_REGISTER_REGISTER (Offset 0x0785) */
+
+#define BIT_SHIFT_ISOLATION_CHK 1
+#define BIT_MASK_ISOLATION_CHK 0x7fffffffffffffffffffL
+#define BIT_ISOLATION_CHK(x)                                                   \
+	(((x) & BIT_MASK_ISOLATION_CHK) << BIT_SHIFT_ISOLATION_CHK)
+#define BIT_GET_ISOLATION_CHK(x)                                               \
+	(((x) >> BIT_SHIFT_ISOLATION_CHK) & BIT_MASK_ISOLATION_CHK)
+
+/* 2 REG_BT_ISOLATION_TABLE_REGISTER_REGISTER (Offset 0x0785) */
+
+#define BIT_ISOLATION_EN BIT(0)
+
+/* 2 REG_BT_INTERRUPT_STATUS_REGISTER	(Offset 0x078F) */
+
+#define BIT_BT_HID_ISR BIT(7)
+#define BIT_BT_QUERY_ISR BIT(6)
+#define BIT_MAC_NULL_PKT_NOTIFY_ISR BIT(5)
+#define BIT_WLAN_RPT_ISR BIT(4)
+#define BIT_BT_POWER_ISR BIT(3)
+#define BIT_BT_CHANNEL_ISR BIT(2)
+#define BIT_BT_SLOT_CHANGE_ISR BIT(1)
+#define BIT_BT_PROFILE_ISR BIT(0)
+
+/* 2 REG_BT_TDMA_TIME_REGISTER		(Offset 0x0790) */
+
+#define BIT_SHIFT_BT_TIME 6
+#define BIT_MASK_BT_TIME 0x3ffffff
+#define BIT_BT_TIME(x) (((x) & BIT_MASK_BT_TIME) << BIT_SHIFT_BT_TIME)
+#define BIT_GET_BT_TIME(x) (((x) >> BIT_SHIFT_BT_TIME) & BIT_MASK_BT_TIME)
+
+#define BIT_SHIFT_BT_RPT_SAMPLE_RATE 0
+#define BIT_MASK_BT_RPT_SAMPLE_RATE 0x3f
+#define BIT_BT_RPT_SAMPLE_RATE(x)                                              \
+	(((x) & BIT_MASK_BT_RPT_SAMPLE_RATE) << BIT_SHIFT_BT_RPT_SAMPLE_RATE)
+#define BIT_GET_BT_RPT_SAMPLE_RATE(x)                                          \
+	(((x) >> BIT_SHIFT_BT_RPT_SAMPLE_RATE) & BIT_MASK_BT_RPT_SAMPLE_RATE)
+
+/* 2 REG_BT_ACT_REGISTER			(Offset 0x0794) */
+
+#define BIT_SHIFT_BT_EISR_EN 16
+#define BIT_MASK_BT_EISR_EN 0xff
+#define BIT_BT_EISR_EN(x) (((x) & BIT_MASK_BT_EISR_EN) << BIT_SHIFT_BT_EISR_EN)
+#define BIT_GET_BT_EISR_EN(x)                                                  \
+	(((x) >> BIT_SHIFT_BT_EISR_EN) & BIT_MASK_BT_EISR_EN)
+
+#define BIT_BT_ACT_FALLING_ISR BIT(10)
+#define BIT_BT_ACT_RISING_ISR BIT(9)
+#define BIT_TDMA_TO_ISR BIT(8)
+
+#define BIT_SHIFT_BT_CH 0
+#define BIT_MASK_BT_CH 0xff
+#define BIT_BT_CH(x) (((x) & BIT_MASK_BT_CH) << BIT_SHIFT_BT_CH)
+#define BIT_GET_BT_CH(x) (((x) >> BIT_SHIFT_BT_CH) & BIT_MASK_BT_CH)
+
+/* 2 REG_OBFF_CTRL_BASIC			(Offset 0x0798) */
+
+#define BIT_OBFF_EN_V1 BIT(31)
+
+#define BIT_SHIFT_OBFF_STATE_V1 28
+#define BIT_MASK_OBFF_STATE_V1 0x3
+#define BIT_OBFF_STATE_V1(x)                                                   \
+	(((x) & BIT_MASK_OBFF_STATE_V1) << BIT_SHIFT_OBFF_STATE_V1)
+#define BIT_GET_OBFF_STATE_V1(x)                                               \
+	(((x) >> BIT_SHIFT_OBFF_STATE_V1) & BIT_MASK_OBFF_STATE_V1)
+
+#define BIT_OBFF_ACT_RXDMA_EN BIT(27)
+#define BIT_OBFF_BLOCK_INT_EN BIT(26)
+#define BIT_OBFF_AUTOACT_EN BIT(25)
+#define BIT_OBFF_AUTOIDLE_EN BIT(24)
+
+#define BIT_SHIFT_WAKE_MAX_PLS 20
+#define BIT_MASK_WAKE_MAX_PLS 0x7
+#define BIT_WAKE_MAX_PLS(x)                                                    \
+	(((x) & BIT_MASK_WAKE_MAX_PLS) << BIT_SHIFT_WAKE_MAX_PLS)
+#define BIT_GET_WAKE_MAX_PLS(x)                                                \
+	(((x) >> BIT_SHIFT_WAKE_MAX_PLS) & BIT_MASK_WAKE_MAX_PLS)
+
+#define BIT_SHIFT_WAKE_MIN_PLS 16
+#define BIT_MASK_WAKE_MIN_PLS 0x7
+#define BIT_WAKE_MIN_PLS(x)                                                    \
+	(((x) & BIT_MASK_WAKE_MIN_PLS) << BIT_SHIFT_WAKE_MIN_PLS)
+#define BIT_GET_WAKE_MIN_PLS(x)                                                \
+	(((x) >> BIT_SHIFT_WAKE_MIN_PLS) & BIT_MASK_WAKE_MIN_PLS)
+
+#define BIT_SHIFT_WAKE_MAX_F2F 12
+#define BIT_MASK_WAKE_MAX_F2F 0x7
+#define BIT_WAKE_MAX_F2F(x)                                                    \
+	(((x) & BIT_MASK_WAKE_MAX_F2F) << BIT_SHIFT_WAKE_MAX_F2F)
+#define BIT_GET_WAKE_MAX_F2F(x)                                                \
+	(((x) >> BIT_SHIFT_WAKE_MAX_F2F) & BIT_MASK_WAKE_MAX_F2F)
+
+#define BIT_SHIFT_WAKE_MIN_F2F 8
+#define BIT_MASK_WAKE_MIN_F2F 0x7
+#define BIT_WAKE_MIN_F2F(x)                                                    \
+	(((x) & BIT_MASK_WAKE_MIN_F2F) << BIT_SHIFT_WAKE_MIN_F2F)
+#define BIT_GET_WAKE_MIN_F2F(x)                                                \
+	(((x) >> BIT_SHIFT_WAKE_MIN_F2F) & BIT_MASK_WAKE_MIN_F2F)
+
+#define BIT_APP_CPU_ACT_V1 BIT(3)
+#define BIT_APP_OBFF_V1 BIT(2)
+#define BIT_APP_IDLE_V1 BIT(1)
+#define BIT_APP_INIT_V1 BIT(0)
+
+/* 2 REG_OBFF_CTRL2_TIMER			(Offset 0x079C) */
+
+#define BIT_SHIFT_RX_HIGH_TIMER_IDX 24
+#define BIT_MASK_RX_HIGH_TIMER_IDX 0x7
+#define BIT_RX_HIGH_TIMER_IDX(x)                                               \
+	(((x) & BIT_MASK_RX_HIGH_TIMER_IDX) << BIT_SHIFT_RX_HIGH_TIMER_IDX)
+#define BIT_GET_RX_HIGH_TIMER_IDX(x)                                           \
+	(((x) >> BIT_SHIFT_RX_HIGH_TIMER_IDX) & BIT_MASK_RX_HIGH_TIMER_IDX)
+
+#define BIT_SHIFT_RX_MED_TIMER_IDX 16
+#define BIT_MASK_RX_MED_TIMER_IDX 0x7
+#define BIT_RX_MED_TIMER_IDX(x)                                                \
+	(((x) & BIT_MASK_RX_MED_TIMER_IDX) << BIT_SHIFT_RX_MED_TIMER_IDX)
+#define BIT_GET_RX_MED_TIMER_IDX(x)                                            \
+	(((x) >> BIT_SHIFT_RX_MED_TIMER_IDX) & BIT_MASK_RX_MED_TIMER_IDX)
+
+#define BIT_SHIFT_RX_LOW_TIMER_IDX 8
+#define BIT_MASK_RX_LOW_TIMER_IDX 0x7
+#define BIT_RX_LOW_TIMER_IDX(x)                                                \
+	(((x) & BIT_MASK_RX_LOW_TIMER_IDX) << BIT_SHIFT_RX_LOW_TIMER_IDX)
+#define BIT_GET_RX_LOW_TIMER_IDX(x)                                            \
+	(((x) >> BIT_SHIFT_RX_LOW_TIMER_IDX) & BIT_MASK_RX_LOW_TIMER_IDX)
+
+#define BIT_SHIFT_OBFF_INT_TIMER_IDX 0
+#define BIT_MASK_OBFF_INT_TIMER_IDX 0x7
+#define BIT_OBFF_INT_TIMER_IDX(x)                                              \
+	(((x) & BIT_MASK_OBFF_INT_TIMER_IDX) << BIT_SHIFT_OBFF_INT_TIMER_IDX)
+#define BIT_GET_OBFF_INT_TIMER_IDX(x)                                          \
+	(((x) >> BIT_SHIFT_OBFF_INT_TIMER_IDX) & BIT_MASK_OBFF_INT_TIMER_IDX)
+
+/* 2 REG_LTR_CTRL_BASIC			(Offset 0x07A0) */
+
+#define BIT_LTR_EN_V1 BIT(31)
+#define BIT_LTR_HW_EN_V1 BIT(30)
+#define BIT_LRT_ACT_CTS_EN BIT(29)
+#define BIT_LTR_ACT_RXPKT_EN BIT(28)
+#define BIT_LTR_ACT_RXDMA_EN BIT(27)
+#define BIT_LTR_IDLE_NO_SNOOP BIT(26)
+#define BIT_SPDUP_MGTPKT BIT(25)
+#define BIT_RX_AGG_EN BIT(24)
+#define BIT_APP_LTR_ACT BIT(23)
+#define BIT_APP_LTR_IDLE BIT(22)
+
+#define BIT_SHIFT_HIGH_RATE_TRIG_SEL 20
+#define BIT_MASK_HIGH_RATE_TRIG_SEL 0x3
+#define BIT_HIGH_RATE_TRIG_SEL(x)                                              \
+	(((x) & BIT_MASK_HIGH_RATE_TRIG_SEL) << BIT_SHIFT_HIGH_RATE_TRIG_SEL)
+#define BIT_GET_HIGH_RATE_TRIG_SEL(x)                                          \
+	(((x) >> BIT_SHIFT_HIGH_RATE_TRIG_SEL) & BIT_MASK_HIGH_RATE_TRIG_SEL)
+
+#define BIT_SHIFT_MED_RATE_TRIG_SEL 18
+#define BIT_MASK_MED_RATE_TRIG_SEL 0x3
+#define BIT_MED_RATE_TRIG_SEL(x)                                               \
+	(((x) & BIT_MASK_MED_RATE_TRIG_SEL) << BIT_SHIFT_MED_RATE_TRIG_SEL)
+#define BIT_GET_MED_RATE_TRIG_SEL(x)                                           \
+	(((x) >> BIT_SHIFT_MED_RATE_TRIG_SEL) & BIT_MASK_MED_RATE_TRIG_SEL)
+
+#define BIT_SHIFT_LOW_RATE_TRIG_SEL 16
+#define BIT_MASK_LOW_RATE_TRIG_SEL 0x3
+#define BIT_LOW_RATE_TRIG_SEL(x)                                               \
+	(((x) & BIT_MASK_LOW_RATE_TRIG_SEL) << BIT_SHIFT_LOW_RATE_TRIG_SEL)
+#define BIT_GET_LOW_RATE_TRIG_SEL(x)                                           \
+	(((x) >> BIT_SHIFT_LOW_RATE_TRIG_SEL) & BIT_MASK_LOW_RATE_TRIG_SEL)
+
+#define BIT_SHIFT_HIGH_RATE_BD_IDX 8
+#define BIT_MASK_HIGH_RATE_BD_IDX 0x7f
+#define BIT_HIGH_RATE_BD_IDX(x)                                                \
+	(((x) & BIT_MASK_HIGH_RATE_BD_IDX) << BIT_SHIFT_HIGH_RATE_BD_IDX)
+#define BIT_GET_HIGH_RATE_BD_IDX(x)                                            \
+	(((x) >> BIT_SHIFT_HIGH_RATE_BD_IDX) & BIT_MASK_HIGH_RATE_BD_IDX)
+
+#define BIT_SHIFT_LOW_RATE_BD_IDX 0
+#define BIT_MASK_LOW_RATE_BD_IDX 0x7f
+#define BIT_LOW_RATE_BD_IDX(x)                                                 \
+	(((x) & BIT_MASK_LOW_RATE_BD_IDX) << BIT_SHIFT_LOW_RATE_BD_IDX)
+#define BIT_GET_LOW_RATE_BD_IDX(x)                                             \
+	(((x) >> BIT_SHIFT_LOW_RATE_BD_IDX) & BIT_MASK_LOW_RATE_BD_IDX)
+
+/* 2 REG_LTR_CTRL2_TIMER_THRESHOLD		(Offset 0x07A4) */
+
+#define BIT_SHIFT_RX_EMPTY_TIMER_IDX 24
+#define BIT_MASK_RX_EMPTY_TIMER_IDX 0x7
+#define BIT_RX_EMPTY_TIMER_IDX(x)                                              \
+	(((x) & BIT_MASK_RX_EMPTY_TIMER_IDX) << BIT_SHIFT_RX_EMPTY_TIMER_IDX)
+#define BIT_GET_RX_EMPTY_TIMER_IDX(x)                                          \
+	(((x) >> BIT_SHIFT_RX_EMPTY_TIMER_IDX) & BIT_MASK_RX_EMPTY_TIMER_IDX)
+
+#define BIT_SHIFT_RX_AFULL_TH_IDX 20
+#define BIT_MASK_RX_AFULL_TH_IDX 0x7
+#define BIT_RX_AFULL_TH_IDX(x)                                                 \
+	(((x) & BIT_MASK_RX_AFULL_TH_IDX) << BIT_SHIFT_RX_AFULL_TH_IDX)
+#define BIT_GET_RX_AFULL_TH_IDX(x)                                             \
+	(((x) >> BIT_SHIFT_RX_AFULL_TH_IDX) & BIT_MASK_RX_AFULL_TH_IDX)
+
+#define BIT_SHIFT_RX_HIGH_TH_IDX 16
+#define BIT_MASK_RX_HIGH_TH_IDX 0x7
+#define BIT_RX_HIGH_TH_IDX(x)                                                  \
+	(((x) & BIT_MASK_RX_HIGH_TH_IDX) << BIT_SHIFT_RX_HIGH_TH_IDX)
+#define BIT_GET_RX_HIGH_TH_IDX(x)                                              \
+	(((x) >> BIT_SHIFT_RX_HIGH_TH_IDX) & BIT_MASK_RX_HIGH_TH_IDX)
+
+#define BIT_SHIFT_RX_MED_TH_IDX 12
+#define BIT_MASK_RX_MED_TH_IDX 0x7
+#define BIT_RX_MED_TH_IDX(x)                                                   \
+	(((x) & BIT_MASK_RX_MED_TH_IDX) << BIT_SHIFT_RX_MED_TH_IDX)
+#define BIT_GET_RX_MED_TH_IDX(x)                                               \
+	(((x) >> BIT_SHIFT_RX_MED_TH_IDX) & BIT_MASK_RX_MED_TH_IDX)
+
+#define BIT_SHIFT_RX_LOW_TH_IDX 8
+#define BIT_MASK_RX_LOW_TH_IDX 0x7
+#define BIT_RX_LOW_TH_IDX(x)                                                   \
+	(((x) & BIT_MASK_RX_LOW_TH_IDX) << BIT_SHIFT_RX_LOW_TH_IDX)
+#define BIT_GET_RX_LOW_TH_IDX(x)                                               \
+	(((x) >> BIT_SHIFT_RX_LOW_TH_IDX) & BIT_MASK_RX_LOW_TH_IDX)
+
+#define BIT_SHIFT_LTR_SPACE_IDX 4
+#define BIT_MASK_LTR_SPACE_IDX 0x3
+#define BIT_LTR_SPACE_IDX(x)                                                   \
+	(((x) & BIT_MASK_LTR_SPACE_IDX) << BIT_SHIFT_LTR_SPACE_IDX)
+#define BIT_GET_LTR_SPACE_IDX(x)                                               \
+	(((x) >> BIT_SHIFT_LTR_SPACE_IDX) & BIT_MASK_LTR_SPACE_IDX)
+
+#define BIT_SHIFT_LTR_IDLE_TIMER_IDX 0
+#define BIT_MASK_LTR_IDLE_TIMER_IDX 0x7
+#define BIT_LTR_IDLE_TIMER_IDX(x)                                              \
+	(((x) & BIT_MASK_LTR_IDLE_TIMER_IDX) << BIT_SHIFT_LTR_IDLE_TIMER_IDX)
+#define BIT_GET_LTR_IDLE_TIMER_IDX(x)                                          \
+	(((x) >> BIT_SHIFT_LTR_IDLE_TIMER_IDX) & BIT_MASK_LTR_IDLE_TIMER_IDX)
+
+/* 2 REG_LTR_IDLE_LATENCY_V1			(Offset 0x07A8) */
+
+#define BIT_SHIFT_LTR_IDLE_L 0
+#define BIT_MASK_LTR_IDLE_L 0xffffffffL
+#define BIT_LTR_IDLE_L(x) (((x) & BIT_MASK_LTR_IDLE_L) << BIT_SHIFT_LTR_IDLE_L)
+#define BIT_GET_LTR_IDLE_L(x)                                                  \
+	(((x) >> BIT_SHIFT_LTR_IDLE_L) & BIT_MASK_LTR_IDLE_L)
+
+/* 2 REG_LTR_ACTIVE_LATENCY_V1		(Offset 0x07AC) */
+
+#define BIT_SHIFT_LTR_ACT_L 0
+#define BIT_MASK_LTR_ACT_L 0xffffffffL
+#define BIT_LTR_ACT_L(x) (((x) & BIT_MASK_LTR_ACT_L) << BIT_SHIFT_LTR_ACT_L)
+#define BIT_GET_LTR_ACT_L(x) (((x) >> BIT_SHIFT_LTR_ACT_L) & BIT_MASK_LTR_ACT_L)
+
+/* 2 REG_ANTENNA_TRAINING_CONTROL_REGISTER	(Offset 0x07B0) */
+
+#define BIT_APPEND_MACID_IN_RESP_EN BIT(50)
+#define BIT_ADDR2_MATCH_EN BIT(49)
+#define BIT_ANTTRN_EN BIT(48)
+
+#define BIT_SHIFT_TRAIN_STA_ADDR 0
+#define BIT_MASK_TRAIN_STA_ADDR 0xffffffffffffL
+#define BIT_TRAIN_STA_ADDR(x)                                                  \
+	(((x) & BIT_MASK_TRAIN_STA_ADDR) << BIT_SHIFT_TRAIN_STA_ADDR)
+#define BIT_GET_TRAIN_STA_ADDR(x)                                              \
+	(((x) >> BIT_SHIFT_TRAIN_STA_ADDR) & BIT_MASK_TRAIN_STA_ADDR)
+
+/* 2 REG_WMAC_PKTCNT_RWD			(Offset 0x07B8) */
+
+#define BIT_SHIFT_PKTCNT_BSSIDMAP 4
+#define BIT_MASK_PKTCNT_BSSIDMAP 0xf
+#define BIT_PKTCNT_BSSIDMAP(x)                                                 \
+	(((x) & BIT_MASK_PKTCNT_BSSIDMAP) << BIT_SHIFT_PKTCNT_BSSIDMAP)
+#define BIT_GET_PKTCNT_BSSIDMAP(x)                                             \
+	(((x) >> BIT_SHIFT_PKTCNT_BSSIDMAP) & BIT_MASK_PKTCNT_BSSIDMAP)
+
+#define BIT_PKTCNT_CNTRST BIT(1)
+#define BIT_PKTCNT_CNTEN BIT(0)
+
+/* 2 REG_WMAC_PKTCNT_CTRL			(Offset 0x07BC) */
+
+#define BIT_WMAC_PKTCNT_TRST BIT(9)
+#define BIT_WMAC_PKTCNT_FEN BIT(8)
+
+#define BIT_SHIFT_WMAC_PKTCNT_CFGAD 0
+#define BIT_MASK_WMAC_PKTCNT_CFGAD 0xff
+#define BIT_WMAC_PKTCNT_CFGAD(x)                                               \
+	(((x) & BIT_MASK_WMAC_PKTCNT_CFGAD) << BIT_SHIFT_WMAC_PKTCNT_CFGAD)
+#define BIT_GET_WMAC_PKTCNT_CFGAD(x)                                           \
+	(((x) >> BIT_SHIFT_WMAC_PKTCNT_CFGAD) & BIT_MASK_WMAC_PKTCNT_CFGAD)
+
+/* 2 REG_IQ_DUMP				(Offset 0x07C0) */
+
+#define BIT_SHIFT_R_WMAC_MATCH_REF_MAC (64 & CPU_OPT_WIDTH)
+#define BIT_MASK_R_WMAC_MATCH_REF_MAC 0xffffffffL
+#define BIT_R_WMAC_MATCH_REF_MAC(x)                                            \
+	(((x) & BIT_MASK_R_WMAC_MATCH_REF_MAC)                                 \
+	 << BIT_SHIFT_R_WMAC_MATCH_REF_MAC)
+#define BIT_GET_R_WMAC_MATCH_REF_MAC(x)                                        \
+	(((x) >> BIT_SHIFT_R_WMAC_MATCH_REF_MAC) &                             \
+	 BIT_MASK_R_WMAC_MATCH_REF_MAC)
+
+#define BIT_SHIFT_R_WMAC_RX_FIL_LEN (64 & CPU_OPT_WIDTH)
+#define BIT_MASK_R_WMAC_RX_FIL_LEN 0xffff
+#define BIT_R_WMAC_RX_FIL_LEN(x)                                               \
+	(((x) & BIT_MASK_R_WMAC_RX_FIL_LEN) << BIT_SHIFT_R_WMAC_RX_FIL_LEN)
+#define BIT_GET_R_WMAC_RX_FIL_LEN(x)                                           \
+	(((x) >> BIT_SHIFT_R_WMAC_RX_FIL_LEN) & BIT_MASK_R_WMAC_RX_FIL_LEN)
+
+#define BIT_SHIFT_R_WMAC_RXFIFO_FULL_TH (56 & CPU_OPT_WIDTH)
+#define BIT_MASK_R_WMAC_RXFIFO_FULL_TH 0xff
+#define BIT_R_WMAC_RXFIFO_FULL_TH(x)                                           \
+	(((x) & BIT_MASK_R_WMAC_RXFIFO_FULL_TH)                                \
+	 << BIT_SHIFT_R_WMAC_RXFIFO_FULL_TH)
+#define BIT_GET_R_WMAC_RXFIFO_FULL_TH(x)                                       \
+	(((x) >> BIT_SHIFT_R_WMAC_RXFIFO_FULL_TH) &                            \
+	 BIT_MASK_R_WMAC_RXFIFO_FULL_TH)
+
+#define BIT_R_WMAC_SRCH_TXRPT_TYPE BIT(51)
+#define BIT_R_WMAC_NDP_RST BIT(50)
+#define BIT_R_WMAC_POWINT_EN BIT(49)
+#define BIT_R_WMAC_SRCH_TXRPT_PERPKT BIT(48)
+#define BIT_R_WMAC_SRCH_TXRPT_MID BIT(47)
+#define BIT_R_WMAC_PFIN_TOEN BIT(46)
+#define BIT_R_WMAC_FIL_SECERR BIT(45)
+#define BIT_R_WMAC_FIL_CTLPKTLEN BIT(44)
+#define BIT_R_WMAC_FIL_FCTYPE BIT(43)
+#define BIT_R_WMAC_FIL_FCPROVER BIT(42)
+#define BIT_R_WMAC_PHYSTS_SNIF BIT(41)
+#define BIT_R_WMAC_PHYSTS_PLCP BIT(40)
+#define BIT_R_MAC_TCR_VBONF_RD BIT(39)
+#define BIT_R_WMAC_TCR_MPAR_NDP BIT(38)
+#define BIT_R_WMAC_NDP_FILTER BIT(37)
+#define BIT_R_WMAC_RXLEN_SEL BIT(36)
+#define BIT_R_WMAC_RXLEN_SEL1 BIT(35)
+#define BIT_R_OFDM_FILTER BIT(34)
+#define BIT_R_WMAC_CHK_OFDM_LEN BIT(33)
+
+#define BIT_SHIFT_R_WMAC_MASK_LA_MAC (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_R_WMAC_MASK_LA_MAC 0xffffffffL
+#define BIT_R_WMAC_MASK_LA_MAC(x)                                              \
+	(((x) & BIT_MASK_R_WMAC_MASK_LA_MAC) << BIT_SHIFT_R_WMAC_MASK_LA_MAC)
+#define BIT_GET_R_WMAC_MASK_LA_MAC(x)                                          \
+	(((x) >> BIT_SHIFT_R_WMAC_MASK_LA_MAC) & BIT_MASK_R_WMAC_MASK_LA_MAC)
+
+#define BIT_R_WMAC_CHK_CCK_LEN BIT(32)
+
+/* 2 REG_IQ_DUMP				(Offset 0x07C0) */
+
+#define BIT_SHIFT_R_OFDM_LEN 26
+#define BIT_MASK_R_OFDM_LEN 0x3f
+#define BIT_R_OFDM_LEN(x) (((x) & BIT_MASK_R_OFDM_LEN) << BIT_SHIFT_R_OFDM_LEN)
+#define BIT_GET_R_OFDM_LEN(x)                                                  \
+	(((x) >> BIT_SHIFT_R_OFDM_LEN) & BIT_MASK_R_OFDM_LEN)
+
+#define BIT_SHIFT_DUMP_OK_ADDR 15
+#define BIT_MASK_DUMP_OK_ADDR 0x1ffff
+#define BIT_DUMP_OK_ADDR(x)                                                    \
+	(((x) & BIT_MASK_DUMP_OK_ADDR) << BIT_SHIFT_DUMP_OK_ADDR)
+#define BIT_GET_DUMP_OK_ADDR(x)                                                \
+	(((x) >> BIT_SHIFT_DUMP_OK_ADDR) & BIT_MASK_DUMP_OK_ADDR)
+
+#define BIT_SHIFT_R_TRIG_TIME_SEL 8
+#define BIT_MASK_R_TRIG_TIME_SEL 0x7f
+#define BIT_R_TRIG_TIME_SEL(x)                                                 \
+	(((x) & BIT_MASK_R_TRIG_TIME_SEL) << BIT_SHIFT_R_TRIG_TIME_SEL)
+#define BIT_GET_R_TRIG_TIME_SEL(x)                                             \
+	(((x) >> BIT_SHIFT_R_TRIG_TIME_SEL) & BIT_MASK_R_TRIG_TIME_SEL)
+
+#define BIT_SHIFT_R_MAC_TRIG_SEL 6
+#define BIT_MASK_R_MAC_TRIG_SEL 0x3
+#define BIT_R_MAC_TRIG_SEL(x)                                                  \
+	(((x) & BIT_MASK_R_MAC_TRIG_SEL) << BIT_SHIFT_R_MAC_TRIG_SEL)
+#define BIT_GET_R_MAC_TRIG_SEL(x)                                              \
+	(((x) >> BIT_SHIFT_R_MAC_TRIG_SEL) & BIT_MASK_R_MAC_TRIG_SEL)
+
+#define BIT_MAC_TRIG_REG BIT(5)
+
+#define BIT_SHIFT_R_LEVEL_PULSE_SEL 3
+#define BIT_MASK_R_LEVEL_PULSE_SEL 0x3
+#define BIT_R_LEVEL_PULSE_SEL(x)                                               \
+	(((x) & BIT_MASK_R_LEVEL_PULSE_SEL) << BIT_SHIFT_R_LEVEL_PULSE_SEL)
+#define BIT_GET_R_LEVEL_PULSE_SEL(x)                                           \
+	(((x) >> BIT_SHIFT_R_LEVEL_PULSE_SEL) & BIT_MASK_R_LEVEL_PULSE_SEL)
+
+#define BIT_EN_LA_MAC BIT(2)
+#define BIT_R_EN_IQDUMP BIT(1)
+#define BIT_R_IQDATA_DUMP BIT(0)
+
+#define BIT_SHIFT_R_CCK_LEN 0
+#define BIT_MASK_R_CCK_LEN 0xffff
+#define BIT_R_CCK_LEN(x) (((x) & BIT_MASK_R_CCK_LEN) << BIT_SHIFT_R_CCK_LEN)
+#define BIT_GET_R_CCK_LEN(x) (((x) >> BIT_SHIFT_R_CCK_LEN) & BIT_MASK_R_CCK_LEN)
+
+/* 2 REG_WMAC_FTM_CTL			(Offset 0x07CC) */
+
+#define BIT_RXFTM_TXACK_SC BIT(6)
+#define BIT_RXFTM_TXACK_BW BIT(5)
+#define BIT_RXFTM_EN BIT(3)
+#define BIT_RXFTMREQ_BYDRV BIT(2)
+#define BIT_RXFTMREQ_EN BIT(1)
+#define BIT_FTM_EN BIT(0)
+
+/* 2 REG_RX_FILTER_FUNCTION			(Offset 0x07DA) */
+
+#define BIT_R_WMAC_MHRDDY_LATCH BIT(14)
+
+/* 2 REG_RX_FILTER_FUNCTION			(Offset 0x07DA) */
+
+#define BIT_R_WMAC_MHRDDY_CLR BIT(13)
+
+/* 2 REG_RX_FILTER_FUNCTION			(Offset 0x07DA) */
+
+#define BIT_R_RXPKTCTL_FSM_BASED_MPDURDY1 BIT(12)
+
+/* 2 REG_RX_FILTER_FUNCTION			(Offset 0x07DA) */
+
+#define BIT_WMAC_DIS_VHT_PLCP_CHK_MU BIT(11)
+
+/* 2 REG_RX_FILTER_FUNCTION			(Offset 0x07DA) */
+
+#define BIT_R_CHK_DELIMIT_LEN BIT(10)
+#define BIT_R_REAPTER_ADDR_MATCH BIT(9)
+#define BIT_R_RXPKTCTL_FSM_BASED_MPDURDY BIT(8)
+#define BIT_R_LATCH_MACHRDY BIT(7)
+#define BIT_R_WMAC_RXFIL_REND BIT(6)
+#define BIT_R_WMAC_MPDURDY_CLR BIT(5)
+#define BIT_R_WMAC_CLRRXSEC BIT(4)
+#define BIT_R_WMAC_RXFIL_RDEL BIT(3)
+#define BIT_R_WMAC_RXFIL_FCSE BIT(2)
+#define BIT_R_WMAC_RXFIL_MESH_DEL BIT(1)
+#define BIT_R_WMAC_RXFIL_MASKM BIT(0)
+
+/* 2 REG_NDP_SIG				(Offset 0x07E0) */
+
+#define BIT_SHIFT_R_WMAC_TXNDP_SIGB 0
+#define BIT_MASK_R_WMAC_TXNDP_SIGB 0x1fffff
+#define BIT_R_WMAC_TXNDP_SIGB(x)                                               \
+	(((x) & BIT_MASK_R_WMAC_TXNDP_SIGB) << BIT_SHIFT_R_WMAC_TXNDP_SIGB)
+#define BIT_GET_R_WMAC_TXNDP_SIGB(x)                                           \
+	(((x) >> BIT_SHIFT_R_WMAC_TXNDP_SIGB) & BIT_MASK_R_WMAC_TXNDP_SIGB)
+
+/* 2 REG_TXCMD_INFO_FOR_RSP_PKT		(Offset 0x07E4) */
+
+#define BIT_SHIFT_R_MAC_DEBUG (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_R_MAC_DEBUG 0xffffffffL
+#define BIT_R_MAC_DEBUG(x)                                                     \
+	(((x) & BIT_MASK_R_MAC_DEBUG) << BIT_SHIFT_R_MAC_DEBUG)
+#define BIT_GET_R_MAC_DEBUG(x)                                                 \
+	(((x) >> BIT_SHIFT_R_MAC_DEBUG) & BIT_MASK_R_MAC_DEBUG)
+
+/* 2 REG_TXCMD_INFO_FOR_RSP_PKT		(Offset 0x07E4) */
+
+#define BIT_SHIFT_R_MAC_DBG_SHIFT 8
+#define BIT_MASK_R_MAC_DBG_SHIFT 0x7
+#define BIT_R_MAC_DBG_SHIFT(x)                                                 \
+	(((x) & BIT_MASK_R_MAC_DBG_SHIFT) << BIT_SHIFT_R_MAC_DBG_SHIFT)
+#define BIT_GET_R_MAC_DBG_SHIFT(x)                                             \
+	(((x) >> BIT_SHIFT_R_MAC_DBG_SHIFT) & BIT_MASK_R_MAC_DBG_SHIFT)
+
+#define BIT_SHIFT_R_MAC_DBG_SEL 0
+#define BIT_MASK_R_MAC_DBG_SEL 0x3
+#define BIT_R_MAC_DBG_SEL(x)                                                   \
+	(((x) & BIT_MASK_R_MAC_DBG_SEL) << BIT_SHIFT_R_MAC_DBG_SEL)
+#define BIT_GET_R_MAC_DBG_SEL(x)                                               \
+	(((x) >> BIT_SHIFT_R_MAC_DBG_SEL) & BIT_MASK_R_MAC_DBG_SEL)
+
+/* 2 REG_SYS_CFG3				(Offset 0x1000) */
+
+#define BIT_PWC_MA33V BIT(15)
+
+/* 2 REG_SYS_CFG3				(Offset 0x1000) */
+
+#define BIT_PWC_MA12V BIT(14)
+#define BIT_PWC_MD12V BIT(13)
+#define BIT_PWC_PD12V BIT(12)
+#define BIT_PWC_UD12V BIT(11)
+#define BIT_ISO_MA2MD BIT(1)
+
+/* 2 REG_SYS_CFG5				(Offset 0x1070) */
+
+#define BIT_LPS_STATUS BIT(3)
+#define BIT_HCI_TXDMA_BUSY BIT(2)
+#define BIT_HCI_TXDMA_ALLOW BIT(1)
+#define BIT_FW_CTRL_HCI_TXDMA_EN BIT(0)
+
+/* 2 REG_CPU_DMEM_CON			(Offset 0x1080) */
+
+#define BIT_WDT_OPT_IOWRAPPER BIT(19)
+
+/* 2 REG_CPU_DMEM_CON			(Offset 0x1080) */
+
+#define BIT_ANA_PORT_IDLE BIT(18)
+#define BIT_MAC_PORT_IDLE BIT(17)
+#define BIT_WL_PLATFORM_RST BIT(16)
+#define BIT_WL_SECURITY_CLK BIT(15)
+
+/* 2 REG_CPU_DMEM_CON			(Offset 0x1080) */
+
+#define BIT_SHIFT_CPU_DMEM_CON 0
+#define BIT_MASK_CPU_DMEM_CON 0xff
+#define BIT_CPU_DMEM_CON(x)                                                    \
+	(((x) & BIT_MASK_CPU_DMEM_CON) << BIT_SHIFT_CPU_DMEM_CON)
+#define BIT_GET_CPU_DMEM_CON(x)                                                \
+	(((x) >> BIT_SHIFT_CPU_DMEM_CON) & BIT_MASK_CPU_DMEM_CON)
+
+/* 2 REG_BOOT_REASON				(Offset 0x1088) */
+
+#define BIT_SHIFT_BOOT_REASON 0
+#define BIT_MASK_BOOT_REASON 0x7
+#define BIT_BOOT_REASON(x)                                                     \
+	(((x) & BIT_MASK_BOOT_REASON) << BIT_SHIFT_BOOT_REASON)
+#define BIT_GET_BOOT_REASON(x)                                                 \
+	(((x) >> BIT_SHIFT_BOOT_REASON) & BIT_MASK_BOOT_REASON)
+
+/* 2 REG_NFCPAD_CTRL				(Offset 0x10A8) */
+
+#define BIT_PAD_SHUTDW BIT(18)
+#define BIT_SYSON_NFC_PAD BIT(17)
+#define BIT_NFC_INT_PAD_CTRL BIT(16)
+#define BIT_NFC_RFDIS_PAD_CTRL BIT(15)
+#define BIT_NFC_CLK_PAD_CTRL BIT(14)
+#define BIT_NFC_DATA_PAD_CTRL BIT(13)
+#define BIT_NFC_PAD_PULL_CTRL BIT(12)
+
+#define BIT_SHIFT_NFCPAD_IO_SEL 8
+#define BIT_MASK_NFCPAD_IO_SEL 0xf
+#define BIT_NFCPAD_IO_SEL(x)                                                   \
+	(((x) & BIT_MASK_NFCPAD_IO_SEL) << BIT_SHIFT_NFCPAD_IO_SEL)
+#define BIT_GET_NFCPAD_IO_SEL(x)                                               \
+	(((x) >> BIT_SHIFT_NFCPAD_IO_SEL) & BIT_MASK_NFCPAD_IO_SEL)
+
+#define BIT_SHIFT_NFCPAD_OUT 4
+#define BIT_MASK_NFCPAD_OUT 0xf
+#define BIT_NFCPAD_OUT(x) (((x) & BIT_MASK_NFCPAD_OUT) << BIT_SHIFT_NFCPAD_OUT)
+#define BIT_GET_NFCPAD_OUT(x)                                                  \
+	(((x) >> BIT_SHIFT_NFCPAD_OUT) & BIT_MASK_NFCPAD_OUT)
+
+#define BIT_SHIFT_NFCPAD_IN 0
+#define BIT_MASK_NFCPAD_IN 0xf
+#define BIT_NFCPAD_IN(x) (((x) & BIT_MASK_NFCPAD_IN) << BIT_SHIFT_NFCPAD_IN)
+#define BIT_GET_NFCPAD_IN(x) (((x) >> BIT_SHIFT_NFCPAD_IN) & BIT_MASK_NFCPAD_IN)
+
+/* 2 REG_HIMR2				(Offset 0x10B0) */
+
+#define BIT_BCNDMAINT_P4_MSK BIT(31)
+#define BIT_BCNDMAINT_P3_MSK BIT(30)
+#define BIT_BCNDMAINT_P2_MSK BIT(29)
+#define BIT_BCNDMAINT_P1_MSK BIT(28)
+#define BIT_ATIMEND7_MSK BIT(22)
+#define BIT_ATIMEND6_MSK BIT(21)
+#define BIT_ATIMEND5_MSK BIT(20)
+#define BIT_ATIMEND4_MSK BIT(19)
+#define BIT_ATIMEND3_MSK BIT(18)
+#define BIT_ATIMEND2_MSK BIT(17)
+#define BIT_ATIMEND1_MSK BIT(16)
+#define BIT_TXBCN7OK_MSK BIT(14)
+#define BIT_TXBCN6OK_MSK BIT(13)
+#define BIT_TXBCN5OK_MSK BIT(12)
+#define BIT_TXBCN4OK_MSK BIT(11)
+#define BIT_TXBCN3OK_MSK BIT(10)
+#define BIT_TXBCN2OK_MSK BIT(9)
+#define BIT_TXBCN1OK_MSK_V1 BIT(8)
+#define BIT_TXBCN7ERR_MSK BIT(6)
+#define BIT_TXBCN6ERR_MSK BIT(5)
+#define BIT_TXBCN5ERR_MSK BIT(4)
+#define BIT_TXBCN4ERR_MSK BIT(3)
+#define BIT_TXBCN3ERR_MSK BIT(2)
+#define BIT_TXBCN2ERR_MSK BIT(1)
+#define BIT_TXBCN1ERR_MSK_V1 BIT(0)
+
+/* 2 REG_HISR2				(Offset 0x10B4) */
+
+#define BIT_BCNDMAINT_P4 BIT(31)
+#define BIT_BCNDMAINT_P3 BIT(30)
+#define BIT_BCNDMAINT_P2 BIT(29)
+#define BIT_BCNDMAINT_P1 BIT(28)
+#define BIT_ATIMEND7 BIT(22)
+#define BIT_ATIMEND6 BIT(21)
+#define BIT_ATIMEND5 BIT(20)
+#define BIT_ATIMEND4 BIT(19)
+#define BIT_ATIMEND3 BIT(18)
+#define BIT_ATIMEND2 BIT(17)
+#define BIT_ATIMEND1 BIT(16)
+#define BIT_TXBCN7OK BIT(14)
+#define BIT_TXBCN6OK BIT(13)
+#define BIT_TXBCN5OK BIT(12)
+#define BIT_TXBCN4OK BIT(11)
+#define BIT_TXBCN3OK BIT(10)
+#define BIT_TXBCN2OK BIT(9)
+#define BIT_TXBCN1OK BIT(8)
+#define BIT_TXBCN7ERR BIT(6)
+#define BIT_TXBCN6ERR BIT(5)
+#define BIT_TXBCN5ERR BIT(4)
+#define BIT_TXBCN4ERR BIT(3)
+#define BIT_TXBCN3ERR BIT(2)
+#define BIT_TXBCN2ERR BIT(1)
+#define BIT_TXBCN1ERR BIT(0)
+
+/* 2 REG_HIMR3				(Offset 0x10B8) */
+
+#define BIT_WDT_PLATFORM_INT_MSK BIT(18)
+#define BIT_WDT_CPU_INT_MSK BIT(17)
+
+/* 2 REG_HIMR3				(Offset 0x10B8) */
+
+#define BIT_SETH2CDOK_MASK BIT(16)
+#define BIT_H2C_CMD_FULL_MASK BIT(15)
+#define BIT_PWR_INT_127_MASK BIT(14)
+#define BIT_TXSHORTCUT_TXDESUPDATEOK_MASK BIT(13)
+#define BIT_TXSHORTCUT_BKUPDATEOK_MASK BIT(12)
+#define BIT_TXSHORTCUT_BEUPDATEOK_MASK BIT(11)
+#define BIT_TXSHORTCUT_VIUPDATEOK_MAS BIT(10)
+#define BIT_TXSHORTCUT_VOUPDATEOK_MASK BIT(9)
+#define BIT_PWR_INT_127_MASK_V1 BIT(8)
+#define BIT_PWR_INT_126TO96_MASK BIT(7)
+#define BIT_PWR_INT_95TO64_MASK BIT(6)
+#define BIT_PWR_INT_63TO32_MASK BIT(5)
+#define BIT_PWR_INT_31TO0_MASK BIT(4)
+#define BIT_DDMA0_LP_INT_MSK BIT(1)
+#define BIT_DDMA0_HP_INT_MSK BIT(0)
+
+/* 2 REG_HISR3				(Offset 0x10BC) */
+
+#define BIT_WDT_PLATFORM_INT BIT(18)
+#define BIT_WDT_CPU_INT BIT(17)
+
+/* 2 REG_HISR3				(Offset 0x10BC) */
+
+#define BIT_SETH2CDOK BIT(16)
+#define BIT_H2C_CMD_FULL BIT(15)
+#define BIT_PWR_INT_127 BIT(14)
+#define BIT_TXSHORTCUT_TXDESUPDATEOK BIT(13)
+#define BIT_TXSHORTCUT_BKUPDATEOK BIT(12)
+#define BIT_TXSHORTCUT_BEUPDATEOK BIT(11)
+#define BIT_TXSHORTCUT_VIUPDATEOK BIT(10)
+#define BIT_TXSHORTCUT_VOUPDATEOK BIT(9)
+#define BIT_PWR_INT_127_V1 BIT(8)
+#define BIT_PWR_INT_126TO96 BIT(7)
+#define BIT_PWR_INT_95TO64 BIT(6)
+#define BIT_PWR_INT_63TO32 BIT(5)
+#define BIT_PWR_INT_31TO0 BIT(4)
+#define BIT_DDMA0_LP_INT BIT(1)
+#define BIT_DDMA0_HP_INT BIT(0)
+
+/* 2 REG_SW_MDIO				(Offset 0x10C0) */
+
+#define BIT_DIS_TIMEOUT_IO BIT(24)
+
+/* 2 REG_SW_FLUSH				(Offset 0x10C4) */
+
+#define BIT_FLUSH_HOLDN_EN BIT(25)
+#define BIT_FLUSH_WR_EN BIT(24)
+#define BIT_SW_FLASH_CONTROL BIT(23)
+#define BIT_SW_FLASH_WEN_E BIT(19)
+#define BIT_SW_FLASH_HOLDN_E BIT(18)
+#define BIT_SW_FLASH_SO_E BIT(17)
+#define BIT_SW_FLASH_SI_E BIT(16)
+#define BIT_SW_FLASH_SK_O BIT(13)
+#define BIT_SW_FLASH_CEN_O BIT(12)
+#define BIT_SW_FLASH_WEN_O BIT(11)
+#define BIT_SW_FLASH_HOLDN_O BIT(10)
+#define BIT_SW_FLASH_SO_O BIT(9)
+#define BIT_SW_FLASH_SI_O BIT(8)
+#define BIT_SW_FLASH_WEN_I BIT(3)
+#define BIT_SW_FLASH_HOLDN_I BIT(2)
+#define BIT_SW_FLASH_SO_I BIT(1)
+#define BIT_SW_FLASH_SI_I BIT(0)
+
+/* 2 REG_H2C_PKT_READADDR			(Offset 0x10D0) */
+
+#define BIT_SHIFT_H2C_PKT_READADDR 0
+#define BIT_MASK_H2C_PKT_READADDR 0x3ffff
+#define BIT_H2C_PKT_READADDR(x)                                                \
+	(((x) & BIT_MASK_H2C_PKT_READADDR) << BIT_SHIFT_H2C_PKT_READADDR)
+#define BIT_GET_H2C_PKT_READADDR(x)                                            \
+	(((x) >> BIT_SHIFT_H2C_PKT_READADDR) & BIT_MASK_H2C_PKT_READADDR)
+
+/* 2 REG_H2C_PKT_WRITEADDR			(Offset 0x10D4) */
+
+#define BIT_SHIFT_H2C_PKT_WRITEADDR 0
+#define BIT_MASK_H2C_PKT_WRITEADDR 0x3ffff
+#define BIT_H2C_PKT_WRITEADDR(x)                                               \
+	(((x) & BIT_MASK_H2C_PKT_WRITEADDR) << BIT_SHIFT_H2C_PKT_WRITEADDR)
+#define BIT_GET_H2C_PKT_WRITEADDR(x)                                           \
+	(((x) >> BIT_SHIFT_H2C_PKT_WRITEADDR) & BIT_MASK_H2C_PKT_WRITEADDR)
+
+/* 2 REG_MEM_PWR_CRTL			(Offset 0x10D8) */
+
+#define BIT_MEM_BB_SD BIT(17)
+#define BIT_MEM_BB_DS BIT(16)
+#define BIT_MEM_BT_DS BIT(10)
+#define BIT_MEM_SDIO_LS BIT(9)
+#define BIT_MEM_SDIO_DS BIT(8)
+#define BIT_MEM_USB_LS BIT(7)
+#define BIT_MEM_USB_DS BIT(6)
+#define BIT_MEM_PCI_LS BIT(5)
+#define BIT_MEM_PCI_DS BIT(4)
+#define BIT_MEM_WLMAC_LS BIT(3)
+#define BIT_MEM_WLMAC_DS BIT(2)
+#define BIT_MEM_WLMCU_LS BIT(1)
+
+/* 2 REG_MEM_PWR_CRTL			(Offset 0x10D8) */
+
+#define BIT_MEM_WLMCU_DS BIT(0)
+
+/* 2 REG_FW_DBG0				(Offset 0x10E0) */
+
+#define BIT_SHIFT_FW_DBG0 0
+#define BIT_MASK_FW_DBG0 0xffffffffL
+#define BIT_FW_DBG0(x) (((x) & BIT_MASK_FW_DBG0) << BIT_SHIFT_FW_DBG0)
+#define BIT_GET_FW_DBG0(x) (((x) >> BIT_SHIFT_FW_DBG0) & BIT_MASK_FW_DBG0)
+
+/* 2 REG_FW_DBG1				(Offset 0x10E4) */
+
+#define BIT_SHIFT_FW_DBG1 0
+#define BIT_MASK_FW_DBG1 0xffffffffL
+#define BIT_FW_DBG1(x) (((x) & BIT_MASK_FW_DBG1) << BIT_SHIFT_FW_DBG1)
+#define BIT_GET_FW_DBG1(x) (((x) >> BIT_SHIFT_FW_DBG1) & BIT_MASK_FW_DBG1)
+
+/* 2 REG_FW_DBG2				(Offset 0x10E8) */
+
+#define BIT_SHIFT_FW_DBG2 0
+#define BIT_MASK_FW_DBG2 0xffffffffL
+#define BIT_FW_DBG2(x) (((x) & BIT_MASK_FW_DBG2) << BIT_SHIFT_FW_DBG2)
+#define BIT_GET_FW_DBG2(x) (((x) >> BIT_SHIFT_FW_DBG2) & BIT_MASK_FW_DBG2)
+
+/* 2 REG_FW_DBG3				(Offset 0x10EC) */
+
+#define BIT_SHIFT_FW_DBG3 0
+#define BIT_MASK_FW_DBG3 0xffffffffL
+#define BIT_FW_DBG3(x) (((x) & BIT_MASK_FW_DBG3) << BIT_SHIFT_FW_DBG3)
+#define BIT_GET_FW_DBG3(x) (((x) >> BIT_SHIFT_FW_DBG3) & BIT_MASK_FW_DBG3)
+
+/* 2 REG_FW_DBG4				(Offset 0x10F0) */
+
+#define BIT_SHIFT_FW_DBG4 0
+#define BIT_MASK_FW_DBG4 0xffffffffL
+#define BIT_FW_DBG4(x) (((x) & BIT_MASK_FW_DBG4) << BIT_SHIFT_FW_DBG4)
+#define BIT_GET_FW_DBG4(x) (((x) >> BIT_SHIFT_FW_DBG4) & BIT_MASK_FW_DBG4)
+
+/* 2 REG_FW_DBG5				(Offset 0x10F4) */
+
+#define BIT_SHIFT_FW_DBG5 0
+#define BIT_MASK_FW_DBG5 0xffffffffL
+#define BIT_FW_DBG5(x) (((x) & BIT_MASK_FW_DBG5) << BIT_SHIFT_FW_DBG5)
+#define BIT_GET_FW_DBG5(x) (((x) >> BIT_SHIFT_FW_DBG5) & BIT_MASK_FW_DBG5)
+
+/* 2 REG_FW_DBG6				(Offset 0x10F8) */
+
+#define BIT_SHIFT_FW_DBG6 0
+#define BIT_MASK_FW_DBG6 0xffffffffL
+#define BIT_FW_DBG6(x) (((x) & BIT_MASK_FW_DBG6) << BIT_SHIFT_FW_DBG6)
+#define BIT_GET_FW_DBG6(x) (((x) >> BIT_SHIFT_FW_DBG6) & BIT_MASK_FW_DBG6)
+
+/* 2 REG_FW_DBG7				(Offset 0x10FC) */
+
+#define BIT_SHIFT_FW_DBG7 0
+#define BIT_MASK_FW_DBG7 0xffffffffL
+#define BIT_FW_DBG7(x) (((x) & BIT_MASK_FW_DBG7) << BIT_SHIFT_FW_DBG7)
+#define BIT_GET_FW_DBG7(x) (((x) >> BIT_SHIFT_FW_DBG7) & BIT_MASK_FW_DBG7)
+
+/* 2 REG_CR_EXT				(Offset 0x1100) */
+
+#define BIT_SHIFT_PHY_REQ_DELAY 24
+#define BIT_MASK_PHY_REQ_DELAY 0xf
+#define BIT_PHY_REQ_DELAY(x)                                                   \
+	(((x) & BIT_MASK_PHY_REQ_DELAY) << BIT_SHIFT_PHY_REQ_DELAY)
+#define BIT_GET_PHY_REQ_DELAY(x)                                               \
+	(((x) >> BIT_SHIFT_PHY_REQ_DELAY) & BIT_MASK_PHY_REQ_DELAY)
+
+#define BIT_SPD_DOWN BIT(16)
+
+#define BIT_SHIFT_NETYPE4 4
+#define BIT_MASK_NETYPE4 0x3
+#define BIT_NETYPE4(x) (((x) & BIT_MASK_NETYPE4) << BIT_SHIFT_NETYPE4)
+#define BIT_GET_NETYPE4(x) (((x) >> BIT_SHIFT_NETYPE4) & BIT_MASK_NETYPE4)
+
+#define BIT_SHIFT_NETYPE3 2
+#define BIT_MASK_NETYPE3 0x3
+#define BIT_NETYPE3(x) (((x) & BIT_MASK_NETYPE3) << BIT_SHIFT_NETYPE3)
+#define BIT_GET_NETYPE3(x) (((x) >> BIT_SHIFT_NETYPE3) & BIT_MASK_NETYPE3)
+
+#define BIT_SHIFT_NETYPE2 0
+#define BIT_MASK_NETYPE2 0x3
+#define BIT_NETYPE2(x) (((x) & BIT_MASK_NETYPE2) << BIT_SHIFT_NETYPE2)
+#define BIT_GET_NETYPE2(x) (((x) >> BIT_SHIFT_NETYPE2) & BIT_MASK_NETYPE2)
+
+/* 2 REG_FWFF				(Offset 0x1114) */
+
+#define BIT_SHIFT_PKTNUM_TH_V1 24
+#define BIT_MASK_PKTNUM_TH_V1 0xff
+#define BIT_PKTNUM_TH_V1(x)                                                    \
+	(((x) & BIT_MASK_PKTNUM_TH_V1) << BIT_SHIFT_PKTNUM_TH_V1)
+#define BIT_GET_PKTNUM_TH_V1(x)                                                \
+	(((x) >> BIT_SHIFT_PKTNUM_TH_V1) & BIT_MASK_PKTNUM_TH_V1)
+
+/* 2 REG_FWFF				(Offset 0x1114) */
+
+#define BIT_SHIFT_TIMER_TH 16
+#define BIT_MASK_TIMER_TH 0xff
+#define BIT_TIMER_TH(x) (((x) & BIT_MASK_TIMER_TH) << BIT_SHIFT_TIMER_TH)
+#define BIT_GET_TIMER_TH(x) (((x) >> BIT_SHIFT_TIMER_TH) & BIT_MASK_TIMER_TH)
+
+/* 2 REG_FWFF				(Offset 0x1114) */
+
+#define BIT_SHIFT_RXPKT1ENADDR 0
+#define BIT_MASK_RXPKT1ENADDR 0xffff
+#define BIT_RXPKT1ENADDR(x)                                                    \
+	(((x) & BIT_MASK_RXPKT1ENADDR) << BIT_SHIFT_RXPKT1ENADDR)
+#define BIT_GET_RXPKT1ENADDR(x)                                                \
+	(((x) >> BIT_SHIFT_RXPKT1ENADDR) & BIT_MASK_RXPKT1ENADDR)
+
+/* 2 REG_FE2IMR				(Offset 0x1120) */
+
+#define BIT__FE4ISR__IND_MSK BIT(29)
+
+/* 2 REG_FE2IMR				(Offset 0x1120) */
+
+#define BIT_FS_TXSC_DESC_DONE_INT_EN BIT(28)
+#define BIT_FS_TXSC_BKDONE_INT_EN BIT(27)
+#define BIT_FS_TXSC_BEDONE_INT_EN BIT(26)
+#define BIT_FS_TXSC_VIDONE_INT_EN BIT(25)
+#define BIT_FS_TXSC_VODONE_INT_EN BIT(24)
+
+/* 2 REG_FE2IMR				(Offset 0x1120) */
+
+#define BIT_FS_ATIM_MB7_INT_EN BIT(23)
+#define BIT_FS_ATIM_MB6_INT_EN BIT(22)
+#define BIT_FS_ATIM_MB5_INT_EN BIT(21)
+#define BIT_FS_ATIM_MB4_INT_EN BIT(20)
+#define BIT_FS_ATIM_MB3_INT_EN BIT(19)
+#define BIT_FS_ATIM_MB2_INT_EN BIT(18)
+#define BIT_FS_ATIM_MB1_INT_EN BIT(17)
+#define BIT_FS_ATIM_MB0_INT_EN BIT(16)
+#define BIT_FS_TBTT4INT_EN BIT(11)
+#define BIT_FS_TBTT3INT_EN BIT(10)
+#define BIT_FS_TBTT2INT_EN BIT(9)
+#define BIT_FS_TBTT1INT_EN BIT(8)
+#define BIT_FS_TBTT0_MB7INT_EN BIT(7)
+#define BIT_FS_TBTT0_MB6INT_EN BIT(6)
+#define BIT_FS_TBTT0_MB5INT_EN BIT(5)
+#define BIT_FS_TBTT0_MB4INT_EN BIT(4)
+#define BIT_FS_TBTT0_MB3INT_EN BIT(3)
+#define BIT_FS_TBTT0_MB2INT_EN BIT(2)
+#define BIT_FS_TBTT0_MB1INT_EN BIT(1)
+#define BIT_FS_TBTT0_INT_EN BIT(0)
+
+/* 2 REG_FE2ISR				(Offset 0x1124) */
+
+#define BIT__FE4ISR__IND_INT BIT(29)
+
+/* 2 REG_FE2ISR				(Offset 0x1124) */
+
+#define BIT_FS_TXSC_DESC_DONE_INT BIT(28)
+#define BIT_FS_TXSC_BKDONE_INT BIT(27)
+#define BIT_FS_TXSC_BEDONE_INT BIT(26)
+#define BIT_FS_TXSC_VIDONE_INT BIT(25)
+#define BIT_FS_TXSC_VODONE_INT BIT(24)
+
+/* 2 REG_FE2ISR				(Offset 0x1124) */
+
+#define BIT_FS_ATIM_MB7_INT BIT(23)
+#define BIT_FS_ATIM_MB6_INT BIT(22)
+#define BIT_FS_ATIM_MB5_INT BIT(21)
+#define BIT_FS_ATIM_MB4_INT BIT(20)
+#define BIT_FS_ATIM_MB3_INT BIT(19)
+#define BIT_FS_ATIM_MB2_INT BIT(18)
+#define BIT_FS_ATIM_MB1_INT BIT(17)
+#define BIT_FS_ATIM_MB0_INT BIT(16)
+#define BIT_FS_TBTT4INT BIT(11)
+#define BIT_FS_TBTT3INT BIT(10)
+#define BIT_FS_TBTT2INT BIT(9)
+#define BIT_FS_TBTT1INT BIT(8)
+#define BIT_FS_TBTT0_MB7INT BIT(7)
+#define BIT_FS_TBTT0_MB6INT BIT(6)
+#define BIT_FS_TBTT0_MB5INT BIT(5)
+#define BIT_FS_TBTT0_MB4INT BIT(4)
+#define BIT_FS_TBTT0_MB3INT BIT(3)
+#define BIT_FS_TBTT0_MB2INT BIT(2)
+#define BIT_FS_TBTT0_MB1INT BIT(1)
+#define BIT_FS_TBTT0_INT BIT(0)
+
+/* 2 REG_FE3IMR				(Offset 0x1128) */
+
+#define BIT_FS_CLI3_MTI_BCNIVLEAR_INT__EN BIT(31)
+
+/* 2 REG_FE3IMR				(Offset 0x1128) */
+
+#define BIT_FS_CLI2_MTI_BCNIVLEAR_INT__EN BIT(30)
+
+/* 2 REG_FE3IMR				(Offset 0x1128) */
+
+#define BIT_FS_CLI1_MTI_BCNIVLEAR_INT__EN BIT(29)
+
+/* 2 REG_FE3IMR				(Offset 0x1128) */
+
+#define BIT_FS_CLI0_MTI_BCNIVLEAR_INT__EN BIT(28)
+
+/* 2 REG_FE3IMR				(Offset 0x1128) */
+
+#define BIT_FS_BCNDMA4_INT_EN BIT(27)
+#define BIT_FS_BCNDMA3_INT_EN BIT(26)
+#define BIT_FS_BCNDMA2_INT_EN BIT(25)
+#define BIT_FS_BCNDMA1_INT_EN BIT(24)
+#define BIT_FS_BCNDMA0_MB7_INT_EN BIT(23)
+#define BIT_FS_BCNDMA0_MB6_INT_EN BIT(22)
+#define BIT_FS_BCNDMA0_MB5_INT_EN BIT(21)
+#define BIT_FS_BCNDMA0_MB4_INT_EN BIT(20)
+#define BIT_FS_BCNDMA0_MB3_INT_EN BIT(19)
+#define BIT_FS_BCNDMA0_MB2_INT_EN BIT(18)
+#define BIT_FS_BCNDMA0_MB1_INT_EN BIT(17)
+#define BIT_FS_BCNDMA0_INT_EN BIT(16)
+#define BIT_FS_MTI_BCNIVLEAR_INT__EN BIT(15)
+#define BIT_FS_BCNERLY4_INT_EN BIT(11)
+#define BIT_FS_BCNERLY3_INT_EN BIT(10)
+#define BIT_FS_BCNERLY2_INT_EN BIT(9)
+#define BIT_FS_BCNERLY1_INT_EN BIT(8)
+#define BIT_FS_BCNERLY0_MB7INT_EN BIT(7)
+#define BIT_FS_BCNERLY0_MB6INT_EN BIT(6)
+#define BIT_FS_BCNERLY0_MB5INT_EN BIT(5)
+#define BIT_FS_BCNERLY0_MB4INT_EN BIT(4)
+#define BIT_FS_BCNERLY0_MB3INT_EN BIT(3)
+#define BIT_FS_BCNERLY0_MB2INT_EN BIT(2)
+#define BIT_FS_BCNERLY0_MB1INT_EN BIT(1)
+#define BIT_FS_BCNERLY0_INT_EN BIT(0)
+
+/* 2 REG_FE3ISR				(Offset 0x112C) */
+
+#define BIT_FS_CLI3_MTI_BCNIVLEAR_INT BIT(31)
+
+/* 2 REG_FE3ISR				(Offset 0x112C) */
+
+#define BIT_FS_CLI2_MTI_BCNIVLEAR_INT BIT(30)
+
+/* 2 REG_FE3ISR				(Offset 0x112C) */
+
+#define BIT_FS_CLI1_MTI_BCNIVLEAR_INT BIT(29)
+
+/* 2 REG_FE3ISR				(Offset 0x112C) */
+
+#define BIT_FS_CLI0_MTI_BCNIVLEAR_INT BIT(28)
+
+/* 2 REG_FE3ISR				(Offset 0x112C) */
+
+#define BIT_FS_BCNDMA4_INT BIT(27)
+#define BIT_FS_BCNDMA3_INT BIT(26)
+#define BIT_FS_BCNDMA2_INT BIT(25)
+#define BIT_FS_BCNDMA1_INT BIT(24)
+#define BIT_FS_BCNDMA0_MB7_INT BIT(23)
+#define BIT_FS_BCNDMA0_MB6_INT BIT(22)
+#define BIT_FS_BCNDMA0_MB5_INT BIT(21)
+#define BIT_FS_BCNDMA0_MB4_INT BIT(20)
+#define BIT_FS_BCNDMA0_MB3_INT BIT(19)
+#define BIT_FS_BCNDMA0_MB2_INT BIT(18)
+#define BIT_FS_BCNDMA0_MB1_INT BIT(17)
+#define BIT_FS_BCNDMA0_INT BIT(16)
+#define BIT_FS_MTI_BCNIVLEAR_INT BIT(15)
+#define BIT_FS_BCNERLY4_INT BIT(11)
+#define BIT_FS_BCNERLY3_INT BIT(10)
+#define BIT_FS_BCNERLY2_INT BIT(9)
+#define BIT_FS_BCNERLY1_INT BIT(8)
+#define BIT_FS_BCNERLY0_MB7INT BIT(7)
+#define BIT_FS_BCNERLY0_MB6INT BIT(6)
+#define BIT_FS_BCNERLY0_MB5INT BIT(5)
+#define BIT_FS_BCNERLY0_MB4INT BIT(4)
+#define BIT_FS_BCNERLY0_MB3INT BIT(3)
+#define BIT_FS_BCNERLY0_MB2INT BIT(2)
+#define BIT_FS_BCNERLY0_MB1INT BIT(1)
+#define BIT_FS_BCNERLY0_INT BIT(0)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI3_TXPKTIN_INT_EN BIT(19)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI2_TXPKTIN_INT_EN BIT(18)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI1_TXPKTIN_INT_EN BIT(17)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI0_TXPKTIN_INT_EN BIT(16)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI3_RX_UMD0_INT_EN BIT(15)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI3_RX_UMD1_INT_EN BIT(14)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI3_RX_BMD0_INT_EN BIT(13)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI3_RX_BMD1_INT_EN BIT(12)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI2_RX_UMD0_INT_EN BIT(11)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI2_RX_UMD1_INT_EN BIT(10)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI2_RX_BMD0_INT_EN BIT(9)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI2_RX_BMD1_INT_EN BIT(8)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI1_RX_UMD0_INT_EN BIT(7)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI1_RX_UMD1_INT_EN BIT(6)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI1_RX_BMD0_INT_EN BIT(5)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI1_RX_BMD1_INT_EN BIT(4)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI0_RX_UMD0_INT_EN BIT(3)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI0_RX_UMD1_INT_EN BIT(2)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI0_RX_BMD0_INT_EN BIT(1)
+
+/* 2 REG_FE4IMR				(Offset 0x1130) */
+
+#define BIT_FS_CLI0_RX_BMD1_INT_EN BIT(0)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI3_TXPKTIN_INT BIT(19)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI2_TXPKTIN_INT BIT(18)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI1_TXPKTIN_INT BIT(17)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI0_TXPKTIN_INT BIT(16)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI3_RX_UMD0_INT BIT(15)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI3_RX_UMD1_INT BIT(14)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI3_RX_BMD0_INT BIT(13)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI3_RX_BMD1_INT BIT(12)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI2_RX_UMD0_INT BIT(11)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI2_RX_UMD1_INT BIT(10)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI2_RX_BMD0_INT BIT(9)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI2_RX_BMD1_INT BIT(8)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI1_RX_UMD0_INT BIT(7)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI1_RX_UMD1_INT BIT(6)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI1_RX_BMD0_INT BIT(5)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI1_RX_BMD1_INT BIT(4)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI0_RX_UMD0_INT BIT(3)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI0_RX_UMD1_INT BIT(2)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI0_RX_BMD0_INT BIT(1)
+
+/* 2 REG_FE4ISR				(Offset 0x1134) */
+
+#define BIT_FS_CLI0_RX_BMD1_INT BIT(0)
+
+/* 2 REG_FT1IMR				(Offset 0x1138) */
+
+#define BIT__FT2ISR__IND_MSK BIT(30)
+#define BIT_FTM_PTT_INT_EN BIT(29)
+#define BIT_RXFTMREQ_INT_EN BIT(28)
+#define BIT_RXFTM_INT_EN BIT(27)
+#define BIT_TXFTM_INT_EN BIT(26)
+
+/* 2 REG_FT1IMR				(Offset 0x1138) */
+
+#define BIT_FS_H2C_CMD_OK_INT_EN BIT(25)
+#define BIT_FS_H2C_CMD_FULL_INT_EN BIT(24)
+
+/* 2 REG_FT1IMR				(Offset 0x1138) */
+
+#define BIT_FS_MACID_PWRCHANGE5_INT_EN BIT(23)
+#define BIT_FS_MACID_PWRCHANGE4_INT_EN BIT(22)
+#define BIT_FS_MACID_PWRCHANGE3_INT_EN BIT(21)
+#define BIT_FS_MACID_PWRCHANGE2_INT_EN BIT(20)
+#define BIT_FS_MACID_PWRCHANGE1_INT_EN BIT(19)
+#define BIT_FS_MACID_PWRCHANGE0_INT_EN BIT(18)
+#define BIT_FS_CTWEND2_INT_EN BIT(17)
+#define BIT_FS_CTWEND1_INT_EN BIT(16)
+#define BIT_FS_CTWEND0_INT_EN BIT(15)
+#define BIT_FS_TX_NULL1_INT_EN BIT(14)
+#define BIT_FS_TX_NULL0_INT_EN BIT(13)
+#define BIT_FS_TSF_BIT32_TOGGLE_EN BIT(12)
+#define BIT_FS_P2P_RFON2_INT_EN BIT(11)
+#define BIT_FS_P2P_RFOFF2_INT_EN BIT(10)
+#define BIT_FS_P2P_RFON1_INT_EN BIT(9)
+#define BIT_FS_P2P_RFOFF1_INT_EN BIT(8)
+#define BIT_FS_P2P_RFON0_INT_EN BIT(7)
+#define BIT_FS_P2P_RFOFF0_INT_EN BIT(6)
+#define BIT_FS_RX_UAPSDMD1_EN BIT(5)
+#define BIT_FS_RX_UAPSDMD0_EN BIT(4)
+#define BIT_FS_TRIGGER_PKT_EN BIT(3)
+#define BIT_FS_EOSP_INT_EN BIT(2)
+#define BIT_FS_RPWM2_INT_EN BIT(1)
+#define BIT_FS_RPWM_INT_EN BIT(0)
+
+/* 2 REG_FT1ISR				(Offset 0x113C) */
+
+#define BIT__FT2ISR__IND_INT BIT(30)
+#define BIT_FTM_PTT_INT BIT(29)
+#define BIT_RXFTMREQ_INT BIT(28)
+#define BIT_RXFTM_INT BIT(27)
+#define BIT_TXFTM_INT BIT(26)
+
+/* 2 REG_FT1ISR				(Offset 0x113C) */
+
+#define BIT_FS_H2C_CMD_OK_INT BIT(25)
+#define BIT_FS_H2C_CMD_FULL_INT BIT(24)
+
+/* 2 REG_FT1ISR				(Offset 0x113C) */
+
+#define BIT_FS_MACID_PWRCHANGE5_INT BIT(23)
+#define BIT_FS_MACID_PWRCHANGE4_INT BIT(22)
+#define BIT_FS_MACID_PWRCHANGE3_INT BIT(21)
+#define BIT_FS_MACID_PWRCHANGE2_INT BIT(20)
+#define BIT_FS_MACID_PWRCHANGE1_INT BIT(19)
+#define BIT_FS_MACID_PWRCHANGE0_INT BIT(18)
+#define BIT_FS_CTWEND2_INT BIT(17)
+#define BIT_FS_CTWEND1_INT BIT(16)
+#define BIT_FS_CTWEND0_INT BIT(15)
+#define BIT_FS_TX_NULL1_INT BIT(14)
+#define BIT_FS_TX_NULL0_INT BIT(13)
+#define BIT_FS_TSF_BIT32_TOGGLE_INT BIT(12)
+#define BIT_FS_P2P_RFON2_INT BIT(11)
+#define BIT_FS_P2P_RFOFF2_INT BIT(10)
+#define BIT_FS_P2P_RFON1_INT BIT(9)
+#define BIT_FS_P2P_RFOFF1_INT BIT(8)
+#define BIT_FS_P2P_RFON0_INT BIT(7)
+#define BIT_FS_P2P_RFOFF0_INT BIT(6)
+#define BIT_FS_RX_UAPSDMD1_INT BIT(5)
+#define BIT_FS_RX_UAPSDMD0_INT BIT(4)
+#define BIT_FS_TRIGGER_PKT_INT BIT(3)
+#define BIT_FS_EOSP_INT BIT(2)
+#define BIT_FS_RPWM2_INT BIT(1)
+#define BIT_FS_RPWM_INT BIT(0)
+
+/* 2 REG_SPWR0				(Offset 0x1140) */
+
+#define BIT_SHIFT_MID_31TO0 0
+#define BIT_MASK_MID_31TO0 0xffffffffL
+#define BIT_MID_31TO0(x) (((x) & BIT_MASK_MID_31TO0) << BIT_SHIFT_MID_31TO0)
+#define BIT_GET_MID_31TO0(x) (((x) >> BIT_SHIFT_MID_31TO0) & BIT_MASK_MID_31TO0)
+
+/* 2 REG_SPWR1				(Offset 0x1144) */
+
+#define BIT_SHIFT_MID_63TO32 0
+#define BIT_MASK_MID_63TO32 0xffffffffL
+#define BIT_MID_63TO32(x) (((x) & BIT_MASK_MID_63TO32) << BIT_SHIFT_MID_63TO32)
+#define BIT_GET_MID_63TO32(x)                                                  \
+	(((x) >> BIT_SHIFT_MID_63TO32) & BIT_MASK_MID_63TO32)
+
+/* 2 REG_SPWR2				(Offset 0x1148) */
+
+#define BIT_SHIFT_MID_95O64 0
+#define BIT_MASK_MID_95O64 0xffffffffL
+#define BIT_MID_95O64(x) (((x) & BIT_MASK_MID_95O64) << BIT_SHIFT_MID_95O64)
+#define BIT_GET_MID_95O64(x) (((x) >> BIT_SHIFT_MID_95O64) & BIT_MASK_MID_95O64)
+
+/* 2 REG_SPWR3				(Offset 0x114C) */
+
+#define BIT_SHIFT_MID_127TO96 0
+#define BIT_MASK_MID_127TO96 0xffffffffL
+#define BIT_MID_127TO96(x)                                                     \
+	(((x) & BIT_MASK_MID_127TO96) << BIT_SHIFT_MID_127TO96)
+#define BIT_GET_MID_127TO96(x)                                                 \
+	(((x) >> BIT_SHIFT_MID_127TO96) & BIT_MASK_MID_127TO96)
+
+/* 2 REG_POWSEQ				(Offset 0x1150) */
+
+#define BIT_SHIFT_SEQNUM_MID 16
+#define BIT_MASK_SEQNUM_MID 0xffff
+#define BIT_SEQNUM_MID(x) (((x) & BIT_MASK_SEQNUM_MID) << BIT_SHIFT_SEQNUM_MID)
+#define BIT_GET_SEQNUM_MID(x)                                                  \
+	(((x) >> BIT_SHIFT_SEQNUM_MID) & BIT_MASK_SEQNUM_MID)
+
+#define BIT_SHIFT_REF_MID 0
+#define BIT_MASK_REF_MID 0x7f
+#define BIT_REF_MID(x) (((x) & BIT_MASK_REF_MID) << BIT_SHIFT_REF_MID)
+#define BIT_GET_REF_MID(x) (((x) >> BIT_SHIFT_REF_MID) & BIT_MASK_REF_MID)
+
+/* 2 REG_TC7_CTRL_V1				(Offset 0x1158) */
+
+#define BIT_TC7INT_EN BIT(26)
+#define BIT_TC7MODE BIT(25)
+#define BIT_TC7EN BIT(24)
+
+#define BIT_SHIFT_TC7DATA 0
+#define BIT_MASK_TC7DATA 0xffffff
+#define BIT_TC7DATA(x) (((x) & BIT_MASK_TC7DATA) << BIT_SHIFT_TC7DATA)
+#define BIT_GET_TC7DATA(x) (((x) >> BIT_SHIFT_TC7DATA) & BIT_MASK_TC7DATA)
+
+/* 2 REG_TC8_CTRL_V1				(Offset 0x115C) */
+
+#define BIT_TC8INT_EN BIT(26)
+#define BIT_TC8MODE BIT(25)
+#define BIT_TC8EN BIT(24)
+
+#define BIT_SHIFT_TC8DATA 0
+#define BIT_MASK_TC8DATA 0xffffff
+#define BIT_TC8DATA(x) (((x) & BIT_MASK_TC8DATA) << BIT_SHIFT_TC8DATA)
+#define BIT_GET_TC8DATA(x) (((x) >> BIT_SHIFT_TC8DATA) & BIT_MASK_TC8DATA)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI3_RX_UAPSDMD1_EN BIT(31)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI3_RX_UAPSDMD0_EN BIT(30)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI3_TRIGGER_PKT_EN BIT(29)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI3_EOSP_INT_EN BIT(28)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI2_RX_UAPSDMD1_EN BIT(27)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI2_RX_UAPSDMD0_EN BIT(26)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI2_TRIGGER_PKT_EN BIT(25)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI2_EOSP_INT_EN BIT(24)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI1_RX_UAPSDMD1_EN BIT(23)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI1_RX_UAPSDMD0_EN BIT(22)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI1_TRIGGER_PKT_EN BIT(21)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI1_EOSP_INT_EN BIT(20)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI0_RX_UAPSDMD1_EN BIT(19)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI0_RX_UAPSDMD0_EN BIT(18)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI0_TRIGGER_PKT_EN BIT(17)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI0_EOSP_INT_EN BIT(16)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_TSF_BIT32_TOGGLE_P2P2_EN BIT(9)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_TSF_BIT32_TOGGLE_P2P1_EN BIT(8)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI3_TX_NULL1_INT_EN BIT(7)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI3_TX_NULL0_INT_EN BIT(6)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI2_TX_NULL1_INT_EN BIT(5)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI2_TX_NULL0_INT_EN BIT(4)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI1_TX_NULL1_INT_EN BIT(3)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI1_TX_NULL0_INT_EN BIT(2)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI0_TX_NULL1_INT_EN BIT(1)
+
+/* 2 REG_FT2IMR				(Offset 0x11E0) */
+
+#define BIT_FS_CLI0_TX_NULL0_INT_EN BIT(0)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI3_RX_UAPSDMD1_INT BIT(31)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI3_RX_UAPSDMD0_INT BIT(30)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI3_TRIGGER_PKT_INT BIT(29)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI3_EOSP_INT BIT(28)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI2_RX_UAPSDMD1_INT BIT(27)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI2_RX_UAPSDMD0_INT BIT(26)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI2_TRIGGER_PKT_INT BIT(25)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI2_EOSP_INT BIT(24)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI1_RX_UAPSDMD1_INT BIT(23)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI1_RX_UAPSDMD0_INT BIT(22)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI1_TRIGGER_PKT_INT BIT(21)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI1_EOSP_INT BIT(20)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI0_RX_UAPSDMD1_INT BIT(19)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI0_RX_UAPSDMD0_INT BIT(18)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI0_TRIGGER_PKT_INT BIT(17)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI0_EOSP_INT BIT(16)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_TSF_BIT32_TOGGLE_P2P2_INT BIT(9)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_TSF_BIT32_TOGGLE_P2P1_INT BIT(8)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI3_TX_NULL1_INT BIT(7)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI3_TX_NULL0_INT BIT(6)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI2_TX_NULL1_INT BIT(5)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI2_TX_NULL0_INT BIT(4)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI1_TX_NULL1_INT BIT(3)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI1_TX_NULL0_INT BIT(2)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI0_TX_NULL1_INT BIT(1)
+
+/* 2 REG_FT2ISR				(Offset 0x11E4) */
+
+#define BIT_FS_CLI0_TX_NULL0_INT BIT(0)
+
+/* 2 REG_MSG2				(Offset 0x11F0) */
+
+#define BIT_SHIFT_FW_MSG2 0
+#define BIT_MASK_FW_MSG2 0xffffffffL
+#define BIT_FW_MSG2(x) (((x) & BIT_MASK_FW_MSG2) << BIT_SHIFT_FW_MSG2)
+#define BIT_GET_FW_MSG2(x) (((x) >> BIT_SHIFT_FW_MSG2) & BIT_MASK_FW_MSG2)
+
+/* 2 REG_MSG3				(Offset 0x11F4) */
+
+#define BIT_SHIFT_FW_MSG3 0
+#define BIT_MASK_FW_MSG3 0xffffffffL
+#define BIT_FW_MSG3(x) (((x) & BIT_MASK_FW_MSG3) << BIT_SHIFT_FW_MSG3)
+#define BIT_GET_FW_MSG3(x) (((x) >> BIT_SHIFT_FW_MSG3) & BIT_MASK_FW_MSG3)
+
+/* 2 REG_MSG4				(Offset 0x11F8) */
+
+#define BIT_SHIFT_FW_MSG4 0
+#define BIT_MASK_FW_MSG4 0xffffffffL
+#define BIT_FW_MSG4(x) (((x) & BIT_MASK_FW_MSG4) << BIT_SHIFT_FW_MSG4)
+#define BIT_GET_FW_MSG4(x) (((x) >> BIT_SHIFT_FW_MSG4) & BIT_MASK_FW_MSG4)
+
+/* 2 REG_MSG5				(Offset 0x11FC) */
+
+#define BIT_SHIFT_FW_MSG5 0
+#define BIT_MASK_FW_MSG5 0xffffffffL
+#define BIT_FW_MSG5(x) (((x) & BIT_MASK_FW_MSG5) << BIT_SHIFT_FW_MSG5)
+#define BIT_GET_FW_MSG5(x) (((x) >> BIT_SHIFT_FW_MSG5) & BIT_MASK_FW_MSG5)
+
+/* 2 REG_DDMA_CH0SA				(Offset 0x1200) */
+
+#define BIT_SHIFT_DDMACH0_SA 0
+#define BIT_MASK_DDMACH0_SA 0xffffffffL
+#define BIT_DDMACH0_SA(x) (((x) & BIT_MASK_DDMACH0_SA) << BIT_SHIFT_DDMACH0_SA)
+#define BIT_GET_DDMACH0_SA(x)                                                  \
+	(((x) >> BIT_SHIFT_DDMACH0_SA) & BIT_MASK_DDMACH0_SA)
+
+/* 2 REG_DDMA_CH0DA				(Offset 0x1204) */
+
+#define BIT_SHIFT_DDMACH0_DA 0
+#define BIT_MASK_DDMACH0_DA 0xffffffffL
+#define BIT_DDMACH0_DA(x) (((x) & BIT_MASK_DDMACH0_DA) << BIT_SHIFT_DDMACH0_DA)
+#define BIT_GET_DDMACH0_DA(x)                                                  \
+	(((x) >> BIT_SHIFT_DDMACH0_DA) & BIT_MASK_DDMACH0_DA)
+
+/* 2 REG_DDMA_CH0CTRL			(Offset 0x1208) */
+
+#define BIT_DDMACH0_OWN BIT(31)
+#define BIT_DDMACH0_CHKSUM_EN BIT(29)
+#define BIT_DDMACH0_DA_W_DISABLE BIT(28)
+#define BIT_DDMACH0_CHKSUM_STS BIT(27)
+#define BIT_DDMACH0_DDMA_MODE BIT(26)
+#define BIT_DDMACH0_RESET_CHKSUM_STS BIT(25)
+#define BIT_DDMACH0_CHKSUM_CONT BIT(24)
+
+#define BIT_SHIFT_DDMACH0_DLEN 0
+#define BIT_MASK_DDMACH0_DLEN 0x3ffff
+#define BIT_DDMACH0_DLEN(x)                                                    \
+	(((x) & BIT_MASK_DDMACH0_DLEN) << BIT_SHIFT_DDMACH0_DLEN)
+#define BIT_GET_DDMACH0_DLEN(x)                                                \
+	(((x) >> BIT_SHIFT_DDMACH0_DLEN) & BIT_MASK_DDMACH0_DLEN)
+
+/* 2 REG_DDMA_CH1SA				(Offset 0x1210) */
+
+#define BIT_SHIFT_DDMACH1_SA 0
+#define BIT_MASK_DDMACH1_SA 0xffffffffL
+#define BIT_DDMACH1_SA(x) (((x) & BIT_MASK_DDMACH1_SA) << BIT_SHIFT_DDMACH1_SA)
+#define BIT_GET_DDMACH1_SA(x)                                                  \
+	(((x) >> BIT_SHIFT_DDMACH1_SA) & BIT_MASK_DDMACH1_SA)
+
+/* 2 REG_DDMA_CH1DA				(Offset 0x1214) */
+
+#define BIT_SHIFT_DDMACH1_DA 0
+#define BIT_MASK_DDMACH1_DA 0xffffffffL
+#define BIT_DDMACH1_DA(x) (((x) & BIT_MASK_DDMACH1_DA) << BIT_SHIFT_DDMACH1_DA)
+#define BIT_GET_DDMACH1_DA(x)                                                  \
+	(((x) >> BIT_SHIFT_DDMACH1_DA) & BIT_MASK_DDMACH1_DA)
+
+/* 2 REG_DDMA_CH1CTRL			(Offset 0x1218) */
+
+#define BIT_DDMACH1_OWN BIT(31)
+#define BIT_DDMACH1_CHKSUM_EN BIT(29)
+#define BIT_DDMACH1_DA_W_DISABLE BIT(28)
+#define BIT_DDMACH1_CHKSUM_STS BIT(27)
+#define BIT_DDMACH1_DDMA_MODE BIT(26)
+#define BIT_DDMACH1_RESET_CHKSUM_STS BIT(25)
+#define BIT_DDMACH1_CHKSUM_CONT BIT(24)
+
+#define BIT_SHIFT_DDMACH1_DLEN 0
+#define BIT_MASK_DDMACH1_DLEN 0x3ffff
+#define BIT_DDMACH1_DLEN(x)                                                    \
+	(((x) & BIT_MASK_DDMACH1_DLEN) << BIT_SHIFT_DDMACH1_DLEN)
+#define BIT_GET_DDMACH1_DLEN(x)                                                \
+	(((x) >> BIT_SHIFT_DDMACH1_DLEN) & BIT_MASK_DDMACH1_DLEN)
+
+/* 2 REG_DDMA_CH2SA				(Offset 0x1220) */
+
+#define BIT_SHIFT_DDMACH2_SA 0
+#define BIT_MASK_DDMACH2_SA 0xffffffffL
+#define BIT_DDMACH2_SA(x) (((x) & BIT_MASK_DDMACH2_SA) << BIT_SHIFT_DDMACH2_SA)
+#define BIT_GET_DDMACH2_SA(x)                                                  \
+	(((x) >> BIT_SHIFT_DDMACH2_SA) & BIT_MASK_DDMACH2_SA)
+
+/* 2 REG_DDMA_CH2DA				(Offset 0x1224) */
+
+#define BIT_SHIFT_DDMACH2_DA 0
+#define BIT_MASK_DDMACH2_DA 0xffffffffL
+#define BIT_DDMACH2_DA(x) (((x) & BIT_MASK_DDMACH2_DA) << BIT_SHIFT_DDMACH2_DA)
+#define BIT_GET_DDMACH2_DA(x)                                                  \
+	(((x) >> BIT_SHIFT_DDMACH2_DA) & BIT_MASK_DDMACH2_DA)
+
+/* 2 REG_DDMA_CH2CTRL			(Offset 0x1228) */
+
+#define BIT_DDMACH2_OWN BIT(31)
+#define BIT_DDMACH2_CHKSUM_EN BIT(29)
+#define BIT_DDMACH2_DA_W_DISABLE BIT(28)
+#define BIT_DDMACH2_CHKSUM_STS BIT(27)
+#define BIT_DDMACH2_DDMA_MODE BIT(26)
+#define BIT_DDMACH2_RESET_CHKSUM_STS BIT(25)
+#define BIT_DDMACH2_CHKSUM_CONT BIT(24)
+
+#define BIT_SHIFT_DDMACH2_DLEN 0
+#define BIT_MASK_DDMACH2_DLEN 0x3ffff
+#define BIT_DDMACH2_DLEN(x)                                                    \
+	(((x) & BIT_MASK_DDMACH2_DLEN) << BIT_SHIFT_DDMACH2_DLEN)
+#define BIT_GET_DDMACH2_DLEN(x)                                                \
+	(((x) >> BIT_SHIFT_DDMACH2_DLEN) & BIT_MASK_DDMACH2_DLEN)
+
+/* 2 REG_DDMA_CH3SA				(Offset 0x1230) */
+
+#define BIT_SHIFT_DDMACH3_SA 0
+#define BIT_MASK_DDMACH3_SA 0xffffffffL
+#define BIT_DDMACH3_SA(x) (((x) & BIT_MASK_DDMACH3_SA) << BIT_SHIFT_DDMACH3_SA)
+#define BIT_GET_DDMACH3_SA(x)                                                  \
+	(((x) >> BIT_SHIFT_DDMACH3_SA) & BIT_MASK_DDMACH3_SA)
+
+/* 2 REG_DDMA_CH3DA				(Offset 0x1234) */
+
+#define BIT_SHIFT_DDMACH3_DA 0
+#define BIT_MASK_DDMACH3_DA 0xffffffffL
+#define BIT_DDMACH3_DA(x) (((x) & BIT_MASK_DDMACH3_DA) << BIT_SHIFT_DDMACH3_DA)
+#define BIT_GET_DDMACH3_DA(x)                                                  \
+	(((x) >> BIT_SHIFT_DDMACH3_DA) & BIT_MASK_DDMACH3_DA)
+
+/* 2 REG_DDMA_CH3CTRL			(Offset 0x1238) */
+
+#define BIT_DDMACH3_OWN BIT(31)
+#define BIT_DDMACH3_CHKSUM_EN BIT(29)
+#define BIT_DDMACH3_DA_W_DISABLE BIT(28)
+#define BIT_DDMACH3_CHKSUM_STS BIT(27)
+#define BIT_DDMACH3_DDMA_MODE BIT(26)
+#define BIT_DDMACH3_RESET_CHKSUM_STS BIT(25)
+#define BIT_DDMACH3_CHKSUM_CONT BIT(24)
+
+#define BIT_SHIFT_DDMACH3_DLEN 0
+#define BIT_MASK_DDMACH3_DLEN 0x3ffff
+#define BIT_DDMACH3_DLEN(x)                                                    \
+	(((x) & BIT_MASK_DDMACH3_DLEN) << BIT_SHIFT_DDMACH3_DLEN)
+#define BIT_GET_DDMACH3_DLEN(x)                                                \
+	(((x) >> BIT_SHIFT_DDMACH3_DLEN) & BIT_MASK_DDMACH3_DLEN)
+
+/* 2 REG_DDMA_CH4SA				(Offset 0x1240) */
+
+#define BIT_SHIFT_DDMACH4_SA 0
+#define BIT_MASK_DDMACH4_SA 0xffffffffL
+#define BIT_DDMACH4_SA(x) (((x) & BIT_MASK_DDMACH4_SA) << BIT_SHIFT_DDMACH4_SA)
+#define BIT_GET_DDMACH4_SA(x)                                                  \
+	(((x) >> BIT_SHIFT_DDMACH4_SA) & BIT_MASK_DDMACH4_SA)
+
+/* 2 REG_DDMA_CH4DA				(Offset 0x1244) */
+
+#define BIT_SHIFT_DDMACH4_DA 0
+#define BIT_MASK_DDMACH4_DA 0xffffffffL
+#define BIT_DDMACH4_DA(x) (((x) & BIT_MASK_DDMACH4_DA) << BIT_SHIFT_DDMACH4_DA)
+#define BIT_GET_DDMACH4_DA(x)                                                  \
+	(((x) >> BIT_SHIFT_DDMACH4_DA) & BIT_MASK_DDMACH4_DA)
+
+/* 2 REG_DDMA_CH4CTRL			(Offset 0x1248) */
+
+#define BIT_DDMACH4_OWN BIT(31)
+#define BIT_DDMACH4_CHKSUM_EN BIT(29)
+#define BIT_DDMACH4_DA_W_DISABLE BIT(28)
+#define BIT_DDMACH4_CHKSUM_STS BIT(27)
+#define BIT_DDMACH4_DDMA_MODE BIT(26)
+#define BIT_DDMACH4_RESET_CHKSUM_STS BIT(25)
+#define BIT_DDMACH4_CHKSUM_CONT BIT(24)
+
+#define BIT_SHIFT_DDMACH4_DLEN 0
+#define BIT_MASK_DDMACH4_DLEN 0x3ffff
+#define BIT_DDMACH4_DLEN(x)                                                    \
+	(((x) & BIT_MASK_DDMACH4_DLEN) << BIT_SHIFT_DDMACH4_DLEN)
+#define BIT_GET_DDMACH4_DLEN(x)                                                \
+	(((x) >> BIT_SHIFT_DDMACH4_DLEN) & BIT_MASK_DDMACH4_DLEN)
+
+/* 2 REG_DDMA_CH5SA				(Offset 0x1250) */
+
+#define BIT_SHIFT_DDMACH5_SA 0
+#define BIT_MASK_DDMACH5_SA 0xffffffffL
+#define BIT_DDMACH5_SA(x) (((x) & BIT_MASK_DDMACH5_SA) << BIT_SHIFT_DDMACH5_SA)
+#define BIT_GET_DDMACH5_SA(x)                                                  \
+	(((x) >> BIT_SHIFT_DDMACH5_SA) & BIT_MASK_DDMACH5_SA)
+
+/* 2 REG_DDMA_CH5DA				(Offset 0x1254) */
+
+#define BIT_DDMACH5_OWN BIT(31)
+#define BIT_DDMACH5_CHKSUM_EN BIT(29)
+#define BIT_DDMACH5_DA_W_DISABLE BIT(28)
+#define BIT_DDMACH5_CHKSUM_STS BIT(27)
+#define BIT_DDMACH5_DDMA_MODE BIT(26)
+#define BIT_DDMACH5_RESET_CHKSUM_STS BIT(25)
+#define BIT_DDMACH5_CHKSUM_CONT BIT(24)
+
+#define BIT_SHIFT_DDMACH5_DA 0
+#define BIT_MASK_DDMACH5_DA 0xffffffffL
+#define BIT_DDMACH5_DA(x) (((x) & BIT_MASK_DDMACH5_DA) << BIT_SHIFT_DDMACH5_DA)
+#define BIT_GET_DDMACH5_DA(x)                                                  \
+	(((x) >> BIT_SHIFT_DDMACH5_DA) & BIT_MASK_DDMACH5_DA)
+
+#define BIT_SHIFT_DDMACH5_DLEN 0
+#define BIT_MASK_DDMACH5_DLEN 0x3ffff
+#define BIT_DDMACH5_DLEN(x)                                                    \
+	(((x) & BIT_MASK_DDMACH5_DLEN) << BIT_SHIFT_DDMACH5_DLEN)
+#define BIT_GET_DDMACH5_DLEN(x)                                                \
+	(((x) >> BIT_SHIFT_DDMACH5_DLEN) & BIT_MASK_DDMACH5_DLEN)
+
+/* 2 REG_DDMA_INT_MSK			(Offset 0x12E0) */
+
+#define BIT_DDMACH5_MSK BIT(5)
+#define BIT_DDMACH4_MSK BIT(4)
+#define BIT_DDMACH3_MSK BIT(3)
+#define BIT_DDMACH2_MSK BIT(2)
+#define BIT_DDMACH1_MSK BIT(1)
+#define BIT_DDMACH0_MSK BIT(0)
+
+/* 2 REG_DDMA_CHSTATUS			(Offset 0x12E8) */
+
+#define BIT_DDMACH5_BUSY BIT(5)
+#define BIT_DDMACH4_BUSY BIT(4)
+#define BIT_DDMACH3_BUSY BIT(3)
+#define BIT_DDMACH2_BUSY BIT(2)
+#define BIT_DDMACH1_BUSY BIT(1)
+#define BIT_DDMACH0_BUSY BIT(0)
+
+/* 2 REG_DDMA_CHKSUM				(Offset 0x12F0) */
+
+#define BIT_SHIFT_IDDMA0_CHKSUM 0
+#define BIT_MASK_IDDMA0_CHKSUM 0xffff
+#define BIT_IDDMA0_CHKSUM(x)                                                   \
+	(((x) & BIT_MASK_IDDMA0_CHKSUM) << BIT_SHIFT_IDDMA0_CHKSUM)
+#define BIT_GET_IDDMA0_CHKSUM(x)                                               \
+	(((x) >> BIT_SHIFT_IDDMA0_CHKSUM) & BIT_MASK_IDDMA0_CHKSUM)
+
+/* 2 REG_DDMA_MONITOR			(Offset 0x12FC) */
+
+#define BIT_IDDMA0_PERMU_UNDERFLOW BIT(14)
+#define BIT_IDDMA0_FIFO_UNDERFLOW BIT(13)
+#define BIT_IDDMA0_FIFO_OVERFLOW BIT(12)
+#define BIT_ECRC_EN_V1 BIT(7)
+#define BIT_MDIO_RFLAG_V1 BIT(6)
+#define BIT_CH5_ERR BIT(5)
+#define BIT_MDIO_WFLAG_V1 BIT(5)
+#define BIT_CH4_ERR BIT(4)
+#define BIT_CH3_ERR BIT(3)
+#define BIT_CH2_ERR BIT(2)
+#define BIT_CH1_ERR BIT(1)
+#define BIT_CH0_ERR BIT(0)
+
+/* 2 REG_STC_INT_CS				(Offset 0x1300) */
+
+#define BIT_STC_INT_EN BIT(31)
+
+#define BIT_SHIFT_STC_INT_FLAG 16
+#define BIT_MASK_STC_INT_FLAG 0xff
+#define BIT_STC_INT_FLAG(x)                                                    \
+	(((x) & BIT_MASK_STC_INT_FLAG) << BIT_SHIFT_STC_INT_FLAG)
+#define BIT_GET_STC_INT_FLAG(x)                                                \
+	(((x) >> BIT_SHIFT_STC_INT_FLAG) & BIT_MASK_STC_INT_FLAG)
+
+#define BIT_SHIFT_STC_INT_IDX 8
+#define BIT_MASK_STC_INT_IDX 0x7
+#define BIT_STC_INT_IDX(x)                                                     \
+	(((x) & BIT_MASK_STC_INT_IDX) << BIT_SHIFT_STC_INT_IDX)
+#define BIT_GET_STC_INT_IDX(x)                                                 \
+	(((x) >> BIT_SHIFT_STC_INT_IDX) & BIT_MASK_STC_INT_IDX)
+
+#define BIT_SHIFT_STC_INT_REALTIME_CS 0
+#define BIT_MASK_STC_INT_REALTIME_CS 0x3f
+#define BIT_STC_INT_REALTIME_CS(x)                                             \
+	(((x) & BIT_MASK_STC_INT_REALTIME_CS) << BIT_SHIFT_STC_INT_REALTIME_CS)
+#define BIT_GET_STC_INT_REALTIME_CS(x)                                         \
+	(((x) >> BIT_SHIFT_STC_INT_REALTIME_CS) & BIT_MASK_STC_INT_REALTIME_CS)
+
+/* 2 REG_ST_INT_CFG				(Offset 0x1304) */
+
+#define BIT_STC_INT_GRP_EN BIT(31)
+
+#define BIT_SHIFT_STC_INT_EXPECT_LS 8
+#define BIT_MASK_STC_INT_EXPECT_LS 0x3f
+#define BIT_STC_INT_EXPECT_LS(x)                                               \
+	(((x) & BIT_MASK_STC_INT_EXPECT_LS) << BIT_SHIFT_STC_INT_EXPECT_LS)
+#define BIT_GET_STC_INT_EXPECT_LS(x)                                           \
+	(((x) >> BIT_SHIFT_STC_INT_EXPECT_LS) & BIT_MASK_STC_INT_EXPECT_LS)
+
+#define BIT_SHIFT_STC_INT_EXPECT_CS 0
+#define BIT_MASK_STC_INT_EXPECT_CS 0x3f
+#define BIT_STC_INT_EXPECT_CS(x)                                               \
+	(((x) & BIT_MASK_STC_INT_EXPECT_CS) << BIT_SHIFT_STC_INT_EXPECT_CS)
+#define BIT_GET_STC_INT_EXPECT_CS(x)                                           \
+	(((x) >> BIT_SHIFT_STC_INT_EXPECT_CS) & BIT_MASK_STC_INT_EXPECT_CS)
+
+/* 2 REG_CMU_DLY_CTRL			(Offset 0x1310) */
+
+#define BIT_CMU_DLY_EN BIT(31)
+#define BIT_CMU_DLY_MODE BIT(30)
+
+#define BIT_SHIFT_CMU_DLY_PRE_DIV 0
+#define BIT_MASK_CMU_DLY_PRE_DIV 0xff
+#define BIT_CMU_DLY_PRE_DIV(x)                                                 \
+	(((x) & BIT_MASK_CMU_DLY_PRE_DIV) << BIT_SHIFT_CMU_DLY_PRE_DIV)
+#define BIT_GET_CMU_DLY_PRE_DIV(x)                                             \
+	(((x) >> BIT_SHIFT_CMU_DLY_PRE_DIV) & BIT_MASK_CMU_DLY_PRE_DIV)
+
+/* 2 REG_CMU_DLY_CFG				(Offset 0x1314) */
+
+#define BIT_SHIFT_CMU_DLY_LTR_A2I 24
+#define BIT_MASK_CMU_DLY_LTR_A2I 0xff
+#define BIT_CMU_DLY_LTR_A2I(x)                                                 \
+	(((x) & BIT_MASK_CMU_DLY_LTR_A2I) << BIT_SHIFT_CMU_DLY_LTR_A2I)
+#define BIT_GET_CMU_DLY_LTR_A2I(x)                                             \
+	(((x) >> BIT_SHIFT_CMU_DLY_LTR_A2I) & BIT_MASK_CMU_DLY_LTR_A2I)
+
+#define BIT_SHIFT_CMU_DLY_LTR_I2A 16
+#define BIT_MASK_CMU_DLY_LTR_I2A 0xff
+#define BIT_CMU_DLY_LTR_I2A(x)                                                 \
+	(((x) & BIT_MASK_CMU_DLY_LTR_I2A) << BIT_SHIFT_CMU_DLY_LTR_I2A)
+#define BIT_GET_CMU_DLY_LTR_I2A(x)                                             \
+	(((x) >> BIT_SHIFT_CMU_DLY_LTR_I2A) & BIT_MASK_CMU_DLY_LTR_I2A)
+
+#define BIT_SHIFT_CMU_DLY_LTR_IDLE 8
+#define BIT_MASK_CMU_DLY_LTR_IDLE 0xff
+#define BIT_CMU_DLY_LTR_IDLE(x)                                                \
+	(((x) & BIT_MASK_CMU_DLY_LTR_IDLE) << BIT_SHIFT_CMU_DLY_LTR_IDLE)
+#define BIT_GET_CMU_DLY_LTR_IDLE(x)                                            \
+	(((x) >> BIT_SHIFT_CMU_DLY_LTR_IDLE) & BIT_MASK_CMU_DLY_LTR_IDLE)
+
+#define BIT_SHIFT_CMU_DLY_LTR_ACT 0
+#define BIT_MASK_CMU_DLY_LTR_ACT 0xff
+#define BIT_CMU_DLY_LTR_ACT(x)                                                 \
+	(((x) & BIT_MASK_CMU_DLY_LTR_ACT) << BIT_SHIFT_CMU_DLY_LTR_ACT)
+#define BIT_GET_CMU_DLY_LTR_ACT(x)                                             \
+	(((x) >> BIT_SHIFT_CMU_DLY_LTR_ACT) & BIT_MASK_CMU_DLY_LTR_ACT)
+
+/* 2 REG_H2CQ_TXBD_DESA			(Offset 0x1320) */
+
+#define BIT_SHIFT_H2CQ_TXBD_DESA 0
+#define BIT_MASK_H2CQ_TXBD_DESA 0xffffffffffffffffL
+#define BIT_H2CQ_TXBD_DESA(x)                                                  \
+	(((x) & BIT_MASK_H2CQ_TXBD_DESA) << BIT_SHIFT_H2CQ_TXBD_DESA)
+#define BIT_GET_H2CQ_TXBD_DESA(x)                                              \
+	(((x) >> BIT_SHIFT_H2CQ_TXBD_DESA) & BIT_MASK_H2CQ_TXBD_DESA)
+
+/* 2 REG_H2CQ_TXBD_NUM			(Offset 0x1328) */
+
+#define BIT_PCIE_H2CQ_FLAG BIT(14)
+
+/* 2 REG_H2CQ_TXBD_NUM			(Offset 0x1328) */
+
+#define BIT_SHIFT_H2CQ_DESC_MODE 12
+#define BIT_MASK_H2CQ_DESC_MODE 0x3
+#define BIT_H2CQ_DESC_MODE(x)                                                  \
+	(((x) & BIT_MASK_H2CQ_DESC_MODE) << BIT_SHIFT_H2CQ_DESC_MODE)
+#define BIT_GET_H2CQ_DESC_MODE(x)                                              \
+	(((x) >> BIT_SHIFT_H2CQ_DESC_MODE) & BIT_MASK_H2CQ_DESC_MODE)
+
+#define BIT_SHIFT_H2CQ_DESC_NUM 0
+#define BIT_MASK_H2CQ_DESC_NUM 0xfff
+#define BIT_H2CQ_DESC_NUM(x)                                                   \
+	(((x) & BIT_MASK_H2CQ_DESC_NUM) << BIT_SHIFT_H2CQ_DESC_NUM)
+#define BIT_GET_H2CQ_DESC_NUM(x)                                               \
+	(((x) >> BIT_SHIFT_H2CQ_DESC_NUM) & BIT_MASK_H2CQ_DESC_NUM)
+
+/* 2 REG_H2CQ_TXBD_IDX			(Offset 0x132C) */
+
+#define BIT_SHIFT_H2CQ_HW_IDX 16
+#define BIT_MASK_H2CQ_HW_IDX 0xfff
+#define BIT_H2CQ_HW_IDX(x)                                                     \
+	(((x) & BIT_MASK_H2CQ_HW_IDX) << BIT_SHIFT_H2CQ_HW_IDX)
+#define BIT_GET_H2CQ_HW_IDX(x)                                                 \
+	(((x) >> BIT_SHIFT_H2CQ_HW_IDX) & BIT_MASK_H2CQ_HW_IDX)
+
+#define BIT_SHIFT_H2CQ_HOST_IDX 0
+#define BIT_MASK_H2CQ_HOST_IDX 0xfff
+#define BIT_H2CQ_HOST_IDX(x)                                                   \
+	(((x) & BIT_MASK_H2CQ_HOST_IDX) << BIT_SHIFT_H2CQ_HOST_IDX)
+#define BIT_GET_H2CQ_HOST_IDX(x)                                               \
+	(((x) >> BIT_SHIFT_H2CQ_HOST_IDX) & BIT_MASK_H2CQ_HOST_IDX)
+
+/* 2 REG_H2CQ_CSR				(Offset 0x1330) */
+
+#define BIT_H2CQ_FULL BIT(31)
+#define BIT_CLR_H2CQ_HOST_IDX BIT(16)
+#define BIT_CLR_H2CQ_HW_IDX BIT(8)
+
+/* 2 REG_CHANGE_PCIE_SPEED			(Offset 0x1350) */
+
+#define BIT_CHANGE_PCIE_SPEED BIT(18)
+
+/* 2 REG_CHANGE_PCIE_SPEED			(Offset 0x1350) */
+
+#define BIT_SHIFT_GEN1_GEN2 16
+#define BIT_MASK_GEN1_GEN2 0x3
+#define BIT_GEN1_GEN2(x) (((x) & BIT_MASK_GEN1_GEN2) << BIT_SHIFT_GEN1_GEN2)
+#define BIT_GET_GEN1_GEN2(x) (((x) >> BIT_SHIFT_GEN1_GEN2) & BIT_MASK_GEN1_GEN2)
+
+/* 2 REG_CHANGE_PCIE_SPEED			(Offset 0x1350) */
+
+#define BIT_SHIFT_AUTO_HANG_RELEASE 0
+#define BIT_MASK_AUTO_HANG_RELEASE 0x7
+#define BIT_AUTO_HANG_RELEASE(x)                                               \
+	(((x) & BIT_MASK_AUTO_HANG_RELEASE) << BIT_SHIFT_AUTO_HANG_RELEASE)
+#define BIT_GET_AUTO_HANG_RELEASE(x)                                           \
+	(((x) >> BIT_SHIFT_AUTO_HANG_RELEASE) & BIT_MASK_AUTO_HANG_RELEASE)
+
+/* 2 REG_OLD_DEHANG				(Offset 0x13F4) */
+
+#define BIT_OLD_DEHANG BIT(1)
+
+/* 2 REG_Q0_Q1_INFO				(Offset 0x1400) */
+
+#define BIT_SHIFT_AC1_PKT_INFO 16
+#define BIT_MASK_AC1_PKT_INFO 0xfff
+#define BIT_AC1_PKT_INFO(x)                                                    \
+	(((x) & BIT_MASK_AC1_PKT_INFO) << BIT_SHIFT_AC1_PKT_INFO)
+#define BIT_GET_AC1_PKT_INFO(x)                                                \
+	(((x) >> BIT_SHIFT_AC1_PKT_INFO) & BIT_MASK_AC1_PKT_INFO)
+
+#define BIT_SHIFT_AC0_PKT_INFO 0
+#define BIT_MASK_AC0_PKT_INFO 0xfff
+#define BIT_AC0_PKT_INFO(x)                                                    \
+	(((x) & BIT_MASK_AC0_PKT_INFO) << BIT_SHIFT_AC0_PKT_INFO)
+#define BIT_GET_AC0_PKT_INFO(x)                                                \
+	(((x) >> BIT_SHIFT_AC0_PKT_INFO) & BIT_MASK_AC0_PKT_INFO)
+
+/* 2 REG_Q2_Q3_INFO				(Offset 0x1404) */
+
+#define BIT_SHIFT_AC3_PKT_INFO 16
+#define BIT_MASK_AC3_PKT_INFO 0xfff
+#define BIT_AC3_PKT_INFO(x)                                                    \
+	(((x) & BIT_MASK_AC3_PKT_INFO) << BIT_SHIFT_AC3_PKT_INFO)
+#define BIT_GET_AC3_PKT_INFO(x)                                                \
+	(((x) >> BIT_SHIFT_AC3_PKT_INFO) & BIT_MASK_AC3_PKT_INFO)
+
+#define BIT_SHIFT_AC2_PKT_INFO 0
+#define BIT_MASK_AC2_PKT_INFO 0xfff
+#define BIT_AC2_PKT_INFO(x)                                                    \
+	(((x) & BIT_MASK_AC2_PKT_INFO) << BIT_SHIFT_AC2_PKT_INFO)
+#define BIT_GET_AC2_PKT_INFO(x)                                                \
+	(((x) >> BIT_SHIFT_AC2_PKT_INFO) & BIT_MASK_AC2_PKT_INFO)
+
+/* 2 REG_Q4_Q5_INFO				(Offset 0x1408) */
+
+#define BIT_SHIFT_AC5_PKT_INFO 16
+#define BIT_MASK_AC5_PKT_INFO 0xfff
+#define BIT_AC5_PKT_INFO(x)                                                    \
+	(((x) & BIT_MASK_AC5_PKT_INFO) << BIT_SHIFT_AC5_PKT_INFO)
+#define BIT_GET_AC5_PKT_INFO(x)                                                \
+	(((x) >> BIT_SHIFT_AC5_PKT_INFO) & BIT_MASK_AC5_PKT_INFO)
+
+#define BIT_SHIFT_AC4_PKT_INFO 0
+#define BIT_MASK_AC4_PKT_INFO 0xfff
+#define BIT_AC4_PKT_INFO(x)                                                    \
+	(((x) & BIT_MASK_AC4_PKT_INFO) << BIT_SHIFT_AC4_PKT_INFO)
+#define BIT_GET_AC4_PKT_INFO(x)                                                \
+	(((x) >> BIT_SHIFT_AC4_PKT_INFO) & BIT_MASK_AC4_PKT_INFO)
+
+/* 2 REG_Q6_Q7_INFO				(Offset 0x140C) */
+
+#define BIT_SHIFT_AC7_PKT_INFO 16
+#define BIT_MASK_AC7_PKT_INFO 0xfff
+#define BIT_AC7_PKT_INFO(x)                                                    \
+	(((x) & BIT_MASK_AC7_PKT_INFO) << BIT_SHIFT_AC7_PKT_INFO)
+#define BIT_GET_AC7_PKT_INFO(x)                                                \
+	(((x) >> BIT_SHIFT_AC7_PKT_INFO) & BIT_MASK_AC7_PKT_INFO)
+
+#define BIT_SHIFT_AC6_PKT_INFO 0
+#define BIT_MASK_AC6_PKT_INFO 0xfff
+#define BIT_AC6_PKT_INFO(x)                                                    \
+	(((x) & BIT_MASK_AC6_PKT_INFO) << BIT_SHIFT_AC6_PKT_INFO)
+#define BIT_GET_AC6_PKT_INFO(x)                                                \
+	(((x) >> BIT_SHIFT_AC6_PKT_INFO) & BIT_MASK_AC6_PKT_INFO)
+
+/* 2 REG_MGQ_HIQ_INFO			(Offset 0x1410) */
+
+#define BIT_SHIFT_HIQ_PKT_INFO 16
+#define BIT_MASK_HIQ_PKT_INFO 0xfff
+#define BIT_HIQ_PKT_INFO(x)                                                    \
+	(((x) & BIT_MASK_HIQ_PKT_INFO) << BIT_SHIFT_HIQ_PKT_INFO)
+#define BIT_GET_HIQ_PKT_INFO(x)                                                \
+	(((x) >> BIT_SHIFT_HIQ_PKT_INFO) & BIT_MASK_HIQ_PKT_INFO)
+
+#define BIT_SHIFT_MGQ_PKT_INFO 0
+#define BIT_MASK_MGQ_PKT_INFO 0xfff
+#define BIT_MGQ_PKT_INFO(x)                                                    \
+	(((x) & BIT_MASK_MGQ_PKT_INFO) << BIT_SHIFT_MGQ_PKT_INFO)
+#define BIT_GET_MGQ_PKT_INFO(x)                                                \
+	(((x) >> BIT_SHIFT_MGQ_PKT_INFO) & BIT_MASK_MGQ_PKT_INFO)
+
+/* 2 REG_CMDQ_BCNQ_INFO			(Offset 0x1414) */
+
+#define BIT_SHIFT_CMDQ_PKT_INFO 16
+#define BIT_MASK_CMDQ_PKT_INFO 0xfff
+#define BIT_CMDQ_PKT_INFO(x)                                                   \
+	(((x) & BIT_MASK_CMDQ_PKT_INFO) << BIT_SHIFT_CMDQ_PKT_INFO)
+#define BIT_GET_CMDQ_PKT_INFO(x)                                               \
+	(((x) >> BIT_SHIFT_CMDQ_PKT_INFO) & BIT_MASK_CMDQ_PKT_INFO)
+
+/* 2 REG_CMDQ_BCNQ_INFO			(Offset 0x1414) */
+
+#define BIT_SHIFT_BCNQ_PKT_INFO 0
+#define BIT_MASK_BCNQ_PKT_INFO 0xfff
+#define BIT_BCNQ_PKT_INFO(x)                                                   \
+	(((x) & BIT_MASK_BCNQ_PKT_INFO) << BIT_SHIFT_BCNQ_PKT_INFO)
+#define BIT_GET_BCNQ_PKT_INFO(x)                                               \
+	(((x) >> BIT_SHIFT_BCNQ_PKT_INFO) & BIT_MASK_BCNQ_PKT_INFO)
+
+/* 2 REG_USEREG_SETTING			(Offset 0x1420) */
+
+#define BIT_NDPA_USEREG BIT(21)
+
+#define BIT_SHIFT_RETRY_USEREG 19
+#define BIT_MASK_RETRY_USEREG 0x3
+#define BIT_RETRY_USEREG(x)                                                    \
+	(((x) & BIT_MASK_RETRY_USEREG) << BIT_SHIFT_RETRY_USEREG)
+#define BIT_GET_RETRY_USEREG(x)                                                \
+	(((x) >> BIT_SHIFT_RETRY_USEREG) & BIT_MASK_RETRY_USEREG)
+
+#define BIT_SHIFT_TRYPKT_USEREG 17
+#define BIT_MASK_TRYPKT_USEREG 0x3
+#define BIT_TRYPKT_USEREG(x)                                                   \
+	(((x) & BIT_MASK_TRYPKT_USEREG) << BIT_SHIFT_TRYPKT_USEREG)
+#define BIT_GET_TRYPKT_USEREG(x)                                               \
+	(((x) >> BIT_SHIFT_TRYPKT_USEREG) & BIT_MASK_TRYPKT_USEREG)
+
+#define BIT_CTLPKT_USEREG BIT(16)
+
+/* 2 REG_AESIV_SETTING			(Offset 0x1424) */
+
+#define BIT_SHIFT_AESIV_OFFSET 0
+#define BIT_MASK_AESIV_OFFSET 0xfff
+#define BIT_AESIV_OFFSET(x)                                                    \
+	(((x) & BIT_MASK_AESIV_OFFSET) << BIT_SHIFT_AESIV_OFFSET)
+#define BIT_GET_AESIV_OFFSET(x)                                                \
+	(((x) >> BIT_SHIFT_AESIV_OFFSET) & BIT_MASK_AESIV_OFFSET)
+
+/* 2 REG_BF0_TIME_SETTING			(Offset 0x1428) */
+
+#define BIT_BF0_TIMER_SET BIT(31)
+#define BIT_BF0_TIMER_CLR BIT(30)
+#define BIT_BF0_UPDATE_EN BIT(29)
+#define BIT_BF0_TIMER_EN BIT(28)
+
+#define BIT_SHIFT_BF0_PRETIME_OVER 16
+#define BIT_MASK_BF0_PRETIME_OVER 0xfff
+#define BIT_BF0_PRETIME_OVER(x)                                                \
+	(((x) & BIT_MASK_BF0_PRETIME_OVER) << BIT_SHIFT_BF0_PRETIME_OVER)
+#define BIT_GET_BF0_PRETIME_OVER(x)                                            \
+	(((x) >> BIT_SHIFT_BF0_PRETIME_OVER) & BIT_MASK_BF0_PRETIME_OVER)
+
+#define BIT_SHIFT_BF0_LIFETIME 0
+#define BIT_MASK_BF0_LIFETIME 0xffff
+#define BIT_BF0_LIFETIME(x)                                                    \
+	(((x) & BIT_MASK_BF0_LIFETIME) << BIT_SHIFT_BF0_LIFETIME)
+#define BIT_GET_BF0_LIFETIME(x)                                                \
+	(((x) >> BIT_SHIFT_BF0_LIFETIME) & BIT_MASK_BF0_LIFETIME)
+
+/* 2 REG_BF1_TIME_SETTING			(Offset 0x142C) */
+
+#define BIT_BF1_TIMER_SET BIT(31)
+#define BIT_BF1_TIMER_CLR BIT(30)
+#define BIT_BF1_UPDATE_EN BIT(29)
+#define BIT_BF1_TIMER_EN BIT(28)
+
+#define BIT_SHIFT_BF1_PRETIME_OVER 16
+#define BIT_MASK_BF1_PRETIME_OVER 0xfff
+#define BIT_BF1_PRETIME_OVER(x)                                                \
+	(((x) & BIT_MASK_BF1_PRETIME_OVER) << BIT_SHIFT_BF1_PRETIME_OVER)
+#define BIT_GET_BF1_PRETIME_OVER(x)                                            \
+	(((x) >> BIT_SHIFT_BF1_PRETIME_OVER) & BIT_MASK_BF1_PRETIME_OVER)
+
+#define BIT_SHIFT_BF1_LIFETIME 0
+#define BIT_MASK_BF1_LIFETIME 0xffff
+#define BIT_BF1_LIFETIME(x)                                                    \
+	(((x) & BIT_MASK_BF1_LIFETIME) << BIT_SHIFT_BF1_LIFETIME)
+#define BIT_GET_BF1_LIFETIME(x)                                                \
+	(((x) >> BIT_SHIFT_BF1_LIFETIME) & BIT_MASK_BF1_LIFETIME)
+
+/* 2 REG_BF_TIMEOUT_EN			(Offset 0x1430) */
+
+#define BIT_EN_VHT_LDPC BIT(9)
+#define BIT_EN_HT_LDPC BIT(8)
+#define BIT_BF1_TIMEOUT_EN BIT(1)
+#define BIT_BF0_TIMEOUT_EN BIT(0)
+
+/* 2 REG_MACID_RELEASE0			(Offset 0x1434) */
+
+#define BIT_SHIFT_MACID31_0_RELEASE 0
+#define BIT_MASK_MACID31_0_RELEASE 0xffffffffL
+#define BIT_MACID31_0_RELEASE(x)                                               \
+	(((x) & BIT_MASK_MACID31_0_RELEASE) << BIT_SHIFT_MACID31_0_RELEASE)
+#define BIT_GET_MACID31_0_RELEASE(x)                                           \
+	(((x) >> BIT_SHIFT_MACID31_0_RELEASE) & BIT_MASK_MACID31_0_RELEASE)
+
+/* 2 REG_MACID_RELEASE1			(Offset 0x1438) */
+
+#define BIT_SHIFT_MACID63_32_RELEASE 0
+#define BIT_MASK_MACID63_32_RELEASE 0xffffffffL
+#define BIT_MACID63_32_RELEASE(x)                                              \
+	(((x) & BIT_MASK_MACID63_32_RELEASE) << BIT_SHIFT_MACID63_32_RELEASE)
+#define BIT_GET_MACID63_32_RELEASE(x)                                          \
+	(((x) >> BIT_SHIFT_MACID63_32_RELEASE) & BIT_MASK_MACID63_32_RELEASE)
+
+/* 2 REG_MACID_RELEASE2			(Offset 0x143C) */
+
+#define BIT_SHIFT_MACID95_64_RELEASE 0
+#define BIT_MASK_MACID95_64_RELEASE 0xffffffffL
+#define BIT_MACID95_64_RELEASE(x)                                              \
+	(((x) & BIT_MASK_MACID95_64_RELEASE) << BIT_SHIFT_MACID95_64_RELEASE)
+#define BIT_GET_MACID95_64_RELEASE(x)                                          \
+	(((x) >> BIT_SHIFT_MACID95_64_RELEASE) & BIT_MASK_MACID95_64_RELEASE)
+
+/* 2 REG_MACID_RELEASE3			(Offset 0x1440) */
+
+#define BIT_SHIFT_MACID127_96_RELEASE 0
+#define BIT_MASK_MACID127_96_RELEASE 0xffffffffL
+#define BIT_MACID127_96_RELEASE(x)                                             \
+	(((x) & BIT_MASK_MACID127_96_RELEASE) << BIT_SHIFT_MACID127_96_RELEASE)
+#define BIT_GET_MACID127_96_RELEASE(x)                                         \
+	(((x) >> BIT_SHIFT_MACID127_96_RELEASE) & BIT_MASK_MACID127_96_RELEASE)
+
+/* 2 REG_MACID_RELEASE_SETTING		(Offset 0x1444) */
+
+#define BIT_MACID_VALUE BIT(7)
+
+#define BIT_SHIFT_MACID_OFFSET 0
+#define BIT_MASK_MACID_OFFSET 0x7f
+#define BIT_MACID_OFFSET(x)                                                    \
+	(((x) & BIT_MASK_MACID_OFFSET) << BIT_SHIFT_MACID_OFFSET)
+#define BIT_GET_MACID_OFFSET(x)                                                \
+	(((x) >> BIT_SHIFT_MACID_OFFSET) & BIT_MASK_MACID_OFFSET)
+
+/* 2 REG_FAST_EDCA_VOVI_SETTING		(Offset 0x1448) */
+
+#define BIT_SHIFT_VI_FAST_EDCA_TO 24
+#define BIT_MASK_VI_FAST_EDCA_TO 0xff
+#define BIT_VI_FAST_EDCA_TO(x)                                                 \
+	(((x) & BIT_MASK_VI_FAST_EDCA_TO) << BIT_SHIFT_VI_FAST_EDCA_TO)
+#define BIT_GET_VI_FAST_EDCA_TO(x)                                             \
+	(((x) >> BIT_SHIFT_VI_FAST_EDCA_TO) & BIT_MASK_VI_FAST_EDCA_TO)
+
+#define BIT_VI_THRESHOLD_SEL BIT(23)
+
+#define BIT_SHIFT_VI_FAST_EDCA_PKT_TH 16
+#define BIT_MASK_VI_FAST_EDCA_PKT_TH 0x7f
+#define BIT_VI_FAST_EDCA_PKT_TH(x)                                             \
+	(((x) & BIT_MASK_VI_FAST_EDCA_PKT_TH) << BIT_SHIFT_VI_FAST_EDCA_PKT_TH)
+#define BIT_GET_VI_FAST_EDCA_PKT_TH(x)                                         \
+	(((x) >> BIT_SHIFT_VI_FAST_EDCA_PKT_TH) & BIT_MASK_VI_FAST_EDCA_PKT_TH)
+
+#define BIT_SHIFT_VO_FAST_EDCA_TO 8
+#define BIT_MASK_VO_FAST_EDCA_TO 0xff
+#define BIT_VO_FAST_EDCA_TO(x)                                                 \
+	(((x) & BIT_MASK_VO_FAST_EDCA_TO) << BIT_SHIFT_VO_FAST_EDCA_TO)
+#define BIT_GET_VO_FAST_EDCA_TO(x)                                             \
+	(((x) >> BIT_SHIFT_VO_FAST_EDCA_TO) & BIT_MASK_VO_FAST_EDCA_TO)
+
+#define BIT_VO_THRESHOLD_SEL BIT(7)
+
+#define BIT_SHIFT_VO_FAST_EDCA_PKT_TH 0
+#define BIT_MASK_VO_FAST_EDCA_PKT_TH 0x7f
+#define BIT_VO_FAST_EDCA_PKT_TH(x)                                             \
+	(((x) & BIT_MASK_VO_FAST_EDCA_PKT_TH) << BIT_SHIFT_VO_FAST_EDCA_PKT_TH)
+#define BIT_GET_VO_FAST_EDCA_PKT_TH(x)                                         \
+	(((x) >> BIT_SHIFT_VO_FAST_EDCA_PKT_TH) & BIT_MASK_VO_FAST_EDCA_PKT_TH)
+
+/* 2 REG_FAST_EDCA_BEBK_SETTING		(Offset 0x144C) */
+
+#define BIT_SHIFT_BK_FAST_EDCA_TO 24
+#define BIT_MASK_BK_FAST_EDCA_TO 0xff
+#define BIT_BK_FAST_EDCA_TO(x)                                                 \
+	(((x) & BIT_MASK_BK_FAST_EDCA_TO) << BIT_SHIFT_BK_FAST_EDCA_TO)
+#define BIT_GET_BK_FAST_EDCA_TO(x)                                             \
+	(((x) >> BIT_SHIFT_BK_FAST_EDCA_TO) & BIT_MASK_BK_FAST_EDCA_TO)
+
+#define BIT_BK_THRESHOLD_SEL BIT(23)
+
+#define BIT_SHIFT_BK_FAST_EDCA_PKT_TH 16
+#define BIT_MASK_BK_FAST_EDCA_PKT_TH 0x7f
+#define BIT_BK_FAST_EDCA_PKT_TH(x)                                             \
+	(((x) & BIT_MASK_BK_FAST_EDCA_PKT_TH) << BIT_SHIFT_BK_FAST_EDCA_PKT_TH)
+#define BIT_GET_BK_FAST_EDCA_PKT_TH(x)                                         \
+	(((x) >> BIT_SHIFT_BK_FAST_EDCA_PKT_TH) & BIT_MASK_BK_FAST_EDCA_PKT_TH)
+
+#define BIT_SHIFT_BE_FAST_EDCA_TO 8
+#define BIT_MASK_BE_FAST_EDCA_TO 0xff
+#define BIT_BE_FAST_EDCA_TO(x)                                                 \
+	(((x) & BIT_MASK_BE_FAST_EDCA_TO) << BIT_SHIFT_BE_FAST_EDCA_TO)
+#define BIT_GET_BE_FAST_EDCA_TO(x)                                             \
+	(((x) >> BIT_SHIFT_BE_FAST_EDCA_TO) & BIT_MASK_BE_FAST_EDCA_TO)
+
+#define BIT_BE_THRESHOLD_SEL BIT(7)
+
+#define BIT_SHIFT_BE_FAST_EDCA_PKT_TH 0
+#define BIT_MASK_BE_FAST_EDCA_PKT_TH 0x7f
+#define BIT_BE_FAST_EDCA_PKT_TH(x)                                             \
+	(((x) & BIT_MASK_BE_FAST_EDCA_PKT_TH) << BIT_SHIFT_BE_FAST_EDCA_PKT_TH)
+#define BIT_GET_BE_FAST_EDCA_PKT_TH(x)                                         \
+	(((x) >> BIT_SHIFT_BE_FAST_EDCA_PKT_TH) & BIT_MASK_BE_FAST_EDCA_PKT_TH)
+
+/* 2 REG_MACID_DROP0				(Offset 0x1450) */
+
+#define BIT_SHIFT_MACID31_0_DROP 0
+#define BIT_MASK_MACID31_0_DROP 0xffffffffL
+#define BIT_MACID31_0_DROP(x)                                                  \
+	(((x) & BIT_MASK_MACID31_0_DROP) << BIT_SHIFT_MACID31_0_DROP)
+#define BIT_GET_MACID31_0_DROP(x)                                              \
+	(((x) >> BIT_SHIFT_MACID31_0_DROP) & BIT_MASK_MACID31_0_DROP)
+
+/* 2 REG_MACID_DROP1				(Offset 0x1454) */
+
+#define BIT_SHIFT_MACID63_32_DROP 0
+#define BIT_MASK_MACID63_32_DROP 0xffffffffL
+#define BIT_MACID63_32_DROP(x)                                                 \
+	(((x) & BIT_MASK_MACID63_32_DROP) << BIT_SHIFT_MACID63_32_DROP)
+#define BIT_GET_MACID63_32_DROP(x)                                             \
+	(((x) >> BIT_SHIFT_MACID63_32_DROP) & BIT_MASK_MACID63_32_DROP)
+
+/* 2 REG_MACID_DROP2				(Offset 0x1458) */
+
+#define BIT_SHIFT_MACID95_64_DROP 0
+#define BIT_MASK_MACID95_64_DROP 0xffffffffL
+#define BIT_MACID95_64_DROP(x)                                                 \
+	(((x) & BIT_MASK_MACID95_64_DROP) << BIT_SHIFT_MACID95_64_DROP)
+#define BIT_GET_MACID95_64_DROP(x)                                             \
+	(((x) >> BIT_SHIFT_MACID95_64_DROP) & BIT_MASK_MACID95_64_DROP)
+
+/* 2 REG_MACID_DROP3				(Offset 0x145C) */
+
+#define BIT_SHIFT_MACID127_96_DROP 0
+#define BIT_MASK_MACID127_96_DROP 0xffffffffL
+#define BIT_MACID127_96_DROP(x)                                                \
+	(((x) & BIT_MASK_MACID127_96_DROP) << BIT_SHIFT_MACID127_96_DROP)
+#define BIT_GET_MACID127_96_DROP(x)                                            \
+	(((x) >> BIT_SHIFT_MACID127_96_DROP) & BIT_MASK_MACID127_96_DROP)
+
+/* 2 REG_R_MACID_RELEASE_SUCCESS_0		(Offset 0x1460) */
+
+#define BIT_SHIFT_R_MACID_RELEASE_SUCCESS_0 0
+#define BIT_MASK_R_MACID_RELEASE_SUCCESS_0 0xffffffffL
+#define BIT_R_MACID_RELEASE_SUCCESS_0(x)                                       \
+	(((x) & BIT_MASK_R_MACID_RELEASE_SUCCESS_0)                            \
+	 << BIT_SHIFT_R_MACID_RELEASE_SUCCESS_0)
+#define BIT_GET_R_MACID_RELEASE_SUCCESS_0(x)                                   \
+	(((x) >> BIT_SHIFT_R_MACID_RELEASE_SUCCESS_0) &                        \
+	 BIT_MASK_R_MACID_RELEASE_SUCCESS_0)
+
+/* 2 REG_R_MACID_RELEASE_SUCCESS_1		(Offset 0x1464) */
+
+#define BIT_SHIFT_R_MACID_RELEASE_SUCCESS_1 0
+#define BIT_MASK_R_MACID_RELEASE_SUCCESS_1 0xffffffffL
+#define BIT_R_MACID_RELEASE_SUCCESS_1(x)                                       \
+	(((x) & BIT_MASK_R_MACID_RELEASE_SUCCESS_1)                            \
+	 << BIT_SHIFT_R_MACID_RELEASE_SUCCESS_1)
+#define BIT_GET_R_MACID_RELEASE_SUCCESS_1(x)                                   \
+	(((x) >> BIT_SHIFT_R_MACID_RELEASE_SUCCESS_1) &                        \
+	 BIT_MASK_R_MACID_RELEASE_SUCCESS_1)
+
+/* 2 REG_R_MACID_RELEASE_SUCCESS_2		(Offset 0x1468) */
+
+#define BIT_SHIFT_R_MACID_RELEASE_SUCCESS_2 0
+#define BIT_MASK_R_MACID_RELEASE_SUCCESS_2 0xffffffffL
+#define BIT_R_MACID_RELEASE_SUCCESS_2(x)                                       \
+	(((x) & BIT_MASK_R_MACID_RELEASE_SUCCESS_2)                            \
+	 << BIT_SHIFT_R_MACID_RELEASE_SUCCESS_2)
+#define BIT_GET_R_MACID_RELEASE_SUCCESS_2(x)                                   \
+	(((x) >> BIT_SHIFT_R_MACID_RELEASE_SUCCESS_2) &                        \
+	 BIT_MASK_R_MACID_RELEASE_SUCCESS_2)
+
+/* 2 REG_R_MACID_RELEASE_SUCCESS_3		(Offset 0x146C) */
+
+#define BIT_SHIFT_R_MACID_RELEASE_SUCCESS_3 0
+#define BIT_MASK_R_MACID_RELEASE_SUCCESS_3 0xffffffffL
+#define BIT_R_MACID_RELEASE_SUCCESS_3(x)                                       \
+	(((x) & BIT_MASK_R_MACID_RELEASE_SUCCESS_3)                            \
+	 << BIT_SHIFT_R_MACID_RELEASE_SUCCESS_3)
+#define BIT_GET_R_MACID_RELEASE_SUCCESS_3(x)                                   \
+	(((x) >> BIT_SHIFT_R_MACID_RELEASE_SUCCESS_3) &                        \
+	 BIT_MASK_R_MACID_RELEASE_SUCCESS_3)
+
+/* 2 REG_MGG_FIFO_CRTL			(Offset 0x1470) */
+
+#define BIT_R_MGG_FIFO_EN BIT(31)
+
+#define BIT_SHIFT_R_MGG_FIFO_PG_SIZE 28
+#define BIT_MASK_R_MGG_FIFO_PG_SIZE 0x7
+#define BIT_R_MGG_FIFO_PG_SIZE(x)                                              \
+	(((x) & BIT_MASK_R_MGG_FIFO_PG_SIZE) << BIT_SHIFT_R_MGG_FIFO_PG_SIZE)
+#define BIT_GET_R_MGG_FIFO_PG_SIZE(x)                                          \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_PG_SIZE) & BIT_MASK_R_MGG_FIFO_PG_SIZE)
+
+#define BIT_SHIFT_R_MGG_FIFO_START_PG 16
+#define BIT_MASK_R_MGG_FIFO_START_PG 0xfff
+#define BIT_R_MGG_FIFO_START_PG(x)                                             \
+	(((x) & BIT_MASK_R_MGG_FIFO_START_PG) << BIT_SHIFT_R_MGG_FIFO_START_PG)
+#define BIT_GET_R_MGG_FIFO_START_PG(x)                                         \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_START_PG) & BIT_MASK_R_MGG_FIFO_START_PG)
+
+#define BIT_SHIFT_R_MGG_FIFO_SIZE 14
+#define BIT_MASK_R_MGG_FIFO_SIZE 0x3
+#define BIT_R_MGG_FIFO_SIZE(x)                                                 \
+	(((x) & BIT_MASK_R_MGG_FIFO_SIZE) << BIT_SHIFT_R_MGG_FIFO_SIZE)
+#define BIT_GET_R_MGG_FIFO_SIZE(x)                                             \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_SIZE) & BIT_MASK_R_MGG_FIFO_SIZE)
+
+#define BIT_R_MGG_FIFO_PAUSE BIT(13)
+
+#define BIT_SHIFT_R_MGG_FIFO_RPTR 8
+#define BIT_MASK_R_MGG_FIFO_RPTR 0x1f
+#define BIT_R_MGG_FIFO_RPTR(x)                                                 \
+	(((x) & BIT_MASK_R_MGG_FIFO_RPTR) << BIT_SHIFT_R_MGG_FIFO_RPTR)
+#define BIT_GET_R_MGG_FIFO_RPTR(x)                                             \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_RPTR) & BIT_MASK_R_MGG_FIFO_RPTR)
+
+#define BIT_R_MGG_FIFO_OV BIT(7)
+#define BIT_R_MGG_FIFO_WPTR_ERROR BIT(6)
+#define BIT_R_EN_CPU_LIFETIME BIT(5)
+
+#define BIT_SHIFT_R_MGG_FIFO_WPTR 0
+#define BIT_MASK_R_MGG_FIFO_WPTR 0x1f
+#define BIT_R_MGG_FIFO_WPTR(x)                                                 \
+	(((x) & BIT_MASK_R_MGG_FIFO_WPTR) << BIT_SHIFT_R_MGG_FIFO_WPTR)
+#define BIT_GET_R_MGG_FIFO_WPTR(x)                                             \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_WPTR) & BIT_MASK_R_MGG_FIFO_WPTR)
+
+/* 2 REG_MGG_FIFO_INT			(Offset 0x1474) */
+
+#define BIT_SHIFT_R_MGG_FIFO_INT_FLAG 16
+#define BIT_MASK_R_MGG_FIFO_INT_FLAG 0xffff
+#define BIT_R_MGG_FIFO_INT_FLAG(x)                                             \
+	(((x) & BIT_MASK_R_MGG_FIFO_INT_FLAG) << BIT_SHIFT_R_MGG_FIFO_INT_FLAG)
+#define BIT_GET_R_MGG_FIFO_INT_FLAG(x)                                         \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_INT_FLAG) & BIT_MASK_R_MGG_FIFO_INT_FLAG)
+
+#define BIT_SHIFT_R_MGG_FIFO_INT_MASK 0
+#define BIT_MASK_R_MGG_FIFO_INT_MASK 0xffff
+#define BIT_R_MGG_FIFO_INT_MASK(x)                                             \
+	(((x) & BIT_MASK_R_MGG_FIFO_INT_MASK) << BIT_SHIFT_R_MGG_FIFO_INT_MASK)
+#define BIT_GET_R_MGG_FIFO_INT_MASK(x)                                         \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_INT_MASK) & BIT_MASK_R_MGG_FIFO_INT_MASK)
+
+/* 2 REG_MGG_FIFO_LIFETIME			(Offset 0x1478) */
+
+#define BIT_SHIFT_R_MGG_FIFO_LIFETIME 16
+#define BIT_MASK_R_MGG_FIFO_LIFETIME 0xffff
+#define BIT_R_MGG_FIFO_LIFETIME(x)                                             \
+	(((x) & BIT_MASK_R_MGG_FIFO_LIFETIME) << BIT_SHIFT_R_MGG_FIFO_LIFETIME)
+#define BIT_GET_R_MGG_FIFO_LIFETIME(x)                                         \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_LIFETIME) & BIT_MASK_R_MGG_FIFO_LIFETIME)
+
+#define BIT_SHIFT_R_MGG_FIFO_VALID_MAP 0
+#define BIT_MASK_R_MGG_FIFO_VALID_MAP 0xffff
+#define BIT_R_MGG_FIFO_VALID_MAP(x)                                            \
+	(((x) & BIT_MASK_R_MGG_FIFO_VALID_MAP)                                 \
+	 << BIT_SHIFT_R_MGG_FIFO_VALID_MAP)
+#define BIT_GET_R_MGG_FIFO_VALID_MAP(x)                                        \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_VALID_MAP) &                             \
+	 BIT_MASK_R_MGG_FIFO_VALID_MAP)
+
+/* 2 REG_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET (Offset 0x147C) */
+
+#define BIT_SHIFT_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET 0
+#define BIT_MASK_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET 0x7f
+#define BIT_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET(x)                            \
+	(((x) & BIT_MASK_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET)                 \
+	 << BIT_SHIFT_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET)
+#define BIT_GET_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET(x)                        \
+	(((x) >> BIT_SHIFT_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET) &             \
+	 BIT_MASK_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET)
+
+#define BIT_SHIFT_P2PON_DIS_TXTIME 0
+#define BIT_MASK_P2PON_DIS_TXTIME 0xff
+#define BIT_P2PON_DIS_TXTIME(x)                                                \
+	(((x) & BIT_MASK_P2PON_DIS_TXTIME) << BIT_SHIFT_P2PON_DIS_TXTIME)
+#define BIT_GET_P2PON_DIS_TXTIME(x)                                            \
+	(((x) >> BIT_SHIFT_P2PON_DIS_TXTIME) & BIT_MASK_P2PON_DIS_TXTIME)
+
+/* 2 REG_MACID_SHCUT_OFFSET			(Offset 0x1480) */
+
+#define BIT_SHIFT_MACID_SHCUT_OFFSET_V1 0
+#define BIT_MASK_MACID_SHCUT_OFFSET_V1 0xff
+#define BIT_MACID_SHCUT_OFFSET_V1(x)                                           \
+	(((x) & BIT_MASK_MACID_SHCUT_OFFSET_V1)                                \
+	 << BIT_SHIFT_MACID_SHCUT_OFFSET_V1)
+#define BIT_GET_MACID_SHCUT_OFFSET_V1(x)                                       \
+	(((x) >> BIT_SHIFT_MACID_SHCUT_OFFSET_V1) &                            \
+	 BIT_MASK_MACID_SHCUT_OFFSET_V1)
+
+/* 2 REG_MU_TX_CTL				(Offset 0x14C0) */
+
+#define BIT_R_EN_REVERS_GTAB BIT(6)
+
+#define BIT_SHIFT_R_MU_TABLE_VALID 0
+#define BIT_MASK_R_MU_TABLE_VALID 0x3f
+#define BIT_R_MU_TABLE_VALID(x)                                                \
+	(((x) & BIT_MASK_R_MU_TABLE_VALID) << BIT_SHIFT_R_MU_TABLE_VALID)
+#define BIT_GET_R_MU_TABLE_VALID(x)                                            \
+	(((x) >> BIT_SHIFT_R_MU_TABLE_VALID) & BIT_MASK_R_MU_TABLE_VALID)
+
+#define BIT_SHIFT_R_MU_STA_GTAB_VALID 0
+#define BIT_MASK_R_MU_STA_GTAB_VALID 0xffffffffL
+#define BIT_R_MU_STA_GTAB_VALID(x)                                             \
+	(((x) & BIT_MASK_R_MU_STA_GTAB_VALID) << BIT_SHIFT_R_MU_STA_GTAB_VALID)
+#define BIT_GET_R_MU_STA_GTAB_VALID(x)                                         \
+	(((x) >> BIT_SHIFT_R_MU_STA_GTAB_VALID) & BIT_MASK_R_MU_STA_GTAB_VALID)
+
+#define BIT_SHIFT_R_MU_STA_GTAB_POSITION 0
+#define BIT_MASK_R_MU_STA_GTAB_POSITION 0xffffffffffffffffL
+#define BIT_R_MU_STA_GTAB_POSITION(x)                                          \
+	(((x) & BIT_MASK_R_MU_STA_GTAB_POSITION)                               \
+	 << BIT_SHIFT_R_MU_STA_GTAB_POSITION)
+#define BIT_GET_R_MU_STA_GTAB_POSITION(x)                                      \
+	(((x) >> BIT_SHIFT_R_MU_STA_GTAB_POSITION) &                           \
+	 BIT_MASK_R_MU_STA_GTAB_POSITION)
+
+/* 2 REG_MU_TRX_DBG_CNT			(Offset 0x14D0) */
+
+#define BIT_MU_DNGCNT_RST BIT(20)
+
+#define BIT_SHIFT_MU_DBGCNT_SEL 16
+#define BIT_MASK_MU_DBGCNT_SEL 0xf
+#define BIT_MU_DBGCNT_SEL(x)                                                   \
+	(((x) & BIT_MASK_MU_DBGCNT_SEL) << BIT_SHIFT_MU_DBGCNT_SEL)
+#define BIT_GET_MU_DBGCNT_SEL(x)                                               \
+	(((x) >> BIT_SHIFT_MU_DBGCNT_SEL) & BIT_MASK_MU_DBGCNT_SEL)
+
+#define BIT_SHIFT_MU_DNGCNT 0
+#define BIT_MASK_MU_DNGCNT 0xffff
+#define BIT_MU_DNGCNT(x) (((x) & BIT_MASK_MU_DNGCNT) << BIT_SHIFT_MU_DNGCNT)
+#define BIT_GET_MU_DNGCNT(x) (((x) >> BIT_SHIFT_MU_DNGCNT) & BIT_MASK_MU_DNGCNT)
+
+/* 2 REG_CPUMGQ_TX_TIMER			(Offset 0x1500) */
+
+#define BIT_SHIFT_CPUMGQ_TX_TIMER_V1 0
+#define BIT_MASK_CPUMGQ_TX_TIMER_V1 0xffffffffL
+#define BIT_CPUMGQ_TX_TIMER_V1(x)                                              \
+	(((x) & BIT_MASK_CPUMGQ_TX_TIMER_V1) << BIT_SHIFT_CPUMGQ_TX_TIMER_V1)
+#define BIT_GET_CPUMGQ_TX_TIMER_V1(x)                                          \
+	(((x) >> BIT_SHIFT_CPUMGQ_TX_TIMER_V1) & BIT_MASK_CPUMGQ_TX_TIMER_V1)
+
+/* 2 REG_PS_TIMER_A				(Offset 0x1504) */
+
+#define BIT_SHIFT_PS_TIMER_A_V1 0
+#define BIT_MASK_PS_TIMER_A_V1 0xffffffffL
+#define BIT_PS_TIMER_A_V1(x)                                                   \
+	(((x) & BIT_MASK_PS_TIMER_A_V1) << BIT_SHIFT_PS_TIMER_A_V1)
+#define BIT_GET_PS_TIMER_A_V1(x)                                               \
+	(((x) >> BIT_SHIFT_PS_TIMER_A_V1) & BIT_MASK_PS_TIMER_A_V1)
+
+/* 2 REG_PS_TIMER_B				(Offset 0x1508) */
+
+#define BIT_SHIFT_PS_TIMER_B_V1 0
+#define BIT_MASK_PS_TIMER_B_V1 0xffffffffL
+#define BIT_PS_TIMER_B_V1(x)                                                   \
+	(((x) & BIT_MASK_PS_TIMER_B_V1) << BIT_SHIFT_PS_TIMER_B_V1)
+#define BIT_GET_PS_TIMER_B_V1(x)                                               \
+	(((x) >> BIT_SHIFT_PS_TIMER_B_V1) & BIT_MASK_PS_TIMER_B_V1)
+
+/* 2 REG_PS_TIMER_C				(Offset 0x150C) */
+
+#define BIT_SHIFT_PS_TIMER_C_V1 0
+#define BIT_MASK_PS_TIMER_C_V1 0xffffffffL
+#define BIT_PS_TIMER_C_V1(x)                                                   \
+	(((x) & BIT_MASK_PS_TIMER_C_V1) << BIT_SHIFT_PS_TIMER_C_V1)
+#define BIT_GET_PS_TIMER_C_V1(x)                                               \
+	(((x) >> BIT_SHIFT_PS_TIMER_C_V1) & BIT_MASK_PS_TIMER_C_V1)
+
+/* 2 REG_PS_TIMER_ABC_CPUMGQ_TIMER_CRTL	(Offset 0x1510) */
+
+#define BIT_CPUMGQ_TIMER_EN BIT(31)
+#define BIT_CPUMGQ_TX_EN BIT(28)
+
+#define BIT_SHIFT_CPUMGQ_TIMER_TSF_SEL 24
+#define BIT_MASK_CPUMGQ_TIMER_TSF_SEL 0x7
+#define BIT_CPUMGQ_TIMER_TSF_SEL(x)                                            \
+	(((x) & BIT_MASK_CPUMGQ_TIMER_TSF_SEL)                                 \
+	 << BIT_SHIFT_CPUMGQ_TIMER_TSF_SEL)
+#define BIT_GET_CPUMGQ_TIMER_TSF_SEL(x)                                        \
+	(((x) >> BIT_SHIFT_CPUMGQ_TIMER_TSF_SEL) &                             \
+	 BIT_MASK_CPUMGQ_TIMER_TSF_SEL)
+
+#define BIT_PS_TIMER_C_EN BIT(23)
+
+#define BIT_SHIFT_PS_TIMER_C_TSF_SEL 16
+#define BIT_MASK_PS_TIMER_C_TSF_SEL 0x7
+#define BIT_PS_TIMER_C_TSF_SEL(x)                                              \
+	(((x) & BIT_MASK_PS_TIMER_C_TSF_SEL) << BIT_SHIFT_PS_TIMER_C_TSF_SEL)
+#define BIT_GET_PS_TIMER_C_TSF_SEL(x)                                          \
+	(((x) >> BIT_SHIFT_PS_TIMER_C_TSF_SEL) & BIT_MASK_PS_TIMER_C_TSF_SEL)
+
+#define BIT_PS_TIMER_B_EN BIT(15)
+
+#define BIT_SHIFT_PS_TIMER_B_TSF_SEL 8
+#define BIT_MASK_PS_TIMER_B_TSF_SEL 0x7
+#define BIT_PS_TIMER_B_TSF_SEL(x)                                              \
+	(((x) & BIT_MASK_PS_TIMER_B_TSF_SEL) << BIT_SHIFT_PS_TIMER_B_TSF_SEL)
+#define BIT_GET_PS_TIMER_B_TSF_SEL(x)                                          \
+	(((x) >> BIT_SHIFT_PS_TIMER_B_TSF_SEL) & BIT_MASK_PS_TIMER_B_TSF_SEL)
+
+#define BIT_PS_TIMER_A_EN BIT(7)
+
+#define BIT_SHIFT_PS_TIMER_A_TSF_SEL 0
+#define BIT_MASK_PS_TIMER_A_TSF_SEL 0x7
+#define BIT_PS_TIMER_A_TSF_SEL(x)                                              \
+	(((x) & BIT_MASK_PS_TIMER_A_TSF_SEL) << BIT_SHIFT_PS_TIMER_A_TSF_SEL)
+#define BIT_GET_PS_TIMER_A_TSF_SEL(x)                                          \
+	(((x) >> BIT_SHIFT_PS_TIMER_A_TSF_SEL) & BIT_MASK_PS_TIMER_A_TSF_SEL)
+
+/* 2 REG_CPUMGQ_TX_TIMER_EARLY		(Offset 0x1514) */
+
+#define BIT_SHIFT_CPUMGQ_TX_TIMER_EARLY 0
+#define BIT_MASK_CPUMGQ_TX_TIMER_EARLY 0xff
+#define BIT_CPUMGQ_TX_TIMER_EARLY(x)                                           \
+	(((x) & BIT_MASK_CPUMGQ_TX_TIMER_EARLY)                                \
+	 << BIT_SHIFT_CPUMGQ_TX_TIMER_EARLY)
+#define BIT_GET_CPUMGQ_TX_TIMER_EARLY(x)                                       \
+	(((x) >> BIT_SHIFT_CPUMGQ_TX_TIMER_EARLY) &                            \
+	 BIT_MASK_CPUMGQ_TX_TIMER_EARLY)
+
+/* 2 REG_PS_TIMER_A_EARLY			(Offset 0x1515) */
+
+#define BIT_SHIFT_PS_TIMER_A_EARLY 0
+#define BIT_MASK_PS_TIMER_A_EARLY 0xff
+#define BIT_PS_TIMER_A_EARLY(x)                                                \
+	(((x) & BIT_MASK_PS_TIMER_A_EARLY) << BIT_SHIFT_PS_TIMER_A_EARLY)
+#define BIT_GET_PS_TIMER_A_EARLY(x)                                            \
+	(((x) >> BIT_SHIFT_PS_TIMER_A_EARLY) & BIT_MASK_PS_TIMER_A_EARLY)
+
+/* 2 REG_PS_TIMER_B_EARLY			(Offset 0x1516) */
+
+#define BIT_SHIFT_PS_TIMER_B_EARLY 0
+#define BIT_MASK_PS_TIMER_B_EARLY 0xff
+#define BIT_PS_TIMER_B_EARLY(x)                                                \
+	(((x) & BIT_MASK_PS_TIMER_B_EARLY) << BIT_SHIFT_PS_TIMER_B_EARLY)
+#define BIT_GET_PS_TIMER_B_EARLY(x)                                            \
+	(((x) >> BIT_SHIFT_PS_TIMER_B_EARLY) & BIT_MASK_PS_TIMER_B_EARLY)
+
+/* 2 REG_PS_TIMER_C_EARLY			(Offset 0x1517) */
+
+#define BIT_SHIFT_PS_TIMER_C_EARLY 0
+#define BIT_MASK_PS_TIMER_C_EARLY 0xff
+#define BIT_PS_TIMER_C_EARLY(x)                                                \
+	(((x) & BIT_MASK_PS_TIMER_C_EARLY) << BIT_SHIFT_PS_TIMER_C_EARLY)
+#define BIT_GET_PS_TIMER_C_EARLY(x)                                            \
+	(((x) >> BIT_SHIFT_PS_TIMER_C_EARLY) & BIT_MASK_PS_TIMER_C_EARLY)
+
+/* 2 REG_BCN_PSR_RPT2			(Offset 0x1600) */
+
+#define BIT_SHIFT_DTIM_CNT2 24
+#define BIT_MASK_DTIM_CNT2 0xff
+#define BIT_DTIM_CNT2(x) (((x) & BIT_MASK_DTIM_CNT2) << BIT_SHIFT_DTIM_CNT2)
+#define BIT_GET_DTIM_CNT2(x) (((x) >> BIT_SHIFT_DTIM_CNT2) & BIT_MASK_DTIM_CNT2)
+
+#define BIT_SHIFT_DTIM_PERIOD2 16
+#define BIT_MASK_DTIM_PERIOD2 0xff
+#define BIT_DTIM_PERIOD2(x)                                                    \
+	(((x) & BIT_MASK_DTIM_PERIOD2) << BIT_SHIFT_DTIM_PERIOD2)
+#define BIT_GET_DTIM_PERIOD2(x)                                                \
+	(((x) >> BIT_SHIFT_DTIM_PERIOD2) & BIT_MASK_DTIM_PERIOD2)
+
+#define BIT_DTIM2 BIT(15)
+#define BIT_TIM2 BIT(14)
+
+#define BIT_SHIFT_PS_AID_2 0
+#define BIT_MASK_PS_AID_2 0x7ff
+#define BIT_PS_AID_2(x) (((x) & BIT_MASK_PS_AID_2) << BIT_SHIFT_PS_AID_2)
+#define BIT_GET_PS_AID_2(x) (((x) >> BIT_SHIFT_PS_AID_2) & BIT_MASK_PS_AID_2)
+
+/* 2 REG_BCN_PSR_RPT3			(Offset 0x1604) */
+
+#define BIT_SHIFT_DTIM_CNT3 24
+#define BIT_MASK_DTIM_CNT3 0xff
+#define BIT_DTIM_CNT3(x) (((x) & BIT_MASK_DTIM_CNT3) << BIT_SHIFT_DTIM_CNT3)
+#define BIT_GET_DTIM_CNT3(x) (((x) >> BIT_SHIFT_DTIM_CNT3) & BIT_MASK_DTIM_CNT3)
+
+#define BIT_SHIFT_DTIM_PERIOD3 16
+#define BIT_MASK_DTIM_PERIOD3 0xff
+#define BIT_DTIM_PERIOD3(x)                                                    \
+	(((x) & BIT_MASK_DTIM_PERIOD3) << BIT_SHIFT_DTIM_PERIOD3)
+#define BIT_GET_DTIM_PERIOD3(x)                                                \
+	(((x) >> BIT_SHIFT_DTIM_PERIOD3) & BIT_MASK_DTIM_PERIOD3)
+
+#define BIT_DTIM3 BIT(15)
+#define BIT_TIM3 BIT(14)
+
+#define BIT_SHIFT_PS_AID_3 0
+#define BIT_MASK_PS_AID_3 0x7ff
+#define BIT_PS_AID_3(x) (((x) & BIT_MASK_PS_AID_3) << BIT_SHIFT_PS_AID_3)
+#define BIT_GET_PS_AID_3(x) (((x) >> BIT_SHIFT_PS_AID_3) & BIT_MASK_PS_AID_3)
+
+/* 2 REG_BCN_PSR_RPT4			(Offset 0x1608) */
+
+#define BIT_SHIFT_DTIM_CNT4 24
+#define BIT_MASK_DTIM_CNT4 0xff
+#define BIT_DTIM_CNT4(x) (((x) & BIT_MASK_DTIM_CNT4) << BIT_SHIFT_DTIM_CNT4)
+#define BIT_GET_DTIM_CNT4(x) (((x) >> BIT_SHIFT_DTIM_CNT4) & BIT_MASK_DTIM_CNT4)
+
+#define BIT_SHIFT_DTIM_PERIOD4 16
+#define BIT_MASK_DTIM_PERIOD4 0xff
+#define BIT_DTIM_PERIOD4(x)                                                    \
+	(((x) & BIT_MASK_DTIM_PERIOD4) << BIT_SHIFT_DTIM_PERIOD4)
+#define BIT_GET_DTIM_PERIOD4(x)                                                \
+	(((x) >> BIT_SHIFT_DTIM_PERIOD4) & BIT_MASK_DTIM_PERIOD4)
+
+#define BIT_DTIM4 BIT(15)
+#define BIT_TIM4 BIT(14)
+
+#define BIT_SHIFT_PS_AID_4 0
+#define BIT_MASK_PS_AID_4 0x7ff
+#define BIT_PS_AID_4(x) (((x) & BIT_MASK_PS_AID_4) << BIT_SHIFT_PS_AID_4)
+#define BIT_GET_PS_AID_4(x) (((x) >> BIT_SHIFT_PS_AID_4) & BIT_MASK_PS_AID_4)
+
+/* 2 REG_A1_ADDR_MASK			(Offset 0x160C) */
+
+#define BIT_SHIFT_A1_ADDR_MASK 0
+#define BIT_MASK_A1_ADDR_MASK 0xffffffffL
+#define BIT_A1_ADDR_MASK(x)                                                    \
+	(((x) & BIT_MASK_A1_ADDR_MASK) << BIT_SHIFT_A1_ADDR_MASK)
+#define BIT_GET_A1_ADDR_MASK(x)                                                \
+	(((x) >> BIT_SHIFT_A1_ADDR_MASK) & BIT_MASK_A1_ADDR_MASK)
+
+/* 2 REG_MACID2				(Offset 0x1620) */
+
+#define BIT_SHIFT_MACID2 0
+#define BIT_MASK_MACID2 0xffffffffffffL
+#define BIT_MACID2(x) (((x) & BIT_MASK_MACID2) << BIT_SHIFT_MACID2)
+#define BIT_GET_MACID2(x) (((x) >> BIT_SHIFT_MACID2) & BIT_MASK_MACID2)
+
+/* 2 REG_BSSID2				(Offset 0x1628) */
+
+#define BIT_SHIFT_BSSID2 0
+#define BIT_MASK_BSSID2 0xffffffffffffL
+#define BIT_BSSID2(x) (((x) & BIT_MASK_BSSID2) << BIT_SHIFT_BSSID2)
+#define BIT_GET_BSSID2(x) (((x) >> BIT_SHIFT_BSSID2) & BIT_MASK_BSSID2)
+
+/* 2 REG_MACID3				(Offset 0x1630) */
+
+#define BIT_SHIFT_MACID3 0
+#define BIT_MASK_MACID3 0xffffffffffffL
+#define BIT_MACID3(x) (((x) & BIT_MASK_MACID3) << BIT_SHIFT_MACID3)
+#define BIT_GET_MACID3(x) (((x) >> BIT_SHIFT_MACID3) & BIT_MASK_MACID3)
+
+/* 2 REG_BSSID3				(Offset 0x1638) */
+
+#define BIT_SHIFT_BSSID3 0
+#define BIT_MASK_BSSID3 0xffffffffffffL
+#define BIT_BSSID3(x) (((x) & BIT_MASK_BSSID3) << BIT_SHIFT_BSSID3)
+#define BIT_GET_BSSID3(x) (((x) >> BIT_SHIFT_BSSID3) & BIT_MASK_BSSID3)
+
+/* 2 REG_MACID4				(Offset 0x1640) */
+
+#define BIT_SHIFT_MACID4 0
+#define BIT_MASK_MACID4 0xffffffffffffL
+#define BIT_MACID4(x) (((x) & BIT_MASK_MACID4) << BIT_SHIFT_MACID4)
+#define BIT_GET_MACID4(x) (((x) >> BIT_SHIFT_MACID4) & BIT_MASK_MACID4)
+
+/* 2 REG_BSSID4				(Offset 0x1648) */
+
+#define BIT_SHIFT_BSSID4 0
+#define BIT_MASK_BSSID4 0xffffffffffffL
+#define BIT_BSSID4(x) (((x) & BIT_MASK_BSSID4) << BIT_SHIFT_BSSID4)
+#define BIT_GET_BSSID4(x) (((x) >> BIT_SHIFT_BSSID4) & BIT_MASK_BSSID4)
+
+/* 2 REG_PWRBIT_SETTING			(Offset 0x1660) */
+
+#define BIT_CLI3_PWRBIT_OW_EN BIT(7)
+#define BIT_CLI3_PWR_ST BIT(6)
+#define BIT_CLI2_PWRBIT_OW_EN BIT(5)
+#define BIT_CLI2_PWR_ST BIT(4)
+#define BIT_CLI1_PWRBIT_OW_EN BIT(3)
+#define BIT_CLI1_PWR_ST BIT(2)
+#define BIT_CLI0_PWRBIT_OW_EN BIT(1)
+#define BIT_CLI0_PWR_ST BIT(0)
+
+/* 2 REG_WMAC_MU_BF_OPTION			(Offset 0x167C) */
+
+#define BIT_WMAC_RESP_NONSTA1_DIS BIT(7)
+
+/* 2 REG_WMAC_MU_BF_OPTION			(Offset 0x167C) */
+
+#define BIT_BIT_WMAC_TXMU_ACKPOLICY_EN BIT(6)
+
+/* 2 REG_WMAC_MU_BF_OPTION			(Offset 0x167C) */
+
+#define BIT_SHIFT_WMAC_TXMU_ACKPOLICY 4
+#define BIT_MASK_WMAC_TXMU_ACKPOLICY 0x3
+#define BIT_WMAC_TXMU_ACKPOLICY(x)                                             \
+	(((x) & BIT_MASK_WMAC_TXMU_ACKPOLICY) << BIT_SHIFT_WMAC_TXMU_ACKPOLICY)
+#define BIT_GET_WMAC_TXMU_ACKPOLICY(x)                                         \
+	(((x) >> BIT_SHIFT_WMAC_TXMU_ACKPOLICY) & BIT_MASK_WMAC_TXMU_ACKPOLICY)
+
+#define BIT_SHIFT_WMAC_MU_BFEE_PORT_SEL 1
+#define BIT_MASK_WMAC_MU_BFEE_PORT_SEL 0x7
+#define BIT_WMAC_MU_BFEE_PORT_SEL(x)                                           \
+	(((x) & BIT_MASK_WMAC_MU_BFEE_PORT_SEL)                                \
+	 << BIT_SHIFT_WMAC_MU_BFEE_PORT_SEL)
+#define BIT_GET_WMAC_MU_BFEE_PORT_SEL(x)                                       \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFEE_PORT_SEL) &                            \
+	 BIT_MASK_WMAC_MU_BFEE_PORT_SEL)
+
+#define BIT_WMAC_MU_BFEE_DIS BIT(0)
+
+/* 2 REG_WMAC_PAUSE_BB_CLR_TH		(Offset 0x167D) */
+
+#define BIT_SHIFT_WMAC_PAUSE_BB_CLR_TH 0
+#define BIT_MASK_WMAC_PAUSE_BB_CLR_TH 0xff
+#define BIT_WMAC_PAUSE_BB_CLR_TH(x)                                            \
+	(((x) & BIT_MASK_WMAC_PAUSE_BB_CLR_TH)                                 \
+	 << BIT_SHIFT_WMAC_PAUSE_BB_CLR_TH)
+#define BIT_GET_WMAC_PAUSE_BB_CLR_TH(x)                                        \
+	(((x) >> BIT_SHIFT_WMAC_PAUSE_BB_CLR_TH) &                             \
+	 BIT_MASK_WMAC_PAUSE_BB_CLR_TH)
+
+/* 2 REG_WMAC_MU_ARB				(Offset 0x167E) */
+
+#define BIT_WMAC_ARB_HW_ADAPT_EN BIT(7)
+#define BIT_WMAC_ARB_SW_EN BIT(6)
+
+#define BIT_SHIFT_WMAC_ARB_SW_STATE 0
+#define BIT_MASK_WMAC_ARB_SW_STATE 0x3f
+#define BIT_WMAC_ARB_SW_STATE(x)                                               \
+	(((x) & BIT_MASK_WMAC_ARB_SW_STATE) << BIT_SHIFT_WMAC_ARB_SW_STATE)
+#define BIT_GET_WMAC_ARB_SW_STATE(x)                                           \
+	(((x) >> BIT_SHIFT_WMAC_ARB_SW_STATE) & BIT_MASK_WMAC_ARB_SW_STATE)
+
+/* 2 REG_WMAC_MU_OPTION			(Offset 0x167F) */
+
+#define BIT_SHIFT_WMAC_MU_DBGSEL 5
+#define BIT_MASK_WMAC_MU_DBGSEL 0x3
+#define BIT_WMAC_MU_DBGSEL(x)                                                  \
+	(((x) & BIT_MASK_WMAC_MU_DBGSEL) << BIT_SHIFT_WMAC_MU_DBGSEL)
+#define BIT_GET_WMAC_MU_DBGSEL(x)                                              \
+	(((x) >> BIT_SHIFT_WMAC_MU_DBGSEL) & BIT_MASK_WMAC_MU_DBGSEL)
+
+#define BIT_SHIFT_WMAC_MU_CPRD_TIMEOUT 0
+#define BIT_MASK_WMAC_MU_CPRD_TIMEOUT 0x1f
+#define BIT_WMAC_MU_CPRD_TIMEOUT(x)                                            \
+	(((x) & BIT_MASK_WMAC_MU_CPRD_TIMEOUT)                                 \
+	 << BIT_SHIFT_WMAC_MU_CPRD_TIMEOUT)
+#define BIT_GET_WMAC_MU_CPRD_TIMEOUT(x)                                        \
+	(((x) >> BIT_SHIFT_WMAC_MU_CPRD_TIMEOUT) &                             \
+	 BIT_MASK_WMAC_MU_CPRD_TIMEOUT)
+
+/* 2 REG_WMAC_MU_BF_CTL			(Offset 0x1680) */
+
+#define BIT_WMAC_INVLD_BFPRT_CHK BIT(15)
+#define BIT_WMAC_RETXBFRPTSEQ_UPD BIT(14)
+
+#define BIT_SHIFT_WMAC_MU_BFRPTSEG_SEL 12
+#define BIT_MASK_WMAC_MU_BFRPTSEG_SEL 0x3
+#define BIT_WMAC_MU_BFRPTSEG_SEL(x)                                            \
+	(((x) & BIT_MASK_WMAC_MU_BFRPTSEG_SEL)                                 \
+	 << BIT_SHIFT_WMAC_MU_BFRPTSEG_SEL)
+#define BIT_GET_WMAC_MU_BFRPTSEG_SEL(x)                                        \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFRPTSEG_SEL) &                             \
+	 BIT_MASK_WMAC_MU_BFRPTSEG_SEL)
+
+#define BIT_SHIFT_WMAC_MU_BF_MYAID 0
+#define BIT_MASK_WMAC_MU_BF_MYAID 0xfff
+#define BIT_WMAC_MU_BF_MYAID(x)                                                \
+	(((x) & BIT_MASK_WMAC_MU_BF_MYAID) << BIT_SHIFT_WMAC_MU_BF_MYAID)
+#define BIT_GET_WMAC_MU_BF_MYAID(x)                                            \
+	(((x) >> BIT_SHIFT_WMAC_MU_BF_MYAID) & BIT_MASK_WMAC_MU_BF_MYAID)
+
+#define BIT_SHIFT_BFRPT_PARA 0
+#define BIT_MASK_BFRPT_PARA 0xfff
+#define BIT_BFRPT_PARA(x) (((x) & BIT_MASK_BFRPT_PARA) << BIT_SHIFT_BFRPT_PARA)
+#define BIT_GET_BFRPT_PARA(x)                                                  \
+	(((x) >> BIT_SHIFT_BFRPT_PARA) & BIT_MASK_BFRPT_PARA)
+
+/* 2 REG_WMAC_MU_BFRPT_PARA			(Offset 0x1682) */
+
+#define BIT_SHIFT_BIT_BFRPT_PARA_USERID_SEL 12
+#define BIT_MASK_BIT_BFRPT_PARA_USERID_SEL 0x7
+#define BIT_BIT_BFRPT_PARA_USERID_SEL(x)                                       \
+	(((x) & BIT_MASK_BIT_BFRPT_PARA_USERID_SEL)                            \
+	 << BIT_SHIFT_BIT_BFRPT_PARA_USERID_SEL)
+#define BIT_GET_BIT_BFRPT_PARA_USERID_SEL(x)                                   \
+	(((x) >> BIT_SHIFT_BIT_BFRPT_PARA_USERID_SEL) &                        \
+	 BIT_MASK_BIT_BFRPT_PARA_USERID_SEL)
+
+/* 2 REG_WMAC_ASSOCIATED_MU_BFMEE2		(Offset 0x1684) */
+
+#define BIT_STATUS_BFEE2 BIT(10)
+#define BIT_WMAC_MU_BFEE2_EN BIT(9)
+
+#define BIT_SHIFT_WMAC_MU_BFEE2_AID 0
+#define BIT_MASK_WMAC_MU_BFEE2_AID 0x1ff
+#define BIT_WMAC_MU_BFEE2_AID(x)                                               \
+	(((x) & BIT_MASK_WMAC_MU_BFEE2_AID) << BIT_SHIFT_WMAC_MU_BFEE2_AID)
+#define BIT_GET_WMAC_MU_BFEE2_AID(x)                                           \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFEE2_AID) & BIT_MASK_WMAC_MU_BFEE2_AID)
+
+/* 2 REG_WMAC_ASSOCIATED_MU_BFMEE3		(Offset 0x1686) */
+
+#define BIT_STATUS_BFEE3 BIT(10)
+#define BIT_WMAC_MU_BFEE3_EN BIT(9)
+
+#define BIT_SHIFT_WMAC_MU_BFEE3_AID 0
+#define BIT_MASK_WMAC_MU_BFEE3_AID 0x1ff
+#define BIT_WMAC_MU_BFEE3_AID(x)                                               \
+	(((x) & BIT_MASK_WMAC_MU_BFEE3_AID) << BIT_SHIFT_WMAC_MU_BFEE3_AID)
+#define BIT_GET_WMAC_MU_BFEE3_AID(x)                                           \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFEE3_AID) & BIT_MASK_WMAC_MU_BFEE3_AID)
+
+/* 2 REG_WMAC_ASSOCIATED_MU_BFMEE4		(Offset 0x1688) */
+
+#define BIT_STATUS_BFEE4 BIT(10)
+#define BIT_WMAC_MU_BFEE4_EN BIT(9)
+
+#define BIT_SHIFT_WMAC_MU_BFEE4_AID 0
+#define BIT_MASK_WMAC_MU_BFEE4_AID 0x1ff
+#define BIT_WMAC_MU_BFEE4_AID(x)                                               \
+	(((x) & BIT_MASK_WMAC_MU_BFEE4_AID) << BIT_SHIFT_WMAC_MU_BFEE4_AID)
+#define BIT_GET_WMAC_MU_BFEE4_AID(x)                                           \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFEE4_AID) & BIT_MASK_WMAC_MU_BFEE4_AID)
+
+/* 2 REG_WMAC_ASSOCIATED_MU_BFMEE5		(Offset 0x168A) */
+
+#define BIT_R_WMAC_RX_SYNCFIFO_SYNC BIT(55)
+#define BIT_R_WMAC_RXRST_DLY BIT(54)
+#define BIT_R_WMAC_SRCH_TXRPT_REF_DROP BIT(53)
+#define BIT_R_WMAC_SRCH_TXRPT_UA1 BIT(52)
+#define BIT_STATUS_BFEE5 BIT(10)
+
+/* 2 REG_WMAC_ASSOCIATED_MU_BFMEE5		(Offset 0x168A) */
+
+#define BIT_WMAC_MU_BFEE5_EN BIT(9)
+
+#define BIT_SHIFT_WMAC_MU_BFEE5_AID 0
+#define BIT_MASK_WMAC_MU_BFEE5_AID 0x1ff
+#define BIT_WMAC_MU_BFEE5_AID(x)                                               \
+	(((x) & BIT_MASK_WMAC_MU_BFEE5_AID) << BIT_SHIFT_WMAC_MU_BFEE5_AID)
+#define BIT_GET_WMAC_MU_BFEE5_AID(x)                                           \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFEE5_AID) & BIT_MASK_WMAC_MU_BFEE5_AID)
+
+/* 2 REG_WMAC_ASSOCIATED_MU_BFMEE6		(Offset 0x168C) */
+
+#define BIT_STATUS_BFEE6 BIT(10)
+#define BIT_WMAC_MU_BFEE6_EN BIT(9)
+
+#define BIT_SHIFT_WMAC_MU_BFEE6_AID 0
+#define BIT_MASK_WMAC_MU_BFEE6_AID 0x1ff
+#define BIT_WMAC_MU_BFEE6_AID(x)                                               \
+	(((x) & BIT_MASK_WMAC_MU_BFEE6_AID) << BIT_SHIFT_WMAC_MU_BFEE6_AID)
+#define BIT_GET_WMAC_MU_BFEE6_AID(x)                                           \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFEE6_AID) & BIT_MASK_WMAC_MU_BFEE6_AID)
+
+/* 2 REG_WMAC_ASSOCIATED_MU_BFMEE7		(Offset 0x168E) */
+
+#define BIT_BIT_STATUS_BFEE4 BIT(10)
+#define BIT_WMAC_MU_BFEE7_EN BIT(9)
+
+#define BIT_SHIFT_WMAC_MU_BFEE7_AID 0
+#define BIT_MASK_WMAC_MU_BFEE7_AID 0x1ff
+#define BIT_WMAC_MU_BFEE7_AID(x)                                               \
+	(((x) & BIT_MASK_WMAC_MU_BFEE7_AID) << BIT_SHIFT_WMAC_MU_BFEE7_AID)
+#define BIT_GET_WMAC_MU_BFEE7_AID(x)                                           \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFEE7_AID) & BIT_MASK_WMAC_MU_BFEE7_AID)
+
+/* 2 REG_WMAC_BB_STOP_RX_COUNTER		(Offset 0x1690) */
+
+#define BIT_RST_ALL_COUNTER BIT(31)
+
+#define BIT_SHIFT_ABORT_RX_VBON_COUNTER 16
+#define BIT_MASK_ABORT_RX_VBON_COUNTER 0xff
+#define BIT_ABORT_RX_VBON_COUNTER(x)                                           \
+	(((x) & BIT_MASK_ABORT_RX_VBON_COUNTER)                                \
+	 << BIT_SHIFT_ABORT_RX_VBON_COUNTER)
+#define BIT_GET_ABORT_RX_VBON_COUNTER(x)                                       \
+	(((x) >> BIT_SHIFT_ABORT_RX_VBON_COUNTER) &                            \
+	 BIT_MASK_ABORT_RX_VBON_COUNTER)
+
+#define BIT_SHIFT_ABORT_RX_RDRDY_COUNTER 8
+#define BIT_MASK_ABORT_RX_RDRDY_COUNTER 0xff
+#define BIT_ABORT_RX_RDRDY_COUNTER(x)                                          \
+	(((x) & BIT_MASK_ABORT_RX_RDRDY_COUNTER)                               \
+	 << BIT_SHIFT_ABORT_RX_RDRDY_COUNTER)
+#define BIT_GET_ABORT_RX_RDRDY_COUNTER(x)                                      \
+	(((x) >> BIT_SHIFT_ABORT_RX_RDRDY_COUNTER) &                           \
+	 BIT_MASK_ABORT_RX_RDRDY_COUNTER)
+
+#define BIT_SHIFT_VBON_EARLY_FALLING_COUNTER 0
+#define BIT_MASK_VBON_EARLY_FALLING_COUNTER 0xff
+#define BIT_VBON_EARLY_FALLING_COUNTER(x)                                      \
+	(((x) & BIT_MASK_VBON_EARLY_FALLING_COUNTER)                           \
+	 << BIT_SHIFT_VBON_EARLY_FALLING_COUNTER)
+#define BIT_GET_VBON_EARLY_FALLING_COUNTER(x)                                  \
+	(((x) >> BIT_SHIFT_VBON_EARLY_FALLING_COUNTER) &                       \
+	 BIT_MASK_VBON_EARLY_FALLING_COUNTER)
+
+/* 2 REG_WMAC_PLCP_MONITOR			(Offset 0x1694) */
+
+#define BIT_WMAC_PLCP_TRX_SEL BIT(31)
+
+#define BIT_SHIFT_WMAC_PLCP_RDSIG_SEL 28
+#define BIT_MASK_WMAC_PLCP_RDSIG_SEL 0x7
+#define BIT_WMAC_PLCP_RDSIG_SEL(x)                                             \
+	(((x) & BIT_MASK_WMAC_PLCP_RDSIG_SEL) << BIT_SHIFT_WMAC_PLCP_RDSIG_SEL)
+#define BIT_GET_WMAC_PLCP_RDSIG_SEL(x)                                         \
+	(((x) >> BIT_SHIFT_WMAC_PLCP_RDSIG_SEL) & BIT_MASK_WMAC_PLCP_RDSIG_SEL)
+
+#define BIT_SHIFT_WMAC_RATE_IDX 24
+#define BIT_MASK_WMAC_RATE_IDX 0xf
+#define BIT_WMAC_RATE_IDX(x)                                                   \
+	(((x) & BIT_MASK_WMAC_RATE_IDX) << BIT_SHIFT_WMAC_RATE_IDX)
+#define BIT_GET_WMAC_RATE_IDX(x)                                               \
+	(((x) >> BIT_SHIFT_WMAC_RATE_IDX) & BIT_MASK_WMAC_RATE_IDX)
+
+#define BIT_SHIFT_WMAC_PLCP_RDSIG 0
+#define BIT_MASK_WMAC_PLCP_RDSIG 0xffffff
+#define BIT_WMAC_PLCP_RDSIG(x)                                                 \
+	(((x) & BIT_MASK_WMAC_PLCP_RDSIG) << BIT_SHIFT_WMAC_PLCP_RDSIG)
+#define BIT_GET_WMAC_PLCP_RDSIG(x)                                             \
+	(((x) >> BIT_SHIFT_WMAC_PLCP_RDSIG) & BIT_MASK_WMAC_PLCP_RDSIG)
+
+/* 2 REG_WMAC_PLCP_MONITOR_MUTX		(Offset 0x1698) */
+
+#define BIT_WMAC_MUTX_IDX BIT(24)
+
+/* 2 REG_TRANSMIT_ADDRSS_0			(Offset 0x16A0) */
+
+#define BIT_SHIFT_TA0 0
+#define BIT_MASK_TA0 0xffffffffffffL
+#define BIT_TA0(x) (((x) & BIT_MASK_TA0) << BIT_SHIFT_TA0)
+#define BIT_GET_TA0(x) (((x) >> BIT_SHIFT_TA0) & BIT_MASK_TA0)
+
+/* 2 REG_TRANSMIT_ADDRSS_1			(Offset 0x16A8) */
+
+#define BIT_SHIFT_TA1 0
+#define BIT_MASK_TA1 0xffffffffffffL
+#define BIT_TA1(x) (((x) & BIT_MASK_TA1) << BIT_SHIFT_TA1)
+#define BIT_GET_TA1(x) (((x) >> BIT_SHIFT_TA1) & BIT_MASK_TA1)
+
+/* 2 REG_TRANSMIT_ADDRSS_2			(Offset 0x16B0) */
+
+#define BIT_SHIFT_TA2 0
+#define BIT_MASK_TA2 0xffffffffffffL
+#define BIT_TA2(x) (((x) & BIT_MASK_TA2) << BIT_SHIFT_TA2)
+#define BIT_GET_TA2(x) (((x) >> BIT_SHIFT_TA2) & BIT_MASK_TA2)
+
+/* 2 REG_TRANSMIT_ADDRSS_3			(Offset 0x16B8) */
+
+#define BIT_SHIFT_TA3 0
+#define BIT_MASK_TA3 0xffffffffffffL
+#define BIT_TA3(x) (((x) & BIT_MASK_TA3) << BIT_SHIFT_TA3)
+#define BIT_GET_TA3(x) (((x) >> BIT_SHIFT_TA3) & BIT_MASK_TA3)
+
+/* 2 REG_TRANSMIT_ADDRSS_4			(Offset 0x16C0) */
+
+#define BIT_SHIFT_TA4 0
+#define BIT_MASK_TA4 0xffffffffffffL
+#define BIT_TA4(x) (((x) & BIT_MASK_TA4) << BIT_SHIFT_TA4)
+#define BIT_GET_TA4(x) (((x) >> BIT_SHIFT_TA4) & BIT_MASK_TA4)
+
+/* 2 REG_WL2LTECOEX_INDIRECT_ACCESS_CTRL_V1 (Offset 0x1700) */
+
+#define BIT_LTECOEX_ACCESS_START_V1 BIT(31)
+#define BIT_LTECOEX_WRITE_MODE_V1 BIT(30)
+#define BIT_LTECOEX_READY_BIT_V1 BIT(29)
+
+#define BIT_SHIFT_WRITE_BYTE_EN_V1 16
+#define BIT_MASK_WRITE_BYTE_EN_V1 0xf
+#define BIT_WRITE_BYTE_EN_V1(x)                                                \
+	(((x) & BIT_MASK_WRITE_BYTE_EN_V1) << BIT_SHIFT_WRITE_BYTE_EN_V1)
+#define BIT_GET_WRITE_BYTE_EN_V1(x)                                            \
+	(((x) >> BIT_SHIFT_WRITE_BYTE_EN_V1) & BIT_MASK_WRITE_BYTE_EN_V1)
+
+#define BIT_SHIFT_LTECOEX_REG_ADDR_V1 0
+#define BIT_MASK_LTECOEX_REG_ADDR_V1 0xffff
+#define BIT_LTECOEX_REG_ADDR_V1(x)                                             \
+	(((x) & BIT_MASK_LTECOEX_REG_ADDR_V1) << BIT_SHIFT_LTECOEX_REG_ADDR_V1)
+#define BIT_GET_LTECOEX_REG_ADDR_V1(x)                                         \
+	(((x) >> BIT_SHIFT_LTECOEX_REG_ADDR_V1) & BIT_MASK_LTECOEX_REG_ADDR_V1)
+
+/* 2 REG_WL2LTECOEX_INDIRECT_ACCESS_WRITE_DATA_V1 (Offset 0x1704) */
+
+#define BIT_SHIFT_LTECOEX_W_DATA_V1 0
+#define BIT_MASK_LTECOEX_W_DATA_V1 0xffffffffL
+#define BIT_LTECOEX_W_DATA_V1(x)                                               \
+	(((x) & BIT_MASK_LTECOEX_W_DATA_V1) << BIT_SHIFT_LTECOEX_W_DATA_V1)
+#define BIT_GET_LTECOEX_W_DATA_V1(x)                                           \
+	(((x) >> BIT_SHIFT_LTECOEX_W_DATA_V1) & BIT_MASK_LTECOEX_W_DATA_V1)
+
+/* 2 REG_WL2LTECOEX_INDIRECT_ACCESS_READ_DATA_V1 (Offset 0x1708) */
+
+#define BIT_SHIFT_LTECOEX_R_DATA_V1 0
+#define BIT_MASK_LTECOEX_R_DATA_V1 0xffffffffL
+#define BIT_LTECOEX_R_DATA_V1(x)                                               \
+	(((x) & BIT_MASK_LTECOEX_R_DATA_V1) << BIT_SHIFT_LTECOEX_R_DATA_V1)
+#define BIT_GET_LTECOEX_R_DATA_V1(x)                                           \
+	(((x) >> BIT_SHIFT_LTECOEX_R_DATA_V1) & BIT_MASK_LTECOEX_R_DATA_V1)
+
+#endif /* __RTL_WLAN_BITDEF_H__ */
diff --git a/drivers/staging/rtlwifi/halmac/halmac_bit_8822b.h b/drivers/staging/rtlwifi/halmac/halmac_bit_8822b.h
new file mode 100644
index 000000000000..7d02553f229e
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_bit_8822b.h
@@ -0,0 +1,12103 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __INC_HALMAC_BIT_8822B_H
+#define __INC_HALMAC_BIT_8822B_H
+
+#define CPU_OPT_WIDTH 0x1F
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_SYS_ISO_CTRL_8822B */
+#define BIT_PWC_EV12V_8822B BIT(15)
+#define BIT_PWC_EV25V_8822B BIT(14)
+#define BIT_PA33V_EN_8822B BIT(13)
+#define BIT_PA12V_EN_8822B BIT(12)
+#define BIT_UA33V_EN_8822B BIT(11)
+#define BIT_UA12V_EN_8822B BIT(10)
+#define BIT_ISO_RFDIO_8822B BIT(9)
+#define BIT_ISO_EB2CORE_8822B BIT(8)
+#define BIT_ISO_DIOE_8822B BIT(7)
+#define BIT_ISO_WLPON2PP_8822B BIT(6)
+#define BIT_ISO_IP2MAC_WA2PP_8822B BIT(5)
+#define BIT_ISO_PD2CORE_8822B BIT(4)
+#define BIT_ISO_PA2PCIE_8822B BIT(3)
+#define BIT_ISO_UD2CORE_8822B BIT(2)
+#define BIT_ISO_UA2USB_8822B BIT(1)
+#define BIT_ISO_WD2PP_8822B BIT(0)
+
+/* 2 REG_SYS_FUNC_EN_8822B */
+#define BIT_FEN_MREGEN_8822B BIT(15)
+#define BIT_FEN_HWPDN_8822B BIT(14)
+#define BIT_EN_25_1_8822B BIT(13)
+#define BIT_FEN_ELDR_8822B BIT(12)
+#define BIT_FEN_DCORE_8822B BIT(11)
+#define BIT_FEN_CPUEN_8822B BIT(10)
+#define BIT_FEN_DIOE_8822B BIT(9)
+#define BIT_FEN_PCIED_8822B BIT(8)
+#define BIT_FEN_PPLL_8822B BIT(7)
+#define BIT_FEN_PCIEA_8822B BIT(6)
+#define BIT_FEN_DIO_PCIE_8822B BIT(5)
+#define BIT_FEN_USBD_8822B BIT(4)
+#define BIT_FEN_UPLL_8822B BIT(3)
+#define BIT_FEN_USBA_8822B BIT(2)
+#define BIT_FEN_BB_GLB_RSTN_8822B BIT(1)
+#define BIT_FEN_BBRSTB_8822B BIT(0)
+
+/* 2 REG_SYS_PW_CTRL_8822B */
+#define BIT_SOP_EABM_8822B BIT(31)
+#define BIT_SOP_ACKF_8822B BIT(30)
+#define BIT_SOP_ERCK_8822B BIT(29)
+#define BIT_SOP_ESWR_8822B BIT(28)
+#define BIT_SOP_PWMM_8822B BIT(27)
+#define BIT_SOP_EECK_8822B BIT(26)
+#define BIT_SOP_EXTL_8822B BIT(24)
+#define BIT_SYM_OP_RING_12M_8822B BIT(22)
+#define BIT_ROP_SWPR_8822B BIT(21)
+#define BIT_DIS_HW_LPLDM_8822B BIT(20)
+#define BIT_OPT_SWRST_WLMCU_8822B BIT(19)
+#define BIT_RDY_SYSPWR_8822B BIT(17)
+#define BIT_EN_WLON_8822B BIT(16)
+#define BIT_APDM_HPDN_8822B BIT(15)
+#define BIT_AFSM_PCIE_SUS_EN_8822B BIT(12)
+#define BIT_AFSM_WLSUS_EN_8822B BIT(11)
+#define BIT_APFM_SWLPS_8822B BIT(10)
+#define BIT_APFM_OFFMAC_8822B BIT(9)
+#define BIT_APFN_ONMAC_8822B BIT(8)
+#define BIT_CHIP_PDN_EN_8822B BIT(7)
+#define BIT_RDY_MACDIS_8822B BIT(6)
+#define BIT_RING_CLK_12M_EN_8822B BIT(4)
+#define BIT_PFM_WOWL_8822B BIT(3)
+#define BIT_PFM_LDKP_8822B BIT(2)
+#define BIT_WL_HCI_ALD_8822B BIT(1)
+#define BIT_PFM_LDALL_8822B BIT(0)
+
+/* 2 REG_SYS_CLK_CTRL_8822B */
+#define BIT_LDO_DUMMY_8822B BIT(15)
+#define BIT_CPU_CLK_EN_8822B BIT(14)
+#define BIT_SYMREG_CLK_EN_8822B BIT(13)
+#define BIT_HCI_CLK_EN_8822B BIT(12)
+#define BIT_MAC_CLK_EN_8822B BIT(11)
+#define BIT_SEC_CLK_EN_8822B BIT(10)
+#define BIT_PHY_SSC_RSTB_8822B BIT(9)
+#define BIT_EXT_32K_EN_8822B BIT(8)
+#define BIT_WL_CLK_TEST_8822B BIT(7)
+#define BIT_OP_SPS_PWM_EN_8822B BIT(6)
+#define BIT_LOADER_CLK_EN_8822B BIT(5)
+#define BIT_MACSLP_8822B BIT(4)
+#define BIT_WAKEPAD_EN_8822B BIT(3)
+#define BIT_ROMD16V_EN_8822B BIT(2)
+#define BIT_CKANA12M_EN_8822B BIT(1)
+#define BIT_CNTD16V_EN_8822B BIT(0)
+
+/* 2 REG_SYS_EEPROM_CTRL_8822B */
+
+#define BIT_SHIFT_VPDIDX_8822B 8
+#define BIT_MASK_VPDIDX_8822B 0xff
+#define BIT_VPDIDX_8822B(x)                                                    \
+	(((x) & BIT_MASK_VPDIDX_8822B) << BIT_SHIFT_VPDIDX_8822B)
+#define BIT_GET_VPDIDX_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_VPDIDX_8822B) & BIT_MASK_VPDIDX_8822B)
+
+#define BIT_SHIFT_EEM1_0_8822B 6
+#define BIT_MASK_EEM1_0_8822B 0x3
+#define BIT_EEM1_0_8822B(x)                                                    \
+	(((x) & BIT_MASK_EEM1_0_8822B) << BIT_SHIFT_EEM1_0_8822B)
+#define BIT_GET_EEM1_0_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_EEM1_0_8822B) & BIT_MASK_EEM1_0_8822B)
+
+#define BIT_AUTOLOAD_SUS_8822B BIT(5)
+#define BIT_EERPOMSEL_8822B BIT(4)
+#define BIT_EECS_V1_8822B BIT(3)
+#define BIT_EESK_V1_8822B BIT(2)
+#define BIT_EEDI_V1_8822B BIT(1)
+#define BIT_EEDO_V1_8822B BIT(0)
+
+/* 2 REG_EE_VPD_8822B */
+
+#define BIT_SHIFT_VPD_DATA_8822B 0
+#define BIT_MASK_VPD_DATA_8822B 0xffffffffL
+#define BIT_VPD_DATA_8822B(x)                                                  \
+	(((x) & BIT_MASK_VPD_DATA_8822B) << BIT_SHIFT_VPD_DATA_8822B)
+#define BIT_GET_VPD_DATA_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_VPD_DATA_8822B) & BIT_MASK_VPD_DATA_8822B)
+
+/* 2 REG_SYS_SWR_CTRL1_8822B */
+#define BIT_C2_L_BIT0_8822B BIT(31)
+
+#define BIT_SHIFT_C1_L_8822B 29
+#define BIT_MASK_C1_L_8822B 0x3
+#define BIT_C1_L_8822B(x) (((x) & BIT_MASK_C1_L_8822B) << BIT_SHIFT_C1_L_8822B)
+#define BIT_GET_C1_L_8822B(x)                                                  \
+	(((x) >> BIT_SHIFT_C1_L_8822B) & BIT_MASK_C1_L_8822B)
+
+#define BIT_SHIFT_REG_FREQ_L_8822B 25
+#define BIT_MASK_REG_FREQ_L_8822B 0x7
+#define BIT_REG_FREQ_L_8822B(x)                                                \
+	(((x) & BIT_MASK_REG_FREQ_L_8822B) << BIT_SHIFT_REG_FREQ_L_8822B)
+#define BIT_GET_REG_FREQ_L_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_REG_FREQ_L_8822B) & BIT_MASK_REG_FREQ_L_8822B)
+
+#define BIT_REG_EN_DUTY_8822B BIT(24)
+
+#define BIT_SHIFT_REG_MODE_8822B 22
+#define BIT_MASK_REG_MODE_8822B 0x3
+#define BIT_REG_MODE_8822B(x)                                                  \
+	(((x) & BIT_MASK_REG_MODE_8822B) << BIT_SHIFT_REG_MODE_8822B)
+#define BIT_GET_REG_MODE_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_REG_MODE_8822B) & BIT_MASK_REG_MODE_8822B)
+
+#define BIT_REG_EN_SP_8822B BIT(21)
+#define BIT_REG_AUTO_L_8822B BIT(20)
+#define BIT_SW18_SELD_BIT0_8822B BIT(19)
+#define BIT_SW18_POWOCP_8822B BIT(18)
+
+#define BIT_SHIFT_OCP_L1_8822B 15
+#define BIT_MASK_OCP_L1_8822B 0x7
+#define BIT_OCP_L1_8822B(x)                                                    \
+	(((x) & BIT_MASK_OCP_L1_8822B) << BIT_SHIFT_OCP_L1_8822B)
+#define BIT_GET_OCP_L1_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_OCP_L1_8822B) & BIT_MASK_OCP_L1_8822B)
+
+#define BIT_SHIFT_CF_L_8822B 13
+#define BIT_MASK_CF_L_8822B 0x3
+#define BIT_CF_L_8822B(x) (((x) & BIT_MASK_CF_L_8822B) << BIT_SHIFT_CF_L_8822B)
+#define BIT_GET_CF_L_8822B(x)                                                  \
+	(((x) >> BIT_SHIFT_CF_L_8822B) & BIT_MASK_CF_L_8822B)
+
+#define BIT_SW18_FPWM_8822B BIT(11)
+#define BIT_SW18_SWEN_8822B BIT(9)
+#define BIT_SW18_LDEN_8822B BIT(8)
+#define BIT_MAC_ID_EN_8822B BIT(7)
+#define BIT_AFE_BGEN_8822B BIT(0)
+
+/* 2 REG_SYS_SWR_CTRL2_8822B */
+#define BIT_POW_ZCD_L_8822B BIT(31)
+#define BIT_AUTOZCD_L_8822B BIT(30)
+
+#define BIT_SHIFT_REG_DELAY_8822B 28
+#define BIT_MASK_REG_DELAY_8822B 0x3
+#define BIT_REG_DELAY_8822B(x)                                                 \
+	(((x) & BIT_MASK_REG_DELAY_8822B) << BIT_SHIFT_REG_DELAY_8822B)
+#define BIT_GET_REG_DELAY_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_REG_DELAY_8822B) & BIT_MASK_REG_DELAY_8822B)
+
+#define BIT_SHIFT_V15ADJ_L1_V1_8822B 24
+#define BIT_MASK_V15ADJ_L1_V1_8822B 0x7
+#define BIT_V15ADJ_L1_V1_8822B(x)                                              \
+	(((x) & BIT_MASK_V15ADJ_L1_V1_8822B) << BIT_SHIFT_V15ADJ_L1_V1_8822B)
+#define BIT_GET_V15ADJ_L1_V1_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_V15ADJ_L1_V1_8822B) & BIT_MASK_V15ADJ_L1_V1_8822B)
+
+#define BIT_SHIFT_VOL_L1_V1_8822B 20
+#define BIT_MASK_VOL_L1_V1_8822B 0xf
+#define BIT_VOL_L1_V1_8822B(x)                                                 \
+	(((x) & BIT_MASK_VOL_L1_V1_8822B) << BIT_SHIFT_VOL_L1_V1_8822B)
+#define BIT_GET_VOL_L1_V1_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_VOL_L1_V1_8822B) & BIT_MASK_VOL_L1_V1_8822B)
+
+#define BIT_SHIFT_IN_L1_V1_8822B 17
+#define BIT_MASK_IN_L1_V1_8822B 0x7
+#define BIT_IN_L1_V1_8822B(x)                                                  \
+	(((x) & BIT_MASK_IN_L1_V1_8822B) << BIT_SHIFT_IN_L1_V1_8822B)
+#define BIT_GET_IN_L1_V1_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_IN_L1_V1_8822B) & BIT_MASK_IN_L1_V1_8822B)
+
+#define BIT_SHIFT_TBOX_L1_8822B 15
+#define BIT_MASK_TBOX_L1_8822B 0x3
+#define BIT_TBOX_L1_8822B(x)                                                   \
+	(((x) & BIT_MASK_TBOX_L1_8822B) << BIT_SHIFT_TBOX_L1_8822B)
+#define BIT_GET_TBOX_L1_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_TBOX_L1_8822B) & BIT_MASK_TBOX_L1_8822B)
+
+#define BIT_SW18_SEL_8822B BIT(13)
+
+/* 2 REG_NOT_VALID_8822B */
+#define BIT_SW18_SD_8822B BIT(10)
+
+#define BIT_SHIFT_R3_L_8822B 7
+#define BIT_MASK_R3_L_8822B 0x3
+#define BIT_R3_L_8822B(x) (((x) & BIT_MASK_R3_L_8822B) << BIT_SHIFT_R3_L_8822B)
+#define BIT_GET_R3_L_8822B(x)                                                  \
+	(((x) >> BIT_SHIFT_R3_L_8822B) & BIT_MASK_R3_L_8822B)
+
+#define BIT_SHIFT_SW18_R2_8822B 5
+#define BIT_MASK_SW18_R2_8822B 0x3
+#define BIT_SW18_R2_8822B(x)                                                   \
+	(((x) & BIT_MASK_SW18_R2_8822B) << BIT_SHIFT_SW18_R2_8822B)
+#define BIT_GET_SW18_R2_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_SW18_R2_8822B) & BIT_MASK_SW18_R2_8822B)
+
+#define BIT_SHIFT_SW18_R1_8822B 3
+#define BIT_MASK_SW18_R1_8822B 0x3
+#define BIT_SW18_R1_8822B(x)                                                   \
+	(((x) & BIT_MASK_SW18_R1_8822B) << BIT_SHIFT_SW18_R1_8822B)
+#define BIT_GET_SW18_R1_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_SW18_R1_8822B) & BIT_MASK_SW18_R1_8822B)
+
+#define BIT_SHIFT_C3_L_C3_8822B 1
+#define BIT_MASK_C3_L_C3_8822B 0x3
+#define BIT_C3_L_C3_8822B(x)                                                   \
+	(((x) & BIT_MASK_C3_L_C3_8822B) << BIT_SHIFT_C3_L_C3_8822B)
+#define BIT_GET_C3_L_C3_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_C3_L_C3_8822B) & BIT_MASK_C3_L_C3_8822B)
+
+#define BIT_C2_L_BIT1_8822B BIT(0)
+
+/* 2 REG_SYS_SWR_CTRL3_8822B */
+#define BIT_SPS18_OCP_DIS_8822B BIT(31)
+
+#define BIT_SHIFT_SPS18_OCP_TH_8822B 16
+#define BIT_MASK_SPS18_OCP_TH_8822B 0x7fff
+#define BIT_SPS18_OCP_TH_8822B(x)                                              \
+	(((x) & BIT_MASK_SPS18_OCP_TH_8822B) << BIT_SHIFT_SPS18_OCP_TH_8822B)
+#define BIT_GET_SPS18_OCP_TH_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_SPS18_OCP_TH_8822B) & BIT_MASK_SPS18_OCP_TH_8822B)
+
+#define BIT_SHIFT_OCP_WINDOW_8822B 0
+#define BIT_MASK_OCP_WINDOW_8822B 0xffff
+#define BIT_OCP_WINDOW_8822B(x)                                                \
+	(((x) & BIT_MASK_OCP_WINDOW_8822B) << BIT_SHIFT_OCP_WINDOW_8822B)
+#define BIT_GET_OCP_WINDOW_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_OCP_WINDOW_8822B) & BIT_MASK_OCP_WINDOW_8822B)
+
+/* 2 REG_RSV_CTRL_8822B */
+#define BIT_HREG_DBG_8822B BIT(23)
+#define BIT_WLMCUIOIF_8822B BIT(8)
+#define BIT_LOCK_ALL_EN_8822B BIT(7)
+#define BIT_R_DIS_PRST_8822B BIT(6)
+#define BIT_WLOCK_1C_B6_8822B BIT(5)
+#define BIT_WLOCK_40_8822B BIT(4)
+#define BIT_WLOCK_08_8822B BIT(3)
+#define BIT_WLOCK_04_8822B BIT(2)
+#define BIT_WLOCK_00_8822B BIT(1)
+#define BIT_WLOCK_ALL_8822B BIT(0)
+
+/* 2 REG_RF_CTRL_8822B */
+#define BIT_RF_SDMRSTB_8822B BIT(2)
+#define BIT_RF_RSTB_8822B BIT(1)
+#define BIT_RF_EN_8822B BIT(0)
+
+/* 2 REG_AFE_LDO_CTRL_8822B */
+
+#define BIT_SHIFT_LPLDH12_RSV_8822B 29
+#define BIT_MASK_LPLDH12_RSV_8822B 0x7
+#define BIT_LPLDH12_RSV_8822B(x)                                               \
+	(((x) & BIT_MASK_LPLDH12_RSV_8822B) << BIT_SHIFT_LPLDH12_RSV_8822B)
+#define BIT_GET_LPLDH12_RSV_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_LPLDH12_RSV_8822B) & BIT_MASK_LPLDH12_RSV_8822B)
+
+#define BIT_LPLDH12_SLP_8822B BIT(28)
+
+#define BIT_SHIFT_LPLDH12_VADJ_8822B 24
+#define BIT_MASK_LPLDH12_VADJ_8822B 0xf
+#define BIT_LPLDH12_VADJ_8822B(x)                                              \
+	(((x) & BIT_MASK_LPLDH12_VADJ_8822B) << BIT_SHIFT_LPLDH12_VADJ_8822B)
+#define BIT_GET_LPLDH12_VADJ_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_LPLDH12_VADJ_8822B) & BIT_MASK_LPLDH12_VADJ_8822B)
+
+#define BIT_LDH12_EN_8822B BIT(16)
+#define BIT_WLBBOFF_BIG_PWC_EN_8822B BIT(14)
+#define BIT_WLBBOFF_SMALL_PWC_EN_8822B BIT(13)
+#define BIT_WLMACOFF_BIG_PWC_EN_8822B BIT(12)
+#define BIT_WLPON_PWC_EN_8822B BIT(11)
+#define BIT_POW_REGU_P1_8822B BIT(10)
+#define BIT_LDOV12W_EN_8822B BIT(8)
+#define BIT_EX_XTAL_DRV_DIGI_8822B BIT(7)
+#define BIT_EX_XTAL_DRV_USB_8822B BIT(6)
+#define BIT_EX_XTAL_DRV_AFE_8822B BIT(5)
+#define BIT_EX_XTAL_DRV_RF2_8822B BIT(4)
+#define BIT_EX_XTAL_DRV_RF1_8822B BIT(3)
+#define BIT_POW_REGU_P0_8822B BIT(2)
+
+/* 2 REG_NOT_VALID_8822B */
+#define BIT_POW_PLL_LDO_8822B BIT(0)
+
+/* 2 REG_AFE_CTRL1_8822B */
+#define BIT_AGPIO_GPE_8822B BIT(31)
+
+#define BIT_SHIFT_XTAL_CAP_XI_8822B 25
+#define BIT_MASK_XTAL_CAP_XI_8822B 0x3f
+#define BIT_XTAL_CAP_XI_8822B(x)                                               \
+	(((x) & BIT_MASK_XTAL_CAP_XI_8822B) << BIT_SHIFT_XTAL_CAP_XI_8822B)
+#define BIT_GET_XTAL_CAP_XI_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_XTAL_CAP_XI_8822B) & BIT_MASK_XTAL_CAP_XI_8822B)
+
+#define BIT_SHIFT_XTAL_DRV_DIGI_8822B 23
+#define BIT_MASK_XTAL_DRV_DIGI_8822B 0x3
+#define BIT_XTAL_DRV_DIGI_8822B(x)                                             \
+	(((x) & BIT_MASK_XTAL_DRV_DIGI_8822B) << BIT_SHIFT_XTAL_DRV_DIGI_8822B)
+#define BIT_GET_XTAL_DRV_DIGI_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_XTAL_DRV_DIGI_8822B) & BIT_MASK_XTAL_DRV_DIGI_8822B)
+
+#define BIT_XTAL_DRV_USB_BIT1_8822B BIT(22)
+
+#define BIT_SHIFT_MAC_CLK_SEL_8822B 20
+#define BIT_MASK_MAC_CLK_SEL_8822B 0x3
+#define BIT_MAC_CLK_SEL_8822B(x)                                               \
+	(((x) & BIT_MASK_MAC_CLK_SEL_8822B) << BIT_SHIFT_MAC_CLK_SEL_8822B)
+#define BIT_GET_MAC_CLK_SEL_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_MAC_CLK_SEL_8822B) & BIT_MASK_MAC_CLK_SEL_8822B)
+
+#define BIT_XTAL_DRV_USB_BIT0_8822B BIT(19)
+
+#define BIT_SHIFT_XTAL_DRV_AFE_8822B 17
+#define BIT_MASK_XTAL_DRV_AFE_8822B 0x3
+#define BIT_XTAL_DRV_AFE_8822B(x)                                              \
+	(((x) & BIT_MASK_XTAL_DRV_AFE_8822B) << BIT_SHIFT_XTAL_DRV_AFE_8822B)
+#define BIT_GET_XTAL_DRV_AFE_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_XTAL_DRV_AFE_8822B) & BIT_MASK_XTAL_DRV_AFE_8822B)
+
+#define BIT_SHIFT_XTAL_DRV_RF2_8822B 15
+#define BIT_MASK_XTAL_DRV_RF2_8822B 0x3
+#define BIT_XTAL_DRV_RF2_8822B(x)                                              \
+	(((x) & BIT_MASK_XTAL_DRV_RF2_8822B) << BIT_SHIFT_XTAL_DRV_RF2_8822B)
+#define BIT_GET_XTAL_DRV_RF2_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_XTAL_DRV_RF2_8822B) & BIT_MASK_XTAL_DRV_RF2_8822B)
+
+#define BIT_SHIFT_XTAL_DRV_RF1_8822B 13
+#define BIT_MASK_XTAL_DRV_RF1_8822B 0x3
+#define BIT_XTAL_DRV_RF1_8822B(x)                                              \
+	(((x) & BIT_MASK_XTAL_DRV_RF1_8822B) << BIT_SHIFT_XTAL_DRV_RF1_8822B)
+#define BIT_GET_XTAL_DRV_RF1_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_XTAL_DRV_RF1_8822B) & BIT_MASK_XTAL_DRV_RF1_8822B)
+
+#define BIT_XTAL_DELAY_DIGI_8822B BIT(12)
+#define BIT_XTAL_DELAY_USB_8822B BIT(11)
+#define BIT_XTAL_DELAY_AFE_8822B BIT(10)
+
+#define BIT_SHIFT_XTAL_LDO_VREF_8822B 7
+#define BIT_MASK_XTAL_LDO_VREF_8822B 0x7
+#define BIT_XTAL_LDO_VREF_8822B(x)                                             \
+	(((x) & BIT_MASK_XTAL_LDO_VREF_8822B) << BIT_SHIFT_XTAL_LDO_VREF_8822B)
+#define BIT_GET_XTAL_LDO_VREF_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_XTAL_LDO_VREF_8822B) & BIT_MASK_XTAL_LDO_VREF_8822B)
+
+#define BIT_XTAL_XQSEL_RF_8822B BIT(6)
+#define BIT_XTAL_XQSEL_8822B BIT(5)
+
+#define BIT_SHIFT_XTAL_GMN_V2_8822B 3
+#define BIT_MASK_XTAL_GMN_V2_8822B 0x3
+#define BIT_XTAL_GMN_V2_8822B(x)                                               \
+	(((x) & BIT_MASK_XTAL_GMN_V2_8822B) << BIT_SHIFT_XTAL_GMN_V2_8822B)
+#define BIT_GET_XTAL_GMN_V2_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_XTAL_GMN_V2_8822B) & BIT_MASK_XTAL_GMN_V2_8822B)
+
+#define BIT_SHIFT_XTAL_GMP_V2_8822B 1
+#define BIT_MASK_XTAL_GMP_V2_8822B 0x3
+#define BIT_XTAL_GMP_V2_8822B(x)                                               \
+	(((x) & BIT_MASK_XTAL_GMP_V2_8822B) << BIT_SHIFT_XTAL_GMP_V2_8822B)
+#define BIT_GET_XTAL_GMP_V2_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_XTAL_GMP_V2_8822B) & BIT_MASK_XTAL_GMP_V2_8822B)
+
+#define BIT_XTAL_EN_8822B BIT(0)
+
+/* 2 REG_AFE_CTRL2_8822B */
+
+#define BIT_SHIFT_REG_C3_V4_8822B 30
+#define BIT_MASK_REG_C3_V4_8822B 0x3
+#define BIT_REG_C3_V4_8822B(x)                                                 \
+	(((x) & BIT_MASK_REG_C3_V4_8822B) << BIT_SHIFT_REG_C3_V4_8822B)
+#define BIT_GET_REG_C3_V4_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_REG_C3_V4_8822B) & BIT_MASK_REG_C3_V4_8822B)
+
+#define BIT_REG_CP_BIT1_8822B BIT(29)
+
+#define BIT_SHIFT_REG_RS_V4_8822B 26
+#define BIT_MASK_REG_RS_V4_8822B 0x7
+#define BIT_REG_RS_V4_8822B(x)                                                 \
+	(((x) & BIT_MASK_REG_RS_V4_8822B) << BIT_SHIFT_REG_RS_V4_8822B)
+#define BIT_GET_REG_RS_V4_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_REG_RS_V4_8822B) & BIT_MASK_REG_RS_V4_8822B)
+
+#define BIT_SHIFT_REG__CS_8822B 24
+#define BIT_MASK_REG__CS_8822B 0x3
+#define BIT_REG__CS_8822B(x)                                                   \
+	(((x) & BIT_MASK_REG__CS_8822B) << BIT_SHIFT_REG__CS_8822B)
+#define BIT_GET_REG__CS_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_REG__CS_8822B) & BIT_MASK_REG__CS_8822B)
+
+#define BIT_SHIFT_REG_CP_OFFSET_8822B 21
+#define BIT_MASK_REG_CP_OFFSET_8822B 0x7
+#define BIT_REG_CP_OFFSET_8822B(x)                                             \
+	(((x) & BIT_MASK_REG_CP_OFFSET_8822B) << BIT_SHIFT_REG_CP_OFFSET_8822B)
+#define BIT_GET_REG_CP_OFFSET_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_REG_CP_OFFSET_8822B) & BIT_MASK_REG_CP_OFFSET_8822B)
+
+#define BIT_SHIFT_CP_BIAS_8822B 18
+#define BIT_MASK_CP_BIAS_8822B 0x7
+#define BIT_CP_BIAS_8822B(x)                                                   \
+	(((x) & BIT_MASK_CP_BIAS_8822B) << BIT_SHIFT_CP_BIAS_8822B)
+#define BIT_GET_CP_BIAS_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_CP_BIAS_8822B) & BIT_MASK_CP_BIAS_8822B)
+
+#define BIT_REG_IDOUBLE_V2_8822B BIT(17)
+#define BIT_EN_SYN_8822B BIT(16)
+
+#define BIT_SHIFT_MCCO_8822B 14
+#define BIT_MASK_MCCO_8822B 0x3
+#define BIT_MCCO_8822B(x) (((x) & BIT_MASK_MCCO_8822B) << BIT_SHIFT_MCCO_8822B)
+#define BIT_GET_MCCO_8822B(x)                                                  \
+	(((x) >> BIT_SHIFT_MCCO_8822B) & BIT_MASK_MCCO_8822B)
+
+#define BIT_SHIFT_REG_LDO_SEL_8822B 12
+#define BIT_MASK_REG_LDO_SEL_8822B 0x3
+#define BIT_REG_LDO_SEL_8822B(x)                                               \
+	(((x) & BIT_MASK_REG_LDO_SEL_8822B) << BIT_SHIFT_REG_LDO_SEL_8822B)
+#define BIT_GET_REG_LDO_SEL_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_REG_LDO_SEL_8822B) & BIT_MASK_REG_LDO_SEL_8822B)
+
+#define BIT_REG_KVCO_V2_8822B BIT(10)
+#define BIT_AGPIO_GPO_8822B BIT(9)
+
+#define BIT_SHIFT_AGPIO_DRV_8822B 7
+#define BIT_MASK_AGPIO_DRV_8822B 0x3
+#define BIT_AGPIO_DRV_8822B(x)                                                 \
+	(((x) & BIT_MASK_AGPIO_DRV_8822B) << BIT_SHIFT_AGPIO_DRV_8822B)
+#define BIT_GET_AGPIO_DRV_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_AGPIO_DRV_8822B) & BIT_MASK_AGPIO_DRV_8822B)
+
+#define BIT_SHIFT_XTAL_CAP_XO_8822B 1
+#define BIT_MASK_XTAL_CAP_XO_8822B 0x3f
+#define BIT_XTAL_CAP_XO_8822B(x)                                               \
+	(((x) & BIT_MASK_XTAL_CAP_XO_8822B) << BIT_SHIFT_XTAL_CAP_XO_8822B)
+#define BIT_GET_XTAL_CAP_XO_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_XTAL_CAP_XO_8822B) & BIT_MASK_XTAL_CAP_XO_8822B)
+
+#define BIT_POW_PLL_8822B BIT(0)
+
+/* 2 REG_AFE_CTRL3_8822B */
+
+#define BIT_SHIFT_PS_8822B 7
+#define BIT_MASK_PS_8822B 0x7
+#define BIT_PS_8822B(x) (((x) & BIT_MASK_PS_8822B) << BIT_SHIFT_PS_8822B)
+#define BIT_GET_PS_8822B(x) (((x) >> BIT_SHIFT_PS_8822B) & BIT_MASK_PS_8822B)
+
+#define BIT_PSEN_8822B BIT(6)
+#define BIT_DOGENB_8822B BIT(5)
+#define BIT_REG_MBIAS_8822B BIT(4)
+
+#define BIT_SHIFT_REG_R3_V4_8822B 1
+#define BIT_MASK_REG_R3_V4_8822B 0x7
+#define BIT_REG_R3_V4_8822B(x)                                                 \
+	(((x) & BIT_MASK_REG_R3_V4_8822B) << BIT_SHIFT_REG_R3_V4_8822B)
+#define BIT_GET_REG_R3_V4_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_REG_R3_V4_8822B) & BIT_MASK_REG_R3_V4_8822B)
+
+#define BIT_REG_CP_BIT0_8822B BIT(0)
+
+/* 2 REG_EFUSE_CTRL_8822B */
+#define BIT_EF_FLAG_8822B BIT(31)
+
+#define BIT_SHIFT_EF_PGPD_8822B 28
+#define BIT_MASK_EF_PGPD_8822B 0x7
+#define BIT_EF_PGPD_8822B(x)                                                   \
+	(((x) & BIT_MASK_EF_PGPD_8822B) << BIT_SHIFT_EF_PGPD_8822B)
+#define BIT_GET_EF_PGPD_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_EF_PGPD_8822B) & BIT_MASK_EF_PGPD_8822B)
+
+#define BIT_SHIFT_EF_RDT_8822B 24
+#define BIT_MASK_EF_RDT_8822B 0xf
+#define BIT_EF_RDT_8822B(x)                                                    \
+	(((x) & BIT_MASK_EF_RDT_8822B) << BIT_SHIFT_EF_RDT_8822B)
+#define BIT_GET_EF_RDT_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_EF_RDT_8822B) & BIT_MASK_EF_RDT_8822B)
+
+#define BIT_SHIFT_EF_PGTS_8822B 20
+#define BIT_MASK_EF_PGTS_8822B 0xf
+#define BIT_EF_PGTS_8822B(x)                                                   \
+	(((x) & BIT_MASK_EF_PGTS_8822B) << BIT_SHIFT_EF_PGTS_8822B)
+#define BIT_GET_EF_PGTS_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_EF_PGTS_8822B) & BIT_MASK_EF_PGTS_8822B)
+
+#define BIT_EF_PDWN_8822B BIT(19)
+#define BIT_EF_ALDEN_8822B BIT(18)
+
+#define BIT_SHIFT_EF_ADDR_8822B 8
+#define BIT_MASK_EF_ADDR_8822B 0x3ff
+#define BIT_EF_ADDR_8822B(x)                                                   \
+	(((x) & BIT_MASK_EF_ADDR_8822B) << BIT_SHIFT_EF_ADDR_8822B)
+#define BIT_GET_EF_ADDR_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_EF_ADDR_8822B) & BIT_MASK_EF_ADDR_8822B)
+
+#define BIT_SHIFT_EF_DATA_8822B 0
+#define BIT_MASK_EF_DATA_8822B 0xff
+#define BIT_EF_DATA_8822B(x)                                                   \
+	(((x) & BIT_MASK_EF_DATA_8822B) << BIT_SHIFT_EF_DATA_8822B)
+#define BIT_GET_EF_DATA_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_EF_DATA_8822B) & BIT_MASK_EF_DATA_8822B)
+
+/* 2 REG_LDO_EFUSE_CTRL_8822B */
+#define BIT_LDOE25_EN_8822B BIT(31)
+
+#define BIT_SHIFT_LDOE25_V12ADJ_L_8822B 27
+#define BIT_MASK_LDOE25_V12ADJ_L_8822B 0xf
+#define BIT_LDOE25_V12ADJ_L_8822B(x)                                           \
+	(((x) & BIT_MASK_LDOE25_V12ADJ_L_8822B)                                \
+	 << BIT_SHIFT_LDOE25_V12ADJ_L_8822B)
+#define BIT_GET_LDOE25_V12ADJ_L_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_LDOE25_V12ADJ_L_8822B) &                            \
+	 BIT_MASK_LDOE25_V12ADJ_L_8822B)
+
+#define BIT_EF_CRES_SEL_8822B BIT(26)
+
+#define BIT_SHIFT_EF_SCAN_START_V1_8822B 16
+#define BIT_MASK_EF_SCAN_START_V1_8822B 0x3ff
+#define BIT_EF_SCAN_START_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_EF_SCAN_START_V1_8822B)                               \
+	 << BIT_SHIFT_EF_SCAN_START_V1_8822B)
+#define BIT_GET_EF_SCAN_START_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_EF_SCAN_START_V1_8822B) &                           \
+	 BIT_MASK_EF_SCAN_START_V1_8822B)
+
+#define BIT_SHIFT_EF_SCAN_END_8822B 12
+#define BIT_MASK_EF_SCAN_END_8822B 0xf
+#define BIT_EF_SCAN_END_8822B(x)                                               \
+	(((x) & BIT_MASK_EF_SCAN_END_8822B) << BIT_SHIFT_EF_SCAN_END_8822B)
+#define BIT_GET_EF_SCAN_END_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_EF_SCAN_END_8822B) & BIT_MASK_EF_SCAN_END_8822B)
+
+#define BIT_EF_PD_DIS_8822B BIT(11)
+
+#define BIT_SHIFT_EF_CELL_SEL_8822B 8
+#define BIT_MASK_EF_CELL_SEL_8822B 0x3
+#define BIT_EF_CELL_SEL_8822B(x)                                               \
+	(((x) & BIT_MASK_EF_CELL_SEL_8822B) << BIT_SHIFT_EF_CELL_SEL_8822B)
+#define BIT_GET_EF_CELL_SEL_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_EF_CELL_SEL_8822B) & BIT_MASK_EF_CELL_SEL_8822B)
+
+#define BIT_EF_TRPT_8822B BIT(7)
+
+#define BIT_SHIFT_EF_TTHD_8822B 0
+#define BIT_MASK_EF_TTHD_8822B 0x7f
+#define BIT_EF_TTHD_8822B(x)                                                   \
+	(((x) & BIT_MASK_EF_TTHD_8822B) << BIT_SHIFT_EF_TTHD_8822B)
+#define BIT_GET_EF_TTHD_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_EF_TTHD_8822B) & BIT_MASK_EF_TTHD_8822B)
+
+/* 2 REG_PWR_OPTION_CTRL_8822B */
+
+#define BIT_SHIFT_DBG_SEL_V1_8822B 16
+#define BIT_MASK_DBG_SEL_V1_8822B 0xff
+#define BIT_DBG_SEL_V1_8822B(x)                                                \
+	(((x) & BIT_MASK_DBG_SEL_V1_8822B) << BIT_SHIFT_DBG_SEL_V1_8822B)
+#define BIT_GET_DBG_SEL_V1_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_DBG_SEL_V1_8822B) & BIT_MASK_DBG_SEL_V1_8822B)
+
+#define BIT_SHIFT_DBG_SEL_BYTE_8822B 14
+#define BIT_MASK_DBG_SEL_BYTE_8822B 0x3
+#define BIT_DBG_SEL_BYTE_8822B(x)                                              \
+	(((x) & BIT_MASK_DBG_SEL_BYTE_8822B) << BIT_SHIFT_DBG_SEL_BYTE_8822B)
+#define BIT_GET_DBG_SEL_BYTE_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_DBG_SEL_BYTE_8822B) & BIT_MASK_DBG_SEL_BYTE_8822B)
+
+#define BIT_SHIFT_STD_L1_V1_8822B 12
+#define BIT_MASK_STD_L1_V1_8822B 0x3
+#define BIT_STD_L1_V1_8822B(x)                                                 \
+	(((x) & BIT_MASK_STD_L1_V1_8822B) << BIT_SHIFT_STD_L1_V1_8822B)
+#define BIT_GET_STD_L1_V1_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_STD_L1_V1_8822B) & BIT_MASK_STD_L1_V1_8822B)
+
+#define BIT_SYSON_DBG_PAD_E2_8822B BIT(11)
+#define BIT_SYSON_LED_PAD_E2_8822B BIT(10)
+#define BIT_SYSON_GPEE_PAD_E2_8822B BIT(9)
+#define BIT_SYSON_PCI_PAD_E2_8822B BIT(8)
+#define BIT_AUTO_SW_LDO_VOL_EN_8822B BIT(7)
+
+#define BIT_SHIFT_SYSON_SPS0WWV_WT_8822B 4
+#define BIT_MASK_SYSON_SPS0WWV_WT_8822B 0x3
+#define BIT_SYSON_SPS0WWV_WT_8822B(x)                                          \
+	(((x) & BIT_MASK_SYSON_SPS0WWV_WT_8822B)                               \
+	 << BIT_SHIFT_SYSON_SPS0WWV_WT_8822B)
+#define BIT_GET_SYSON_SPS0WWV_WT_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_SYSON_SPS0WWV_WT_8822B) &                           \
+	 BIT_MASK_SYSON_SPS0WWV_WT_8822B)
+
+#define BIT_SHIFT_SYSON_SPS0LDO_WT_8822B 2
+#define BIT_MASK_SYSON_SPS0LDO_WT_8822B 0x3
+#define BIT_SYSON_SPS0LDO_WT_8822B(x)                                          \
+	(((x) & BIT_MASK_SYSON_SPS0LDO_WT_8822B)                               \
+	 << BIT_SHIFT_SYSON_SPS0LDO_WT_8822B)
+#define BIT_GET_SYSON_SPS0LDO_WT_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_SYSON_SPS0LDO_WT_8822B) &                           \
+	 BIT_MASK_SYSON_SPS0LDO_WT_8822B)
+
+#define BIT_SHIFT_SYSON_RCLK_SCALE_8822B 0
+#define BIT_MASK_SYSON_RCLK_SCALE_8822B 0x3
+#define BIT_SYSON_RCLK_SCALE_8822B(x)                                          \
+	(((x) & BIT_MASK_SYSON_RCLK_SCALE_8822B)                               \
+	 << BIT_SHIFT_SYSON_RCLK_SCALE_8822B)
+#define BIT_GET_SYSON_RCLK_SCALE_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_SYSON_RCLK_SCALE_8822B) &                           \
+	 BIT_MASK_SYSON_RCLK_SCALE_8822B)
+
+/* 2 REG_CAL_TIMER_8822B */
+
+#define BIT_SHIFT_MATCH_CNT_8822B 8
+#define BIT_MASK_MATCH_CNT_8822B 0xff
+#define BIT_MATCH_CNT_8822B(x)                                                 \
+	(((x) & BIT_MASK_MATCH_CNT_8822B) << BIT_SHIFT_MATCH_CNT_8822B)
+#define BIT_GET_MATCH_CNT_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_MATCH_CNT_8822B) & BIT_MASK_MATCH_CNT_8822B)
+
+#define BIT_SHIFT_CAL_SCAL_8822B 0
+#define BIT_MASK_CAL_SCAL_8822B 0xff
+#define BIT_CAL_SCAL_8822B(x)                                                  \
+	(((x) & BIT_MASK_CAL_SCAL_8822B) << BIT_SHIFT_CAL_SCAL_8822B)
+#define BIT_GET_CAL_SCAL_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_CAL_SCAL_8822B) & BIT_MASK_CAL_SCAL_8822B)
+
+/* 2 REG_ACLK_MON_8822B */
+
+#define BIT_SHIFT_RCLK_MON_8822B 5
+#define BIT_MASK_RCLK_MON_8822B 0x7ff
+#define BIT_RCLK_MON_8822B(x)                                                  \
+	(((x) & BIT_MASK_RCLK_MON_8822B) << BIT_SHIFT_RCLK_MON_8822B)
+#define BIT_GET_RCLK_MON_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_RCLK_MON_8822B) & BIT_MASK_RCLK_MON_8822B)
+
+#define BIT_CAL_EN_8822B BIT(4)
+
+#define BIT_SHIFT_DPSTU_8822B 2
+#define BIT_MASK_DPSTU_8822B 0x3
+#define BIT_DPSTU_8822B(x)                                                     \
+	(((x) & BIT_MASK_DPSTU_8822B) << BIT_SHIFT_DPSTU_8822B)
+#define BIT_GET_DPSTU_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_DPSTU_8822B) & BIT_MASK_DPSTU_8822B)
+
+#define BIT_SUS_16X_8822B BIT(1)
+
+/* 2 REG_GPIO_MUXCFG_8822B */
+#define BIT_FSPI_EN_8822B BIT(19)
+#define BIT_WL_RTS_EXT_32K_SEL_8822B BIT(18)
+#define BIT_WLGP_SPI_EN_8822B BIT(16)
+#define BIT_SIC_LBK_8822B BIT(15)
+#define BIT_ENHTP_8822B BIT(14)
+#define BIT_ENSIC_8822B BIT(12)
+#define BIT_SIC_SWRST_8822B BIT(11)
+#define BIT_PO_WIFI_PTA_PINS_8822B BIT(10)
+#define BIT_PO_BT_PTA_PINS_8822B BIT(9)
+#define BIT_ENUART_8822B BIT(8)
+
+#define BIT_SHIFT_BTMODE_8822B 6
+#define BIT_MASK_BTMODE_8822B 0x3
+#define BIT_BTMODE_8822B(x)                                                    \
+	(((x) & BIT_MASK_BTMODE_8822B) << BIT_SHIFT_BTMODE_8822B)
+#define BIT_GET_BTMODE_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_BTMODE_8822B) & BIT_MASK_BTMODE_8822B)
+
+#define BIT_ENBT_8822B BIT(5)
+#define BIT_EROM_EN_8822B BIT(4)
+#define BIT_WLRFE_6_7_EN_8822B BIT(3)
+#define BIT_WLRFE_4_5_EN_8822B BIT(2)
+
+#define BIT_SHIFT_GPIOSEL_8822B 0
+#define BIT_MASK_GPIOSEL_8822B 0x3
+#define BIT_GPIOSEL_8822B(x)                                                   \
+	(((x) & BIT_MASK_GPIOSEL_8822B) << BIT_SHIFT_GPIOSEL_8822B)
+#define BIT_GET_GPIOSEL_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_GPIOSEL_8822B) & BIT_MASK_GPIOSEL_8822B)
+
+/* 2 REG_GPIO_PIN_CTRL_8822B */
+
+#define BIT_SHIFT_GPIO_MOD_7_TO_0_8822B 24
+#define BIT_MASK_GPIO_MOD_7_TO_0_8822B 0xff
+#define BIT_GPIO_MOD_7_TO_0_8822B(x)                                           \
+	(((x) & BIT_MASK_GPIO_MOD_7_TO_0_8822B)                                \
+	 << BIT_SHIFT_GPIO_MOD_7_TO_0_8822B)
+#define BIT_GET_GPIO_MOD_7_TO_0_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_GPIO_MOD_7_TO_0_8822B) &                            \
+	 BIT_MASK_GPIO_MOD_7_TO_0_8822B)
+
+#define BIT_SHIFT_GPIO_IO_SEL_7_TO_0_8822B 16
+#define BIT_MASK_GPIO_IO_SEL_7_TO_0_8822B 0xff
+#define BIT_GPIO_IO_SEL_7_TO_0_8822B(x)                                        \
+	(((x) & BIT_MASK_GPIO_IO_SEL_7_TO_0_8822B)                             \
+	 << BIT_SHIFT_GPIO_IO_SEL_7_TO_0_8822B)
+#define BIT_GET_GPIO_IO_SEL_7_TO_0_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_GPIO_IO_SEL_7_TO_0_8822B) &                         \
+	 BIT_MASK_GPIO_IO_SEL_7_TO_0_8822B)
+
+#define BIT_SHIFT_GPIO_OUT_7_TO_0_8822B 8
+#define BIT_MASK_GPIO_OUT_7_TO_0_8822B 0xff
+#define BIT_GPIO_OUT_7_TO_0_8822B(x)                                           \
+	(((x) & BIT_MASK_GPIO_OUT_7_TO_0_8822B)                                \
+	 << BIT_SHIFT_GPIO_OUT_7_TO_0_8822B)
+#define BIT_GET_GPIO_OUT_7_TO_0_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_GPIO_OUT_7_TO_0_8822B) &                            \
+	 BIT_MASK_GPIO_OUT_7_TO_0_8822B)
+
+#define BIT_SHIFT_GPIO_IN_7_TO_0_8822B 0
+#define BIT_MASK_GPIO_IN_7_TO_0_8822B 0xff
+#define BIT_GPIO_IN_7_TO_0_8822B(x)                                            \
+	(((x) & BIT_MASK_GPIO_IN_7_TO_0_8822B)                                 \
+	 << BIT_SHIFT_GPIO_IN_7_TO_0_8822B)
+#define BIT_GET_GPIO_IN_7_TO_0_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_GPIO_IN_7_TO_0_8822B) &                             \
+	 BIT_MASK_GPIO_IN_7_TO_0_8822B)
+
+/* 2 REG_GPIO_INTM_8822B */
+
+#define BIT_SHIFT_MUXDBG_SEL_8822B 30
+#define BIT_MASK_MUXDBG_SEL_8822B 0x3
+#define BIT_MUXDBG_SEL_8822B(x)                                                \
+	(((x) & BIT_MASK_MUXDBG_SEL_8822B) << BIT_SHIFT_MUXDBG_SEL_8822B)
+#define BIT_GET_MUXDBG_SEL_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_MUXDBG_SEL_8822B) & BIT_MASK_MUXDBG_SEL_8822B)
+
+#define BIT_EXTWOL_SEL_8822B BIT(17)
+#define BIT_EXTWOL_EN_8822B BIT(16)
+#define BIT_GPIOF_INT_MD_8822B BIT(15)
+#define BIT_GPIOE_INT_MD_8822B BIT(14)
+#define BIT_GPIOD_INT_MD_8822B BIT(13)
+#define BIT_GPIOF_INT_MD_8822B BIT(15)
+#define BIT_GPIOE_INT_MD_8822B BIT(14)
+#define BIT_GPIOD_INT_MD_8822B BIT(13)
+#define BIT_GPIOC_INT_MD_8822B BIT(12)
+#define BIT_GPIOB_INT_MD_8822B BIT(11)
+#define BIT_GPIOA_INT_MD_8822B BIT(10)
+#define BIT_GPIO9_INT_MD_8822B BIT(9)
+#define BIT_GPIO8_INT_MD_8822B BIT(8)
+#define BIT_GPIO7_INT_MD_8822B BIT(7)
+#define BIT_GPIO6_INT_MD_8822B BIT(6)
+#define BIT_GPIO5_INT_MD_8822B BIT(5)
+#define BIT_GPIO4_INT_MD_8822B BIT(4)
+#define BIT_GPIO3_INT_MD_8822B BIT(3)
+#define BIT_GPIO2_INT_MD_8822B BIT(2)
+#define BIT_GPIO1_INT_MD_8822B BIT(1)
+#define BIT_GPIO0_INT_MD_8822B BIT(0)
+
+/* 2 REG_LED_CFG_8822B */
+#define BIT_GPIO3_WL_CTRL_EN_8822B BIT(27)
+#define BIT_LNAON_SEL_EN_8822B BIT(26)
+#define BIT_PAPE_SEL_EN_8822B BIT(25)
+#define BIT_DPDT_WLBT_SEL_8822B BIT(24)
+#define BIT_DPDT_SEL_EN_8822B BIT(23)
+#define BIT_GPIO13_14_WL_CTRL_EN_8822B BIT(22)
+#define BIT_GPIO13_14_WL_CTRL_EN_8822B BIT(22)
+#define BIT_LED2DIS_8822B BIT(21)
+#define BIT_LED2PL_8822B BIT(20)
+#define BIT_LED2SV_8822B BIT(19)
+
+#define BIT_SHIFT_LED2CM_8822B 16
+#define BIT_MASK_LED2CM_8822B 0x7
+#define BIT_LED2CM_8822B(x)                                                    \
+	(((x) & BIT_MASK_LED2CM_8822B) << BIT_SHIFT_LED2CM_8822B)
+#define BIT_GET_LED2CM_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_LED2CM_8822B) & BIT_MASK_LED2CM_8822B)
+
+#define BIT_LED1DIS_8822B BIT(15)
+#define BIT_LED1PL_8822B BIT(12)
+#define BIT_LED1SV_8822B BIT(11)
+
+#define BIT_SHIFT_LED1CM_8822B 8
+#define BIT_MASK_LED1CM_8822B 0x7
+#define BIT_LED1CM_8822B(x)                                                    \
+	(((x) & BIT_MASK_LED1CM_8822B) << BIT_SHIFT_LED1CM_8822B)
+#define BIT_GET_LED1CM_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_LED1CM_8822B) & BIT_MASK_LED1CM_8822B)
+
+#define BIT_LED0DIS_8822B BIT(7)
+
+#define BIT_SHIFT_AFE_LDO_SWR_CHECK_8822B 5
+#define BIT_MASK_AFE_LDO_SWR_CHECK_8822B 0x3
+#define BIT_AFE_LDO_SWR_CHECK_8822B(x)                                         \
+	(((x) & BIT_MASK_AFE_LDO_SWR_CHECK_8822B)                              \
+	 << BIT_SHIFT_AFE_LDO_SWR_CHECK_8822B)
+#define BIT_GET_AFE_LDO_SWR_CHECK_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_AFE_LDO_SWR_CHECK_8822B) &                          \
+	 BIT_MASK_AFE_LDO_SWR_CHECK_8822B)
+
+#define BIT_LED0PL_8822B BIT(4)
+#define BIT_LED0SV_8822B BIT(3)
+
+#define BIT_SHIFT_LED0CM_8822B 0
+#define BIT_MASK_LED0CM_8822B 0x7
+#define BIT_LED0CM_8822B(x)                                                    \
+	(((x) & BIT_MASK_LED0CM_8822B) << BIT_SHIFT_LED0CM_8822B)
+#define BIT_GET_LED0CM_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_LED0CM_8822B) & BIT_MASK_LED0CM_8822B)
+
+/* 2 REG_FSIMR_8822B */
+#define BIT_FS_PDNINT_EN_8822B BIT(31)
+#define BIT_NFC_INT_PAD_EN_8822B BIT(30)
+#define BIT_FS_SPS_OCP_INT_EN_8822B BIT(29)
+#define BIT_FS_PWMERR_INT_EN_8822B BIT(28)
+#define BIT_FS_GPIOF_INT_EN_8822B BIT(27)
+#define BIT_FS_GPIOE_INT_EN_8822B BIT(26)
+#define BIT_FS_GPIOD_INT_EN_8822B BIT(25)
+#define BIT_FS_GPIOC_INT_EN_8822B BIT(24)
+#define BIT_FS_GPIOB_INT_EN_8822B BIT(23)
+#define BIT_FS_GPIOA_INT_EN_8822B BIT(22)
+#define BIT_FS_GPIO9_INT_EN_8822B BIT(21)
+#define BIT_FS_GPIO8_INT_EN_8822B BIT(20)
+#define BIT_FS_GPIO7_INT_EN_8822B BIT(19)
+#define BIT_FS_GPIO6_INT_EN_8822B BIT(18)
+#define BIT_FS_GPIO5_INT_EN_8822B BIT(17)
+#define BIT_FS_GPIO4_INT_EN_8822B BIT(16)
+#define BIT_FS_GPIO3_INT_EN_8822B BIT(15)
+#define BIT_FS_GPIO2_INT_EN_8822B BIT(14)
+#define BIT_FS_GPIO1_INT_EN_8822B BIT(13)
+#define BIT_FS_GPIO0_INT_EN_8822B BIT(12)
+#define BIT_FS_HCI_SUS_EN_8822B BIT(11)
+#define BIT_FS_HCI_RES_EN_8822B BIT(10)
+#define BIT_FS_HCI_RESET_EN_8822B BIT(9)
+#define BIT_FS_BTON_STS_UPDATE_MSK_EN_8822B BIT(7)
+#define BIT_ACT2RECOVERY_INT_EN_V1_8822B BIT(6)
+#define BIT_GEN1GEN2_SWITCH_8822B BIT(5)
+#define BIT_HCI_TXDMA_REQ_HIMR_8822B BIT(4)
+#define BIT_FS_32K_LEAVE_SETTING_MAK_8822B BIT(3)
+#define BIT_FS_32K_ENTER_SETTING_MAK_8822B BIT(2)
+#define BIT_FS_USB_LPMRSM_MSK_8822B BIT(1)
+#define BIT_FS_USB_LPMINT_MSK_8822B BIT(0)
+
+/* 2 REG_FSISR_8822B */
+#define BIT_FS_PDNINT_8822B BIT(31)
+#define BIT_FS_SPS_OCP_INT_8822B BIT(29)
+#define BIT_FS_PWMERR_INT_8822B BIT(28)
+#define BIT_FS_GPIOF_INT_8822B BIT(27)
+#define BIT_FS_GPIOE_INT_8822B BIT(26)
+#define BIT_FS_GPIOD_INT_8822B BIT(25)
+#define BIT_FS_GPIOC_INT_8822B BIT(24)
+#define BIT_FS_GPIOB_INT_8822B BIT(23)
+#define BIT_FS_GPIOA_INT_8822B BIT(22)
+#define BIT_FS_GPIO9_INT_8822B BIT(21)
+#define BIT_FS_GPIO8_INT_8822B BIT(20)
+#define BIT_FS_GPIO7_INT_8822B BIT(19)
+#define BIT_FS_GPIO6_INT_8822B BIT(18)
+#define BIT_FS_GPIO5_INT_8822B BIT(17)
+#define BIT_FS_GPIO4_INT_8822B BIT(16)
+#define BIT_FS_GPIO3_INT_8822B BIT(15)
+#define BIT_FS_GPIO2_INT_8822B BIT(14)
+#define BIT_FS_GPIO1_INT_8822B BIT(13)
+#define BIT_FS_GPIO0_INT_8822B BIT(12)
+#define BIT_FS_HCI_SUS_INT_8822B BIT(11)
+#define BIT_FS_HCI_RES_INT_8822B BIT(10)
+#define BIT_FS_HCI_RESET_INT_8822B BIT(9)
+#define BIT_ACT2RECOVERY_8822B BIT(6)
+#define BIT_GEN1GEN2_SWITCH_8822B BIT(5)
+#define BIT_HCI_TXDMA_REQ_HISR_8822B BIT(4)
+#define BIT_FS_32K_LEAVE_SETTING_INT_8822B BIT(3)
+#define BIT_FS_32K_ENTER_SETTING_INT_8822B BIT(2)
+#define BIT_FS_USB_LPMRSM_INT_8822B BIT(1)
+#define BIT_FS_USB_LPMINT_INT_8822B BIT(0)
+
+/* 2 REG_HSIMR_8822B */
+#define BIT_GPIOF_INT_EN_8822B BIT(31)
+#define BIT_GPIOE_INT_EN_8822B BIT(30)
+#define BIT_GPIOD_INT_EN_8822B BIT(29)
+#define BIT_GPIOC_INT_EN_8822B BIT(28)
+#define BIT_GPIOB_INT_EN_8822B BIT(27)
+#define BIT_GPIOA_INT_EN_8822B BIT(26)
+#define BIT_GPIO9_INT_EN_8822B BIT(25)
+#define BIT_GPIO8_INT_EN_8822B BIT(24)
+#define BIT_GPIO7_INT_EN_8822B BIT(23)
+#define BIT_GPIO6_INT_EN_8822B BIT(22)
+#define BIT_GPIO5_INT_EN_8822B BIT(21)
+#define BIT_GPIO4_INT_EN_8822B BIT(20)
+#define BIT_GPIO3_INT_EN_8822B BIT(19)
+#define BIT_GPIO2_INT_EN_V1_8822B BIT(16)
+#define BIT_GPIO1_INT_EN_8822B BIT(17)
+#define BIT_GPIO0_INT_EN_8822B BIT(16)
+#define BIT_PDNINT_EN_8822B BIT(7)
+#define BIT_RON_INT_EN_8822B BIT(6)
+#define BIT_SPS_OCP_INT_EN_8822B BIT(5)
+#define BIT_GPIO15_0_INT_EN_8822B BIT(0)
+
+/* 2 REG_HSISR_8822B */
+#define BIT_GPIOF_INT_8822B BIT(31)
+#define BIT_GPIOE_INT_8822B BIT(30)
+#define BIT_GPIOD_INT_8822B BIT(29)
+#define BIT_GPIOC_INT_8822B BIT(28)
+#define BIT_GPIOB_INT_8822B BIT(27)
+#define BIT_GPIOA_INT_8822B BIT(26)
+#define BIT_GPIO9_INT_8822B BIT(25)
+#define BIT_GPIO8_INT_8822B BIT(24)
+#define BIT_GPIO7_INT_8822B BIT(23)
+#define BIT_GPIO6_INT_8822B BIT(22)
+#define BIT_GPIO5_INT_8822B BIT(21)
+#define BIT_GPIO4_INT_8822B BIT(20)
+#define BIT_GPIO3_INT_8822B BIT(19)
+#define BIT_GPIO2_INT_V1_8822B BIT(16)
+#define BIT_GPIO1_INT_8822B BIT(17)
+#define BIT_GPIO0_INT_8822B BIT(16)
+#define BIT_PDNINT_8822B BIT(7)
+#define BIT_RON_INT_8822B BIT(6)
+#define BIT_SPS_OCP_INT_8822B BIT(5)
+#define BIT_GPIO15_0_INT_8822B BIT(0)
+
+/* 2 REG_GPIO_EXT_CTRL_8822B */
+
+#define BIT_SHIFT_GPIO_MOD_15_TO_8_8822B 24
+#define BIT_MASK_GPIO_MOD_15_TO_8_8822B 0xff
+#define BIT_GPIO_MOD_15_TO_8_8822B(x)                                          \
+	(((x) & BIT_MASK_GPIO_MOD_15_TO_8_8822B)                               \
+	 << BIT_SHIFT_GPIO_MOD_15_TO_8_8822B)
+#define BIT_GET_GPIO_MOD_15_TO_8_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_GPIO_MOD_15_TO_8_8822B) &                           \
+	 BIT_MASK_GPIO_MOD_15_TO_8_8822B)
+
+#define BIT_SHIFT_GPIO_IO_SEL_15_TO_8_8822B 16
+#define BIT_MASK_GPIO_IO_SEL_15_TO_8_8822B 0xff
+#define BIT_GPIO_IO_SEL_15_TO_8_8822B(x)                                       \
+	(((x) & BIT_MASK_GPIO_IO_SEL_15_TO_8_8822B)                            \
+	 << BIT_SHIFT_GPIO_IO_SEL_15_TO_8_8822B)
+#define BIT_GET_GPIO_IO_SEL_15_TO_8_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_GPIO_IO_SEL_15_TO_8_8822B) &                        \
+	 BIT_MASK_GPIO_IO_SEL_15_TO_8_8822B)
+
+#define BIT_SHIFT_GPIO_OUT_15_TO_8_8822B 8
+#define BIT_MASK_GPIO_OUT_15_TO_8_8822B 0xff
+#define BIT_GPIO_OUT_15_TO_8_8822B(x)                                          \
+	(((x) & BIT_MASK_GPIO_OUT_15_TO_8_8822B)                               \
+	 << BIT_SHIFT_GPIO_OUT_15_TO_8_8822B)
+#define BIT_GET_GPIO_OUT_15_TO_8_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_GPIO_OUT_15_TO_8_8822B) &                           \
+	 BIT_MASK_GPIO_OUT_15_TO_8_8822B)
+
+#define BIT_SHIFT_GPIO_IN_15_TO_8_8822B 0
+#define BIT_MASK_GPIO_IN_15_TO_8_8822B 0xff
+#define BIT_GPIO_IN_15_TO_8_8822B(x)                                           \
+	(((x) & BIT_MASK_GPIO_IN_15_TO_8_8822B)                                \
+	 << BIT_SHIFT_GPIO_IN_15_TO_8_8822B)
+#define BIT_GET_GPIO_IN_15_TO_8_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_GPIO_IN_15_TO_8_8822B) &                            \
+	 BIT_MASK_GPIO_IN_15_TO_8_8822B)
+
+/* 2 REG_PAD_CTRL1_8822B */
+#define BIT_PAPE_WLBT_SEL_8822B BIT(29)
+#define BIT_LNAON_WLBT_SEL_8822B BIT(28)
+#define BIT_BTGP_GPG3_FEN_8822B BIT(26)
+#define BIT_BTGP_GPG2_FEN_8822B BIT(25)
+#define BIT_BTGP_JTAG_EN_8822B BIT(24)
+#define BIT_XTAL_CLK_EXTARNAL_EN_8822B BIT(23)
+#define BIT_BTGP_UART0_EN_8822B BIT(22)
+#define BIT_BTGP_UART1_EN_8822B BIT(21)
+#define BIT_BTGP_SPI_EN_8822B BIT(20)
+#define BIT_BTGP_GPIO_E2_8822B BIT(19)
+#define BIT_BTGP_GPIO_EN_8822B BIT(18)
+
+#define BIT_SHIFT_BTGP_GPIO_SL_8822B 16
+#define BIT_MASK_BTGP_GPIO_SL_8822B 0x3
+#define BIT_BTGP_GPIO_SL_8822B(x)                                              \
+	(((x) & BIT_MASK_BTGP_GPIO_SL_8822B) << BIT_SHIFT_BTGP_GPIO_SL_8822B)
+#define BIT_GET_BTGP_GPIO_SL_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_BTGP_GPIO_SL_8822B) & BIT_MASK_BTGP_GPIO_SL_8822B)
+
+#define BIT_PAD_SDIO_SR_8822B BIT(14)
+#define BIT_GPIO14_OUTPUT_PL_8822B BIT(13)
+#define BIT_HOST_WAKE_PAD_PULL_EN_8822B BIT(12)
+#define BIT_HOST_WAKE_PAD_SL_8822B BIT(11)
+#define BIT_PAD_LNAON_SR_8822B BIT(10)
+#define BIT_PAD_LNAON_E2_8822B BIT(9)
+#define BIT_SW_LNAON_G_SEL_DATA_8822B BIT(8)
+#define BIT_SW_LNAON_A_SEL_DATA_8822B BIT(7)
+#define BIT_PAD_PAPE_SR_8822B BIT(6)
+#define BIT_PAD_PAPE_E2_8822B BIT(5)
+#define BIT_SW_PAPE_G_SEL_DATA_8822B BIT(4)
+#define BIT_SW_PAPE_A_SEL_DATA_8822B BIT(3)
+#define BIT_PAD_DPDT_SR_8822B BIT(2)
+#define BIT_PAD_DPDT_PAD_E2_8822B BIT(1)
+#define BIT_SW_DPDT_SEL_DATA_8822B BIT(0)
+
+/* 2 REG_WL_BT_PWR_CTRL_8822B */
+#define BIT_ISO_BD2PP_8822B BIT(31)
+#define BIT_LDOV12B_EN_8822B BIT(30)
+#define BIT_CKEN_BTGPS_8822B BIT(29)
+#define BIT_FEN_BTGPS_8822B BIT(28)
+#define BIT_BTCPU_BOOTSEL_8822B BIT(27)
+#define BIT_SPI_SPEEDUP_8822B BIT(26)
+#define BIT_DEVWAKE_PAD_TYPE_SEL_8822B BIT(24)
+#define BIT_CLKREQ_PAD_TYPE_SEL_8822B BIT(23)
+#define BIT_ISO_BTPON2PP_8822B BIT(22)
+#define BIT_BT_HWROF_EN_8822B BIT(19)
+#define BIT_BT_FUNC_EN_8822B BIT(18)
+#define BIT_BT_HWPDN_SL_8822B BIT(17)
+#define BIT_BT_DISN_EN_8822B BIT(16)
+#define BIT_BT_PDN_PULL_EN_8822B BIT(15)
+#define BIT_WL_PDN_PULL_EN_8822B BIT(14)
+#define BIT_EXTERNAL_REQUEST_PL_8822B BIT(13)
+#define BIT_GPIO0_2_3_PULL_LOW_EN_8822B BIT(12)
+#define BIT_ISO_BA2PP_8822B BIT(11)
+#define BIT_BT_AFE_LDO_EN_8822B BIT(10)
+#define BIT_BT_AFE_PLL_EN_8822B BIT(9)
+#define BIT_BT_DIG_CLK_EN_8822B BIT(8)
+#define BIT_WL_DRV_EXIST_IDX_8822B BIT(5)
+#define BIT_DOP_EHPAD_8822B BIT(4)
+#define BIT_WL_HWROF_EN_8822B BIT(3)
+#define BIT_WL_FUNC_EN_8822B BIT(2)
+#define BIT_WL_HWPDN_SL_8822B BIT(1)
+#define BIT_WL_HWPDN_EN_8822B BIT(0)
+
+/* 2 REG_SDM_DEBUG_8822B */
+
+#define BIT_SHIFT_WLCLK_PHASE_8822B 0
+#define BIT_MASK_WLCLK_PHASE_8822B 0x1f
+#define BIT_WLCLK_PHASE_8822B(x)                                               \
+	(((x) & BIT_MASK_WLCLK_PHASE_8822B) << BIT_SHIFT_WLCLK_PHASE_8822B)
+#define BIT_GET_WLCLK_PHASE_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_WLCLK_PHASE_8822B) & BIT_MASK_WLCLK_PHASE_8822B)
+
+/* 2 REG_SYS_SDIO_CTRL_8822B */
+#define BIT_DBG_GNT_WL_BT_8822B BIT(27)
+#define BIT_LTE_MUX_CTRL_PATH_8822B BIT(26)
+#define BIT_LTE_COEX_UART_8822B BIT(25)
+#define BIT_3W_LTE_WL_GPIO_8822B BIT(24)
+#define BIT_SDIO_INT_POLARITY_8822B BIT(19)
+#define BIT_SDIO_INT_8822B BIT(18)
+#define BIT_SDIO_OFF_EN_8822B BIT(17)
+#define BIT_SDIO_ON_EN_8822B BIT(16)
+#define BIT_PCIE_WAIT_TIMEOUT_EVENT_8822B BIT(10)
+#define BIT_PCIE_WAIT_TIME_8822B BIT(9)
+#define BIT_MPCIE_REFCLK_XTAL_SEL_8822B BIT(8)
+
+/* 2 REG_HCI_OPT_CTRL_8822B */
+
+#define BIT_SHIFT_TSFT_SEL_8822B 29
+#define BIT_MASK_TSFT_SEL_8822B 0x7
+#define BIT_TSFT_SEL_8822B(x)                                                  \
+	(((x) & BIT_MASK_TSFT_SEL_8822B) << BIT_SHIFT_TSFT_SEL_8822B)
+#define BIT_GET_TSFT_SEL_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_TSFT_SEL_8822B) & BIT_MASK_TSFT_SEL_8822B)
+
+#define BIT_USB_HOST_PWR_OFF_EN_8822B BIT(12)
+#define BIT_SYM_LPS_BLOCK_EN_8822B BIT(11)
+#define BIT_USB_LPM_ACT_EN_8822B BIT(10)
+#define BIT_USB_LPM_NY_8822B BIT(9)
+#define BIT_USB_SUS_DIS_8822B BIT(8)
+
+#define BIT_SHIFT_SDIO_PAD_E_8822B 5
+#define BIT_MASK_SDIO_PAD_E_8822B 0x7
+#define BIT_SDIO_PAD_E_8822B(x)                                                \
+	(((x) & BIT_MASK_SDIO_PAD_E_8822B) << BIT_SHIFT_SDIO_PAD_E_8822B)
+#define BIT_GET_SDIO_PAD_E_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_SDIO_PAD_E_8822B) & BIT_MASK_SDIO_PAD_E_8822B)
+
+#define BIT_USB_LPPLL_EN_8822B BIT(4)
+#define BIT_ROP_SW15_8822B BIT(2)
+#define BIT_PCI_CKRDY_OPT_8822B BIT(1)
+#define BIT_PCI_VAUX_EN_8822B BIT(0)
+
+/* 2 REG_AFE_CTRL4_8822B */
+
+/* 2 REG_LDO_SWR_CTRL_8822B */
+#define BIT_ZCD_HW_AUTO_EN_8822B BIT(27)
+#define BIT_ZCD_REGSEL_8822B BIT(26)
+
+#define BIT_SHIFT_AUTO_ZCD_IN_CODE_8822B 21
+#define BIT_MASK_AUTO_ZCD_IN_CODE_8822B 0x1f
+#define BIT_AUTO_ZCD_IN_CODE_8822B(x)                                          \
+	(((x) & BIT_MASK_AUTO_ZCD_IN_CODE_8822B)                               \
+	 << BIT_SHIFT_AUTO_ZCD_IN_CODE_8822B)
+#define BIT_GET_AUTO_ZCD_IN_CODE_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_AUTO_ZCD_IN_CODE_8822B) &                           \
+	 BIT_MASK_AUTO_ZCD_IN_CODE_8822B)
+
+#define BIT_SHIFT_ZCD_CODE_IN_L_8822B 16
+#define BIT_MASK_ZCD_CODE_IN_L_8822B 0x1f
+#define BIT_ZCD_CODE_IN_L_8822B(x)                                             \
+	(((x) & BIT_MASK_ZCD_CODE_IN_L_8822B) << BIT_SHIFT_ZCD_CODE_IN_L_8822B)
+#define BIT_GET_ZCD_CODE_IN_L_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_ZCD_CODE_IN_L_8822B) & BIT_MASK_ZCD_CODE_IN_L_8822B)
+
+#define BIT_SHIFT_LDO_HV5_DUMMY_8822B 14
+#define BIT_MASK_LDO_HV5_DUMMY_8822B 0x3
+#define BIT_LDO_HV5_DUMMY_8822B(x)                                             \
+	(((x) & BIT_MASK_LDO_HV5_DUMMY_8822B) << BIT_SHIFT_LDO_HV5_DUMMY_8822B)
+#define BIT_GET_LDO_HV5_DUMMY_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_LDO_HV5_DUMMY_8822B) & BIT_MASK_LDO_HV5_DUMMY_8822B)
+
+#define BIT_SHIFT_REG_VTUNE33_BIT0_TO_BIT1_8822B 12
+#define BIT_MASK_REG_VTUNE33_BIT0_TO_BIT1_8822B 0x3
+#define BIT_REG_VTUNE33_BIT0_TO_BIT1_8822B(x)                                  \
+	(((x) & BIT_MASK_REG_VTUNE33_BIT0_TO_BIT1_8822B)                       \
+	 << BIT_SHIFT_REG_VTUNE33_BIT0_TO_BIT1_8822B)
+#define BIT_GET_REG_VTUNE33_BIT0_TO_BIT1_8822B(x)                              \
+	(((x) >> BIT_SHIFT_REG_VTUNE33_BIT0_TO_BIT1_8822B) &                   \
+	 BIT_MASK_REG_VTUNE33_BIT0_TO_BIT1_8822B)
+
+#define BIT_SHIFT_REG_STANDBY33_BIT0_TO_BIT1_8822B 10
+#define BIT_MASK_REG_STANDBY33_BIT0_TO_BIT1_8822B 0x3
+#define BIT_REG_STANDBY33_BIT0_TO_BIT1_8822B(x)                                \
+	(((x) & BIT_MASK_REG_STANDBY33_BIT0_TO_BIT1_8822B)                     \
+	 << BIT_SHIFT_REG_STANDBY33_BIT0_TO_BIT1_8822B)
+#define BIT_GET_REG_STANDBY33_BIT0_TO_BIT1_8822B(x)                            \
+	(((x) >> BIT_SHIFT_REG_STANDBY33_BIT0_TO_BIT1_8822B) &                 \
+	 BIT_MASK_REG_STANDBY33_BIT0_TO_BIT1_8822B)
+
+#define BIT_SHIFT_REG_LOAD33_BIT0_TO_BIT1_8822B 8
+#define BIT_MASK_REG_LOAD33_BIT0_TO_BIT1_8822B 0x3
+#define BIT_REG_LOAD33_BIT0_TO_BIT1_8822B(x)                                   \
+	(((x) & BIT_MASK_REG_LOAD33_BIT0_TO_BIT1_8822B)                        \
+	 << BIT_SHIFT_REG_LOAD33_BIT0_TO_BIT1_8822B)
+#define BIT_GET_REG_LOAD33_BIT0_TO_BIT1_8822B(x)                               \
+	(((x) >> BIT_SHIFT_REG_LOAD33_BIT0_TO_BIT1_8822B) &                    \
+	 BIT_MASK_REG_LOAD33_BIT0_TO_BIT1_8822B)
+
+#define BIT_REG_BYPASS_L_8822B BIT(7)
+#define BIT_REG_LDOF_L_8822B BIT(6)
+#define BIT_REG_TYPE_L_V1_8822B BIT(5)
+#define BIT_ARENB_L_8822B BIT(3)
+
+#define BIT_SHIFT_CFC_L_8822B 1
+#define BIT_MASK_CFC_L_8822B 0x3
+#define BIT_CFC_L_8822B(x)                                                     \
+	(((x) & BIT_MASK_CFC_L_8822B) << BIT_SHIFT_CFC_L_8822B)
+#define BIT_GET_CFC_L_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_CFC_L_8822B) & BIT_MASK_CFC_L_8822B)
+
+#define BIT_REG_OCPS_L_V1_8822B BIT(0)
+
+/* 2 REG_MCUFW_CTRL_8822B */
+
+#define BIT_SHIFT_RPWM_8822B 24
+#define BIT_MASK_RPWM_8822B 0xff
+#define BIT_RPWM_8822B(x) (((x) & BIT_MASK_RPWM_8822B) << BIT_SHIFT_RPWM_8822B)
+#define BIT_GET_RPWM_8822B(x)                                                  \
+	(((x) >> BIT_SHIFT_RPWM_8822B) & BIT_MASK_RPWM_8822B)
+
+#define BIT_ANA_PORT_EN_8822B BIT(22)
+#define BIT_MAC_PORT_EN_8822B BIT(21)
+#define BIT_BOOT_FSPI_EN_8822B BIT(20)
+#define BIT_ROM_DLEN_8822B BIT(19)
+
+#define BIT_SHIFT_ROM_PGE_8822B 16
+#define BIT_MASK_ROM_PGE_8822B 0x7
+#define BIT_ROM_PGE_8822B(x)                                                   \
+	(((x) & BIT_MASK_ROM_PGE_8822B) << BIT_SHIFT_ROM_PGE_8822B)
+#define BIT_GET_ROM_PGE_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_ROM_PGE_8822B) & BIT_MASK_ROM_PGE_8822B)
+
+#define BIT_FW_INIT_RDY_8822B BIT(15)
+#define BIT_FW_DW_RDY_8822B BIT(14)
+
+#define BIT_SHIFT_CPU_CLK_SEL_8822B 12
+#define BIT_MASK_CPU_CLK_SEL_8822B 0x3
+#define BIT_CPU_CLK_SEL_8822B(x)                                               \
+	(((x) & BIT_MASK_CPU_CLK_SEL_8822B) << BIT_SHIFT_CPU_CLK_SEL_8822B)
+#define BIT_GET_CPU_CLK_SEL_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_CPU_CLK_SEL_8822B) & BIT_MASK_CPU_CLK_SEL_8822B)
+
+#define BIT_CCLK_CHG_MASK_8822B BIT(11)
+#define BIT_EMEM__TXBUF_CHKSUM_OK_8822B BIT(10)
+#define BIT_EMEM_TXBUF_DW_RDY_8822B BIT(9)
+#define BIT_EMEM_CHKSUM_OK_8822B BIT(8)
+#define BIT_EMEM_DW_OK_8822B BIT(7)
+#define BIT_DMEM_CHKSUM_OK_8822B BIT(6)
+#define BIT_DMEM_DW_OK_8822B BIT(5)
+#define BIT_IMEM_CHKSUM_OK_8822B BIT(4)
+#define BIT_IMEM_DW_OK_8822B BIT(3)
+#define BIT_IMEM_BOOT_LOAD_CHKSUM_OK_8822B BIT(2)
+#define BIT_IMEM_BOOT_LOAD_DW_OK_8822B BIT(1)
+#define BIT_MCUFWDL_EN_8822B BIT(0)
+
+/* 2 REG_MCU_TST_CFG_8822B */
+
+#define BIT_SHIFT_LBKTST_8822B 0
+#define BIT_MASK_LBKTST_8822B 0xffff
+#define BIT_LBKTST_8822B(x)                                                    \
+	(((x) & BIT_MASK_LBKTST_8822B) << BIT_SHIFT_LBKTST_8822B)
+#define BIT_GET_LBKTST_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_LBKTST_8822B) & BIT_MASK_LBKTST_8822B)
+
+/* 2 REG_HMEBOX_E0_E1_8822B */
+
+#define BIT_SHIFT_HOST_MSG_E1_8822B 16
+#define BIT_MASK_HOST_MSG_E1_8822B 0xffff
+#define BIT_HOST_MSG_E1_8822B(x)                                               \
+	(((x) & BIT_MASK_HOST_MSG_E1_8822B) << BIT_SHIFT_HOST_MSG_E1_8822B)
+#define BIT_GET_HOST_MSG_E1_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HOST_MSG_E1_8822B) & BIT_MASK_HOST_MSG_E1_8822B)
+
+#define BIT_SHIFT_HOST_MSG_E0_8822B 0
+#define BIT_MASK_HOST_MSG_E0_8822B 0xffff
+#define BIT_HOST_MSG_E0_8822B(x)                                               \
+	(((x) & BIT_MASK_HOST_MSG_E0_8822B) << BIT_SHIFT_HOST_MSG_E0_8822B)
+#define BIT_GET_HOST_MSG_E0_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HOST_MSG_E0_8822B) & BIT_MASK_HOST_MSG_E0_8822B)
+
+/* 2 REG_HMEBOX_E2_E3_8822B */
+
+#define BIT_SHIFT_HOST_MSG_E3_8822B 16
+#define BIT_MASK_HOST_MSG_E3_8822B 0xffff
+#define BIT_HOST_MSG_E3_8822B(x)                                               \
+	(((x) & BIT_MASK_HOST_MSG_E3_8822B) << BIT_SHIFT_HOST_MSG_E3_8822B)
+#define BIT_GET_HOST_MSG_E3_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HOST_MSG_E3_8822B) & BIT_MASK_HOST_MSG_E3_8822B)
+
+#define BIT_SHIFT_HOST_MSG_E2_8822B 0
+#define BIT_MASK_HOST_MSG_E2_8822B 0xffff
+#define BIT_HOST_MSG_E2_8822B(x)                                               \
+	(((x) & BIT_MASK_HOST_MSG_E2_8822B) << BIT_SHIFT_HOST_MSG_E2_8822B)
+#define BIT_GET_HOST_MSG_E2_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HOST_MSG_E2_8822B) & BIT_MASK_HOST_MSG_E2_8822B)
+
+/* 2 REG_WLLPS_CTRL_8822B */
+#define BIT_WLLPSOP_EABM_8822B BIT(31)
+#define BIT_WLLPSOP_ACKF_8822B BIT(30)
+#define BIT_WLLPSOP_DLDM_8822B BIT(29)
+#define BIT_WLLPSOP_ESWR_8822B BIT(28)
+#define BIT_WLLPSOP_PWMM_8822B BIT(27)
+#define BIT_WLLPSOP_EECK_8822B BIT(26)
+#define BIT_WLLPSOP_WLMACOFF_8822B BIT(25)
+#define BIT_WLLPSOP_EXTAL_8822B BIT(24)
+#define BIT_WL_SYNPON_VOLTSPDN_8822B BIT(23)
+#define BIT_WLLPSOP_WLBBOFF_8822B BIT(22)
+#define BIT_WLLPSOP_WLMEM_DS_8822B BIT(21)
+
+#define BIT_SHIFT_LPLDH12_VADJ_STEP_DN_8822B 12
+#define BIT_MASK_LPLDH12_VADJ_STEP_DN_8822B 0xf
+#define BIT_LPLDH12_VADJ_STEP_DN_8822B(x)                                      \
+	(((x) & BIT_MASK_LPLDH12_VADJ_STEP_DN_8822B)                           \
+	 << BIT_SHIFT_LPLDH12_VADJ_STEP_DN_8822B)
+#define BIT_GET_LPLDH12_VADJ_STEP_DN_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_LPLDH12_VADJ_STEP_DN_8822B) &                       \
+	 BIT_MASK_LPLDH12_VADJ_STEP_DN_8822B)
+
+#define BIT_SHIFT_V15ADJ_L1_STEP_DN_8822B 8
+#define BIT_MASK_V15ADJ_L1_STEP_DN_8822B 0x7
+#define BIT_V15ADJ_L1_STEP_DN_8822B(x)                                         \
+	(((x) & BIT_MASK_V15ADJ_L1_STEP_DN_8822B)                              \
+	 << BIT_SHIFT_V15ADJ_L1_STEP_DN_8822B)
+#define BIT_GET_V15ADJ_L1_STEP_DN_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_V15ADJ_L1_STEP_DN_8822B) &                          \
+	 BIT_MASK_V15ADJ_L1_STEP_DN_8822B)
+
+#define BIT_REGU_32K_CLK_EN_8822B BIT(1)
+#define BIT_WL_LPS_EN_8822B BIT(0)
+
+/* 2 REG_AFE_CTRL5_8822B */
+#define BIT_BB_DBG_SEL_AFE_SDM_BIT0_8822B BIT(31)
+#define BIT_ORDER_SDM_8822B BIT(30)
+#define BIT_RFE_SEL_SDM_8822B BIT(29)
+
+#define BIT_SHIFT_REF_SEL_8822B 25
+#define BIT_MASK_REF_SEL_8822B 0xf
+#define BIT_REF_SEL_8822B(x)                                                   \
+	(((x) & BIT_MASK_REF_SEL_8822B) << BIT_SHIFT_REF_SEL_8822B)
+#define BIT_GET_REF_SEL_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_REF_SEL_8822B) & BIT_MASK_REF_SEL_8822B)
+
+#define BIT_SHIFT_F0F_SDM_8822B 12
+#define BIT_MASK_F0F_SDM_8822B 0x1fff
+#define BIT_F0F_SDM_8822B(x)                                                   \
+	(((x) & BIT_MASK_F0F_SDM_8822B) << BIT_SHIFT_F0F_SDM_8822B)
+#define BIT_GET_F0F_SDM_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_F0F_SDM_8822B) & BIT_MASK_F0F_SDM_8822B)
+
+#define BIT_SHIFT_F0N_SDM_8822B 9
+#define BIT_MASK_F0N_SDM_8822B 0x7
+#define BIT_F0N_SDM_8822B(x)                                                   \
+	(((x) & BIT_MASK_F0N_SDM_8822B) << BIT_SHIFT_F0N_SDM_8822B)
+#define BIT_GET_F0N_SDM_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_F0N_SDM_8822B) & BIT_MASK_F0N_SDM_8822B)
+
+#define BIT_SHIFT_DIVN_SDM_8822B 3
+#define BIT_MASK_DIVN_SDM_8822B 0x3f
+#define BIT_DIVN_SDM_8822B(x)                                                  \
+	(((x) & BIT_MASK_DIVN_SDM_8822B) << BIT_SHIFT_DIVN_SDM_8822B)
+#define BIT_GET_DIVN_SDM_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_DIVN_SDM_8822B) & BIT_MASK_DIVN_SDM_8822B)
+
+/* 2 REG_GPIO_DEBOUNCE_CTRL_8822B */
+#define BIT_WLGP_DBC1EN_8822B BIT(15)
+
+#define BIT_SHIFT_WLGP_DBC1_8822B 8
+#define BIT_MASK_WLGP_DBC1_8822B 0xf
+#define BIT_WLGP_DBC1_8822B(x)                                                 \
+	(((x) & BIT_MASK_WLGP_DBC1_8822B) << BIT_SHIFT_WLGP_DBC1_8822B)
+#define BIT_GET_WLGP_DBC1_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_WLGP_DBC1_8822B) & BIT_MASK_WLGP_DBC1_8822B)
+
+#define BIT_WLGP_DBC0EN_8822B BIT(7)
+
+#define BIT_SHIFT_WLGP_DBC0_8822B 0
+#define BIT_MASK_WLGP_DBC0_8822B 0xf
+#define BIT_WLGP_DBC0_8822B(x)                                                 \
+	(((x) & BIT_MASK_WLGP_DBC0_8822B) << BIT_SHIFT_WLGP_DBC0_8822B)
+#define BIT_GET_WLGP_DBC0_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_WLGP_DBC0_8822B) & BIT_MASK_WLGP_DBC0_8822B)
+
+/* 2 REG_RPWM2_8822B */
+
+#define BIT_SHIFT_RPWM2_8822B 16
+#define BIT_MASK_RPWM2_8822B 0xffff
+#define BIT_RPWM2_8822B(x)                                                     \
+	(((x) & BIT_MASK_RPWM2_8822B) << BIT_SHIFT_RPWM2_8822B)
+#define BIT_GET_RPWM2_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_RPWM2_8822B) & BIT_MASK_RPWM2_8822B)
+
+/* 2 REG_SYSON_FSM_MON_8822B */
+
+#define BIT_SHIFT_FSM_MON_SEL_8822B 24
+#define BIT_MASK_FSM_MON_SEL_8822B 0x7
+#define BIT_FSM_MON_SEL_8822B(x)                                               \
+	(((x) & BIT_MASK_FSM_MON_SEL_8822B) << BIT_SHIFT_FSM_MON_SEL_8822B)
+#define BIT_GET_FSM_MON_SEL_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_FSM_MON_SEL_8822B) & BIT_MASK_FSM_MON_SEL_8822B)
+
+#define BIT_DOP_ELDO_8822B BIT(23)
+#define BIT_FSM_MON_UPD_8822B BIT(15)
+
+#define BIT_SHIFT_FSM_PAR_8822B 0
+#define BIT_MASK_FSM_PAR_8822B 0x7fff
+#define BIT_FSM_PAR_8822B(x)                                                   \
+	(((x) & BIT_MASK_FSM_PAR_8822B) << BIT_SHIFT_FSM_PAR_8822B)
+#define BIT_GET_FSM_PAR_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_FSM_PAR_8822B) & BIT_MASK_FSM_PAR_8822B)
+
+/* 2 REG_AFE_CTRL6_8822B */
+
+#define BIT_SHIFT_BB_DBG_SEL_AFE_SDM_BIT3_1_8822B 0
+#define BIT_MASK_BB_DBG_SEL_AFE_SDM_BIT3_1_8822B 0x7
+#define BIT_BB_DBG_SEL_AFE_SDM_BIT3_1_8822B(x)                                 \
+	(((x) & BIT_MASK_BB_DBG_SEL_AFE_SDM_BIT3_1_8822B)                      \
+	 << BIT_SHIFT_BB_DBG_SEL_AFE_SDM_BIT3_1_8822B)
+#define BIT_GET_BB_DBG_SEL_AFE_SDM_BIT3_1_8822B(x)                             \
+	(((x) >> BIT_SHIFT_BB_DBG_SEL_AFE_SDM_BIT3_1_8822B) &                  \
+	 BIT_MASK_BB_DBG_SEL_AFE_SDM_BIT3_1_8822B)
+
+/* 2 REG_PMC_DBG_CTRL1_8822B */
+#define BIT_BT_INT_EN_8822B BIT(31)
+
+#define BIT_SHIFT_RD_WR_WIFI_BT_INFO_8822B 16
+#define BIT_MASK_RD_WR_WIFI_BT_INFO_8822B 0x7fff
+#define BIT_RD_WR_WIFI_BT_INFO_8822B(x)                                        \
+	(((x) & BIT_MASK_RD_WR_WIFI_BT_INFO_8822B)                             \
+	 << BIT_SHIFT_RD_WR_WIFI_BT_INFO_8822B)
+#define BIT_GET_RD_WR_WIFI_BT_INFO_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_RD_WR_WIFI_BT_INFO_8822B) &                         \
+	 BIT_MASK_RD_WR_WIFI_BT_INFO_8822B)
+
+#define BIT_PMC_WR_OVF_8822B BIT(8)
+
+#define BIT_SHIFT_WLPMC_ERRINT_8822B 0
+#define BIT_MASK_WLPMC_ERRINT_8822B 0xff
+#define BIT_WLPMC_ERRINT_8822B(x)                                              \
+	(((x) & BIT_MASK_WLPMC_ERRINT_8822B) << BIT_SHIFT_WLPMC_ERRINT_8822B)
+#define BIT_GET_WLPMC_ERRINT_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_WLPMC_ERRINT_8822B) & BIT_MASK_WLPMC_ERRINT_8822B)
+
+/* 2 REG_AFE_CTRL7_8822B */
+
+#define BIT_SHIFT_SEL_V_8822B 30
+#define BIT_MASK_SEL_V_8822B 0x3
+#define BIT_SEL_V_8822B(x)                                                     \
+	(((x) & BIT_MASK_SEL_V_8822B) << BIT_SHIFT_SEL_V_8822B)
+#define BIT_GET_SEL_V_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_SEL_V_8822B) & BIT_MASK_SEL_V_8822B)
+
+#define BIT_SEL_LDO_PC_8822B BIT(29)
+
+#define BIT_SHIFT_CK_MON_SEL_8822B 26
+#define BIT_MASK_CK_MON_SEL_8822B 0x7
+#define BIT_CK_MON_SEL_8822B(x)                                                \
+	(((x) & BIT_MASK_CK_MON_SEL_8822B) << BIT_SHIFT_CK_MON_SEL_8822B)
+#define BIT_GET_CK_MON_SEL_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_CK_MON_SEL_8822B) & BIT_MASK_CK_MON_SEL_8822B)
+
+#define BIT_CK_MON_EN_8822B BIT(25)
+#define BIT_FREF_EDGE_8822B BIT(24)
+#define BIT_CK320M_EN_8822B BIT(23)
+#define BIT_CK_5M_EN_8822B BIT(22)
+#define BIT_TESTEN_8822B BIT(21)
+
+/* 2 REG_HIMR0_8822B */
+#define BIT_TIMEOUT_INTERRUPT2_MASK_8822B BIT(31)
+#define BIT_TIMEOUT_INTERRUTP1_MASK_8822B BIT(30)
+#define BIT_PSTIMEOUT_MSK_8822B BIT(29)
+#define BIT_GTINT4_MSK_8822B BIT(28)
+#define BIT_GTINT3_MSK_8822B BIT(27)
+#define BIT_TXBCN0ERR_MSK_8822B BIT(26)
+#define BIT_TXBCN0OK_MSK_8822B BIT(25)
+#define BIT_TSF_BIT32_TOGGLE_MSK_8822B BIT(24)
+#define BIT_BCNDMAINT0_MSK_8822B BIT(20)
+#define BIT_BCNDERR0_MSK_8822B BIT(16)
+#define BIT_HSISR_IND_ON_INT_MSK_8822B BIT(15)
+#define BIT_BCNDMAINT_E_MSK_8822B BIT(14)
+#define BIT_CTWEND_MSK_8822B BIT(12)
+#define BIT_HISR1_IND_MSK_8822B BIT(11)
+#define BIT_C2HCMD_MSK_8822B BIT(10)
+#define BIT_CPWM2_MSK_8822B BIT(9)
+#define BIT_CPWM_MSK_8822B BIT(8)
+#define BIT_HIGHDOK_MSK_8822B BIT(7)
+#define BIT_MGTDOK_MSK_8822B BIT(6)
+#define BIT_BKDOK_MSK_8822B BIT(5)
+#define BIT_BEDOK_MSK_8822B BIT(4)
+#define BIT_VIDOK_MSK_8822B BIT(3)
+#define BIT_VODOK_MSK_8822B BIT(2)
+#define BIT_RDU_MSK_8822B BIT(1)
+#define BIT_RXOK_MSK_8822B BIT(0)
+
+/* 2 REG_HISR0_8822B */
+#define BIT_TIMEOUT_INTERRUPT2_8822B BIT(31)
+#define BIT_TIMEOUT_INTERRUTP1_8822B BIT(30)
+#define BIT_PSTIMEOUT_8822B BIT(29)
+#define BIT_GTINT4_8822B BIT(28)
+#define BIT_GTINT3_8822B BIT(27)
+#define BIT_TXBCN0ERR_8822B BIT(26)
+#define BIT_TXBCN0OK_8822B BIT(25)
+#define BIT_TSF_BIT32_TOGGLE_8822B BIT(24)
+#define BIT_BCNDMAINT0_8822B BIT(20)
+#define BIT_BCNDERR0_8822B BIT(16)
+#define BIT_HSISR_IND_ON_INT_8822B BIT(15)
+#define BIT_BCNDMAINT_E_8822B BIT(14)
+#define BIT_CTWEND_8822B BIT(12)
+#define BIT_HISR1_IND_INT_8822B BIT(11)
+#define BIT_C2HCMD_8822B BIT(10)
+#define BIT_CPWM2_8822B BIT(9)
+#define BIT_CPWM_8822B BIT(8)
+#define BIT_HIGHDOK_8822B BIT(7)
+#define BIT_MGTDOK_8822B BIT(6)
+#define BIT_BKDOK_8822B BIT(5)
+#define BIT_BEDOK_8822B BIT(4)
+#define BIT_VIDOK_8822B BIT(3)
+#define BIT_VODOK_8822B BIT(2)
+#define BIT_RDU_8822B BIT(1)
+#define BIT_RXOK_8822B BIT(0)
+
+/* 2 REG_HIMR1_8822B */
+#define BIT_TXFIFO_TH_INT_8822B BIT(30)
+#define BIT_BTON_STS_UPDATE_MASK_8822B BIT(29)
+#define BIT_MCU_ERR_MASK_8822B BIT(28)
+#define BIT_BCNDMAINT7__MSK_8822B BIT(27)
+#define BIT_BCNDMAINT6__MSK_8822B BIT(26)
+#define BIT_BCNDMAINT5__MSK_8822B BIT(25)
+#define BIT_BCNDMAINT4__MSK_8822B BIT(24)
+#define BIT_BCNDMAINT3_MSK_8822B BIT(23)
+#define BIT_BCNDMAINT2_MSK_8822B BIT(22)
+#define BIT_BCNDMAINT1_MSK_8822B BIT(21)
+#define BIT_BCNDERR7_MSK_8822B BIT(20)
+#define BIT_BCNDERR6_MSK_8822B BIT(19)
+#define BIT_BCNDERR5_MSK_8822B BIT(18)
+#define BIT_BCNDERR4_MSK_8822B BIT(17)
+#define BIT_BCNDERR3_MSK_8822B BIT(16)
+#define BIT_BCNDERR2_MSK_8822B BIT(15)
+#define BIT_BCNDERR1_MSK_8822B BIT(14)
+#define BIT_ATIMEND_E_MSK_8822B BIT(13)
+#define BIT_ATIMEND__MSK_8822B BIT(12)
+#define BIT_TXERR_MSK_8822B BIT(11)
+#define BIT_RXERR_MSK_8822B BIT(10)
+#define BIT_TXFOVW_MSK_8822B BIT(9)
+#define BIT_FOVW_MSK_8822B BIT(8)
+#define BIT_CPU_MGQ_TXDONE_MSK_8822B BIT(5)
+#define BIT_PS_TIMER_C_MSK_8822B BIT(4)
+#define BIT_PS_TIMER_B_MSK_8822B BIT(3)
+#define BIT_PS_TIMER_A_MSK_8822B BIT(2)
+#define BIT_CPUMGQ_TX_TIMER_MSK_8822B BIT(1)
+
+/* 2 REG_HISR1_8822B */
+#define BIT_TXFIFO_TH_INT_8822B BIT(30)
+#define BIT_BTON_STS_UPDATE_INT_8822B BIT(29)
+#define BIT_MCU_ERR_8822B BIT(28)
+#define BIT_BCNDMAINT7_8822B BIT(27)
+#define BIT_BCNDMAINT6_8822B BIT(26)
+#define BIT_BCNDMAINT5_8822B BIT(25)
+#define BIT_BCNDMAINT4_8822B BIT(24)
+#define BIT_BCNDMAINT3_8822B BIT(23)
+#define BIT_BCNDMAINT2_8822B BIT(22)
+#define BIT_BCNDMAINT1_8822B BIT(21)
+#define BIT_BCNDERR7_8822B BIT(20)
+#define BIT_BCNDERR6_8822B BIT(19)
+#define BIT_BCNDERR5_8822B BIT(18)
+#define BIT_BCNDERR4_8822B BIT(17)
+#define BIT_BCNDERR3_8822B BIT(16)
+#define BIT_BCNDERR2_8822B BIT(15)
+#define BIT_BCNDERR1_8822B BIT(14)
+#define BIT_ATIMEND_E_8822B BIT(13)
+#define BIT_ATIMEND_8822B BIT(12)
+#define BIT_TXERR_INT_8822B BIT(11)
+#define BIT_RXERR_INT_8822B BIT(10)
+#define BIT_TXFOVW_8822B BIT(9)
+#define BIT_FOVW_8822B BIT(8)
+#define BIT_CPU_MGQ_TXDONE_8822B BIT(5)
+#define BIT_PS_TIMER_C_8822B BIT(4)
+#define BIT_PS_TIMER_B_8822B BIT(3)
+#define BIT_PS_TIMER_A_8822B BIT(2)
+#define BIT_CPUMGQ_TX_TIMER_8822B BIT(1)
+
+/* 2 REG_DBG_PORT_SEL_8822B */
+
+#define BIT_SHIFT_DEBUG_ST_8822B 0
+#define BIT_MASK_DEBUG_ST_8822B 0xffffffffL
+#define BIT_DEBUG_ST_8822B(x)                                                  \
+	(((x) & BIT_MASK_DEBUG_ST_8822B) << BIT_SHIFT_DEBUG_ST_8822B)
+#define BIT_GET_DEBUG_ST_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_DEBUG_ST_8822B) & BIT_MASK_DEBUG_ST_8822B)
+
+/* 2 REG_PAD_CTRL2_8822B */
+#define BIT_USB3_USB2_TRANSITION_8822B BIT(20)
+
+#define BIT_SHIFT_USB23_SW_MODE_V1_8822B 18
+#define BIT_MASK_USB23_SW_MODE_V1_8822B 0x3
+#define BIT_USB23_SW_MODE_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_USB23_SW_MODE_V1_8822B)                               \
+	 << BIT_SHIFT_USB23_SW_MODE_V1_8822B)
+#define BIT_GET_USB23_SW_MODE_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_USB23_SW_MODE_V1_8822B) &                           \
+	 BIT_MASK_USB23_SW_MODE_V1_8822B)
+
+#define BIT_NO_PDN_CHIPOFF_V1_8822B BIT(17)
+#define BIT_RSM_EN_V1_8822B BIT(16)
+
+#define BIT_SHIFT_MATCH_CNT_8822B 8
+#define BIT_MASK_MATCH_CNT_8822B 0xff
+#define BIT_MATCH_CNT_8822B(x)                                                 \
+	(((x) & BIT_MASK_MATCH_CNT_8822B) << BIT_SHIFT_MATCH_CNT_8822B)
+#define BIT_GET_MATCH_CNT_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_MATCH_CNT_8822B) & BIT_MASK_MATCH_CNT_8822B)
+
+#define BIT_LD_B12V_EN_8822B BIT(7)
+#define BIT_EECS_IOSEL_V1_8822B BIT(6)
+#define BIT_EECS_DATA_O_V1_8822B BIT(5)
+#define BIT_EECS_DATA_I_V1_8822B BIT(4)
+#define BIT_EESK_IOSEL_V1_8822B BIT(2)
+#define BIT_EESK_DATA_O_V1_8822B BIT(1)
+#define BIT_EESK_DATA_I_V1_8822B BIT(0)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_PMC_DBG_CTRL2_8822B */
+
+#define BIT_SHIFT_EFUSE_BURN_GNT_8822B 24
+#define BIT_MASK_EFUSE_BURN_GNT_8822B 0xff
+#define BIT_EFUSE_BURN_GNT_8822B(x)                                            \
+	(((x) & BIT_MASK_EFUSE_BURN_GNT_8822B)                                 \
+	 << BIT_SHIFT_EFUSE_BURN_GNT_8822B)
+#define BIT_GET_EFUSE_BURN_GNT_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_EFUSE_BURN_GNT_8822B) &                             \
+	 BIT_MASK_EFUSE_BURN_GNT_8822B)
+
+#define BIT_STOP_WL_PMC_8822B BIT(9)
+#define BIT_STOP_SYM_PMC_8822B BIT(8)
+#define BIT_REG_RST_WLPMC_8822B BIT(5)
+#define BIT_REG_RST_PD12N_8822B BIT(4)
+#define BIT_SYSON_DIS_WLREG_WRMSK_8822B BIT(3)
+#define BIT_SYSON_DIS_PMCREG_WRMSK_8822B BIT(2)
+
+#define BIT_SHIFT_SYSON_REG_ARB_8822B 0
+#define BIT_MASK_SYSON_REG_ARB_8822B 0x3
+#define BIT_SYSON_REG_ARB_8822B(x)                                             \
+	(((x) & BIT_MASK_SYSON_REG_ARB_8822B) << BIT_SHIFT_SYSON_REG_ARB_8822B)
+#define BIT_GET_SYSON_REG_ARB_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_SYSON_REG_ARB_8822B) & BIT_MASK_SYSON_REG_ARB_8822B)
+
+/* 2 REG_BIST_CTRL_8822B */
+#define BIT_BIST_USB_DIS_8822B BIT(27)
+#define BIT_BIST_PCI_DIS_8822B BIT(26)
+#define BIT_BIST_BT_DIS_8822B BIT(25)
+#define BIT_BIST_WL_DIS_8822B BIT(24)
+
+#define BIT_SHIFT_BIST_RPT_SEL_8822B 16
+#define BIT_MASK_BIST_RPT_SEL_8822B 0xf
+#define BIT_BIST_RPT_SEL_8822B(x)                                              \
+	(((x) & BIT_MASK_BIST_RPT_SEL_8822B) << BIT_SHIFT_BIST_RPT_SEL_8822B)
+#define BIT_GET_BIST_RPT_SEL_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_BIST_RPT_SEL_8822B) & BIT_MASK_BIST_RPT_SEL_8822B)
+
+#define BIT_BIST_RESUME_PS_8822B BIT(4)
+#define BIT_BIST_RESUME_8822B BIT(3)
+#define BIT_BIST_NORMAL_8822B BIT(2)
+#define BIT_BIST_RSTN_8822B BIT(1)
+#define BIT_BIST_CLK_EN_8822B BIT(0)
+
+/* 2 REG_BIST_RPT_8822B */
+
+#define BIT_SHIFT_MBIST_REPORT_8822B 0
+#define BIT_MASK_MBIST_REPORT_8822B 0xffffffffL
+#define BIT_MBIST_REPORT_8822B(x)                                              \
+	(((x) & BIT_MASK_MBIST_REPORT_8822B) << BIT_SHIFT_MBIST_REPORT_8822B)
+#define BIT_GET_MBIST_REPORT_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_MBIST_REPORT_8822B) & BIT_MASK_MBIST_REPORT_8822B)
+
+/* 2 REG_MEM_CTRL_8822B */
+#define BIT_UMEM_RME_8822B BIT(31)
+
+#define BIT_SHIFT_BT_SPRAM_8822B 28
+#define BIT_MASK_BT_SPRAM_8822B 0x3
+#define BIT_BT_SPRAM_8822B(x)                                                  \
+	(((x) & BIT_MASK_BT_SPRAM_8822B) << BIT_SHIFT_BT_SPRAM_8822B)
+#define BIT_GET_BT_SPRAM_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_BT_SPRAM_8822B) & BIT_MASK_BT_SPRAM_8822B)
+
+#define BIT_SHIFT_BT_ROM_8822B 24
+#define BIT_MASK_BT_ROM_8822B 0xf
+#define BIT_BT_ROM_8822B(x)                                                    \
+	(((x) & BIT_MASK_BT_ROM_8822B) << BIT_SHIFT_BT_ROM_8822B)
+#define BIT_GET_BT_ROM_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_BT_ROM_8822B) & BIT_MASK_BT_ROM_8822B)
+
+#define BIT_SHIFT_PCI_DPRAM_8822B 10
+#define BIT_MASK_PCI_DPRAM_8822B 0x3
+#define BIT_PCI_DPRAM_8822B(x)                                                 \
+	(((x) & BIT_MASK_PCI_DPRAM_8822B) << BIT_SHIFT_PCI_DPRAM_8822B)
+#define BIT_GET_PCI_DPRAM_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_PCI_DPRAM_8822B) & BIT_MASK_PCI_DPRAM_8822B)
+
+#define BIT_SHIFT_PCI_SPRAM_8822B 8
+#define BIT_MASK_PCI_SPRAM_8822B 0x3
+#define BIT_PCI_SPRAM_8822B(x)                                                 \
+	(((x) & BIT_MASK_PCI_SPRAM_8822B) << BIT_SHIFT_PCI_SPRAM_8822B)
+#define BIT_GET_PCI_SPRAM_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_PCI_SPRAM_8822B) & BIT_MASK_PCI_SPRAM_8822B)
+
+#define BIT_SHIFT_USB_SPRAM_8822B 6
+#define BIT_MASK_USB_SPRAM_8822B 0x3
+#define BIT_USB_SPRAM_8822B(x)                                                 \
+	(((x) & BIT_MASK_USB_SPRAM_8822B) << BIT_SHIFT_USB_SPRAM_8822B)
+#define BIT_GET_USB_SPRAM_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_USB_SPRAM_8822B) & BIT_MASK_USB_SPRAM_8822B)
+
+#define BIT_SHIFT_USB_SPRF_8822B 4
+#define BIT_MASK_USB_SPRF_8822B 0x3
+#define BIT_USB_SPRF_8822B(x)                                                  \
+	(((x) & BIT_MASK_USB_SPRF_8822B) << BIT_SHIFT_USB_SPRF_8822B)
+#define BIT_GET_USB_SPRF_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_USB_SPRF_8822B) & BIT_MASK_USB_SPRF_8822B)
+
+#define BIT_SHIFT_MCU_ROM_8822B 0
+#define BIT_MASK_MCU_ROM_8822B 0xf
+#define BIT_MCU_ROM_8822B(x)                                                   \
+	(((x) & BIT_MASK_MCU_ROM_8822B) << BIT_SHIFT_MCU_ROM_8822B)
+#define BIT_GET_MCU_ROM_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_MCU_ROM_8822B) & BIT_MASK_MCU_ROM_8822B)
+
+/* 2 REG_AFE_CTRL8_8822B */
+#define BIT_SYN_AGPIO_8822B BIT(20)
+#define BIT_XTAL_LP_8822B BIT(4)
+#define BIT_XTAL_GM_SEP_8822B BIT(3)
+
+#define BIT_SHIFT_XTAL_SEL_TOK_8822B 0
+#define BIT_MASK_XTAL_SEL_TOK_8822B 0x7
+#define BIT_XTAL_SEL_TOK_8822B(x)                                              \
+	(((x) & BIT_MASK_XTAL_SEL_TOK_8822B) << BIT_SHIFT_XTAL_SEL_TOK_8822B)
+#define BIT_GET_XTAL_SEL_TOK_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_XTAL_SEL_TOK_8822B) & BIT_MASK_XTAL_SEL_TOK_8822B)
+
+/* 2 REG_USB_SIE_INTF_8822B */
+#define BIT_RD_SEL_8822B BIT(31)
+#define BIT_USB_SIE_INTF_WE_V1_8822B BIT(30)
+#define BIT_USB_SIE_INTF_BYIOREG_V1_8822B BIT(29)
+#define BIT_USB_SIE_SELECT_8822B BIT(28)
+
+#define BIT_SHIFT_USB_SIE_INTF_ADDR_V1_8822B 16
+#define BIT_MASK_USB_SIE_INTF_ADDR_V1_8822B 0x1ff
+#define BIT_USB_SIE_INTF_ADDR_V1_8822B(x)                                      \
+	(((x) & BIT_MASK_USB_SIE_INTF_ADDR_V1_8822B)                           \
+	 << BIT_SHIFT_USB_SIE_INTF_ADDR_V1_8822B)
+#define BIT_GET_USB_SIE_INTF_ADDR_V1_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_USB_SIE_INTF_ADDR_V1_8822B) &                       \
+	 BIT_MASK_USB_SIE_INTF_ADDR_V1_8822B)
+
+#define BIT_SHIFT_USB_SIE_INTF_RD_8822B 8
+#define BIT_MASK_USB_SIE_INTF_RD_8822B 0xff
+#define BIT_USB_SIE_INTF_RD_8822B(x)                                           \
+	(((x) & BIT_MASK_USB_SIE_INTF_RD_8822B)                                \
+	 << BIT_SHIFT_USB_SIE_INTF_RD_8822B)
+#define BIT_GET_USB_SIE_INTF_RD_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_USB_SIE_INTF_RD_8822B) &                            \
+	 BIT_MASK_USB_SIE_INTF_RD_8822B)
+
+#define BIT_SHIFT_USB_SIE_INTF_WD_8822B 0
+#define BIT_MASK_USB_SIE_INTF_WD_8822B 0xff
+#define BIT_USB_SIE_INTF_WD_8822B(x)                                           \
+	(((x) & BIT_MASK_USB_SIE_INTF_WD_8822B)                                \
+	 << BIT_SHIFT_USB_SIE_INTF_WD_8822B)
+#define BIT_GET_USB_SIE_INTF_WD_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_USB_SIE_INTF_WD_8822B) &                            \
+	 BIT_MASK_USB_SIE_INTF_WD_8822B)
+
+/* 2 REG_PCIE_MIO_INTF_8822B */
+#define BIT_PCIE_MIO_BYIOREG_8822B BIT(13)
+#define BIT_PCIE_MIO_RE_8822B BIT(12)
+
+#define BIT_SHIFT_PCIE_MIO_WE_8822B 8
+#define BIT_MASK_PCIE_MIO_WE_8822B 0xf
+#define BIT_PCIE_MIO_WE_8822B(x)                                               \
+	(((x) & BIT_MASK_PCIE_MIO_WE_8822B) << BIT_SHIFT_PCIE_MIO_WE_8822B)
+#define BIT_GET_PCIE_MIO_WE_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_PCIE_MIO_WE_8822B) & BIT_MASK_PCIE_MIO_WE_8822B)
+
+#define BIT_SHIFT_PCIE_MIO_ADDR_8822B 0
+#define BIT_MASK_PCIE_MIO_ADDR_8822B 0xff
+#define BIT_PCIE_MIO_ADDR_8822B(x)                                             \
+	(((x) & BIT_MASK_PCIE_MIO_ADDR_8822B) << BIT_SHIFT_PCIE_MIO_ADDR_8822B)
+#define BIT_GET_PCIE_MIO_ADDR_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_PCIE_MIO_ADDR_8822B) & BIT_MASK_PCIE_MIO_ADDR_8822B)
+
+/* 2 REG_PCIE_MIO_INTD_8822B */
+
+#define BIT_SHIFT_PCIE_MIO_DATA_8822B 0
+#define BIT_MASK_PCIE_MIO_DATA_8822B 0xffffffffL
+#define BIT_PCIE_MIO_DATA_8822B(x)                                             \
+	(((x) & BIT_MASK_PCIE_MIO_DATA_8822B) << BIT_SHIFT_PCIE_MIO_DATA_8822B)
+#define BIT_GET_PCIE_MIO_DATA_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_PCIE_MIO_DATA_8822B) & BIT_MASK_PCIE_MIO_DATA_8822B)
+
+/* 2 REG_WLRF1_8822B */
+
+#define BIT_SHIFT_WLRF1_CTRL_8822B 24
+#define BIT_MASK_WLRF1_CTRL_8822B 0xff
+#define BIT_WLRF1_CTRL_8822B(x)                                                \
+	(((x) & BIT_MASK_WLRF1_CTRL_8822B) << BIT_SHIFT_WLRF1_CTRL_8822B)
+#define BIT_GET_WLRF1_CTRL_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_WLRF1_CTRL_8822B) & BIT_MASK_WLRF1_CTRL_8822B)
+
+/* 2 REG_SYS_CFG1_8822B */
+
+#define BIT_SHIFT_TRP_ICFG_8822B 28
+#define BIT_MASK_TRP_ICFG_8822B 0xf
+#define BIT_TRP_ICFG_8822B(x)                                                  \
+	(((x) & BIT_MASK_TRP_ICFG_8822B) << BIT_SHIFT_TRP_ICFG_8822B)
+#define BIT_GET_TRP_ICFG_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_TRP_ICFG_8822B) & BIT_MASK_TRP_ICFG_8822B)
+
+#define BIT_RF_TYPE_ID_8822B BIT(27)
+#define BIT_BD_HCI_SEL_8822B BIT(26)
+#define BIT_BD_PKG_SEL_8822B BIT(25)
+#define BIT_SPSLDO_SEL_8822B BIT(24)
+#define BIT_RTL_ID_8822B BIT(23)
+#define BIT_PAD_HWPD_IDN_8822B BIT(22)
+#define BIT_TESTMODE_8822B BIT(20)
+
+#define BIT_SHIFT_VENDOR_ID_8822B 16
+#define BIT_MASK_VENDOR_ID_8822B 0xf
+#define BIT_VENDOR_ID_8822B(x)                                                 \
+	(((x) & BIT_MASK_VENDOR_ID_8822B) << BIT_SHIFT_VENDOR_ID_8822B)
+#define BIT_GET_VENDOR_ID_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_VENDOR_ID_8822B) & BIT_MASK_VENDOR_ID_8822B)
+
+#define BIT_SHIFT_CHIP_VER_8822B 12
+#define BIT_MASK_CHIP_VER_8822B 0xf
+#define BIT_CHIP_VER_8822B(x)                                                  \
+	(((x) & BIT_MASK_CHIP_VER_8822B) << BIT_SHIFT_CHIP_VER_8822B)
+#define BIT_GET_CHIP_VER_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_CHIP_VER_8822B) & BIT_MASK_CHIP_VER_8822B)
+
+#define BIT_BD_MAC3_8822B BIT(11)
+#define BIT_BD_MAC1_8822B BIT(10)
+#define BIT_BD_MAC2_8822B BIT(9)
+#define BIT_SIC_IDLE_8822B BIT(8)
+#define BIT_SW_OFFLOAD_EN_8822B BIT(7)
+#define BIT_OCP_SHUTDN_8822B BIT(6)
+#define BIT_V15_VLD_8822B BIT(5)
+#define BIT_PCIRSTB_8822B BIT(4)
+#define BIT_PCLK_VLD_8822B BIT(3)
+#define BIT_UCLK_VLD_8822B BIT(2)
+#define BIT_ACLK_VLD_8822B BIT(1)
+#define BIT_XCLK_VLD_8822B BIT(0)
+
+/* 2 REG_SYS_STATUS1_8822B */
+
+#define BIT_SHIFT_RF_RL_ID_8822B 28
+#define BIT_MASK_RF_RL_ID_8822B 0xf
+#define BIT_RF_RL_ID_8822B(x)                                                  \
+	(((x) & BIT_MASK_RF_RL_ID_8822B) << BIT_SHIFT_RF_RL_ID_8822B)
+#define BIT_GET_RF_RL_ID_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_RF_RL_ID_8822B) & BIT_MASK_RF_RL_ID_8822B)
+
+#define BIT_HPHY_ICFG_8822B BIT(19)
+
+#define BIT_SHIFT_SEL_0XC0_8822B 16
+#define BIT_MASK_SEL_0XC0_8822B 0x3
+#define BIT_SEL_0XC0_8822B(x)                                                  \
+	(((x) & BIT_MASK_SEL_0XC0_8822B) << BIT_SHIFT_SEL_0XC0_8822B)
+#define BIT_GET_SEL_0XC0_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_SEL_0XC0_8822B) & BIT_MASK_SEL_0XC0_8822B)
+
+#define BIT_SHIFT_HCI_SEL_V3_8822B 12
+#define BIT_MASK_HCI_SEL_V3_8822B 0x7
+#define BIT_HCI_SEL_V3_8822B(x)                                                \
+	(((x) & BIT_MASK_HCI_SEL_V3_8822B) << BIT_SHIFT_HCI_SEL_V3_8822B)
+#define BIT_GET_HCI_SEL_V3_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_HCI_SEL_V3_8822B) & BIT_MASK_HCI_SEL_V3_8822B)
+
+#define BIT_USB_OPERATION_MODE_8822B BIT(10)
+#define BIT_BT_PDN_8822B BIT(9)
+#define BIT_AUTO_WLPON_8822B BIT(8)
+#define BIT_WL_MODE_8822B BIT(7)
+#define BIT_PKG_SEL_HCI_8822B BIT(6)
+
+#define BIT_SHIFT_PAD_HCI_SEL_V1_8822B 3
+#define BIT_MASK_PAD_HCI_SEL_V1_8822B 0x7
+#define BIT_PAD_HCI_SEL_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_PAD_HCI_SEL_V1_8822B)                                 \
+	 << BIT_SHIFT_PAD_HCI_SEL_V1_8822B)
+#define BIT_GET_PAD_HCI_SEL_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_PAD_HCI_SEL_V1_8822B) &                             \
+	 BIT_MASK_PAD_HCI_SEL_V1_8822B)
+
+#define BIT_SHIFT_EFS_HCI_SEL_V1_8822B 0
+#define BIT_MASK_EFS_HCI_SEL_V1_8822B 0x7
+#define BIT_EFS_HCI_SEL_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_EFS_HCI_SEL_V1_8822B)                                 \
+	 << BIT_SHIFT_EFS_HCI_SEL_V1_8822B)
+#define BIT_GET_EFS_HCI_SEL_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_EFS_HCI_SEL_V1_8822B) &                             \
+	 BIT_MASK_EFS_HCI_SEL_V1_8822B)
+
+/* 2 REG_SYS_STATUS2_8822B */
+#define BIT_SIO_ALDN_8822B BIT(19)
+#define BIT_USB_ALDN_8822B BIT(18)
+#define BIT_PCI_ALDN_8822B BIT(17)
+#define BIT_SYS_ALDN_8822B BIT(16)
+
+#define BIT_SHIFT_EPVID1_8822B 8
+#define BIT_MASK_EPVID1_8822B 0xff
+#define BIT_EPVID1_8822B(x)                                                    \
+	(((x) & BIT_MASK_EPVID1_8822B) << BIT_SHIFT_EPVID1_8822B)
+#define BIT_GET_EPVID1_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_EPVID1_8822B) & BIT_MASK_EPVID1_8822B)
+
+#define BIT_SHIFT_EPVID0_8822B 0
+#define BIT_MASK_EPVID0_8822B 0xff
+#define BIT_EPVID0_8822B(x)                                                    \
+	(((x) & BIT_MASK_EPVID0_8822B) << BIT_SHIFT_EPVID0_8822B)
+#define BIT_GET_EPVID0_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_EPVID0_8822B) & BIT_MASK_EPVID0_8822B)
+
+/* 2 REG_SYS_CFG2_8822B */
+#define BIT_HCI_SEL_EMBEDDED_8822B BIT(8)
+
+#define BIT_SHIFT_HW_ID_8822B 0
+#define BIT_MASK_HW_ID_8822B 0xff
+#define BIT_HW_ID_8822B(x)                                                     \
+	(((x) & BIT_MASK_HW_ID_8822B) << BIT_SHIFT_HW_ID_8822B)
+#define BIT_GET_HW_ID_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_HW_ID_8822B) & BIT_MASK_HW_ID_8822B)
+
+/* 2 REG_SYS_CFG3_8822B */
+#define BIT_PWC_MA33V_8822B BIT(15)
+#define BIT_PWC_MA12V_8822B BIT(14)
+#define BIT_PWC_MD12V_8822B BIT(13)
+#define BIT_PWC_PD12V_8822B BIT(12)
+#define BIT_PWC_UD12V_8822B BIT(11)
+#define BIT_ISO_MA2MD_8822B BIT(1)
+#define BIT_ISO_MD2PP_8822B BIT(0)
+
+/* 2 REG_SYS_CFG4_8822B */
+
+/* 2 REG_SYS_CFG5_8822B */
+#define BIT_LPS_STATUS_8822B BIT(3)
+#define BIT_HCI_TXDMA_BUSY_8822B BIT(2)
+#define BIT_HCI_TXDMA_ALLOW_8822B BIT(1)
+#define BIT_FW_CTRL_HCI_TXDMA_EN_8822B BIT(0)
+
+/* 2 REG_CPU_DMEM_CON_8822B */
+#define BIT_WDT_OPT_IOWRAPPER_8822B BIT(19)
+#define BIT_ANA_PORT_IDLE_8822B BIT(18)
+#define BIT_MAC_PORT_IDLE_8822B BIT(17)
+#define BIT_WL_PLATFORM_RST_8822B BIT(16)
+#define BIT_WL_SECURITY_CLK_8822B BIT(15)
+
+#define BIT_SHIFT_CPU_DMEM_CON_8822B 0
+#define BIT_MASK_CPU_DMEM_CON_8822B 0xff
+#define BIT_CPU_DMEM_CON_8822B(x)                                              \
+	(((x) & BIT_MASK_CPU_DMEM_CON_8822B) << BIT_SHIFT_CPU_DMEM_CON_8822B)
+#define BIT_GET_CPU_DMEM_CON_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_CPU_DMEM_CON_8822B) & BIT_MASK_CPU_DMEM_CON_8822B)
+
+/* 2 REG_BOOT_REASON_8822B */
+
+#define BIT_SHIFT_BOOT_REASON_8822B 0
+#define BIT_MASK_BOOT_REASON_8822B 0x7
+#define BIT_BOOT_REASON_8822B(x)                                               \
+	(((x) & BIT_MASK_BOOT_REASON_8822B) << BIT_SHIFT_BOOT_REASON_8822B)
+#define BIT_GET_BOOT_REASON_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_BOOT_REASON_8822B) & BIT_MASK_BOOT_REASON_8822B)
+
+/* 2 REG_NFCPAD_CTRL_8822B */
+#define BIT_PAD_SHUTDW_8822B BIT(18)
+#define BIT_SYSON_NFC_PAD_8822B BIT(17)
+#define BIT_NFC_INT_PAD_CTRL_8822B BIT(16)
+#define BIT_NFC_RFDIS_PAD_CTRL_8822B BIT(15)
+#define BIT_NFC_CLK_PAD_CTRL_8822B BIT(14)
+#define BIT_NFC_DATA_PAD_CTRL_8822B BIT(13)
+#define BIT_NFC_PAD_PULL_CTRL_8822B BIT(12)
+
+#define BIT_SHIFT_NFCPAD_IO_SEL_8822B 8
+#define BIT_MASK_NFCPAD_IO_SEL_8822B 0xf
+#define BIT_NFCPAD_IO_SEL_8822B(x)                                             \
+	(((x) & BIT_MASK_NFCPAD_IO_SEL_8822B) << BIT_SHIFT_NFCPAD_IO_SEL_8822B)
+#define BIT_GET_NFCPAD_IO_SEL_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_NFCPAD_IO_SEL_8822B) & BIT_MASK_NFCPAD_IO_SEL_8822B)
+
+#define BIT_SHIFT_NFCPAD_OUT_8822B 4
+#define BIT_MASK_NFCPAD_OUT_8822B 0xf
+#define BIT_NFCPAD_OUT_8822B(x)                                                \
+	(((x) & BIT_MASK_NFCPAD_OUT_8822B) << BIT_SHIFT_NFCPAD_OUT_8822B)
+#define BIT_GET_NFCPAD_OUT_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_NFCPAD_OUT_8822B) & BIT_MASK_NFCPAD_OUT_8822B)
+
+#define BIT_SHIFT_NFCPAD_IN_8822B 0
+#define BIT_MASK_NFCPAD_IN_8822B 0xf
+#define BIT_NFCPAD_IN_8822B(x)                                                 \
+	(((x) & BIT_MASK_NFCPAD_IN_8822B) << BIT_SHIFT_NFCPAD_IN_8822B)
+#define BIT_GET_NFCPAD_IN_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_NFCPAD_IN_8822B) & BIT_MASK_NFCPAD_IN_8822B)
+
+/* 2 REG_HIMR2_8822B */
+#define BIT_BCNDMAINT_P4_MSK_8822B BIT(31)
+#define BIT_BCNDMAINT_P3_MSK_8822B BIT(30)
+#define BIT_BCNDMAINT_P2_MSK_8822B BIT(29)
+#define BIT_BCNDMAINT_P1_MSK_8822B BIT(28)
+#define BIT_ATIMEND7_MSK_8822B BIT(22)
+#define BIT_ATIMEND6_MSK_8822B BIT(21)
+#define BIT_ATIMEND5_MSK_8822B BIT(20)
+#define BIT_ATIMEND4_MSK_8822B BIT(19)
+#define BIT_ATIMEND3_MSK_8822B BIT(18)
+#define BIT_ATIMEND2_MSK_8822B BIT(17)
+#define BIT_ATIMEND1_MSK_8822B BIT(16)
+#define BIT_TXBCN7OK_MSK_8822B BIT(14)
+#define BIT_TXBCN6OK_MSK_8822B BIT(13)
+#define BIT_TXBCN5OK_MSK_8822B BIT(12)
+#define BIT_TXBCN4OK_MSK_8822B BIT(11)
+#define BIT_TXBCN3OK_MSK_8822B BIT(10)
+#define BIT_TXBCN2OK_MSK_8822B BIT(9)
+#define BIT_TXBCN1OK_MSK_V1_8822B BIT(8)
+#define BIT_TXBCN7ERR_MSK_8822B BIT(6)
+#define BIT_TXBCN6ERR_MSK_8822B BIT(5)
+#define BIT_TXBCN5ERR_MSK_8822B BIT(4)
+#define BIT_TXBCN4ERR_MSK_8822B BIT(3)
+#define BIT_TXBCN3ERR_MSK_8822B BIT(2)
+#define BIT_TXBCN2ERR_MSK_8822B BIT(1)
+#define BIT_TXBCN1ERR_MSK_V1_8822B BIT(0)
+
+/* 2 REG_HISR2_8822B */
+#define BIT_BCNDMAINT_P4_8822B BIT(31)
+#define BIT_BCNDMAINT_P3_8822B BIT(30)
+#define BIT_BCNDMAINT_P2_8822B BIT(29)
+#define BIT_BCNDMAINT_P1_8822B BIT(28)
+#define BIT_ATIMEND7_8822B BIT(22)
+#define BIT_ATIMEND6_8822B BIT(21)
+#define BIT_ATIMEND5_8822B BIT(20)
+#define BIT_ATIMEND4_8822B BIT(19)
+#define BIT_ATIMEND3_8822B BIT(18)
+#define BIT_ATIMEND2_8822B BIT(17)
+#define BIT_ATIMEND1_8822B BIT(16)
+#define BIT_TXBCN7OK_8822B BIT(14)
+#define BIT_TXBCN6OK_8822B BIT(13)
+#define BIT_TXBCN5OK_8822B BIT(12)
+#define BIT_TXBCN4OK_8822B BIT(11)
+#define BIT_TXBCN3OK_8822B BIT(10)
+#define BIT_TXBCN2OK_8822B BIT(9)
+#define BIT_TXBCN1OK_8822B BIT(8)
+#define BIT_TXBCN7ERR_8822B BIT(6)
+#define BIT_TXBCN6ERR_8822B BIT(5)
+#define BIT_TXBCN5ERR_8822B BIT(4)
+#define BIT_TXBCN4ERR_8822B BIT(3)
+#define BIT_TXBCN3ERR_8822B BIT(2)
+#define BIT_TXBCN2ERR_8822B BIT(1)
+#define BIT_TXBCN1ERR_8822B BIT(0)
+
+/* 2 REG_HIMR3_8822B */
+#define BIT_WDT_PLATFORM_INT_MSK_8822B BIT(18)
+#define BIT_WDT_CPU_INT_MSK_8822B BIT(17)
+#define BIT_SETH2CDOK_MASK_8822B BIT(16)
+#define BIT_H2C_CMD_FULL_MASK_8822B BIT(15)
+#define BIT_PWR_INT_127_MASK_8822B BIT(14)
+#define BIT_TXSHORTCUT_TXDESUPDATEOK_MASK_8822B BIT(13)
+#define BIT_TXSHORTCUT_BKUPDATEOK_MASK_8822B BIT(12)
+#define BIT_TXSHORTCUT_BEUPDATEOK_MASK_8822B BIT(11)
+#define BIT_TXSHORTCUT_VIUPDATEOK_MAS_8822B BIT(10)
+#define BIT_TXSHORTCUT_VOUPDATEOK_MASK_8822B BIT(9)
+#define BIT_PWR_INT_127_MASK_V1_8822B BIT(8)
+#define BIT_PWR_INT_126TO96_MASK_8822B BIT(7)
+#define BIT_PWR_INT_95TO64_MASK_8822B BIT(6)
+#define BIT_PWR_INT_63TO32_MASK_8822B BIT(5)
+#define BIT_PWR_INT_31TO0_MASK_8822B BIT(4)
+#define BIT_DDMA0_LP_INT_MSK_8822B BIT(1)
+#define BIT_DDMA0_HP_INT_MSK_8822B BIT(0)
+
+/* 2 REG_HISR3_8822B */
+#define BIT_WDT_PLATFORM_INT_8822B BIT(18)
+#define BIT_WDT_CPU_INT_8822B BIT(17)
+#define BIT_SETH2CDOK_8822B BIT(16)
+#define BIT_H2C_CMD_FULL_8822B BIT(15)
+#define BIT_PWR_INT_127_8822B BIT(14)
+#define BIT_TXSHORTCUT_TXDESUPDATEOK_8822B BIT(13)
+#define BIT_TXSHORTCUT_BKUPDATEOK_8822B BIT(12)
+#define BIT_TXSHORTCUT_BEUPDATEOK_8822B BIT(11)
+#define BIT_TXSHORTCUT_VIUPDATEOK_8822B BIT(10)
+#define BIT_TXSHORTCUT_VOUPDATEOK_8822B BIT(9)
+#define BIT_PWR_INT_127_V1_8822B BIT(8)
+#define BIT_PWR_INT_126TO96_8822B BIT(7)
+#define BIT_PWR_INT_95TO64_8822B BIT(6)
+#define BIT_PWR_INT_63TO32_8822B BIT(5)
+#define BIT_PWR_INT_31TO0_8822B BIT(4)
+#define BIT_DDMA0_LP_INT_8822B BIT(1)
+#define BIT_DDMA0_HP_INT_8822B BIT(0)
+
+/* 2 REG_SW_MDIO_8822B */
+#define BIT_DIS_TIMEOUT_IO_8822B BIT(24)
+
+/* 2 REG_SW_FLUSH_8822B */
+#define BIT_FLUSH_HOLDN_EN_8822B BIT(25)
+#define BIT_FLUSH_WR_EN_8822B BIT(24)
+#define BIT_SW_FLASH_CONTROL_8822B BIT(23)
+#define BIT_SW_FLASH_WEN_E_8822B BIT(19)
+#define BIT_SW_FLASH_HOLDN_E_8822B BIT(18)
+#define BIT_SW_FLASH_SO_E_8822B BIT(17)
+#define BIT_SW_FLASH_SI_E_8822B BIT(16)
+#define BIT_SW_FLASH_SK_O_8822B BIT(13)
+#define BIT_SW_FLASH_CEN_O_8822B BIT(12)
+#define BIT_SW_FLASH_WEN_O_8822B BIT(11)
+#define BIT_SW_FLASH_HOLDN_O_8822B BIT(10)
+#define BIT_SW_FLASH_SO_O_8822B BIT(9)
+#define BIT_SW_FLASH_SI_O_8822B BIT(8)
+#define BIT_SW_FLASH_WEN_I_8822B BIT(3)
+#define BIT_SW_FLASH_HOLDN_I_8822B BIT(2)
+#define BIT_SW_FLASH_SO_I_8822B BIT(1)
+#define BIT_SW_FLASH_SI_I_8822B BIT(0)
+
+/* 2 REG_H2C_PKT_READADDR_8822B */
+
+#define BIT_SHIFT_H2C_PKT_READADDR_8822B 0
+#define BIT_MASK_H2C_PKT_READADDR_8822B 0x3ffff
+#define BIT_H2C_PKT_READADDR_8822B(x)                                          \
+	(((x) & BIT_MASK_H2C_PKT_READADDR_8822B)                               \
+	 << BIT_SHIFT_H2C_PKT_READADDR_8822B)
+#define BIT_GET_H2C_PKT_READADDR_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_H2C_PKT_READADDR_8822B) &                           \
+	 BIT_MASK_H2C_PKT_READADDR_8822B)
+
+/* 2 REG_H2C_PKT_WRITEADDR_8822B */
+
+#define BIT_SHIFT_H2C_PKT_WRITEADDR_8822B 0
+#define BIT_MASK_H2C_PKT_WRITEADDR_8822B 0x3ffff
+#define BIT_H2C_PKT_WRITEADDR_8822B(x)                                         \
+	(((x) & BIT_MASK_H2C_PKT_WRITEADDR_8822B)                              \
+	 << BIT_SHIFT_H2C_PKT_WRITEADDR_8822B)
+#define BIT_GET_H2C_PKT_WRITEADDR_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_H2C_PKT_WRITEADDR_8822B) &                          \
+	 BIT_MASK_H2C_PKT_WRITEADDR_8822B)
+
+/* 2 REG_MEM_PWR_CRTL_8822B */
+#define BIT_MEM_BB_SD_8822B BIT(17)
+#define BIT_MEM_BB_DS_8822B BIT(16)
+#define BIT_MEM_BT_DS_8822B BIT(10)
+#define BIT_MEM_SDIO_LS_8822B BIT(9)
+#define BIT_MEM_SDIO_DS_8822B BIT(8)
+#define BIT_MEM_USB_LS_8822B BIT(7)
+#define BIT_MEM_USB_DS_8822B BIT(6)
+#define BIT_MEM_PCI_LS_8822B BIT(5)
+#define BIT_MEM_PCI_DS_8822B BIT(4)
+#define BIT_MEM_WLMAC_LS_8822B BIT(3)
+#define BIT_MEM_WLMAC_DS_8822B BIT(2)
+#define BIT_MEM_WLMCU_LS_8822B BIT(1)
+#define BIT_MEM_WLMCU_DS_8822B BIT(0)
+
+/* 2 REG_FW_DBG0_8822B */
+
+#define BIT_SHIFT_FW_DBG0_8822B 0
+#define BIT_MASK_FW_DBG0_8822B 0xffffffffL
+#define BIT_FW_DBG0_8822B(x)                                                   \
+	(((x) & BIT_MASK_FW_DBG0_8822B) << BIT_SHIFT_FW_DBG0_8822B)
+#define BIT_GET_FW_DBG0_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_FW_DBG0_8822B) & BIT_MASK_FW_DBG0_8822B)
+
+/* 2 REG_FW_DBG1_8822B */
+
+#define BIT_SHIFT_FW_DBG1_8822B 0
+#define BIT_MASK_FW_DBG1_8822B 0xffffffffL
+#define BIT_FW_DBG1_8822B(x)                                                   \
+	(((x) & BIT_MASK_FW_DBG1_8822B) << BIT_SHIFT_FW_DBG1_8822B)
+#define BIT_GET_FW_DBG1_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_FW_DBG1_8822B) & BIT_MASK_FW_DBG1_8822B)
+
+/* 2 REG_FW_DBG2_8822B */
+
+#define BIT_SHIFT_FW_DBG2_8822B 0
+#define BIT_MASK_FW_DBG2_8822B 0xffffffffL
+#define BIT_FW_DBG2_8822B(x)                                                   \
+	(((x) & BIT_MASK_FW_DBG2_8822B) << BIT_SHIFT_FW_DBG2_8822B)
+#define BIT_GET_FW_DBG2_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_FW_DBG2_8822B) & BIT_MASK_FW_DBG2_8822B)
+
+/* 2 REG_FW_DBG3_8822B */
+
+#define BIT_SHIFT_FW_DBG3_8822B 0
+#define BIT_MASK_FW_DBG3_8822B 0xffffffffL
+#define BIT_FW_DBG3_8822B(x)                                                   \
+	(((x) & BIT_MASK_FW_DBG3_8822B) << BIT_SHIFT_FW_DBG3_8822B)
+#define BIT_GET_FW_DBG3_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_FW_DBG3_8822B) & BIT_MASK_FW_DBG3_8822B)
+
+/* 2 REG_FW_DBG4_8822B */
+
+#define BIT_SHIFT_FW_DBG4_8822B 0
+#define BIT_MASK_FW_DBG4_8822B 0xffffffffL
+#define BIT_FW_DBG4_8822B(x)                                                   \
+	(((x) & BIT_MASK_FW_DBG4_8822B) << BIT_SHIFT_FW_DBG4_8822B)
+#define BIT_GET_FW_DBG4_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_FW_DBG4_8822B) & BIT_MASK_FW_DBG4_8822B)
+
+/* 2 REG_FW_DBG5_8822B */
+
+#define BIT_SHIFT_FW_DBG5_8822B 0
+#define BIT_MASK_FW_DBG5_8822B 0xffffffffL
+#define BIT_FW_DBG5_8822B(x)                                                   \
+	(((x) & BIT_MASK_FW_DBG5_8822B) << BIT_SHIFT_FW_DBG5_8822B)
+#define BIT_GET_FW_DBG5_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_FW_DBG5_8822B) & BIT_MASK_FW_DBG5_8822B)
+
+/* 2 REG_FW_DBG6_8822B */
+
+#define BIT_SHIFT_FW_DBG6_8822B 0
+#define BIT_MASK_FW_DBG6_8822B 0xffffffffL
+#define BIT_FW_DBG6_8822B(x)                                                   \
+	(((x) & BIT_MASK_FW_DBG6_8822B) << BIT_SHIFT_FW_DBG6_8822B)
+#define BIT_GET_FW_DBG6_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_FW_DBG6_8822B) & BIT_MASK_FW_DBG6_8822B)
+
+/* 2 REG_FW_DBG7_8822B */
+
+#define BIT_SHIFT_FW_DBG7_8822B 0
+#define BIT_MASK_FW_DBG7_8822B 0xffffffffL
+#define BIT_FW_DBG7_8822B(x)                                                   \
+	(((x) & BIT_MASK_FW_DBG7_8822B) << BIT_SHIFT_FW_DBG7_8822B)
+#define BIT_GET_FW_DBG7_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_FW_DBG7_8822B) & BIT_MASK_FW_DBG7_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_CR_8822B */
+
+#define BIT_SHIFT_LBMODE_8822B 24
+#define BIT_MASK_LBMODE_8822B 0x1f
+#define BIT_LBMODE_8822B(x)                                                    \
+	(((x) & BIT_MASK_LBMODE_8822B) << BIT_SHIFT_LBMODE_8822B)
+#define BIT_GET_LBMODE_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_LBMODE_8822B) & BIT_MASK_LBMODE_8822B)
+
+#define BIT_SHIFT_NETYPE1_8822B 18
+#define BIT_MASK_NETYPE1_8822B 0x3
+#define BIT_NETYPE1_8822B(x)                                                   \
+	(((x) & BIT_MASK_NETYPE1_8822B) << BIT_SHIFT_NETYPE1_8822B)
+#define BIT_GET_NETYPE1_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_NETYPE1_8822B) & BIT_MASK_NETYPE1_8822B)
+
+#define BIT_SHIFT_NETYPE0_8822B 16
+#define BIT_MASK_NETYPE0_8822B 0x3
+#define BIT_NETYPE0_8822B(x)                                                   \
+	(((x) & BIT_MASK_NETYPE0_8822B) << BIT_SHIFT_NETYPE0_8822B)
+#define BIT_GET_NETYPE0_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_NETYPE0_8822B) & BIT_MASK_NETYPE0_8822B)
+
+#define BIT_I2C_MAILBOX_EN_8822B BIT(12)
+#define BIT_SHCUT_EN_8822B BIT(11)
+#define BIT_32K_CAL_TMR_EN_8822B BIT(10)
+#define BIT_MAC_SEC_EN_8822B BIT(9)
+#define BIT_ENSWBCN_8822B BIT(8)
+#define BIT_MACRXEN_8822B BIT(7)
+#define BIT_MACTXEN_8822B BIT(6)
+#define BIT_SCHEDULE_EN_8822B BIT(5)
+#define BIT_PROTOCOL_EN_8822B BIT(4)
+#define BIT_RXDMA_EN_8822B BIT(3)
+#define BIT_TXDMA_EN_8822B BIT(2)
+#define BIT_HCI_RXDMA_EN_8822B BIT(1)
+#define BIT_HCI_TXDMA_EN_8822B BIT(0)
+
+/* 2 REG_PKT_BUFF_ACCESS_CTRL_8822B */
+
+#define BIT_SHIFT_PKT_BUFF_ACCESS_CTRL_8822B 0
+#define BIT_MASK_PKT_BUFF_ACCESS_CTRL_8822B 0xff
+#define BIT_PKT_BUFF_ACCESS_CTRL_8822B(x)                                      \
+	(((x) & BIT_MASK_PKT_BUFF_ACCESS_CTRL_8822B)                           \
+	 << BIT_SHIFT_PKT_BUFF_ACCESS_CTRL_8822B)
+#define BIT_GET_PKT_BUFF_ACCESS_CTRL_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_PKT_BUFF_ACCESS_CTRL_8822B) &                       \
+	 BIT_MASK_PKT_BUFF_ACCESS_CTRL_8822B)
+
+/* 2 REG_TSF_CLK_STATE_8822B */
+#define BIT_TSF_CLK_STABLE_8822B BIT(15)
+
+/* 2 REG_TXDMA_PQ_MAP_8822B */
+
+#define BIT_SHIFT_TXDMA_HIQ_MAP_8822B 14
+#define BIT_MASK_TXDMA_HIQ_MAP_8822B 0x3
+#define BIT_TXDMA_HIQ_MAP_8822B(x)                                             \
+	(((x) & BIT_MASK_TXDMA_HIQ_MAP_8822B) << BIT_SHIFT_TXDMA_HIQ_MAP_8822B)
+#define BIT_GET_TXDMA_HIQ_MAP_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_TXDMA_HIQ_MAP_8822B) & BIT_MASK_TXDMA_HIQ_MAP_8822B)
+
+#define BIT_SHIFT_TXDMA_MGQ_MAP_8822B 12
+#define BIT_MASK_TXDMA_MGQ_MAP_8822B 0x3
+#define BIT_TXDMA_MGQ_MAP_8822B(x)                                             \
+	(((x) & BIT_MASK_TXDMA_MGQ_MAP_8822B) << BIT_SHIFT_TXDMA_MGQ_MAP_8822B)
+#define BIT_GET_TXDMA_MGQ_MAP_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_TXDMA_MGQ_MAP_8822B) & BIT_MASK_TXDMA_MGQ_MAP_8822B)
+
+#define BIT_SHIFT_TXDMA_BKQ_MAP_8822B 10
+#define BIT_MASK_TXDMA_BKQ_MAP_8822B 0x3
+#define BIT_TXDMA_BKQ_MAP_8822B(x)                                             \
+	(((x) & BIT_MASK_TXDMA_BKQ_MAP_8822B) << BIT_SHIFT_TXDMA_BKQ_MAP_8822B)
+#define BIT_GET_TXDMA_BKQ_MAP_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_TXDMA_BKQ_MAP_8822B) & BIT_MASK_TXDMA_BKQ_MAP_8822B)
+
+#define BIT_SHIFT_TXDMA_BEQ_MAP_8822B 8
+#define BIT_MASK_TXDMA_BEQ_MAP_8822B 0x3
+#define BIT_TXDMA_BEQ_MAP_8822B(x)                                             \
+	(((x) & BIT_MASK_TXDMA_BEQ_MAP_8822B) << BIT_SHIFT_TXDMA_BEQ_MAP_8822B)
+#define BIT_GET_TXDMA_BEQ_MAP_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_TXDMA_BEQ_MAP_8822B) & BIT_MASK_TXDMA_BEQ_MAP_8822B)
+
+#define BIT_SHIFT_TXDMA_VIQ_MAP_8822B 6
+#define BIT_MASK_TXDMA_VIQ_MAP_8822B 0x3
+#define BIT_TXDMA_VIQ_MAP_8822B(x)                                             \
+	(((x) & BIT_MASK_TXDMA_VIQ_MAP_8822B) << BIT_SHIFT_TXDMA_VIQ_MAP_8822B)
+#define BIT_GET_TXDMA_VIQ_MAP_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_TXDMA_VIQ_MAP_8822B) & BIT_MASK_TXDMA_VIQ_MAP_8822B)
+
+#define BIT_SHIFT_TXDMA_VOQ_MAP_8822B 4
+#define BIT_MASK_TXDMA_VOQ_MAP_8822B 0x3
+#define BIT_TXDMA_VOQ_MAP_8822B(x)                                             \
+	(((x) & BIT_MASK_TXDMA_VOQ_MAP_8822B) << BIT_SHIFT_TXDMA_VOQ_MAP_8822B)
+#define BIT_GET_TXDMA_VOQ_MAP_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_TXDMA_VOQ_MAP_8822B) & BIT_MASK_TXDMA_VOQ_MAP_8822B)
+
+#define BIT_RXDMA_AGG_EN_8822B BIT(2)
+#define BIT_RXSHFT_EN_8822B BIT(1)
+#define BIT_RXDMA_ARBBW_EN_8822B BIT(0)
+
+/* 2 REG_TRXFF_BNDY_8822B */
+
+#define BIT_SHIFT_RXFFOVFL_RSV_V2_8822B 8
+#define BIT_MASK_RXFFOVFL_RSV_V2_8822B 0xf
+#define BIT_RXFFOVFL_RSV_V2_8822B(x)                                           \
+	(((x) & BIT_MASK_RXFFOVFL_RSV_V2_8822B)                                \
+	 << BIT_SHIFT_RXFFOVFL_RSV_V2_8822B)
+#define BIT_GET_RXFFOVFL_RSV_V2_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_RXFFOVFL_RSV_V2_8822B) &                            \
+	 BIT_MASK_RXFFOVFL_RSV_V2_8822B)
+
+#define BIT_SHIFT_TXPKTBUF_PGBNDY_8822B 0
+#define BIT_MASK_TXPKTBUF_PGBNDY_8822B 0xff
+#define BIT_TXPKTBUF_PGBNDY_8822B(x)                                           \
+	(((x) & BIT_MASK_TXPKTBUF_PGBNDY_8822B)                                \
+	 << BIT_SHIFT_TXPKTBUF_PGBNDY_8822B)
+#define BIT_GET_TXPKTBUF_PGBNDY_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_TXPKTBUF_PGBNDY_8822B) &                            \
+	 BIT_MASK_TXPKTBUF_PGBNDY_8822B)
+
+/* 2 REG_PTA_I2C_MBOX_8822B */
+
+/* 2 REG_NOT_VALID_8822B */
+
+#define BIT_SHIFT_I2C_M_STATUS_8822B 8
+#define BIT_MASK_I2C_M_STATUS_8822B 0xf
+#define BIT_I2C_M_STATUS_8822B(x)                                              \
+	(((x) & BIT_MASK_I2C_M_STATUS_8822B) << BIT_SHIFT_I2C_M_STATUS_8822B)
+#define BIT_GET_I2C_M_STATUS_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_I2C_M_STATUS_8822B) & BIT_MASK_I2C_M_STATUS_8822B)
+
+#define BIT_SHIFT_I2C_M_BUS_GNT_FW_8822B 4
+#define BIT_MASK_I2C_M_BUS_GNT_FW_8822B 0x7
+#define BIT_I2C_M_BUS_GNT_FW_8822B(x)                                          \
+	(((x) & BIT_MASK_I2C_M_BUS_GNT_FW_8822B)                               \
+	 << BIT_SHIFT_I2C_M_BUS_GNT_FW_8822B)
+#define BIT_GET_I2C_M_BUS_GNT_FW_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_I2C_M_BUS_GNT_FW_8822B) &                           \
+	 BIT_MASK_I2C_M_BUS_GNT_FW_8822B)
+
+#define BIT_I2C_M_GNT_FW_8822B BIT(3)
+
+#define BIT_SHIFT_I2C_M_SPEED_8822B 1
+#define BIT_MASK_I2C_M_SPEED_8822B 0x3
+#define BIT_I2C_M_SPEED_8822B(x)                                               \
+	(((x) & BIT_MASK_I2C_M_SPEED_8822B) << BIT_SHIFT_I2C_M_SPEED_8822B)
+#define BIT_GET_I2C_M_SPEED_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_I2C_M_SPEED_8822B) & BIT_MASK_I2C_M_SPEED_8822B)
+
+#define BIT_I2C_M_UNLOCK_8822B BIT(0)
+
+/* 2 REG_RXFF_BNDY_8822B */
+
+/* 2 REG_NOT_VALID_8822B */
+
+#define BIT_SHIFT_RXFF0_BNDY_V2_8822B 0
+#define BIT_MASK_RXFF0_BNDY_V2_8822B 0x3ffff
+#define BIT_RXFF0_BNDY_V2_8822B(x)                                             \
+	(((x) & BIT_MASK_RXFF0_BNDY_V2_8822B) << BIT_SHIFT_RXFF0_BNDY_V2_8822B)
+#define BIT_GET_RXFF0_BNDY_V2_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_RXFF0_BNDY_V2_8822B) & BIT_MASK_RXFF0_BNDY_V2_8822B)
+
+/* 2 REG_FE1IMR_8822B */
+#define BIT_FS_RXDMA2_DONE_INT_EN_8822B BIT(28)
+#define BIT_FS_RXDONE3_INT_EN_8822B BIT(27)
+#define BIT_FS_RXDONE2_INT_EN_8822B BIT(26)
+#define BIT_FS_RX_BCN_P4_INT_EN_8822B BIT(25)
+#define BIT_FS_RX_BCN_P3_INT_EN_8822B BIT(24)
+#define BIT_FS_RX_BCN_P2_INT_EN_8822B BIT(23)
+#define BIT_FS_RX_BCN_P1_INT_EN_8822B BIT(22)
+#define BIT_FS_RX_BCN_P0_INT_EN_8822B BIT(21)
+#define BIT_FS_RX_UMD0_INT_EN_8822B BIT(20)
+#define BIT_FS_RX_UMD1_INT_EN_8822B BIT(19)
+#define BIT_FS_RX_BMD0_INT_EN_8822B BIT(18)
+#define BIT_FS_RX_BMD1_INT_EN_8822B BIT(17)
+#define BIT_FS_RXDONE_INT_EN_8822B BIT(16)
+#define BIT_FS_WWLAN_INT_EN_8822B BIT(15)
+#define BIT_FS_SOUND_DONE_INT_EN_8822B BIT(14)
+#define BIT_FS_LP_STBY_INT_EN_8822B BIT(13)
+#define BIT_FS_TRL_MTR_INT_EN_8822B BIT(12)
+#define BIT_FS_BF1_PRETO_INT_EN_8822B BIT(11)
+#define BIT_FS_BF0_PRETO_INT_EN_8822B BIT(10)
+#define BIT_FS_PTCL_RELEASE_MACID_INT_EN_8822B BIT(9)
+#define BIT_FS_LTE_COEX_EN_8822B BIT(6)
+#define BIT_FS_WLACTOFF_INT_EN_8822B BIT(5)
+#define BIT_FS_WLACTON_INT_EN_8822B BIT(4)
+#define BIT_FS_BTCMD_INT_EN_8822B BIT(3)
+#define BIT_FS_REG_MAILBOX_TO_I2C_INT_EN_8822B BIT(2)
+#define BIT_FS_TRPC_TO_INT_EN_V1_8822B BIT(1)
+#define BIT_FS_RPC_O_T_INT_EN_V1_8822B BIT(0)
+
+/* 2 REG_FE1ISR_8822B */
+#define BIT_FS_RXDMA2_DONE_INT_8822B BIT(28)
+#define BIT_FS_RXDONE3_INT_8822B BIT(27)
+#define BIT_FS_RXDONE2_INT_8822B BIT(26)
+#define BIT_FS_RX_BCN_P4_INT_8822B BIT(25)
+#define BIT_FS_RX_BCN_P3_INT_8822B BIT(24)
+#define BIT_FS_RX_BCN_P2_INT_8822B BIT(23)
+#define BIT_FS_RX_BCN_P1_INT_8822B BIT(22)
+#define BIT_FS_RX_BCN_P0_INT_8822B BIT(21)
+#define BIT_FS_RX_UMD0_INT_8822B BIT(20)
+#define BIT_FS_RX_UMD1_INT_8822B BIT(19)
+#define BIT_FS_RX_BMD0_INT_8822B BIT(18)
+#define BIT_FS_RX_BMD1_INT_8822B BIT(17)
+#define BIT_FS_RXDONE_INT_8822B BIT(16)
+#define BIT_FS_WWLAN_INT_8822B BIT(15)
+#define BIT_FS_SOUND_DONE_INT_8822B BIT(14)
+#define BIT_FS_LP_STBY_INT_8822B BIT(13)
+#define BIT_FS_TRL_MTR_INT_8822B BIT(12)
+#define BIT_FS_BF1_PRETO_INT_8822B BIT(11)
+#define BIT_FS_BF0_PRETO_INT_8822B BIT(10)
+#define BIT_FS_PTCL_RELEASE_MACID_INT_8822B BIT(9)
+#define BIT_FS_LTE_COEX_INT_8822B BIT(6)
+#define BIT_FS_WLACTOFF_INT_8822B BIT(5)
+#define BIT_FS_WLACTON_INT_8822B BIT(4)
+#define BIT_FS_BCN_RX_INT_INT_8822B BIT(3)
+#define BIT_FS_MAILBOX_TO_I2C_INT_8822B BIT(2)
+#define BIT_FS_TRPC_TO_INT_8822B BIT(1)
+#define BIT_FS_RPC_O_T_INT_8822B BIT(0)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_CPWM_8822B */
+#define BIT_CPWM_TOGGLING_8822B BIT(31)
+
+#define BIT_SHIFT_CPWM_MOD_8822B 24
+#define BIT_MASK_CPWM_MOD_8822B 0x7f
+#define BIT_CPWM_MOD_8822B(x)                                                  \
+	(((x) & BIT_MASK_CPWM_MOD_8822B) << BIT_SHIFT_CPWM_MOD_8822B)
+#define BIT_GET_CPWM_MOD_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_CPWM_MOD_8822B) & BIT_MASK_CPWM_MOD_8822B)
+
+/* 2 REG_FWIMR_8822B */
+#define BIT_FS_TXBCNOK_MB7_INT_EN_8822B BIT(31)
+#define BIT_FS_TXBCNOK_MB6_INT_EN_8822B BIT(30)
+#define BIT_FS_TXBCNOK_MB5_INT_EN_8822B BIT(29)
+#define BIT_FS_TXBCNOK_MB4_INT_EN_8822B BIT(28)
+#define BIT_FS_TXBCNOK_MB3_INT_EN_8822B BIT(27)
+#define BIT_FS_TXBCNOK_MB2_INT_EN_8822B BIT(26)
+#define BIT_FS_TXBCNOK_MB1_INT_EN_8822B BIT(25)
+#define BIT_FS_TXBCNOK_MB0_INT_EN_8822B BIT(24)
+#define BIT_FS_TXBCNERR_MB7_INT_EN_8822B BIT(23)
+#define BIT_FS_TXBCNERR_MB6_INT_EN_8822B BIT(22)
+#define BIT_FS_TXBCNERR_MB5_INT_EN_8822B BIT(21)
+#define BIT_FS_TXBCNERR_MB4_INT_EN_8822B BIT(20)
+#define BIT_FS_TXBCNERR_MB3_INT_EN_8822B BIT(19)
+#define BIT_FS_TXBCNERR_MB2_INT_EN_8822B BIT(18)
+#define BIT_FS_TXBCNERR_MB1_INT_EN_8822B BIT(17)
+#define BIT_FS_TXBCNERR_MB0_INT_EN_8822B BIT(16)
+#define BIT_CPU_MGQ_TXDONE_INT_EN_8822B BIT(15)
+#define BIT_SIFS_OVERSPEC_INT_EN_8822B BIT(14)
+#define BIT_FS_MGNTQ_RPTR_RELEASE_INT_EN_8822B BIT(13)
+#define BIT_FS_MGNTQFF_TO_INT_EN_8822B BIT(12)
+#define BIT_FS_DDMA1_LP_INT_EN_8822B BIT(11)
+#define BIT_FS_DDMA1_HP_INT_EN_8822B BIT(10)
+#define BIT_FS_DDMA0_LP_INT_EN_8822B BIT(9)
+#define BIT_FS_DDMA0_HP_INT_EN_8822B BIT(8)
+#define BIT_FS_TRXRPT_INT_EN_8822B BIT(7)
+#define BIT_FS_C2H_W_READY_INT_EN_8822B BIT(6)
+#define BIT_FS_HRCV_INT_EN_8822B BIT(5)
+#define BIT_FS_H2CCMD_INT_EN_8822B BIT(4)
+#define BIT_FS_TXPKTIN_INT_EN_8822B BIT(3)
+#define BIT_FS_ERRORHDL_INT_EN_8822B BIT(2)
+#define BIT_FS_TXCCX_INT_EN_8822B BIT(1)
+#define BIT_FS_TXCLOSE_INT_EN_8822B BIT(0)
+
+/* 2 REG_FWISR_8822B */
+#define BIT_FS_TXBCNOK_MB7_INT_8822B BIT(31)
+#define BIT_FS_TXBCNOK_MB6_INT_8822B BIT(30)
+#define BIT_FS_TXBCNOK_MB5_INT_8822B BIT(29)
+#define BIT_FS_TXBCNOK_MB4_INT_8822B BIT(28)
+#define BIT_FS_TXBCNOK_MB3_INT_8822B BIT(27)
+#define BIT_FS_TXBCNOK_MB2_INT_8822B BIT(26)
+#define BIT_FS_TXBCNOK_MB1_INT_8822B BIT(25)
+#define BIT_FS_TXBCNOK_MB0_INT_8822B BIT(24)
+#define BIT_FS_TXBCNERR_MB7_INT_8822B BIT(23)
+#define BIT_FS_TXBCNERR_MB6_INT_8822B BIT(22)
+#define BIT_FS_TXBCNERR_MB5_INT_8822B BIT(21)
+#define BIT_FS_TXBCNERR_MB4_INT_8822B BIT(20)
+#define BIT_FS_TXBCNERR_MB3_INT_8822B BIT(19)
+#define BIT_FS_TXBCNERR_MB2_INT_8822B BIT(18)
+#define BIT_FS_TXBCNERR_MB1_INT_8822B BIT(17)
+#define BIT_FS_TXBCNERR_MB0_INT_8822B BIT(16)
+#define BIT_CPU_MGQ_TXDONE_INT_8822B BIT(15)
+#define BIT_SIFS_OVERSPEC_INT_8822B BIT(14)
+#define BIT_FS_MGNTQ_RPTR_RELEASE_INT_8822B BIT(13)
+#define BIT_FS_MGNTQFF_TO_INT_8822B BIT(12)
+#define BIT_FS_DDMA1_LP_INT_8822B BIT(11)
+#define BIT_FS_DDMA1_HP_INT_8822B BIT(10)
+#define BIT_FS_DDMA0_LP_INT_8822B BIT(9)
+#define BIT_FS_DDMA0_HP_INT_8822B BIT(8)
+#define BIT_FS_TRXRPT_INT_8822B BIT(7)
+#define BIT_FS_C2H_W_READY_INT_8822B BIT(6)
+#define BIT_FS_HRCV_INT_8822B BIT(5)
+#define BIT_FS_H2CCMD_INT_8822B BIT(4)
+#define BIT_FS_TXPKTIN_INT_8822B BIT(3)
+#define BIT_FS_ERRORHDL_INT_8822B BIT(2)
+#define BIT_FS_TXCCX_INT_8822B BIT(1)
+#define BIT_FS_TXCLOSE_INT_8822B BIT(0)
+
+/* 2 REG_FTIMR_8822B */
+#define BIT_PS_TIMER_C_EARLY_INT_EN_8822B BIT(23)
+#define BIT_PS_TIMER_B_EARLY_INT_EN_8822B BIT(22)
+#define BIT_PS_TIMER_A_EARLY_INT_EN_8822B BIT(21)
+#define BIT_CPUMGQ_TX_TIMER_EARLY_INT_EN_8822B BIT(20)
+#define BIT_PS_TIMER_C_INT_EN_8822B BIT(19)
+#define BIT_PS_TIMER_B_INT_EN_8822B BIT(18)
+#define BIT_PS_TIMER_A_INT_EN_8822B BIT(17)
+#define BIT_CPUMGQ_TX_TIMER_INT_EN_8822B BIT(16)
+#define BIT_FS_PS_TIMEOUT2_EN_8822B BIT(15)
+#define BIT_FS_PS_TIMEOUT1_EN_8822B BIT(14)
+#define BIT_FS_PS_TIMEOUT0_EN_8822B BIT(13)
+#define BIT_FS_GTINT8_EN_8822B BIT(8)
+#define BIT_FS_GTINT7_EN_8822B BIT(7)
+#define BIT_FS_GTINT6_EN_8822B BIT(6)
+#define BIT_FS_GTINT5_EN_8822B BIT(5)
+#define BIT_FS_GTINT4_EN_8822B BIT(4)
+#define BIT_FS_GTINT3_EN_8822B BIT(3)
+#define BIT_FS_GTINT2_EN_8822B BIT(2)
+#define BIT_FS_GTINT1_EN_8822B BIT(1)
+#define BIT_FS_GTINT0_EN_8822B BIT(0)
+
+/* 2 REG_FTISR_8822B */
+#define BIT_PS_TIMER_C_EARLY__INT_8822B BIT(23)
+#define BIT_PS_TIMER_B_EARLY__INT_8822B BIT(22)
+#define BIT_PS_TIMER_A_EARLY__INT_8822B BIT(21)
+#define BIT_CPUMGQ_TX_TIMER_EARLY_INT_8822B BIT(20)
+#define BIT_PS_TIMER_C_INT_8822B BIT(19)
+#define BIT_PS_TIMER_B_INT_8822B BIT(18)
+#define BIT_PS_TIMER_A_INT_8822B BIT(17)
+#define BIT_CPUMGQ_TX_TIMER_INT_8822B BIT(16)
+#define BIT_FS_PS_TIMEOUT2_INT_8822B BIT(15)
+#define BIT_FS_PS_TIMEOUT1_INT_8822B BIT(14)
+#define BIT_FS_PS_TIMEOUT0_INT_8822B BIT(13)
+#define BIT_FS_GTINT8_INT_8822B BIT(8)
+#define BIT_FS_GTINT7_INT_8822B BIT(7)
+#define BIT_FS_GTINT6_INT_8822B BIT(6)
+#define BIT_FS_GTINT5_INT_8822B BIT(5)
+#define BIT_FS_GTINT4_INT_8822B BIT(4)
+#define BIT_FS_GTINT3_INT_8822B BIT(3)
+#define BIT_FS_GTINT2_INT_8822B BIT(2)
+#define BIT_FS_GTINT1_INT_8822B BIT(1)
+#define BIT_FS_GTINT0_INT_8822B BIT(0)
+
+/* 2 REG_PKTBUF_DBG_CTRL_8822B */
+
+#define BIT_SHIFT_PKTBUF_WRITE_EN_8822B 24
+#define BIT_MASK_PKTBUF_WRITE_EN_8822B 0xff
+#define BIT_PKTBUF_WRITE_EN_8822B(x)                                           \
+	(((x) & BIT_MASK_PKTBUF_WRITE_EN_8822B)                                \
+	 << BIT_SHIFT_PKTBUF_WRITE_EN_8822B)
+#define BIT_GET_PKTBUF_WRITE_EN_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_PKTBUF_WRITE_EN_8822B) &                            \
+	 BIT_MASK_PKTBUF_WRITE_EN_8822B)
+
+#define BIT_TXRPTBUF_DBG_8822B BIT(23)
+
+/* 2 REG_NOT_VALID_8822B */
+#define BIT_TXPKTBUF_DBG_V2_8822B BIT(20)
+#define BIT_RXPKTBUF_DBG_8822B BIT(16)
+
+#define BIT_SHIFT_PKTBUF_DBG_ADDR_8822B 0
+#define BIT_MASK_PKTBUF_DBG_ADDR_8822B 0x1fff
+#define BIT_PKTBUF_DBG_ADDR_8822B(x)                                           \
+	(((x) & BIT_MASK_PKTBUF_DBG_ADDR_8822B)                                \
+	 << BIT_SHIFT_PKTBUF_DBG_ADDR_8822B)
+#define BIT_GET_PKTBUF_DBG_ADDR_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_PKTBUF_DBG_ADDR_8822B) &                            \
+	 BIT_MASK_PKTBUF_DBG_ADDR_8822B)
+
+/* 2 REG_PKTBUF_DBG_DATA_L_8822B */
+
+#define BIT_SHIFT_PKTBUF_DBG_DATA_L_8822B 0
+#define BIT_MASK_PKTBUF_DBG_DATA_L_8822B 0xffffffffL
+#define BIT_PKTBUF_DBG_DATA_L_8822B(x)                                         \
+	(((x) & BIT_MASK_PKTBUF_DBG_DATA_L_8822B)                              \
+	 << BIT_SHIFT_PKTBUF_DBG_DATA_L_8822B)
+#define BIT_GET_PKTBUF_DBG_DATA_L_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_PKTBUF_DBG_DATA_L_8822B) &                          \
+	 BIT_MASK_PKTBUF_DBG_DATA_L_8822B)
+
+/* 2 REG_PKTBUF_DBG_DATA_H_8822B */
+
+#define BIT_SHIFT_PKTBUF_DBG_DATA_H_8822B 0
+#define BIT_MASK_PKTBUF_DBG_DATA_H_8822B 0xffffffffL
+#define BIT_PKTBUF_DBG_DATA_H_8822B(x)                                         \
+	(((x) & BIT_MASK_PKTBUF_DBG_DATA_H_8822B)                              \
+	 << BIT_SHIFT_PKTBUF_DBG_DATA_H_8822B)
+#define BIT_GET_PKTBUF_DBG_DATA_H_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_PKTBUF_DBG_DATA_H_8822B) &                          \
+	 BIT_MASK_PKTBUF_DBG_DATA_H_8822B)
+
+/* 2 REG_CPWM2_8822B */
+
+#define BIT_SHIFT_L0S_TO_RCVY_NUM_8822B 16
+#define BIT_MASK_L0S_TO_RCVY_NUM_8822B 0xff
+#define BIT_L0S_TO_RCVY_NUM_8822B(x)                                           \
+	(((x) & BIT_MASK_L0S_TO_RCVY_NUM_8822B)                                \
+	 << BIT_SHIFT_L0S_TO_RCVY_NUM_8822B)
+#define BIT_GET_L0S_TO_RCVY_NUM_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_L0S_TO_RCVY_NUM_8822B) &                            \
+	 BIT_MASK_L0S_TO_RCVY_NUM_8822B)
+
+#define BIT_CPWM2_TOGGLING_8822B BIT(15)
+
+#define BIT_SHIFT_CPWM2_MOD_8822B 0
+#define BIT_MASK_CPWM2_MOD_8822B 0x7fff
+#define BIT_CPWM2_MOD_8822B(x)                                                 \
+	(((x) & BIT_MASK_CPWM2_MOD_8822B) << BIT_SHIFT_CPWM2_MOD_8822B)
+#define BIT_GET_CPWM2_MOD_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_CPWM2_MOD_8822B) & BIT_MASK_CPWM2_MOD_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_TC0_CTRL_8822B */
+#define BIT_TC0INT_EN_8822B BIT(26)
+#define BIT_TC0MODE_8822B BIT(25)
+#define BIT_TC0EN_8822B BIT(24)
+
+#define BIT_SHIFT_TC0DATA_8822B 0
+#define BIT_MASK_TC0DATA_8822B 0xffffff
+#define BIT_TC0DATA_8822B(x)                                                   \
+	(((x) & BIT_MASK_TC0DATA_8822B) << BIT_SHIFT_TC0DATA_8822B)
+#define BIT_GET_TC0DATA_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_TC0DATA_8822B) & BIT_MASK_TC0DATA_8822B)
+
+/* 2 REG_TC1_CTRL_8822B */
+#define BIT_TC1INT_EN_8822B BIT(26)
+#define BIT_TC1MODE_8822B BIT(25)
+#define BIT_TC1EN_8822B BIT(24)
+
+#define BIT_SHIFT_TC1DATA_8822B 0
+#define BIT_MASK_TC1DATA_8822B 0xffffff
+#define BIT_TC1DATA_8822B(x)                                                   \
+	(((x) & BIT_MASK_TC1DATA_8822B) << BIT_SHIFT_TC1DATA_8822B)
+#define BIT_GET_TC1DATA_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_TC1DATA_8822B) & BIT_MASK_TC1DATA_8822B)
+
+/* 2 REG_TC2_CTRL_8822B */
+#define BIT_TC2INT_EN_8822B BIT(26)
+#define BIT_TC2MODE_8822B BIT(25)
+#define BIT_TC2EN_8822B BIT(24)
+
+#define BIT_SHIFT_TC2DATA_8822B 0
+#define BIT_MASK_TC2DATA_8822B 0xffffff
+#define BIT_TC2DATA_8822B(x)                                                   \
+	(((x) & BIT_MASK_TC2DATA_8822B) << BIT_SHIFT_TC2DATA_8822B)
+#define BIT_GET_TC2DATA_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_TC2DATA_8822B) & BIT_MASK_TC2DATA_8822B)
+
+/* 2 REG_TC3_CTRL_8822B */
+#define BIT_TC3INT_EN_8822B BIT(26)
+#define BIT_TC3MODE_8822B BIT(25)
+#define BIT_TC3EN_8822B BIT(24)
+
+#define BIT_SHIFT_TC3DATA_8822B 0
+#define BIT_MASK_TC3DATA_8822B 0xffffff
+#define BIT_TC3DATA_8822B(x)                                                   \
+	(((x) & BIT_MASK_TC3DATA_8822B) << BIT_SHIFT_TC3DATA_8822B)
+#define BIT_GET_TC3DATA_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_TC3DATA_8822B) & BIT_MASK_TC3DATA_8822B)
+
+/* 2 REG_TC4_CTRL_8822B */
+#define BIT_TC4INT_EN_8822B BIT(26)
+#define BIT_TC4MODE_8822B BIT(25)
+#define BIT_TC4EN_8822B BIT(24)
+
+#define BIT_SHIFT_TC4DATA_8822B 0
+#define BIT_MASK_TC4DATA_8822B 0xffffff
+#define BIT_TC4DATA_8822B(x)                                                   \
+	(((x) & BIT_MASK_TC4DATA_8822B) << BIT_SHIFT_TC4DATA_8822B)
+#define BIT_GET_TC4DATA_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_TC4DATA_8822B) & BIT_MASK_TC4DATA_8822B)
+
+/* 2 REG_TCUNIT_BASE_8822B */
+
+#define BIT_SHIFT_TCUNIT_BASE_8822B 0
+#define BIT_MASK_TCUNIT_BASE_8822B 0x3fff
+#define BIT_TCUNIT_BASE_8822B(x)                                               \
+	(((x) & BIT_MASK_TCUNIT_BASE_8822B) << BIT_SHIFT_TCUNIT_BASE_8822B)
+#define BIT_GET_TCUNIT_BASE_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_TCUNIT_BASE_8822B) & BIT_MASK_TCUNIT_BASE_8822B)
+
+/* 2 REG_TC5_CTRL_8822B */
+#define BIT_TC5INT_EN_8822B BIT(26)
+#define BIT_TC5MODE_8822B BIT(25)
+#define BIT_TC5EN_8822B BIT(24)
+
+#define BIT_SHIFT_TC5DATA_8822B 0
+#define BIT_MASK_TC5DATA_8822B 0xffffff
+#define BIT_TC5DATA_8822B(x)                                                   \
+	(((x) & BIT_MASK_TC5DATA_8822B) << BIT_SHIFT_TC5DATA_8822B)
+#define BIT_GET_TC5DATA_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_TC5DATA_8822B) & BIT_MASK_TC5DATA_8822B)
+
+/* 2 REG_TC6_CTRL_8822B */
+#define BIT_TC6INT_EN_8822B BIT(26)
+#define BIT_TC6MODE_8822B BIT(25)
+#define BIT_TC6EN_8822B BIT(24)
+
+#define BIT_SHIFT_TC6DATA_8822B 0
+#define BIT_MASK_TC6DATA_8822B 0xffffff
+#define BIT_TC6DATA_8822B(x)                                                   \
+	(((x) & BIT_MASK_TC6DATA_8822B) << BIT_SHIFT_TC6DATA_8822B)
+#define BIT_GET_TC6DATA_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_TC6DATA_8822B) & BIT_MASK_TC6DATA_8822B)
+
+/* 2 REG_MBIST_FAIL_8822B */
+
+#define BIT_SHIFT_8051_MBIST_FAIL_8822B 26
+#define BIT_MASK_8051_MBIST_FAIL_8822B 0x7
+#define BIT_8051_MBIST_FAIL_8822B(x)                                           \
+	(((x) & BIT_MASK_8051_MBIST_FAIL_8822B)                                \
+	 << BIT_SHIFT_8051_MBIST_FAIL_8822B)
+#define BIT_GET_8051_MBIST_FAIL_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_8051_MBIST_FAIL_8822B) &                            \
+	 BIT_MASK_8051_MBIST_FAIL_8822B)
+
+#define BIT_SHIFT_USB_MBIST_FAIL_8822B 24
+#define BIT_MASK_USB_MBIST_FAIL_8822B 0x3
+#define BIT_USB_MBIST_FAIL_8822B(x)                                            \
+	(((x) & BIT_MASK_USB_MBIST_FAIL_8822B)                                 \
+	 << BIT_SHIFT_USB_MBIST_FAIL_8822B)
+#define BIT_GET_USB_MBIST_FAIL_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_USB_MBIST_FAIL_8822B) &                             \
+	 BIT_MASK_USB_MBIST_FAIL_8822B)
+
+#define BIT_SHIFT_PCIE_MBIST_FAIL_8822B 16
+#define BIT_MASK_PCIE_MBIST_FAIL_8822B 0x3f
+#define BIT_PCIE_MBIST_FAIL_8822B(x)                                           \
+	(((x) & BIT_MASK_PCIE_MBIST_FAIL_8822B)                                \
+	 << BIT_SHIFT_PCIE_MBIST_FAIL_8822B)
+#define BIT_GET_PCIE_MBIST_FAIL_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_PCIE_MBIST_FAIL_8822B) &                            \
+	 BIT_MASK_PCIE_MBIST_FAIL_8822B)
+
+#define BIT_SHIFT_MAC_MBIST_FAIL_8822B 0
+#define BIT_MASK_MAC_MBIST_FAIL_8822B 0xfff
+#define BIT_MAC_MBIST_FAIL_8822B(x)                                            \
+	(((x) & BIT_MASK_MAC_MBIST_FAIL_8822B)                                 \
+	 << BIT_SHIFT_MAC_MBIST_FAIL_8822B)
+#define BIT_GET_MAC_MBIST_FAIL_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_MAC_MBIST_FAIL_8822B) &                             \
+	 BIT_MASK_MAC_MBIST_FAIL_8822B)
+
+/* 2 REG_MBIST_START_PAUSE_8822B */
+
+#define BIT_SHIFT_8051_MBIST_START_PAUSE_8822B 26
+#define BIT_MASK_8051_MBIST_START_PAUSE_8822B 0x7
+#define BIT_8051_MBIST_START_PAUSE_8822B(x)                                    \
+	(((x) & BIT_MASK_8051_MBIST_START_PAUSE_8822B)                         \
+	 << BIT_SHIFT_8051_MBIST_START_PAUSE_8822B)
+#define BIT_GET_8051_MBIST_START_PAUSE_8822B(x)                                \
+	(((x) >> BIT_SHIFT_8051_MBIST_START_PAUSE_8822B) &                     \
+	 BIT_MASK_8051_MBIST_START_PAUSE_8822B)
+
+#define BIT_SHIFT_USB_MBIST_START_PAUSE_8822B 24
+#define BIT_MASK_USB_MBIST_START_PAUSE_8822B 0x3
+#define BIT_USB_MBIST_START_PAUSE_8822B(x)                                     \
+	(((x) & BIT_MASK_USB_MBIST_START_PAUSE_8822B)                          \
+	 << BIT_SHIFT_USB_MBIST_START_PAUSE_8822B)
+#define BIT_GET_USB_MBIST_START_PAUSE_8822B(x)                                 \
+	(((x) >> BIT_SHIFT_USB_MBIST_START_PAUSE_8822B) &                      \
+	 BIT_MASK_USB_MBIST_START_PAUSE_8822B)
+
+#define BIT_SHIFT_PCIE_MBIST_START_PAUSE_8822B 16
+#define BIT_MASK_PCIE_MBIST_START_PAUSE_8822B 0x3f
+#define BIT_PCIE_MBIST_START_PAUSE_8822B(x)                                    \
+	(((x) & BIT_MASK_PCIE_MBIST_START_PAUSE_8822B)                         \
+	 << BIT_SHIFT_PCIE_MBIST_START_PAUSE_8822B)
+#define BIT_GET_PCIE_MBIST_START_PAUSE_8822B(x)                                \
+	(((x) >> BIT_SHIFT_PCIE_MBIST_START_PAUSE_8822B) &                     \
+	 BIT_MASK_PCIE_MBIST_START_PAUSE_8822B)
+
+#define BIT_SHIFT_MAC_MBIST_START_PAUSE_8822B 0
+#define BIT_MASK_MAC_MBIST_START_PAUSE_8822B 0xfff
+#define BIT_MAC_MBIST_START_PAUSE_8822B(x)                                     \
+	(((x) & BIT_MASK_MAC_MBIST_START_PAUSE_8822B)                          \
+	 << BIT_SHIFT_MAC_MBIST_START_PAUSE_8822B)
+#define BIT_GET_MAC_MBIST_START_PAUSE_8822B(x)                                 \
+	(((x) >> BIT_SHIFT_MAC_MBIST_START_PAUSE_8822B) &                      \
+	 BIT_MASK_MAC_MBIST_START_PAUSE_8822B)
+
+/* 2 REG_MBIST_DONE_8822B */
+
+#define BIT_SHIFT_8051_MBIST_DONE_8822B 26
+#define BIT_MASK_8051_MBIST_DONE_8822B 0x7
+#define BIT_8051_MBIST_DONE_8822B(x)                                           \
+	(((x) & BIT_MASK_8051_MBIST_DONE_8822B)                                \
+	 << BIT_SHIFT_8051_MBIST_DONE_8822B)
+#define BIT_GET_8051_MBIST_DONE_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_8051_MBIST_DONE_8822B) &                            \
+	 BIT_MASK_8051_MBIST_DONE_8822B)
+
+#define BIT_SHIFT_USB_MBIST_DONE_8822B 24
+#define BIT_MASK_USB_MBIST_DONE_8822B 0x3
+#define BIT_USB_MBIST_DONE_8822B(x)                                            \
+	(((x) & BIT_MASK_USB_MBIST_DONE_8822B)                                 \
+	 << BIT_SHIFT_USB_MBIST_DONE_8822B)
+#define BIT_GET_USB_MBIST_DONE_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_USB_MBIST_DONE_8822B) &                             \
+	 BIT_MASK_USB_MBIST_DONE_8822B)
+
+#define BIT_SHIFT_PCIE_MBIST_DONE_8822B 16
+#define BIT_MASK_PCIE_MBIST_DONE_8822B 0x3f
+#define BIT_PCIE_MBIST_DONE_8822B(x)                                           \
+	(((x) & BIT_MASK_PCIE_MBIST_DONE_8822B)                                \
+	 << BIT_SHIFT_PCIE_MBIST_DONE_8822B)
+#define BIT_GET_PCIE_MBIST_DONE_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_PCIE_MBIST_DONE_8822B) &                            \
+	 BIT_MASK_PCIE_MBIST_DONE_8822B)
+
+#define BIT_SHIFT_MAC_MBIST_DONE_8822B 0
+#define BIT_MASK_MAC_MBIST_DONE_8822B 0xfff
+#define BIT_MAC_MBIST_DONE_8822B(x)                                            \
+	(((x) & BIT_MASK_MAC_MBIST_DONE_8822B)                                 \
+	 << BIT_SHIFT_MAC_MBIST_DONE_8822B)
+#define BIT_GET_MAC_MBIST_DONE_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_MAC_MBIST_DONE_8822B) &                             \
+	 BIT_MASK_MAC_MBIST_DONE_8822B)
+
+/* 2 REG_MBIST_FAIL_NRML_8822B */
+
+#define BIT_SHIFT_MBIST_FAIL_NRML_8822B 0
+#define BIT_MASK_MBIST_FAIL_NRML_8822B 0xffffffffL
+#define BIT_MBIST_FAIL_NRML_8822B(x)                                           \
+	(((x) & BIT_MASK_MBIST_FAIL_NRML_8822B)                                \
+	 << BIT_SHIFT_MBIST_FAIL_NRML_8822B)
+#define BIT_GET_MBIST_FAIL_NRML_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_MBIST_FAIL_NRML_8822B) &                            \
+	 BIT_MASK_MBIST_FAIL_NRML_8822B)
+
+/* 2 REG_AES_DECRPT_DATA_8822B */
+
+#define BIT_SHIFT_IPS_CFG_ADDR_8822B 0
+#define BIT_MASK_IPS_CFG_ADDR_8822B 0xff
+#define BIT_IPS_CFG_ADDR_8822B(x)                                              \
+	(((x) & BIT_MASK_IPS_CFG_ADDR_8822B) << BIT_SHIFT_IPS_CFG_ADDR_8822B)
+#define BIT_GET_IPS_CFG_ADDR_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_IPS_CFG_ADDR_8822B) & BIT_MASK_IPS_CFG_ADDR_8822B)
+
+/* 2 REG_AES_DECRPT_CFG_8822B */
+
+#define BIT_SHIFT_IPS_CFG_DATA_8822B 0
+#define BIT_MASK_IPS_CFG_DATA_8822B 0xffffffffL
+#define BIT_IPS_CFG_DATA_8822B(x)                                              \
+	(((x) & BIT_MASK_IPS_CFG_DATA_8822B) << BIT_SHIFT_IPS_CFG_DATA_8822B)
+#define BIT_GET_IPS_CFG_DATA_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_IPS_CFG_DATA_8822B) & BIT_MASK_IPS_CFG_DATA_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_TMETER_8822B */
+#define BIT_TEMP_VALID_8822B BIT(31)
+
+#define BIT_SHIFT_TEMP_VALUE_8822B 24
+#define BIT_MASK_TEMP_VALUE_8822B 0x3f
+#define BIT_TEMP_VALUE_8822B(x)                                                \
+	(((x) & BIT_MASK_TEMP_VALUE_8822B) << BIT_SHIFT_TEMP_VALUE_8822B)
+#define BIT_GET_TEMP_VALUE_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_TEMP_VALUE_8822B) & BIT_MASK_TEMP_VALUE_8822B)
+
+#define BIT_SHIFT_REG_TMETER_TIMER_8822B 8
+#define BIT_MASK_REG_TMETER_TIMER_8822B 0xfff
+#define BIT_REG_TMETER_TIMER_8822B(x)                                          \
+	(((x) & BIT_MASK_REG_TMETER_TIMER_8822B)                               \
+	 << BIT_SHIFT_REG_TMETER_TIMER_8822B)
+#define BIT_GET_REG_TMETER_TIMER_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_REG_TMETER_TIMER_8822B) &                           \
+	 BIT_MASK_REG_TMETER_TIMER_8822B)
+
+#define BIT_SHIFT_REG_TEMP_DELTA_8822B 2
+#define BIT_MASK_REG_TEMP_DELTA_8822B 0x3f
+#define BIT_REG_TEMP_DELTA_8822B(x)                                            \
+	(((x) & BIT_MASK_REG_TEMP_DELTA_8822B)                                 \
+	 << BIT_SHIFT_REG_TEMP_DELTA_8822B)
+#define BIT_GET_REG_TEMP_DELTA_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_REG_TEMP_DELTA_8822B) &                             \
+	 BIT_MASK_REG_TEMP_DELTA_8822B)
+
+#define BIT_REG_TMETER_EN_8822B BIT(0)
+
+/* 2 REG_OSC_32K_CTRL_8822B */
+
+#define BIT_SHIFT_OSC_32K_CLKGEN_0_8822B 16
+#define BIT_MASK_OSC_32K_CLKGEN_0_8822B 0xffff
+#define BIT_OSC_32K_CLKGEN_0_8822B(x)                                          \
+	(((x) & BIT_MASK_OSC_32K_CLKGEN_0_8822B)                               \
+	 << BIT_SHIFT_OSC_32K_CLKGEN_0_8822B)
+#define BIT_GET_OSC_32K_CLKGEN_0_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_OSC_32K_CLKGEN_0_8822B) &                           \
+	 BIT_MASK_OSC_32K_CLKGEN_0_8822B)
+
+#define BIT_SHIFT_OSC_32K_RES_COMP_8822B 4
+#define BIT_MASK_OSC_32K_RES_COMP_8822B 0x3
+#define BIT_OSC_32K_RES_COMP_8822B(x)                                          \
+	(((x) & BIT_MASK_OSC_32K_RES_COMP_8822B)                               \
+	 << BIT_SHIFT_OSC_32K_RES_COMP_8822B)
+#define BIT_GET_OSC_32K_RES_COMP_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_OSC_32K_RES_COMP_8822B) &                           \
+	 BIT_MASK_OSC_32K_RES_COMP_8822B)
+
+#define BIT_OSC_32K_OUT_SEL_8822B BIT(3)
+#define BIT_ISO_WL_2_OSC_32K_8822B BIT(1)
+#define BIT_POW_CKGEN_8822B BIT(0)
+
+/* 2 REG_32K_CAL_REG1_8822B */
+#define BIT_CAL_32K_REG_WR_8822B BIT(31)
+#define BIT_CAL_32K_DBG_SEL_8822B BIT(22)
+
+#define BIT_SHIFT_CAL_32K_REG_ADDR_8822B 16
+#define BIT_MASK_CAL_32K_REG_ADDR_8822B 0x3f
+#define BIT_CAL_32K_REG_ADDR_8822B(x)                                          \
+	(((x) & BIT_MASK_CAL_32K_REG_ADDR_8822B)                               \
+	 << BIT_SHIFT_CAL_32K_REG_ADDR_8822B)
+#define BIT_GET_CAL_32K_REG_ADDR_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_CAL_32K_REG_ADDR_8822B) &                           \
+	 BIT_MASK_CAL_32K_REG_ADDR_8822B)
+
+#define BIT_SHIFT_CAL_32K_REG_DATA_8822B 0
+#define BIT_MASK_CAL_32K_REG_DATA_8822B 0xffff
+#define BIT_CAL_32K_REG_DATA_8822B(x)                                          \
+	(((x) & BIT_MASK_CAL_32K_REG_DATA_8822B)                               \
+	 << BIT_SHIFT_CAL_32K_REG_DATA_8822B)
+#define BIT_GET_CAL_32K_REG_DATA_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_CAL_32K_REG_DATA_8822B) &                           \
+	 BIT_MASK_CAL_32K_REG_DATA_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_C2HEVT_8822B */
+
+#define BIT_SHIFT_C2HEVT_MSG_8822B 0
+#define BIT_MASK_C2HEVT_MSG_8822B 0xffffffffffffffffffffffffffffffffL
+#define BIT_C2HEVT_MSG_8822B(x)                                                \
+	(((x) & BIT_MASK_C2HEVT_MSG_8822B) << BIT_SHIFT_C2HEVT_MSG_8822B)
+#define BIT_GET_C2HEVT_MSG_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_C2HEVT_MSG_8822B) & BIT_MASK_C2HEVT_MSG_8822B)
+
+/* 2 REG_SW_DEFINED_PAGE1_8822B */
+
+#define BIT_SHIFT_SW_DEFINED_PAGE1_8822B 0
+#define BIT_MASK_SW_DEFINED_PAGE1_8822B 0xffffffffffffffffL
+#define BIT_SW_DEFINED_PAGE1_8822B(x)                                          \
+	(((x) & BIT_MASK_SW_DEFINED_PAGE1_8822B)                               \
+	 << BIT_SHIFT_SW_DEFINED_PAGE1_8822B)
+#define BIT_GET_SW_DEFINED_PAGE1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_SW_DEFINED_PAGE1_8822B) &                           \
+	 BIT_MASK_SW_DEFINED_PAGE1_8822B)
+
+/* 2 REG_MCUTST_I_8822B */
+
+#define BIT_SHIFT_MCUDMSG_I_8822B 0
+#define BIT_MASK_MCUDMSG_I_8822B 0xffffffffL
+#define BIT_MCUDMSG_I_8822B(x)                                                 \
+	(((x) & BIT_MASK_MCUDMSG_I_8822B) << BIT_SHIFT_MCUDMSG_I_8822B)
+#define BIT_GET_MCUDMSG_I_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_MCUDMSG_I_8822B) & BIT_MASK_MCUDMSG_I_8822B)
+
+/* 2 REG_MCUTST_II_8822B */
+
+#define BIT_SHIFT_MCUDMSG_II_8822B 0
+#define BIT_MASK_MCUDMSG_II_8822B 0xffffffffL
+#define BIT_MCUDMSG_II_8822B(x)                                                \
+	(((x) & BIT_MASK_MCUDMSG_II_8822B) << BIT_SHIFT_MCUDMSG_II_8822B)
+#define BIT_GET_MCUDMSG_II_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_MCUDMSG_II_8822B) & BIT_MASK_MCUDMSG_II_8822B)
+
+/* 2 REG_FMETHR_8822B */
+#define BIT_FMSG_INT_8822B BIT(31)
+
+#define BIT_SHIFT_FW_MSG_8822B 0
+#define BIT_MASK_FW_MSG_8822B 0xffffffffL
+#define BIT_FW_MSG_8822B(x)                                                    \
+	(((x) & BIT_MASK_FW_MSG_8822B) << BIT_SHIFT_FW_MSG_8822B)
+#define BIT_GET_FW_MSG_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_FW_MSG_8822B) & BIT_MASK_FW_MSG_8822B)
+
+/* 2 REG_HMETFR_8822B */
+
+#define BIT_SHIFT_HRCV_MSG_8822B 24
+#define BIT_MASK_HRCV_MSG_8822B 0xff
+#define BIT_HRCV_MSG_8822B(x)                                                  \
+	(((x) & BIT_MASK_HRCV_MSG_8822B) << BIT_SHIFT_HRCV_MSG_8822B)
+#define BIT_GET_HRCV_MSG_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_HRCV_MSG_8822B) & BIT_MASK_HRCV_MSG_8822B)
+
+#define BIT_INT_BOX3_8822B BIT(3)
+#define BIT_INT_BOX2_8822B BIT(2)
+#define BIT_INT_BOX1_8822B BIT(1)
+#define BIT_INT_BOX0_8822B BIT(0)
+
+/* 2 REG_HMEBOX0_8822B */
+
+#define BIT_SHIFT_HOST_MSG_0_8822B 0
+#define BIT_MASK_HOST_MSG_0_8822B 0xffffffffL
+#define BIT_HOST_MSG_0_8822B(x)                                                \
+	(((x) & BIT_MASK_HOST_MSG_0_8822B) << BIT_SHIFT_HOST_MSG_0_8822B)
+#define BIT_GET_HOST_MSG_0_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_HOST_MSG_0_8822B) & BIT_MASK_HOST_MSG_0_8822B)
+
+/* 2 REG_HMEBOX1_8822B */
+
+#define BIT_SHIFT_HOST_MSG_1_8822B 0
+#define BIT_MASK_HOST_MSG_1_8822B 0xffffffffL
+#define BIT_HOST_MSG_1_8822B(x)                                                \
+	(((x) & BIT_MASK_HOST_MSG_1_8822B) << BIT_SHIFT_HOST_MSG_1_8822B)
+#define BIT_GET_HOST_MSG_1_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_HOST_MSG_1_8822B) & BIT_MASK_HOST_MSG_1_8822B)
+
+/* 2 REG_HMEBOX2_8822B */
+
+#define BIT_SHIFT_HOST_MSG_2_8822B 0
+#define BIT_MASK_HOST_MSG_2_8822B 0xffffffffL
+#define BIT_HOST_MSG_2_8822B(x)                                                \
+	(((x) & BIT_MASK_HOST_MSG_2_8822B) << BIT_SHIFT_HOST_MSG_2_8822B)
+#define BIT_GET_HOST_MSG_2_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_HOST_MSG_2_8822B) & BIT_MASK_HOST_MSG_2_8822B)
+
+/* 2 REG_HMEBOX3_8822B */
+
+#define BIT_SHIFT_HOST_MSG_3_8822B 0
+#define BIT_MASK_HOST_MSG_3_8822B 0xffffffffL
+#define BIT_HOST_MSG_3_8822B(x)                                                \
+	(((x) & BIT_MASK_HOST_MSG_3_8822B) << BIT_SHIFT_HOST_MSG_3_8822B)
+#define BIT_GET_HOST_MSG_3_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_HOST_MSG_3_8822B) & BIT_MASK_HOST_MSG_3_8822B)
+
+/* 2 REG_LLT_INIT_8822B */
+
+#define BIT_SHIFT_LLTE_RWM_8822B 30
+#define BIT_MASK_LLTE_RWM_8822B 0x3
+#define BIT_LLTE_RWM_8822B(x)                                                  \
+	(((x) & BIT_MASK_LLTE_RWM_8822B) << BIT_SHIFT_LLTE_RWM_8822B)
+#define BIT_GET_LLTE_RWM_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_LLTE_RWM_8822B) & BIT_MASK_LLTE_RWM_8822B)
+
+#define BIT_SHIFT_LLTINI_PDATA_V1_8822B 16
+#define BIT_MASK_LLTINI_PDATA_V1_8822B 0xfff
+#define BIT_LLTINI_PDATA_V1_8822B(x)                                           \
+	(((x) & BIT_MASK_LLTINI_PDATA_V1_8822B)                                \
+	 << BIT_SHIFT_LLTINI_PDATA_V1_8822B)
+#define BIT_GET_LLTINI_PDATA_V1_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_LLTINI_PDATA_V1_8822B) &                            \
+	 BIT_MASK_LLTINI_PDATA_V1_8822B)
+
+#define BIT_SHIFT_LLTINI_HDATA_V1_8822B 0
+#define BIT_MASK_LLTINI_HDATA_V1_8822B 0xfff
+#define BIT_LLTINI_HDATA_V1_8822B(x)                                           \
+	(((x) & BIT_MASK_LLTINI_HDATA_V1_8822B)                                \
+	 << BIT_SHIFT_LLTINI_HDATA_V1_8822B)
+#define BIT_GET_LLTINI_HDATA_V1_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_LLTINI_HDATA_V1_8822B) &                            \
+	 BIT_MASK_LLTINI_HDATA_V1_8822B)
+
+/* 2 REG_LLT_INIT_ADDR_8822B */
+
+#define BIT_SHIFT_LLTINI_ADDR_V1_8822B 0
+#define BIT_MASK_LLTINI_ADDR_V1_8822B 0xfff
+#define BIT_LLTINI_ADDR_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_LLTINI_ADDR_V1_8822B)                                 \
+	 << BIT_SHIFT_LLTINI_ADDR_V1_8822B)
+#define BIT_GET_LLTINI_ADDR_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_LLTINI_ADDR_V1_8822B) &                             \
+	 BIT_MASK_LLTINI_ADDR_V1_8822B)
+
+/* 2 REG_BB_ACCESS_CTRL_8822B */
+
+#define BIT_SHIFT_BB_WRITE_READ_8822B 30
+#define BIT_MASK_BB_WRITE_READ_8822B 0x3
+#define BIT_BB_WRITE_READ_8822B(x)                                             \
+	(((x) & BIT_MASK_BB_WRITE_READ_8822B) << BIT_SHIFT_BB_WRITE_READ_8822B)
+#define BIT_GET_BB_WRITE_READ_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_BB_WRITE_READ_8822B) & BIT_MASK_BB_WRITE_READ_8822B)
+
+#define BIT_SHIFT_BB_WRITE_EN_8822B 12
+#define BIT_MASK_BB_WRITE_EN_8822B 0xf
+#define BIT_BB_WRITE_EN_8822B(x)                                               \
+	(((x) & BIT_MASK_BB_WRITE_EN_8822B) << BIT_SHIFT_BB_WRITE_EN_8822B)
+#define BIT_GET_BB_WRITE_EN_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_BB_WRITE_EN_8822B) & BIT_MASK_BB_WRITE_EN_8822B)
+
+#define BIT_SHIFT_BB_ADDR_8822B 2
+#define BIT_MASK_BB_ADDR_8822B 0x1ff
+#define BIT_BB_ADDR_8822B(x)                                                   \
+	(((x) & BIT_MASK_BB_ADDR_8822B) << BIT_SHIFT_BB_ADDR_8822B)
+#define BIT_GET_BB_ADDR_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_BB_ADDR_8822B) & BIT_MASK_BB_ADDR_8822B)
+
+#define BIT_BB_ERRACC_8822B BIT(0)
+
+/* 2 REG_BB_ACCESS_DATA_8822B */
+
+#define BIT_SHIFT_BB_DATA_8822B 0
+#define BIT_MASK_BB_DATA_8822B 0xffffffffL
+#define BIT_BB_DATA_8822B(x)                                                   \
+	(((x) & BIT_MASK_BB_DATA_8822B) << BIT_SHIFT_BB_DATA_8822B)
+#define BIT_GET_BB_DATA_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_BB_DATA_8822B) & BIT_MASK_BB_DATA_8822B)
+
+/* 2 REG_HMEBOX_E0_8822B */
+
+#define BIT_SHIFT_HMEBOX_E0_8822B 0
+#define BIT_MASK_HMEBOX_E0_8822B 0xffffffffL
+#define BIT_HMEBOX_E0_8822B(x)                                                 \
+	(((x) & BIT_MASK_HMEBOX_E0_8822B) << BIT_SHIFT_HMEBOX_E0_8822B)
+#define BIT_GET_HMEBOX_E0_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_HMEBOX_E0_8822B) & BIT_MASK_HMEBOX_E0_8822B)
+
+/* 2 REG_HMEBOX_E1_8822B */
+
+#define BIT_SHIFT_HMEBOX_E1_8822B 0
+#define BIT_MASK_HMEBOX_E1_8822B 0xffffffffL
+#define BIT_HMEBOX_E1_8822B(x)                                                 \
+	(((x) & BIT_MASK_HMEBOX_E1_8822B) << BIT_SHIFT_HMEBOX_E1_8822B)
+#define BIT_GET_HMEBOX_E1_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_HMEBOX_E1_8822B) & BIT_MASK_HMEBOX_E1_8822B)
+
+/* 2 REG_HMEBOX_E2_8822B */
+
+#define BIT_SHIFT_HMEBOX_E2_8822B 0
+#define BIT_MASK_HMEBOX_E2_8822B 0xffffffffL
+#define BIT_HMEBOX_E2_8822B(x)                                                 \
+	(((x) & BIT_MASK_HMEBOX_E2_8822B) << BIT_SHIFT_HMEBOX_E2_8822B)
+#define BIT_GET_HMEBOX_E2_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_HMEBOX_E2_8822B) & BIT_MASK_HMEBOX_E2_8822B)
+
+/* 2 REG_HMEBOX_E3_8822B */
+
+#define BIT_SHIFT_HMEBOX_E3_8822B 0
+#define BIT_MASK_HMEBOX_E3_8822B 0xffffffffL
+#define BIT_HMEBOX_E3_8822B(x)                                                 \
+	(((x) & BIT_MASK_HMEBOX_E3_8822B) << BIT_SHIFT_HMEBOX_E3_8822B)
+#define BIT_GET_HMEBOX_E3_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_HMEBOX_E3_8822B) & BIT_MASK_HMEBOX_E3_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_CR_EXT_8822B */
+
+#define BIT_SHIFT_PHY_REQ_DELAY_8822B 24
+#define BIT_MASK_PHY_REQ_DELAY_8822B 0xf
+#define BIT_PHY_REQ_DELAY_8822B(x)                                             \
+	(((x) & BIT_MASK_PHY_REQ_DELAY_8822B) << BIT_SHIFT_PHY_REQ_DELAY_8822B)
+#define BIT_GET_PHY_REQ_DELAY_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_PHY_REQ_DELAY_8822B) & BIT_MASK_PHY_REQ_DELAY_8822B)
+
+#define BIT_SPD_DOWN_8822B BIT(16)
+
+#define BIT_SHIFT_NETYPE4_8822B 4
+#define BIT_MASK_NETYPE4_8822B 0x3
+#define BIT_NETYPE4_8822B(x)                                                   \
+	(((x) & BIT_MASK_NETYPE4_8822B) << BIT_SHIFT_NETYPE4_8822B)
+#define BIT_GET_NETYPE4_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_NETYPE4_8822B) & BIT_MASK_NETYPE4_8822B)
+
+#define BIT_SHIFT_NETYPE3_8822B 2
+#define BIT_MASK_NETYPE3_8822B 0x3
+#define BIT_NETYPE3_8822B(x)                                                   \
+	(((x) & BIT_MASK_NETYPE3_8822B) << BIT_SHIFT_NETYPE3_8822B)
+#define BIT_GET_NETYPE3_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_NETYPE3_8822B) & BIT_MASK_NETYPE3_8822B)
+
+#define BIT_SHIFT_NETYPE2_8822B 0
+#define BIT_MASK_NETYPE2_8822B 0x3
+#define BIT_NETYPE2_8822B(x)                                                   \
+	(((x) & BIT_MASK_NETYPE2_8822B) << BIT_SHIFT_NETYPE2_8822B)
+#define BIT_GET_NETYPE2_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_NETYPE2_8822B) & BIT_MASK_NETYPE2_8822B)
+
+/* 2 REG_FWFF_8822B */
+
+#define BIT_SHIFT_PKTNUM_TH_V1_8822B 24
+#define BIT_MASK_PKTNUM_TH_V1_8822B 0xff
+#define BIT_PKTNUM_TH_V1_8822B(x)                                              \
+	(((x) & BIT_MASK_PKTNUM_TH_V1_8822B) << BIT_SHIFT_PKTNUM_TH_V1_8822B)
+#define BIT_GET_PKTNUM_TH_V1_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_PKTNUM_TH_V1_8822B) & BIT_MASK_PKTNUM_TH_V1_8822B)
+
+#define BIT_SHIFT_TIMER_TH_8822B 16
+#define BIT_MASK_TIMER_TH_8822B 0xff
+#define BIT_TIMER_TH_8822B(x)                                                  \
+	(((x) & BIT_MASK_TIMER_TH_8822B) << BIT_SHIFT_TIMER_TH_8822B)
+#define BIT_GET_TIMER_TH_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_TIMER_TH_8822B) & BIT_MASK_TIMER_TH_8822B)
+
+#define BIT_SHIFT_RXPKT1ENADDR_8822B 0
+#define BIT_MASK_RXPKT1ENADDR_8822B 0xffff
+#define BIT_RXPKT1ENADDR_8822B(x)                                              \
+	(((x) & BIT_MASK_RXPKT1ENADDR_8822B) << BIT_SHIFT_RXPKT1ENADDR_8822B)
+#define BIT_GET_RXPKT1ENADDR_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_RXPKT1ENADDR_8822B) & BIT_MASK_RXPKT1ENADDR_8822B)
+
+/* 2 REG_RXFF_PTR_V1_8822B */
+
+/* 2 REG_NOT_VALID_8822B */
+
+#define BIT_SHIFT_RXFF0_RDPTR_V2_8822B 0
+#define BIT_MASK_RXFF0_RDPTR_V2_8822B 0x3ffff
+#define BIT_RXFF0_RDPTR_V2_8822B(x)                                            \
+	(((x) & BIT_MASK_RXFF0_RDPTR_V2_8822B)                                 \
+	 << BIT_SHIFT_RXFF0_RDPTR_V2_8822B)
+#define BIT_GET_RXFF0_RDPTR_V2_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_RXFF0_RDPTR_V2_8822B) &                             \
+	 BIT_MASK_RXFF0_RDPTR_V2_8822B)
+
+/* 2 REG_RXFF_WTR_V1_8822B */
+
+/* 2 REG_NOT_VALID_8822B */
+
+#define BIT_SHIFT_RXFF0_WTPTR_V2_8822B 0
+#define BIT_MASK_RXFF0_WTPTR_V2_8822B 0x3ffff
+#define BIT_RXFF0_WTPTR_V2_8822B(x)                                            \
+	(((x) & BIT_MASK_RXFF0_WTPTR_V2_8822B)                                 \
+	 << BIT_SHIFT_RXFF0_WTPTR_V2_8822B)
+#define BIT_GET_RXFF0_WTPTR_V2_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_RXFF0_WTPTR_V2_8822B) &                             \
+	 BIT_MASK_RXFF0_WTPTR_V2_8822B)
+
+/* 2 REG_FE2IMR_8822B */
+#define BIT__FE4ISR__IND_MSK_8822B BIT(29)
+#define BIT_FS_TXSC_DESC_DONE_INT_EN_8822B BIT(28)
+#define BIT_FS_TXSC_BKDONE_INT_EN_8822B BIT(27)
+#define BIT_FS_TXSC_BEDONE_INT_EN_8822B BIT(26)
+#define BIT_FS_TXSC_VIDONE_INT_EN_8822B BIT(25)
+#define BIT_FS_TXSC_VODONE_INT_EN_8822B BIT(24)
+#define BIT_FS_ATIM_MB7_INT_EN_8822B BIT(23)
+#define BIT_FS_ATIM_MB6_INT_EN_8822B BIT(22)
+#define BIT_FS_ATIM_MB5_INT_EN_8822B BIT(21)
+#define BIT_FS_ATIM_MB4_INT_EN_8822B BIT(20)
+#define BIT_FS_ATIM_MB3_INT_EN_8822B BIT(19)
+#define BIT_FS_ATIM_MB2_INT_EN_8822B BIT(18)
+#define BIT_FS_ATIM_MB1_INT_EN_8822B BIT(17)
+#define BIT_FS_ATIM_MB0_INT_EN_8822B BIT(16)
+#define BIT_FS_TBTT4INT_EN_8822B BIT(11)
+#define BIT_FS_TBTT3INT_EN_8822B BIT(10)
+#define BIT_FS_TBTT2INT_EN_8822B BIT(9)
+#define BIT_FS_TBTT1INT_EN_8822B BIT(8)
+#define BIT_FS_TBTT0_MB7INT_EN_8822B BIT(7)
+#define BIT_FS_TBTT0_MB6INT_EN_8822B BIT(6)
+#define BIT_FS_TBTT0_MB5INT_EN_8822B BIT(5)
+#define BIT_FS_TBTT0_MB4INT_EN_8822B BIT(4)
+#define BIT_FS_TBTT0_MB3INT_EN_8822B BIT(3)
+#define BIT_FS_TBTT0_MB2INT_EN_8822B BIT(2)
+#define BIT_FS_TBTT0_MB1INT_EN_8822B BIT(1)
+#define BIT_FS_TBTT0_INT_EN_8822B BIT(0)
+
+/* 2 REG_FE2ISR_8822B */
+#define BIT__FE4ISR__IND_INT_8822B BIT(29)
+#define BIT_FS_TXSC_DESC_DONE_INT_8822B BIT(28)
+#define BIT_FS_TXSC_BKDONE_INT_8822B BIT(27)
+#define BIT_FS_TXSC_BEDONE_INT_8822B BIT(26)
+#define BIT_FS_TXSC_VIDONE_INT_8822B BIT(25)
+#define BIT_FS_TXSC_VODONE_INT_8822B BIT(24)
+#define BIT_FS_ATIM_MB7_INT_8822B BIT(23)
+#define BIT_FS_ATIM_MB6_INT_8822B BIT(22)
+#define BIT_FS_ATIM_MB5_INT_8822B BIT(21)
+#define BIT_FS_ATIM_MB4_INT_8822B BIT(20)
+#define BIT_FS_ATIM_MB3_INT_8822B BIT(19)
+#define BIT_FS_ATIM_MB2_INT_8822B BIT(18)
+#define BIT_FS_ATIM_MB1_INT_8822B BIT(17)
+#define BIT_FS_ATIM_MB0_INT_8822B BIT(16)
+#define BIT_FS_TBTT4INT_8822B BIT(11)
+#define BIT_FS_TBTT3INT_8822B BIT(10)
+#define BIT_FS_TBTT2INT_8822B BIT(9)
+#define BIT_FS_TBTT1INT_8822B BIT(8)
+#define BIT_FS_TBTT0_MB7INT_8822B BIT(7)
+#define BIT_FS_TBTT0_MB6INT_8822B BIT(6)
+#define BIT_FS_TBTT0_MB5INT_8822B BIT(5)
+#define BIT_FS_TBTT0_MB4INT_8822B BIT(4)
+#define BIT_FS_TBTT0_MB3INT_8822B BIT(3)
+#define BIT_FS_TBTT0_MB2INT_8822B BIT(2)
+#define BIT_FS_TBTT0_MB1INT_8822B BIT(1)
+#define BIT_FS_TBTT0_INT_8822B BIT(0)
+
+/* 2 REG_FE3IMR_8822B */
+#define BIT_FS_CLI3_MTI_BCNIVLEAR_INT__EN_8822B BIT(31)
+#define BIT_FS_CLI2_MTI_BCNIVLEAR_INT__EN_8822B BIT(30)
+#define BIT_FS_CLI1_MTI_BCNIVLEAR_INT__EN_8822B BIT(29)
+#define BIT_FS_CLI0_MTI_BCNIVLEAR_INT__EN_8822B BIT(28)
+#define BIT_FS_BCNDMA4_INT_EN_8822B BIT(27)
+#define BIT_FS_BCNDMA3_INT_EN_8822B BIT(26)
+#define BIT_FS_BCNDMA2_INT_EN_8822B BIT(25)
+#define BIT_FS_BCNDMA1_INT_EN_8822B BIT(24)
+#define BIT_FS_BCNDMA0_MB7_INT_EN_8822B BIT(23)
+#define BIT_FS_BCNDMA0_MB6_INT_EN_8822B BIT(22)
+#define BIT_FS_BCNDMA0_MB5_INT_EN_8822B BIT(21)
+#define BIT_FS_BCNDMA0_MB4_INT_EN_8822B BIT(20)
+#define BIT_FS_BCNDMA0_MB3_INT_EN_8822B BIT(19)
+#define BIT_FS_BCNDMA0_MB2_INT_EN_8822B BIT(18)
+#define BIT_FS_BCNDMA0_MB1_INT_EN_8822B BIT(17)
+#define BIT_FS_BCNDMA0_INT_EN_8822B BIT(16)
+#define BIT_FS_MTI_BCNIVLEAR_INT__EN_8822B BIT(15)
+#define BIT_FS_BCNERLY4_INT_EN_8822B BIT(11)
+#define BIT_FS_BCNERLY3_INT_EN_8822B BIT(10)
+#define BIT_FS_BCNERLY2_INT_EN_8822B BIT(9)
+#define BIT_FS_BCNERLY1_INT_EN_8822B BIT(8)
+#define BIT_FS_BCNERLY0_MB7INT_EN_8822B BIT(7)
+#define BIT_FS_BCNERLY0_MB6INT_EN_8822B BIT(6)
+#define BIT_FS_BCNERLY0_MB5INT_EN_8822B BIT(5)
+#define BIT_FS_BCNERLY0_MB4INT_EN_8822B BIT(4)
+#define BIT_FS_BCNERLY0_MB3INT_EN_8822B BIT(3)
+#define BIT_FS_BCNERLY0_MB2INT_EN_8822B BIT(2)
+#define BIT_FS_BCNERLY0_MB1INT_EN_8822B BIT(1)
+#define BIT_FS_BCNERLY0_INT_EN_8822B BIT(0)
+
+/* 2 REG_FE3ISR_8822B */
+#define BIT_FS_CLI3_MTI_BCNIVLEAR_INT_8822B BIT(31)
+#define BIT_FS_CLI2_MTI_BCNIVLEAR_INT_8822B BIT(30)
+#define BIT_FS_CLI1_MTI_BCNIVLEAR_INT_8822B BIT(29)
+#define BIT_FS_CLI0_MTI_BCNIVLEAR_INT_8822B BIT(28)
+#define BIT_FS_BCNDMA4_INT_8822B BIT(27)
+#define BIT_FS_BCNDMA3_INT_8822B BIT(26)
+#define BIT_FS_BCNDMA2_INT_8822B BIT(25)
+#define BIT_FS_BCNDMA1_INT_8822B BIT(24)
+#define BIT_FS_BCNDMA0_MB7_INT_8822B BIT(23)
+#define BIT_FS_BCNDMA0_MB6_INT_8822B BIT(22)
+#define BIT_FS_BCNDMA0_MB5_INT_8822B BIT(21)
+#define BIT_FS_BCNDMA0_MB4_INT_8822B BIT(20)
+#define BIT_FS_BCNDMA0_MB3_INT_8822B BIT(19)
+#define BIT_FS_BCNDMA0_MB2_INT_8822B BIT(18)
+#define BIT_FS_BCNDMA0_MB1_INT_8822B BIT(17)
+#define BIT_FS_BCNDMA0_INT_8822B BIT(16)
+#define BIT_FS_MTI_BCNIVLEAR_INT_8822B BIT(15)
+#define BIT_FS_BCNERLY4_INT_8822B BIT(11)
+#define BIT_FS_BCNERLY3_INT_8822B BIT(10)
+#define BIT_FS_BCNERLY2_INT_8822B BIT(9)
+#define BIT_FS_BCNERLY1_INT_8822B BIT(8)
+#define BIT_FS_BCNERLY0_MB7INT_8822B BIT(7)
+#define BIT_FS_BCNERLY0_MB6INT_8822B BIT(6)
+#define BIT_FS_BCNERLY0_MB5INT_8822B BIT(5)
+#define BIT_FS_BCNERLY0_MB4INT_8822B BIT(4)
+#define BIT_FS_BCNERLY0_MB3INT_8822B BIT(3)
+#define BIT_FS_BCNERLY0_MB2INT_8822B BIT(2)
+#define BIT_FS_BCNERLY0_MB1INT_8822B BIT(1)
+#define BIT_FS_BCNERLY0_INT_8822B BIT(0)
+
+/* 2 REG_FE4IMR_8822B */
+#define BIT_FS_CLI3_TXPKTIN_INT_EN_8822B BIT(19)
+#define BIT_FS_CLI2_TXPKTIN_INT_EN_8822B BIT(18)
+#define BIT_FS_CLI1_TXPKTIN_INT_EN_8822B BIT(17)
+#define BIT_FS_CLI0_TXPKTIN_INT_EN_8822B BIT(16)
+#define BIT_FS_CLI3_RX_UMD0_INT_EN_8822B BIT(15)
+#define BIT_FS_CLI3_RX_UMD1_INT_EN_8822B BIT(14)
+#define BIT_FS_CLI3_RX_BMD0_INT_EN_8822B BIT(13)
+#define BIT_FS_CLI3_RX_BMD1_INT_EN_8822B BIT(12)
+#define BIT_FS_CLI2_RX_UMD0_INT_EN_8822B BIT(11)
+#define BIT_FS_CLI2_RX_UMD1_INT_EN_8822B BIT(10)
+#define BIT_FS_CLI2_RX_BMD0_INT_EN_8822B BIT(9)
+#define BIT_FS_CLI2_RX_BMD1_INT_EN_8822B BIT(8)
+#define BIT_FS_CLI1_RX_UMD0_INT_EN_8822B BIT(7)
+#define BIT_FS_CLI1_RX_UMD1_INT_EN_8822B BIT(6)
+#define BIT_FS_CLI1_RX_BMD0_INT_EN_8822B BIT(5)
+#define BIT_FS_CLI1_RX_BMD1_INT_EN_8822B BIT(4)
+#define BIT_FS_CLI0_RX_UMD0_INT_EN_8822B BIT(3)
+#define BIT_FS_CLI0_RX_UMD1_INT_EN_8822B BIT(2)
+#define BIT_FS_CLI0_RX_BMD0_INT_EN_8822B BIT(1)
+#define BIT_FS_CLI0_RX_BMD1_INT_EN_8822B BIT(0)
+
+/* 2 REG_FE4ISR_8822B */
+#define BIT_FS_CLI3_TXPKTIN_INT_8822B BIT(19)
+#define BIT_FS_CLI2_TXPKTIN_INT_8822B BIT(18)
+#define BIT_FS_CLI1_TXPKTIN_INT_8822B BIT(17)
+#define BIT_FS_CLI0_TXPKTIN_INT_8822B BIT(16)
+#define BIT_FS_CLI3_RX_UMD0_INT_8822B BIT(15)
+#define BIT_FS_CLI3_RX_UMD1_INT_8822B BIT(14)
+#define BIT_FS_CLI3_RX_BMD0_INT_8822B BIT(13)
+#define BIT_FS_CLI3_RX_BMD1_INT_8822B BIT(12)
+#define BIT_FS_CLI2_RX_UMD0_INT_8822B BIT(11)
+#define BIT_FS_CLI2_RX_UMD1_INT_8822B BIT(10)
+#define BIT_FS_CLI2_RX_BMD0_INT_8822B BIT(9)
+#define BIT_FS_CLI2_RX_BMD1_INT_8822B BIT(8)
+#define BIT_FS_CLI1_RX_UMD0_INT_8822B BIT(7)
+#define BIT_FS_CLI1_RX_UMD1_INT_8822B BIT(6)
+#define BIT_FS_CLI1_RX_BMD0_INT_8822B BIT(5)
+#define BIT_FS_CLI1_RX_BMD1_INT_8822B BIT(4)
+#define BIT_FS_CLI0_RX_UMD0_INT_8822B BIT(3)
+#define BIT_FS_CLI0_RX_UMD1_INT_8822B BIT(2)
+#define BIT_FS_CLI0_RX_BMD0_INT_8822B BIT(1)
+#define BIT_FS_CLI0_RX_BMD1_INT_8822B BIT(0)
+
+/* 2 REG_FT1IMR_8822B */
+#define BIT__FT2ISR__IND_MSK_8822B BIT(30)
+#define BIT_FTM_PTT_INT_EN_8822B BIT(29)
+#define BIT_RXFTMREQ_INT_EN_8822B BIT(28)
+#define BIT_RXFTM_INT_EN_8822B BIT(27)
+#define BIT_TXFTM_INT_EN_8822B BIT(26)
+#define BIT_FS_H2C_CMD_OK_INT_EN_8822B BIT(25)
+#define BIT_FS_H2C_CMD_FULL_INT_EN_8822B BIT(24)
+#define BIT_FS_MACID_PWRCHANGE5_INT_EN_8822B BIT(23)
+#define BIT_FS_MACID_PWRCHANGE4_INT_EN_8822B BIT(22)
+#define BIT_FS_MACID_PWRCHANGE3_INT_EN_8822B BIT(21)
+#define BIT_FS_MACID_PWRCHANGE2_INT_EN_8822B BIT(20)
+#define BIT_FS_MACID_PWRCHANGE1_INT_EN_8822B BIT(19)
+#define BIT_FS_MACID_PWRCHANGE0_INT_EN_8822B BIT(18)
+#define BIT_FS_CTWEND2_INT_EN_8822B BIT(17)
+#define BIT_FS_CTWEND1_INT_EN_8822B BIT(16)
+#define BIT_FS_CTWEND0_INT_EN_8822B BIT(15)
+#define BIT_FS_TX_NULL1_INT_EN_8822B BIT(14)
+#define BIT_FS_TX_NULL0_INT_EN_8822B BIT(13)
+#define BIT_FS_TSF_BIT32_TOGGLE_EN_8822B BIT(12)
+#define BIT_FS_P2P_RFON2_INT_EN_8822B BIT(11)
+#define BIT_FS_P2P_RFOFF2_INT_EN_8822B BIT(10)
+#define BIT_FS_P2P_RFON1_INT_EN_8822B BIT(9)
+#define BIT_FS_P2P_RFOFF1_INT_EN_8822B BIT(8)
+#define BIT_FS_P2P_RFON0_INT_EN_8822B BIT(7)
+#define BIT_FS_P2P_RFOFF0_INT_EN_8822B BIT(6)
+#define BIT_FS_RX_UAPSDMD1_EN_8822B BIT(5)
+#define BIT_FS_RX_UAPSDMD0_EN_8822B BIT(4)
+#define BIT_FS_TRIGGER_PKT_EN_8822B BIT(3)
+#define BIT_FS_EOSP_INT_EN_8822B BIT(2)
+#define BIT_FS_RPWM2_INT_EN_8822B BIT(1)
+#define BIT_FS_RPWM_INT_EN_8822B BIT(0)
+
+/* 2 REG_FT1ISR_8822B */
+#define BIT__FT2ISR__IND_INT_8822B BIT(30)
+#define BIT_FTM_PTT_INT_8822B BIT(29)
+#define BIT_RXFTMREQ_INT_8822B BIT(28)
+#define BIT_RXFTM_INT_8822B BIT(27)
+#define BIT_TXFTM_INT_8822B BIT(26)
+#define BIT_FS_H2C_CMD_OK_INT_8822B BIT(25)
+#define BIT_FS_H2C_CMD_FULL_INT_8822B BIT(24)
+#define BIT_FS_MACID_PWRCHANGE5_INT_8822B BIT(23)
+#define BIT_FS_MACID_PWRCHANGE4_INT_8822B BIT(22)
+#define BIT_FS_MACID_PWRCHANGE3_INT_8822B BIT(21)
+#define BIT_FS_MACID_PWRCHANGE2_INT_8822B BIT(20)
+#define BIT_FS_MACID_PWRCHANGE1_INT_8822B BIT(19)
+#define BIT_FS_MACID_PWRCHANGE0_INT_8822B BIT(18)
+#define BIT_FS_CTWEND2_INT_8822B BIT(17)
+#define BIT_FS_CTWEND1_INT_8822B BIT(16)
+#define BIT_FS_CTWEND0_INT_8822B BIT(15)
+#define BIT_FS_TX_NULL1_INT_8822B BIT(14)
+#define BIT_FS_TX_NULL0_INT_8822B BIT(13)
+#define BIT_FS_TSF_BIT32_TOGGLE_INT_8822B BIT(12)
+#define BIT_FS_P2P_RFON2_INT_8822B BIT(11)
+#define BIT_FS_P2P_RFOFF2_INT_8822B BIT(10)
+#define BIT_FS_P2P_RFON1_INT_8822B BIT(9)
+#define BIT_FS_P2P_RFOFF1_INT_8822B BIT(8)
+#define BIT_FS_P2P_RFON0_INT_8822B BIT(7)
+#define BIT_FS_P2P_RFOFF0_INT_8822B BIT(6)
+#define BIT_FS_RX_UAPSDMD1_INT_8822B BIT(5)
+#define BIT_FS_RX_UAPSDMD0_INT_8822B BIT(4)
+#define BIT_FS_TRIGGER_PKT_INT_8822B BIT(3)
+#define BIT_FS_EOSP_INT_8822B BIT(2)
+#define BIT_FS_RPWM2_INT_8822B BIT(1)
+#define BIT_FS_RPWM_INT_8822B BIT(0)
+
+/* 2 REG_SPWR0_8822B */
+
+#define BIT_SHIFT_MID_31TO0_8822B 0
+#define BIT_MASK_MID_31TO0_8822B 0xffffffffL
+#define BIT_MID_31TO0_8822B(x)                                                 \
+	(((x) & BIT_MASK_MID_31TO0_8822B) << BIT_SHIFT_MID_31TO0_8822B)
+#define BIT_GET_MID_31TO0_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_MID_31TO0_8822B) & BIT_MASK_MID_31TO0_8822B)
+
+/* 2 REG_SPWR1_8822B */
+
+#define BIT_SHIFT_MID_63TO32_8822B 0
+#define BIT_MASK_MID_63TO32_8822B 0xffffffffL
+#define BIT_MID_63TO32_8822B(x)                                                \
+	(((x) & BIT_MASK_MID_63TO32_8822B) << BIT_SHIFT_MID_63TO32_8822B)
+#define BIT_GET_MID_63TO32_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_MID_63TO32_8822B) & BIT_MASK_MID_63TO32_8822B)
+
+/* 2 REG_SPWR2_8822B */
+
+#define BIT_SHIFT_MID_95O64_8822B 0
+#define BIT_MASK_MID_95O64_8822B 0xffffffffL
+#define BIT_MID_95O64_8822B(x)                                                 \
+	(((x) & BIT_MASK_MID_95O64_8822B) << BIT_SHIFT_MID_95O64_8822B)
+#define BIT_GET_MID_95O64_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_MID_95O64_8822B) & BIT_MASK_MID_95O64_8822B)
+
+/* 2 REG_SPWR3_8822B */
+
+#define BIT_SHIFT_MID_127TO96_8822B 0
+#define BIT_MASK_MID_127TO96_8822B 0xffffffffL
+#define BIT_MID_127TO96_8822B(x)                                               \
+	(((x) & BIT_MASK_MID_127TO96_8822B) << BIT_SHIFT_MID_127TO96_8822B)
+#define BIT_GET_MID_127TO96_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_MID_127TO96_8822B) & BIT_MASK_MID_127TO96_8822B)
+
+/* 2 REG_POWSEQ_8822B */
+
+#define BIT_SHIFT_SEQNUM_MID_8822B 16
+#define BIT_MASK_SEQNUM_MID_8822B 0xffff
+#define BIT_SEQNUM_MID_8822B(x)                                                \
+	(((x) & BIT_MASK_SEQNUM_MID_8822B) << BIT_SHIFT_SEQNUM_MID_8822B)
+#define BIT_GET_SEQNUM_MID_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_SEQNUM_MID_8822B) & BIT_MASK_SEQNUM_MID_8822B)
+
+#define BIT_SHIFT_REF_MID_8822B 0
+#define BIT_MASK_REF_MID_8822B 0x7f
+#define BIT_REF_MID_8822B(x)                                                   \
+	(((x) & BIT_MASK_REF_MID_8822B) << BIT_SHIFT_REF_MID_8822B)
+#define BIT_GET_REF_MID_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_REF_MID_8822B) & BIT_MASK_REF_MID_8822B)
+
+/* 2 REG_TC7_CTRL_V1_8822B */
+#define BIT_TC7INT_EN_8822B BIT(26)
+#define BIT_TC7MODE_8822B BIT(25)
+#define BIT_TC7EN_8822B BIT(24)
+
+#define BIT_SHIFT_TC7DATA_8822B 0
+#define BIT_MASK_TC7DATA_8822B 0xffffff
+#define BIT_TC7DATA_8822B(x)                                                   \
+	(((x) & BIT_MASK_TC7DATA_8822B) << BIT_SHIFT_TC7DATA_8822B)
+#define BIT_GET_TC7DATA_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_TC7DATA_8822B) & BIT_MASK_TC7DATA_8822B)
+
+/* 2 REG_TC8_CTRL_V1_8822B */
+#define BIT_TC8INT_EN_8822B BIT(26)
+#define BIT_TC8MODE_8822B BIT(25)
+#define BIT_TC8EN_8822B BIT(24)
+
+#define BIT_SHIFT_TC8DATA_8822B 0
+#define BIT_MASK_TC8DATA_8822B 0xffffff
+#define BIT_TC8DATA_8822B(x)                                                   \
+	(((x) & BIT_MASK_TC8DATA_8822B) << BIT_SHIFT_TC8DATA_8822B)
+#define BIT_GET_TC8DATA_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_TC8DATA_8822B) & BIT_MASK_TC8DATA_8822B)
+
+/* 2 REG_FT2IMR_8822B */
+#define BIT_FS_CLI3_RX_UAPSDMD1_EN_8822B BIT(31)
+#define BIT_FS_CLI3_RX_UAPSDMD0_EN_8822B BIT(30)
+#define BIT_FS_CLI3_TRIGGER_PKT_EN_8822B BIT(29)
+#define BIT_FS_CLI3_EOSP_INT_EN_8822B BIT(28)
+#define BIT_FS_CLI2_RX_UAPSDMD1_EN_8822B BIT(27)
+#define BIT_FS_CLI2_RX_UAPSDMD0_EN_8822B BIT(26)
+#define BIT_FS_CLI2_TRIGGER_PKT_EN_8822B BIT(25)
+#define BIT_FS_CLI2_EOSP_INT_EN_8822B BIT(24)
+#define BIT_FS_CLI1_RX_UAPSDMD1_EN_8822B BIT(23)
+#define BIT_FS_CLI1_RX_UAPSDMD0_EN_8822B BIT(22)
+#define BIT_FS_CLI1_TRIGGER_PKT_EN_8822B BIT(21)
+#define BIT_FS_CLI1_EOSP_INT_EN_8822B BIT(20)
+#define BIT_FS_CLI0_RX_UAPSDMD1_EN_8822B BIT(19)
+#define BIT_FS_CLI0_RX_UAPSDMD0_EN_8822B BIT(18)
+#define BIT_FS_CLI0_TRIGGER_PKT_EN_8822B BIT(17)
+#define BIT_FS_CLI0_EOSP_INT_EN_8822B BIT(16)
+#define BIT_FS_TSF_BIT32_TOGGLE_P2P2_EN_8822B BIT(9)
+#define BIT_FS_TSF_BIT32_TOGGLE_P2P1_EN_8822B BIT(8)
+#define BIT_FS_CLI3_TX_NULL1_INT_EN_8822B BIT(7)
+#define BIT_FS_CLI3_TX_NULL0_INT_EN_8822B BIT(6)
+#define BIT_FS_CLI2_TX_NULL1_INT_EN_8822B BIT(5)
+#define BIT_FS_CLI2_TX_NULL0_INT_EN_8822B BIT(4)
+#define BIT_FS_CLI1_TX_NULL1_INT_EN_8822B BIT(3)
+#define BIT_FS_CLI1_TX_NULL0_INT_EN_8822B BIT(2)
+#define BIT_FS_CLI0_TX_NULL1_INT_EN_8822B BIT(1)
+#define BIT_FS_CLI0_TX_NULL0_INT_EN_8822B BIT(0)
+
+/* 2 REG_FT2ISR_8822B */
+#define BIT_FS_CLI3_RX_UAPSDMD1_INT_8822B BIT(31)
+#define BIT_FS_CLI3_RX_UAPSDMD0_INT_8822B BIT(30)
+#define BIT_FS_CLI3_TRIGGER_PKT_INT_8822B BIT(29)
+#define BIT_FS_CLI3_EOSP_INT_8822B BIT(28)
+#define BIT_FS_CLI2_RX_UAPSDMD1_INT_8822B BIT(27)
+#define BIT_FS_CLI2_RX_UAPSDMD0_INT_8822B BIT(26)
+#define BIT_FS_CLI2_TRIGGER_PKT_INT_8822B BIT(25)
+#define BIT_FS_CLI2_EOSP_INT_8822B BIT(24)
+#define BIT_FS_CLI1_RX_UAPSDMD1_INT_8822B BIT(23)
+#define BIT_FS_CLI1_RX_UAPSDMD0_INT_8822B BIT(22)
+#define BIT_FS_CLI1_TRIGGER_PKT_INT_8822B BIT(21)
+#define BIT_FS_CLI1_EOSP_INT_8822B BIT(20)
+#define BIT_FS_CLI0_RX_UAPSDMD1_INT_8822B BIT(19)
+#define BIT_FS_CLI0_RX_UAPSDMD0_INT_8822B BIT(18)
+#define BIT_FS_CLI0_TRIGGER_PKT_INT_8822B BIT(17)
+#define BIT_FS_CLI0_EOSP_INT_8822B BIT(16)
+#define BIT_FS_TSF_BIT32_TOGGLE_P2P2_INT_8822B BIT(9)
+#define BIT_FS_TSF_BIT32_TOGGLE_P2P1_INT_8822B BIT(8)
+#define BIT_FS_CLI3_TX_NULL1_INT_8822B BIT(7)
+#define BIT_FS_CLI3_TX_NULL0_INT_8822B BIT(6)
+#define BIT_FS_CLI2_TX_NULL1_INT_8822B BIT(5)
+#define BIT_FS_CLI2_TX_NULL0_INT_8822B BIT(4)
+#define BIT_FS_CLI1_TX_NULL1_INT_8822B BIT(3)
+#define BIT_FS_CLI1_TX_NULL0_INT_8822B BIT(2)
+#define BIT_FS_CLI0_TX_NULL1_INT_8822B BIT(1)
+#define BIT_FS_CLI0_TX_NULL0_INT_8822B BIT(0)
+
+/* 2 REG_MSG2_8822B */
+
+#define BIT_SHIFT_FW_MSG2_8822B 0
+#define BIT_MASK_FW_MSG2_8822B 0xffffffffL
+#define BIT_FW_MSG2_8822B(x)                                                   \
+	(((x) & BIT_MASK_FW_MSG2_8822B) << BIT_SHIFT_FW_MSG2_8822B)
+#define BIT_GET_FW_MSG2_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_FW_MSG2_8822B) & BIT_MASK_FW_MSG2_8822B)
+
+/* 2 REG_MSG3_8822B */
+
+#define BIT_SHIFT_FW_MSG3_8822B 0
+#define BIT_MASK_FW_MSG3_8822B 0xffffffffL
+#define BIT_FW_MSG3_8822B(x)                                                   \
+	(((x) & BIT_MASK_FW_MSG3_8822B) << BIT_SHIFT_FW_MSG3_8822B)
+#define BIT_GET_FW_MSG3_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_FW_MSG3_8822B) & BIT_MASK_FW_MSG3_8822B)
+
+/* 2 REG_MSG4_8822B */
+
+#define BIT_SHIFT_FW_MSG4_8822B 0
+#define BIT_MASK_FW_MSG4_8822B 0xffffffffL
+#define BIT_FW_MSG4_8822B(x)                                                   \
+	(((x) & BIT_MASK_FW_MSG4_8822B) << BIT_SHIFT_FW_MSG4_8822B)
+#define BIT_GET_FW_MSG4_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_FW_MSG4_8822B) & BIT_MASK_FW_MSG4_8822B)
+
+/* 2 REG_MSG5_8822B */
+
+#define BIT_SHIFT_FW_MSG5_8822B 0
+#define BIT_MASK_FW_MSG5_8822B 0xffffffffL
+#define BIT_FW_MSG5_8822B(x)                                                   \
+	(((x) & BIT_MASK_FW_MSG5_8822B) << BIT_SHIFT_FW_MSG5_8822B)
+#define BIT_GET_FW_MSG5_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_FW_MSG5_8822B) & BIT_MASK_FW_MSG5_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_FIFOPAGE_CTRL_1_8822B */
+
+#define BIT_SHIFT_TX_OQT_HE_FREE_SPACE_V1_8822B 16
+#define BIT_MASK_TX_OQT_HE_FREE_SPACE_V1_8822B 0xff
+#define BIT_TX_OQT_HE_FREE_SPACE_V1_8822B(x)                                   \
+	(((x) & BIT_MASK_TX_OQT_HE_FREE_SPACE_V1_8822B)                        \
+	 << BIT_SHIFT_TX_OQT_HE_FREE_SPACE_V1_8822B)
+#define BIT_GET_TX_OQT_HE_FREE_SPACE_V1_8822B(x)                               \
+	(((x) >> BIT_SHIFT_TX_OQT_HE_FREE_SPACE_V1_8822B) &                    \
+	 BIT_MASK_TX_OQT_HE_FREE_SPACE_V1_8822B)
+
+#define BIT_SHIFT_TX_OQT_NL_FREE_SPACE_V1_8822B 0
+#define BIT_MASK_TX_OQT_NL_FREE_SPACE_V1_8822B 0xff
+#define BIT_TX_OQT_NL_FREE_SPACE_V1_8822B(x)                                   \
+	(((x) & BIT_MASK_TX_OQT_NL_FREE_SPACE_V1_8822B)                        \
+	 << BIT_SHIFT_TX_OQT_NL_FREE_SPACE_V1_8822B)
+#define BIT_GET_TX_OQT_NL_FREE_SPACE_V1_8822B(x)                               \
+	(((x) >> BIT_SHIFT_TX_OQT_NL_FREE_SPACE_V1_8822B) &                    \
+	 BIT_MASK_TX_OQT_NL_FREE_SPACE_V1_8822B)
+
+/* 2 REG_FIFOPAGE_CTRL_2_8822B */
+#define BIT_BCN_VALID_1_V1_8822B BIT(31)
+
+#define BIT_SHIFT_BCN_HEAD_1_V1_8822B 16
+#define BIT_MASK_BCN_HEAD_1_V1_8822B 0xfff
+#define BIT_BCN_HEAD_1_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_BCN_HEAD_1_V1_8822B) << BIT_SHIFT_BCN_HEAD_1_V1_8822B)
+#define BIT_GET_BCN_HEAD_1_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_BCN_HEAD_1_V1_8822B) & BIT_MASK_BCN_HEAD_1_V1_8822B)
+
+#define BIT_BCN_VALID_V1_8822B BIT(15)
+
+#define BIT_SHIFT_BCN_HEAD_V1_8822B 0
+#define BIT_MASK_BCN_HEAD_V1_8822B 0xfff
+#define BIT_BCN_HEAD_V1_8822B(x)                                               \
+	(((x) & BIT_MASK_BCN_HEAD_V1_8822B) << BIT_SHIFT_BCN_HEAD_V1_8822B)
+#define BIT_GET_BCN_HEAD_V1_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_BCN_HEAD_V1_8822B) & BIT_MASK_BCN_HEAD_V1_8822B)
+
+/* 2 REG_AUTO_LLT_V1_8822B */
+
+#define BIT_SHIFT_MAX_TX_PKT_FOR_USB_AND_SDIO_V1_8822B 24
+#define BIT_MASK_MAX_TX_PKT_FOR_USB_AND_SDIO_V1_8822B 0xff
+#define BIT_MAX_TX_PKT_FOR_USB_AND_SDIO_V1_8822B(x)                            \
+	(((x) & BIT_MASK_MAX_TX_PKT_FOR_USB_AND_SDIO_V1_8822B)                 \
+	 << BIT_SHIFT_MAX_TX_PKT_FOR_USB_AND_SDIO_V1_8822B)
+#define BIT_GET_MAX_TX_PKT_FOR_USB_AND_SDIO_V1_8822B(x)                        \
+	(((x) >> BIT_SHIFT_MAX_TX_PKT_FOR_USB_AND_SDIO_V1_8822B) &             \
+	 BIT_MASK_MAX_TX_PKT_FOR_USB_AND_SDIO_V1_8822B)
+
+#define BIT_SHIFT_LLT_FREE_PAGE_V1_8822B 8
+#define BIT_MASK_LLT_FREE_PAGE_V1_8822B 0xffff
+#define BIT_LLT_FREE_PAGE_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_LLT_FREE_PAGE_V1_8822B)                               \
+	 << BIT_SHIFT_LLT_FREE_PAGE_V1_8822B)
+#define BIT_GET_LLT_FREE_PAGE_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_LLT_FREE_PAGE_V1_8822B) &                           \
+	 BIT_MASK_LLT_FREE_PAGE_V1_8822B)
+
+#define BIT_SHIFT_BLK_DESC_NUM_8822B 4
+#define BIT_MASK_BLK_DESC_NUM_8822B 0xf
+#define BIT_BLK_DESC_NUM_8822B(x)                                              \
+	(((x) & BIT_MASK_BLK_DESC_NUM_8822B) << BIT_SHIFT_BLK_DESC_NUM_8822B)
+#define BIT_GET_BLK_DESC_NUM_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_BLK_DESC_NUM_8822B) & BIT_MASK_BLK_DESC_NUM_8822B)
+
+#define BIT_R_BCN_HEAD_SEL_8822B BIT(3)
+#define BIT_R_EN_BCN_SW_HEAD_SEL_8822B BIT(2)
+#define BIT_LLT_DBG_SEL_8822B BIT(1)
+#define BIT_AUTO_INIT_LLT_V1_8822B BIT(0)
+
+/* 2 REG_TXDMA_OFFSET_CHK_8822B */
+#define BIT_EM_CHKSUM_FIN_8822B BIT(31)
+#define BIT_EMN_PCIE_DMA_MOD_8822B BIT(30)
+#define BIT_EN_TXQUE_CLR_8822B BIT(29)
+#define BIT_EN_PCIE_FIFO_MODE_8822B BIT(28)
+
+#define BIT_SHIFT_PG_UNDER_TH_V1_8822B 16
+#define BIT_MASK_PG_UNDER_TH_V1_8822B 0xfff
+#define BIT_PG_UNDER_TH_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_PG_UNDER_TH_V1_8822B)                                 \
+	 << BIT_SHIFT_PG_UNDER_TH_V1_8822B)
+#define BIT_GET_PG_UNDER_TH_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_PG_UNDER_TH_V1_8822B) &                             \
+	 BIT_MASK_PG_UNDER_TH_V1_8822B)
+
+#define BIT_RESTORE_H2C_ADDRESS_8822B BIT(15)
+#define BIT_SDIO_TXDESC_CHKSUM_EN_8822B BIT(13)
+#define BIT_RST_RDPTR_8822B BIT(12)
+#define BIT_RST_WRPTR_8822B BIT(11)
+#define BIT_CHK_PG_TH_EN_8822B BIT(10)
+#define BIT_DROP_DATA_EN_8822B BIT(9)
+#define BIT_CHECK_OFFSET_EN_8822B BIT(8)
+
+#define BIT_SHIFT_CHECK_OFFSET_8822B 0
+#define BIT_MASK_CHECK_OFFSET_8822B 0xff
+#define BIT_CHECK_OFFSET_8822B(x)                                              \
+	(((x) & BIT_MASK_CHECK_OFFSET_8822B) << BIT_SHIFT_CHECK_OFFSET_8822B)
+#define BIT_GET_CHECK_OFFSET_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_CHECK_OFFSET_8822B) & BIT_MASK_CHECK_OFFSET_8822B)
+
+/* 2 REG_TXDMA_STATUS_8822B */
+#define BIT_HI_OQT_UDN_8822B BIT(17)
+#define BIT_HI_OQT_OVF_8822B BIT(16)
+#define BIT_PAYLOAD_CHKSUM_ERR_8822B BIT(15)
+#define BIT_PAYLOAD_UDN_8822B BIT(14)
+#define BIT_PAYLOAD_OVF_8822B BIT(13)
+#define BIT_DSC_CHKSUM_FAIL_8822B BIT(12)
+#define BIT_UNKNOWN_QSEL_8822B BIT(11)
+#define BIT_EP_QSEL_DIFF_8822B BIT(10)
+#define BIT_TX_OFFS_UNMATCH_8822B BIT(9)
+#define BIT_TXOQT_UDN_8822B BIT(8)
+#define BIT_TXOQT_OVF_8822B BIT(7)
+#define BIT_TXDMA_SFF_UDN_8822B BIT(6)
+#define BIT_TXDMA_SFF_OVF_8822B BIT(5)
+#define BIT_LLT_NULL_PG_8822B BIT(4)
+#define BIT_PAGE_UDN_8822B BIT(3)
+#define BIT_PAGE_OVF_8822B BIT(2)
+#define BIT_TXFF_PG_UDN_8822B BIT(1)
+#define BIT_TXFF_PG_OVF_8822B BIT(0)
+
+/* 2 REG_TX_DMA_DBG_8822B */
+
+/* 2 REG_TQPNT1_8822B */
+
+#define BIT_SHIFT_HPQ_HIGH_TH_V1_8822B 16
+#define BIT_MASK_HPQ_HIGH_TH_V1_8822B 0xfff
+#define BIT_HPQ_HIGH_TH_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_HPQ_HIGH_TH_V1_8822B)                                 \
+	 << BIT_SHIFT_HPQ_HIGH_TH_V1_8822B)
+#define BIT_GET_HPQ_HIGH_TH_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HPQ_HIGH_TH_V1_8822B) &                             \
+	 BIT_MASK_HPQ_HIGH_TH_V1_8822B)
+
+#define BIT_SHIFT_HPQ_LOW_TH_V1_8822B 0
+#define BIT_MASK_HPQ_LOW_TH_V1_8822B 0xfff
+#define BIT_HPQ_LOW_TH_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_HPQ_LOW_TH_V1_8822B) << BIT_SHIFT_HPQ_LOW_TH_V1_8822B)
+#define BIT_GET_HPQ_LOW_TH_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HPQ_LOW_TH_V1_8822B) & BIT_MASK_HPQ_LOW_TH_V1_8822B)
+
+/* 2 REG_TQPNT2_8822B */
+
+#define BIT_SHIFT_NPQ_HIGH_TH_V1_8822B 16
+#define BIT_MASK_NPQ_HIGH_TH_V1_8822B 0xfff
+#define BIT_NPQ_HIGH_TH_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_NPQ_HIGH_TH_V1_8822B)                                 \
+	 << BIT_SHIFT_NPQ_HIGH_TH_V1_8822B)
+#define BIT_GET_NPQ_HIGH_TH_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_NPQ_HIGH_TH_V1_8822B) &                             \
+	 BIT_MASK_NPQ_HIGH_TH_V1_8822B)
+
+#define BIT_SHIFT_NPQ_LOW_TH_V1_8822B 0
+#define BIT_MASK_NPQ_LOW_TH_V1_8822B 0xfff
+#define BIT_NPQ_LOW_TH_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_NPQ_LOW_TH_V1_8822B) << BIT_SHIFT_NPQ_LOW_TH_V1_8822B)
+#define BIT_GET_NPQ_LOW_TH_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_NPQ_LOW_TH_V1_8822B) & BIT_MASK_NPQ_LOW_TH_V1_8822B)
+
+/* 2 REG_TQPNT3_8822B */
+
+#define BIT_SHIFT_LPQ_HIGH_TH_V1_8822B 16
+#define BIT_MASK_LPQ_HIGH_TH_V1_8822B 0xfff
+#define BIT_LPQ_HIGH_TH_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_LPQ_HIGH_TH_V1_8822B)                                 \
+	 << BIT_SHIFT_LPQ_HIGH_TH_V1_8822B)
+#define BIT_GET_LPQ_HIGH_TH_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_LPQ_HIGH_TH_V1_8822B) &                             \
+	 BIT_MASK_LPQ_HIGH_TH_V1_8822B)
+
+#define BIT_SHIFT_LPQ_LOW_TH_V1_8822B 0
+#define BIT_MASK_LPQ_LOW_TH_V1_8822B 0xfff
+#define BIT_LPQ_LOW_TH_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_LPQ_LOW_TH_V1_8822B) << BIT_SHIFT_LPQ_LOW_TH_V1_8822B)
+#define BIT_GET_LPQ_LOW_TH_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_LPQ_LOW_TH_V1_8822B) & BIT_MASK_LPQ_LOW_TH_V1_8822B)
+
+/* 2 REG_TQPNT4_8822B */
+
+#define BIT_SHIFT_EXQ_HIGH_TH_V1_8822B 16
+#define BIT_MASK_EXQ_HIGH_TH_V1_8822B 0xfff
+#define BIT_EXQ_HIGH_TH_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_EXQ_HIGH_TH_V1_8822B)                                 \
+	 << BIT_SHIFT_EXQ_HIGH_TH_V1_8822B)
+#define BIT_GET_EXQ_HIGH_TH_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_EXQ_HIGH_TH_V1_8822B) &                             \
+	 BIT_MASK_EXQ_HIGH_TH_V1_8822B)
+
+#define BIT_SHIFT_EXQ_LOW_TH_V1_8822B 0
+#define BIT_MASK_EXQ_LOW_TH_V1_8822B 0xfff
+#define BIT_EXQ_LOW_TH_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_EXQ_LOW_TH_V1_8822B) << BIT_SHIFT_EXQ_LOW_TH_V1_8822B)
+#define BIT_GET_EXQ_LOW_TH_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_EXQ_LOW_TH_V1_8822B) & BIT_MASK_EXQ_LOW_TH_V1_8822B)
+
+/* 2 REG_RQPN_CTRL_1_8822B */
+
+#define BIT_SHIFT_TXPKTNUM_H_8822B 16
+#define BIT_MASK_TXPKTNUM_H_8822B 0xffff
+#define BIT_TXPKTNUM_H_8822B(x)                                                \
+	(((x) & BIT_MASK_TXPKTNUM_H_8822B) << BIT_SHIFT_TXPKTNUM_H_8822B)
+#define BIT_GET_TXPKTNUM_H_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_TXPKTNUM_H_8822B) & BIT_MASK_TXPKTNUM_H_8822B)
+
+#define BIT_SHIFT_TXPKTNUM_V2_8822B 0
+#define BIT_MASK_TXPKTNUM_V2_8822B 0xffff
+#define BIT_TXPKTNUM_V2_8822B(x)                                               \
+	(((x) & BIT_MASK_TXPKTNUM_V2_8822B) << BIT_SHIFT_TXPKTNUM_V2_8822B)
+#define BIT_GET_TXPKTNUM_V2_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_TXPKTNUM_V2_8822B) & BIT_MASK_TXPKTNUM_V2_8822B)
+
+/* 2 REG_RQPN_CTRL_2_8822B */
+#define BIT_LD_RQPN_8822B BIT(31)
+#define BIT_EXQ_PUBLIC_DIS_V1_8822B BIT(19)
+#define BIT_NPQ_PUBLIC_DIS_V1_8822B BIT(18)
+#define BIT_LPQ_PUBLIC_DIS_V1_8822B BIT(17)
+#define BIT_HPQ_PUBLIC_DIS_V1_8822B BIT(16)
+
+/* 2 REG_FIFOPAGE_INFO_1_8822B */
+
+#define BIT_SHIFT_HPQ_AVAL_PG_V1_8822B 16
+#define BIT_MASK_HPQ_AVAL_PG_V1_8822B 0xfff
+#define BIT_HPQ_AVAL_PG_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_HPQ_AVAL_PG_V1_8822B)                                 \
+	 << BIT_SHIFT_HPQ_AVAL_PG_V1_8822B)
+#define BIT_GET_HPQ_AVAL_PG_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HPQ_AVAL_PG_V1_8822B) &                             \
+	 BIT_MASK_HPQ_AVAL_PG_V1_8822B)
+
+#define BIT_SHIFT_HPQ_V1_8822B 0
+#define BIT_MASK_HPQ_V1_8822B 0xfff
+#define BIT_HPQ_V1_8822B(x)                                                    \
+	(((x) & BIT_MASK_HPQ_V1_8822B) << BIT_SHIFT_HPQ_V1_8822B)
+#define BIT_GET_HPQ_V1_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_HPQ_V1_8822B) & BIT_MASK_HPQ_V1_8822B)
+
+/* 2 REG_FIFOPAGE_INFO_2_8822B */
+
+#define BIT_SHIFT_LPQ_AVAL_PG_V1_8822B 16
+#define BIT_MASK_LPQ_AVAL_PG_V1_8822B 0xfff
+#define BIT_LPQ_AVAL_PG_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_LPQ_AVAL_PG_V1_8822B)                                 \
+	 << BIT_SHIFT_LPQ_AVAL_PG_V1_8822B)
+#define BIT_GET_LPQ_AVAL_PG_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_LPQ_AVAL_PG_V1_8822B) &                             \
+	 BIT_MASK_LPQ_AVAL_PG_V1_8822B)
+
+#define BIT_SHIFT_LPQ_V1_8822B 0
+#define BIT_MASK_LPQ_V1_8822B 0xfff
+#define BIT_LPQ_V1_8822B(x)                                                    \
+	(((x) & BIT_MASK_LPQ_V1_8822B) << BIT_SHIFT_LPQ_V1_8822B)
+#define BIT_GET_LPQ_V1_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_LPQ_V1_8822B) & BIT_MASK_LPQ_V1_8822B)
+
+/* 2 REG_FIFOPAGE_INFO_3_8822B */
+
+#define BIT_SHIFT_NPQ_AVAL_PG_V1_8822B 16
+#define BIT_MASK_NPQ_AVAL_PG_V1_8822B 0xfff
+#define BIT_NPQ_AVAL_PG_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_NPQ_AVAL_PG_V1_8822B)                                 \
+	 << BIT_SHIFT_NPQ_AVAL_PG_V1_8822B)
+#define BIT_GET_NPQ_AVAL_PG_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_NPQ_AVAL_PG_V1_8822B) &                             \
+	 BIT_MASK_NPQ_AVAL_PG_V1_8822B)
+
+#define BIT_SHIFT_NPQ_V1_8822B 0
+#define BIT_MASK_NPQ_V1_8822B 0xfff
+#define BIT_NPQ_V1_8822B(x)                                                    \
+	(((x) & BIT_MASK_NPQ_V1_8822B) << BIT_SHIFT_NPQ_V1_8822B)
+#define BIT_GET_NPQ_V1_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_NPQ_V1_8822B) & BIT_MASK_NPQ_V1_8822B)
+
+/* 2 REG_FIFOPAGE_INFO_4_8822B */
+
+#define BIT_SHIFT_EXQ_AVAL_PG_V1_8822B 16
+#define BIT_MASK_EXQ_AVAL_PG_V1_8822B 0xfff
+#define BIT_EXQ_AVAL_PG_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_EXQ_AVAL_PG_V1_8822B)                                 \
+	 << BIT_SHIFT_EXQ_AVAL_PG_V1_8822B)
+#define BIT_GET_EXQ_AVAL_PG_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_EXQ_AVAL_PG_V1_8822B) &                             \
+	 BIT_MASK_EXQ_AVAL_PG_V1_8822B)
+
+#define BIT_SHIFT_EXQ_V1_8822B 0
+#define BIT_MASK_EXQ_V1_8822B 0xfff
+#define BIT_EXQ_V1_8822B(x)                                                    \
+	(((x) & BIT_MASK_EXQ_V1_8822B) << BIT_SHIFT_EXQ_V1_8822B)
+#define BIT_GET_EXQ_V1_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_EXQ_V1_8822B) & BIT_MASK_EXQ_V1_8822B)
+
+/* 2 REG_FIFOPAGE_INFO_5_8822B */
+
+#define BIT_SHIFT_PUBQ_AVAL_PG_V1_8822B 16
+#define BIT_MASK_PUBQ_AVAL_PG_V1_8822B 0xfff
+#define BIT_PUBQ_AVAL_PG_V1_8822B(x)                                           \
+	(((x) & BIT_MASK_PUBQ_AVAL_PG_V1_8822B)                                \
+	 << BIT_SHIFT_PUBQ_AVAL_PG_V1_8822B)
+#define BIT_GET_PUBQ_AVAL_PG_V1_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_PUBQ_AVAL_PG_V1_8822B) &                            \
+	 BIT_MASK_PUBQ_AVAL_PG_V1_8822B)
+
+#define BIT_SHIFT_PUBQ_V1_8822B 0
+#define BIT_MASK_PUBQ_V1_8822B 0xfff
+#define BIT_PUBQ_V1_8822B(x)                                                   \
+	(((x) & BIT_MASK_PUBQ_V1_8822B) << BIT_SHIFT_PUBQ_V1_8822B)
+#define BIT_GET_PUBQ_V1_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_PUBQ_V1_8822B) & BIT_MASK_PUBQ_V1_8822B)
+
+/* 2 REG_H2C_HEAD_8822B */
+
+#define BIT_SHIFT_H2C_HEAD_8822B 0
+#define BIT_MASK_H2C_HEAD_8822B 0x3ffff
+#define BIT_H2C_HEAD_8822B(x)                                                  \
+	(((x) & BIT_MASK_H2C_HEAD_8822B) << BIT_SHIFT_H2C_HEAD_8822B)
+#define BIT_GET_H2C_HEAD_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_H2C_HEAD_8822B) & BIT_MASK_H2C_HEAD_8822B)
+
+/* 2 REG_H2C_TAIL_8822B */
+
+#define BIT_SHIFT_H2C_TAIL_8822B 0
+#define BIT_MASK_H2C_TAIL_8822B 0x3ffff
+#define BIT_H2C_TAIL_8822B(x)                                                  \
+	(((x) & BIT_MASK_H2C_TAIL_8822B) << BIT_SHIFT_H2C_TAIL_8822B)
+#define BIT_GET_H2C_TAIL_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_H2C_TAIL_8822B) & BIT_MASK_H2C_TAIL_8822B)
+
+/* 2 REG_H2C_READ_ADDR_8822B */
+
+#define BIT_SHIFT_H2C_READ_ADDR_8822B 0
+#define BIT_MASK_H2C_READ_ADDR_8822B 0x3ffff
+#define BIT_H2C_READ_ADDR_8822B(x)                                             \
+	(((x) & BIT_MASK_H2C_READ_ADDR_8822B) << BIT_SHIFT_H2C_READ_ADDR_8822B)
+#define BIT_GET_H2C_READ_ADDR_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_H2C_READ_ADDR_8822B) & BIT_MASK_H2C_READ_ADDR_8822B)
+
+/* 2 REG_H2C_WR_ADDR_8822B */
+
+#define BIT_SHIFT_H2C_WR_ADDR_8822B 0
+#define BIT_MASK_H2C_WR_ADDR_8822B 0x3ffff
+#define BIT_H2C_WR_ADDR_8822B(x)                                               \
+	(((x) & BIT_MASK_H2C_WR_ADDR_8822B) << BIT_SHIFT_H2C_WR_ADDR_8822B)
+#define BIT_GET_H2C_WR_ADDR_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_H2C_WR_ADDR_8822B) & BIT_MASK_H2C_WR_ADDR_8822B)
+
+/* 2 REG_H2C_INFO_8822B */
+#define BIT_H2C_SPACE_VLD_8822B BIT(3)
+#define BIT_H2C_WR_ADDR_RST_8822B BIT(2)
+
+#define BIT_SHIFT_H2C_LEN_SEL_8822B 0
+#define BIT_MASK_H2C_LEN_SEL_8822B 0x3
+#define BIT_H2C_LEN_SEL_8822B(x)                                               \
+	(((x) & BIT_MASK_H2C_LEN_SEL_8822B) << BIT_SHIFT_H2C_LEN_SEL_8822B)
+#define BIT_GET_H2C_LEN_SEL_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_H2C_LEN_SEL_8822B) & BIT_MASK_H2C_LEN_SEL_8822B)
+
+/* 2 REG_RXDMA_AGG_PG_TH_8822B */
+
+#define BIT_SHIFT_RXDMA_AGG_OLD_MOD_8822B 24
+#define BIT_MASK_RXDMA_AGG_OLD_MOD_8822B 0xff
+#define BIT_RXDMA_AGG_OLD_MOD_8822B(x)                                         \
+	(((x) & BIT_MASK_RXDMA_AGG_OLD_MOD_8822B)                              \
+	 << BIT_SHIFT_RXDMA_AGG_OLD_MOD_8822B)
+#define BIT_GET_RXDMA_AGG_OLD_MOD_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_RXDMA_AGG_OLD_MOD_8822B) &                          \
+	 BIT_MASK_RXDMA_AGG_OLD_MOD_8822B)
+
+#define BIT_SHIFT_PKT_NUM_WOL_8822B 16
+#define BIT_MASK_PKT_NUM_WOL_8822B 0xff
+#define BIT_PKT_NUM_WOL_8822B(x)                                               \
+	(((x) & BIT_MASK_PKT_NUM_WOL_8822B) << BIT_SHIFT_PKT_NUM_WOL_8822B)
+#define BIT_GET_PKT_NUM_WOL_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_PKT_NUM_WOL_8822B) & BIT_MASK_PKT_NUM_WOL_8822B)
+
+#define BIT_SHIFT_DMA_AGG_TO_8822B 8
+#define BIT_MASK_DMA_AGG_TO_8822B 0xf
+#define BIT_DMA_AGG_TO_8822B(x)                                                \
+	(((x) & BIT_MASK_DMA_AGG_TO_8822B) << BIT_SHIFT_DMA_AGG_TO_8822B)
+#define BIT_GET_DMA_AGG_TO_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_DMA_AGG_TO_8822B) & BIT_MASK_DMA_AGG_TO_8822B)
+
+#define BIT_SHIFT_RXDMA_AGG_PG_TH_V1_8822B 0
+#define BIT_MASK_RXDMA_AGG_PG_TH_V1_8822B 0xf
+#define BIT_RXDMA_AGG_PG_TH_V1_8822B(x)                                        \
+	(((x) & BIT_MASK_RXDMA_AGG_PG_TH_V1_8822B)                             \
+	 << BIT_SHIFT_RXDMA_AGG_PG_TH_V1_8822B)
+#define BIT_GET_RXDMA_AGG_PG_TH_V1_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_RXDMA_AGG_PG_TH_V1_8822B) &                         \
+	 BIT_MASK_RXDMA_AGG_PG_TH_V1_8822B)
+
+/* 2 REG_RXPKT_NUM_8822B */
+
+#define BIT_SHIFT_RXPKT_NUM_8822B 24
+#define BIT_MASK_RXPKT_NUM_8822B 0xff
+#define BIT_RXPKT_NUM_8822B(x)                                                 \
+	(((x) & BIT_MASK_RXPKT_NUM_8822B) << BIT_SHIFT_RXPKT_NUM_8822B)
+#define BIT_GET_RXPKT_NUM_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_RXPKT_NUM_8822B) & BIT_MASK_RXPKT_NUM_8822B)
+
+#define BIT_SHIFT_FW_UPD_RDPTR19_TO_16_8822B 20
+#define BIT_MASK_FW_UPD_RDPTR19_TO_16_8822B 0xf
+#define BIT_FW_UPD_RDPTR19_TO_16_8822B(x)                                      \
+	(((x) & BIT_MASK_FW_UPD_RDPTR19_TO_16_8822B)                           \
+	 << BIT_SHIFT_FW_UPD_RDPTR19_TO_16_8822B)
+#define BIT_GET_FW_UPD_RDPTR19_TO_16_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_FW_UPD_RDPTR19_TO_16_8822B) &                       \
+	 BIT_MASK_FW_UPD_RDPTR19_TO_16_8822B)
+
+#define BIT_RXDMA_REQ_8822B BIT(19)
+#define BIT_RW_RELEASE_EN_8822B BIT(18)
+#define BIT_RXDMA_IDLE_8822B BIT(17)
+#define BIT_RXPKT_RELEASE_POLL_8822B BIT(16)
+
+#define BIT_SHIFT_FW_UPD_RDPTR_8822B 0
+#define BIT_MASK_FW_UPD_RDPTR_8822B 0xffff
+#define BIT_FW_UPD_RDPTR_8822B(x)                                              \
+	(((x) & BIT_MASK_FW_UPD_RDPTR_8822B) << BIT_SHIFT_FW_UPD_RDPTR_8822B)
+#define BIT_GET_FW_UPD_RDPTR_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_FW_UPD_RDPTR_8822B) & BIT_MASK_FW_UPD_RDPTR_8822B)
+
+/* 2 REG_RXDMA_STATUS_8822B */
+#define BIT_C2H_PKT_OVF_8822B BIT(7)
+#define BIT_AGG_CONFGI_ISSUE_8822B BIT(6)
+#define BIT_FW_POLL_ISSUE_8822B BIT(5)
+#define BIT_RX_DATA_UDN_8822B BIT(4)
+#define BIT_RX_SFF_UDN_8822B BIT(3)
+#define BIT_RX_SFF_OVF_8822B BIT(2)
+#define BIT_RXPKT_OVF_8822B BIT(0)
+
+/* 2 REG_RXDMA_DPR_8822B */
+
+#define BIT_SHIFT_RDE_DEBUG_8822B 0
+#define BIT_MASK_RDE_DEBUG_8822B 0xffffffffL
+#define BIT_RDE_DEBUG_8822B(x)                                                 \
+	(((x) & BIT_MASK_RDE_DEBUG_8822B) << BIT_SHIFT_RDE_DEBUG_8822B)
+#define BIT_GET_RDE_DEBUG_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_RDE_DEBUG_8822B) & BIT_MASK_RDE_DEBUG_8822B)
+
+/* 2 REG_RXDMA_MODE_8822B */
+
+#define BIT_SHIFT_PKTNUM_TH_V2_8822B 24
+#define BIT_MASK_PKTNUM_TH_V2_8822B 0x1f
+#define BIT_PKTNUM_TH_V2_8822B(x)                                              \
+	(((x) & BIT_MASK_PKTNUM_TH_V2_8822B) << BIT_SHIFT_PKTNUM_TH_V2_8822B)
+#define BIT_GET_PKTNUM_TH_V2_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_PKTNUM_TH_V2_8822B) & BIT_MASK_PKTNUM_TH_V2_8822B)
+
+#define BIT_TXBA_BREAK_USBAGG_8822B BIT(23)
+
+#define BIT_SHIFT_PKTLEN_PARA_8822B 16
+#define BIT_MASK_PKTLEN_PARA_8822B 0x7
+#define BIT_PKTLEN_PARA_8822B(x)                                               \
+	(((x) & BIT_MASK_PKTLEN_PARA_8822B) << BIT_SHIFT_PKTLEN_PARA_8822B)
+#define BIT_GET_PKTLEN_PARA_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_PKTLEN_PARA_8822B) & BIT_MASK_PKTLEN_PARA_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_NOT_VALID_8822B */
+
+#define BIT_SHIFT_BURST_SIZE_8822B 4
+#define BIT_MASK_BURST_SIZE_8822B 0x3
+#define BIT_BURST_SIZE_8822B(x)                                                \
+	(((x) & BIT_MASK_BURST_SIZE_8822B) << BIT_SHIFT_BURST_SIZE_8822B)
+#define BIT_GET_BURST_SIZE_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_BURST_SIZE_8822B) & BIT_MASK_BURST_SIZE_8822B)
+
+#define BIT_SHIFT_BURST_CNT_8822B 2
+#define BIT_MASK_BURST_CNT_8822B 0x3
+#define BIT_BURST_CNT_8822B(x)                                                 \
+	(((x) & BIT_MASK_BURST_CNT_8822B) << BIT_SHIFT_BURST_CNT_8822B)
+#define BIT_GET_BURST_CNT_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_BURST_CNT_8822B) & BIT_MASK_BURST_CNT_8822B)
+
+#define BIT_DMA_MODE_8822B BIT(1)
+
+/* 2 REG_C2H_PKT_8822B */
+
+#define BIT_SHIFT_R_C2H_STR_ADDR_16_TO_19_8822B 24
+#define BIT_MASK_R_C2H_STR_ADDR_16_TO_19_8822B 0xf
+#define BIT_R_C2H_STR_ADDR_16_TO_19_8822B(x)                                   \
+	(((x) & BIT_MASK_R_C2H_STR_ADDR_16_TO_19_8822B)                        \
+	 << BIT_SHIFT_R_C2H_STR_ADDR_16_TO_19_8822B)
+#define BIT_GET_R_C2H_STR_ADDR_16_TO_19_8822B(x)                               \
+	(((x) >> BIT_SHIFT_R_C2H_STR_ADDR_16_TO_19_8822B) &                    \
+	 BIT_MASK_R_C2H_STR_ADDR_16_TO_19_8822B)
+
+#define BIT_R_C2H_PKT_REQ_8822B BIT(16)
+
+#define BIT_SHIFT_R_C2H_STR_ADDR_8822B 0
+#define BIT_MASK_R_C2H_STR_ADDR_8822B 0xffff
+#define BIT_R_C2H_STR_ADDR_8822B(x)                                            \
+	(((x) & BIT_MASK_R_C2H_STR_ADDR_8822B)                                 \
+	 << BIT_SHIFT_R_C2H_STR_ADDR_8822B)
+#define BIT_GET_R_C2H_STR_ADDR_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_R_C2H_STR_ADDR_8822B) &                             \
+	 BIT_MASK_R_C2H_STR_ADDR_8822B)
+
+/* 2 REG_FWFF_C2H_8822B */
+
+#define BIT_SHIFT_C2H_DMA_ADDR_8822B 0
+#define BIT_MASK_C2H_DMA_ADDR_8822B 0x3ffff
+#define BIT_C2H_DMA_ADDR_8822B(x)                                              \
+	(((x) & BIT_MASK_C2H_DMA_ADDR_8822B) << BIT_SHIFT_C2H_DMA_ADDR_8822B)
+#define BIT_GET_C2H_DMA_ADDR_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_C2H_DMA_ADDR_8822B) & BIT_MASK_C2H_DMA_ADDR_8822B)
+
+/* 2 REG_FWFF_CTRL_8822B */
+#define BIT_FWFF_DMAPKT_REQ_8822B BIT(31)
+
+#define BIT_SHIFT_FWFF_DMA_PKT_NUM_8822B 16
+#define BIT_MASK_FWFF_DMA_PKT_NUM_8822B 0xff
+#define BIT_FWFF_DMA_PKT_NUM_8822B(x)                                          \
+	(((x) & BIT_MASK_FWFF_DMA_PKT_NUM_8822B)                               \
+	 << BIT_SHIFT_FWFF_DMA_PKT_NUM_8822B)
+#define BIT_GET_FWFF_DMA_PKT_NUM_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_FWFF_DMA_PKT_NUM_8822B) &                           \
+	 BIT_MASK_FWFF_DMA_PKT_NUM_8822B)
+
+#define BIT_SHIFT_FWFF_STR_ADDR_8822B 0
+#define BIT_MASK_FWFF_STR_ADDR_8822B 0xffff
+#define BIT_FWFF_STR_ADDR_8822B(x)                                             \
+	(((x) & BIT_MASK_FWFF_STR_ADDR_8822B) << BIT_SHIFT_FWFF_STR_ADDR_8822B)
+#define BIT_GET_FWFF_STR_ADDR_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_FWFF_STR_ADDR_8822B) & BIT_MASK_FWFF_STR_ADDR_8822B)
+
+/* 2 REG_FWFF_PKT_INFO_8822B */
+
+#define BIT_SHIFT_FWFF_PKT_QUEUED_8822B 16
+#define BIT_MASK_FWFF_PKT_QUEUED_8822B 0xff
+#define BIT_FWFF_PKT_QUEUED_8822B(x)                                           \
+	(((x) & BIT_MASK_FWFF_PKT_QUEUED_8822B)                                \
+	 << BIT_SHIFT_FWFF_PKT_QUEUED_8822B)
+#define BIT_GET_FWFF_PKT_QUEUED_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_FWFF_PKT_QUEUED_8822B) &                            \
+	 BIT_MASK_FWFF_PKT_QUEUED_8822B)
+
+#define BIT_SHIFT_FWFF_PKT_STR_ADDR_8822B 0
+#define BIT_MASK_FWFF_PKT_STR_ADDR_8822B 0xffff
+#define BIT_FWFF_PKT_STR_ADDR_8822B(x)                                         \
+	(((x) & BIT_MASK_FWFF_PKT_STR_ADDR_8822B)                              \
+	 << BIT_SHIFT_FWFF_PKT_STR_ADDR_8822B)
+#define BIT_GET_FWFF_PKT_STR_ADDR_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_FWFF_PKT_STR_ADDR_8822B) &                          \
+	 BIT_MASK_FWFF_PKT_STR_ADDR_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_DDMA_CH0SA_8822B */
+
+#define BIT_SHIFT_DDMACH0_SA_8822B 0
+#define BIT_MASK_DDMACH0_SA_8822B 0xffffffffL
+#define BIT_DDMACH0_SA_8822B(x)                                                \
+	(((x) & BIT_MASK_DDMACH0_SA_8822B) << BIT_SHIFT_DDMACH0_SA_8822B)
+#define BIT_GET_DDMACH0_SA_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_DDMACH0_SA_8822B) & BIT_MASK_DDMACH0_SA_8822B)
+
+/* 2 REG_DDMA_CH0DA_8822B */
+
+#define BIT_SHIFT_DDMACH0_DA_8822B 0
+#define BIT_MASK_DDMACH0_DA_8822B 0xffffffffL
+#define BIT_DDMACH0_DA_8822B(x)                                                \
+	(((x) & BIT_MASK_DDMACH0_DA_8822B) << BIT_SHIFT_DDMACH0_DA_8822B)
+#define BIT_GET_DDMACH0_DA_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_DDMACH0_DA_8822B) & BIT_MASK_DDMACH0_DA_8822B)
+
+/* 2 REG_DDMA_CH0CTRL_8822B */
+#define BIT_DDMACH0_OWN_8822B BIT(31)
+#define BIT_DDMACH0_CHKSUM_EN_8822B BIT(29)
+#define BIT_DDMACH0_DA_W_DISABLE_8822B BIT(28)
+#define BIT_DDMACH0_CHKSUM_STS_8822B BIT(27)
+#define BIT_DDMACH0_DDMA_MODE_8822B BIT(26)
+#define BIT_DDMACH0_RESET_CHKSUM_STS_8822B BIT(25)
+#define BIT_DDMACH0_CHKSUM_CONT_8822B BIT(24)
+
+#define BIT_SHIFT_DDMACH0_DLEN_8822B 0
+#define BIT_MASK_DDMACH0_DLEN_8822B 0x3ffff
+#define BIT_DDMACH0_DLEN_8822B(x)                                              \
+	(((x) & BIT_MASK_DDMACH0_DLEN_8822B) << BIT_SHIFT_DDMACH0_DLEN_8822B)
+#define BIT_GET_DDMACH0_DLEN_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_DDMACH0_DLEN_8822B) & BIT_MASK_DDMACH0_DLEN_8822B)
+
+/* 2 REG_DDMA_CH1SA_8822B */
+
+#define BIT_SHIFT_DDMACH1_SA_8822B 0
+#define BIT_MASK_DDMACH1_SA_8822B 0xffffffffL
+#define BIT_DDMACH1_SA_8822B(x)                                                \
+	(((x) & BIT_MASK_DDMACH1_SA_8822B) << BIT_SHIFT_DDMACH1_SA_8822B)
+#define BIT_GET_DDMACH1_SA_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_DDMACH1_SA_8822B) & BIT_MASK_DDMACH1_SA_8822B)
+
+/* 2 REG_DDMA_CH1DA_8822B */
+
+#define BIT_SHIFT_DDMACH1_DA_8822B 0
+#define BIT_MASK_DDMACH1_DA_8822B 0xffffffffL
+#define BIT_DDMACH1_DA_8822B(x)                                                \
+	(((x) & BIT_MASK_DDMACH1_DA_8822B) << BIT_SHIFT_DDMACH1_DA_8822B)
+#define BIT_GET_DDMACH1_DA_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_DDMACH1_DA_8822B) & BIT_MASK_DDMACH1_DA_8822B)
+
+/* 2 REG_DDMA_CH1CTRL_8822B */
+#define BIT_DDMACH1_OWN_8822B BIT(31)
+#define BIT_DDMACH1_CHKSUM_EN_8822B BIT(29)
+#define BIT_DDMACH1_DA_W_DISABLE_8822B BIT(28)
+#define BIT_DDMACH1_CHKSUM_STS_8822B BIT(27)
+#define BIT_DDMACH1_DDMA_MODE_8822B BIT(26)
+#define BIT_DDMACH1_RESET_CHKSUM_STS_8822B BIT(25)
+#define BIT_DDMACH1_CHKSUM_CONT_8822B BIT(24)
+
+#define BIT_SHIFT_DDMACH1_DLEN_8822B 0
+#define BIT_MASK_DDMACH1_DLEN_8822B 0x3ffff
+#define BIT_DDMACH1_DLEN_8822B(x)                                              \
+	(((x) & BIT_MASK_DDMACH1_DLEN_8822B) << BIT_SHIFT_DDMACH1_DLEN_8822B)
+#define BIT_GET_DDMACH1_DLEN_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_DDMACH1_DLEN_8822B) & BIT_MASK_DDMACH1_DLEN_8822B)
+
+/* 2 REG_DDMA_CH2SA_8822B */
+
+#define BIT_SHIFT_DDMACH2_SA_8822B 0
+#define BIT_MASK_DDMACH2_SA_8822B 0xffffffffL
+#define BIT_DDMACH2_SA_8822B(x)                                                \
+	(((x) & BIT_MASK_DDMACH2_SA_8822B) << BIT_SHIFT_DDMACH2_SA_8822B)
+#define BIT_GET_DDMACH2_SA_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_DDMACH2_SA_8822B) & BIT_MASK_DDMACH2_SA_8822B)
+
+/* 2 REG_DDMA_CH2DA_8822B */
+
+#define BIT_SHIFT_DDMACH2_DA_8822B 0
+#define BIT_MASK_DDMACH2_DA_8822B 0xffffffffL
+#define BIT_DDMACH2_DA_8822B(x)                                                \
+	(((x) & BIT_MASK_DDMACH2_DA_8822B) << BIT_SHIFT_DDMACH2_DA_8822B)
+#define BIT_GET_DDMACH2_DA_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_DDMACH2_DA_8822B) & BIT_MASK_DDMACH2_DA_8822B)
+
+/* 2 REG_DDMA_CH2CTRL_8822B */
+#define BIT_DDMACH2_OWN_8822B BIT(31)
+#define BIT_DDMACH2_CHKSUM_EN_8822B BIT(29)
+#define BIT_DDMACH2_DA_W_DISABLE_8822B BIT(28)
+#define BIT_DDMACH2_CHKSUM_STS_8822B BIT(27)
+#define BIT_DDMACH2_DDMA_MODE_8822B BIT(26)
+#define BIT_DDMACH2_RESET_CHKSUM_STS_8822B BIT(25)
+#define BIT_DDMACH2_CHKSUM_CONT_8822B BIT(24)
+
+#define BIT_SHIFT_DDMACH2_DLEN_8822B 0
+#define BIT_MASK_DDMACH2_DLEN_8822B 0x3ffff
+#define BIT_DDMACH2_DLEN_8822B(x)                                              \
+	(((x) & BIT_MASK_DDMACH2_DLEN_8822B) << BIT_SHIFT_DDMACH2_DLEN_8822B)
+#define BIT_GET_DDMACH2_DLEN_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_DDMACH2_DLEN_8822B) & BIT_MASK_DDMACH2_DLEN_8822B)
+
+/* 2 REG_DDMA_CH3SA_8822B */
+
+#define BIT_SHIFT_DDMACH3_SA_8822B 0
+#define BIT_MASK_DDMACH3_SA_8822B 0xffffffffL
+#define BIT_DDMACH3_SA_8822B(x)                                                \
+	(((x) & BIT_MASK_DDMACH3_SA_8822B) << BIT_SHIFT_DDMACH3_SA_8822B)
+#define BIT_GET_DDMACH3_SA_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_DDMACH3_SA_8822B) & BIT_MASK_DDMACH3_SA_8822B)
+
+/* 2 REG_DDMA_CH3DA_8822B */
+
+#define BIT_SHIFT_DDMACH3_DA_8822B 0
+#define BIT_MASK_DDMACH3_DA_8822B 0xffffffffL
+#define BIT_DDMACH3_DA_8822B(x)                                                \
+	(((x) & BIT_MASK_DDMACH3_DA_8822B) << BIT_SHIFT_DDMACH3_DA_8822B)
+#define BIT_GET_DDMACH3_DA_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_DDMACH3_DA_8822B) & BIT_MASK_DDMACH3_DA_8822B)
+
+/* 2 REG_DDMA_CH3CTRL_8822B */
+#define BIT_DDMACH3_OWN_8822B BIT(31)
+#define BIT_DDMACH3_CHKSUM_EN_8822B BIT(29)
+#define BIT_DDMACH3_DA_W_DISABLE_8822B BIT(28)
+#define BIT_DDMACH3_CHKSUM_STS_8822B BIT(27)
+#define BIT_DDMACH3_DDMA_MODE_8822B BIT(26)
+#define BIT_DDMACH3_RESET_CHKSUM_STS_8822B BIT(25)
+#define BIT_DDMACH3_CHKSUM_CONT_8822B BIT(24)
+
+#define BIT_SHIFT_DDMACH3_DLEN_8822B 0
+#define BIT_MASK_DDMACH3_DLEN_8822B 0x3ffff
+#define BIT_DDMACH3_DLEN_8822B(x)                                              \
+	(((x) & BIT_MASK_DDMACH3_DLEN_8822B) << BIT_SHIFT_DDMACH3_DLEN_8822B)
+#define BIT_GET_DDMACH3_DLEN_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_DDMACH3_DLEN_8822B) & BIT_MASK_DDMACH3_DLEN_8822B)
+
+/* 2 REG_DDMA_CH4SA_8822B */
+
+#define BIT_SHIFT_DDMACH4_SA_8822B 0
+#define BIT_MASK_DDMACH4_SA_8822B 0xffffffffL
+#define BIT_DDMACH4_SA_8822B(x)                                                \
+	(((x) & BIT_MASK_DDMACH4_SA_8822B) << BIT_SHIFT_DDMACH4_SA_8822B)
+#define BIT_GET_DDMACH4_SA_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_DDMACH4_SA_8822B) & BIT_MASK_DDMACH4_SA_8822B)
+
+/* 2 REG_DDMA_CH4DA_8822B */
+
+#define BIT_SHIFT_DDMACH4_DA_8822B 0
+#define BIT_MASK_DDMACH4_DA_8822B 0xffffffffL
+#define BIT_DDMACH4_DA_8822B(x)                                                \
+	(((x) & BIT_MASK_DDMACH4_DA_8822B) << BIT_SHIFT_DDMACH4_DA_8822B)
+#define BIT_GET_DDMACH4_DA_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_DDMACH4_DA_8822B) & BIT_MASK_DDMACH4_DA_8822B)
+
+/* 2 REG_DDMA_CH4CTRL_8822B */
+#define BIT_DDMACH4_OWN_8822B BIT(31)
+#define BIT_DDMACH4_CHKSUM_EN_8822B BIT(29)
+#define BIT_DDMACH4_DA_W_DISABLE_8822B BIT(28)
+#define BIT_DDMACH4_CHKSUM_STS_8822B BIT(27)
+#define BIT_DDMACH4_DDMA_MODE_8822B BIT(26)
+#define BIT_DDMACH4_RESET_CHKSUM_STS_8822B BIT(25)
+#define BIT_DDMACH4_CHKSUM_CONT_8822B BIT(24)
+
+#define BIT_SHIFT_DDMACH4_DLEN_8822B 0
+#define BIT_MASK_DDMACH4_DLEN_8822B 0x3ffff
+#define BIT_DDMACH4_DLEN_8822B(x)                                              \
+	(((x) & BIT_MASK_DDMACH4_DLEN_8822B) << BIT_SHIFT_DDMACH4_DLEN_8822B)
+#define BIT_GET_DDMACH4_DLEN_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_DDMACH4_DLEN_8822B) & BIT_MASK_DDMACH4_DLEN_8822B)
+
+/* 2 REG_DDMA_CH5SA_8822B */
+
+#define BIT_SHIFT_DDMACH5_SA_8822B 0
+#define BIT_MASK_DDMACH5_SA_8822B 0xffffffffL
+#define BIT_DDMACH5_SA_8822B(x)                                                \
+	(((x) & BIT_MASK_DDMACH5_SA_8822B) << BIT_SHIFT_DDMACH5_SA_8822B)
+#define BIT_GET_DDMACH5_SA_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_DDMACH5_SA_8822B) & BIT_MASK_DDMACH5_SA_8822B)
+
+/* 2 REG_DDMA_CH5DA_8822B */
+
+#define BIT_SHIFT_DDMACH5_DA_8822B 0
+#define BIT_MASK_DDMACH5_DA_8822B 0xffffffffL
+#define BIT_DDMACH5_DA_8822B(x)                                                \
+	(((x) & BIT_MASK_DDMACH5_DA_8822B) << BIT_SHIFT_DDMACH5_DA_8822B)
+#define BIT_GET_DDMACH5_DA_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_DDMACH5_DA_8822B) & BIT_MASK_DDMACH5_DA_8822B)
+
+/* 2 REG_REG_DDMA_CH5CTRL_8822B */
+#define BIT_DDMACH5_OWN_8822B BIT(31)
+#define BIT_DDMACH5_CHKSUM_EN_8822B BIT(29)
+#define BIT_DDMACH5_DA_W_DISABLE_8822B BIT(28)
+#define BIT_DDMACH5_CHKSUM_STS_8822B BIT(27)
+#define BIT_DDMACH5_DDMA_MODE_8822B BIT(26)
+#define BIT_DDMACH5_RESET_CHKSUM_STS_8822B BIT(25)
+#define BIT_DDMACH5_CHKSUM_CONT_8822B BIT(24)
+
+#define BIT_SHIFT_DDMACH5_DLEN_8822B 0
+#define BIT_MASK_DDMACH5_DLEN_8822B 0x3ffff
+#define BIT_DDMACH5_DLEN_8822B(x)                                              \
+	(((x) & BIT_MASK_DDMACH5_DLEN_8822B) << BIT_SHIFT_DDMACH5_DLEN_8822B)
+#define BIT_GET_DDMACH5_DLEN_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_DDMACH5_DLEN_8822B) & BIT_MASK_DDMACH5_DLEN_8822B)
+
+/* 2 REG_DDMA_INT_MSK_8822B */
+#define BIT_DDMACH5_MSK_8822B BIT(5)
+#define BIT_DDMACH4_MSK_8822B BIT(4)
+#define BIT_DDMACH3_MSK_8822B BIT(3)
+#define BIT_DDMACH2_MSK_8822B BIT(2)
+#define BIT_DDMACH1_MSK_8822B BIT(1)
+#define BIT_DDMACH0_MSK_8822B BIT(0)
+
+/* 2 REG_DDMA_CHSTATUS_8822B */
+#define BIT_DDMACH5_BUSY_8822B BIT(5)
+#define BIT_DDMACH4_BUSY_8822B BIT(4)
+#define BIT_DDMACH3_BUSY_8822B BIT(3)
+#define BIT_DDMACH2_BUSY_8822B BIT(2)
+#define BIT_DDMACH1_BUSY_8822B BIT(1)
+#define BIT_DDMACH0_BUSY_8822B BIT(0)
+
+/* 2 REG_DDMA_CHKSUM_8822B */
+
+#define BIT_SHIFT_IDDMA0_CHKSUM_8822B 0
+#define BIT_MASK_IDDMA0_CHKSUM_8822B 0xffff
+#define BIT_IDDMA0_CHKSUM_8822B(x)                                             \
+	(((x) & BIT_MASK_IDDMA0_CHKSUM_8822B) << BIT_SHIFT_IDDMA0_CHKSUM_8822B)
+#define BIT_GET_IDDMA0_CHKSUM_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_IDDMA0_CHKSUM_8822B) & BIT_MASK_IDDMA0_CHKSUM_8822B)
+
+/* 2 REG_DDMA_MONITOR_8822B */
+#define BIT_IDDMA0_PERMU_UNDERFLOW_8822B BIT(14)
+#define BIT_IDDMA0_FIFO_UNDERFLOW_8822B BIT(13)
+#define BIT_IDDMA0_FIFO_OVERFLOW_8822B BIT(12)
+#define BIT_CH5_ERR_8822B BIT(5)
+#define BIT_CH4_ERR_8822B BIT(4)
+#define BIT_CH3_ERR_8822B BIT(3)
+#define BIT_CH2_ERR_8822B BIT(2)
+#define BIT_CH1_ERR_8822B BIT(1)
+#define BIT_CH0_ERR_8822B BIT(0)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_PCIE_CTRL_8822B */
+#define BIT_PCIEIO_PERSTB_SEL_8822B BIT(31)
+
+#define BIT_SHIFT_PCIE_MAX_RXDMA_8822B 28
+#define BIT_MASK_PCIE_MAX_RXDMA_8822B 0x7
+#define BIT_PCIE_MAX_RXDMA_8822B(x)                                            \
+	(((x) & BIT_MASK_PCIE_MAX_RXDMA_8822B)                                 \
+	 << BIT_SHIFT_PCIE_MAX_RXDMA_8822B)
+#define BIT_GET_PCIE_MAX_RXDMA_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_PCIE_MAX_RXDMA_8822B) &                             \
+	 BIT_MASK_PCIE_MAX_RXDMA_8822B)
+
+#define BIT_MULRW_8822B BIT(27)
+
+#define BIT_SHIFT_PCIE_MAX_TXDMA_8822B 24
+#define BIT_MASK_PCIE_MAX_TXDMA_8822B 0x7
+#define BIT_PCIE_MAX_TXDMA_8822B(x)                                            \
+	(((x) & BIT_MASK_PCIE_MAX_TXDMA_8822B)                                 \
+	 << BIT_SHIFT_PCIE_MAX_TXDMA_8822B)
+#define BIT_GET_PCIE_MAX_TXDMA_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_PCIE_MAX_TXDMA_8822B) &                             \
+	 BIT_MASK_PCIE_MAX_TXDMA_8822B)
+
+#define BIT_EN_CPL_TIMEOUT_PS_8822B BIT(22)
+#define BIT_REG_TXDMA_FAIL_PS_8822B BIT(21)
+#define BIT_PCIE_RST_TRXDMA_INTF_8822B BIT(20)
+#define BIT_EN_HWENTR_L1_8822B BIT(19)
+#define BIT_EN_ADV_CLKGATE_8822B BIT(18)
+#define BIT_PCIE_EN_SWENT_L23_8822B BIT(17)
+#define BIT_PCIE_EN_HWEXT_L1_8822B BIT(16)
+#define BIT_RX_CLOSE_EN_8822B BIT(15)
+#define BIT_STOP_BCNQ_8822B BIT(14)
+#define BIT_STOP_MGQ_8822B BIT(13)
+#define BIT_STOP_VOQ_8822B BIT(12)
+#define BIT_STOP_VIQ_8822B BIT(11)
+#define BIT_STOP_BEQ_8822B BIT(10)
+#define BIT_STOP_BKQ_8822B BIT(9)
+#define BIT_STOP_RXQ_8822B BIT(8)
+#define BIT_STOP_HI7Q_8822B BIT(7)
+#define BIT_STOP_HI6Q_8822B BIT(6)
+#define BIT_STOP_HI5Q_8822B BIT(5)
+#define BIT_STOP_HI4Q_8822B BIT(4)
+#define BIT_STOP_HI3Q_8822B BIT(3)
+#define BIT_STOP_HI2Q_8822B BIT(2)
+#define BIT_STOP_HI1Q_8822B BIT(1)
+#define BIT_STOP_HI0Q_8822B BIT(0)
+
+/* 2 REG_INT_MIG_8822B */
+
+#define BIT_SHIFT_TXTTIMER_MATCH_NUM_8822B 28
+#define BIT_MASK_TXTTIMER_MATCH_NUM_8822B 0xf
+#define BIT_TXTTIMER_MATCH_NUM_8822B(x)                                        \
+	(((x) & BIT_MASK_TXTTIMER_MATCH_NUM_8822B)                             \
+	 << BIT_SHIFT_TXTTIMER_MATCH_NUM_8822B)
+#define BIT_GET_TXTTIMER_MATCH_NUM_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_TXTTIMER_MATCH_NUM_8822B) &                         \
+	 BIT_MASK_TXTTIMER_MATCH_NUM_8822B)
+
+#define BIT_SHIFT_TXPKT_NUM_MATCH_8822B 24
+#define BIT_MASK_TXPKT_NUM_MATCH_8822B 0xf
+#define BIT_TXPKT_NUM_MATCH_8822B(x)                                           \
+	(((x) & BIT_MASK_TXPKT_NUM_MATCH_8822B)                                \
+	 << BIT_SHIFT_TXPKT_NUM_MATCH_8822B)
+#define BIT_GET_TXPKT_NUM_MATCH_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_TXPKT_NUM_MATCH_8822B) &                            \
+	 BIT_MASK_TXPKT_NUM_MATCH_8822B)
+
+#define BIT_SHIFT_RXTTIMER_MATCH_NUM_8822B 20
+#define BIT_MASK_RXTTIMER_MATCH_NUM_8822B 0xf
+#define BIT_RXTTIMER_MATCH_NUM_8822B(x)                                        \
+	(((x) & BIT_MASK_RXTTIMER_MATCH_NUM_8822B)                             \
+	 << BIT_SHIFT_RXTTIMER_MATCH_NUM_8822B)
+#define BIT_GET_RXTTIMER_MATCH_NUM_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_RXTTIMER_MATCH_NUM_8822B) &                         \
+	 BIT_MASK_RXTTIMER_MATCH_NUM_8822B)
+
+#define BIT_SHIFT_RXPKT_NUM_MATCH_8822B 16
+#define BIT_MASK_RXPKT_NUM_MATCH_8822B 0xf
+#define BIT_RXPKT_NUM_MATCH_8822B(x)                                           \
+	(((x) & BIT_MASK_RXPKT_NUM_MATCH_8822B)                                \
+	 << BIT_SHIFT_RXPKT_NUM_MATCH_8822B)
+#define BIT_GET_RXPKT_NUM_MATCH_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_RXPKT_NUM_MATCH_8822B) &                            \
+	 BIT_MASK_RXPKT_NUM_MATCH_8822B)
+
+#define BIT_SHIFT_MIGRATE_TIMER_8822B 0
+#define BIT_MASK_MIGRATE_TIMER_8822B 0xffff
+#define BIT_MIGRATE_TIMER_8822B(x)                                             \
+	(((x) & BIT_MASK_MIGRATE_TIMER_8822B) << BIT_SHIFT_MIGRATE_TIMER_8822B)
+#define BIT_GET_MIGRATE_TIMER_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_MIGRATE_TIMER_8822B) & BIT_MASK_MIGRATE_TIMER_8822B)
+
+/* 2 REG_BCNQ_TXBD_DESA_8822B */
+
+#define BIT_SHIFT_BCNQ_TXBD_DESA_8822B 0
+#define BIT_MASK_BCNQ_TXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_BCNQ_TXBD_DESA_8822B(x)                                            \
+	(((x) & BIT_MASK_BCNQ_TXBD_DESA_8822B)                                 \
+	 << BIT_SHIFT_BCNQ_TXBD_DESA_8822B)
+#define BIT_GET_BCNQ_TXBD_DESA_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_BCNQ_TXBD_DESA_8822B) &                             \
+	 BIT_MASK_BCNQ_TXBD_DESA_8822B)
+
+/* 2 REG_MGQ_TXBD_DESA_8822B */
+
+#define BIT_SHIFT_MGQ_TXBD_DESA_8822B 0
+#define BIT_MASK_MGQ_TXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_MGQ_TXBD_DESA_8822B(x)                                             \
+	(((x) & BIT_MASK_MGQ_TXBD_DESA_8822B) << BIT_SHIFT_MGQ_TXBD_DESA_8822B)
+#define BIT_GET_MGQ_TXBD_DESA_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_MGQ_TXBD_DESA_8822B) & BIT_MASK_MGQ_TXBD_DESA_8822B)
+
+/* 2 REG_VOQ_TXBD_DESA_8822B */
+
+#define BIT_SHIFT_VOQ_TXBD_DESA_8822B 0
+#define BIT_MASK_VOQ_TXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_VOQ_TXBD_DESA_8822B(x)                                             \
+	(((x) & BIT_MASK_VOQ_TXBD_DESA_8822B) << BIT_SHIFT_VOQ_TXBD_DESA_8822B)
+#define BIT_GET_VOQ_TXBD_DESA_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_VOQ_TXBD_DESA_8822B) & BIT_MASK_VOQ_TXBD_DESA_8822B)
+
+/* 2 REG_VIQ_TXBD_DESA_8822B */
+
+#define BIT_SHIFT_VIQ_TXBD_DESA_8822B 0
+#define BIT_MASK_VIQ_TXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_VIQ_TXBD_DESA_8822B(x)                                             \
+	(((x) & BIT_MASK_VIQ_TXBD_DESA_8822B) << BIT_SHIFT_VIQ_TXBD_DESA_8822B)
+#define BIT_GET_VIQ_TXBD_DESA_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_VIQ_TXBD_DESA_8822B) & BIT_MASK_VIQ_TXBD_DESA_8822B)
+
+/* 2 REG_BEQ_TXBD_DESA_8822B */
+
+#define BIT_SHIFT_BEQ_TXBD_DESA_8822B 0
+#define BIT_MASK_BEQ_TXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_BEQ_TXBD_DESA_8822B(x)                                             \
+	(((x) & BIT_MASK_BEQ_TXBD_DESA_8822B) << BIT_SHIFT_BEQ_TXBD_DESA_8822B)
+#define BIT_GET_BEQ_TXBD_DESA_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_BEQ_TXBD_DESA_8822B) & BIT_MASK_BEQ_TXBD_DESA_8822B)
+
+/* 2 REG_BKQ_TXBD_DESA_8822B */
+
+#define BIT_SHIFT_BKQ_TXBD_DESA_8822B 0
+#define BIT_MASK_BKQ_TXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_BKQ_TXBD_DESA_8822B(x)                                             \
+	(((x) & BIT_MASK_BKQ_TXBD_DESA_8822B) << BIT_SHIFT_BKQ_TXBD_DESA_8822B)
+#define BIT_GET_BKQ_TXBD_DESA_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_BKQ_TXBD_DESA_8822B) & BIT_MASK_BKQ_TXBD_DESA_8822B)
+
+/* 2 REG_RXQ_RXBD_DESA_8822B */
+
+#define BIT_SHIFT_RXQ_RXBD_DESA_8822B 0
+#define BIT_MASK_RXQ_RXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_RXQ_RXBD_DESA_8822B(x)                                             \
+	(((x) & BIT_MASK_RXQ_RXBD_DESA_8822B) << BIT_SHIFT_RXQ_RXBD_DESA_8822B)
+#define BIT_GET_RXQ_RXBD_DESA_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_RXQ_RXBD_DESA_8822B) & BIT_MASK_RXQ_RXBD_DESA_8822B)
+
+/* 2 REG_HI0Q_TXBD_DESA_8822B */
+
+#define BIT_SHIFT_HI0Q_TXBD_DESA_8822B 0
+#define BIT_MASK_HI0Q_TXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_HI0Q_TXBD_DESA_8822B(x)                                            \
+	(((x) & BIT_MASK_HI0Q_TXBD_DESA_8822B)                                 \
+	 << BIT_SHIFT_HI0Q_TXBD_DESA_8822B)
+#define BIT_GET_HI0Q_TXBD_DESA_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI0Q_TXBD_DESA_8822B) &                             \
+	 BIT_MASK_HI0Q_TXBD_DESA_8822B)
+
+/* 2 REG_HI1Q_TXBD_DESA_8822B */
+
+#define BIT_SHIFT_HI1Q_TXBD_DESA_8822B 0
+#define BIT_MASK_HI1Q_TXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_HI1Q_TXBD_DESA_8822B(x)                                            \
+	(((x) & BIT_MASK_HI1Q_TXBD_DESA_8822B)                                 \
+	 << BIT_SHIFT_HI1Q_TXBD_DESA_8822B)
+#define BIT_GET_HI1Q_TXBD_DESA_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI1Q_TXBD_DESA_8822B) &                             \
+	 BIT_MASK_HI1Q_TXBD_DESA_8822B)
+
+/* 2 REG_HI2Q_TXBD_DESA_8822B */
+
+#define BIT_SHIFT_HI2Q_TXBD_DESA_8822B 0
+#define BIT_MASK_HI2Q_TXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_HI2Q_TXBD_DESA_8822B(x)                                            \
+	(((x) & BIT_MASK_HI2Q_TXBD_DESA_8822B)                                 \
+	 << BIT_SHIFT_HI2Q_TXBD_DESA_8822B)
+#define BIT_GET_HI2Q_TXBD_DESA_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI2Q_TXBD_DESA_8822B) &                             \
+	 BIT_MASK_HI2Q_TXBD_DESA_8822B)
+
+/* 2 REG_HI3Q_TXBD_DESA_8822B */
+
+#define BIT_SHIFT_HI3Q_TXBD_DESA_8822B 0
+#define BIT_MASK_HI3Q_TXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_HI3Q_TXBD_DESA_8822B(x)                                            \
+	(((x) & BIT_MASK_HI3Q_TXBD_DESA_8822B)                                 \
+	 << BIT_SHIFT_HI3Q_TXBD_DESA_8822B)
+#define BIT_GET_HI3Q_TXBD_DESA_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI3Q_TXBD_DESA_8822B) &                             \
+	 BIT_MASK_HI3Q_TXBD_DESA_8822B)
+
+/* 2 REG_HI4Q_TXBD_DESA_8822B */
+
+#define BIT_SHIFT_HI4Q_TXBD_DESA_8822B 0
+#define BIT_MASK_HI4Q_TXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_HI4Q_TXBD_DESA_8822B(x)                                            \
+	(((x) & BIT_MASK_HI4Q_TXBD_DESA_8822B)                                 \
+	 << BIT_SHIFT_HI4Q_TXBD_DESA_8822B)
+#define BIT_GET_HI4Q_TXBD_DESA_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI4Q_TXBD_DESA_8822B) &                             \
+	 BIT_MASK_HI4Q_TXBD_DESA_8822B)
+
+/* 2 REG_HI5Q_TXBD_DESA_8822B */
+
+#define BIT_SHIFT_HI5Q_TXBD_DESA_8822B 0
+#define BIT_MASK_HI5Q_TXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_HI5Q_TXBD_DESA_8822B(x)                                            \
+	(((x) & BIT_MASK_HI5Q_TXBD_DESA_8822B)                                 \
+	 << BIT_SHIFT_HI5Q_TXBD_DESA_8822B)
+#define BIT_GET_HI5Q_TXBD_DESA_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI5Q_TXBD_DESA_8822B) &                             \
+	 BIT_MASK_HI5Q_TXBD_DESA_8822B)
+
+/* 2 REG_HI6Q_TXBD_DESA_8822B */
+
+#define BIT_SHIFT_HI6Q_TXBD_DESA_8822B 0
+#define BIT_MASK_HI6Q_TXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_HI6Q_TXBD_DESA_8822B(x)                                            \
+	(((x) & BIT_MASK_HI6Q_TXBD_DESA_8822B)                                 \
+	 << BIT_SHIFT_HI6Q_TXBD_DESA_8822B)
+#define BIT_GET_HI6Q_TXBD_DESA_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI6Q_TXBD_DESA_8822B) &                             \
+	 BIT_MASK_HI6Q_TXBD_DESA_8822B)
+
+/* 2 REG_HI7Q_TXBD_DESA_8822B */
+
+#define BIT_SHIFT_HI7Q_TXBD_DESA_8822B 0
+#define BIT_MASK_HI7Q_TXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_HI7Q_TXBD_DESA_8822B(x)                                            \
+	(((x) & BIT_MASK_HI7Q_TXBD_DESA_8822B)                                 \
+	 << BIT_SHIFT_HI7Q_TXBD_DESA_8822B)
+#define BIT_GET_HI7Q_TXBD_DESA_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI7Q_TXBD_DESA_8822B) &                             \
+	 BIT_MASK_HI7Q_TXBD_DESA_8822B)
+
+/* 2 REG_MGQ_TXBD_NUM_8822B */
+#define BIT_PCIE_MGQ_FLAG_8822B BIT(14)
+
+#define BIT_SHIFT_MGQ_DESC_MODE_8822B 12
+#define BIT_MASK_MGQ_DESC_MODE_8822B 0x3
+#define BIT_MGQ_DESC_MODE_8822B(x)                                             \
+	(((x) & BIT_MASK_MGQ_DESC_MODE_8822B) << BIT_SHIFT_MGQ_DESC_MODE_8822B)
+#define BIT_GET_MGQ_DESC_MODE_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_MGQ_DESC_MODE_8822B) & BIT_MASK_MGQ_DESC_MODE_8822B)
+
+#define BIT_SHIFT_MGQ_DESC_NUM_8822B 0
+#define BIT_MASK_MGQ_DESC_NUM_8822B 0xfff
+#define BIT_MGQ_DESC_NUM_8822B(x)                                              \
+	(((x) & BIT_MASK_MGQ_DESC_NUM_8822B) << BIT_SHIFT_MGQ_DESC_NUM_8822B)
+#define BIT_GET_MGQ_DESC_NUM_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_MGQ_DESC_NUM_8822B) & BIT_MASK_MGQ_DESC_NUM_8822B)
+
+/* 2 REG_RX_RXBD_NUM_8822B */
+#define BIT_SYS_32_64_8822B BIT(15)
+
+#define BIT_SHIFT_BCNQ_DESC_MODE_8822B 13
+#define BIT_MASK_BCNQ_DESC_MODE_8822B 0x3
+#define BIT_BCNQ_DESC_MODE_8822B(x)                                            \
+	(((x) & BIT_MASK_BCNQ_DESC_MODE_8822B)                                 \
+	 << BIT_SHIFT_BCNQ_DESC_MODE_8822B)
+#define BIT_GET_BCNQ_DESC_MODE_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_BCNQ_DESC_MODE_8822B) &                             \
+	 BIT_MASK_BCNQ_DESC_MODE_8822B)
+
+#define BIT_PCIE_BCNQ_FLAG_8822B BIT(12)
+
+#define BIT_SHIFT_RXQ_DESC_NUM_8822B 0
+#define BIT_MASK_RXQ_DESC_NUM_8822B 0xfff
+#define BIT_RXQ_DESC_NUM_8822B(x)                                              \
+	(((x) & BIT_MASK_RXQ_DESC_NUM_8822B) << BIT_SHIFT_RXQ_DESC_NUM_8822B)
+#define BIT_GET_RXQ_DESC_NUM_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_RXQ_DESC_NUM_8822B) & BIT_MASK_RXQ_DESC_NUM_8822B)
+
+/* 2 REG_VOQ_TXBD_NUM_8822B */
+#define BIT_PCIE_VOQ_FLAG_8822B BIT(14)
+
+#define BIT_SHIFT_VOQ_DESC_MODE_8822B 12
+#define BIT_MASK_VOQ_DESC_MODE_8822B 0x3
+#define BIT_VOQ_DESC_MODE_8822B(x)                                             \
+	(((x) & BIT_MASK_VOQ_DESC_MODE_8822B) << BIT_SHIFT_VOQ_DESC_MODE_8822B)
+#define BIT_GET_VOQ_DESC_MODE_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_VOQ_DESC_MODE_8822B) & BIT_MASK_VOQ_DESC_MODE_8822B)
+
+#define BIT_SHIFT_VOQ_DESC_NUM_8822B 0
+#define BIT_MASK_VOQ_DESC_NUM_8822B 0xfff
+#define BIT_VOQ_DESC_NUM_8822B(x)                                              \
+	(((x) & BIT_MASK_VOQ_DESC_NUM_8822B) << BIT_SHIFT_VOQ_DESC_NUM_8822B)
+#define BIT_GET_VOQ_DESC_NUM_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_VOQ_DESC_NUM_8822B) & BIT_MASK_VOQ_DESC_NUM_8822B)
+
+/* 2 REG_VIQ_TXBD_NUM_8822B */
+#define BIT_PCIE_VIQ_FLAG_8822B BIT(14)
+
+#define BIT_SHIFT_VIQ_DESC_MODE_8822B 12
+#define BIT_MASK_VIQ_DESC_MODE_8822B 0x3
+#define BIT_VIQ_DESC_MODE_8822B(x)                                             \
+	(((x) & BIT_MASK_VIQ_DESC_MODE_8822B) << BIT_SHIFT_VIQ_DESC_MODE_8822B)
+#define BIT_GET_VIQ_DESC_MODE_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_VIQ_DESC_MODE_8822B) & BIT_MASK_VIQ_DESC_MODE_8822B)
+
+#define BIT_SHIFT_VIQ_DESC_NUM_8822B 0
+#define BIT_MASK_VIQ_DESC_NUM_8822B 0xfff
+#define BIT_VIQ_DESC_NUM_8822B(x)                                              \
+	(((x) & BIT_MASK_VIQ_DESC_NUM_8822B) << BIT_SHIFT_VIQ_DESC_NUM_8822B)
+#define BIT_GET_VIQ_DESC_NUM_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_VIQ_DESC_NUM_8822B) & BIT_MASK_VIQ_DESC_NUM_8822B)
+
+/* 2 REG_BEQ_TXBD_NUM_8822B */
+#define BIT_PCIE_BEQ_FLAG_8822B BIT(14)
+
+#define BIT_SHIFT_BEQ_DESC_MODE_8822B 12
+#define BIT_MASK_BEQ_DESC_MODE_8822B 0x3
+#define BIT_BEQ_DESC_MODE_8822B(x)                                             \
+	(((x) & BIT_MASK_BEQ_DESC_MODE_8822B) << BIT_SHIFT_BEQ_DESC_MODE_8822B)
+#define BIT_GET_BEQ_DESC_MODE_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_BEQ_DESC_MODE_8822B) & BIT_MASK_BEQ_DESC_MODE_8822B)
+
+#define BIT_SHIFT_BEQ_DESC_NUM_8822B 0
+#define BIT_MASK_BEQ_DESC_NUM_8822B 0xfff
+#define BIT_BEQ_DESC_NUM_8822B(x)                                              \
+	(((x) & BIT_MASK_BEQ_DESC_NUM_8822B) << BIT_SHIFT_BEQ_DESC_NUM_8822B)
+#define BIT_GET_BEQ_DESC_NUM_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_BEQ_DESC_NUM_8822B) & BIT_MASK_BEQ_DESC_NUM_8822B)
+
+/* 2 REG_BKQ_TXBD_NUM_8822B */
+#define BIT_PCIE_BKQ_FLAG_8822B BIT(14)
+
+#define BIT_SHIFT_BKQ_DESC_MODE_8822B 12
+#define BIT_MASK_BKQ_DESC_MODE_8822B 0x3
+#define BIT_BKQ_DESC_MODE_8822B(x)                                             \
+	(((x) & BIT_MASK_BKQ_DESC_MODE_8822B) << BIT_SHIFT_BKQ_DESC_MODE_8822B)
+#define BIT_GET_BKQ_DESC_MODE_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_BKQ_DESC_MODE_8822B) & BIT_MASK_BKQ_DESC_MODE_8822B)
+
+#define BIT_SHIFT_BKQ_DESC_NUM_8822B 0
+#define BIT_MASK_BKQ_DESC_NUM_8822B 0xfff
+#define BIT_BKQ_DESC_NUM_8822B(x)                                              \
+	(((x) & BIT_MASK_BKQ_DESC_NUM_8822B) << BIT_SHIFT_BKQ_DESC_NUM_8822B)
+#define BIT_GET_BKQ_DESC_NUM_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_BKQ_DESC_NUM_8822B) & BIT_MASK_BKQ_DESC_NUM_8822B)
+
+/* 2 REG_HI0Q_TXBD_NUM_8822B */
+#define BIT_HI0Q_FLAG_8822B BIT(14)
+
+#define BIT_SHIFT_HI0Q_DESC_MODE_8822B 12
+#define BIT_MASK_HI0Q_DESC_MODE_8822B 0x3
+#define BIT_HI0Q_DESC_MODE_8822B(x)                                            \
+	(((x) & BIT_MASK_HI0Q_DESC_MODE_8822B)                                 \
+	 << BIT_SHIFT_HI0Q_DESC_MODE_8822B)
+#define BIT_GET_HI0Q_DESC_MODE_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI0Q_DESC_MODE_8822B) &                             \
+	 BIT_MASK_HI0Q_DESC_MODE_8822B)
+
+#define BIT_SHIFT_HI0Q_DESC_NUM_8822B 0
+#define BIT_MASK_HI0Q_DESC_NUM_8822B 0xfff
+#define BIT_HI0Q_DESC_NUM_8822B(x)                                             \
+	(((x) & BIT_MASK_HI0Q_DESC_NUM_8822B) << BIT_SHIFT_HI0Q_DESC_NUM_8822B)
+#define BIT_GET_HI0Q_DESC_NUM_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI0Q_DESC_NUM_8822B) & BIT_MASK_HI0Q_DESC_NUM_8822B)
+
+/* 2 REG_HI1Q_TXBD_NUM_8822B */
+#define BIT_HI1Q_FLAG_8822B BIT(14)
+
+#define BIT_SHIFT_HI1Q_DESC_MODE_8822B 12
+#define BIT_MASK_HI1Q_DESC_MODE_8822B 0x3
+#define BIT_HI1Q_DESC_MODE_8822B(x)                                            \
+	(((x) & BIT_MASK_HI1Q_DESC_MODE_8822B)                                 \
+	 << BIT_SHIFT_HI1Q_DESC_MODE_8822B)
+#define BIT_GET_HI1Q_DESC_MODE_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI1Q_DESC_MODE_8822B) &                             \
+	 BIT_MASK_HI1Q_DESC_MODE_8822B)
+
+#define BIT_SHIFT_HI1Q_DESC_NUM_8822B 0
+#define BIT_MASK_HI1Q_DESC_NUM_8822B 0xfff
+#define BIT_HI1Q_DESC_NUM_8822B(x)                                             \
+	(((x) & BIT_MASK_HI1Q_DESC_NUM_8822B) << BIT_SHIFT_HI1Q_DESC_NUM_8822B)
+#define BIT_GET_HI1Q_DESC_NUM_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI1Q_DESC_NUM_8822B) & BIT_MASK_HI1Q_DESC_NUM_8822B)
+
+/* 2 REG_HI2Q_TXBD_NUM_8822B */
+#define BIT_HI2Q_FLAG_8822B BIT(14)
+
+#define BIT_SHIFT_HI2Q_DESC_MODE_8822B 12
+#define BIT_MASK_HI2Q_DESC_MODE_8822B 0x3
+#define BIT_HI2Q_DESC_MODE_8822B(x)                                            \
+	(((x) & BIT_MASK_HI2Q_DESC_MODE_8822B)                                 \
+	 << BIT_SHIFT_HI2Q_DESC_MODE_8822B)
+#define BIT_GET_HI2Q_DESC_MODE_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI2Q_DESC_MODE_8822B) &                             \
+	 BIT_MASK_HI2Q_DESC_MODE_8822B)
+
+#define BIT_SHIFT_HI2Q_DESC_NUM_8822B 0
+#define BIT_MASK_HI2Q_DESC_NUM_8822B 0xfff
+#define BIT_HI2Q_DESC_NUM_8822B(x)                                             \
+	(((x) & BIT_MASK_HI2Q_DESC_NUM_8822B) << BIT_SHIFT_HI2Q_DESC_NUM_8822B)
+#define BIT_GET_HI2Q_DESC_NUM_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI2Q_DESC_NUM_8822B) & BIT_MASK_HI2Q_DESC_NUM_8822B)
+
+/* 2 REG_HI3Q_TXBD_NUM_8822B */
+#define BIT_HI3Q_FLAG_8822B BIT(14)
+
+#define BIT_SHIFT_HI3Q_DESC_MODE_8822B 12
+#define BIT_MASK_HI3Q_DESC_MODE_8822B 0x3
+#define BIT_HI3Q_DESC_MODE_8822B(x)                                            \
+	(((x) & BIT_MASK_HI3Q_DESC_MODE_8822B)                                 \
+	 << BIT_SHIFT_HI3Q_DESC_MODE_8822B)
+#define BIT_GET_HI3Q_DESC_MODE_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI3Q_DESC_MODE_8822B) &                             \
+	 BIT_MASK_HI3Q_DESC_MODE_8822B)
+
+#define BIT_SHIFT_HI3Q_DESC_NUM_8822B 0
+#define BIT_MASK_HI3Q_DESC_NUM_8822B 0xfff
+#define BIT_HI3Q_DESC_NUM_8822B(x)                                             \
+	(((x) & BIT_MASK_HI3Q_DESC_NUM_8822B) << BIT_SHIFT_HI3Q_DESC_NUM_8822B)
+#define BIT_GET_HI3Q_DESC_NUM_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI3Q_DESC_NUM_8822B) & BIT_MASK_HI3Q_DESC_NUM_8822B)
+
+/* 2 REG_HI4Q_TXBD_NUM_8822B */
+#define BIT_HI4Q_FLAG_8822B BIT(14)
+
+#define BIT_SHIFT_HI4Q_DESC_MODE_8822B 12
+#define BIT_MASK_HI4Q_DESC_MODE_8822B 0x3
+#define BIT_HI4Q_DESC_MODE_8822B(x)                                            \
+	(((x) & BIT_MASK_HI4Q_DESC_MODE_8822B)                                 \
+	 << BIT_SHIFT_HI4Q_DESC_MODE_8822B)
+#define BIT_GET_HI4Q_DESC_MODE_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI4Q_DESC_MODE_8822B) &                             \
+	 BIT_MASK_HI4Q_DESC_MODE_8822B)
+
+#define BIT_SHIFT_HI4Q_DESC_NUM_8822B 0
+#define BIT_MASK_HI4Q_DESC_NUM_8822B 0xfff
+#define BIT_HI4Q_DESC_NUM_8822B(x)                                             \
+	(((x) & BIT_MASK_HI4Q_DESC_NUM_8822B) << BIT_SHIFT_HI4Q_DESC_NUM_8822B)
+#define BIT_GET_HI4Q_DESC_NUM_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI4Q_DESC_NUM_8822B) & BIT_MASK_HI4Q_DESC_NUM_8822B)
+
+/* 2 REG_HI5Q_TXBD_NUM_8822B */
+#define BIT_HI5Q_FLAG_8822B BIT(14)
+
+#define BIT_SHIFT_HI5Q_DESC_MODE_8822B 12
+#define BIT_MASK_HI5Q_DESC_MODE_8822B 0x3
+#define BIT_HI5Q_DESC_MODE_8822B(x)                                            \
+	(((x) & BIT_MASK_HI5Q_DESC_MODE_8822B)                                 \
+	 << BIT_SHIFT_HI5Q_DESC_MODE_8822B)
+#define BIT_GET_HI5Q_DESC_MODE_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI5Q_DESC_MODE_8822B) &                             \
+	 BIT_MASK_HI5Q_DESC_MODE_8822B)
+
+#define BIT_SHIFT_HI5Q_DESC_NUM_8822B 0
+#define BIT_MASK_HI5Q_DESC_NUM_8822B 0xfff
+#define BIT_HI5Q_DESC_NUM_8822B(x)                                             \
+	(((x) & BIT_MASK_HI5Q_DESC_NUM_8822B) << BIT_SHIFT_HI5Q_DESC_NUM_8822B)
+#define BIT_GET_HI5Q_DESC_NUM_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI5Q_DESC_NUM_8822B) & BIT_MASK_HI5Q_DESC_NUM_8822B)
+
+/* 2 REG_HI6Q_TXBD_NUM_8822B */
+#define BIT_HI6Q_FLAG_8822B BIT(14)
+
+#define BIT_SHIFT_HI6Q_DESC_MODE_8822B 12
+#define BIT_MASK_HI6Q_DESC_MODE_8822B 0x3
+#define BIT_HI6Q_DESC_MODE_8822B(x)                                            \
+	(((x) & BIT_MASK_HI6Q_DESC_MODE_8822B)                                 \
+	 << BIT_SHIFT_HI6Q_DESC_MODE_8822B)
+#define BIT_GET_HI6Q_DESC_MODE_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI6Q_DESC_MODE_8822B) &                             \
+	 BIT_MASK_HI6Q_DESC_MODE_8822B)
+
+#define BIT_SHIFT_HI6Q_DESC_NUM_8822B 0
+#define BIT_MASK_HI6Q_DESC_NUM_8822B 0xfff
+#define BIT_HI6Q_DESC_NUM_8822B(x)                                             \
+	(((x) & BIT_MASK_HI6Q_DESC_NUM_8822B) << BIT_SHIFT_HI6Q_DESC_NUM_8822B)
+#define BIT_GET_HI6Q_DESC_NUM_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI6Q_DESC_NUM_8822B) & BIT_MASK_HI6Q_DESC_NUM_8822B)
+
+/* 2 REG_HI7Q_TXBD_NUM_8822B */
+#define BIT_HI7Q_FLAG_8822B BIT(14)
+
+#define BIT_SHIFT_HI7Q_DESC_MODE_8822B 12
+#define BIT_MASK_HI7Q_DESC_MODE_8822B 0x3
+#define BIT_HI7Q_DESC_MODE_8822B(x)                                            \
+	(((x) & BIT_MASK_HI7Q_DESC_MODE_8822B)                                 \
+	 << BIT_SHIFT_HI7Q_DESC_MODE_8822B)
+#define BIT_GET_HI7Q_DESC_MODE_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HI7Q_DESC_MODE_8822B) &                             \
+	 BIT_MASK_HI7Q_DESC_MODE_8822B)
+
+#define BIT_SHIFT_HI7Q_DESC_NUM_8822B 0
+#define BIT_MASK_HI7Q_DESC_NUM_8822B 0xfff
+#define BIT_HI7Q_DESC_NUM_8822B(x)                                             \
+	(((x) & BIT_MASK_HI7Q_DESC_NUM_8822B) << BIT_SHIFT_HI7Q_DESC_NUM_8822B)
+#define BIT_GET_HI7Q_DESC_NUM_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI7Q_DESC_NUM_8822B) & BIT_MASK_HI7Q_DESC_NUM_8822B)
+
+/* 2 REG_TSFTIMER_HCI_8822B */
+
+#define BIT_SHIFT_TSFT2_HCI_8822B 16
+#define BIT_MASK_TSFT2_HCI_8822B 0xffff
+#define BIT_TSFT2_HCI_8822B(x)                                                 \
+	(((x) & BIT_MASK_TSFT2_HCI_8822B) << BIT_SHIFT_TSFT2_HCI_8822B)
+#define BIT_GET_TSFT2_HCI_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_TSFT2_HCI_8822B) & BIT_MASK_TSFT2_HCI_8822B)
+
+#define BIT_SHIFT_TSFT1_HCI_8822B 0
+#define BIT_MASK_TSFT1_HCI_8822B 0xffff
+#define BIT_TSFT1_HCI_8822B(x)                                                 \
+	(((x) & BIT_MASK_TSFT1_HCI_8822B) << BIT_SHIFT_TSFT1_HCI_8822B)
+#define BIT_GET_TSFT1_HCI_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_TSFT1_HCI_8822B) & BIT_MASK_TSFT1_HCI_8822B)
+
+/* 2 REG_BD_RWPTR_CLR_8822B */
+#define BIT_CLR_HI7Q_HW_IDX_8822B BIT(29)
+#define BIT_CLR_HI6Q_HW_IDX_8822B BIT(28)
+#define BIT_CLR_HI5Q_HW_IDX_8822B BIT(27)
+#define BIT_CLR_HI4Q_HW_IDX_8822B BIT(26)
+#define BIT_CLR_HI3Q_HW_IDX_8822B BIT(25)
+#define BIT_CLR_HI2Q_HW_IDX_8822B BIT(24)
+#define BIT_CLR_HI1Q_HW_IDX_8822B BIT(23)
+#define BIT_CLR_HI0Q_HW_IDX_8822B BIT(22)
+#define BIT_CLR_BKQ_HW_IDX_8822B BIT(21)
+#define BIT_CLR_BEQ_HW_IDX_8822B BIT(20)
+#define BIT_CLR_VIQ_HW_IDX_8822B BIT(19)
+#define BIT_CLR_VOQ_HW_IDX_8822B BIT(18)
+#define BIT_CLR_MGQ_HW_IDX_8822B BIT(17)
+#define BIT_CLR_RXQ_HW_IDX_8822B BIT(16)
+#define BIT_CLR_HI7Q_HOST_IDX_8822B BIT(13)
+#define BIT_CLR_HI6Q_HOST_IDX_8822B BIT(12)
+#define BIT_CLR_HI5Q_HOST_IDX_8822B BIT(11)
+#define BIT_CLR_HI4Q_HOST_IDX_8822B BIT(10)
+#define BIT_CLR_HI3Q_HOST_IDX_8822B BIT(9)
+#define BIT_CLR_HI2Q_HOST_IDX_8822B BIT(8)
+#define BIT_CLR_HI1Q_HOST_IDX_8822B BIT(7)
+#define BIT_CLR_HI0Q_HOST_IDX_8822B BIT(6)
+#define BIT_CLR_BKQ_HOST_IDX_8822B BIT(5)
+#define BIT_CLR_BEQ_HOST_IDX_8822B BIT(4)
+#define BIT_CLR_VIQ_HOST_IDX_8822B BIT(3)
+#define BIT_CLR_VOQ_HOST_IDX_8822B BIT(2)
+#define BIT_CLR_MGQ_HOST_IDX_8822B BIT(1)
+#define BIT_CLR_RXQ_HOST_IDX_8822B BIT(0)
+
+/* 2 REG_VOQ_TXBD_IDX_8822B */
+
+#define BIT_SHIFT_VOQ_HW_IDX_8822B 16
+#define BIT_MASK_VOQ_HW_IDX_8822B 0xfff
+#define BIT_VOQ_HW_IDX_8822B(x)                                                \
+	(((x) & BIT_MASK_VOQ_HW_IDX_8822B) << BIT_SHIFT_VOQ_HW_IDX_8822B)
+#define BIT_GET_VOQ_HW_IDX_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_VOQ_HW_IDX_8822B) & BIT_MASK_VOQ_HW_IDX_8822B)
+
+#define BIT_SHIFT_VOQ_HOST_IDX_8822B 0
+#define BIT_MASK_VOQ_HOST_IDX_8822B 0xfff
+#define BIT_VOQ_HOST_IDX_8822B(x)                                              \
+	(((x) & BIT_MASK_VOQ_HOST_IDX_8822B) << BIT_SHIFT_VOQ_HOST_IDX_8822B)
+#define BIT_GET_VOQ_HOST_IDX_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_VOQ_HOST_IDX_8822B) & BIT_MASK_VOQ_HOST_IDX_8822B)
+
+/* 2 REG_VIQ_TXBD_IDX_8822B */
+
+#define BIT_SHIFT_VIQ_HW_IDX_8822B 16
+#define BIT_MASK_VIQ_HW_IDX_8822B 0xfff
+#define BIT_VIQ_HW_IDX_8822B(x)                                                \
+	(((x) & BIT_MASK_VIQ_HW_IDX_8822B) << BIT_SHIFT_VIQ_HW_IDX_8822B)
+#define BIT_GET_VIQ_HW_IDX_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_VIQ_HW_IDX_8822B) & BIT_MASK_VIQ_HW_IDX_8822B)
+
+#define BIT_SHIFT_VIQ_HOST_IDX_8822B 0
+#define BIT_MASK_VIQ_HOST_IDX_8822B 0xfff
+#define BIT_VIQ_HOST_IDX_8822B(x)                                              \
+	(((x) & BIT_MASK_VIQ_HOST_IDX_8822B) << BIT_SHIFT_VIQ_HOST_IDX_8822B)
+#define BIT_GET_VIQ_HOST_IDX_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_VIQ_HOST_IDX_8822B) & BIT_MASK_VIQ_HOST_IDX_8822B)
+
+/* 2 REG_BEQ_TXBD_IDX_8822B */
+
+#define BIT_SHIFT_BEQ_HW_IDX_8822B 16
+#define BIT_MASK_BEQ_HW_IDX_8822B 0xfff
+#define BIT_BEQ_HW_IDX_8822B(x)                                                \
+	(((x) & BIT_MASK_BEQ_HW_IDX_8822B) << BIT_SHIFT_BEQ_HW_IDX_8822B)
+#define BIT_GET_BEQ_HW_IDX_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_BEQ_HW_IDX_8822B) & BIT_MASK_BEQ_HW_IDX_8822B)
+
+#define BIT_SHIFT_BEQ_HOST_IDX_8822B 0
+#define BIT_MASK_BEQ_HOST_IDX_8822B 0xfff
+#define BIT_BEQ_HOST_IDX_8822B(x)                                              \
+	(((x) & BIT_MASK_BEQ_HOST_IDX_8822B) << BIT_SHIFT_BEQ_HOST_IDX_8822B)
+#define BIT_GET_BEQ_HOST_IDX_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_BEQ_HOST_IDX_8822B) & BIT_MASK_BEQ_HOST_IDX_8822B)
+
+/* 2 REG_BKQ_TXBD_IDX_8822B */
+
+#define BIT_SHIFT_BKQ_HW_IDX_8822B 16
+#define BIT_MASK_BKQ_HW_IDX_8822B 0xfff
+#define BIT_BKQ_HW_IDX_8822B(x)                                                \
+	(((x) & BIT_MASK_BKQ_HW_IDX_8822B) << BIT_SHIFT_BKQ_HW_IDX_8822B)
+#define BIT_GET_BKQ_HW_IDX_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_BKQ_HW_IDX_8822B) & BIT_MASK_BKQ_HW_IDX_8822B)
+
+#define BIT_SHIFT_BKQ_HOST_IDX_8822B 0
+#define BIT_MASK_BKQ_HOST_IDX_8822B 0xfff
+#define BIT_BKQ_HOST_IDX_8822B(x)                                              \
+	(((x) & BIT_MASK_BKQ_HOST_IDX_8822B) << BIT_SHIFT_BKQ_HOST_IDX_8822B)
+#define BIT_GET_BKQ_HOST_IDX_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_BKQ_HOST_IDX_8822B) & BIT_MASK_BKQ_HOST_IDX_8822B)
+
+/* 2 REG_MGQ_TXBD_IDX_8822B */
+
+#define BIT_SHIFT_MGQ_HW_IDX_8822B 16
+#define BIT_MASK_MGQ_HW_IDX_8822B 0xfff
+#define BIT_MGQ_HW_IDX_8822B(x)                                                \
+	(((x) & BIT_MASK_MGQ_HW_IDX_8822B) << BIT_SHIFT_MGQ_HW_IDX_8822B)
+#define BIT_GET_MGQ_HW_IDX_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_MGQ_HW_IDX_8822B) & BIT_MASK_MGQ_HW_IDX_8822B)
+
+#define BIT_SHIFT_MGQ_HOST_IDX_8822B 0
+#define BIT_MASK_MGQ_HOST_IDX_8822B 0xfff
+#define BIT_MGQ_HOST_IDX_8822B(x)                                              \
+	(((x) & BIT_MASK_MGQ_HOST_IDX_8822B) << BIT_SHIFT_MGQ_HOST_IDX_8822B)
+#define BIT_GET_MGQ_HOST_IDX_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_MGQ_HOST_IDX_8822B) & BIT_MASK_MGQ_HOST_IDX_8822B)
+
+/* 2 REG_RXQ_RXBD_IDX_8822B */
+
+#define BIT_SHIFT_RXQ_HW_IDX_8822B 16
+#define BIT_MASK_RXQ_HW_IDX_8822B 0xfff
+#define BIT_RXQ_HW_IDX_8822B(x)                                                \
+	(((x) & BIT_MASK_RXQ_HW_IDX_8822B) << BIT_SHIFT_RXQ_HW_IDX_8822B)
+#define BIT_GET_RXQ_HW_IDX_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_RXQ_HW_IDX_8822B) & BIT_MASK_RXQ_HW_IDX_8822B)
+
+#define BIT_SHIFT_RXQ_HOST_IDX_8822B 0
+#define BIT_MASK_RXQ_HOST_IDX_8822B 0xfff
+#define BIT_RXQ_HOST_IDX_8822B(x)                                              \
+	(((x) & BIT_MASK_RXQ_HOST_IDX_8822B) << BIT_SHIFT_RXQ_HOST_IDX_8822B)
+#define BIT_GET_RXQ_HOST_IDX_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_RXQ_HOST_IDX_8822B) & BIT_MASK_RXQ_HOST_IDX_8822B)
+
+/* 2 REG_HI0Q_TXBD_IDX_8822B */
+
+#define BIT_SHIFT_HI0Q_HW_IDX_8822B 16
+#define BIT_MASK_HI0Q_HW_IDX_8822B 0xfff
+#define BIT_HI0Q_HW_IDX_8822B(x)                                               \
+	(((x) & BIT_MASK_HI0Q_HW_IDX_8822B) << BIT_SHIFT_HI0Q_HW_IDX_8822B)
+#define BIT_GET_HI0Q_HW_IDX_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HI0Q_HW_IDX_8822B) & BIT_MASK_HI0Q_HW_IDX_8822B)
+
+#define BIT_SHIFT_HI0Q_HOST_IDX_8822B 0
+#define BIT_MASK_HI0Q_HOST_IDX_8822B 0xfff
+#define BIT_HI0Q_HOST_IDX_8822B(x)                                             \
+	(((x) & BIT_MASK_HI0Q_HOST_IDX_8822B) << BIT_SHIFT_HI0Q_HOST_IDX_8822B)
+#define BIT_GET_HI0Q_HOST_IDX_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI0Q_HOST_IDX_8822B) & BIT_MASK_HI0Q_HOST_IDX_8822B)
+
+/* 2 REG_HI1Q_TXBD_IDX_8822B */
+
+#define BIT_SHIFT_HI1Q_HW_IDX_8822B 16
+#define BIT_MASK_HI1Q_HW_IDX_8822B 0xfff
+#define BIT_HI1Q_HW_IDX_8822B(x)                                               \
+	(((x) & BIT_MASK_HI1Q_HW_IDX_8822B) << BIT_SHIFT_HI1Q_HW_IDX_8822B)
+#define BIT_GET_HI1Q_HW_IDX_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HI1Q_HW_IDX_8822B) & BIT_MASK_HI1Q_HW_IDX_8822B)
+
+#define BIT_SHIFT_HI1Q_HOST_IDX_8822B 0
+#define BIT_MASK_HI1Q_HOST_IDX_8822B 0xfff
+#define BIT_HI1Q_HOST_IDX_8822B(x)                                             \
+	(((x) & BIT_MASK_HI1Q_HOST_IDX_8822B) << BIT_SHIFT_HI1Q_HOST_IDX_8822B)
+#define BIT_GET_HI1Q_HOST_IDX_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI1Q_HOST_IDX_8822B) & BIT_MASK_HI1Q_HOST_IDX_8822B)
+
+/* 2 REG_HI2Q_TXBD_IDX_8822B */
+
+#define BIT_SHIFT_HI2Q_HW_IDX_8822B 16
+#define BIT_MASK_HI2Q_HW_IDX_8822B 0xfff
+#define BIT_HI2Q_HW_IDX_8822B(x)                                               \
+	(((x) & BIT_MASK_HI2Q_HW_IDX_8822B) << BIT_SHIFT_HI2Q_HW_IDX_8822B)
+#define BIT_GET_HI2Q_HW_IDX_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HI2Q_HW_IDX_8822B) & BIT_MASK_HI2Q_HW_IDX_8822B)
+
+#define BIT_SHIFT_HI2Q_HOST_IDX_8822B 0
+#define BIT_MASK_HI2Q_HOST_IDX_8822B 0xfff
+#define BIT_HI2Q_HOST_IDX_8822B(x)                                             \
+	(((x) & BIT_MASK_HI2Q_HOST_IDX_8822B) << BIT_SHIFT_HI2Q_HOST_IDX_8822B)
+#define BIT_GET_HI2Q_HOST_IDX_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI2Q_HOST_IDX_8822B) & BIT_MASK_HI2Q_HOST_IDX_8822B)
+
+/* 2 REG_HI3Q_TXBD_IDX_8822B */
+
+#define BIT_SHIFT_HI3Q_HW_IDX_8822B 16
+#define BIT_MASK_HI3Q_HW_IDX_8822B 0xfff
+#define BIT_HI3Q_HW_IDX_8822B(x)                                               \
+	(((x) & BIT_MASK_HI3Q_HW_IDX_8822B) << BIT_SHIFT_HI3Q_HW_IDX_8822B)
+#define BIT_GET_HI3Q_HW_IDX_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HI3Q_HW_IDX_8822B) & BIT_MASK_HI3Q_HW_IDX_8822B)
+
+#define BIT_SHIFT_HI3Q_HOST_IDX_8822B 0
+#define BIT_MASK_HI3Q_HOST_IDX_8822B 0xfff
+#define BIT_HI3Q_HOST_IDX_8822B(x)                                             \
+	(((x) & BIT_MASK_HI3Q_HOST_IDX_8822B) << BIT_SHIFT_HI3Q_HOST_IDX_8822B)
+#define BIT_GET_HI3Q_HOST_IDX_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI3Q_HOST_IDX_8822B) & BIT_MASK_HI3Q_HOST_IDX_8822B)
+
+/* 2 REG_HI4Q_TXBD_IDX_8822B */
+
+#define BIT_SHIFT_HI4Q_HW_IDX_8822B 16
+#define BIT_MASK_HI4Q_HW_IDX_8822B 0xfff
+#define BIT_HI4Q_HW_IDX_8822B(x)                                               \
+	(((x) & BIT_MASK_HI4Q_HW_IDX_8822B) << BIT_SHIFT_HI4Q_HW_IDX_8822B)
+#define BIT_GET_HI4Q_HW_IDX_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HI4Q_HW_IDX_8822B) & BIT_MASK_HI4Q_HW_IDX_8822B)
+
+#define BIT_SHIFT_HI4Q_HOST_IDX_8822B 0
+#define BIT_MASK_HI4Q_HOST_IDX_8822B 0xfff
+#define BIT_HI4Q_HOST_IDX_8822B(x)                                             \
+	(((x) & BIT_MASK_HI4Q_HOST_IDX_8822B) << BIT_SHIFT_HI4Q_HOST_IDX_8822B)
+#define BIT_GET_HI4Q_HOST_IDX_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI4Q_HOST_IDX_8822B) & BIT_MASK_HI4Q_HOST_IDX_8822B)
+
+/* 2 REG_HI5Q_TXBD_IDX_8822B */
+
+#define BIT_SHIFT_HI5Q_HW_IDX_8822B 16
+#define BIT_MASK_HI5Q_HW_IDX_8822B 0xfff
+#define BIT_HI5Q_HW_IDX_8822B(x)                                               \
+	(((x) & BIT_MASK_HI5Q_HW_IDX_8822B) << BIT_SHIFT_HI5Q_HW_IDX_8822B)
+#define BIT_GET_HI5Q_HW_IDX_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HI5Q_HW_IDX_8822B) & BIT_MASK_HI5Q_HW_IDX_8822B)
+
+#define BIT_SHIFT_HI5Q_HOST_IDX_8822B 0
+#define BIT_MASK_HI5Q_HOST_IDX_8822B 0xfff
+#define BIT_HI5Q_HOST_IDX_8822B(x)                                             \
+	(((x) & BIT_MASK_HI5Q_HOST_IDX_8822B) << BIT_SHIFT_HI5Q_HOST_IDX_8822B)
+#define BIT_GET_HI5Q_HOST_IDX_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI5Q_HOST_IDX_8822B) & BIT_MASK_HI5Q_HOST_IDX_8822B)
+
+/* 2 REG_HI6Q_TXBD_IDX_8822B */
+
+#define BIT_SHIFT_HI6Q_HW_IDX_8822B 16
+#define BIT_MASK_HI6Q_HW_IDX_8822B 0xfff
+#define BIT_HI6Q_HW_IDX_8822B(x)                                               \
+	(((x) & BIT_MASK_HI6Q_HW_IDX_8822B) << BIT_SHIFT_HI6Q_HW_IDX_8822B)
+#define BIT_GET_HI6Q_HW_IDX_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HI6Q_HW_IDX_8822B) & BIT_MASK_HI6Q_HW_IDX_8822B)
+
+#define BIT_SHIFT_HI6Q_HOST_IDX_8822B 0
+#define BIT_MASK_HI6Q_HOST_IDX_8822B 0xfff
+#define BIT_HI6Q_HOST_IDX_8822B(x)                                             \
+	(((x) & BIT_MASK_HI6Q_HOST_IDX_8822B) << BIT_SHIFT_HI6Q_HOST_IDX_8822B)
+#define BIT_GET_HI6Q_HOST_IDX_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI6Q_HOST_IDX_8822B) & BIT_MASK_HI6Q_HOST_IDX_8822B)
+
+/* 2 REG_HI7Q_TXBD_IDX_8822B */
+
+#define BIT_SHIFT_HI7Q_HW_IDX_8822B 16
+#define BIT_MASK_HI7Q_HW_IDX_8822B 0xfff
+#define BIT_HI7Q_HW_IDX_8822B(x)                                               \
+	(((x) & BIT_MASK_HI7Q_HW_IDX_8822B) << BIT_SHIFT_HI7Q_HW_IDX_8822B)
+#define BIT_GET_HI7Q_HW_IDX_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HI7Q_HW_IDX_8822B) & BIT_MASK_HI7Q_HW_IDX_8822B)
+
+#define BIT_SHIFT_HI7Q_HOST_IDX_8822B 0
+#define BIT_MASK_HI7Q_HOST_IDX_8822B 0xfff
+#define BIT_HI7Q_HOST_IDX_8822B(x)                                             \
+	(((x) & BIT_MASK_HI7Q_HOST_IDX_8822B) << BIT_SHIFT_HI7Q_HOST_IDX_8822B)
+#define BIT_GET_HI7Q_HOST_IDX_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HI7Q_HOST_IDX_8822B) & BIT_MASK_HI7Q_HOST_IDX_8822B)
+
+/* 2 REG_DBG_SEL_V1_8822B */
+
+#define BIT_SHIFT_DBG_SEL_8822B 0
+#define BIT_MASK_DBG_SEL_8822B 0xff
+#define BIT_DBG_SEL_8822B(x)                                                   \
+	(((x) & BIT_MASK_DBG_SEL_8822B) << BIT_SHIFT_DBG_SEL_8822B)
+#define BIT_GET_DBG_SEL_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_DBG_SEL_8822B) & BIT_MASK_DBG_SEL_8822B)
+
+/* 2 REG_PCIE_HRPWM1_V1_8822B */
+
+#define BIT_SHIFT_PCIE_HRPWM_8822B 0
+#define BIT_MASK_PCIE_HRPWM_8822B 0xff
+#define BIT_PCIE_HRPWM_8822B(x)                                                \
+	(((x) & BIT_MASK_PCIE_HRPWM_8822B) << BIT_SHIFT_PCIE_HRPWM_8822B)
+#define BIT_GET_PCIE_HRPWM_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_PCIE_HRPWM_8822B) & BIT_MASK_PCIE_HRPWM_8822B)
+
+/* 2 REG_PCIE_HCPWM1_V1_8822B */
+
+#define BIT_SHIFT_PCIE_HCPWM_8822B 0
+#define BIT_MASK_PCIE_HCPWM_8822B 0xff
+#define BIT_PCIE_HCPWM_8822B(x)                                                \
+	(((x) & BIT_MASK_PCIE_HCPWM_8822B) << BIT_SHIFT_PCIE_HCPWM_8822B)
+#define BIT_GET_PCIE_HCPWM_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_PCIE_HCPWM_8822B) & BIT_MASK_PCIE_HCPWM_8822B)
+
+/* 2 REG_PCIE_CTRL2_8822B */
+#define BIT_DIS_TXDMA_PRE_8822B BIT(7)
+#define BIT_DIS_RXDMA_PRE_8822B BIT(6)
+
+#define BIT_SHIFT_HPS_CLKR_PCIE_8822B 4
+#define BIT_MASK_HPS_CLKR_PCIE_8822B 0x3
+#define BIT_HPS_CLKR_PCIE_8822B(x)                                             \
+	(((x) & BIT_MASK_HPS_CLKR_PCIE_8822B) << BIT_SHIFT_HPS_CLKR_PCIE_8822B)
+#define BIT_GET_HPS_CLKR_PCIE_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HPS_CLKR_PCIE_8822B) & BIT_MASK_HPS_CLKR_PCIE_8822B)
+
+#define BIT_PCIE_INT_8822B BIT(3)
+#define BIT_TXFLAG_EXIT_L1_EN_8822B BIT(2)
+#define BIT_EN_RXDMA_ALIGN_8822B BIT(1)
+#define BIT_EN_TXDMA_ALIGN_8822B BIT(0)
+
+/* 2 REG_PCIE_HRPWM2_V1_8822B */
+
+#define BIT_SHIFT_PCIE_HRPWM2_8822B 0
+#define BIT_MASK_PCIE_HRPWM2_8822B 0xffff
+#define BIT_PCIE_HRPWM2_8822B(x)                                               \
+	(((x) & BIT_MASK_PCIE_HRPWM2_8822B) << BIT_SHIFT_PCIE_HRPWM2_8822B)
+#define BIT_GET_PCIE_HRPWM2_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_PCIE_HRPWM2_8822B) & BIT_MASK_PCIE_HRPWM2_8822B)
+
+/* 2 REG_PCIE_HCPWM2_V1_8822B */
+
+#define BIT_SHIFT_PCIE_HCPWM2_8822B 0
+#define BIT_MASK_PCIE_HCPWM2_8822B 0xffff
+#define BIT_PCIE_HCPWM2_8822B(x)                                               \
+	(((x) & BIT_MASK_PCIE_HCPWM2_8822B) << BIT_SHIFT_PCIE_HCPWM2_8822B)
+#define BIT_GET_PCIE_HCPWM2_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_PCIE_HCPWM2_8822B) & BIT_MASK_PCIE_HCPWM2_8822B)
+
+/* 2 REG_PCIE_H2C_MSG_V1_8822B */
+
+#define BIT_SHIFT_DRV2FW_INFO_8822B 0
+#define BIT_MASK_DRV2FW_INFO_8822B 0xffffffffL
+#define BIT_DRV2FW_INFO_8822B(x)                                               \
+	(((x) & BIT_MASK_DRV2FW_INFO_8822B) << BIT_SHIFT_DRV2FW_INFO_8822B)
+#define BIT_GET_DRV2FW_INFO_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_DRV2FW_INFO_8822B) & BIT_MASK_DRV2FW_INFO_8822B)
+
+/* 2 REG_PCIE_C2H_MSG_V1_8822B */
+
+#define BIT_SHIFT_HCI_PCIE_C2H_MSG_8822B 0
+#define BIT_MASK_HCI_PCIE_C2H_MSG_8822B 0xffffffffL
+#define BIT_HCI_PCIE_C2H_MSG_8822B(x)                                          \
+	(((x) & BIT_MASK_HCI_PCIE_C2H_MSG_8822B)                               \
+	 << BIT_SHIFT_HCI_PCIE_C2H_MSG_8822B)
+#define BIT_GET_HCI_PCIE_C2H_MSG_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_HCI_PCIE_C2H_MSG_8822B) &                           \
+	 BIT_MASK_HCI_PCIE_C2H_MSG_8822B)
+
+/* 2 REG_DBI_WDATA_V1_8822B */
+
+#define BIT_SHIFT_DBI_WDATA_8822B 0
+#define BIT_MASK_DBI_WDATA_8822B 0xffffffffL
+#define BIT_DBI_WDATA_8822B(x)                                                 \
+	(((x) & BIT_MASK_DBI_WDATA_8822B) << BIT_SHIFT_DBI_WDATA_8822B)
+#define BIT_GET_DBI_WDATA_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_DBI_WDATA_8822B) & BIT_MASK_DBI_WDATA_8822B)
+
+/* 2 REG_DBI_RDATA_V1_8822B */
+
+#define BIT_SHIFT_DBI_RDATA_8822B 0
+#define BIT_MASK_DBI_RDATA_8822B 0xffffffffL
+#define BIT_DBI_RDATA_8822B(x)                                                 \
+	(((x) & BIT_MASK_DBI_RDATA_8822B) << BIT_SHIFT_DBI_RDATA_8822B)
+#define BIT_GET_DBI_RDATA_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_DBI_RDATA_8822B) & BIT_MASK_DBI_RDATA_8822B)
+
+/* 2 REG_DBI_FLAG_V1_8822B */
+#define BIT_EN_STUCK_DBG_8822B BIT(26)
+#define BIT_RX_STUCK_8822B BIT(25)
+#define BIT_TX_STUCK_8822B BIT(24)
+#define BIT_DBI_RFLAG_8822B BIT(17)
+#define BIT_DBI_WFLAG_8822B BIT(16)
+
+#define BIT_SHIFT_DBI_WREN_8822B 12
+#define BIT_MASK_DBI_WREN_8822B 0xf
+#define BIT_DBI_WREN_8822B(x)                                                  \
+	(((x) & BIT_MASK_DBI_WREN_8822B) << BIT_SHIFT_DBI_WREN_8822B)
+#define BIT_GET_DBI_WREN_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_DBI_WREN_8822B) & BIT_MASK_DBI_WREN_8822B)
+
+#define BIT_SHIFT_DBI_ADDR_8822B 0
+#define BIT_MASK_DBI_ADDR_8822B 0xfff
+#define BIT_DBI_ADDR_8822B(x)                                                  \
+	(((x) & BIT_MASK_DBI_ADDR_8822B) << BIT_SHIFT_DBI_ADDR_8822B)
+#define BIT_GET_DBI_ADDR_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_DBI_ADDR_8822B) & BIT_MASK_DBI_ADDR_8822B)
+
+/* 2 REG_MDIO_V1_8822B */
+
+#define BIT_SHIFT_MDIO_RDATA_8822B 16
+#define BIT_MASK_MDIO_RDATA_8822B 0xffff
+#define BIT_MDIO_RDATA_8822B(x)                                                \
+	(((x) & BIT_MASK_MDIO_RDATA_8822B) << BIT_SHIFT_MDIO_RDATA_8822B)
+#define BIT_GET_MDIO_RDATA_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_MDIO_RDATA_8822B) & BIT_MASK_MDIO_RDATA_8822B)
+
+#define BIT_SHIFT_MDIO_WDATA_8822B 0
+#define BIT_MASK_MDIO_WDATA_8822B 0xffff
+#define BIT_MDIO_WDATA_8822B(x)                                                \
+	(((x) & BIT_MASK_MDIO_WDATA_8822B) << BIT_SHIFT_MDIO_WDATA_8822B)
+#define BIT_GET_MDIO_WDATA_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_MDIO_WDATA_8822B) & BIT_MASK_MDIO_WDATA_8822B)
+
+/* 2 REG_PCIE_MIX_CFG_8822B */
+
+#define BIT_SHIFT_MDIO_PHY_ADDR_8822B 24
+#define BIT_MASK_MDIO_PHY_ADDR_8822B 0x1f
+#define BIT_MDIO_PHY_ADDR_8822B(x)                                             \
+	(((x) & BIT_MASK_MDIO_PHY_ADDR_8822B) << BIT_SHIFT_MDIO_PHY_ADDR_8822B)
+#define BIT_GET_MDIO_PHY_ADDR_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_MDIO_PHY_ADDR_8822B) & BIT_MASK_MDIO_PHY_ADDR_8822B)
+
+#define BIT_SHIFT_WATCH_DOG_RECORD_V1_8822B 10
+#define BIT_MASK_WATCH_DOG_RECORD_V1_8822B 0x3fff
+#define BIT_WATCH_DOG_RECORD_V1_8822B(x)                                       \
+	(((x) & BIT_MASK_WATCH_DOG_RECORD_V1_8822B)                            \
+	 << BIT_SHIFT_WATCH_DOG_RECORD_V1_8822B)
+#define BIT_GET_WATCH_DOG_RECORD_V1_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_WATCH_DOG_RECORD_V1_8822B) &                        \
+	 BIT_MASK_WATCH_DOG_RECORD_V1_8822B)
+
+#define BIT_R_IO_TIMEOUT_FLAG_V1_8822B BIT(9)
+#define BIT_EN_WATCH_DOG_8822B BIT(8)
+#define BIT_ECRC_EN_V1_8822B BIT(7)
+#define BIT_MDIO_RFLAG_V1_8822B BIT(6)
+#define BIT_MDIO_WFLAG_V1_8822B BIT(5)
+
+#define BIT_SHIFT_MDIO_REG_ADDR_V1_8822B 0
+#define BIT_MASK_MDIO_REG_ADDR_V1_8822B 0x1f
+#define BIT_MDIO_REG_ADDR_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_MDIO_REG_ADDR_V1_8822B)                               \
+	 << BIT_SHIFT_MDIO_REG_ADDR_V1_8822B)
+#define BIT_GET_MDIO_REG_ADDR_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_MDIO_REG_ADDR_V1_8822B) &                           \
+	 BIT_MASK_MDIO_REG_ADDR_V1_8822B)
+
+/* 2 REG_HCI_MIX_CFG_8822B */
+#define BIT_HOST_GEN2_SUPPORT_8822B BIT(20)
+
+#define BIT_SHIFT_TXDMA_ERR_FLAG_8822B 16
+#define BIT_MASK_TXDMA_ERR_FLAG_8822B 0xf
+#define BIT_TXDMA_ERR_FLAG_8822B(x)                                            \
+	(((x) & BIT_MASK_TXDMA_ERR_FLAG_8822B)                                 \
+	 << BIT_SHIFT_TXDMA_ERR_FLAG_8822B)
+#define BIT_GET_TXDMA_ERR_FLAG_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_TXDMA_ERR_FLAG_8822B) &                             \
+	 BIT_MASK_TXDMA_ERR_FLAG_8822B)
+
+#define BIT_SHIFT_EARLY_MODE_SEL_8822B 12
+#define BIT_MASK_EARLY_MODE_SEL_8822B 0xf
+#define BIT_EARLY_MODE_SEL_8822B(x)                                            \
+	(((x) & BIT_MASK_EARLY_MODE_SEL_8822B)                                 \
+	 << BIT_SHIFT_EARLY_MODE_SEL_8822B)
+#define BIT_GET_EARLY_MODE_SEL_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_EARLY_MODE_SEL_8822B) &                             \
+	 BIT_MASK_EARLY_MODE_SEL_8822B)
+
+#define BIT_EPHY_RX50_EN_8822B BIT(11)
+
+#define BIT_SHIFT_MSI_TIMEOUT_ID_V1_8822B 8
+#define BIT_MASK_MSI_TIMEOUT_ID_V1_8822B 0x7
+#define BIT_MSI_TIMEOUT_ID_V1_8822B(x)                                         \
+	(((x) & BIT_MASK_MSI_TIMEOUT_ID_V1_8822B)                              \
+	 << BIT_SHIFT_MSI_TIMEOUT_ID_V1_8822B)
+#define BIT_GET_MSI_TIMEOUT_ID_V1_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_MSI_TIMEOUT_ID_V1_8822B) &                          \
+	 BIT_MASK_MSI_TIMEOUT_ID_V1_8822B)
+
+#define BIT_RADDR_RD_8822B BIT(7)
+#define BIT_EN_MUL_TAG_8822B BIT(6)
+#define BIT_EN_EARLY_MODE_8822B BIT(5)
+#define BIT_L0S_LINK_OFF_8822B BIT(4)
+#define BIT_ACT_LINK_OFF_8822B BIT(3)
+#define BIT_EN_SLOW_MAC_TX_8822B BIT(2)
+#define BIT_EN_SLOW_MAC_RX_8822B BIT(1)
+
+/* 2 REG_STC_INT_CS_8822B(PCIE STATE CHANGE INTERRUPT CONTROL AND STATUS) */
+#define BIT_STC_INT_EN_8822B BIT(31)
+
+#define BIT_SHIFT_STC_INT_FLAG_8822B 16
+#define BIT_MASK_STC_INT_FLAG_8822B 0xff
+#define BIT_STC_INT_FLAG_8822B(x)                                              \
+	(((x) & BIT_MASK_STC_INT_FLAG_8822B) << BIT_SHIFT_STC_INT_FLAG_8822B)
+#define BIT_GET_STC_INT_FLAG_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_STC_INT_FLAG_8822B) & BIT_MASK_STC_INT_FLAG_8822B)
+
+#define BIT_SHIFT_STC_INT_IDX_8822B 8
+#define BIT_MASK_STC_INT_IDX_8822B 0x7
+#define BIT_STC_INT_IDX_8822B(x)                                               \
+	(((x) & BIT_MASK_STC_INT_IDX_8822B) << BIT_SHIFT_STC_INT_IDX_8822B)
+#define BIT_GET_STC_INT_IDX_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_STC_INT_IDX_8822B) & BIT_MASK_STC_INT_IDX_8822B)
+
+#define BIT_SHIFT_STC_INT_REALTIME_CS_8822B 0
+#define BIT_MASK_STC_INT_REALTIME_CS_8822B 0x3f
+#define BIT_STC_INT_REALTIME_CS_8822B(x)                                       \
+	(((x) & BIT_MASK_STC_INT_REALTIME_CS_8822B)                            \
+	 << BIT_SHIFT_STC_INT_REALTIME_CS_8822B)
+#define BIT_GET_STC_INT_REALTIME_CS_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_STC_INT_REALTIME_CS_8822B) &                        \
+	 BIT_MASK_STC_INT_REALTIME_CS_8822B)
+
+/* 2 REG_ST_INT_CFG_8822B(PCIE STATE CHANGE INTERRUPT CONFIGURATION) */
+#define BIT_STC_INT_GRP_EN_8822B BIT(31)
+
+#define BIT_SHIFT_STC_INT_EXPECT_LS_8822B 8
+#define BIT_MASK_STC_INT_EXPECT_LS_8822B 0x3f
+#define BIT_STC_INT_EXPECT_LS_8822B(x)                                         \
+	(((x) & BIT_MASK_STC_INT_EXPECT_LS_8822B)                              \
+	 << BIT_SHIFT_STC_INT_EXPECT_LS_8822B)
+#define BIT_GET_STC_INT_EXPECT_LS_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_STC_INT_EXPECT_LS_8822B) &                          \
+	 BIT_MASK_STC_INT_EXPECT_LS_8822B)
+
+#define BIT_SHIFT_STC_INT_EXPECT_CS_8822B 0
+#define BIT_MASK_STC_INT_EXPECT_CS_8822B 0x3f
+#define BIT_STC_INT_EXPECT_CS_8822B(x)                                         \
+	(((x) & BIT_MASK_STC_INT_EXPECT_CS_8822B)                              \
+	 << BIT_SHIFT_STC_INT_EXPECT_CS_8822B)
+#define BIT_GET_STC_INT_EXPECT_CS_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_STC_INT_EXPECT_CS_8822B) &                          \
+	 BIT_MASK_STC_INT_EXPECT_CS_8822B)
+
+/* 2 REG_CMU_DLY_CTRL_8822B(PCIE PHY CLOCK MGT UNIT DELAY CONTROL ) */
+#define BIT_CMU_DLY_EN_8822B BIT(31)
+#define BIT_CMU_DLY_MODE_8822B BIT(30)
+
+#define BIT_SHIFT_CMU_DLY_PRE_DIV_8822B 0
+#define BIT_MASK_CMU_DLY_PRE_DIV_8822B 0xff
+#define BIT_CMU_DLY_PRE_DIV_8822B(x)                                           \
+	(((x) & BIT_MASK_CMU_DLY_PRE_DIV_8822B)                                \
+	 << BIT_SHIFT_CMU_DLY_PRE_DIV_8822B)
+#define BIT_GET_CMU_DLY_PRE_DIV_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_CMU_DLY_PRE_DIV_8822B) &                            \
+	 BIT_MASK_CMU_DLY_PRE_DIV_8822B)
+
+/* 2 REG_CMU_DLY_CFG_8822B(PCIE PHY CLOCK MGT UNIT DELAY CONFIGURATION ) */
+
+#define BIT_SHIFT_CMU_DLY_LTR_A2I_8822B 24
+#define BIT_MASK_CMU_DLY_LTR_A2I_8822B 0xff
+#define BIT_CMU_DLY_LTR_A2I_8822B(x)                                           \
+	(((x) & BIT_MASK_CMU_DLY_LTR_A2I_8822B)                                \
+	 << BIT_SHIFT_CMU_DLY_LTR_A2I_8822B)
+#define BIT_GET_CMU_DLY_LTR_A2I_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_CMU_DLY_LTR_A2I_8822B) &                            \
+	 BIT_MASK_CMU_DLY_LTR_A2I_8822B)
+
+#define BIT_SHIFT_CMU_DLY_LTR_I2A_8822B 16
+#define BIT_MASK_CMU_DLY_LTR_I2A_8822B 0xff
+#define BIT_CMU_DLY_LTR_I2A_8822B(x)                                           \
+	(((x) & BIT_MASK_CMU_DLY_LTR_I2A_8822B)                                \
+	 << BIT_SHIFT_CMU_DLY_LTR_I2A_8822B)
+#define BIT_GET_CMU_DLY_LTR_I2A_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_CMU_DLY_LTR_I2A_8822B) &                            \
+	 BIT_MASK_CMU_DLY_LTR_I2A_8822B)
+
+#define BIT_SHIFT_CMU_DLY_LTR_IDLE_8822B 8
+#define BIT_MASK_CMU_DLY_LTR_IDLE_8822B 0xff
+#define BIT_CMU_DLY_LTR_IDLE_8822B(x)                                          \
+	(((x) & BIT_MASK_CMU_DLY_LTR_IDLE_8822B)                               \
+	 << BIT_SHIFT_CMU_DLY_LTR_IDLE_8822B)
+#define BIT_GET_CMU_DLY_LTR_IDLE_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_CMU_DLY_LTR_IDLE_8822B) &                           \
+	 BIT_MASK_CMU_DLY_LTR_IDLE_8822B)
+
+#define BIT_SHIFT_CMU_DLY_LTR_ACT_8822B 0
+#define BIT_MASK_CMU_DLY_LTR_ACT_8822B 0xff
+#define BIT_CMU_DLY_LTR_ACT_8822B(x)                                           \
+	(((x) & BIT_MASK_CMU_DLY_LTR_ACT_8822B)                                \
+	 << BIT_SHIFT_CMU_DLY_LTR_ACT_8822B)
+#define BIT_GET_CMU_DLY_LTR_ACT_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_CMU_DLY_LTR_ACT_8822B) &                            \
+	 BIT_MASK_CMU_DLY_LTR_ACT_8822B)
+
+/* 2 REG_H2CQ_TXBD_DESA_8822B */
+
+#define BIT_SHIFT_H2CQ_TXBD_DESA_8822B 0
+#define BIT_MASK_H2CQ_TXBD_DESA_8822B 0xffffffffffffffffL
+#define BIT_H2CQ_TXBD_DESA_8822B(x)                                            \
+	(((x) & BIT_MASK_H2CQ_TXBD_DESA_8822B)                                 \
+	 << BIT_SHIFT_H2CQ_TXBD_DESA_8822B)
+#define BIT_GET_H2CQ_TXBD_DESA_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_H2CQ_TXBD_DESA_8822B) &                             \
+	 BIT_MASK_H2CQ_TXBD_DESA_8822B)
+
+/* 2 REG_H2CQ_TXBD_NUM_8822B */
+#define BIT_PCIE_H2CQ_FLAG_8822B BIT(14)
+
+#define BIT_SHIFT_H2CQ_DESC_MODE_8822B 12
+#define BIT_MASK_H2CQ_DESC_MODE_8822B 0x3
+#define BIT_H2CQ_DESC_MODE_8822B(x)                                            \
+	(((x) & BIT_MASK_H2CQ_DESC_MODE_8822B)                                 \
+	 << BIT_SHIFT_H2CQ_DESC_MODE_8822B)
+#define BIT_GET_H2CQ_DESC_MODE_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_H2CQ_DESC_MODE_8822B) &                             \
+	 BIT_MASK_H2CQ_DESC_MODE_8822B)
+
+#define BIT_SHIFT_H2CQ_DESC_NUM_8822B 0
+#define BIT_MASK_H2CQ_DESC_NUM_8822B 0xfff
+#define BIT_H2CQ_DESC_NUM_8822B(x)                                             \
+	(((x) & BIT_MASK_H2CQ_DESC_NUM_8822B) << BIT_SHIFT_H2CQ_DESC_NUM_8822B)
+#define BIT_GET_H2CQ_DESC_NUM_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_H2CQ_DESC_NUM_8822B) & BIT_MASK_H2CQ_DESC_NUM_8822B)
+
+/* 2 REG_H2CQ_TXBD_IDX_8822B */
+
+#define BIT_SHIFT_H2CQ_HW_IDX_8822B 16
+#define BIT_MASK_H2CQ_HW_IDX_8822B 0xfff
+#define BIT_H2CQ_HW_IDX_8822B(x)                                               \
+	(((x) & BIT_MASK_H2CQ_HW_IDX_8822B) << BIT_SHIFT_H2CQ_HW_IDX_8822B)
+#define BIT_GET_H2CQ_HW_IDX_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_H2CQ_HW_IDX_8822B) & BIT_MASK_H2CQ_HW_IDX_8822B)
+
+#define BIT_SHIFT_H2CQ_HOST_IDX_8822B 0
+#define BIT_MASK_H2CQ_HOST_IDX_8822B 0xfff
+#define BIT_H2CQ_HOST_IDX_8822B(x)                                             \
+	(((x) & BIT_MASK_H2CQ_HOST_IDX_8822B) << BIT_SHIFT_H2CQ_HOST_IDX_8822B)
+#define BIT_GET_H2CQ_HOST_IDX_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_H2CQ_HOST_IDX_8822B) & BIT_MASK_H2CQ_HOST_IDX_8822B)
+
+/* 2 REG_H2CQ_CSR_8822B[31:0] (H2CQ CONTROL AND STATUS) */
+#define BIT_H2CQ_FULL_8822B BIT(31)
+#define BIT_CLR_H2CQ_HOST_IDX_8822B BIT(16)
+#define BIT_CLR_H2CQ_HW_IDX_8822B BIT(8)
+
+/* 2 REG_CHANGE_PCIE_SPEED_8822B */
+#define BIT_CHANGE_PCIE_SPEED_8822B BIT(18)
+
+#define BIT_SHIFT_GEN1_GEN2_8822B 16
+#define BIT_MASK_GEN1_GEN2_8822B 0x3
+#define BIT_GEN1_GEN2_8822B(x)                                                 \
+	(((x) & BIT_MASK_GEN1_GEN2_8822B) << BIT_SHIFT_GEN1_GEN2_8822B)
+#define BIT_GET_GEN1_GEN2_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_GEN1_GEN2_8822B) & BIT_MASK_GEN1_GEN2_8822B)
+
+#define BIT_SHIFT_AUTO_HANG_RELEASE_8822B 0
+#define BIT_MASK_AUTO_HANG_RELEASE_8822B 0x7
+#define BIT_AUTO_HANG_RELEASE_8822B(x)                                         \
+	(((x) & BIT_MASK_AUTO_HANG_RELEASE_8822B)                              \
+	 << BIT_SHIFT_AUTO_HANG_RELEASE_8822B)
+#define BIT_GET_AUTO_HANG_RELEASE_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_AUTO_HANG_RELEASE_8822B) &                          \
+	 BIT_MASK_AUTO_HANG_RELEASE_8822B)
+
+/* 2 REG_OLD_DEHANG_8822B */
+#define BIT_OLD_DEHANG_8822B BIT(1)
+
+/* 2 REG_Q0_INFO_8822B */
+
+#define BIT_SHIFT_QUEUEMACID_Q0_V1_8822B 25
+#define BIT_MASK_QUEUEMACID_Q0_V1_8822B 0x7f
+#define BIT_QUEUEMACID_Q0_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_QUEUEMACID_Q0_V1_8822B)                               \
+	 << BIT_SHIFT_QUEUEMACID_Q0_V1_8822B)
+#define BIT_GET_QUEUEMACID_Q0_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q0_V1_8822B) &                           \
+	 BIT_MASK_QUEUEMACID_Q0_V1_8822B)
+
+#define BIT_SHIFT_QUEUEAC_Q0_V1_8822B 23
+#define BIT_MASK_QUEUEAC_Q0_V1_8822B 0x3
+#define BIT_QUEUEAC_Q0_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_QUEUEAC_Q0_V1_8822B) << BIT_SHIFT_QUEUEAC_Q0_V1_8822B)
+#define BIT_GET_QUEUEAC_Q0_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q0_V1_8822B) & BIT_MASK_QUEUEAC_Q0_V1_8822B)
+
+#define BIT_TIDEMPTY_Q0_V1_8822B BIT(22)
+
+#define BIT_SHIFT_TAIL_PKT_Q0_V2_8822B 11
+#define BIT_MASK_TAIL_PKT_Q0_V2_8822B 0x7ff
+#define BIT_TAIL_PKT_Q0_V2_8822B(x)                                            \
+	(((x) & BIT_MASK_TAIL_PKT_Q0_V2_8822B)                                 \
+	 << BIT_SHIFT_TAIL_PKT_Q0_V2_8822B)
+#define BIT_GET_TAIL_PKT_Q0_V2_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q0_V2_8822B) &                             \
+	 BIT_MASK_TAIL_PKT_Q0_V2_8822B)
+
+#define BIT_SHIFT_HEAD_PKT_Q0_V1_8822B 0
+#define BIT_MASK_HEAD_PKT_Q0_V1_8822B 0x7ff
+#define BIT_HEAD_PKT_Q0_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_HEAD_PKT_Q0_V1_8822B)                                 \
+	 << BIT_SHIFT_HEAD_PKT_Q0_V1_8822B)
+#define BIT_GET_HEAD_PKT_Q0_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q0_V1_8822B) &                             \
+	 BIT_MASK_HEAD_PKT_Q0_V1_8822B)
+
+/* 2 REG_Q1_INFO_8822B */
+
+#define BIT_SHIFT_QUEUEMACID_Q1_V1_8822B 25
+#define BIT_MASK_QUEUEMACID_Q1_V1_8822B 0x7f
+#define BIT_QUEUEMACID_Q1_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_QUEUEMACID_Q1_V1_8822B)                               \
+	 << BIT_SHIFT_QUEUEMACID_Q1_V1_8822B)
+#define BIT_GET_QUEUEMACID_Q1_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q1_V1_8822B) &                           \
+	 BIT_MASK_QUEUEMACID_Q1_V1_8822B)
+
+#define BIT_SHIFT_QUEUEAC_Q1_V1_8822B 23
+#define BIT_MASK_QUEUEAC_Q1_V1_8822B 0x3
+#define BIT_QUEUEAC_Q1_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_QUEUEAC_Q1_V1_8822B) << BIT_SHIFT_QUEUEAC_Q1_V1_8822B)
+#define BIT_GET_QUEUEAC_Q1_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q1_V1_8822B) & BIT_MASK_QUEUEAC_Q1_V1_8822B)
+
+#define BIT_TIDEMPTY_Q1_V1_8822B BIT(22)
+
+#define BIT_SHIFT_TAIL_PKT_Q1_V2_8822B 11
+#define BIT_MASK_TAIL_PKT_Q1_V2_8822B 0x7ff
+#define BIT_TAIL_PKT_Q1_V2_8822B(x)                                            \
+	(((x) & BIT_MASK_TAIL_PKT_Q1_V2_8822B)                                 \
+	 << BIT_SHIFT_TAIL_PKT_Q1_V2_8822B)
+#define BIT_GET_TAIL_PKT_Q1_V2_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q1_V2_8822B) &                             \
+	 BIT_MASK_TAIL_PKT_Q1_V2_8822B)
+
+#define BIT_SHIFT_HEAD_PKT_Q1_V1_8822B 0
+#define BIT_MASK_HEAD_PKT_Q1_V1_8822B 0x7ff
+#define BIT_HEAD_PKT_Q1_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_HEAD_PKT_Q1_V1_8822B)                                 \
+	 << BIT_SHIFT_HEAD_PKT_Q1_V1_8822B)
+#define BIT_GET_HEAD_PKT_Q1_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q1_V1_8822B) &                             \
+	 BIT_MASK_HEAD_PKT_Q1_V1_8822B)
+
+/* 2 REG_Q2_INFO_8822B */
+
+#define BIT_SHIFT_QUEUEMACID_Q2_V1_8822B 25
+#define BIT_MASK_QUEUEMACID_Q2_V1_8822B 0x7f
+#define BIT_QUEUEMACID_Q2_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_QUEUEMACID_Q2_V1_8822B)                               \
+	 << BIT_SHIFT_QUEUEMACID_Q2_V1_8822B)
+#define BIT_GET_QUEUEMACID_Q2_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q2_V1_8822B) &                           \
+	 BIT_MASK_QUEUEMACID_Q2_V1_8822B)
+
+#define BIT_SHIFT_QUEUEAC_Q2_V1_8822B 23
+#define BIT_MASK_QUEUEAC_Q2_V1_8822B 0x3
+#define BIT_QUEUEAC_Q2_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_QUEUEAC_Q2_V1_8822B) << BIT_SHIFT_QUEUEAC_Q2_V1_8822B)
+#define BIT_GET_QUEUEAC_Q2_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q2_V1_8822B) & BIT_MASK_QUEUEAC_Q2_V1_8822B)
+
+#define BIT_TIDEMPTY_Q2_V1_8822B BIT(22)
+
+#define BIT_SHIFT_TAIL_PKT_Q2_V2_8822B 11
+#define BIT_MASK_TAIL_PKT_Q2_V2_8822B 0x7ff
+#define BIT_TAIL_PKT_Q2_V2_8822B(x)                                            \
+	(((x) & BIT_MASK_TAIL_PKT_Q2_V2_8822B)                                 \
+	 << BIT_SHIFT_TAIL_PKT_Q2_V2_8822B)
+#define BIT_GET_TAIL_PKT_Q2_V2_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q2_V2_8822B) &                             \
+	 BIT_MASK_TAIL_PKT_Q2_V2_8822B)
+
+#define BIT_SHIFT_HEAD_PKT_Q2_V1_8822B 0
+#define BIT_MASK_HEAD_PKT_Q2_V1_8822B 0x7ff
+#define BIT_HEAD_PKT_Q2_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_HEAD_PKT_Q2_V1_8822B)                                 \
+	 << BIT_SHIFT_HEAD_PKT_Q2_V1_8822B)
+#define BIT_GET_HEAD_PKT_Q2_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q2_V1_8822B) &                             \
+	 BIT_MASK_HEAD_PKT_Q2_V1_8822B)
+
+/* 2 REG_Q3_INFO_8822B */
+
+#define BIT_SHIFT_QUEUEMACID_Q3_V1_8822B 25
+#define BIT_MASK_QUEUEMACID_Q3_V1_8822B 0x7f
+#define BIT_QUEUEMACID_Q3_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_QUEUEMACID_Q3_V1_8822B)                               \
+	 << BIT_SHIFT_QUEUEMACID_Q3_V1_8822B)
+#define BIT_GET_QUEUEMACID_Q3_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q3_V1_8822B) &                           \
+	 BIT_MASK_QUEUEMACID_Q3_V1_8822B)
+
+#define BIT_SHIFT_QUEUEAC_Q3_V1_8822B 23
+#define BIT_MASK_QUEUEAC_Q3_V1_8822B 0x3
+#define BIT_QUEUEAC_Q3_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_QUEUEAC_Q3_V1_8822B) << BIT_SHIFT_QUEUEAC_Q3_V1_8822B)
+#define BIT_GET_QUEUEAC_Q3_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q3_V1_8822B) & BIT_MASK_QUEUEAC_Q3_V1_8822B)
+
+#define BIT_TIDEMPTY_Q3_V1_8822B BIT(22)
+
+#define BIT_SHIFT_TAIL_PKT_Q3_V2_8822B 11
+#define BIT_MASK_TAIL_PKT_Q3_V2_8822B 0x7ff
+#define BIT_TAIL_PKT_Q3_V2_8822B(x)                                            \
+	(((x) & BIT_MASK_TAIL_PKT_Q3_V2_8822B)                                 \
+	 << BIT_SHIFT_TAIL_PKT_Q3_V2_8822B)
+#define BIT_GET_TAIL_PKT_Q3_V2_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q3_V2_8822B) &                             \
+	 BIT_MASK_TAIL_PKT_Q3_V2_8822B)
+
+#define BIT_SHIFT_HEAD_PKT_Q3_V1_8822B 0
+#define BIT_MASK_HEAD_PKT_Q3_V1_8822B 0x7ff
+#define BIT_HEAD_PKT_Q3_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_HEAD_PKT_Q3_V1_8822B)                                 \
+	 << BIT_SHIFT_HEAD_PKT_Q3_V1_8822B)
+#define BIT_GET_HEAD_PKT_Q3_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q3_V1_8822B) &                             \
+	 BIT_MASK_HEAD_PKT_Q3_V1_8822B)
+
+/* 2 REG_MGQ_INFO_8822B */
+
+#define BIT_SHIFT_QUEUEMACID_MGQ_V1_8822B 25
+#define BIT_MASK_QUEUEMACID_MGQ_V1_8822B 0x7f
+#define BIT_QUEUEMACID_MGQ_V1_8822B(x)                                         \
+	(((x) & BIT_MASK_QUEUEMACID_MGQ_V1_8822B)                              \
+	 << BIT_SHIFT_QUEUEMACID_MGQ_V1_8822B)
+#define BIT_GET_QUEUEMACID_MGQ_V1_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_QUEUEMACID_MGQ_V1_8822B) &                          \
+	 BIT_MASK_QUEUEMACID_MGQ_V1_8822B)
+
+#define BIT_SHIFT_QUEUEAC_MGQ_V1_8822B 23
+#define BIT_MASK_QUEUEAC_MGQ_V1_8822B 0x3
+#define BIT_QUEUEAC_MGQ_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_QUEUEAC_MGQ_V1_8822B)                                 \
+	 << BIT_SHIFT_QUEUEAC_MGQ_V1_8822B)
+#define BIT_GET_QUEUEAC_MGQ_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_QUEUEAC_MGQ_V1_8822B) &                             \
+	 BIT_MASK_QUEUEAC_MGQ_V1_8822B)
+
+#define BIT_TIDEMPTY_MGQ_V1_8822B BIT(22)
+
+#define BIT_SHIFT_TAIL_PKT_MGQ_V2_8822B 11
+#define BIT_MASK_TAIL_PKT_MGQ_V2_8822B 0x7ff
+#define BIT_TAIL_PKT_MGQ_V2_8822B(x)                                           \
+	(((x) & BIT_MASK_TAIL_PKT_MGQ_V2_8822B)                                \
+	 << BIT_SHIFT_TAIL_PKT_MGQ_V2_8822B)
+#define BIT_GET_TAIL_PKT_MGQ_V2_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_TAIL_PKT_MGQ_V2_8822B) &                            \
+	 BIT_MASK_TAIL_PKT_MGQ_V2_8822B)
+
+#define BIT_SHIFT_HEAD_PKT_MGQ_V1_8822B 0
+#define BIT_MASK_HEAD_PKT_MGQ_V1_8822B 0x7ff
+#define BIT_HEAD_PKT_MGQ_V1_8822B(x)                                           \
+	(((x) & BIT_MASK_HEAD_PKT_MGQ_V1_8822B)                                \
+	 << BIT_SHIFT_HEAD_PKT_MGQ_V1_8822B)
+#define BIT_GET_HEAD_PKT_MGQ_V1_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_HEAD_PKT_MGQ_V1_8822B) &                            \
+	 BIT_MASK_HEAD_PKT_MGQ_V1_8822B)
+
+/* 2 REG_HIQ_INFO_8822B */
+
+#define BIT_SHIFT_QUEUEMACID_HIQ_V1_8822B 25
+#define BIT_MASK_QUEUEMACID_HIQ_V1_8822B 0x7f
+#define BIT_QUEUEMACID_HIQ_V1_8822B(x)                                         \
+	(((x) & BIT_MASK_QUEUEMACID_HIQ_V1_8822B)                              \
+	 << BIT_SHIFT_QUEUEMACID_HIQ_V1_8822B)
+#define BIT_GET_QUEUEMACID_HIQ_V1_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_QUEUEMACID_HIQ_V1_8822B) &                          \
+	 BIT_MASK_QUEUEMACID_HIQ_V1_8822B)
+
+#define BIT_SHIFT_QUEUEAC_HIQ_V1_8822B 23
+#define BIT_MASK_QUEUEAC_HIQ_V1_8822B 0x3
+#define BIT_QUEUEAC_HIQ_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_QUEUEAC_HIQ_V1_8822B)                                 \
+	 << BIT_SHIFT_QUEUEAC_HIQ_V1_8822B)
+#define BIT_GET_QUEUEAC_HIQ_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_QUEUEAC_HIQ_V1_8822B) &                             \
+	 BIT_MASK_QUEUEAC_HIQ_V1_8822B)
+
+#define BIT_TIDEMPTY_HIQ_V1_8822B BIT(22)
+
+#define BIT_SHIFT_TAIL_PKT_HIQ_V2_8822B 11
+#define BIT_MASK_TAIL_PKT_HIQ_V2_8822B 0x7ff
+#define BIT_TAIL_PKT_HIQ_V2_8822B(x)                                           \
+	(((x) & BIT_MASK_TAIL_PKT_HIQ_V2_8822B)                                \
+	 << BIT_SHIFT_TAIL_PKT_HIQ_V2_8822B)
+#define BIT_GET_TAIL_PKT_HIQ_V2_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_TAIL_PKT_HIQ_V2_8822B) &                            \
+	 BIT_MASK_TAIL_PKT_HIQ_V2_8822B)
+
+#define BIT_SHIFT_HEAD_PKT_HIQ_V1_8822B 0
+#define BIT_MASK_HEAD_PKT_HIQ_V1_8822B 0x7ff
+#define BIT_HEAD_PKT_HIQ_V1_8822B(x)                                           \
+	(((x) & BIT_MASK_HEAD_PKT_HIQ_V1_8822B)                                \
+	 << BIT_SHIFT_HEAD_PKT_HIQ_V1_8822B)
+#define BIT_GET_HEAD_PKT_HIQ_V1_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_HEAD_PKT_HIQ_V1_8822B) &                            \
+	 BIT_MASK_HEAD_PKT_HIQ_V1_8822B)
+
+/* 2 REG_BCNQ_INFO_8822B */
+
+#define BIT_SHIFT_BCNQ_HEAD_PG_V1_8822B 0
+#define BIT_MASK_BCNQ_HEAD_PG_V1_8822B 0xfff
+#define BIT_BCNQ_HEAD_PG_V1_8822B(x)                                           \
+	(((x) & BIT_MASK_BCNQ_HEAD_PG_V1_8822B)                                \
+	 << BIT_SHIFT_BCNQ_HEAD_PG_V1_8822B)
+#define BIT_GET_BCNQ_HEAD_PG_V1_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_BCNQ_HEAD_PG_V1_8822B) &                            \
+	 BIT_MASK_BCNQ_HEAD_PG_V1_8822B)
+
+/* 2 REG_TXPKT_EMPTY_8822B */
+#define BIT_BCNQ_EMPTY_8822B BIT(11)
+#define BIT_HQQ_EMPTY_8822B BIT(10)
+#define BIT_MQQ_EMPTY_8822B BIT(9)
+#define BIT_MGQ_CPU_EMPTY_8822B BIT(8)
+#define BIT_AC7Q_EMPTY_8822B BIT(7)
+#define BIT_AC6Q_EMPTY_8822B BIT(6)
+#define BIT_AC5Q_EMPTY_8822B BIT(5)
+#define BIT_AC4Q_EMPTY_8822B BIT(4)
+#define BIT_AC3Q_EMPTY_8822B BIT(3)
+#define BIT_AC2Q_EMPTY_8822B BIT(2)
+#define BIT_AC1Q_EMPTY_8822B BIT(1)
+#define BIT_AC0Q_EMPTY_8822B BIT(0)
+
+/* 2 REG_CPU_MGQ_INFO_8822B */
+#define BIT_BCN1_POLL_8822B BIT(30)
+#define BIT_CPUMGT_POLL_8822B BIT(29)
+#define BIT_BCN_POLL_8822B BIT(28)
+#define BIT_CPUMGQ_FW_NUM_V1_8822B BIT(12)
+
+#define BIT_SHIFT_FW_FREE_TAIL_V1_8822B 0
+#define BIT_MASK_FW_FREE_TAIL_V1_8822B 0xfff
+#define BIT_FW_FREE_TAIL_V1_8822B(x)                                           \
+	(((x) & BIT_MASK_FW_FREE_TAIL_V1_8822B)                                \
+	 << BIT_SHIFT_FW_FREE_TAIL_V1_8822B)
+#define BIT_GET_FW_FREE_TAIL_V1_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_FW_FREE_TAIL_V1_8822B) &                            \
+	 BIT_MASK_FW_FREE_TAIL_V1_8822B)
+
+/* 2 REG_FWHW_TXQ_CTRL_8822B */
+#define BIT_RTS_LIMIT_IN_OFDM_8822B BIT(23)
+#define BIT_EN_BCNQ_DL_8822B BIT(22)
+#define BIT_EN_RD_RESP_NAV_BK_8822B BIT(21)
+#define BIT_EN_WR_FREE_TAIL_8822B BIT(20)
+
+#define BIT_SHIFT_EN_QUEUE_RPT_8822B 8
+#define BIT_MASK_EN_QUEUE_RPT_8822B 0xff
+#define BIT_EN_QUEUE_RPT_8822B(x)                                              \
+	(((x) & BIT_MASK_EN_QUEUE_RPT_8822B) << BIT_SHIFT_EN_QUEUE_RPT_8822B)
+#define BIT_GET_EN_QUEUE_RPT_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_EN_QUEUE_RPT_8822B) & BIT_MASK_EN_QUEUE_RPT_8822B)
+
+#define BIT_EN_RTY_BK_8822B BIT(7)
+#define BIT_EN_USE_INI_RAT_8822B BIT(6)
+#define BIT_EN_RTS_NAV_BK_8822B BIT(5)
+#define BIT_DIS_SSN_CHECK_8822B BIT(4)
+#define BIT_MACID_MATCH_RTS_8822B BIT(3)
+#define BIT_EN_BCN_TRXRPT_V1_8822B BIT(2)
+#define BIT_EN_FTMACKRPT_8822B BIT(1)
+#define BIT_EN_FTMRPT_8822B BIT(0)
+
+/* 2 REG_DATAFB_SEL_8822B */
+#define BIT__R_EN_RTY_BK_COD_8822B BIT(2)
+
+#define BIT_SHIFT__R_DATA_FALLBACK_SEL_8822B 0
+#define BIT_MASK__R_DATA_FALLBACK_SEL_8822B 0x3
+#define BIT__R_DATA_FALLBACK_SEL_8822B(x)                                      \
+	(((x) & BIT_MASK__R_DATA_FALLBACK_SEL_8822B)                           \
+	 << BIT_SHIFT__R_DATA_FALLBACK_SEL_8822B)
+#define BIT_GET__R_DATA_FALLBACK_SEL_8822B(x)                                  \
+	(((x) >> BIT_SHIFT__R_DATA_FALLBACK_SEL_8822B) &                       \
+	 BIT_MASK__R_DATA_FALLBACK_SEL_8822B)
+
+/* 2 REG_BCNQ_BDNY_V1_8822B */
+
+#define BIT_SHIFT_BCNQ_PGBNDY_V1_8822B 0
+#define BIT_MASK_BCNQ_PGBNDY_V1_8822B 0xfff
+#define BIT_BCNQ_PGBNDY_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_BCNQ_PGBNDY_V1_8822B)                                 \
+	 << BIT_SHIFT_BCNQ_PGBNDY_V1_8822B)
+#define BIT_GET_BCNQ_PGBNDY_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_BCNQ_PGBNDY_V1_8822B) &                             \
+	 BIT_MASK_BCNQ_PGBNDY_V1_8822B)
+
+/* 2 REG_LIFETIME_EN_8822B */
+#define BIT_BT_INT_CPU_8822B BIT(7)
+#define BIT_BT_INT_PTA_8822B BIT(6)
+#define BIT_EN_CTRL_RTYBIT_8822B BIT(4)
+#define BIT_LIFETIME_BK_EN_8822B BIT(3)
+#define BIT_LIFETIME_BE_EN_8822B BIT(2)
+#define BIT_LIFETIME_VI_EN_8822B BIT(1)
+#define BIT_LIFETIME_VO_EN_8822B BIT(0)
+
+/* 2 REG_SPEC_SIFS_8822B */
+
+#define BIT_SHIFT_SPEC_SIFS_OFDM_PTCL_8822B 8
+#define BIT_MASK_SPEC_SIFS_OFDM_PTCL_8822B 0xff
+#define BIT_SPEC_SIFS_OFDM_PTCL_8822B(x)                                       \
+	(((x) & BIT_MASK_SPEC_SIFS_OFDM_PTCL_8822B)                            \
+	 << BIT_SHIFT_SPEC_SIFS_OFDM_PTCL_8822B)
+#define BIT_GET_SPEC_SIFS_OFDM_PTCL_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_SPEC_SIFS_OFDM_PTCL_8822B) &                        \
+	 BIT_MASK_SPEC_SIFS_OFDM_PTCL_8822B)
+
+#define BIT_SHIFT_SPEC_SIFS_CCK_PTCL_8822B 0
+#define BIT_MASK_SPEC_SIFS_CCK_PTCL_8822B 0xff
+#define BIT_SPEC_SIFS_CCK_PTCL_8822B(x)                                        \
+	(((x) & BIT_MASK_SPEC_SIFS_CCK_PTCL_8822B)                             \
+	 << BIT_SHIFT_SPEC_SIFS_CCK_PTCL_8822B)
+#define BIT_GET_SPEC_SIFS_CCK_PTCL_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_SPEC_SIFS_CCK_PTCL_8822B) &                         \
+	 BIT_MASK_SPEC_SIFS_CCK_PTCL_8822B)
+
+/* 2 REG_RETRY_LIMIT_8822B */
+
+#define BIT_SHIFT_SRL_8822B 8
+#define BIT_MASK_SRL_8822B 0x3f
+#define BIT_SRL_8822B(x) (((x) & BIT_MASK_SRL_8822B) << BIT_SHIFT_SRL_8822B)
+#define BIT_GET_SRL_8822B(x) (((x) >> BIT_SHIFT_SRL_8822B) & BIT_MASK_SRL_8822B)
+
+#define BIT_SHIFT_LRL_8822B 0
+#define BIT_MASK_LRL_8822B 0x3f
+#define BIT_LRL_8822B(x) (((x) & BIT_MASK_LRL_8822B) << BIT_SHIFT_LRL_8822B)
+#define BIT_GET_LRL_8822B(x) (((x) >> BIT_SHIFT_LRL_8822B) & BIT_MASK_LRL_8822B)
+
+/* 2 REG_TXBF_CTRL_8822B */
+#define BIT_R_ENABLE_NDPA_8822B BIT(31)
+#define BIT_USE_NDPA_PARAMETER_8822B BIT(30)
+#define BIT_R_PROP_TXBF_8822B BIT(29)
+#define BIT_R_EN_NDPA_INT_8822B BIT(28)
+#define BIT_R_TXBF1_80M_8822B BIT(27)
+#define BIT_R_TXBF1_40M_8822B BIT(26)
+#define BIT_R_TXBF1_20M_8822B BIT(25)
+
+#define BIT_SHIFT_R_TXBF1_AID_8822B 16
+#define BIT_MASK_R_TXBF1_AID_8822B 0x1ff
+#define BIT_R_TXBF1_AID_8822B(x)                                               \
+	(((x) & BIT_MASK_R_TXBF1_AID_8822B) << BIT_SHIFT_R_TXBF1_AID_8822B)
+#define BIT_GET_R_TXBF1_AID_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_R_TXBF1_AID_8822B) & BIT_MASK_R_TXBF1_AID_8822B)
+
+#define BIT_DIS_NDP_BFEN_8822B BIT(15)
+#define BIT_R_TXBCN_NOBLOCK_NDP_8822B BIT(14)
+#define BIT_R_TXBF0_80M_8822B BIT(11)
+#define BIT_R_TXBF0_40M_8822B BIT(10)
+#define BIT_R_TXBF0_20M_8822B BIT(9)
+
+#define BIT_SHIFT_R_TXBF0_AID_8822B 0
+#define BIT_MASK_R_TXBF0_AID_8822B 0x1ff
+#define BIT_R_TXBF0_AID_8822B(x)                                               \
+	(((x) & BIT_MASK_R_TXBF0_AID_8822B) << BIT_SHIFT_R_TXBF0_AID_8822B)
+#define BIT_GET_R_TXBF0_AID_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_R_TXBF0_AID_8822B) & BIT_MASK_R_TXBF0_AID_8822B)
+
+/* 2 REG_DARFRC_8822B */
+
+#define BIT_SHIFT_DARF_RC8_8822B (56 & CPU_OPT_WIDTH)
+#define BIT_MASK_DARF_RC8_8822B 0x1f
+#define BIT_DARF_RC8_8822B(x)                                                  \
+	(((x) & BIT_MASK_DARF_RC8_8822B) << BIT_SHIFT_DARF_RC8_8822B)
+#define BIT_GET_DARF_RC8_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_DARF_RC8_8822B) & BIT_MASK_DARF_RC8_8822B)
+
+#define BIT_SHIFT_DARF_RC7_8822B (48 & CPU_OPT_WIDTH)
+#define BIT_MASK_DARF_RC7_8822B 0x1f
+#define BIT_DARF_RC7_8822B(x)                                                  \
+	(((x) & BIT_MASK_DARF_RC7_8822B) << BIT_SHIFT_DARF_RC7_8822B)
+#define BIT_GET_DARF_RC7_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_DARF_RC7_8822B) & BIT_MASK_DARF_RC7_8822B)
+
+#define BIT_SHIFT_DARF_RC6_8822B (40 & CPU_OPT_WIDTH)
+#define BIT_MASK_DARF_RC6_8822B 0x1f
+#define BIT_DARF_RC6_8822B(x)                                                  \
+	(((x) & BIT_MASK_DARF_RC6_8822B) << BIT_SHIFT_DARF_RC6_8822B)
+#define BIT_GET_DARF_RC6_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_DARF_RC6_8822B) & BIT_MASK_DARF_RC6_8822B)
+
+#define BIT_SHIFT_DARF_RC5_8822B (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_DARF_RC5_8822B 0x1f
+#define BIT_DARF_RC5_8822B(x)                                                  \
+	(((x) & BIT_MASK_DARF_RC5_8822B) << BIT_SHIFT_DARF_RC5_8822B)
+#define BIT_GET_DARF_RC5_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_DARF_RC5_8822B) & BIT_MASK_DARF_RC5_8822B)
+
+#define BIT_SHIFT_DARF_RC4_8822B 24
+#define BIT_MASK_DARF_RC4_8822B 0x1f
+#define BIT_DARF_RC4_8822B(x)                                                  \
+	(((x) & BIT_MASK_DARF_RC4_8822B) << BIT_SHIFT_DARF_RC4_8822B)
+#define BIT_GET_DARF_RC4_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_DARF_RC4_8822B) & BIT_MASK_DARF_RC4_8822B)
+
+#define BIT_SHIFT_DARF_RC3_8822B 16
+#define BIT_MASK_DARF_RC3_8822B 0x1f
+#define BIT_DARF_RC3_8822B(x)                                                  \
+	(((x) & BIT_MASK_DARF_RC3_8822B) << BIT_SHIFT_DARF_RC3_8822B)
+#define BIT_GET_DARF_RC3_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_DARF_RC3_8822B) & BIT_MASK_DARF_RC3_8822B)
+
+#define BIT_SHIFT_DARF_RC2_8822B 8
+#define BIT_MASK_DARF_RC2_8822B 0x1f
+#define BIT_DARF_RC2_8822B(x)                                                  \
+	(((x) & BIT_MASK_DARF_RC2_8822B) << BIT_SHIFT_DARF_RC2_8822B)
+#define BIT_GET_DARF_RC2_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_DARF_RC2_8822B) & BIT_MASK_DARF_RC2_8822B)
+
+#define BIT_SHIFT_DARF_RC1_8822B 0
+#define BIT_MASK_DARF_RC1_8822B 0x1f
+#define BIT_DARF_RC1_8822B(x)                                                  \
+	(((x) & BIT_MASK_DARF_RC1_8822B) << BIT_SHIFT_DARF_RC1_8822B)
+#define BIT_GET_DARF_RC1_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_DARF_RC1_8822B) & BIT_MASK_DARF_RC1_8822B)
+
+/* 2 REG_RARFRC_8822B */
+
+#define BIT_SHIFT_RARF_RC8_8822B (56 & CPU_OPT_WIDTH)
+#define BIT_MASK_RARF_RC8_8822B 0x1f
+#define BIT_RARF_RC8_8822B(x)                                                  \
+	(((x) & BIT_MASK_RARF_RC8_8822B) << BIT_SHIFT_RARF_RC8_8822B)
+#define BIT_GET_RARF_RC8_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_RARF_RC8_8822B) & BIT_MASK_RARF_RC8_8822B)
+
+#define BIT_SHIFT_RARF_RC7_8822B (48 & CPU_OPT_WIDTH)
+#define BIT_MASK_RARF_RC7_8822B 0x1f
+#define BIT_RARF_RC7_8822B(x)                                                  \
+	(((x) & BIT_MASK_RARF_RC7_8822B) << BIT_SHIFT_RARF_RC7_8822B)
+#define BIT_GET_RARF_RC7_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_RARF_RC7_8822B) & BIT_MASK_RARF_RC7_8822B)
+
+#define BIT_SHIFT_RARF_RC6_8822B (40 & CPU_OPT_WIDTH)
+#define BIT_MASK_RARF_RC6_8822B 0x1f
+#define BIT_RARF_RC6_8822B(x)                                                  \
+	(((x) & BIT_MASK_RARF_RC6_8822B) << BIT_SHIFT_RARF_RC6_8822B)
+#define BIT_GET_RARF_RC6_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_RARF_RC6_8822B) & BIT_MASK_RARF_RC6_8822B)
+
+#define BIT_SHIFT_RARF_RC5_8822B (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_RARF_RC5_8822B 0x1f
+#define BIT_RARF_RC5_8822B(x)                                                  \
+	(((x) & BIT_MASK_RARF_RC5_8822B) << BIT_SHIFT_RARF_RC5_8822B)
+#define BIT_GET_RARF_RC5_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_RARF_RC5_8822B) & BIT_MASK_RARF_RC5_8822B)
+
+#define BIT_SHIFT_RARF_RC4_8822B 24
+#define BIT_MASK_RARF_RC4_8822B 0x1f
+#define BIT_RARF_RC4_8822B(x)                                                  \
+	(((x) & BIT_MASK_RARF_RC4_8822B) << BIT_SHIFT_RARF_RC4_8822B)
+#define BIT_GET_RARF_RC4_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_RARF_RC4_8822B) & BIT_MASK_RARF_RC4_8822B)
+
+#define BIT_SHIFT_RARF_RC3_8822B 16
+#define BIT_MASK_RARF_RC3_8822B 0x1f
+#define BIT_RARF_RC3_8822B(x)                                                  \
+	(((x) & BIT_MASK_RARF_RC3_8822B) << BIT_SHIFT_RARF_RC3_8822B)
+#define BIT_GET_RARF_RC3_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_RARF_RC3_8822B) & BIT_MASK_RARF_RC3_8822B)
+
+#define BIT_SHIFT_RARF_RC2_8822B 8
+#define BIT_MASK_RARF_RC2_8822B 0x1f
+#define BIT_RARF_RC2_8822B(x)                                                  \
+	(((x) & BIT_MASK_RARF_RC2_8822B) << BIT_SHIFT_RARF_RC2_8822B)
+#define BIT_GET_RARF_RC2_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_RARF_RC2_8822B) & BIT_MASK_RARF_RC2_8822B)
+
+#define BIT_SHIFT_RARF_RC1_8822B 0
+#define BIT_MASK_RARF_RC1_8822B 0x1f
+#define BIT_RARF_RC1_8822B(x)                                                  \
+	(((x) & BIT_MASK_RARF_RC1_8822B) << BIT_SHIFT_RARF_RC1_8822B)
+#define BIT_GET_RARF_RC1_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_RARF_RC1_8822B) & BIT_MASK_RARF_RC1_8822B)
+
+/* 2 REG_RRSR_8822B */
+
+#define BIT_SHIFT_RRSR_RSC_8822B 21
+#define BIT_MASK_RRSR_RSC_8822B 0x3
+#define BIT_RRSR_RSC_8822B(x)                                                  \
+	(((x) & BIT_MASK_RRSR_RSC_8822B) << BIT_SHIFT_RRSR_RSC_8822B)
+#define BIT_GET_RRSR_RSC_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_RRSR_RSC_8822B) & BIT_MASK_RRSR_RSC_8822B)
+
+#define BIT_RRSR_BW_8822B BIT(20)
+
+#define BIT_SHIFT_RRSC_BITMAP_8822B 0
+#define BIT_MASK_RRSC_BITMAP_8822B 0xfffff
+#define BIT_RRSC_BITMAP_8822B(x)                                               \
+	(((x) & BIT_MASK_RRSC_BITMAP_8822B) << BIT_SHIFT_RRSC_BITMAP_8822B)
+#define BIT_GET_RRSC_BITMAP_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_RRSC_BITMAP_8822B) & BIT_MASK_RRSC_BITMAP_8822B)
+
+/* 2 REG_ARFR0_8822B */
+
+#define BIT_SHIFT_ARFR0_V1_8822B 0
+#define BIT_MASK_ARFR0_V1_8822B 0xffffffffffffffffL
+#define BIT_ARFR0_V1_8822B(x)                                                  \
+	(((x) & BIT_MASK_ARFR0_V1_8822B) << BIT_SHIFT_ARFR0_V1_8822B)
+#define BIT_GET_ARFR0_V1_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_ARFR0_V1_8822B) & BIT_MASK_ARFR0_V1_8822B)
+
+/* 2 REG_ARFR1_V1_8822B */
+
+#define BIT_SHIFT_ARFR1_V1_8822B 0
+#define BIT_MASK_ARFR1_V1_8822B 0xffffffffffffffffL
+#define BIT_ARFR1_V1_8822B(x)                                                  \
+	(((x) & BIT_MASK_ARFR1_V1_8822B) << BIT_SHIFT_ARFR1_V1_8822B)
+#define BIT_GET_ARFR1_V1_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_ARFR1_V1_8822B) & BIT_MASK_ARFR1_V1_8822B)
+
+/* 2 REG_CCK_CHECK_8822B */
+#define BIT_CHECK_CCK_EN_8822B BIT(7)
+#define BIT_EN_BCN_PKT_REL_8822B BIT(6)
+#define BIT_BCN_PORT_SEL_8822B BIT(5)
+#define BIT_MOREDATA_BYPASS_8822B BIT(4)
+#define BIT_EN_CLR_CMD_REL_BCN_PKT_8822B BIT(3)
+#define BIT_R_EN_SET_MOREDATA_8822B BIT(2)
+#define BIT__R_DIS_CLEAR_MACID_RELEASE_8822B BIT(1)
+#define BIT__R_MACID_RELEASE_EN_8822B BIT(0)
+
+/* 2 REG_AMPDU_MAX_TIME_V1_8822B */
+
+#define BIT_SHIFT_AMPDU_MAX_TIME_8822B 0
+#define BIT_MASK_AMPDU_MAX_TIME_8822B 0xff
+#define BIT_AMPDU_MAX_TIME_8822B(x)                                            \
+	(((x) & BIT_MASK_AMPDU_MAX_TIME_8822B)                                 \
+	 << BIT_SHIFT_AMPDU_MAX_TIME_8822B)
+#define BIT_GET_AMPDU_MAX_TIME_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_AMPDU_MAX_TIME_8822B) &                             \
+	 BIT_MASK_AMPDU_MAX_TIME_8822B)
+
+/* 2 REG_BCNQ1_BDNY_V1_8822B */
+
+#define BIT_SHIFT_BCNQ1_PGBNDY_V1_8822B 0
+#define BIT_MASK_BCNQ1_PGBNDY_V1_8822B 0xfff
+#define BIT_BCNQ1_PGBNDY_V1_8822B(x)                                           \
+	(((x) & BIT_MASK_BCNQ1_PGBNDY_V1_8822B)                                \
+	 << BIT_SHIFT_BCNQ1_PGBNDY_V1_8822B)
+#define BIT_GET_BCNQ1_PGBNDY_V1_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_BCNQ1_PGBNDY_V1_8822B) &                            \
+	 BIT_MASK_BCNQ1_PGBNDY_V1_8822B)
+
+/* 2 REG_AMPDU_MAX_LENGTH_8822B */
+
+#define BIT_SHIFT_AMPDU_MAX_LENGTH_8822B 0
+#define BIT_MASK_AMPDU_MAX_LENGTH_8822B 0xffffffffL
+#define BIT_AMPDU_MAX_LENGTH_8822B(x)                                          \
+	(((x) & BIT_MASK_AMPDU_MAX_LENGTH_8822B)                               \
+	 << BIT_SHIFT_AMPDU_MAX_LENGTH_8822B)
+#define BIT_GET_AMPDU_MAX_LENGTH_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_AMPDU_MAX_LENGTH_8822B) &                           \
+	 BIT_MASK_AMPDU_MAX_LENGTH_8822B)
+
+/* 2 REG_ACQ_STOP_8822B */
+#define BIT_AC7Q_STOP_8822B BIT(7)
+#define BIT_AC6Q_STOP_8822B BIT(6)
+#define BIT_AC5Q_STOP_8822B BIT(5)
+#define BIT_AC4Q_STOP_8822B BIT(4)
+#define BIT_AC3Q_STOP_8822B BIT(3)
+#define BIT_AC2Q_STOP_8822B BIT(2)
+#define BIT_AC1Q_STOP_8822B BIT(1)
+#define BIT_AC0Q_STOP_8822B BIT(0)
+
+/* 2 REG_NDPA_RATE_8822B */
+
+#define BIT_SHIFT_R_NDPA_RATE_V1_8822B 0
+#define BIT_MASK_R_NDPA_RATE_V1_8822B 0xff
+#define BIT_R_NDPA_RATE_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_R_NDPA_RATE_V1_8822B)                                 \
+	 << BIT_SHIFT_R_NDPA_RATE_V1_8822B)
+#define BIT_GET_R_NDPA_RATE_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_R_NDPA_RATE_V1_8822B) &                             \
+	 BIT_MASK_R_NDPA_RATE_V1_8822B)
+
+/* 2 REG_TX_HANG_CTRL_8822B */
+#define BIT_R_EN_GNT_BT_AWAKE_8822B BIT(3)
+#define BIT_EN_EOF_V1_8822B BIT(2)
+#define BIT_DIS_OQT_BLOCK_8822B BIT(1)
+#define BIT_SEARCH_QUEUE_EN_8822B BIT(0)
+
+/* 2 REG_NDPA_OPT_CTRL_8822B */
+#define BIT_R_DIS_MACID_RELEASE_RTY_8822B BIT(5)
+
+#define BIT_SHIFT_BW_SIGTA_8822B 3
+#define BIT_MASK_BW_SIGTA_8822B 0x3
+#define BIT_BW_SIGTA_8822B(x)                                                  \
+	(((x) & BIT_MASK_BW_SIGTA_8822B) << BIT_SHIFT_BW_SIGTA_8822B)
+#define BIT_GET_BW_SIGTA_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_BW_SIGTA_8822B) & BIT_MASK_BW_SIGTA_8822B)
+
+#define BIT_EN_BAR_SIGTA_8822B BIT(2)
+
+#define BIT_SHIFT_R_NDPA_BW_8822B 0
+#define BIT_MASK_R_NDPA_BW_8822B 0x3
+#define BIT_R_NDPA_BW_8822B(x)                                                 \
+	(((x) & BIT_MASK_R_NDPA_BW_8822B) << BIT_SHIFT_R_NDPA_BW_8822B)
+#define BIT_GET_R_NDPA_BW_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_R_NDPA_BW_8822B) & BIT_MASK_R_NDPA_BW_8822B)
+
+/* 2 REG_RD_RESP_PKT_TH_8822B */
+
+#define BIT_SHIFT_RD_RESP_PKT_TH_V1_8822B 0
+#define BIT_MASK_RD_RESP_PKT_TH_V1_8822B 0x3f
+#define BIT_RD_RESP_PKT_TH_V1_8822B(x)                                         \
+	(((x) & BIT_MASK_RD_RESP_PKT_TH_V1_8822B)                              \
+	 << BIT_SHIFT_RD_RESP_PKT_TH_V1_8822B)
+#define BIT_GET_RD_RESP_PKT_TH_V1_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_RD_RESP_PKT_TH_V1_8822B) &                          \
+	 BIT_MASK_RD_RESP_PKT_TH_V1_8822B)
+
+/* 2 REG_CMDQ_INFO_8822B */
+
+#define BIT_SHIFT_QUEUEMACID_CMDQ_V1_8822B 25
+#define BIT_MASK_QUEUEMACID_CMDQ_V1_8822B 0x7f
+#define BIT_QUEUEMACID_CMDQ_V1_8822B(x)                                        \
+	(((x) & BIT_MASK_QUEUEMACID_CMDQ_V1_8822B)                             \
+	 << BIT_SHIFT_QUEUEMACID_CMDQ_V1_8822B)
+#define BIT_GET_QUEUEMACID_CMDQ_V1_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_QUEUEMACID_CMDQ_V1_8822B) &                         \
+	 BIT_MASK_QUEUEMACID_CMDQ_V1_8822B)
+
+#define BIT_SHIFT_QUEUEAC_CMDQ_V1_8822B 23
+#define BIT_MASK_QUEUEAC_CMDQ_V1_8822B 0x3
+#define BIT_QUEUEAC_CMDQ_V1_8822B(x)                                           \
+	(((x) & BIT_MASK_QUEUEAC_CMDQ_V1_8822B)                                \
+	 << BIT_SHIFT_QUEUEAC_CMDQ_V1_8822B)
+#define BIT_GET_QUEUEAC_CMDQ_V1_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_QUEUEAC_CMDQ_V1_8822B) &                            \
+	 BIT_MASK_QUEUEAC_CMDQ_V1_8822B)
+
+#define BIT_TIDEMPTY_CMDQ_V1_8822B BIT(22)
+
+#define BIT_SHIFT_TAIL_PKT_CMDQ_V2_8822B 11
+#define BIT_MASK_TAIL_PKT_CMDQ_V2_8822B 0x7ff
+#define BIT_TAIL_PKT_CMDQ_V2_8822B(x)                                          \
+	(((x) & BIT_MASK_TAIL_PKT_CMDQ_V2_8822B)                               \
+	 << BIT_SHIFT_TAIL_PKT_CMDQ_V2_8822B)
+#define BIT_GET_TAIL_PKT_CMDQ_V2_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_TAIL_PKT_CMDQ_V2_8822B) &                           \
+	 BIT_MASK_TAIL_PKT_CMDQ_V2_8822B)
+
+#define BIT_SHIFT_HEAD_PKT_CMDQ_V1_8822B 0
+#define BIT_MASK_HEAD_PKT_CMDQ_V1_8822B 0x7ff
+#define BIT_HEAD_PKT_CMDQ_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_HEAD_PKT_CMDQ_V1_8822B)                               \
+	 << BIT_SHIFT_HEAD_PKT_CMDQ_V1_8822B)
+#define BIT_GET_HEAD_PKT_CMDQ_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_HEAD_PKT_CMDQ_V1_8822B) &                           \
+	 BIT_MASK_HEAD_PKT_CMDQ_V1_8822B)
+
+/* 2 REG_Q4_INFO_8822B */
+
+#define BIT_SHIFT_QUEUEMACID_Q4_V1_8822B 25
+#define BIT_MASK_QUEUEMACID_Q4_V1_8822B 0x7f
+#define BIT_QUEUEMACID_Q4_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_QUEUEMACID_Q4_V1_8822B)                               \
+	 << BIT_SHIFT_QUEUEMACID_Q4_V1_8822B)
+#define BIT_GET_QUEUEMACID_Q4_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q4_V1_8822B) &                           \
+	 BIT_MASK_QUEUEMACID_Q4_V1_8822B)
+
+#define BIT_SHIFT_QUEUEAC_Q4_V1_8822B 23
+#define BIT_MASK_QUEUEAC_Q4_V1_8822B 0x3
+#define BIT_QUEUEAC_Q4_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_QUEUEAC_Q4_V1_8822B) << BIT_SHIFT_QUEUEAC_Q4_V1_8822B)
+#define BIT_GET_QUEUEAC_Q4_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q4_V1_8822B) & BIT_MASK_QUEUEAC_Q4_V1_8822B)
+
+#define BIT_TIDEMPTY_Q4_V1_8822B BIT(22)
+
+#define BIT_SHIFT_TAIL_PKT_Q4_V2_8822B 11
+#define BIT_MASK_TAIL_PKT_Q4_V2_8822B 0x7ff
+#define BIT_TAIL_PKT_Q4_V2_8822B(x)                                            \
+	(((x) & BIT_MASK_TAIL_PKT_Q4_V2_8822B)                                 \
+	 << BIT_SHIFT_TAIL_PKT_Q4_V2_8822B)
+#define BIT_GET_TAIL_PKT_Q4_V2_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q4_V2_8822B) &                             \
+	 BIT_MASK_TAIL_PKT_Q4_V2_8822B)
+
+#define BIT_SHIFT_HEAD_PKT_Q4_V1_8822B 0
+#define BIT_MASK_HEAD_PKT_Q4_V1_8822B 0x7ff
+#define BIT_HEAD_PKT_Q4_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_HEAD_PKT_Q4_V1_8822B)                                 \
+	 << BIT_SHIFT_HEAD_PKT_Q4_V1_8822B)
+#define BIT_GET_HEAD_PKT_Q4_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q4_V1_8822B) &                             \
+	 BIT_MASK_HEAD_PKT_Q4_V1_8822B)
+
+/* 2 REG_Q5_INFO_8822B */
+
+#define BIT_SHIFT_QUEUEMACID_Q5_V1_8822B 25
+#define BIT_MASK_QUEUEMACID_Q5_V1_8822B 0x7f
+#define BIT_QUEUEMACID_Q5_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_QUEUEMACID_Q5_V1_8822B)                               \
+	 << BIT_SHIFT_QUEUEMACID_Q5_V1_8822B)
+#define BIT_GET_QUEUEMACID_Q5_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q5_V1_8822B) &                           \
+	 BIT_MASK_QUEUEMACID_Q5_V1_8822B)
+
+#define BIT_SHIFT_QUEUEAC_Q5_V1_8822B 23
+#define BIT_MASK_QUEUEAC_Q5_V1_8822B 0x3
+#define BIT_QUEUEAC_Q5_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_QUEUEAC_Q5_V1_8822B) << BIT_SHIFT_QUEUEAC_Q5_V1_8822B)
+#define BIT_GET_QUEUEAC_Q5_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q5_V1_8822B) & BIT_MASK_QUEUEAC_Q5_V1_8822B)
+
+#define BIT_TIDEMPTY_Q5_V1_8822B BIT(22)
+
+#define BIT_SHIFT_TAIL_PKT_Q5_V2_8822B 11
+#define BIT_MASK_TAIL_PKT_Q5_V2_8822B 0x7ff
+#define BIT_TAIL_PKT_Q5_V2_8822B(x)                                            \
+	(((x) & BIT_MASK_TAIL_PKT_Q5_V2_8822B)                                 \
+	 << BIT_SHIFT_TAIL_PKT_Q5_V2_8822B)
+#define BIT_GET_TAIL_PKT_Q5_V2_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q5_V2_8822B) &                             \
+	 BIT_MASK_TAIL_PKT_Q5_V2_8822B)
+
+#define BIT_SHIFT_HEAD_PKT_Q5_V1_8822B 0
+#define BIT_MASK_HEAD_PKT_Q5_V1_8822B 0x7ff
+#define BIT_HEAD_PKT_Q5_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_HEAD_PKT_Q5_V1_8822B)                                 \
+	 << BIT_SHIFT_HEAD_PKT_Q5_V1_8822B)
+#define BIT_GET_HEAD_PKT_Q5_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q5_V1_8822B) &                             \
+	 BIT_MASK_HEAD_PKT_Q5_V1_8822B)
+
+/* 2 REG_Q6_INFO_8822B */
+
+#define BIT_SHIFT_QUEUEMACID_Q6_V1_8822B 25
+#define BIT_MASK_QUEUEMACID_Q6_V1_8822B 0x7f
+#define BIT_QUEUEMACID_Q6_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_QUEUEMACID_Q6_V1_8822B)                               \
+	 << BIT_SHIFT_QUEUEMACID_Q6_V1_8822B)
+#define BIT_GET_QUEUEMACID_Q6_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q6_V1_8822B) &                           \
+	 BIT_MASK_QUEUEMACID_Q6_V1_8822B)
+
+#define BIT_SHIFT_QUEUEAC_Q6_V1_8822B 23
+#define BIT_MASK_QUEUEAC_Q6_V1_8822B 0x3
+#define BIT_QUEUEAC_Q6_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_QUEUEAC_Q6_V1_8822B) << BIT_SHIFT_QUEUEAC_Q6_V1_8822B)
+#define BIT_GET_QUEUEAC_Q6_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q6_V1_8822B) & BIT_MASK_QUEUEAC_Q6_V1_8822B)
+
+#define BIT_TIDEMPTY_Q6_V1_8822B BIT(22)
+
+#define BIT_SHIFT_TAIL_PKT_Q6_V2_8822B 11
+#define BIT_MASK_TAIL_PKT_Q6_V2_8822B 0x7ff
+#define BIT_TAIL_PKT_Q6_V2_8822B(x)                                            \
+	(((x) & BIT_MASK_TAIL_PKT_Q6_V2_8822B)                                 \
+	 << BIT_SHIFT_TAIL_PKT_Q6_V2_8822B)
+#define BIT_GET_TAIL_PKT_Q6_V2_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q6_V2_8822B) &                             \
+	 BIT_MASK_TAIL_PKT_Q6_V2_8822B)
+
+#define BIT_SHIFT_HEAD_PKT_Q6_V1_8822B 0
+#define BIT_MASK_HEAD_PKT_Q6_V1_8822B 0x7ff
+#define BIT_HEAD_PKT_Q6_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_HEAD_PKT_Q6_V1_8822B)                                 \
+	 << BIT_SHIFT_HEAD_PKT_Q6_V1_8822B)
+#define BIT_GET_HEAD_PKT_Q6_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q6_V1_8822B) &                             \
+	 BIT_MASK_HEAD_PKT_Q6_V1_8822B)
+
+/* 2 REG_Q7_INFO_8822B */
+
+#define BIT_SHIFT_QUEUEMACID_Q7_V1_8822B 25
+#define BIT_MASK_QUEUEMACID_Q7_V1_8822B 0x7f
+#define BIT_QUEUEMACID_Q7_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_QUEUEMACID_Q7_V1_8822B)                               \
+	 << BIT_SHIFT_QUEUEMACID_Q7_V1_8822B)
+#define BIT_GET_QUEUEMACID_Q7_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_QUEUEMACID_Q7_V1_8822B) &                           \
+	 BIT_MASK_QUEUEMACID_Q7_V1_8822B)
+
+#define BIT_SHIFT_QUEUEAC_Q7_V1_8822B 23
+#define BIT_MASK_QUEUEAC_Q7_V1_8822B 0x3
+#define BIT_QUEUEAC_Q7_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_QUEUEAC_Q7_V1_8822B) << BIT_SHIFT_QUEUEAC_Q7_V1_8822B)
+#define BIT_GET_QUEUEAC_Q7_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_QUEUEAC_Q7_V1_8822B) & BIT_MASK_QUEUEAC_Q7_V1_8822B)
+
+#define BIT_TIDEMPTY_Q7_V1_8822B BIT(22)
+
+#define BIT_SHIFT_TAIL_PKT_Q7_V2_8822B 11
+#define BIT_MASK_TAIL_PKT_Q7_V2_8822B 0x7ff
+#define BIT_TAIL_PKT_Q7_V2_8822B(x)                                            \
+	(((x) & BIT_MASK_TAIL_PKT_Q7_V2_8822B)                                 \
+	 << BIT_SHIFT_TAIL_PKT_Q7_V2_8822B)
+#define BIT_GET_TAIL_PKT_Q7_V2_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_TAIL_PKT_Q7_V2_8822B) &                             \
+	 BIT_MASK_TAIL_PKT_Q7_V2_8822B)
+
+#define BIT_SHIFT_HEAD_PKT_Q7_V1_8822B 0
+#define BIT_MASK_HEAD_PKT_Q7_V1_8822B 0x7ff
+#define BIT_HEAD_PKT_Q7_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_HEAD_PKT_Q7_V1_8822B)                                 \
+	 << BIT_SHIFT_HEAD_PKT_Q7_V1_8822B)
+#define BIT_GET_HEAD_PKT_Q7_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_HEAD_PKT_Q7_V1_8822B) &                             \
+	 BIT_MASK_HEAD_PKT_Q7_V1_8822B)
+
+/* 2 REG_WMAC_LBK_BUF_HD_V1_8822B */
+
+#define BIT_SHIFT_WMAC_LBK_BUF_HEAD_V1_8822B 0
+#define BIT_MASK_WMAC_LBK_BUF_HEAD_V1_8822B 0xfff
+#define BIT_WMAC_LBK_BUF_HEAD_V1_8822B(x)                                      \
+	(((x) & BIT_MASK_WMAC_LBK_BUF_HEAD_V1_8822B)                           \
+	 << BIT_SHIFT_WMAC_LBK_BUF_HEAD_V1_8822B)
+#define BIT_GET_WMAC_LBK_BUF_HEAD_V1_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_WMAC_LBK_BUF_HEAD_V1_8822B) &                       \
+	 BIT_MASK_WMAC_LBK_BUF_HEAD_V1_8822B)
+
+/* 2 REG_MGQ_BDNY_V1_8822B */
+
+#define BIT_SHIFT_MGQ_PGBNDY_V1_8822B 0
+#define BIT_MASK_MGQ_PGBNDY_V1_8822B 0xfff
+#define BIT_MGQ_PGBNDY_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_MGQ_PGBNDY_V1_8822B) << BIT_SHIFT_MGQ_PGBNDY_V1_8822B)
+#define BIT_GET_MGQ_PGBNDY_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_MGQ_PGBNDY_V1_8822B) & BIT_MASK_MGQ_PGBNDY_V1_8822B)
+
+/* 2 REG_TXRPT_CTRL_8822B */
+
+#define BIT_SHIFT_TRXRPT_TIMER_TH_8822B 24
+#define BIT_MASK_TRXRPT_TIMER_TH_8822B 0xff
+#define BIT_TRXRPT_TIMER_TH_8822B(x)                                           \
+	(((x) & BIT_MASK_TRXRPT_TIMER_TH_8822B)                                \
+	 << BIT_SHIFT_TRXRPT_TIMER_TH_8822B)
+#define BIT_GET_TRXRPT_TIMER_TH_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_TRXRPT_TIMER_TH_8822B) &                            \
+	 BIT_MASK_TRXRPT_TIMER_TH_8822B)
+
+#define BIT_SHIFT_TRXRPT_LEN_TH_8822B 16
+#define BIT_MASK_TRXRPT_LEN_TH_8822B 0xff
+#define BIT_TRXRPT_LEN_TH_8822B(x)                                             \
+	(((x) & BIT_MASK_TRXRPT_LEN_TH_8822B) << BIT_SHIFT_TRXRPT_LEN_TH_8822B)
+#define BIT_GET_TRXRPT_LEN_TH_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_TRXRPT_LEN_TH_8822B) & BIT_MASK_TRXRPT_LEN_TH_8822B)
+
+#define BIT_SHIFT_TRXRPT_READ_PTR_8822B 8
+#define BIT_MASK_TRXRPT_READ_PTR_8822B 0xff
+#define BIT_TRXRPT_READ_PTR_8822B(x)                                           \
+	(((x) & BIT_MASK_TRXRPT_READ_PTR_8822B)                                \
+	 << BIT_SHIFT_TRXRPT_READ_PTR_8822B)
+#define BIT_GET_TRXRPT_READ_PTR_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_TRXRPT_READ_PTR_8822B) &                            \
+	 BIT_MASK_TRXRPT_READ_PTR_8822B)
+
+#define BIT_SHIFT_TRXRPT_WRITE_PTR_8822B 0
+#define BIT_MASK_TRXRPT_WRITE_PTR_8822B 0xff
+#define BIT_TRXRPT_WRITE_PTR_8822B(x)                                          \
+	(((x) & BIT_MASK_TRXRPT_WRITE_PTR_8822B)                               \
+	 << BIT_SHIFT_TRXRPT_WRITE_PTR_8822B)
+#define BIT_GET_TRXRPT_WRITE_PTR_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_TRXRPT_WRITE_PTR_8822B) &                           \
+	 BIT_MASK_TRXRPT_WRITE_PTR_8822B)
+
+/* 2 REG_INIRTS_RATE_SEL_8822B */
+#define BIT_LEAG_RTS_BW_DUP_8822B BIT(5)
+
+/* 2 REG_BASIC_CFEND_RATE_8822B */
+
+#define BIT_SHIFT_BASIC_CFEND_RATE_8822B 0
+#define BIT_MASK_BASIC_CFEND_RATE_8822B 0x1f
+#define BIT_BASIC_CFEND_RATE_8822B(x)                                          \
+	(((x) & BIT_MASK_BASIC_CFEND_RATE_8822B)                               \
+	 << BIT_SHIFT_BASIC_CFEND_RATE_8822B)
+#define BIT_GET_BASIC_CFEND_RATE_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_BASIC_CFEND_RATE_8822B) &                           \
+	 BIT_MASK_BASIC_CFEND_RATE_8822B)
+
+/* 2 REG_STBC_CFEND_RATE_8822B */
+
+#define BIT_SHIFT_STBC_CFEND_RATE_8822B 0
+#define BIT_MASK_STBC_CFEND_RATE_8822B 0x1f
+#define BIT_STBC_CFEND_RATE_8822B(x)                                           \
+	(((x) & BIT_MASK_STBC_CFEND_RATE_8822B)                                \
+	 << BIT_SHIFT_STBC_CFEND_RATE_8822B)
+#define BIT_GET_STBC_CFEND_RATE_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_STBC_CFEND_RATE_8822B) &                            \
+	 BIT_MASK_STBC_CFEND_RATE_8822B)
+
+/* 2 REG_DATA_SC_8822B */
+
+#define BIT_SHIFT_TXSC_40M_8822B 4
+#define BIT_MASK_TXSC_40M_8822B 0xf
+#define BIT_TXSC_40M_8822B(x)                                                  \
+	(((x) & BIT_MASK_TXSC_40M_8822B) << BIT_SHIFT_TXSC_40M_8822B)
+#define BIT_GET_TXSC_40M_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_TXSC_40M_8822B) & BIT_MASK_TXSC_40M_8822B)
+
+#define BIT_SHIFT_TXSC_20M_8822B 0
+#define BIT_MASK_TXSC_20M_8822B 0xf
+#define BIT_TXSC_20M_8822B(x)                                                  \
+	(((x) & BIT_MASK_TXSC_20M_8822B) << BIT_SHIFT_TXSC_20M_8822B)
+#define BIT_GET_TXSC_20M_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_TXSC_20M_8822B) & BIT_MASK_TXSC_20M_8822B)
+
+/* 2 REG_MACID_SLEEP3_8822B */
+
+#define BIT_SHIFT_MACID127_96_PKTSLEEP_8822B 0
+#define BIT_MASK_MACID127_96_PKTSLEEP_8822B 0xffffffffL
+#define BIT_MACID127_96_PKTSLEEP_8822B(x)                                      \
+	(((x) & BIT_MASK_MACID127_96_PKTSLEEP_8822B)                           \
+	 << BIT_SHIFT_MACID127_96_PKTSLEEP_8822B)
+#define BIT_GET_MACID127_96_PKTSLEEP_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_MACID127_96_PKTSLEEP_8822B) &                       \
+	 BIT_MASK_MACID127_96_PKTSLEEP_8822B)
+
+/* 2 REG_MACID_SLEEP1_8822B */
+
+#define BIT_SHIFT_MACID63_32_PKTSLEEP_8822B 0
+#define BIT_MASK_MACID63_32_PKTSLEEP_8822B 0xffffffffL
+#define BIT_MACID63_32_PKTSLEEP_8822B(x)                                       \
+	(((x) & BIT_MASK_MACID63_32_PKTSLEEP_8822B)                            \
+	 << BIT_SHIFT_MACID63_32_PKTSLEEP_8822B)
+#define BIT_GET_MACID63_32_PKTSLEEP_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_MACID63_32_PKTSLEEP_8822B) &                        \
+	 BIT_MASK_MACID63_32_PKTSLEEP_8822B)
+
+/* 2 REG_ARFR2_V1_8822B */
+
+#define BIT_SHIFT_ARFR2_V1_8822B 0
+#define BIT_MASK_ARFR2_V1_8822B 0xffffffffffffffffL
+#define BIT_ARFR2_V1_8822B(x)                                                  \
+	(((x) & BIT_MASK_ARFR2_V1_8822B) << BIT_SHIFT_ARFR2_V1_8822B)
+#define BIT_GET_ARFR2_V1_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_ARFR2_V1_8822B) & BIT_MASK_ARFR2_V1_8822B)
+
+/* 2 REG_ARFR3_V1_8822B */
+
+#define BIT_SHIFT_ARFR3_V1_8822B 0
+#define BIT_MASK_ARFR3_V1_8822B 0xffffffffffffffffL
+#define BIT_ARFR3_V1_8822B(x)                                                  \
+	(((x) & BIT_MASK_ARFR3_V1_8822B) << BIT_SHIFT_ARFR3_V1_8822B)
+#define BIT_GET_ARFR3_V1_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_ARFR3_V1_8822B) & BIT_MASK_ARFR3_V1_8822B)
+
+/* 2 REG_ARFR4_8822B */
+
+#define BIT_SHIFT_ARFR4_8822B 0
+#define BIT_MASK_ARFR4_8822B 0xffffffffffffffffL
+#define BIT_ARFR4_8822B(x)                                                     \
+	(((x) & BIT_MASK_ARFR4_8822B) << BIT_SHIFT_ARFR4_8822B)
+#define BIT_GET_ARFR4_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_ARFR4_8822B) & BIT_MASK_ARFR4_8822B)
+
+/* 2 REG_ARFR5_8822B */
+
+#define BIT_SHIFT_ARFR5_8822B 0
+#define BIT_MASK_ARFR5_8822B 0xffffffffffffffffL
+#define BIT_ARFR5_8822B(x)                                                     \
+	(((x) & BIT_MASK_ARFR5_8822B) << BIT_SHIFT_ARFR5_8822B)
+#define BIT_GET_ARFR5_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_ARFR5_8822B) & BIT_MASK_ARFR5_8822B)
+
+/* 2 REG_TXRPT_START_OFFSET_8822B */
+
+#define BIT_SHIFT_MACID_MURATE_OFFSET_8822B 24
+#define BIT_MASK_MACID_MURATE_OFFSET_8822B 0xff
+#define BIT_MACID_MURATE_OFFSET_8822B(x)                                       \
+	(((x) & BIT_MASK_MACID_MURATE_OFFSET_8822B)                            \
+	 << BIT_SHIFT_MACID_MURATE_OFFSET_8822B)
+#define BIT_GET_MACID_MURATE_OFFSET_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_MACID_MURATE_OFFSET_8822B) &                        \
+	 BIT_MASK_MACID_MURATE_OFFSET_8822B)
+
+#define BIT_RPTFIFO_SIZE_OPT_8822B BIT(16)
+
+#define BIT_SHIFT_MACID_CTRL_OFFSET_8822B 8
+#define BIT_MASK_MACID_CTRL_OFFSET_8822B 0xff
+#define BIT_MACID_CTRL_OFFSET_8822B(x)                                         \
+	(((x) & BIT_MASK_MACID_CTRL_OFFSET_8822B)                              \
+	 << BIT_SHIFT_MACID_CTRL_OFFSET_8822B)
+#define BIT_GET_MACID_CTRL_OFFSET_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_MACID_CTRL_OFFSET_8822B) &                          \
+	 BIT_MASK_MACID_CTRL_OFFSET_8822B)
+
+#define BIT_SHIFT_AMPDU_TXRPT_OFFSET_8822B 0
+#define BIT_MASK_AMPDU_TXRPT_OFFSET_8822B 0xff
+#define BIT_AMPDU_TXRPT_OFFSET_8822B(x)                                        \
+	(((x) & BIT_MASK_AMPDU_TXRPT_OFFSET_8822B)                             \
+	 << BIT_SHIFT_AMPDU_TXRPT_OFFSET_8822B)
+#define BIT_GET_AMPDU_TXRPT_OFFSET_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_AMPDU_TXRPT_OFFSET_8822B) &                         \
+	 BIT_MASK_AMPDU_TXRPT_OFFSET_8822B)
+
+/* 2 REG_POWER_STAGE1_8822B */
+#define BIT_PTA_WL_PRI_MASK_CPU_MGQ_8822B BIT(31)
+#define BIT_PTA_WL_PRI_MASK_BCNQ_8822B BIT(30)
+#define BIT_PTA_WL_PRI_MASK_HIQ_8822B BIT(29)
+#define BIT_PTA_WL_PRI_MASK_MGQ_8822B BIT(28)
+#define BIT_PTA_WL_PRI_MASK_BK_8822B BIT(27)
+#define BIT_PTA_WL_PRI_MASK_BE_8822B BIT(26)
+#define BIT_PTA_WL_PRI_MASK_VI_8822B BIT(25)
+#define BIT_PTA_WL_PRI_MASK_VO_8822B BIT(24)
+
+#define BIT_SHIFT_POWER_STAGE1_8822B 0
+#define BIT_MASK_POWER_STAGE1_8822B 0xffffff
+#define BIT_POWER_STAGE1_8822B(x)                                              \
+	(((x) & BIT_MASK_POWER_STAGE1_8822B) << BIT_SHIFT_POWER_STAGE1_8822B)
+#define BIT_GET_POWER_STAGE1_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_POWER_STAGE1_8822B) & BIT_MASK_POWER_STAGE1_8822B)
+
+/* 2 REG_POWER_STAGE2_8822B */
+#define BIT__R_CTRL_PKT_POW_ADJ_8822B BIT(24)
+
+#define BIT_SHIFT_POWER_STAGE2_8822B 0
+#define BIT_MASK_POWER_STAGE2_8822B 0xffffff
+#define BIT_POWER_STAGE2_8822B(x)                                              \
+	(((x) & BIT_MASK_POWER_STAGE2_8822B) << BIT_SHIFT_POWER_STAGE2_8822B)
+#define BIT_GET_POWER_STAGE2_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_POWER_STAGE2_8822B) & BIT_MASK_POWER_STAGE2_8822B)
+
+/* 2 REG_SW_AMPDU_BURST_MODE_CTRL_8822B */
+
+#define BIT_SHIFT_PAD_NUM_THRES_8822B 24
+#define BIT_MASK_PAD_NUM_THRES_8822B 0x3f
+#define BIT_PAD_NUM_THRES_8822B(x)                                             \
+	(((x) & BIT_MASK_PAD_NUM_THRES_8822B) << BIT_SHIFT_PAD_NUM_THRES_8822B)
+#define BIT_GET_PAD_NUM_THRES_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_PAD_NUM_THRES_8822B) & BIT_MASK_PAD_NUM_THRES_8822B)
+
+#define BIT_R_DMA_THIS_QUEUE_BK_8822B BIT(23)
+#define BIT_R_DMA_THIS_QUEUE_BE_8822B BIT(22)
+#define BIT_R_DMA_THIS_QUEUE_VI_8822B BIT(21)
+#define BIT_R_DMA_THIS_QUEUE_VO_8822B BIT(20)
+
+#define BIT_SHIFT_R_TOTAL_LEN_TH_8822B 8
+#define BIT_MASK_R_TOTAL_LEN_TH_8822B 0xfff
+#define BIT_R_TOTAL_LEN_TH_8822B(x)                                            \
+	(((x) & BIT_MASK_R_TOTAL_LEN_TH_8822B)                                 \
+	 << BIT_SHIFT_R_TOTAL_LEN_TH_8822B)
+#define BIT_GET_R_TOTAL_LEN_TH_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_R_TOTAL_LEN_TH_8822B) &                             \
+	 BIT_MASK_R_TOTAL_LEN_TH_8822B)
+
+#define BIT_EN_NEW_EARLY_8822B BIT(7)
+#define BIT_PRE_TX_CMD_8822B BIT(6)
+
+#define BIT_SHIFT_NUM_SCL_EN_8822B 4
+#define BIT_MASK_NUM_SCL_EN_8822B 0x3
+#define BIT_NUM_SCL_EN_8822B(x)                                                \
+	(((x) & BIT_MASK_NUM_SCL_EN_8822B) << BIT_SHIFT_NUM_SCL_EN_8822B)
+#define BIT_GET_NUM_SCL_EN_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_NUM_SCL_EN_8822B) & BIT_MASK_NUM_SCL_EN_8822B)
+
+#define BIT_BK_EN_8822B BIT(3)
+#define BIT_BE_EN_8822B BIT(2)
+#define BIT_VI_EN_8822B BIT(1)
+#define BIT_VO_EN_8822B BIT(0)
+
+/* 2 REG_PKT_LIFE_TIME_8822B */
+
+#define BIT_SHIFT_PKT_LIFTIME_BEBK_8822B 16
+#define BIT_MASK_PKT_LIFTIME_BEBK_8822B 0xffff
+#define BIT_PKT_LIFTIME_BEBK_8822B(x)                                          \
+	(((x) & BIT_MASK_PKT_LIFTIME_BEBK_8822B)                               \
+	 << BIT_SHIFT_PKT_LIFTIME_BEBK_8822B)
+#define BIT_GET_PKT_LIFTIME_BEBK_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_PKT_LIFTIME_BEBK_8822B) &                           \
+	 BIT_MASK_PKT_LIFTIME_BEBK_8822B)
+
+#define BIT_SHIFT_PKT_LIFTIME_VOVI_8822B 0
+#define BIT_MASK_PKT_LIFTIME_VOVI_8822B 0xffff
+#define BIT_PKT_LIFTIME_VOVI_8822B(x)                                          \
+	(((x) & BIT_MASK_PKT_LIFTIME_VOVI_8822B)                               \
+	 << BIT_SHIFT_PKT_LIFTIME_VOVI_8822B)
+#define BIT_GET_PKT_LIFTIME_VOVI_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_PKT_LIFTIME_VOVI_8822B) &                           \
+	 BIT_MASK_PKT_LIFTIME_VOVI_8822B)
+
+/* 2 REG_STBC_SETTING_8822B */
+
+#define BIT_SHIFT_CDEND_TXTIME_L_8822B 4
+#define BIT_MASK_CDEND_TXTIME_L_8822B 0xf
+#define BIT_CDEND_TXTIME_L_8822B(x)                                            \
+	(((x) & BIT_MASK_CDEND_TXTIME_L_8822B)                                 \
+	 << BIT_SHIFT_CDEND_TXTIME_L_8822B)
+#define BIT_GET_CDEND_TXTIME_L_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_CDEND_TXTIME_L_8822B) &                             \
+	 BIT_MASK_CDEND_TXTIME_L_8822B)
+
+#define BIT_SHIFT_NESS_8822B 2
+#define BIT_MASK_NESS_8822B 0x3
+#define BIT_NESS_8822B(x) (((x) & BIT_MASK_NESS_8822B) << BIT_SHIFT_NESS_8822B)
+#define BIT_GET_NESS_8822B(x)                                                  \
+	(((x) >> BIT_SHIFT_NESS_8822B) & BIT_MASK_NESS_8822B)
+
+#define BIT_SHIFT_STBC_CFEND_8822B 0
+#define BIT_MASK_STBC_CFEND_8822B 0x3
+#define BIT_STBC_CFEND_8822B(x)                                                \
+	(((x) & BIT_MASK_STBC_CFEND_8822B) << BIT_SHIFT_STBC_CFEND_8822B)
+#define BIT_GET_STBC_CFEND_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_STBC_CFEND_8822B) & BIT_MASK_STBC_CFEND_8822B)
+
+/* 2 REG_STBC_SETTING2_8822B */
+
+#define BIT_SHIFT_CDEND_TXTIME_H_8822B 0
+#define BIT_MASK_CDEND_TXTIME_H_8822B 0x1f
+#define BIT_CDEND_TXTIME_H_8822B(x)                                            \
+	(((x) & BIT_MASK_CDEND_TXTIME_H_8822B)                                 \
+	 << BIT_SHIFT_CDEND_TXTIME_H_8822B)
+#define BIT_GET_CDEND_TXTIME_H_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_CDEND_TXTIME_H_8822B) &                             \
+	 BIT_MASK_CDEND_TXTIME_H_8822B)
+
+/* 2 REG_QUEUE_CTRL_8822B */
+#define BIT_PTA_EDCCA_EN_8822B BIT(5)
+#define BIT_PTA_WL_TX_EN_8822B BIT(4)
+#define BIT_R_USE_DATA_BW_8822B BIT(3)
+#define BIT_TRI_PKT_INT_MODE1_8822B BIT(2)
+#define BIT_TRI_PKT_INT_MODE0_8822B BIT(1)
+#define BIT_ACQ_MODE_SEL_8822B BIT(0)
+
+/* 2 REG_SINGLE_AMPDU_CTRL_8822B */
+#define BIT_EN_SINGLE_APMDU_8822B BIT(7)
+
+/* 2 REG_PROT_MODE_CTRL_8822B */
+
+#define BIT_SHIFT_RTS_MAX_AGG_NUM_8822B 24
+#define BIT_MASK_RTS_MAX_AGG_NUM_8822B 0x3f
+#define BIT_RTS_MAX_AGG_NUM_8822B(x)                                           \
+	(((x) & BIT_MASK_RTS_MAX_AGG_NUM_8822B)                                \
+	 << BIT_SHIFT_RTS_MAX_AGG_NUM_8822B)
+#define BIT_GET_RTS_MAX_AGG_NUM_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_RTS_MAX_AGG_NUM_8822B) &                            \
+	 BIT_MASK_RTS_MAX_AGG_NUM_8822B)
+
+#define BIT_SHIFT_MAX_AGG_NUM_8822B 16
+#define BIT_MASK_MAX_AGG_NUM_8822B 0x3f
+#define BIT_MAX_AGG_NUM_8822B(x)                                               \
+	(((x) & BIT_MASK_MAX_AGG_NUM_8822B) << BIT_SHIFT_MAX_AGG_NUM_8822B)
+#define BIT_GET_MAX_AGG_NUM_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_MAX_AGG_NUM_8822B) & BIT_MASK_MAX_AGG_NUM_8822B)
+
+#define BIT_SHIFT_RTS_TXTIME_TH_8822B 8
+#define BIT_MASK_RTS_TXTIME_TH_8822B 0xff
+#define BIT_RTS_TXTIME_TH_8822B(x)                                             \
+	(((x) & BIT_MASK_RTS_TXTIME_TH_8822B) << BIT_SHIFT_RTS_TXTIME_TH_8822B)
+#define BIT_GET_RTS_TXTIME_TH_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_RTS_TXTIME_TH_8822B) & BIT_MASK_RTS_TXTIME_TH_8822B)
+
+#define BIT_SHIFT_RTS_LEN_TH_8822B 0
+#define BIT_MASK_RTS_LEN_TH_8822B 0xff
+#define BIT_RTS_LEN_TH_8822B(x)                                                \
+	(((x) & BIT_MASK_RTS_LEN_TH_8822B) << BIT_SHIFT_RTS_LEN_TH_8822B)
+#define BIT_GET_RTS_LEN_TH_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_RTS_LEN_TH_8822B) & BIT_MASK_RTS_LEN_TH_8822B)
+
+/* 2 REG_BAR_MODE_CTRL_8822B */
+
+#define BIT_SHIFT_BAR_RTY_LMT_8822B 16
+#define BIT_MASK_BAR_RTY_LMT_8822B 0x3
+#define BIT_BAR_RTY_LMT_8822B(x)                                               \
+	(((x) & BIT_MASK_BAR_RTY_LMT_8822B) << BIT_SHIFT_BAR_RTY_LMT_8822B)
+#define BIT_GET_BAR_RTY_LMT_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_BAR_RTY_LMT_8822B) & BIT_MASK_BAR_RTY_LMT_8822B)
+
+#define BIT_SHIFT_BAR_PKT_TXTIME_TH_8822B 8
+#define BIT_MASK_BAR_PKT_TXTIME_TH_8822B 0xff
+#define BIT_BAR_PKT_TXTIME_TH_8822B(x)                                         \
+	(((x) & BIT_MASK_BAR_PKT_TXTIME_TH_8822B)                              \
+	 << BIT_SHIFT_BAR_PKT_TXTIME_TH_8822B)
+#define BIT_GET_BAR_PKT_TXTIME_TH_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_BAR_PKT_TXTIME_TH_8822B) &                          \
+	 BIT_MASK_BAR_PKT_TXTIME_TH_8822B)
+
+#define BIT_BAR_EN_V1_8822B BIT(6)
+
+#define BIT_SHIFT_BAR_PKTNUM_TH_V1_8822B 0
+#define BIT_MASK_BAR_PKTNUM_TH_V1_8822B 0x3f
+#define BIT_BAR_PKTNUM_TH_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_BAR_PKTNUM_TH_V1_8822B)                               \
+	 << BIT_SHIFT_BAR_PKTNUM_TH_V1_8822B)
+#define BIT_GET_BAR_PKTNUM_TH_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_BAR_PKTNUM_TH_V1_8822B) &                           \
+	 BIT_MASK_BAR_PKTNUM_TH_V1_8822B)
+
+/* 2 REG_RA_TRY_RATE_AGG_LMT_8822B */
+
+#define BIT_SHIFT_RA_TRY_RATE_AGG_LMT_V1_8822B 0
+#define BIT_MASK_RA_TRY_RATE_AGG_LMT_V1_8822B 0x3f
+#define BIT_RA_TRY_RATE_AGG_LMT_V1_8822B(x)                                    \
+	(((x) & BIT_MASK_RA_TRY_RATE_AGG_LMT_V1_8822B)                         \
+	 << BIT_SHIFT_RA_TRY_RATE_AGG_LMT_V1_8822B)
+#define BIT_GET_RA_TRY_RATE_AGG_LMT_V1_8822B(x)                                \
+	(((x) >> BIT_SHIFT_RA_TRY_RATE_AGG_LMT_V1_8822B) &                     \
+	 BIT_MASK_RA_TRY_RATE_AGG_LMT_V1_8822B)
+
+/* 2 REG_MACID_SLEEP2_8822B */
+
+#define BIT_SHIFT_MACID95_64PKTSLEEP_8822B 0
+#define BIT_MASK_MACID95_64PKTSLEEP_8822B 0xffffffffL
+#define BIT_MACID95_64PKTSLEEP_8822B(x)                                        \
+	(((x) & BIT_MASK_MACID95_64PKTSLEEP_8822B)                             \
+	 << BIT_SHIFT_MACID95_64PKTSLEEP_8822B)
+#define BIT_GET_MACID95_64PKTSLEEP_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_MACID95_64PKTSLEEP_8822B) &                         \
+	 BIT_MASK_MACID95_64PKTSLEEP_8822B)
+
+/* 2 REG_MACID_SLEEP_8822B */
+
+#define BIT_SHIFT_MACID31_0_PKTSLEEP_8822B 0
+#define BIT_MASK_MACID31_0_PKTSLEEP_8822B 0xffffffffL
+#define BIT_MACID31_0_PKTSLEEP_8822B(x)                                        \
+	(((x) & BIT_MASK_MACID31_0_PKTSLEEP_8822B)                             \
+	 << BIT_SHIFT_MACID31_0_PKTSLEEP_8822B)
+#define BIT_GET_MACID31_0_PKTSLEEP_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_MACID31_0_PKTSLEEP_8822B) &                         \
+	 BIT_MASK_MACID31_0_PKTSLEEP_8822B)
+
+/* 2 REG_HW_SEQ0_8822B */
+
+#define BIT_SHIFT_HW_SSN_SEQ0_8822B 0
+#define BIT_MASK_HW_SSN_SEQ0_8822B 0xfff
+#define BIT_HW_SSN_SEQ0_8822B(x)                                               \
+	(((x) & BIT_MASK_HW_SSN_SEQ0_8822B) << BIT_SHIFT_HW_SSN_SEQ0_8822B)
+#define BIT_GET_HW_SSN_SEQ0_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HW_SSN_SEQ0_8822B) & BIT_MASK_HW_SSN_SEQ0_8822B)
+
+/* 2 REG_HW_SEQ1_8822B */
+
+#define BIT_SHIFT_HW_SSN_SEQ1_8822B 0
+#define BIT_MASK_HW_SSN_SEQ1_8822B 0xfff
+#define BIT_HW_SSN_SEQ1_8822B(x)                                               \
+	(((x) & BIT_MASK_HW_SSN_SEQ1_8822B) << BIT_SHIFT_HW_SSN_SEQ1_8822B)
+#define BIT_GET_HW_SSN_SEQ1_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HW_SSN_SEQ1_8822B) & BIT_MASK_HW_SSN_SEQ1_8822B)
+
+/* 2 REG_HW_SEQ2_8822B */
+
+#define BIT_SHIFT_HW_SSN_SEQ2_8822B 0
+#define BIT_MASK_HW_SSN_SEQ2_8822B 0xfff
+#define BIT_HW_SSN_SEQ2_8822B(x)                                               \
+	(((x) & BIT_MASK_HW_SSN_SEQ2_8822B) << BIT_SHIFT_HW_SSN_SEQ2_8822B)
+#define BIT_GET_HW_SSN_SEQ2_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HW_SSN_SEQ2_8822B) & BIT_MASK_HW_SSN_SEQ2_8822B)
+
+/* 2 REG_HW_SEQ3_8822B */
+
+#define BIT_SHIFT_HW_SSN_SEQ3_8822B 0
+#define BIT_MASK_HW_SSN_SEQ3_8822B 0xfff
+#define BIT_HW_SSN_SEQ3_8822B(x)                                               \
+	(((x) & BIT_MASK_HW_SSN_SEQ3_8822B) << BIT_SHIFT_HW_SSN_SEQ3_8822B)
+#define BIT_GET_HW_SSN_SEQ3_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_HW_SSN_SEQ3_8822B) & BIT_MASK_HW_SSN_SEQ3_8822B)
+
+/* 2 REG_NULL_PKT_STATUS_V1_8822B */
+
+#define BIT_SHIFT_PTCL_TOTAL_PG_V2_8822B 2
+#define BIT_MASK_PTCL_TOTAL_PG_V2_8822B 0x3fff
+#define BIT_PTCL_TOTAL_PG_V2_8822B(x)                                          \
+	(((x) & BIT_MASK_PTCL_TOTAL_PG_V2_8822B)                               \
+	 << BIT_SHIFT_PTCL_TOTAL_PG_V2_8822B)
+#define BIT_GET_PTCL_TOTAL_PG_V2_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_PTCL_TOTAL_PG_V2_8822B) &                           \
+	 BIT_MASK_PTCL_TOTAL_PG_V2_8822B)
+
+#define BIT_TX_NULL_1_8822B BIT(1)
+#define BIT_TX_NULL_0_8822B BIT(0)
+
+/* 2 REG_PTCL_ERR_STATUS_8822B */
+#define BIT_PTCL_RATE_TABLE_INVALID_8822B BIT(7)
+#define BIT_FTM_T2R_ERROR_8822B BIT(6)
+#define BIT_PTCL_ERR0_8822B BIT(5)
+#define BIT_PTCL_ERR1_8822B BIT(4)
+#define BIT_PTCL_ERR2_8822B BIT(3)
+#define BIT_PTCL_ERR3_8822B BIT(2)
+#define BIT_PTCL_ERR4_8822B BIT(1)
+#define BIT_PTCL_ERR5_8822B BIT(0)
+
+/* 2 REG_NULL_PKT_STATUS_EXTEND_8822B */
+#define BIT_CLI3_TX_NULL_1_8822B BIT(7)
+#define BIT_CLI3_TX_NULL_0_8822B BIT(6)
+#define BIT_CLI2_TX_NULL_1_8822B BIT(5)
+#define BIT_CLI2_TX_NULL_0_8822B BIT(4)
+#define BIT_CLI1_TX_NULL_1_8822B BIT(3)
+#define BIT_CLI1_TX_NULL_0_8822B BIT(2)
+#define BIT_CLI0_TX_NULL_1_8822B BIT(1)
+#define BIT_CLI0_TX_NULL_0_8822B BIT(0)
+
+/* 2 REG_VIDEO_ENHANCEMENT_FUN_8822B */
+#define BIT_VIDEO_JUST_DROP_8822B BIT(1)
+#define BIT_VIDEO_ENHANCEMENT_FUN_EN_8822B BIT(0)
+
+/* 2 REG_BT_POLLUTE_PKT_CNT_8822B */
+
+#define BIT_SHIFT_BT_POLLUTE_PKT_CNT_8822B 0
+#define BIT_MASK_BT_POLLUTE_PKT_CNT_8822B 0xffff
+#define BIT_BT_POLLUTE_PKT_CNT_8822B(x)                                        \
+	(((x) & BIT_MASK_BT_POLLUTE_PKT_CNT_8822B)                             \
+	 << BIT_SHIFT_BT_POLLUTE_PKT_CNT_8822B)
+#define BIT_GET_BT_POLLUTE_PKT_CNT_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_BT_POLLUTE_PKT_CNT_8822B) &                         \
+	 BIT_MASK_BT_POLLUTE_PKT_CNT_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_PTCL_DBG_8822B */
+
+#define BIT_SHIFT_PTCL_DBG_8822B 0
+#define BIT_MASK_PTCL_DBG_8822B 0xffffffffL
+#define BIT_PTCL_DBG_8822B(x)                                                  \
+	(((x) & BIT_MASK_PTCL_DBG_8822B) << BIT_SHIFT_PTCL_DBG_8822B)
+#define BIT_GET_PTCL_DBG_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_PTCL_DBG_8822B) & BIT_MASK_PTCL_DBG_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_CPUMGQ_TIMER_CTRL2_8822B */
+
+#define BIT_SHIFT_TRI_HEAD_ADDR_8822B 16
+#define BIT_MASK_TRI_HEAD_ADDR_8822B 0xfff
+#define BIT_TRI_HEAD_ADDR_8822B(x)                                             \
+	(((x) & BIT_MASK_TRI_HEAD_ADDR_8822B) << BIT_SHIFT_TRI_HEAD_ADDR_8822B)
+#define BIT_GET_TRI_HEAD_ADDR_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_TRI_HEAD_ADDR_8822B) & BIT_MASK_TRI_HEAD_ADDR_8822B)
+
+#define BIT_DROP_TH_EN_8822B BIT(8)
+
+#define BIT_SHIFT_DROP_TH_8822B 0
+#define BIT_MASK_DROP_TH_8822B 0xff
+#define BIT_DROP_TH_8822B(x)                                                   \
+	(((x) & BIT_MASK_DROP_TH_8822B) << BIT_SHIFT_DROP_TH_8822B)
+#define BIT_GET_DROP_TH_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_DROP_TH_8822B) & BIT_MASK_DROP_TH_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_DUMMY_PAGE4_V1_8822B */
+#define BIT_BCN_EN_EXTHWSEQ_8822B BIT(1)
+#define BIT_BCN_EN_HWSEQ_8822B BIT(0)
+
+/* 2 REG_MOREDATA_8822B */
+#define BIT_MOREDATA_CTRL2_EN_V1_8822B BIT(3)
+#define BIT_MOREDATA_CTRL1_EN_V1_8822B BIT(2)
+#define BIT_PKTIN_MOREDATA_REPLACE_ENABLE_V1_8822B BIT(0)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_Q0_Q1_INFO_8822B */
+#define BIT_QUEUE_MACID_AC_NOT_THE_SAME_8822B BIT(31)
+
+#define BIT_SHIFT_GTAB_ID_8822B 28
+#define BIT_MASK_GTAB_ID_8822B 0x7
+#define BIT_GTAB_ID_8822B(x)                                                   \
+	(((x) & BIT_MASK_GTAB_ID_8822B) << BIT_SHIFT_GTAB_ID_8822B)
+#define BIT_GET_GTAB_ID_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_GTAB_ID_8822B) & BIT_MASK_GTAB_ID_8822B)
+
+#define BIT_SHIFT_AC1_PKT_INFO_8822B 16
+#define BIT_MASK_AC1_PKT_INFO_8822B 0xfff
+#define BIT_AC1_PKT_INFO_8822B(x)                                              \
+	(((x) & BIT_MASK_AC1_PKT_INFO_8822B) << BIT_SHIFT_AC1_PKT_INFO_8822B)
+#define BIT_GET_AC1_PKT_INFO_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_AC1_PKT_INFO_8822B) & BIT_MASK_AC1_PKT_INFO_8822B)
+
+#define BIT_QUEUE_MACID_AC_NOT_THE_SAME_V1_8822B BIT(15)
+
+#define BIT_SHIFT_GTAB_ID_V1_8822B 12
+#define BIT_MASK_GTAB_ID_V1_8822B 0x7
+#define BIT_GTAB_ID_V1_8822B(x)                                                \
+	(((x) & BIT_MASK_GTAB_ID_V1_8822B) << BIT_SHIFT_GTAB_ID_V1_8822B)
+#define BIT_GET_GTAB_ID_V1_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_GTAB_ID_V1_8822B) & BIT_MASK_GTAB_ID_V1_8822B)
+
+#define BIT_SHIFT_AC0_PKT_INFO_8822B 0
+#define BIT_MASK_AC0_PKT_INFO_8822B 0xfff
+#define BIT_AC0_PKT_INFO_8822B(x)                                              \
+	(((x) & BIT_MASK_AC0_PKT_INFO_8822B) << BIT_SHIFT_AC0_PKT_INFO_8822B)
+#define BIT_GET_AC0_PKT_INFO_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_AC0_PKT_INFO_8822B) & BIT_MASK_AC0_PKT_INFO_8822B)
+
+/* 2 REG_Q2_Q3_INFO_8822B */
+#define BIT_QUEUE_MACID_AC_NOT_THE_SAME_8822B BIT(31)
+
+#define BIT_SHIFT_GTAB_ID_8822B 28
+#define BIT_MASK_GTAB_ID_8822B 0x7
+#define BIT_GTAB_ID_8822B(x)                                                   \
+	(((x) & BIT_MASK_GTAB_ID_8822B) << BIT_SHIFT_GTAB_ID_8822B)
+#define BIT_GET_GTAB_ID_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_GTAB_ID_8822B) & BIT_MASK_GTAB_ID_8822B)
+
+#define BIT_SHIFT_AC3_PKT_INFO_8822B 16
+#define BIT_MASK_AC3_PKT_INFO_8822B 0xfff
+#define BIT_AC3_PKT_INFO_8822B(x)                                              \
+	(((x) & BIT_MASK_AC3_PKT_INFO_8822B) << BIT_SHIFT_AC3_PKT_INFO_8822B)
+#define BIT_GET_AC3_PKT_INFO_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_AC3_PKT_INFO_8822B) & BIT_MASK_AC3_PKT_INFO_8822B)
+
+#define BIT_QUEUE_MACID_AC_NOT_THE_SAME_V1_8822B BIT(15)
+
+#define BIT_SHIFT_GTAB_ID_V1_8822B 12
+#define BIT_MASK_GTAB_ID_V1_8822B 0x7
+#define BIT_GTAB_ID_V1_8822B(x)                                                \
+	(((x) & BIT_MASK_GTAB_ID_V1_8822B) << BIT_SHIFT_GTAB_ID_V1_8822B)
+#define BIT_GET_GTAB_ID_V1_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_GTAB_ID_V1_8822B) & BIT_MASK_GTAB_ID_V1_8822B)
+
+#define BIT_SHIFT_AC2_PKT_INFO_8822B 0
+#define BIT_MASK_AC2_PKT_INFO_8822B 0xfff
+#define BIT_AC2_PKT_INFO_8822B(x)                                              \
+	(((x) & BIT_MASK_AC2_PKT_INFO_8822B) << BIT_SHIFT_AC2_PKT_INFO_8822B)
+#define BIT_GET_AC2_PKT_INFO_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_AC2_PKT_INFO_8822B) & BIT_MASK_AC2_PKT_INFO_8822B)
+
+/* 2 REG_Q4_Q5_INFO_8822B */
+#define BIT_QUEUE_MACID_AC_NOT_THE_SAME_8822B BIT(31)
+
+#define BIT_SHIFT_GTAB_ID_8822B 28
+#define BIT_MASK_GTAB_ID_8822B 0x7
+#define BIT_GTAB_ID_8822B(x)                                                   \
+	(((x) & BIT_MASK_GTAB_ID_8822B) << BIT_SHIFT_GTAB_ID_8822B)
+#define BIT_GET_GTAB_ID_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_GTAB_ID_8822B) & BIT_MASK_GTAB_ID_8822B)
+
+#define BIT_SHIFT_AC5_PKT_INFO_8822B 16
+#define BIT_MASK_AC5_PKT_INFO_8822B 0xfff
+#define BIT_AC5_PKT_INFO_8822B(x)                                              \
+	(((x) & BIT_MASK_AC5_PKT_INFO_8822B) << BIT_SHIFT_AC5_PKT_INFO_8822B)
+#define BIT_GET_AC5_PKT_INFO_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_AC5_PKT_INFO_8822B) & BIT_MASK_AC5_PKT_INFO_8822B)
+
+#define BIT_QUEUE_MACID_AC_NOT_THE_SAME_V1_8822B BIT(15)
+
+#define BIT_SHIFT_GTAB_ID_V1_8822B 12
+#define BIT_MASK_GTAB_ID_V1_8822B 0x7
+#define BIT_GTAB_ID_V1_8822B(x)                                                \
+	(((x) & BIT_MASK_GTAB_ID_V1_8822B) << BIT_SHIFT_GTAB_ID_V1_8822B)
+#define BIT_GET_GTAB_ID_V1_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_GTAB_ID_V1_8822B) & BIT_MASK_GTAB_ID_V1_8822B)
+
+#define BIT_SHIFT_AC4_PKT_INFO_8822B 0
+#define BIT_MASK_AC4_PKT_INFO_8822B 0xfff
+#define BIT_AC4_PKT_INFO_8822B(x)                                              \
+	(((x) & BIT_MASK_AC4_PKT_INFO_8822B) << BIT_SHIFT_AC4_PKT_INFO_8822B)
+#define BIT_GET_AC4_PKT_INFO_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_AC4_PKT_INFO_8822B) & BIT_MASK_AC4_PKT_INFO_8822B)
+
+/* 2 REG_Q6_Q7_INFO_8822B */
+#define BIT_QUEUE_MACID_AC_NOT_THE_SAME_8822B BIT(31)
+
+#define BIT_SHIFT_GTAB_ID_8822B 28
+#define BIT_MASK_GTAB_ID_8822B 0x7
+#define BIT_GTAB_ID_8822B(x)                                                   \
+	(((x) & BIT_MASK_GTAB_ID_8822B) << BIT_SHIFT_GTAB_ID_8822B)
+#define BIT_GET_GTAB_ID_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_GTAB_ID_8822B) & BIT_MASK_GTAB_ID_8822B)
+
+#define BIT_SHIFT_AC7_PKT_INFO_8822B 16
+#define BIT_MASK_AC7_PKT_INFO_8822B 0xfff
+#define BIT_AC7_PKT_INFO_8822B(x)                                              \
+	(((x) & BIT_MASK_AC7_PKT_INFO_8822B) << BIT_SHIFT_AC7_PKT_INFO_8822B)
+#define BIT_GET_AC7_PKT_INFO_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_AC7_PKT_INFO_8822B) & BIT_MASK_AC7_PKT_INFO_8822B)
+
+#define BIT_QUEUE_MACID_AC_NOT_THE_SAME_V1_8822B BIT(15)
+
+#define BIT_SHIFT_GTAB_ID_V1_8822B 12
+#define BIT_MASK_GTAB_ID_V1_8822B 0x7
+#define BIT_GTAB_ID_V1_8822B(x)                                                \
+	(((x) & BIT_MASK_GTAB_ID_V1_8822B) << BIT_SHIFT_GTAB_ID_V1_8822B)
+#define BIT_GET_GTAB_ID_V1_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_GTAB_ID_V1_8822B) & BIT_MASK_GTAB_ID_V1_8822B)
+
+#define BIT_SHIFT_AC6_PKT_INFO_8822B 0
+#define BIT_MASK_AC6_PKT_INFO_8822B 0xfff
+#define BIT_AC6_PKT_INFO_8822B(x)                                              \
+	(((x) & BIT_MASK_AC6_PKT_INFO_8822B) << BIT_SHIFT_AC6_PKT_INFO_8822B)
+#define BIT_GET_AC6_PKT_INFO_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_AC6_PKT_INFO_8822B) & BIT_MASK_AC6_PKT_INFO_8822B)
+
+/* 2 REG_MGQ_HIQ_INFO_8822B */
+
+#define BIT_SHIFT_HIQ_PKT_INFO_8822B 16
+#define BIT_MASK_HIQ_PKT_INFO_8822B 0xfff
+#define BIT_HIQ_PKT_INFO_8822B(x)                                              \
+	(((x) & BIT_MASK_HIQ_PKT_INFO_8822B) << BIT_SHIFT_HIQ_PKT_INFO_8822B)
+#define BIT_GET_HIQ_PKT_INFO_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_HIQ_PKT_INFO_8822B) & BIT_MASK_HIQ_PKT_INFO_8822B)
+
+#define BIT_SHIFT_MGQ_PKT_INFO_8822B 0
+#define BIT_MASK_MGQ_PKT_INFO_8822B 0xfff
+#define BIT_MGQ_PKT_INFO_8822B(x)                                              \
+	(((x) & BIT_MASK_MGQ_PKT_INFO_8822B) << BIT_SHIFT_MGQ_PKT_INFO_8822B)
+#define BIT_GET_MGQ_PKT_INFO_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_MGQ_PKT_INFO_8822B) & BIT_MASK_MGQ_PKT_INFO_8822B)
+
+/* 2 REG_CMDQ_BCNQ_INFO_8822B */
+
+#define BIT_SHIFT_CMDQ_PKT_INFO_8822B 16
+#define BIT_MASK_CMDQ_PKT_INFO_8822B 0xfff
+#define BIT_CMDQ_PKT_INFO_8822B(x)                                             \
+	(((x) & BIT_MASK_CMDQ_PKT_INFO_8822B) << BIT_SHIFT_CMDQ_PKT_INFO_8822B)
+#define BIT_GET_CMDQ_PKT_INFO_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_CMDQ_PKT_INFO_8822B) & BIT_MASK_CMDQ_PKT_INFO_8822B)
+
+#define BIT_SHIFT_BCNQ_PKT_INFO_8822B 0
+#define BIT_MASK_BCNQ_PKT_INFO_8822B 0xfff
+#define BIT_BCNQ_PKT_INFO_8822B(x)                                             \
+	(((x) & BIT_MASK_BCNQ_PKT_INFO_8822B) << BIT_SHIFT_BCNQ_PKT_INFO_8822B)
+#define BIT_GET_BCNQ_PKT_INFO_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_BCNQ_PKT_INFO_8822B) & BIT_MASK_BCNQ_PKT_INFO_8822B)
+
+/* 2 REG_USEREG_SETTING_8822B */
+#define BIT_NDPA_USEREG_8822B BIT(21)
+
+#define BIT_SHIFT_RETRY_USEREG_8822B 19
+#define BIT_MASK_RETRY_USEREG_8822B 0x3
+#define BIT_RETRY_USEREG_8822B(x)                                              \
+	(((x) & BIT_MASK_RETRY_USEREG_8822B) << BIT_SHIFT_RETRY_USEREG_8822B)
+#define BIT_GET_RETRY_USEREG_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_RETRY_USEREG_8822B) & BIT_MASK_RETRY_USEREG_8822B)
+
+#define BIT_SHIFT_TRYPKT_USEREG_8822B 17
+#define BIT_MASK_TRYPKT_USEREG_8822B 0x3
+#define BIT_TRYPKT_USEREG_8822B(x)                                             \
+	(((x) & BIT_MASK_TRYPKT_USEREG_8822B) << BIT_SHIFT_TRYPKT_USEREG_8822B)
+#define BIT_GET_TRYPKT_USEREG_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_TRYPKT_USEREG_8822B) & BIT_MASK_TRYPKT_USEREG_8822B)
+
+#define BIT_CTLPKT_USEREG_8822B BIT(16)
+
+/* 2 REG_AESIV_SETTING_8822B */
+
+#define BIT_SHIFT_AESIV_OFFSET_8822B 0
+#define BIT_MASK_AESIV_OFFSET_8822B 0xfff
+#define BIT_AESIV_OFFSET_8822B(x)                                              \
+	(((x) & BIT_MASK_AESIV_OFFSET_8822B) << BIT_SHIFT_AESIV_OFFSET_8822B)
+#define BIT_GET_AESIV_OFFSET_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_AESIV_OFFSET_8822B) & BIT_MASK_AESIV_OFFSET_8822B)
+
+/* 2 REG_BF0_TIME_SETTING_8822B */
+#define BIT_BF0_TIMER_SET_8822B BIT(31)
+#define BIT_BF0_TIMER_CLR_8822B BIT(30)
+#define BIT_BF0_UPDATE_EN_8822B BIT(29)
+#define BIT_BF0_TIMER_EN_8822B BIT(28)
+
+#define BIT_SHIFT_BF0_PRETIME_OVER_8822B 16
+#define BIT_MASK_BF0_PRETIME_OVER_8822B 0xfff
+#define BIT_BF0_PRETIME_OVER_8822B(x)                                          \
+	(((x) & BIT_MASK_BF0_PRETIME_OVER_8822B)                               \
+	 << BIT_SHIFT_BF0_PRETIME_OVER_8822B)
+#define BIT_GET_BF0_PRETIME_OVER_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_BF0_PRETIME_OVER_8822B) &                           \
+	 BIT_MASK_BF0_PRETIME_OVER_8822B)
+
+#define BIT_SHIFT_BF0_LIFETIME_8822B 0
+#define BIT_MASK_BF0_LIFETIME_8822B 0xffff
+#define BIT_BF0_LIFETIME_8822B(x)                                              \
+	(((x) & BIT_MASK_BF0_LIFETIME_8822B) << BIT_SHIFT_BF0_LIFETIME_8822B)
+#define BIT_GET_BF0_LIFETIME_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_BF0_LIFETIME_8822B) & BIT_MASK_BF0_LIFETIME_8822B)
+
+/* 2 REG_BF1_TIME_SETTING_8822B */
+#define BIT_BF1_TIMER_SET_8822B BIT(31)
+#define BIT_BF1_TIMER_CLR_8822B BIT(30)
+#define BIT_BF1_UPDATE_EN_8822B BIT(29)
+#define BIT_BF1_TIMER_EN_8822B BIT(28)
+
+#define BIT_SHIFT_BF1_PRETIME_OVER_8822B 16
+#define BIT_MASK_BF1_PRETIME_OVER_8822B 0xfff
+#define BIT_BF1_PRETIME_OVER_8822B(x)                                          \
+	(((x) & BIT_MASK_BF1_PRETIME_OVER_8822B)                               \
+	 << BIT_SHIFT_BF1_PRETIME_OVER_8822B)
+#define BIT_GET_BF1_PRETIME_OVER_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_BF1_PRETIME_OVER_8822B) &                           \
+	 BIT_MASK_BF1_PRETIME_OVER_8822B)
+
+#define BIT_SHIFT_BF1_LIFETIME_8822B 0
+#define BIT_MASK_BF1_LIFETIME_8822B 0xffff
+#define BIT_BF1_LIFETIME_8822B(x)                                              \
+	(((x) & BIT_MASK_BF1_LIFETIME_8822B) << BIT_SHIFT_BF1_LIFETIME_8822B)
+#define BIT_GET_BF1_LIFETIME_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_BF1_LIFETIME_8822B) & BIT_MASK_BF1_LIFETIME_8822B)
+
+/* 2 REG_BF_TIMEOUT_EN_8822B */
+#define BIT_EN_VHT_LDPC_8822B BIT(9)
+#define BIT_EN_HT_LDPC_8822B BIT(8)
+#define BIT_BF1_TIMEOUT_EN_8822B BIT(1)
+#define BIT_BF0_TIMEOUT_EN_8822B BIT(0)
+
+/* 2 REG_MACID_RELEASE0_8822B */
+
+#define BIT_SHIFT_MACID31_0_RELEASE_8822B 0
+#define BIT_MASK_MACID31_0_RELEASE_8822B 0xffffffffL
+#define BIT_MACID31_0_RELEASE_8822B(x)                                         \
+	(((x) & BIT_MASK_MACID31_0_RELEASE_8822B)                              \
+	 << BIT_SHIFT_MACID31_0_RELEASE_8822B)
+#define BIT_GET_MACID31_0_RELEASE_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_MACID31_0_RELEASE_8822B) &                          \
+	 BIT_MASK_MACID31_0_RELEASE_8822B)
+
+/* 2 REG_MACID_RELEASE1_8822B */
+
+#define BIT_SHIFT_MACID63_32_RELEASE_8822B 0
+#define BIT_MASK_MACID63_32_RELEASE_8822B 0xffffffffL
+#define BIT_MACID63_32_RELEASE_8822B(x)                                        \
+	(((x) & BIT_MASK_MACID63_32_RELEASE_8822B)                             \
+	 << BIT_SHIFT_MACID63_32_RELEASE_8822B)
+#define BIT_GET_MACID63_32_RELEASE_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_MACID63_32_RELEASE_8822B) &                         \
+	 BIT_MASK_MACID63_32_RELEASE_8822B)
+
+/* 2 REG_MACID_RELEASE2_8822B */
+
+#define BIT_SHIFT_MACID95_64_RELEASE_8822B 0
+#define BIT_MASK_MACID95_64_RELEASE_8822B 0xffffffffL
+#define BIT_MACID95_64_RELEASE_8822B(x)                                        \
+	(((x) & BIT_MASK_MACID95_64_RELEASE_8822B)                             \
+	 << BIT_SHIFT_MACID95_64_RELEASE_8822B)
+#define BIT_GET_MACID95_64_RELEASE_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_MACID95_64_RELEASE_8822B) &                         \
+	 BIT_MASK_MACID95_64_RELEASE_8822B)
+
+/* 2 REG_MACID_RELEASE3_8822B */
+
+#define BIT_SHIFT_MACID127_96_RELEASE_8822B 0
+#define BIT_MASK_MACID127_96_RELEASE_8822B 0xffffffffL
+#define BIT_MACID127_96_RELEASE_8822B(x)                                       \
+	(((x) & BIT_MASK_MACID127_96_RELEASE_8822B)                            \
+	 << BIT_SHIFT_MACID127_96_RELEASE_8822B)
+#define BIT_GET_MACID127_96_RELEASE_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_MACID127_96_RELEASE_8822B) &                        \
+	 BIT_MASK_MACID127_96_RELEASE_8822B)
+
+/* 2 REG_MACID_RELEASE_SETTING_8822B */
+#define BIT_MACID_VALUE_8822B BIT(7)
+
+#define BIT_SHIFT_MACID_OFFSET_8822B 0
+#define BIT_MASK_MACID_OFFSET_8822B 0x7f
+#define BIT_MACID_OFFSET_8822B(x)                                              \
+	(((x) & BIT_MASK_MACID_OFFSET_8822B) << BIT_SHIFT_MACID_OFFSET_8822B)
+#define BIT_GET_MACID_OFFSET_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_MACID_OFFSET_8822B) & BIT_MASK_MACID_OFFSET_8822B)
+
+/* 2 REG_FAST_EDCA_VOVI_SETTING_8822B */
+
+#define BIT_SHIFT_VI_FAST_EDCA_TO_8822B 24
+#define BIT_MASK_VI_FAST_EDCA_TO_8822B 0xff
+#define BIT_VI_FAST_EDCA_TO_8822B(x)                                           \
+	(((x) & BIT_MASK_VI_FAST_EDCA_TO_8822B)                                \
+	 << BIT_SHIFT_VI_FAST_EDCA_TO_8822B)
+#define BIT_GET_VI_FAST_EDCA_TO_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_VI_FAST_EDCA_TO_8822B) &                            \
+	 BIT_MASK_VI_FAST_EDCA_TO_8822B)
+
+#define BIT_VI_THRESHOLD_SEL_8822B BIT(23)
+
+#define BIT_SHIFT_VI_FAST_EDCA_PKT_TH_8822B 16
+#define BIT_MASK_VI_FAST_EDCA_PKT_TH_8822B 0x7f
+#define BIT_VI_FAST_EDCA_PKT_TH_8822B(x)                                       \
+	(((x) & BIT_MASK_VI_FAST_EDCA_PKT_TH_8822B)                            \
+	 << BIT_SHIFT_VI_FAST_EDCA_PKT_TH_8822B)
+#define BIT_GET_VI_FAST_EDCA_PKT_TH_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_VI_FAST_EDCA_PKT_TH_8822B) &                        \
+	 BIT_MASK_VI_FAST_EDCA_PKT_TH_8822B)
+
+#define BIT_SHIFT_VO_FAST_EDCA_TO_8822B 8
+#define BIT_MASK_VO_FAST_EDCA_TO_8822B 0xff
+#define BIT_VO_FAST_EDCA_TO_8822B(x)                                           \
+	(((x) & BIT_MASK_VO_FAST_EDCA_TO_8822B)                                \
+	 << BIT_SHIFT_VO_FAST_EDCA_TO_8822B)
+#define BIT_GET_VO_FAST_EDCA_TO_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_VO_FAST_EDCA_TO_8822B) &                            \
+	 BIT_MASK_VO_FAST_EDCA_TO_8822B)
+
+#define BIT_VO_THRESHOLD_SEL_8822B BIT(7)
+
+#define BIT_SHIFT_VO_FAST_EDCA_PKT_TH_8822B 0
+#define BIT_MASK_VO_FAST_EDCA_PKT_TH_8822B 0x7f
+#define BIT_VO_FAST_EDCA_PKT_TH_8822B(x)                                       \
+	(((x) & BIT_MASK_VO_FAST_EDCA_PKT_TH_8822B)                            \
+	 << BIT_SHIFT_VO_FAST_EDCA_PKT_TH_8822B)
+#define BIT_GET_VO_FAST_EDCA_PKT_TH_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_VO_FAST_EDCA_PKT_TH_8822B) &                        \
+	 BIT_MASK_VO_FAST_EDCA_PKT_TH_8822B)
+
+/* 2 REG_FAST_EDCA_BEBK_SETTING_8822B */
+
+#define BIT_SHIFT_BK_FAST_EDCA_TO_8822B 24
+#define BIT_MASK_BK_FAST_EDCA_TO_8822B 0xff
+#define BIT_BK_FAST_EDCA_TO_8822B(x)                                           \
+	(((x) & BIT_MASK_BK_FAST_EDCA_TO_8822B)                                \
+	 << BIT_SHIFT_BK_FAST_EDCA_TO_8822B)
+#define BIT_GET_BK_FAST_EDCA_TO_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_BK_FAST_EDCA_TO_8822B) &                            \
+	 BIT_MASK_BK_FAST_EDCA_TO_8822B)
+
+#define BIT_BK_THRESHOLD_SEL_8822B BIT(23)
+
+#define BIT_SHIFT_BK_FAST_EDCA_PKT_TH_8822B 16
+#define BIT_MASK_BK_FAST_EDCA_PKT_TH_8822B 0x7f
+#define BIT_BK_FAST_EDCA_PKT_TH_8822B(x)                                       \
+	(((x) & BIT_MASK_BK_FAST_EDCA_PKT_TH_8822B)                            \
+	 << BIT_SHIFT_BK_FAST_EDCA_PKT_TH_8822B)
+#define BIT_GET_BK_FAST_EDCA_PKT_TH_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_BK_FAST_EDCA_PKT_TH_8822B) &                        \
+	 BIT_MASK_BK_FAST_EDCA_PKT_TH_8822B)
+
+#define BIT_SHIFT_BE_FAST_EDCA_TO_8822B 8
+#define BIT_MASK_BE_FAST_EDCA_TO_8822B 0xff
+#define BIT_BE_FAST_EDCA_TO_8822B(x)                                           \
+	(((x) & BIT_MASK_BE_FAST_EDCA_TO_8822B)                                \
+	 << BIT_SHIFT_BE_FAST_EDCA_TO_8822B)
+#define BIT_GET_BE_FAST_EDCA_TO_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_BE_FAST_EDCA_TO_8822B) &                            \
+	 BIT_MASK_BE_FAST_EDCA_TO_8822B)
+
+#define BIT_BE_THRESHOLD_SEL_8822B BIT(7)
+
+#define BIT_SHIFT_BE_FAST_EDCA_PKT_TH_8822B 0
+#define BIT_MASK_BE_FAST_EDCA_PKT_TH_8822B 0x7f
+#define BIT_BE_FAST_EDCA_PKT_TH_8822B(x)                                       \
+	(((x) & BIT_MASK_BE_FAST_EDCA_PKT_TH_8822B)                            \
+	 << BIT_SHIFT_BE_FAST_EDCA_PKT_TH_8822B)
+#define BIT_GET_BE_FAST_EDCA_PKT_TH_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_BE_FAST_EDCA_PKT_TH_8822B) &                        \
+	 BIT_MASK_BE_FAST_EDCA_PKT_TH_8822B)
+
+/* 2 REG_MACID_DROP0_8822B */
+
+#define BIT_SHIFT_MACID31_0_DROP_8822B 0
+#define BIT_MASK_MACID31_0_DROP_8822B 0xffffffffL
+#define BIT_MACID31_0_DROP_8822B(x)                                            \
+	(((x) & BIT_MASK_MACID31_0_DROP_8822B)                                 \
+	 << BIT_SHIFT_MACID31_0_DROP_8822B)
+#define BIT_GET_MACID31_0_DROP_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_MACID31_0_DROP_8822B) &                             \
+	 BIT_MASK_MACID31_0_DROP_8822B)
+
+/* 2 REG_MACID_DROP1_8822B */
+
+#define BIT_SHIFT_MACID63_32_DROP_8822B 0
+#define BIT_MASK_MACID63_32_DROP_8822B 0xffffffffL
+#define BIT_MACID63_32_DROP_8822B(x)                                           \
+	(((x) & BIT_MASK_MACID63_32_DROP_8822B)                                \
+	 << BIT_SHIFT_MACID63_32_DROP_8822B)
+#define BIT_GET_MACID63_32_DROP_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_MACID63_32_DROP_8822B) &                            \
+	 BIT_MASK_MACID63_32_DROP_8822B)
+
+/* 2 REG_MACID_DROP2_8822B */
+
+#define BIT_SHIFT_MACID95_64_DROP_8822B 0
+#define BIT_MASK_MACID95_64_DROP_8822B 0xffffffffL
+#define BIT_MACID95_64_DROP_8822B(x)                                           \
+	(((x) & BIT_MASK_MACID95_64_DROP_8822B)                                \
+	 << BIT_SHIFT_MACID95_64_DROP_8822B)
+#define BIT_GET_MACID95_64_DROP_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_MACID95_64_DROP_8822B) &                            \
+	 BIT_MASK_MACID95_64_DROP_8822B)
+
+/* 2 REG_MACID_DROP3_8822B */
+
+#define BIT_SHIFT_MACID127_96_DROP_8822B 0
+#define BIT_MASK_MACID127_96_DROP_8822B 0xffffffffL
+#define BIT_MACID127_96_DROP_8822B(x)                                          \
+	(((x) & BIT_MASK_MACID127_96_DROP_8822B)                               \
+	 << BIT_SHIFT_MACID127_96_DROP_8822B)
+#define BIT_GET_MACID127_96_DROP_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_MACID127_96_DROP_8822B) &                           \
+	 BIT_MASK_MACID127_96_DROP_8822B)
+
+/* 2 REG_R_MACID_RELEASE_SUCCESS_0_8822B */
+
+#define BIT_SHIFT_R_MACID_RELEASE_SUCCESS_0_8822B 0
+#define BIT_MASK_R_MACID_RELEASE_SUCCESS_0_8822B 0xffffffffL
+#define BIT_R_MACID_RELEASE_SUCCESS_0_8822B(x)                                 \
+	(((x) & BIT_MASK_R_MACID_RELEASE_SUCCESS_0_8822B)                      \
+	 << BIT_SHIFT_R_MACID_RELEASE_SUCCESS_0_8822B)
+#define BIT_GET_R_MACID_RELEASE_SUCCESS_0_8822B(x)                             \
+	(((x) >> BIT_SHIFT_R_MACID_RELEASE_SUCCESS_0_8822B) &                  \
+	 BIT_MASK_R_MACID_RELEASE_SUCCESS_0_8822B)
+
+/* 2 REG_R_MACID_RELEASE_SUCCESS_1_8822B */
+
+#define BIT_SHIFT_R_MACID_RELEASE_SUCCESS_1_8822B 0
+#define BIT_MASK_R_MACID_RELEASE_SUCCESS_1_8822B 0xffffffffL
+#define BIT_R_MACID_RELEASE_SUCCESS_1_8822B(x)                                 \
+	(((x) & BIT_MASK_R_MACID_RELEASE_SUCCESS_1_8822B)                      \
+	 << BIT_SHIFT_R_MACID_RELEASE_SUCCESS_1_8822B)
+#define BIT_GET_R_MACID_RELEASE_SUCCESS_1_8822B(x)                             \
+	(((x) >> BIT_SHIFT_R_MACID_RELEASE_SUCCESS_1_8822B) &                  \
+	 BIT_MASK_R_MACID_RELEASE_SUCCESS_1_8822B)
+
+/* 2 REG_R_MACID_RELEASE_SUCCESS_2_8822B */
+
+#define BIT_SHIFT_R_MACID_RELEASE_SUCCESS_2_8822B 0
+#define BIT_MASK_R_MACID_RELEASE_SUCCESS_2_8822B 0xffffffffL
+#define BIT_R_MACID_RELEASE_SUCCESS_2_8822B(x)                                 \
+	(((x) & BIT_MASK_R_MACID_RELEASE_SUCCESS_2_8822B)                      \
+	 << BIT_SHIFT_R_MACID_RELEASE_SUCCESS_2_8822B)
+#define BIT_GET_R_MACID_RELEASE_SUCCESS_2_8822B(x)                             \
+	(((x) >> BIT_SHIFT_R_MACID_RELEASE_SUCCESS_2_8822B) &                  \
+	 BIT_MASK_R_MACID_RELEASE_SUCCESS_2_8822B)
+
+/* 2 REG_R_MACID_RELEASE_SUCCESS_3_8822B */
+
+#define BIT_SHIFT_R_MACID_RELEASE_SUCCESS_3_8822B 0
+#define BIT_MASK_R_MACID_RELEASE_SUCCESS_3_8822B 0xffffffffL
+#define BIT_R_MACID_RELEASE_SUCCESS_3_8822B(x)                                 \
+	(((x) & BIT_MASK_R_MACID_RELEASE_SUCCESS_3_8822B)                      \
+	 << BIT_SHIFT_R_MACID_RELEASE_SUCCESS_3_8822B)
+#define BIT_GET_R_MACID_RELEASE_SUCCESS_3_8822B(x)                             \
+	(((x) >> BIT_SHIFT_R_MACID_RELEASE_SUCCESS_3_8822B) &                  \
+	 BIT_MASK_R_MACID_RELEASE_SUCCESS_3_8822B)
+
+/* 2 REG_MGG_FIFO_CRTL_8822B */
+#define BIT_R_MGG_FIFO_EN_8822B BIT(31)
+
+#define BIT_SHIFT_R_MGG_FIFO_PG_SIZE_8822B 28
+#define BIT_MASK_R_MGG_FIFO_PG_SIZE_8822B 0x7
+#define BIT_R_MGG_FIFO_PG_SIZE_8822B(x)                                        \
+	(((x) & BIT_MASK_R_MGG_FIFO_PG_SIZE_8822B)                             \
+	 << BIT_SHIFT_R_MGG_FIFO_PG_SIZE_8822B)
+#define BIT_GET_R_MGG_FIFO_PG_SIZE_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_PG_SIZE_8822B) &                         \
+	 BIT_MASK_R_MGG_FIFO_PG_SIZE_8822B)
+
+#define BIT_SHIFT_R_MGG_FIFO_START_PG_8822B 16
+#define BIT_MASK_R_MGG_FIFO_START_PG_8822B 0xfff
+#define BIT_R_MGG_FIFO_START_PG_8822B(x)                                       \
+	(((x) & BIT_MASK_R_MGG_FIFO_START_PG_8822B)                            \
+	 << BIT_SHIFT_R_MGG_FIFO_START_PG_8822B)
+#define BIT_GET_R_MGG_FIFO_START_PG_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_START_PG_8822B) &                        \
+	 BIT_MASK_R_MGG_FIFO_START_PG_8822B)
+
+#define BIT_SHIFT_R_MGG_FIFO_SIZE_8822B 14
+#define BIT_MASK_R_MGG_FIFO_SIZE_8822B 0x3
+#define BIT_R_MGG_FIFO_SIZE_8822B(x)                                           \
+	(((x) & BIT_MASK_R_MGG_FIFO_SIZE_8822B)                                \
+	 << BIT_SHIFT_R_MGG_FIFO_SIZE_8822B)
+#define BIT_GET_R_MGG_FIFO_SIZE_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_SIZE_8822B) &                            \
+	 BIT_MASK_R_MGG_FIFO_SIZE_8822B)
+
+#define BIT_R_MGG_FIFO_PAUSE_8822B BIT(13)
+
+#define BIT_SHIFT_R_MGG_FIFO_RPTR_8822B 8
+#define BIT_MASK_R_MGG_FIFO_RPTR_8822B 0x1f
+#define BIT_R_MGG_FIFO_RPTR_8822B(x)                                           \
+	(((x) & BIT_MASK_R_MGG_FIFO_RPTR_8822B)                                \
+	 << BIT_SHIFT_R_MGG_FIFO_RPTR_8822B)
+#define BIT_GET_R_MGG_FIFO_RPTR_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_RPTR_8822B) &                            \
+	 BIT_MASK_R_MGG_FIFO_RPTR_8822B)
+
+#define BIT_R_MGG_FIFO_OV_8822B BIT(7)
+#define BIT_R_MGG_FIFO_WPTR_ERROR_8822B BIT(6)
+#define BIT_R_EN_CPU_LIFETIME_8822B BIT(5)
+
+#define BIT_SHIFT_R_MGG_FIFO_WPTR_8822B 0
+#define BIT_MASK_R_MGG_FIFO_WPTR_8822B 0x1f
+#define BIT_R_MGG_FIFO_WPTR_8822B(x)                                           \
+	(((x) & BIT_MASK_R_MGG_FIFO_WPTR_8822B)                                \
+	 << BIT_SHIFT_R_MGG_FIFO_WPTR_8822B)
+#define BIT_GET_R_MGG_FIFO_WPTR_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_WPTR_8822B) &                            \
+	 BIT_MASK_R_MGG_FIFO_WPTR_8822B)
+
+/* 2 REG_MGG_FIFO_INT_8822B */
+
+#define BIT_SHIFT_R_MGG_FIFO_INT_FLAG_8822B 16
+#define BIT_MASK_R_MGG_FIFO_INT_FLAG_8822B 0xffff
+#define BIT_R_MGG_FIFO_INT_FLAG_8822B(x)                                       \
+	(((x) & BIT_MASK_R_MGG_FIFO_INT_FLAG_8822B)                            \
+	 << BIT_SHIFT_R_MGG_FIFO_INT_FLAG_8822B)
+#define BIT_GET_R_MGG_FIFO_INT_FLAG_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_INT_FLAG_8822B) &                        \
+	 BIT_MASK_R_MGG_FIFO_INT_FLAG_8822B)
+
+#define BIT_SHIFT_R_MGG_FIFO_INT_MASK_8822B 0
+#define BIT_MASK_R_MGG_FIFO_INT_MASK_8822B 0xffff
+#define BIT_R_MGG_FIFO_INT_MASK_8822B(x)                                       \
+	(((x) & BIT_MASK_R_MGG_FIFO_INT_MASK_8822B)                            \
+	 << BIT_SHIFT_R_MGG_FIFO_INT_MASK_8822B)
+#define BIT_GET_R_MGG_FIFO_INT_MASK_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_INT_MASK_8822B) &                        \
+	 BIT_MASK_R_MGG_FIFO_INT_MASK_8822B)
+
+/* 2 REG_MGG_FIFO_LIFETIME_8822B */
+
+#define BIT_SHIFT_R_MGG_FIFO_LIFETIME_8822B 16
+#define BIT_MASK_R_MGG_FIFO_LIFETIME_8822B 0xffff
+#define BIT_R_MGG_FIFO_LIFETIME_8822B(x)                                       \
+	(((x) & BIT_MASK_R_MGG_FIFO_LIFETIME_8822B)                            \
+	 << BIT_SHIFT_R_MGG_FIFO_LIFETIME_8822B)
+#define BIT_GET_R_MGG_FIFO_LIFETIME_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_LIFETIME_8822B) &                        \
+	 BIT_MASK_R_MGG_FIFO_LIFETIME_8822B)
+
+#define BIT_SHIFT_R_MGG_FIFO_VALID_MAP_8822B 0
+#define BIT_MASK_R_MGG_FIFO_VALID_MAP_8822B 0xffff
+#define BIT_R_MGG_FIFO_VALID_MAP_8822B(x)                                      \
+	(((x) & BIT_MASK_R_MGG_FIFO_VALID_MAP_8822B)                           \
+	 << BIT_SHIFT_R_MGG_FIFO_VALID_MAP_8822B)
+#define BIT_GET_R_MGG_FIFO_VALID_MAP_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_R_MGG_FIFO_VALID_MAP_8822B) &                       \
+	 BIT_MASK_R_MGG_FIFO_VALID_MAP_8822B)
+
+/* 2 REG_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET_8822B */
+
+#define BIT_SHIFT_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET_8822B 0
+#define BIT_MASK_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET_8822B 0x7f
+#define BIT_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET_8822B(x)                      \
+	(((x) & BIT_MASK_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET_8822B)           \
+	 << BIT_SHIFT_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET_8822B)
+#define BIT_GET_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET_8822B(x)                  \
+	(((x) >> BIT_SHIFT_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET_8822B) &       \
+	 BIT_MASK_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET_8822B)
+
+/* 2 REG_MACID_SHCUT_OFFSET_8822B */
+
+#define BIT_SHIFT_MACID_SHCUT_OFFSET_V1_8822B 0
+#define BIT_MASK_MACID_SHCUT_OFFSET_V1_8822B 0xff
+#define BIT_MACID_SHCUT_OFFSET_V1_8822B(x)                                     \
+	(((x) & BIT_MASK_MACID_SHCUT_OFFSET_V1_8822B)                          \
+	 << BIT_SHIFT_MACID_SHCUT_OFFSET_V1_8822B)
+#define BIT_GET_MACID_SHCUT_OFFSET_V1_8822B(x)                                 \
+	(((x) >> BIT_SHIFT_MACID_SHCUT_OFFSET_V1_8822B) &                      \
+	 BIT_MASK_MACID_SHCUT_OFFSET_V1_8822B)
+
+/* 2 REG_MU_TX_CTL_8822B */
+#define BIT_R_EN_REVERS_GTAB_8822B BIT(6)
+
+#define BIT_SHIFT_R_MU_TABLE_VALID_8822B 0
+#define BIT_MASK_R_MU_TABLE_VALID_8822B 0x3f
+#define BIT_R_MU_TABLE_VALID_8822B(x)                                          \
+	(((x) & BIT_MASK_R_MU_TABLE_VALID_8822B)                               \
+	 << BIT_SHIFT_R_MU_TABLE_VALID_8822B)
+#define BIT_GET_R_MU_TABLE_VALID_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_R_MU_TABLE_VALID_8822B) &                           \
+	 BIT_MASK_R_MU_TABLE_VALID_8822B)
+
+/* 2 REG_MU_STA_GID_VLD_8822B */
+
+/* 2 REG_NOT_VALID_8822B */
+
+#define BIT_SHIFT_R_MU_STA_GTAB_VALID_8822B 0
+#define BIT_MASK_R_MU_STA_GTAB_VALID_8822B 0xffffffffL
+#define BIT_R_MU_STA_GTAB_VALID_8822B(x)                                       \
+	(((x) & BIT_MASK_R_MU_STA_GTAB_VALID_8822B)                            \
+	 << BIT_SHIFT_R_MU_STA_GTAB_VALID_8822B)
+#define BIT_GET_R_MU_STA_GTAB_VALID_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_R_MU_STA_GTAB_VALID_8822B) &                        \
+	 BIT_MASK_R_MU_STA_GTAB_VALID_8822B)
+
+#define BIT_SHIFT_R_MU_STA_GTAB_VALID_8822B 0
+#define BIT_MASK_R_MU_STA_GTAB_VALID_8822B 0xffffffffL
+#define BIT_R_MU_STA_GTAB_VALID_8822B(x)                                       \
+	(((x) & BIT_MASK_R_MU_STA_GTAB_VALID_8822B)                            \
+	 << BIT_SHIFT_R_MU_STA_GTAB_VALID_8822B)
+#define BIT_GET_R_MU_STA_GTAB_VALID_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_R_MU_STA_GTAB_VALID_8822B) &                        \
+	 BIT_MASK_R_MU_STA_GTAB_VALID_8822B)
+
+/* 2 REG_MU_STA_USER_POS_INFO_8822B */
+
+/* 2 REG_NOT_VALID_8822B */
+
+#define BIT_SHIFT_R_MU_STA_GTAB_POSITION_8822B 0
+#define BIT_MASK_R_MU_STA_GTAB_POSITION_8822B 0xffffffffffffffffL
+#define BIT_R_MU_STA_GTAB_POSITION_8822B(x)                                    \
+	(((x) & BIT_MASK_R_MU_STA_GTAB_POSITION_8822B)                         \
+	 << BIT_SHIFT_R_MU_STA_GTAB_POSITION_8822B)
+#define BIT_GET_R_MU_STA_GTAB_POSITION_8822B(x)                                \
+	(((x) >> BIT_SHIFT_R_MU_STA_GTAB_POSITION_8822B) &                     \
+	 BIT_MASK_R_MU_STA_GTAB_POSITION_8822B)
+
+#define BIT_SHIFT_R_MU_STA_GTAB_POSITION_8822B 0
+#define BIT_MASK_R_MU_STA_GTAB_POSITION_8822B 0xffffffffffffffffL
+#define BIT_R_MU_STA_GTAB_POSITION_8822B(x)                                    \
+	(((x) & BIT_MASK_R_MU_STA_GTAB_POSITION_8822B)                         \
+	 << BIT_SHIFT_R_MU_STA_GTAB_POSITION_8822B)
+#define BIT_GET_R_MU_STA_GTAB_POSITION_8822B(x)                                \
+	(((x) >> BIT_SHIFT_R_MU_STA_GTAB_POSITION_8822B) &                     \
+	 BIT_MASK_R_MU_STA_GTAB_POSITION_8822B)
+
+/* 2 REG_MU_TRX_DBG_CNT_8822B */
+#define BIT_MU_DNGCNT_RST_8822B BIT(20)
+
+#define BIT_SHIFT_MU_DBGCNT_SEL_8822B 16
+#define BIT_MASK_MU_DBGCNT_SEL_8822B 0xf
+#define BIT_MU_DBGCNT_SEL_8822B(x)                                             \
+	(((x) & BIT_MASK_MU_DBGCNT_SEL_8822B) << BIT_SHIFT_MU_DBGCNT_SEL_8822B)
+#define BIT_GET_MU_DBGCNT_SEL_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_MU_DBGCNT_SEL_8822B) & BIT_MASK_MU_DBGCNT_SEL_8822B)
+
+#define BIT_SHIFT_MU_DNGCNT_8822B 0
+#define BIT_MASK_MU_DNGCNT_8822B 0xffff
+#define BIT_MU_DNGCNT_8822B(x)                                                 \
+	(((x) & BIT_MASK_MU_DNGCNT_8822B) << BIT_SHIFT_MU_DNGCNT_8822B)
+#define BIT_GET_MU_DNGCNT_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_MU_DNGCNT_8822B) & BIT_MASK_MU_DNGCNT_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_EDCA_VO_PARAM_8822B */
+
+#define BIT_SHIFT_TXOPLIMIT_8822B 16
+#define BIT_MASK_TXOPLIMIT_8822B 0x7ff
+#define BIT_TXOPLIMIT_8822B(x)                                                 \
+	(((x) & BIT_MASK_TXOPLIMIT_8822B) << BIT_SHIFT_TXOPLIMIT_8822B)
+#define BIT_GET_TXOPLIMIT_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_TXOPLIMIT_8822B) & BIT_MASK_TXOPLIMIT_8822B)
+
+#define BIT_SHIFT_CW_8822B 8
+#define BIT_MASK_CW_8822B 0xff
+#define BIT_CW_8822B(x) (((x) & BIT_MASK_CW_8822B) << BIT_SHIFT_CW_8822B)
+#define BIT_GET_CW_8822B(x) (((x) >> BIT_SHIFT_CW_8822B) & BIT_MASK_CW_8822B)
+
+#define BIT_SHIFT_AIFS_8822B 0
+#define BIT_MASK_AIFS_8822B 0xff
+#define BIT_AIFS_8822B(x) (((x) & BIT_MASK_AIFS_8822B) << BIT_SHIFT_AIFS_8822B)
+#define BIT_GET_AIFS_8822B(x)                                                  \
+	(((x) >> BIT_SHIFT_AIFS_8822B) & BIT_MASK_AIFS_8822B)
+
+/* 2 REG_EDCA_VI_PARAM_8822B */
+
+/* 2 REG_NOT_VALID_8822B */
+
+#define BIT_SHIFT_TXOPLIMIT_8822B 16
+#define BIT_MASK_TXOPLIMIT_8822B 0x7ff
+#define BIT_TXOPLIMIT_8822B(x)                                                 \
+	(((x) & BIT_MASK_TXOPLIMIT_8822B) << BIT_SHIFT_TXOPLIMIT_8822B)
+#define BIT_GET_TXOPLIMIT_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_TXOPLIMIT_8822B) & BIT_MASK_TXOPLIMIT_8822B)
+
+#define BIT_SHIFT_CW_8822B 8
+#define BIT_MASK_CW_8822B 0xff
+#define BIT_CW_8822B(x) (((x) & BIT_MASK_CW_8822B) << BIT_SHIFT_CW_8822B)
+#define BIT_GET_CW_8822B(x) (((x) >> BIT_SHIFT_CW_8822B) & BIT_MASK_CW_8822B)
+
+#define BIT_SHIFT_AIFS_8822B 0
+#define BIT_MASK_AIFS_8822B 0xff
+#define BIT_AIFS_8822B(x) (((x) & BIT_MASK_AIFS_8822B) << BIT_SHIFT_AIFS_8822B)
+#define BIT_GET_AIFS_8822B(x)                                                  \
+	(((x) >> BIT_SHIFT_AIFS_8822B) & BIT_MASK_AIFS_8822B)
+
+/* 2 REG_EDCA_BE_PARAM_8822B */
+
+/* 2 REG_NOT_VALID_8822B */
+
+#define BIT_SHIFT_TXOPLIMIT_8822B 16
+#define BIT_MASK_TXOPLIMIT_8822B 0x7ff
+#define BIT_TXOPLIMIT_8822B(x)                                                 \
+	(((x) & BIT_MASK_TXOPLIMIT_8822B) << BIT_SHIFT_TXOPLIMIT_8822B)
+#define BIT_GET_TXOPLIMIT_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_TXOPLIMIT_8822B) & BIT_MASK_TXOPLIMIT_8822B)
+
+#define BIT_SHIFT_CW_8822B 8
+#define BIT_MASK_CW_8822B 0xff
+#define BIT_CW_8822B(x) (((x) & BIT_MASK_CW_8822B) << BIT_SHIFT_CW_8822B)
+#define BIT_GET_CW_8822B(x) (((x) >> BIT_SHIFT_CW_8822B) & BIT_MASK_CW_8822B)
+
+#define BIT_SHIFT_AIFS_8822B 0
+#define BIT_MASK_AIFS_8822B 0xff
+#define BIT_AIFS_8822B(x) (((x) & BIT_MASK_AIFS_8822B) << BIT_SHIFT_AIFS_8822B)
+#define BIT_GET_AIFS_8822B(x)                                                  \
+	(((x) >> BIT_SHIFT_AIFS_8822B) & BIT_MASK_AIFS_8822B)
+
+/* 2 REG_EDCA_BK_PARAM_8822B */
+
+/* 2 REG_NOT_VALID_8822B */
+
+#define BIT_SHIFT_TXOPLIMIT_8822B 16
+#define BIT_MASK_TXOPLIMIT_8822B 0x7ff
+#define BIT_TXOPLIMIT_8822B(x)                                                 \
+	(((x) & BIT_MASK_TXOPLIMIT_8822B) << BIT_SHIFT_TXOPLIMIT_8822B)
+#define BIT_GET_TXOPLIMIT_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_TXOPLIMIT_8822B) & BIT_MASK_TXOPLIMIT_8822B)
+
+#define BIT_SHIFT_CW_8822B 8
+#define BIT_MASK_CW_8822B 0xff
+#define BIT_CW_8822B(x) (((x) & BIT_MASK_CW_8822B) << BIT_SHIFT_CW_8822B)
+#define BIT_GET_CW_8822B(x) (((x) >> BIT_SHIFT_CW_8822B) & BIT_MASK_CW_8822B)
+
+#define BIT_SHIFT_AIFS_8822B 0
+#define BIT_MASK_AIFS_8822B 0xff
+#define BIT_AIFS_8822B(x) (((x) & BIT_MASK_AIFS_8822B) << BIT_SHIFT_AIFS_8822B)
+#define BIT_GET_AIFS_8822B(x)                                                  \
+	(((x) >> BIT_SHIFT_AIFS_8822B) & BIT_MASK_AIFS_8822B)
+
+/* 2 REG_BCNTCFG_8822B */
+
+#define BIT_SHIFT_BCNCW_MAX_8822B 12
+#define BIT_MASK_BCNCW_MAX_8822B 0xf
+#define BIT_BCNCW_MAX_8822B(x)                                                 \
+	(((x) & BIT_MASK_BCNCW_MAX_8822B) << BIT_SHIFT_BCNCW_MAX_8822B)
+#define BIT_GET_BCNCW_MAX_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_BCNCW_MAX_8822B) & BIT_MASK_BCNCW_MAX_8822B)
+
+#define BIT_SHIFT_BCNCW_MIN_8822B 8
+#define BIT_MASK_BCNCW_MIN_8822B 0xf
+#define BIT_BCNCW_MIN_8822B(x)                                                 \
+	(((x) & BIT_MASK_BCNCW_MIN_8822B) << BIT_SHIFT_BCNCW_MIN_8822B)
+#define BIT_GET_BCNCW_MIN_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_BCNCW_MIN_8822B) & BIT_MASK_BCNCW_MIN_8822B)
+
+#define BIT_SHIFT_BCNIFS_8822B 0
+#define BIT_MASK_BCNIFS_8822B 0xff
+#define BIT_BCNIFS_8822B(x)                                                    \
+	(((x) & BIT_MASK_BCNIFS_8822B) << BIT_SHIFT_BCNIFS_8822B)
+#define BIT_GET_BCNIFS_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_BCNIFS_8822B) & BIT_MASK_BCNIFS_8822B)
+
+/* 2 REG_PIFS_8822B */
+
+#define BIT_SHIFT_PIFS_8822B 0
+#define BIT_MASK_PIFS_8822B 0xff
+#define BIT_PIFS_8822B(x) (((x) & BIT_MASK_PIFS_8822B) << BIT_SHIFT_PIFS_8822B)
+#define BIT_GET_PIFS_8822B(x)                                                  \
+	(((x) >> BIT_SHIFT_PIFS_8822B) & BIT_MASK_PIFS_8822B)
+
+/* 2 REG_RDG_PIFS_8822B */
+
+#define BIT_SHIFT_RDG_PIFS_8822B 0
+#define BIT_MASK_RDG_PIFS_8822B 0xff
+#define BIT_RDG_PIFS_8822B(x)                                                  \
+	(((x) & BIT_MASK_RDG_PIFS_8822B) << BIT_SHIFT_RDG_PIFS_8822B)
+#define BIT_GET_RDG_PIFS_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_RDG_PIFS_8822B) & BIT_MASK_RDG_PIFS_8822B)
+
+/* 2 REG_SIFS_8822B */
+
+#define BIT_SHIFT_SIFS_OFDM_TRX_8822B 24
+#define BIT_MASK_SIFS_OFDM_TRX_8822B 0xff
+#define BIT_SIFS_OFDM_TRX_8822B(x)                                             \
+	(((x) & BIT_MASK_SIFS_OFDM_TRX_8822B) << BIT_SHIFT_SIFS_OFDM_TRX_8822B)
+#define BIT_GET_SIFS_OFDM_TRX_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_SIFS_OFDM_TRX_8822B) & BIT_MASK_SIFS_OFDM_TRX_8822B)
+
+#define BIT_SHIFT_SIFS_CCK_TRX_8822B 16
+#define BIT_MASK_SIFS_CCK_TRX_8822B 0xff
+#define BIT_SIFS_CCK_TRX_8822B(x)                                              \
+	(((x) & BIT_MASK_SIFS_CCK_TRX_8822B) << BIT_SHIFT_SIFS_CCK_TRX_8822B)
+#define BIT_GET_SIFS_CCK_TRX_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_SIFS_CCK_TRX_8822B) & BIT_MASK_SIFS_CCK_TRX_8822B)
+
+#define BIT_SHIFT_SIFS_OFDM_CTX_8822B 8
+#define BIT_MASK_SIFS_OFDM_CTX_8822B 0xff
+#define BIT_SIFS_OFDM_CTX_8822B(x)                                             \
+	(((x) & BIT_MASK_SIFS_OFDM_CTX_8822B) << BIT_SHIFT_SIFS_OFDM_CTX_8822B)
+#define BIT_GET_SIFS_OFDM_CTX_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_SIFS_OFDM_CTX_8822B) & BIT_MASK_SIFS_OFDM_CTX_8822B)
+
+#define BIT_SHIFT_SIFS_CCK_CTX_8822B 0
+#define BIT_MASK_SIFS_CCK_CTX_8822B 0xff
+#define BIT_SIFS_CCK_CTX_8822B(x)                                              \
+	(((x) & BIT_MASK_SIFS_CCK_CTX_8822B) << BIT_SHIFT_SIFS_CCK_CTX_8822B)
+#define BIT_GET_SIFS_CCK_CTX_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_SIFS_CCK_CTX_8822B) & BIT_MASK_SIFS_CCK_CTX_8822B)
+
+/* 2 REG_TSFTR_SYN_OFFSET_8822B */
+
+#define BIT_SHIFT_TSFTR_SNC_OFFSET_8822B 0
+#define BIT_MASK_TSFTR_SNC_OFFSET_8822B 0xffff
+#define BIT_TSFTR_SNC_OFFSET_8822B(x)                                          \
+	(((x) & BIT_MASK_TSFTR_SNC_OFFSET_8822B)                               \
+	 << BIT_SHIFT_TSFTR_SNC_OFFSET_8822B)
+#define BIT_GET_TSFTR_SNC_OFFSET_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_TSFTR_SNC_OFFSET_8822B) &                           \
+	 BIT_MASK_TSFTR_SNC_OFFSET_8822B)
+
+/* 2 REG_AGGR_BREAK_TIME_8822B */
+
+#define BIT_SHIFT_AGGR_BK_TIME_8822B 0
+#define BIT_MASK_AGGR_BK_TIME_8822B 0xff
+#define BIT_AGGR_BK_TIME_8822B(x)                                              \
+	(((x) & BIT_MASK_AGGR_BK_TIME_8822B) << BIT_SHIFT_AGGR_BK_TIME_8822B)
+#define BIT_GET_AGGR_BK_TIME_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_AGGR_BK_TIME_8822B) & BIT_MASK_AGGR_BK_TIME_8822B)
+
+/* 2 REG_SLOT_8822B */
+
+#define BIT_SHIFT_SLOT_8822B 0
+#define BIT_MASK_SLOT_8822B 0xff
+#define BIT_SLOT_8822B(x) (((x) & BIT_MASK_SLOT_8822B) << BIT_SHIFT_SLOT_8822B)
+#define BIT_GET_SLOT_8822B(x)                                                  \
+	(((x) >> BIT_SHIFT_SLOT_8822B) & BIT_MASK_SLOT_8822B)
+
+/* 2 REG_TX_PTCL_CTRL_8822B */
+#define BIT_DIS_EDCCA_8822B BIT(15)
+#define BIT_DIS_CCA_8822B BIT(14)
+#define BIT_LSIG_TXOP_TXCMD_NAV_8822B BIT(13)
+#define BIT_SIFS_BK_EN_8822B BIT(12)
+
+#define BIT_SHIFT_TXQ_NAV_MSK_8822B 8
+#define BIT_MASK_TXQ_NAV_MSK_8822B 0xf
+#define BIT_TXQ_NAV_MSK_8822B(x)                                               \
+	(((x) & BIT_MASK_TXQ_NAV_MSK_8822B) << BIT_SHIFT_TXQ_NAV_MSK_8822B)
+#define BIT_GET_TXQ_NAV_MSK_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_TXQ_NAV_MSK_8822B) & BIT_MASK_TXQ_NAV_MSK_8822B)
+
+#define BIT_DIS_CW_8822B BIT(7)
+#define BIT_NAV_END_TXOP_8822B BIT(6)
+#define BIT_RDG_END_TXOP_8822B BIT(5)
+#define BIT_AC_INBCN_HOLD_8822B BIT(4)
+#define BIT_MGTQ_TXOP_EN_8822B BIT(3)
+#define BIT_MGTQ_RTSMF_EN_8822B BIT(2)
+#define BIT_HIQ_RTSMF_EN_8822B BIT(1)
+#define BIT_BCN_RTSMF_EN_8822B BIT(0)
+
+/* 2 REG_TXPAUSE_8822B */
+#define BIT_STOP_BCN_HI_MGT_8822B BIT(7)
+#define BIT_MAC_STOPBCNQ_8822B BIT(6)
+#define BIT_MAC_STOPHIQ_8822B BIT(5)
+#define BIT_MAC_STOPMGQ_8822B BIT(4)
+#define BIT_MAC_STOPBK_8822B BIT(3)
+#define BIT_MAC_STOPBE_8822B BIT(2)
+#define BIT_MAC_STOPVI_8822B BIT(1)
+#define BIT_MAC_STOPVO_8822B BIT(0)
+
+/* 2 REG_DIS_TXREQ_CLR_8822B */
+#define BIT_DIS_BT_CCA_8822B BIT(7)
+#define BIT_DIS_TXREQ_CLR_HI_8822B BIT(5)
+#define BIT_DIS_TXREQ_CLR_MGQ_8822B BIT(4)
+#define BIT_DIS_TXREQ_CLR_VO_8822B BIT(3)
+#define BIT_DIS_TXREQ_CLR_VI_8822B BIT(2)
+#define BIT_DIS_TXREQ_CLR_BE_8822B BIT(1)
+#define BIT_DIS_TXREQ_CLR_BK_8822B BIT(0)
+
+/* 2 REG_RD_CTRL_8822B */
+#define BIT_EN_CLR_TXREQ_INCCA_8822B BIT(15)
+#define BIT_DIS_TX_OVER_BCNQ_8822B BIT(14)
+#define BIT_EN_BCNERR_INCCCA_8822B BIT(13)
+#define BIT_EDCCA_MSK_CNTDOWN_EN_8822B BIT(11)
+#define BIT_DIS_TXOP_CFE_8822B BIT(10)
+#define BIT_DIS_LSIG_CFE_8822B BIT(9)
+#define BIT_DIS_STBC_CFE_8822B BIT(8)
+#define BIT_BKQ_RD_INIT_EN_8822B BIT(7)
+#define BIT_BEQ_RD_INIT_EN_8822B BIT(6)
+#define BIT_VIQ_RD_INIT_EN_8822B BIT(5)
+#define BIT_VOQ_RD_INIT_EN_8822B BIT(4)
+#define BIT_BKQ_RD_RESP_EN_8822B BIT(3)
+#define BIT_BEQ_RD_RESP_EN_8822B BIT(2)
+#define BIT_VIQ_RD_RESP_EN_8822B BIT(1)
+#define BIT_VOQ_RD_RESP_EN_8822B BIT(0)
+
+/* 2 REG_MBSSID_CTRL_8822B */
+#define BIT_MBID_BCNQ7_EN_8822B BIT(7)
+#define BIT_MBID_BCNQ6_EN_8822B BIT(6)
+#define BIT_MBID_BCNQ5_EN_8822B BIT(5)
+#define BIT_MBID_BCNQ4_EN_8822B BIT(4)
+#define BIT_MBID_BCNQ3_EN_8822B BIT(3)
+#define BIT_MBID_BCNQ2_EN_8822B BIT(2)
+#define BIT_MBID_BCNQ1_EN_8822B BIT(1)
+#define BIT_MBID_BCNQ0_EN_8822B BIT(0)
+
+/* 2 REG_P2PPS_CTRL_8822B */
+#define BIT_P2P_CTW_ALLSTASLEEP_8822B BIT(7)
+#define BIT_P2P_OFF_DISTX_EN_8822B BIT(6)
+#define BIT_PWR_MGT_EN_8822B BIT(5)
+#define BIT_P2P_NOA1_EN_8822B BIT(2)
+#define BIT_P2P_NOA0_EN_8822B BIT(1)
+
+/* 2 REG_PKT_LIFETIME_CTRL_8822B */
+#define BIT_EN_P2P_CTWND1_8822B BIT(23)
+#define BIT_EN_BKF_CLR_TXREQ_8822B BIT(22)
+#define BIT_EN_TSFBIT32_RST_P2P_8822B BIT(21)
+#define BIT_EN_BCN_TX_BTCCA_8822B BIT(20)
+#define BIT_DIS_PKT_TX_ATIM_8822B BIT(19)
+#define BIT_DIS_BCN_DIS_CTN_8822B BIT(18)
+#define BIT_EN_NAVEND_RST_TXOP_8822B BIT(17)
+#define BIT_EN_FILTER_CCA_8822B BIT(16)
+
+#define BIT_SHIFT_CCA_FILTER_THRS_8822B 8
+#define BIT_MASK_CCA_FILTER_THRS_8822B 0xff
+#define BIT_CCA_FILTER_THRS_8822B(x)                                           \
+	(((x) & BIT_MASK_CCA_FILTER_THRS_8822B)                                \
+	 << BIT_SHIFT_CCA_FILTER_THRS_8822B)
+#define BIT_GET_CCA_FILTER_THRS_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_CCA_FILTER_THRS_8822B) &                            \
+	 BIT_MASK_CCA_FILTER_THRS_8822B)
+
+#define BIT_SHIFT_EDCCA_THRS_8822B 0
+#define BIT_MASK_EDCCA_THRS_8822B 0xff
+#define BIT_EDCCA_THRS_8822B(x)                                                \
+	(((x) & BIT_MASK_EDCCA_THRS_8822B) << BIT_SHIFT_EDCCA_THRS_8822B)
+#define BIT_GET_EDCCA_THRS_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_EDCCA_THRS_8822B) & BIT_MASK_EDCCA_THRS_8822B)
+
+/* 2 REG_P2PPS_SPEC_STATE_8822B */
+#define BIT_SPEC_POWER_STATE_8822B BIT(7)
+#define BIT_SPEC_CTWINDOW_ON_8822B BIT(6)
+#define BIT_SPEC_BEACON_AREA_ON_8822B BIT(5)
+#define BIT_SPEC_CTWIN_EARLY_DISTX_8822B BIT(4)
+#define BIT_SPEC_NOA1_OFF_PERIOD_8822B BIT(3)
+#define BIT_SPEC_FORCE_DOZE1_8822B BIT(2)
+#define BIT_SPEC_NOA0_OFF_PERIOD_8822B BIT(1)
+#define BIT_SPEC_FORCE_DOZE0_8822B BIT(0)
+
+/* 2 REG_BAR_TX_CTRL_8822B */
+
+/* 2 REG_NOT_VALID_8822B */
+
+#define BIT_SHIFT_P2PON_DIS_TXTIME_8822B 0
+#define BIT_MASK_P2PON_DIS_TXTIME_8822B 0xff
+#define BIT_P2PON_DIS_TXTIME_8822B(x)                                          \
+	(((x) & BIT_MASK_P2PON_DIS_TXTIME_8822B)                               \
+	 << BIT_SHIFT_P2PON_DIS_TXTIME_8822B)
+#define BIT_GET_P2PON_DIS_TXTIME_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_P2PON_DIS_TXTIME_8822B) &                           \
+	 BIT_MASK_P2PON_DIS_TXTIME_8822B)
+
+/* 2 REG_QUEUE_INCOL_THR_8822B */
+
+#define BIT_SHIFT_BK_QUEUE_THR_8822B 24
+#define BIT_MASK_BK_QUEUE_THR_8822B 0xff
+#define BIT_BK_QUEUE_THR_8822B(x)                                              \
+	(((x) & BIT_MASK_BK_QUEUE_THR_8822B) << BIT_SHIFT_BK_QUEUE_THR_8822B)
+#define BIT_GET_BK_QUEUE_THR_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_BK_QUEUE_THR_8822B) & BIT_MASK_BK_QUEUE_THR_8822B)
+
+#define BIT_SHIFT_BE_QUEUE_THR_8822B 16
+#define BIT_MASK_BE_QUEUE_THR_8822B 0xff
+#define BIT_BE_QUEUE_THR_8822B(x)                                              \
+	(((x) & BIT_MASK_BE_QUEUE_THR_8822B) << BIT_SHIFT_BE_QUEUE_THR_8822B)
+#define BIT_GET_BE_QUEUE_THR_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_BE_QUEUE_THR_8822B) & BIT_MASK_BE_QUEUE_THR_8822B)
+
+#define BIT_SHIFT_VI_QUEUE_THR_8822B 8
+#define BIT_MASK_VI_QUEUE_THR_8822B 0xff
+#define BIT_VI_QUEUE_THR_8822B(x)                                              \
+	(((x) & BIT_MASK_VI_QUEUE_THR_8822B) << BIT_SHIFT_VI_QUEUE_THR_8822B)
+#define BIT_GET_VI_QUEUE_THR_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_VI_QUEUE_THR_8822B) & BIT_MASK_VI_QUEUE_THR_8822B)
+
+#define BIT_SHIFT_VO_QUEUE_THR_8822B 0
+#define BIT_MASK_VO_QUEUE_THR_8822B 0xff
+#define BIT_VO_QUEUE_THR_8822B(x)                                              \
+	(((x) & BIT_MASK_VO_QUEUE_THR_8822B) << BIT_SHIFT_VO_QUEUE_THR_8822B)
+#define BIT_GET_VO_QUEUE_THR_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_VO_QUEUE_THR_8822B) & BIT_MASK_VO_QUEUE_THR_8822B)
+
+/* 2 REG_QUEUE_INCOL_EN_8822B */
+#define BIT_QUEUE_INCOL_EN_8822B BIT(16)
+
+#define BIT_SHIFT_BE_TRIGGER_NUM_8822B 12
+#define BIT_MASK_BE_TRIGGER_NUM_8822B 0xf
+#define BIT_BE_TRIGGER_NUM_8822B(x)                                            \
+	(((x) & BIT_MASK_BE_TRIGGER_NUM_8822B)                                 \
+	 << BIT_SHIFT_BE_TRIGGER_NUM_8822B)
+#define BIT_GET_BE_TRIGGER_NUM_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_BE_TRIGGER_NUM_8822B) &                             \
+	 BIT_MASK_BE_TRIGGER_NUM_8822B)
+
+#define BIT_SHIFT_BK_TRIGGER_NUM_8822B 8
+#define BIT_MASK_BK_TRIGGER_NUM_8822B 0xf
+#define BIT_BK_TRIGGER_NUM_8822B(x)                                            \
+	(((x) & BIT_MASK_BK_TRIGGER_NUM_8822B)                                 \
+	 << BIT_SHIFT_BK_TRIGGER_NUM_8822B)
+#define BIT_GET_BK_TRIGGER_NUM_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_BK_TRIGGER_NUM_8822B) &                             \
+	 BIT_MASK_BK_TRIGGER_NUM_8822B)
+
+#define BIT_SHIFT_VI_TRIGGER_NUM_8822B 4
+#define BIT_MASK_VI_TRIGGER_NUM_8822B 0xf
+#define BIT_VI_TRIGGER_NUM_8822B(x)                                            \
+	(((x) & BIT_MASK_VI_TRIGGER_NUM_8822B)                                 \
+	 << BIT_SHIFT_VI_TRIGGER_NUM_8822B)
+#define BIT_GET_VI_TRIGGER_NUM_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_VI_TRIGGER_NUM_8822B) &                             \
+	 BIT_MASK_VI_TRIGGER_NUM_8822B)
+
+#define BIT_SHIFT_VO_TRIGGER_NUM_8822B 0
+#define BIT_MASK_VO_TRIGGER_NUM_8822B 0xf
+#define BIT_VO_TRIGGER_NUM_8822B(x)                                            \
+	(((x) & BIT_MASK_VO_TRIGGER_NUM_8822B)                                 \
+	 << BIT_SHIFT_VO_TRIGGER_NUM_8822B)
+#define BIT_GET_VO_TRIGGER_NUM_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_VO_TRIGGER_NUM_8822B) &                             \
+	 BIT_MASK_VO_TRIGGER_NUM_8822B)
+
+/* 2 REG_TBTT_PROHIBIT_8822B */
+
+#define BIT_SHIFT_TBTT_HOLD_TIME_AP_8822B 8
+#define BIT_MASK_TBTT_HOLD_TIME_AP_8822B 0xfff
+#define BIT_TBTT_HOLD_TIME_AP_8822B(x)                                         \
+	(((x) & BIT_MASK_TBTT_HOLD_TIME_AP_8822B)                              \
+	 << BIT_SHIFT_TBTT_HOLD_TIME_AP_8822B)
+#define BIT_GET_TBTT_HOLD_TIME_AP_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_TBTT_HOLD_TIME_AP_8822B) &                          \
+	 BIT_MASK_TBTT_HOLD_TIME_AP_8822B)
+
+#define BIT_SHIFT_TBTT_PROHIBIT_SETUP_8822B 0
+#define BIT_MASK_TBTT_PROHIBIT_SETUP_8822B 0xf
+#define BIT_TBTT_PROHIBIT_SETUP_8822B(x)                                       \
+	(((x) & BIT_MASK_TBTT_PROHIBIT_SETUP_8822B)                            \
+	 << BIT_SHIFT_TBTT_PROHIBIT_SETUP_8822B)
+#define BIT_GET_TBTT_PROHIBIT_SETUP_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_TBTT_PROHIBIT_SETUP_8822B) &                        \
+	 BIT_MASK_TBTT_PROHIBIT_SETUP_8822B)
+
+/* 2 REG_P2PPS_STATE_8822B */
+#define BIT_POWER_STATE_8822B BIT(7)
+#define BIT_CTWINDOW_ON_8822B BIT(6)
+#define BIT_BEACON_AREA_ON_8822B BIT(5)
+#define BIT_CTWIN_EARLY_DISTX_8822B BIT(4)
+#define BIT_NOA1_OFF_PERIOD_8822B BIT(3)
+#define BIT_FORCE_DOZE1_8822B BIT(2)
+#define BIT_NOA0_OFF_PERIOD_8822B BIT(1)
+#define BIT_FORCE_DOZE0_8822B BIT(0)
+
+/* 2 REG_RD_NAV_NXT_8822B */
+
+#define BIT_SHIFT_RD_NAV_PROT_NXT_8822B 0
+#define BIT_MASK_RD_NAV_PROT_NXT_8822B 0xffff
+#define BIT_RD_NAV_PROT_NXT_8822B(x)                                           \
+	(((x) & BIT_MASK_RD_NAV_PROT_NXT_8822B)                                \
+	 << BIT_SHIFT_RD_NAV_PROT_NXT_8822B)
+#define BIT_GET_RD_NAV_PROT_NXT_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_RD_NAV_PROT_NXT_8822B) &                            \
+	 BIT_MASK_RD_NAV_PROT_NXT_8822B)
+
+/* 2 REG_NAV_PROT_LEN_8822B */
+
+#define BIT_SHIFT_NAV_PROT_LEN_8822B 0
+#define BIT_MASK_NAV_PROT_LEN_8822B 0xffff
+#define BIT_NAV_PROT_LEN_8822B(x)                                              \
+	(((x) & BIT_MASK_NAV_PROT_LEN_8822B) << BIT_SHIFT_NAV_PROT_LEN_8822B)
+#define BIT_GET_NAV_PROT_LEN_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_NAV_PROT_LEN_8822B) & BIT_MASK_NAV_PROT_LEN_8822B)
+
+/* 2 REG_BCN_CTRL_8822B */
+#define BIT_DIS_RX_BSSID_FIT_8822B BIT(6)
+#define BIT_P0_EN_TXBCN_RPT_8822B BIT(5)
+#define BIT_DIS_TSF_UDT_8822B BIT(4)
+#define BIT_EN_BCN_FUNCTION_8822B BIT(3)
+#define BIT_P0_EN_RXBCN_RPT_8822B BIT(2)
+#define BIT_EN_P2P_CTWINDOW_8822B BIT(1)
+#define BIT_EN_P2P_BCNQ_AREA_8822B BIT(0)
+
+/* 2 REG_BCN_CTRL_CLINT0_8822B */
+#define BIT_CLI0_DIS_RX_BSSID_FIT_8822B BIT(6)
+#define BIT_CLI0_DIS_TSF_UDT_8822B BIT(4)
+#define BIT_CLI0_EN_BCN_FUNCTION_8822B BIT(3)
+#define BIT_CLI0_EN_RXBCN_RPT_8822B BIT(2)
+#define BIT_CLI0_ENP2P_CTWINDOW_8822B BIT(1)
+#define BIT_CLI0_ENP2P_BCNQ_AREA_8822B BIT(0)
+
+/* 2 REG_MBID_NUM_8822B */
+#define BIT_EN_PRE_DL_BEACON_8822B BIT(3)
+
+#define BIT_SHIFT_MBID_BCN_NUM_8822B 0
+#define BIT_MASK_MBID_BCN_NUM_8822B 0x7
+#define BIT_MBID_BCN_NUM_8822B(x)                                              \
+	(((x) & BIT_MASK_MBID_BCN_NUM_8822B) << BIT_SHIFT_MBID_BCN_NUM_8822B)
+#define BIT_GET_MBID_BCN_NUM_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_MBID_BCN_NUM_8822B) & BIT_MASK_MBID_BCN_NUM_8822B)
+
+/* 2 REG_DUAL_TSF_RST_8822B */
+#define BIT_FREECNT_RST_8822B BIT(5)
+#define BIT_TSFTR_CLI3_RST_8822B BIT(4)
+#define BIT_TSFTR_CLI2_RST_8822B BIT(3)
+#define BIT_TSFTR_CLI1_RST_8822B BIT(2)
+#define BIT_TSFTR_CLI0_RST_8822B BIT(1)
+#define BIT_TSFTR_RST_8822B BIT(0)
+
+/* 2 REG_MBSSID_BCN_SPACE_8822B */
+
+#define BIT_SHIFT_BCN_TIMER_SEL_FWRD_8822B 28
+#define BIT_MASK_BCN_TIMER_SEL_FWRD_8822B 0x7
+#define BIT_BCN_TIMER_SEL_FWRD_8822B(x)                                        \
+	(((x) & BIT_MASK_BCN_TIMER_SEL_FWRD_8822B)                             \
+	 << BIT_SHIFT_BCN_TIMER_SEL_FWRD_8822B)
+#define BIT_GET_BCN_TIMER_SEL_FWRD_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_BCN_TIMER_SEL_FWRD_8822B) &                         \
+	 BIT_MASK_BCN_TIMER_SEL_FWRD_8822B)
+
+#define BIT_SHIFT_BCN_SPACE_CLINT0_8822B 16
+#define BIT_MASK_BCN_SPACE_CLINT0_8822B 0xfff
+#define BIT_BCN_SPACE_CLINT0_8822B(x)                                          \
+	(((x) & BIT_MASK_BCN_SPACE_CLINT0_8822B)                               \
+	 << BIT_SHIFT_BCN_SPACE_CLINT0_8822B)
+#define BIT_GET_BCN_SPACE_CLINT0_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_BCN_SPACE_CLINT0_8822B) &                           \
+	 BIT_MASK_BCN_SPACE_CLINT0_8822B)
+
+#define BIT_SHIFT_BCN_SPACE0_8822B 0
+#define BIT_MASK_BCN_SPACE0_8822B 0xffff
+#define BIT_BCN_SPACE0_8822B(x)                                                \
+	(((x) & BIT_MASK_BCN_SPACE0_8822B) << BIT_SHIFT_BCN_SPACE0_8822B)
+#define BIT_GET_BCN_SPACE0_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_BCN_SPACE0_8822B) & BIT_MASK_BCN_SPACE0_8822B)
+
+/* 2 REG_DRVERLYINT_8822B */
+
+#define BIT_SHIFT_DRVERLYITV_8822B 0
+#define BIT_MASK_DRVERLYITV_8822B 0xff
+#define BIT_DRVERLYITV_8822B(x)                                                \
+	(((x) & BIT_MASK_DRVERLYITV_8822B) << BIT_SHIFT_DRVERLYITV_8822B)
+#define BIT_GET_DRVERLYITV_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_DRVERLYITV_8822B) & BIT_MASK_DRVERLYITV_8822B)
+
+/* 2 REG_BCNDMATIM_8822B */
+
+#define BIT_SHIFT_BCNDMATIM_8822B 0
+#define BIT_MASK_BCNDMATIM_8822B 0xff
+#define BIT_BCNDMATIM_8822B(x)                                                 \
+	(((x) & BIT_MASK_BCNDMATIM_8822B) << BIT_SHIFT_BCNDMATIM_8822B)
+#define BIT_GET_BCNDMATIM_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_BCNDMATIM_8822B) & BIT_MASK_BCNDMATIM_8822B)
+
+/* 2 REG_ATIMWND_8822B */
+
+#define BIT_SHIFT_ATIMWND0_8822B 0
+#define BIT_MASK_ATIMWND0_8822B 0xffff
+#define BIT_ATIMWND0_8822B(x)                                                  \
+	(((x) & BIT_MASK_ATIMWND0_8822B) << BIT_SHIFT_ATIMWND0_8822B)
+#define BIT_GET_ATIMWND0_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_ATIMWND0_8822B) & BIT_MASK_ATIMWND0_8822B)
+
+/* 2 REG_USTIME_TSF_8822B */
+
+#define BIT_SHIFT_USTIME_TSF_V1_8822B 0
+#define BIT_MASK_USTIME_TSF_V1_8822B 0xff
+#define BIT_USTIME_TSF_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_USTIME_TSF_V1_8822B) << BIT_SHIFT_USTIME_TSF_V1_8822B)
+#define BIT_GET_USTIME_TSF_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_USTIME_TSF_V1_8822B) & BIT_MASK_USTIME_TSF_V1_8822B)
+
+/* 2 REG_BCN_MAX_ERR_8822B */
+
+#define BIT_SHIFT_BCN_MAX_ERR_8822B 0
+#define BIT_MASK_BCN_MAX_ERR_8822B 0xff
+#define BIT_BCN_MAX_ERR_8822B(x)                                               \
+	(((x) & BIT_MASK_BCN_MAX_ERR_8822B) << BIT_SHIFT_BCN_MAX_ERR_8822B)
+#define BIT_GET_BCN_MAX_ERR_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_BCN_MAX_ERR_8822B) & BIT_MASK_BCN_MAX_ERR_8822B)
+
+/* 2 REG_RXTSF_OFFSET_CCK_8822B */
+
+#define BIT_SHIFT_CCK_RXTSF_OFFSET_8822B 0
+#define BIT_MASK_CCK_RXTSF_OFFSET_8822B 0xff
+#define BIT_CCK_RXTSF_OFFSET_8822B(x)                                          \
+	(((x) & BIT_MASK_CCK_RXTSF_OFFSET_8822B)                               \
+	 << BIT_SHIFT_CCK_RXTSF_OFFSET_8822B)
+#define BIT_GET_CCK_RXTSF_OFFSET_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_CCK_RXTSF_OFFSET_8822B) &                           \
+	 BIT_MASK_CCK_RXTSF_OFFSET_8822B)
+
+/* 2 REG_RXTSF_OFFSET_OFDM_8822B */
+
+#define BIT_SHIFT_OFDM_RXTSF_OFFSET_8822B 0
+#define BIT_MASK_OFDM_RXTSF_OFFSET_8822B 0xff
+#define BIT_OFDM_RXTSF_OFFSET_8822B(x)                                         \
+	(((x) & BIT_MASK_OFDM_RXTSF_OFFSET_8822B)                              \
+	 << BIT_SHIFT_OFDM_RXTSF_OFFSET_8822B)
+#define BIT_GET_OFDM_RXTSF_OFFSET_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_OFDM_RXTSF_OFFSET_8822B) &                          \
+	 BIT_MASK_OFDM_RXTSF_OFFSET_8822B)
+
+/* 2 REG_TSFTR_8822B */
+
+#define BIT_SHIFT_TSF_TIMER_8822B 0
+#define BIT_MASK_TSF_TIMER_8822B 0xffffffffffffffffL
+#define BIT_TSF_TIMER_8822B(x)                                                 \
+	(((x) & BIT_MASK_TSF_TIMER_8822B) << BIT_SHIFT_TSF_TIMER_8822B)
+#define BIT_GET_TSF_TIMER_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_TSF_TIMER_8822B) & BIT_MASK_TSF_TIMER_8822B)
+
+/* 2 REG_FREERUN_CNT_8822B */
+
+#define BIT_SHIFT_FREERUN_CNT_8822B 0
+#define BIT_MASK_FREERUN_CNT_8822B 0xffffffffffffffffL
+#define BIT_FREERUN_CNT_8822B(x)                                               \
+	(((x) & BIT_MASK_FREERUN_CNT_8822B) << BIT_SHIFT_FREERUN_CNT_8822B)
+#define BIT_GET_FREERUN_CNT_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_FREERUN_CNT_8822B) & BIT_MASK_FREERUN_CNT_8822B)
+
+/* 2 REG_ATIMWND1_V1_8822B */
+
+#define BIT_SHIFT_ATIMWND1_V1_8822B 0
+#define BIT_MASK_ATIMWND1_V1_8822B 0xff
+#define BIT_ATIMWND1_V1_8822B(x)                                               \
+	(((x) & BIT_MASK_ATIMWND1_V1_8822B) << BIT_SHIFT_ATIMWND1_V1_8822B)
+#define BIT_GET_ATIMWND1_V1_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_ATIMWND1_V1_8822B) & BIT_MASK_ATIMWND1_V1_8822B)
+
+/* 2 REG_TBTT_PROHIBIT_INFRA_8822B */
+
+#define BIT_SHIFT_TBTT_PROHIBIT_INFRA_8822B 0
+#define BIT_MASK_TBTT_PROHIBIT_INFRA_8822B 0xff
+#define BIT_TBTT_PROHIBIT_INFRA_8822B(x)                                       \
+	(((x) & BIT_MASK_TBTT_PROHIBIT_INFRA_8822B)                            \
+	 << BIT_SHIFT_TBTT_PROHIBIT_INFRA_8822B)
+#define BIT_GET_TBTT_PROHIBIT_INFRA_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_TBTT_PROHIBIT_INFRA_8822B) &                        \
+	 BIT_MASK_TBTT_PROHIBIT_INFRA_8822B)
+
+/* 2 REG_CTWND_8822B */
+
+#define BIT_SHIFT_CTWND_8822B 0
+#define BIT_MASK_CTWND_8822B 0xff
+#define BIT_CTWND_8822B(x)                                                     \
+	(((x) & BIT_MASK_CTWND_8822B) << BIT_SHIFT_CTWND_8822B)
+#define BIT_GET_CTWND_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_CTWND_8822B) & BIT_MASK_CTWND_8822B)
+
+/* 2 REG_BCNIVLCUNT_8822B */
+
+#define BIT_SHIFT_BCNIVLCUNT_8822B 0
+#define BIT_MASK_BCNIVLCUNT_8822B 0x7f
+#define BIT_BCNIVLCUNT_8822B(x)                                                \
+	(((x) & BIT_MASK_BCNIVLCUNT_8822B) << BIT_SHIFT_BCNIVLCUNT_8822B)
+#define BIT_GET_BCNIVLCUNT_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_BCNIVLCUNT_8822B) & BIT_MASK_BCNIVLCUNT_8822B)
+
+/* 2 REG_BCNDROPCTRL_8822B */
+#define BIT_BEACON_DROP_EN_8822B BIT(7)
+
+#define BIT_SHIFT_BEACON_DROP_IVL_8822B 0
+#define BIT_MASK_BEACON_DROP_IVL_8822B 0x7f
+#define BIT_BEACON_DROP_IVL_8822B(x)                                           \
+	(((x) & BIT_MASK_BEACON_DROP_IVL_8822B)                                \
+	 << BIT_SHIFT_BEACON_DROP_IVL_8822B)
+#define BIT_GET_BEACON_DROP_IVL_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_BEACON_DROP_IVL_8822B) &                            \
+	 BIT_MASK_BEACON_DROP_IVL_8822B)
+
+/* 2 REG_HGQ_TIMEOUT_PERIOD_8822B */
+
+#define BIT_SHIFT_HGQ_TIMEOUT_PERIOD_8822B 0
+#define BIT_MASK_HGQ_TIMEOUT_PERIOD_8822B 0xff
+#define BIT_HGQ_TIMEOUT_PERIOD_8822B(x)                                        \
+	(((x) & BIT_MASK_HGQ_TIMEOUT_PERIOD_8822B)                             \
+	 << BIT_SHIFT_HGQ_TIMEOUT_PERIOD_8822B)
+#define BIT_GET_HGQ_TIMEOUT_PERIOD_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_HGQ_TIMEOUT_PERIOD_8822B) &                         \
+	 BIT_MASK_HGQ_TIMEOUT_PERIOD_8822B)
+
+/* 2 REG_TXCMD_TIMEOUT_PERIOD_8822B */
+
+#define BIT_SHIFT_TXCMD_TIMEOUT_PERIOD_8822B 0
+#define BIT_MASK_TXCMD_TIMEOUT_PERIOD_8822B 0xff
+#define BIT_TXCMD_TIMEOUT_PERIOD_8822B(x)                                      \
+	(((x) & BIT_MASK_TXCMD_TIMEOUT_PERIOD_8822B)                           \
+	 << BIT_SHIFT_TXCMD_TIMEOUT_PERIOD_8822B)
+#define BIT_GET_TXCMD_TIMEOUT_PERIOD_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_TXCMD_TIMEOUT_PERIOD_8822B) &                       \
+	 BIT_MASK_TXCMD_TIMEOUT_PERIOD_8822B)
+
+/* 2 REG_MISC_CTRL_8822B */
+#define BIT_DIS_TRX_CAL_BCN_8822B BIT(5)
+#define BIT_DIS_TX_CAL_TBTT_8822B BIT(4)
+#define BIT_EN_FREECNT_8822B BIT(3)
+#define BIT_BCN_AGGRESSION_8822B BIT(2)
+
+#define BIT_SHIFT_DIS_SECONDARY_CCA_8822B 0
+#define BIT_MASK_DIS_SECONDARY_CCA_8822B 0x3
+#define BIT_DIS_SECONDARY_CCA_8822B(x)                                         \
+	(((x) & BIT_MASK_DIS_SECONDARY_CCA_8822B)                              \
+	 << BIT_SHIFT_DIS_SECONDARY_CCA_8822B)
+#define BIT_GET_DIS_SECONDARY_CCA_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_DIS_SECONDARY_CCA_8822B) &                          \
+	 BIT_MASK_DIS_SECONDARY_CCA_8822B)
+
+/* 2 REG_BCN_CTRL_CLINT1_8822B */
+#define BIT_CLI1_DIS_RX_BSSID_FIT_8822B BIT(6)
+#define BIT_CLI1_DIS_TSF_UDT_8822B BIT(4)
+#define BIT_CLI1_EN_BCN_FUNCTION_8822B BIT(3)
+#define BIT_CLI1_EN_RXBCN_RPT_8822B BIT(2)
+#define BIT_CLI1_ENP2P_CTWINDOW_8822B BIT(1)
+#define BIT_CLI1_ENP2P_BCNQ_AREA_8822B BIT(0)
+
+/* 2 REG_BCN_CTRL_CLINT2_8822B */
+#define BIT_CLI2_DIS_RX_BSSID_FIT_8822B BIT(6)
+#define BIT_CLI2_DIS_TSF_UDT_8822B BIT(4)
+#define BIT_CLI2_EN_BCN_FUNCTION_8822B BIT(3)
+#define BIT_CLI2_EN_RXBCN_RPT_8822B BIT(2)
+#define BIT_CLI2_ENP2P_CTWINDOW_8822B BIT(1)
+#define BIT_CLI2_ENP2P_BCNQ_AREA_8822B BIT(0)
+
+/* 2 REG_BCN_CTRL_CLINT3_8822B */
+#define BIT_CLI3_DIS_RX_BSSID_FIT_8822B BIT(6)
+#define BIT_CLI3_DIS_TSF_UDT_8822B BIT(4)
+#define BIT_CLI3_EN_BCN_FUNCTION_8822B BIT(3)
+#define BIT_CLI3_EN_RXBCN_RPT_8822B BIT(2)
+#define BIT_CLI3_ENP2P_CTWINDOW_8822B BIT(1)
+#define BIT_CLI3_ENP2P_BCNQ_AREA_8822B BIT(0)
+
+/* 2 REG_EXTEND_CTRL_8822B */
+#define BIT_EN_TSFBIT32_RST_P2P2_8822B BIT(5)
+#define BIT_EN_TSFBIT32_RST_P2P1_8822B BIT(4)
+
+#define BIT_SHIFT_PORT_SEL_8822B 0
+#define BIT_MASK_PORT_SEL_8822B 0x7
+#define BIT_PORT_SEL_8822B(x)                                                  \
+	(((x) & BIT_MASK_PORT_SEL_8822B) << BIT_SHIFT_PORT_SEL_8822B)
+#define BIT_GET_PORT_SEL_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_PORT_SEL_8822B) & BIT_MASK_PORT_SEL_8822B)
+
+/* 2 REG_P2PPS1_SPEC_STATE_8822B */
+#define BIT_P2P1_SPEC_POWER_STATE_8822B BIT(7)
+#define BIT_P2P1_SPEC_CTWINDOW_ON_8822B BIT(6)
+#define BIT_P2P1_SPEC_BCN_AREA_ON_8822B BIT(5)
+#define BIT_P2P1_SPEC_CTWIN_EARLY_DISTX_8822B BIT(4)
+#define BIT_P2P1_SPEC_NOA1_OFF_PERIOD_8822B BIT(3)
+#define BIT_P2P1_SPEC_FORCE_DOZE1_8822B BIT(2)
+#define BIT_P2P1_SPEC_NOA0_OFF_PERIOD_8822B BIT(1)
+#define BIT_P2P1_SPEC_FORCE_DOZE0_8822B BIT(0)
+
+/* 2 REG_P2PPS1_STATE_8822B */
+#define BIT_P2P1_POWER_STATE_8822B BIT(7)
+#define BIT_P2P1_CTWINDOW_ON_8822B BIT(6)
+#define BIT_P2P1_BEACON_AREA_ON_8822B BIT(5)
+#define BIT_P2P1_CTWIN_EARLY_DISTX_8822B BIT(4)
+#define BIT_P2P1_NOA1_OFF_PERIOD_8822B BIT(3)
+#define BIT_P2P1_FORCE_DOZE1_8822B BIT(2)
+#define BIT_P2P1_NOA0_OFF_PERIOD_8822B BIT(1)
+#define BIT_P2P1_FORCE_DOZE0_8822B BIT(0)
+
+/* 2 REG_P2PPS2_SPEC_STATE_8822B */
+#define BIT_P2P2_SPEC_POWER_STATE_8822B BIT(7)
+#define BIT_P2P2_SPEC_CTWINDOW_ON_8822B BIT(6)
+#define BIT_P2P2_SPEC_BCN_AREA_ON_8822B BIT(5)
+#define BIT_P2P2_SPEC_CTWIN_EARLY_DISTX_8822B BIT(4)
+#define BIT_P2P2_SPEC_NOA1_OFF_PERIOD_8822B BIT(3)
+#define BIT_P2P2_SPEC_FORCE_DOZE1_8822B BIT(2)
+#define BIT_P2P2_SPEC_NOA0_OFF_PERIOD_8822B BIT(1)
+#define BIT_P2P2_SPEC_FORCE_DOZE0_8822B BIT(0)
+
+/* 2 REG_P2PPS2_STATE_8822B */
+#define BIT_P2P2_POWER_STATE_8822B BIT(7)
+#define BIT_P2P2_CTWINDOW_ON_8822B BIT(6)
+#define BIT_P2P2_BEACON_AREA_ON_8822B BIT(5)
+#define BIT_P2P2_CTWIN_EARLY_DISTX_8822B BIT(4)
+#define BIT_P2P2_NOA1_OFF_PERIOD_8822B BIT(3)
+#define BIT_P2P2_FORCE_DOZE1_8822B BIT(2)
+#define BIT_P2P2_NOA0_OFF_PERIOD_8822B BIT(1)
+#define BIT_P2P2_FORCE_DOZE0_8822B BIT(0)
+
+/* 2 REG_PS_TIMER0_8822B */
+
+#define BIT_SHIFT_PSTIMER0_INT_8822B 5
+#define BIT_MASK_PSTIMER0_INT_8822B 0x7ffffff
+#define BIT_PSTIMER0_INT_8822B(x)                                              \
+	(((x) & BIT_MASK_PSTIMER0_INT_8822B) << BIT_SHIFT_PSTIMER0_INT_8822B)
+#define BIT_GET_PSTIMER0_INT_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_PSTIMER0_INT_8822B) & BIT_MASK_PSTIMER0_INT_8822B)
+
+/* 2 REG_PS_TIMER1_8822B */
+
+#define BIT_SHIFT_PSTIMER1_INT_8822B 5
+#define BIT_MASK_PSTIMER1_INT_8822B 0x7ffffff
+#define BIT_PSTIMER1_INT_8822B(x)                                              \
+	(((x) & BIT_MASK_PSTIMER1_INT_8822B) << BIT_SHIFT_PSTIMER1_INT_8822B)
+#define BIT_GET_PSTIMER1_INT_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_PSTIMER1_INT_8822B) & BIT_MASK_PSTIMER1_INT_8822B)
+
+/* 2 REG_PS_TIMER2_8822B */
+
+#define BIT_SHIFT_PSTIMER2_INT_8822B 5
+#define BIT_MASK_PSTIMER2_INT_8822B 0x7ffffff
+#define BIT_PSTIMER2_INT_8822B(x)                                              \
+	(((x) & BIT_MASK_PSTIMER2_INT_8822B) << BIT_SHIFT_PSTIMER2_INT_8822B)
+#define BIT_GET_PSTIMER2_INT_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_PSTIMER2_INT_8822B) & BIT_MASK_PSTIMER2_INT_8822B)
+
+/* 2 REG_TBTT_CTN_AREA_8822B */
+
+#define BIT_SHIFT_TBTT_CTN_AREA_8822B 0
+#define BIT_MASK_TBTT_CTN_AREA_8822B 0xff
+#define BIT_TBTT_CTN_AREA_8822B(x)                                             \
+	(((x) & BIT_MASK_TBTT_CTN_AREA_8822B) << BIT_SHIFT_TBTT_CTN_AREA_8822B)
+#define BIT_GET_TBTT_CTN_AREA_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_TBTT_CTN_AREA_8822B) & BIT_MASK_TBTT_CTN_AREA_8822B)
+
+/* 2 REG_FORCE_BCN_IFS_8822B */
+
+#define BIT_SHIFT_FORCE_BCN_IFS_8822B 0
+#define BIT_MASK_FORCE_BCN_IFS_8822B 0xff
+#define BIT_FORCE_BCN_IFS_8822B(x)                                             \
+	(((x) & BIT_MASK_FORCE_BCN_IFS_8822B) << BIT_SHIFT_FORCE_BCN_IFS_8822B)
+#define BIT_GET_FORCE_BCN_IFS_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_FORCE_BCN_IFS_8822B) & BIT_MASK_FORCE_BCN_IFS_8822B)
+
+/* 2 REG_TXOP_MIN_8822B */
+
+#define BIT_SHIFT_TXOP_MIN_8822B 0
+#define BIT_MASK_TXOP_MIN_8822B 0x3fff
+#define BIT_TXOP_MIN_8822B(x)                                                  \
+	(((x) & BIT_MASK_TXOP_MIN_8822B) << BIT_SHIFT_TXOP_MIN_8822B)
+#define BIT_GET_TXOP_MIN_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_TXOP_MIN_8822B) & BIT_MASK_TXOP_MIN_8822B)
+
+/* 2 REG_PRE_BKF_TIME_8822B */
+
+#define BIT_SHIFT_PRE_BKF_TIME_8822B 0
+#define BIT_MASK_PRE_BKF_TIME_8822B 0xff
+#define BIT_PRE_BKF_TIME_8822B(x)                                              \
+	(((x) & BIT_MASK_PRE_BKF_TIME_8822B) << BIT_SHIFT_PRE_BKF_TIME_8822B)
+#define BIT_GET_PRE_BKF_TIME_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_PRE_BKF_TIME_8822B) & BIT_MASK_PRE_BKF_TIME_8822B)
+
+/* 2 REG_CROSS_TXOP_CTRL_8822B */
+#define BIT_DTIM_BYPASS_8822B BIT(2)
+#define BIT_RTS_NAV_TXOP_8822B BIT(1)
+#define BIT_NOT_CROSS_TXOP_8822B BIT(0)
+
+/* 2 REG_ATIMWND2_8822B */
+
+#define BIT_SHIFT_ATIMWND2_8822B 0
+#define BIT_MASK_ATIMWND2_8822B 0xff
+#define BIT_ATIMWND2_8822B(x)                                                  \
+	(((x) & BIT_MASK_ATIMWND2_8822B) << BIT_SHIFT_ATIMWND2_8822B)
+#define BIT_GET_ATIMWND2_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_ATIMWND2_8822B) & BIT_MASK_ATIMWND2_8822B)
+
+/* 2 REG_ATIMWND3_8822B */
+
+#define BIT_SHIFT_ATIMWND3_8822B 0
+#define BIT_MASK_ATIMWND3_8822B 0xff
+#define BIT_ATIMWND3_8822B(x)                                                  \
+	(((x) & BIT_MASK_ATIMWND3_8822B) << BIT_SHIFT_ATIMWND3_8822B)
+#define BIT_GET_ATIMWND3_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_ATIMWND3_8822B) & BIT_MASK_ATIMWND3_8822B)
+
+/* 2 REG_ATIMWND4_8822B */
+
+#define BIT_SHIFT_ATIMWND4_8822B 0
+#define BIT_MASK_ATIMWND4_8822B 0xff
+#define BIT_ATIMWND4_8822B(x)                                                  \
+	(((x) & BIT_MASK_ATIMWND4_8822B) << BIT_SHIFT_ATIMWND4_8822B)
+#define BIT_GET_ATIMWND4_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_ATIMWND4_8822B) & BIT_MASK_ATIMWND4_8822B)
+
+/* 2 REG_ATIMWND5_8822B */
+
+#define BIT_SHIFT_ATIMWND5_8822B 0
+#define BIT_MASK_ATIMWND5_8822B 0xff
+#define BIT_ATIMWND5_8822B(x)                                                  \
+	(((x) & BIT_MASK_ATIMWND5_8822B) << BIT_SHIFT_ATIMWND5_8822B)
+#define BIT_GET_ATIMWND5_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_ATIMWND5_8822B) & BIT_MASK_ATIMWND5_8822B)
+
+/* 2 REG_ATIMWND6_8822B */
+
+#define BIT_SHIFT_ATIMWND6_8822B 0
+#define BIT_MASK_ATIMWND6_8822B 0xff
+#define BIT_ATIMWND6_8822B(x)                                                  \
+	(((x) & BIT_MASK_ATIMWND6_8822B) << BIT_SHIFT_ATIMWND6_8822B)
+#define BIT_GET_ATIMWND6_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_ATIMWND6_8822B) & BIT_MASK_ATIMWND6_8822B)
+
+/* 2 REG_ATIMWND7_8822B */
+
+#define BIT_SHIFT_ATIMWND7_8822B 0
+#define BIT_MASK_ATIMWND7_8822B 0xff
+#define BIT_ATIMWND7_8822B(x)                                                  \
+	(((x) & BIT_MASK_ATIMWND7_8822B) << BIT_SHIFT_ATIMWND7_8822B)
+#define BIT_GET_ATIMWND7_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_ATIMWND7_8822B) & BIT_MASK_ATIMWND7_8822B)
+
+/* 2 REG_ATIMUGT_8822B */
+
+#define BIT_SHIFT_ATIM_URGENT_8822B 0
+#define BIT_MASK_ATIM_URGENT_8822B 0xff
+#define BIT_ATIM_URGENT_8822B(x)                                               \
+	(((x) & BIT_MASK_ATIM_URGENT_8822B) << BIT_SHIFT_ATIM_URGENT_8822B)
+#define BIT_GET_ATIM_URGENT_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_ATIM_URGENT_8822B) & BIT_MASK_ATIM_URGENT_8822B)
+
+/* 2 REG_HIQ_NO_LMT_EN_8822B */
+#define BIT_HIQ_NO_LMT_EN_VAP7_8822B BIT(7)
+#define BIT_HIQ_NO_LMT_EN_VAP6_8822B BIT(6)
+#define BIT_HIQ_NO_LMT_EN_VAP5_8822B BIT(5)
+#define BIT_HIQ_NO_LMT_EN_VAP4_8822B BIT(4)
+#define BIT_HIQ_NO_LMT_EN_VAP3_8822B BIT(3)
+#define BIT_HIQ_NO_LMT_EN_VAP2_8822B BIT(2)
+#define BIT_HIQ_NO_LMT_EN_VAP1_8822B BIT(1)
+#define BIT_HIQ_NO_LMT_EN_ROOT_8822B BIT(0)
+
+/* 2 REG_DTIM_COUNTER_ROOT_8822B */
+
+#define BIT_SHIFT_DTIM_COUNT_ROOT_8822B 0
+#define BIT_MASK_DTIM_COUNT_ROOT_8822B 0xff
+#define BIT_DTIM_COUNT_ROOT_8822B(x)                                           \
+	(((x) & BIT_MASK_DTIM_COUNT_ROOT_8822B)                                \
+	 << BIT_SHIFT_DTIM_COUNT_ROOT_8822B)
+#define BIT_GET_DTIM_COUNT_ROOT_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_ROOT_8822B) &                            \
+	 BIT_MASK_DTIM_COUNT_ROOT_8822B)
+
+/* 2 REG_DTIM_COUNTER_VAP1_8822B */
+
+#define BIT_SHIFT_DTIM_COUNT_VAP1_8822B 0
+#define BIT_MASK_DTIM_COUNT_VAP1_8822B 0xff
+#define BIT_DTIM_COUNT_VAP1_8822B(x)                                           \
+	(((x) & BIT_MASK_DTIM_COUNT_VAP1_8822B)                                \
+	 << BIT_SHIFT_DTIM_COUNT_VAP1_8822B)
+#define BIT_GET_DTIM_COUNT_VAP1_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_VAP1_8822B) &                            \
+	 BIT_MASK_DTIM_COUNT_VAP1_8822B)
+
+/* 2 REG_DTIM_COUNTER_VAP2_8822B */
+
+#define BIT_SHIFT_DTIM_COUNT_VAP2_8822B 0
+#define BIT_MASK_DTIM_COUNT_VAP2_8822B 0xff
+#define BIT_DTIM_COUNT_VAP2_8822B(x)                                           \
+	(((x) & BIT_MASK_DTIM_COUNT_VAP2_8822B)                                \
+	 << BIT_SHIFT_DTIM_COUNT_VAP2_8822B)
+#define BIT_GET_DTIM_COUNT_VAP2_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_VAP2_8822B) &                            \
+	 BIT_MASK_DTIM_COUNT_VAP2_8822B)
+
+/* 2 REG_DTIM_COUNTER_VAP3_8822B */
+
+#define BIT_SHIFT_DTIM_COUNT_VAP3_8822B 0
+#define BIT_MASK_DTIM_COUNT_VAP3_8822B 0xff
+#define BIT_DTIM_COUNT_VAP3_8822B(x)                                           \
+	(((x) & BIT_MASK_DTIM_COUNT_VAP3_8822B)                                \
+	 << BIT_SHIFT_DTIM_COUNT_VAP3_8822B)
+#define BIT_GET_DTIM_COUNT_VAP3_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_VAP3_8822B) &                            \
+	 BIT_MASK_DTIM_COUNT_VAP3_8822B)
+
+/* 2 REG_DTIM_COUNTER_VAP4_8822B */
+
+#define BIT_SHIFT_DTIM_COUNT_VAP4_8822B 0
+#define BIT_MASK_DTIM_COUNT_VAP4_8822B 0xff
+#define BIT_DTIM_COUNT_VAP4_8822B(x)                                           \
+	(((x) & BIT_MASK_DTIM_COUNT_VAP4_8822B)                                \
+	 << BIT_SHIFT_DTIM_COUNT_VAP4_8822B)
+#define BIT_GET_DTIM_COUNT_VAP4_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_VAP4_8822B) &                            \
+	 BIT_MASK_DTIM_COUNT_VAP4_8822B)
+
+/* 2 REG_DTIM_COUNTER_VAP5_8822B */
+
+#define BIT_SHIFT_DTIM_COUNT_VAP5_8822B 0
+#define BIT_MASK_DTIM_COUNT_VAP5_8822B 0xff
+#define BIT_DTIM_COUNT_VAP5_8822B(x)                                           \
+	(((x) & BIT_MASK_DTIM_COUNT_VAP5_8822B)                                \
+	 << BIT_SHIFT_DTIM_COUNT_VAP5_8822B)
+#define BIT_GET_DTIM_COUNT_VAP5_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_VAP5_8822B) &                            \
+	 BIT_MASK_DTIM_COUNT_VAP5_8822B)
+
+/* 2 REG_DTIM_COUNTER_VAP6_8822B */
+
+#define BIT_SHIFT_DTIM_COUNT_VAP6_8822B 0
+#define BIT_MASK_DTIM_COUNT_VAP6_8822B 0xff
+#define BIT_DTIM_COUNT_VAP6_8822B(x)                                           \
+	(((x) & BIT_MASK_DTIM_COUNT_VAP6_8822B)                                \
+	 << BIT_SHIFT_DTIM_COUNT_VAP6_8822B)
+#define BIT_GET_DTIM_COUNT_VAP6_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_VAP6_8822B) &                            \
+	 BIT_MASK_DTIM_COUNT_VAP6_8822B)
+
+/* 2 REG_DTIM_COUNTER_VAP7_8822B */
+
+#define BIT_SHIFT_DTIM_COUNT_VAP7_8822B 0
+#define BIT_MASK_DTIM_COUNT_VAP7_8822B 0xff
+#define BIT_DTIM_COUNT_VAP7_8822B(x)                                           \
+	(((x) & BIT_MASK_DTIM_COUNT_VAP7_8822B)                                \
+	 << BIT_SHIFT_DTIM_COUNT_VAP7_8822B)
+#define BIT_GET_DTIM_COUNT_VAP7_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_DTIM_COUNT_VAP7_8822B) &                            \
+	 BIT_MASK_DTIM_COUNT_VAP7_8822B)
+
+/* 2 REG_DIS_ATIM_8822B */
+#define BIT_DIS_ATIM_VAP7_8822B BIT(7)
+#define BIT_DIS_ATIM_VAP6_8822B BIT(6)
+#define BIT_DIS_ATIM_VAP5_8822B BIT(5)
+#define BIT_DIS_ATIM_VAP4_8822B BIT(4)
+#define BIT_DIS_ATIM_VAP3_8822B BIT(3)
+#define BIT_DIS_ATIM_VAP2_8822B BIT(2)
+#define BIT_DIS_ATIM_VAP1_8822B BIT(1)
+#define BIT_DIS_ATIM_ROOT_8822B BIT(0)
+
+/* 2 REG_EARLY_128US_8822B */
+
+#define BIT_SHIFT_TSFT_SEL_TIMER1_8822B 3
+#define BIT_MASK_TSFT_SEL_TIMER1_8822B 0x7
+#define BIT_TSFT_SEL_TIMER1_8822B(x)                                           \
+	(((x) & BIT_MASK_TSFT_SEL_TIMER1_8822B)                                \
+	 << BIT_SHIFT_TSFT_SEL_TIMER1_8822B)
+#define BIT_GET_TSFT_SEL_TIMER1_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_TSFT_SEL_TIMER1_8822B) &                            \
+	 BIT_MASK_TSFT_SEL_TIMER1_8822B)
+
+#define BIT_SHIFT_EARLY_128US_8822B 0
+#define BIT_MASK_EARLY_128US_8822B 0x7
+#define BIT_EARLY_128US_8822B(x)                                               \
+	(((x) & BIT_MASK_EARLY_128US_8822B) << BIT_SHIFT_EARLY_128US_8822B)
+#define BIT_GET_EARLY_128US_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_EARLY_128US_8822B) & BIT_MASK_EARLY_128US_8822B)
+
+/* 2 REG_P2PPS1_CTRL_8822B */
+#define BIT_P2P1_CTW_ALLSTASLEEP_8822B BIT(7)
+#define BIT_P2P1_OFF_DISTX_EN_8822B BIT(6)
+#define BIT_P2P1_PWR_MGT_EN_8822B BIT(5)
+#define BIT_P2P1_NOA1_EN_8822B BIT(2)
+#define BIT_P2P1_NOA0_EN_8822B BIT(1)
+
+/* 2 REG_P2PPS2_CTRL_8822B */
+#define BIT_P2P2_CTW_ALLSTASLEEP_8822B BIT(7)
+#define BIT_P2P2_OFF_DISTX_EN_8822B BIT(6)
+#define BIT_P2P2_PWR_MGT_EN_8822B BIT(5)
+#define BIT_P2P2_NOA1_EN_8822B BIT(2)
+#define BIT_P2P2_NOA0_EN_8822B BIT(1)
+
+/* 2 REG_TIMER0_SRC_SEL_8822B */
+
+#define BIT_SHIFT_SYNC_CLI_SEL_8822B 4
+#define BIT_MASK_SYNC_CLI_SEL_8822B 0x7
+#define BIT_SYNC_CLI_SEL_8822B(x)                                              \
+	(((x) & BIT_MASK_SYNC_CLI_SEL_8822B) << BIT_SHIFT_SYNC_CLI_SEL_8822B)
+#define BIT_GET_SYNC_CLI_SEL_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_SYNC_CLI_SEL_8822B) & BIT_MASK_SYNC_CLI_SEL_8822B)
+
+#define BIT_SHIFT_TSFT_SEL_TIMER0_8822B 0
+#define BIT_MASK_TSFT_SEL_TIMER0_8822B 0x7
+#define BIT_TSFT_SEL_TIMER0_8822B(x)                                           \
+	(((x) & BIT_MASK_TSFT_SEL_TIMER0_8822B)                                \
+	 << BIT_SHIFT_TSFT_SEL_TIMER0_8822B)
+#define BIT_GET_TSFT_SEL_TIMER0_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_TSFT_SEL_TIMER0_8822B) &                            \
+	 BIT_MASK_TSFT_SEL_TIMER0_8822B)
+
+/* 2 REG_NOA_UNIT_SEL_8822B */
+
+#define BIT_SHIFT_NOA_UNIT2_SEL_8822B 8
+#define BIT_MASK_NOA_UNIT2_SEL_8822B 0x7
+#define BIT_NOA_UNIT2_SEL_8822B(x)                                             \
+	(((x) & BIT_MASK_NOA_UNIT2_SEL_8822B) << BIT_SHIFT_NOA_UNIT2_SEL_8822B)
+#define BIT_GET_NOA_UNIT2_SEL_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_NOA_UNIT2_SEL_8822B) & BIT_MASK_NOA_UNIT2_SEL_8822B)
+
+#define BIT_SHIFT_NOA_UNIT1_SEL_8822B 4
+#define BIT_MASK_NOA_UNIT1_SEL_8822B 0x7
+#define BIT_NOA_UNIT1_SEL_8822B(x)                                             \
+	(((x) & BIT_MASK_NOA_UNIT1_SEL_8822B) << BIT_SHIFT_NOA_UNIT1_SEL_8822B)
+#define BIT_GET_NOA_UNIT1_SEL_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_NOA_UNIT1_SEL_8822B) & BIT_MASK_NOA_UNIT1_SEL_8822B)
+
+#define BIT_SHIFT_NOA_UNIT0_SEL_8822B 0
+#define BIT_MASK_NOA_UNIT0_SEL_8822B 0x7
+#define BIT_NOA_UNIT0_SEL_8822B(x)                                             \
+	(((x) & BIT_MASK_NOA_UNIT0_SEL_8822B) << BIT_SHIFT_NOA_UNIT0_SEL_8822B)
+#define BIT_GET_NOA_UNIT0_SEL_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_NOA_UNIT0_SEL_8822B) & BIT_MASK_NOA_UNIT0_SEL_8822B)
+
+/* 2 REG_P2POFF_DIS_TXTIME_8822B */
+
+#define BIT_SHIFT_P2POFF_DIS_TXTIME_8822B 0
+#define BIT_MASK_P2POFF_DIS_TXTIME_8822B 0xff
+#define BIT_P2POFF_DIS_TXTIME_8822B(x)                                         \
+	(((x) & BIT_MASK_P2POFF_DIS_TXTIME_8822B)                              \
+	 << BIT_SHIFT_P2POFF_DIS_TXTIME_8822B)
+#define BIT_GET_P2POFF_DIS_TXTIME_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_P2POFF_DIS_TXTIME_8822B) &                          \
+	 BIT_MASK_P2POFF_DIS_TXTIME_8822B)
+
+/* 2 REG_MBSSID_BCN_SPACE2_8822B */
+
+#define BIT_SHIFT_BCN_SPACE_CLINT2_8822B 16
+#define BIT_MASK_BCN_SPACE_CLINT2_8822B 0xfff
+#define BIT_BCN_SPACE_CLINT2_8822B(x)                                          \
+	(((x) & BIT_MASK_BCN_SPACE_CLINT2_8822B)                               \
+	 << BIT_SHIFT_BCN_SPACE_CLINT2_8822B)
+#define BIT_GET_BCN_SPACE_CLINT2_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_BCN_SPACE_CLINT2_8822B) &                           \
+	 BIT_MASK_BCN_SPACE_CLINT2_8822B)
+
+#define BIT_SHIFT_BCN_SPACE_CLINT1_8822B 0
+#define BIT_MASK_BCN_SPACE_CLINT1_8822B 0xfff
+#define BIT_BCN_SPACE_CLINT1_8822B(x)                                          \
+	(((x) & BIT_MASK_BCN_SPACE_CLINT1_8822B)                               \
+	 << BIT_SHIFT_BCN_SPACE_CLINT1_8822B)
+#define BIT_GET_BCN_SPACE_CLINT1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_BCN_SPACE_CLINT1_8822B) &                           \
+	 BIT_MASK_BCN_SPACE_CLINT1_8822B)
+
+/* 2 REG_MBSSID_BCN_SPACE3_8822B */
+
+#define BIT_SHIFT_SUB_BCN_SPACE_8822B 16
+#define BIT_MASK_SUB_BCN_SPACE_8822B 0xff
+#define BIT_SUB_BCN_SPACE_8822B(x)                                             \
+	(((x) & BIT_MASK_SUB_BCN_SPACE_8822B) << BIT_SHIFT_SUB_BCN_SPACE_8822B)
+#define BIT_GET_SUB_BCN_SPACE_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_SUB_BCN_SPACE_8822B) & BIT_MASK_SUB_BCN_SPACE_8822B)
+
+#define BIT_SHIFT_BCN_SPACE_CLINT3_8822B 0
+#define BIT_MASK_BCN_SPACE_CLINT3_8822B 0xfff
+#define BIT_BCN_SPACE_CLINT3_8822B(x)                                          \
+	(((x) & BIT_MASK_BCN_SPACE_CLINT3_8822B)                               \
+	 << BIT_SHIFT_BCN_SPACE_CLINT3_8822B)
+#define BIT_GET_BCN_SPACE_CLINT3_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_BCN_SPACE_CLINT3_8822B) &                           \
+	 BIT_MASK_BCN_SPACE_CLINT3_8822B)
+
+/* 2 REG_ACMHWCTRL_8822B */
+#define BIT_BEQ_ACM_STATUS_8822B BIT(7)
+#define BIT_VIQ_ACM_STATUS_8822B BIT(6)
+#define BIT_VOQ_ACM_STATUS_8822B BIT(5)
+#define BIT_BEQ_ACM_EN_8822B BIT(3)
+#define BIT_VIQ_ACM_EN_8822B BIT(2)
+#define BIT_VOQ_ACM_EN_8822B BIT(1)
+#define BIT_ACMHWEN_8822B BIT(0)
+
+/* 2 REG_ACMRSTCTRL_8822B */
+#define BIT_BE_ACM_RESET_USED_TIME_8822B BIT(2)
+#define BIT_VI_ACM_RESET_USED_TIME_8822B BIT(1)
+#define BIT_VO_ACM_RESET_USED_TIME_8822B BIT(0)
+
+/* 2 REG_ACMAVG_8822B */
+
+#define BIT_SHIFT_AVGPERIOD_8822B 0
+#define BIT_MASK_AVGPERIOD_8822B 0xffff
+#define BIT_AVGPERIOD_8822B(x)                                                 \
+	(((x) & BIT_MASK_AVGPERIOD_8822B) << BIT_SHIFT_AVGPERIOD_8822B)
+#define BIT_GET_AVGPERIOD_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_AVGPERIOD_8822B) & BIT_MASK_AVGPERIOD_8822B)
+
+/* 2 REG_VO_ADMTIME_8822B */
+
+#define BIT_SHIFT_VO_ADMITTED_TIME_8822B 0
+#define BIT_MASK_VO_ADMITTED_TIME_8822B 0xffff
+#define BIT_VO_ADMITTED_TIME_8822B(x)                                          \
+	(((x) & BIT_MASK_VO_ADMITTED_TIME_8822B)                               \
+	 << BIT_SHIFT_VO_ADMITTED_TIME_8822B)
+#define BIT_GET_VO_ADMITTED_TIME_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_VO_ADMITTED_TIME_8822B) &                           \
+	 BIT_MASK_VO_ADMITTED_TIME_8822B)
+
+/* 2 REG_VI_ADMTIME_8822B */
+
+#define BIT_SHIFT_VI_ADMITTED_TIME_8822B 0
+#define BIT_MASK_VI_ADMITTED_TIME_8822B 0xffff
+#define BIT_VI_ADMITTED_TIME_8822B(x)                                          \
+	(((x) & BIT_MASK_VI_ADMITTED_TIME_8822B)                               \
+	 << BIT_SHIFT_VI_ADMITTED_TIME_8822B)
+#define BIT_GET_VI_ADMITTED_TIME_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_VI_ADMITTED_TIME_8822B) &                           \
+	 BIT_MASK_VI_ADMITTED_TIME_8822B)
+
+/* 2 REG_BE_ADMTIME_8822B */
+
+#define BIT_SHIFT_BE_ADMITTED_TIME_8822B 0
+#define BIT_MASK_BE_ADMITTED_TIME_8822B 0xffff
+#define BIT_BE_ADMITTED_TIME_8822B(x)                                          \
+	(((x) & BIT_MASK_BE_ADMITTED_TIME_8822B)                               \
+	 << BIT_SHIFT_BE_ADMITTED_TIME_8822B)
+#define BIT_GET_BE_ADMITTED_TIME_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_BE_ADMITTED_TIME_8822B) &                           \
+	 BIT_MASK_BE_ADMITTED_TIME_8822B)
+
+/* 2 REG_EDCA_RANDOM_GEN_8822B */
+
+#define BIT_SHIFT_RANDOM_GEN_8822B 0
+#define BIT_MASK_RANDOM_GEN_8822B 0xffffff
+#define BIT_RANDOM_GEN_8822B(x)                                                \
+	(((x) & BIT_MASK_RANDOM_GEN_8822B) << BIT_SHIFT_RANDOM_GEN_8822B)
+#define BIT_GET_RANDOM_GEN_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_RANDOM_GEN_8822B) & BIT_MASK_RANDOM_GEN_8822B)
+
+/* 2 REG_TXCMD_NOA_SEL_8822B */
+
+#define BIT_SHIFT_NOA_SEL_8822B 4
+#define BIT_MASK_NOA_SEL_8822B 0x7
+#define BIT_NOA_SEL_8822B(x)                                                   \
+	(((x) & BIT_MASK_NOA_SEL_8822B) << BIT_SHIFT_NOA_SEL_8822B)
+#define BIT_GET_NOA_SEL_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_NOA_SEL_8822B) & BIT_MASK_NOA_SEL_8822B)
+
+#define BIT_SHIFT_TXCMD_SEG_SEL_8822B 0
+#define BIT_MASK_TXCMD_SEG_SEL_8822B 0xf
+#define BIT_TXCMD_SEG_SEL_8822B(x)                                             \
+	(((x) & BIT_MASK_TXCMD_SEG_SEL_8822B) << BIT_SHIFT_TXCMD_SEG_SEL_8822B)
+#define BIT_GET_TXCMD_SEG_SEL_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_TXCMD_SEG_SEL_8822B) & BIT_MASK_TXCMD_SEG_SEL_8822B)
+
+/* 2 REG_NOA_PARAM_8822B */
+
+#define BIT_SHIFT_NOA_COUNT_8822B (96 & CPU_OPT_WIDTH)
+#define BIT_MASK_NOA_COUNT_8822B 0xff
+#define BIT_NOA_COUNT_8822B(x)                                                 \
+	(((x) & BIT_MASK_NOA_COUNT_8822B) << BIT_SHIFT_NOA_COUNT_8822B)
+#define BIT_GET_NOA_COUNT_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_NOA_COUNT_8822B) & BIT_MASK_NOA_COUNT_8822B)
+
+#define BIT_SHIFT_NOA_START_TIME_8822B (64 & CPU_OPT_WIDTH)
+#define BIT_MASK_NOA_START_TIME_8822B 0xffffffffL
+#define BIT_NOA_START_TIME_8822B(x)                                            \
+	(((x) & BIT_MASK_NOA_START_TIME_8822B)                                 \
+	 << BIT_SHIFT_NOA_START_TIME_8822B)
+#define BIT_GET_NOA_START_TIME_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_NOA_START_TIME_8822B) &                             \
+	 BIT_MASK_NOA_START_TIME_8822B)
+
+#define BIT_SHIFT_NOA_INTERVAL_8822B (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_NOA_INTERVAL_8822B 0xffffffffL
+#define BIT_NOA_INTERVAL_8822B(x)                                              \
+	(((x) & BIT_MASK_NOA_INTERVAL_8822B) << BIT_SHIFT_NOA_INTERVAL_8822B)
+#define BIT_GET_NOA_INTERVAL_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_NOA_INTERVAL_8822B) & BIT_MASK_NOA_INTERVAL_8822B)
+
+#define BIT_SHIFT_NOA_DURATION_8822B 0
+#define BIT_MASK_NOA_DURATION_8822B 0xffffffffL
+#define BIT_NOA_DURATION_8822B(x)                                              \
+	(((x) & BIT_MASK_NOA_DURATION_8822B) << BIT_SHIFT_NOA_DURATION_8822B)
+#define BIT_GET_NOA_DURATION_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_NOA_DURATION_8822B) & BIT_MASK_NOA_DURATION_8822B)
+
+/* 2 REG_P2P_RST_8822B */
+#define BIT_P2P2_PWR_RST1_8822B BIT(5)
+#define BIT_P2P2_PWR_RST0_8822B BIT(4)
+#define BIT_P2P1_PWR_RST1_8822B BIT(3)
+#define BIT_P2P1_PWR_RST0_8822B BIT(2)
+#define BIT_P2P_PWR_RST1_V1_8822B BIT(1)
+#define BIT_P2P_PWR_RST0_V1_8822B BIT(0)
+
+/* 2 REG_SCHEDULER_RST_8822B */
+#define BIT_SYNC_CLI_8822B BIT(1)
+#define BIT_SCHEDULER_RST_V1_8822B BIT(0)
+
+/* 2 REG_SCH_TXCMD_8822B */
+
+#define BIT_SHIFT_SCH_TXCMD_8822B 0
+#define BIT_MASK_SCH_TXCMD_8822B 0xffffffffL
+#define BIT_SCH_TXCMD_8822B(x)                                                 \
+	(((x) & BIT_MASK_SCH_TXCMD_8822B) << BIT_SHIFT_SCH_TXCMD_8822B)
+#define BIT_GET_SCH_TXCMD_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_SCH_TXCMD_8822B) & BIT_MASK_SCH_TXCMD_8822B)
+
+/* 2 REG_PAGE5_DUMMY_8822B */
+
+/* 2 REG_CPUMGQ_TX_TIMER_8822B */
+
+#define BIT_SHIFT_CPUMGQ_TX_TIMER_V1_8822B 0
+#define BIT_MASK_CPUMGQ_TX_TIMER_V1_8822B 0xffffffffL
+#define BIT_CPUMGQ_TX_TIMER_V1_8822B(x)                                        \
+	(((x) & BIT_MASK_CPUMGQ_TX_TIMER_V1_8822B)                             \
+	 << BIT_SHIFT_CPUMGQ_TX_TIMER_V1_8822B)
+#define BIT_GET_CPUMGQ_TX_TIMER_V1_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_CPUMGQ_TX_TIMER_V1_8822B) &                         \
+	 BIT_MASK_CPUMGQ_TX_TIMER_V1_8822B)
+
+/* 2 REG_PS_TIMER_A_8822B */
+
+#define BIT_SHIFT_PS_TIMER_A_V1_8822B 0
+#define BIT_MASK_PS_TIMER_A_V1_8822B 0xffffffffL
+#define BIT_PS_TIMER_A_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_PS_TIMER_A_V1_8822B) << BIT_SHIFT_PS_TIMER_A_V1_8822B)
+#define BIT_GET_PS_TIMER_A_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_PS_TIMER_A_V1_8822B) & BIT_MASK_PS_TIMER_A_V1_8822B)
+
+/* 2 REG_PS_TIMER_B_8822B */
+
+#define BIT_SHIFT_PS_TIMER_B_V1_8822B 0
+#define BIT_MASK_PS_TIMER_B_V1_8822B 0xffffffffL
+#define BIT_PS_TIMER_B_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_PS_TIMER_B_V1_8822B) << BIT_SHIFT_PS_TIMER_B_V1_8822B)
+#define BIT_GET_PS_TIMER_B_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_PS_TIMER_B_V1_8822B) & BIT_MASK_PS_TIMER_B_V1_8822B)
+
+/* 2 REG_PS_TIMER_C_8822B */
+
+#define BIT_SHIFT_PS_TIMER_C_V1_8822B 0
+#define BIT_MASK_PS_TIMER_C_V1_8822B 0xffffffffL
+#define BIT_PS_TIMER_C_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_PS_TIMER_C_V1_8822B) << BIT_SHIFT_PS_TIMER_C_V1_8822B)
+#define BIT_GET_PS_TIMER_C_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_PS_TIMER_C_V1_8822B) & BIT_MASK_PS_TIMER_C_V1_8822B)
+
+/* 2 REG_PS_TIMER_ABC_CPUMGQ_TIMER_CRTL_8822B */
+#define BIT_CPUMGQ_TIMER_EN_8822B BIT(31)
+#define BIT_CPUMGQ_TX_EN_8822B BIT(28)
+
+#define BIT_SHIFT_CPUMGQ_TIMER_TSF_SEL_8822B 24
+#define BIT_MASK_CPUMGQ_TIMER_TSF_SEL_8822B 0x7
+#define BIT_CPUMGQ_TIMER_TSF_SEL_8822B(x)                                      \
+	(((x) & BIT_MASK_CPUMGQ_TIMER_TSF_SEL_8822B)                           \
+	 << BIT_SHIFT_CPUMGQ_TIMER_TSF_SEL_8822B)
+#define BIT_GET_CPUMGQ_TIMER_TSF_SEL_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_CPUMGQ_TIMER_TSF_SEL_8822B) &                       \
+	 BIT_MASK_CPUMGQ_TIMER_TSF_SEL_8822B)
+
+#define BIT_PS_TIMER_C_EN_8822B BIT(23)
+
+#define BIT_SHIFT_PS_TIMER_C_TSF_SEL_8822B 16
+#define BIT_MASK_PS_TIMER_C_TSF_SEL_8822B 0x7
+#define BIT_PS_TIMER_C_TSF_SEL_8822B(x)                                        \
+	(((x) & BIT_MASK_PS_TIMER_C_TSF_SEL_8822B)                             \
+	 << BIT_SHIFT_PS_TIMER_C_TSF_SEL_8822B)
+#define BIT_GET_PS_TIMER_C_TSF_SEL_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_PS_TIMER_C_TSF_SEL_8822B) &                         \
+	 BIT_MASK_PS_TIMER_C_TSF_SEL_8822B)
+
+#define BIT_PS_TIMER_B_EN_8822B BIT(15)
+
+#define BIT_SHIFT_PS_TIMER_B_TSF_SEL_8822B 8
+#define BIT_MASK_PS_TIMER_B_TSF_SEL_8822B 0x7
+#define BIT_PS_TIMER_B_TSF_SEL_8822B(x)                                        \
+	(((x) & BIT_MASK_PS_TIMER_B_TSF_SEL_8822B)                             \
+	 << BIT_SHIFT_PS_TIMER_B_TSF_SEL_8822B)
+#define BIT_GET_PS_TIMER_B_TSF_SEL_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_PS_TIMER_B_TSF_SEL_8822B) &                         \
+	 BIT_MASK_PS_TIMER_B_TSF_SEL_8822B)
+
+#define BIT_PS_TIMER_A_EN_8822B BIT(7)
+
+#define BIT_SHIFT_PS_TIMER_A_TSF_SEL_8822B 0
+#define BIT_MASK_PS_TIMER_A_TSF_SEL_8822B 0x7
+#define BIT_PS_TIMER_A_TSF_SEL_8822B(x)                                        \
+	(((x) & BIT_MASK_PS_TIMER_A_TSF_SEL_8822B)                             \
+	 << BIT_SHIFT_PS_TIMER_A_TSF_SEL_8822B)
+#define BIT_GET_PS_TIMER_A_TSF_SEL_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_PS_TIMER_A_TSF_SEL_8822B) &                         \
+	 BIT_MASK_PS_TIMER_A_TSF_SEL_8822B)
+
+/* 2 REG_CPUMGQ_TX_TIMER_EARLY_8822B */
+
+#define BIT_SHIFT_CPUMGQ_TX_TIMER_EARLY_8822B 0
+#define BIT_MASK_CPUMGQ_TX_TIMER_EARLY_8822B 0xff
+#define BIT_CPUMGQ_TX_TIMER_EARLY_8822B(x)                                     \
+	(((x) & BIT_MASK_CPUMGQ_TX_TIMER_EARLY_8822B)                          \
+	 << BIT_SHIFT_CPUMGQ_TX_TIMER_EARLY_8822B)
+#define BIT_GET_CPUMGQ_TX_TIMER_EARLY_8822B(x)                                 \
+	(((x) >> BIT_SHIFT_CPUMGQ_TX_TIMER_EARLY_8822B) &                      \
+	 BIT_MASK_CPUMGQ_TX_TIMER_EARLY_8822B)
+
+/* 2 REG_PS_TIMER_A_EARLY_8822B */
+
+#define BIT_SHIFT_PS_TIMER_A_EARLY_8822B 0
+#define BIT_MASK_PS_TIMER_A_EARLY_8822B 0xff
+#define BIT_PS_TIMER_A_EARLY_8822B(x)                                          \
+	(((x) & BIT_MASK_PS_TIMER_A_EARLY_8822B)                               \
+	 << BIT_SHIFT_PS_TIMER_A_EARLY_8822B)
+#define BIT_GET_PS_TIMER_A_EARLY_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_PS_TIMER_A_EARLY_8822B) &                           \
+	 BIT_MASK_PS_TIMER_A_EARLY_8822B)
+
+/* 2 REG_PS_TIMER_B_EARLY_8822B */
+
+#define BIT_SHIFT_PS_TIMER_B_EARLY_8822B 0
+#define BIT_MASK_PS_TIMER_B_EARLY_8822B 0xff
+#define BIT_PS_TIMER_B_EARLY_8822B(x)                                          \
+	(((x) & BIT_MASK_PS_TIMER_B_EARLY_8822B)                               \
+	 << BIT_SHIFT_PS_TIMER_B_EARLY_8822B)
+#define BIT_GET_PS_TIMER_B_EARLY_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_PS_TIMER_B_EARLY_8822B) &                           \
+	 BIT_MASK_PS_TIMER_B_EARLY_8822B)
+
+/* 2 REG_PS_TIMER_C_EARLY_8822B */
+
+#define BIT_SHIFT_PS_TIMER_C_EARLY_8822B 0
+#define BIT_MASK_PS_TIMER_C_EARLY_8822B 0xff
+#define BIT_PS_TIMER_C_EARLY_8822B(x)                                          \
+	(((x) & BIT_MASK_PS_TIMER_C_EARLY_8822B)                               \
+	 << BIT_SHIFT_PS_TIMER_C_EARLY_8822B)
+#define BIT_GET_PS_TIMER_C_EARLY_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_PS_TIMER_C_EARLY_8822B) &                           \
+	 BIT_MASK_PS_TIMER_C_EARLY_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_BWOPMODE_8822B (BW OPERATION MODE REGISTER) */
+
+/* 2 REG_WMAC_FWPKT_CR_8822B */
+#define BIT_FWEN_8822B BIT(7)
+#define BIT_PHYSTS_PKT_CTRL_8822B BIT(6)
+#define BIT_APPHDR_MIDSRCH_FAIL_8822B BIT(4)
+#define BIT_FWPARSING_EN_8822B BIT(3)
+
+#define BIT_SHIFT_APPEND_MHDR_LEN_8822B 0
+#define BIT_MASK_APPEND_MHDR_LEN_8822B 0x7
+#define BIT_APPEND_MHDR_LEN_8822B(x)                                           \
+	(((x) & BIT_MASK_APPEND_MHDR_LEN_8822B)                                \
+	 << BIT_SHIFT_APPEND_MHDR_LEN_8822B)
+#define BIT_GET_APPEND_MHDR_LEN_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_APPEND_MHDR_LEN_8822B) &                            \
+	 BIT_MASK_APPEND_MHDR_LEN_8822B)
+
+/* 2 REG_WMAC_CR_8822B (WMAC CR AND APSD CONTROL REGISTER) */
+#define BIT_IC_MACPHY_M_8822B BIT(0)
+
+/* 2 REG_TCR_8822B (TRANSMISSION CONFIGURATION REGISTER) */
+#define BIT_WMAC_EN_RTS_ADDR_8822B BIT(31)
+#define BIT_WMAC_DISABLE_CCK_8822B BIT(30)
+#define BIT_WMAC_RAW_LEN_8822B BIT(29)
+#define BIT_WMAC_NOTX_IN_RXNDP_8822B BIT(28)
+#define BIT_WMAC_EN_EOF_8822B BIT(27)
+#define BIT_WMAC_BF_SEL_8822B BIT(26)
+#define BIT_WMAC_ANTMODE_SEL_8822B BIT(25)
+#define BIT_WMAC_TCRPWRMGT_HWCTL_8822B BIT(24)
+#define BIT_WMAC_SMOOTH_VAL_8822B BIT(23)
+#define BIT_FETCH_MPDU_AFTER_WSEC_RDY_8822B BIT(20)
+#define BIT_WMAC_TCR_EN_20MST_8822B BIT(19)
+#define BIT_WMAC_DIS_SIGTA_8822B BIT(18)
+#define BIT_WMAC_DIS_A2B0_8822B BIT(17)
+#define BIT_WMAC_MSK_SIGBCRC_8822B BIT(16)
+#define BIT_WMAC_TCR_ERRSTEN_3_8822B BIT(15)
+#define BIT_WMAC_TCR_ERRSTEN_2_8822B BIT(14)
+#define BIT_WMAC_TCR_ERRSTEN_1_8822B BIT(13)
+#define BIT_WMAC_TCR_ERRSTEN_0_8822B BIT(12)
+#define BIT_WMAC_TCR_TXSK_PERPKT_8822B BIT(11)
+#define BIT_ICV_8822B BIT(10)
+#define BIT_CFEND_FORMAT_8822B BIT(9)
+#define BIT_CRC_8822B BIT(8)
+#define BIT_PWRBIT_OW_EN_8822B BIT(7)
+#define BIT_PWR_ST_8822B BIT(6)
+#define BIT_WMAC_TCR_UPD_TIMIE_8822B BIT(5)
+#define BIT_WMAC_TCR_UPD_HGQMD_8822B BIT(4)
+#define BIT_VHTSIGA1_TXPS_8822B BIT(3)
+#define BIT_PAD_SEL_8822B BIT(2)
+#define BIT_DIS_GCLK_8822B BIT(1)
+
+/* 2 REG_RCR_8822B (RECEIVE CONFIGURATION REGISTER) */
+#define BIT_APP_FCS_8822B BIT(31)
+#define BIT_APP_MIC_8822B BIT(30)
+#define BIT_APP_ICV_8822B BIT(29)
+#define BIT_APP_PHYSTS_8822B BIT(28)
+#define BIT_APP_BASSN_8822B BIT(27)
+#define BIT_VHT_DACK_8822B BIT(26)
+#define BIT_TCPOFLD_EN_8822B BIT(25)
+#define BIT_ENMBID_8822B BIT(24)
+#define BIT_LSIGEN_8822B BIT(23)
+#define BIT_MFBEN_8822B BIT(22)
+#define BIT_DISCHKPPDLLEN_8822B BIT(21)
+#define BIT_PKTCTL_DLEN_8822B BIT(20)
+#define BIT_TIM_PARSER_EN_8822B BIT(18)
+#define BIT_BC_MD_EN_8822B BIT(17)
+#define BIT_UC_MD_EN_8822B BIT(16)
+#define BIT_RXSK_PERPKT_8822B BIT(15)
+#define BIT_HTC_LOC_CTRL_8822B BIT(14)
+#define BIT_RPFM_CAM_ENABLE_8822B BIT(12)
+#define BIT_TA_BCN_8822B BIT(11)
+#define BIT_DISDECMYPKT_8822B BIT(10)
+#define BIT_AICV_8822B BIT(9)
+#define BIT_ACRC32_8822B BIT(8)
+#define BIT_CBSSID_BCN_8822B BIT(7)
+#define BIT_CBSSID_DATA_8822B BIT(6)
+#define BIT_APWRMGT_8822B BIT(5)
+#define BIT_ADD3_8822B BIT(4)
+#define BIT_AB_8822B BIT(3)
+#define BIT_AM_8822B BIT(2)
+#define BIT_APM_8822B BIT(1)
+#define BIT_AAP_8822B BIT(0)
+
+/* 2 REG_RX_DRVINFO_SZ_8822B (RX DRIVER INFO SIZE REGISTER) */
+#define BIT_PHYSTS_PER_PKT_MODE_8822B BIT(7)
+
+#define BIT_SHIFT_DRVINFO_SZ_V1_8822B 0
+#define BIT_MASK_DRVINFO_SZ_V1_8822B 0xf
+#define BIT_DRVINFO_SZ_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_DRVINFO_SZ_V1_8822B) << BIT_SHIFT_DRVINFO_SZ_V1_8822B)
+#define BIT_GET_DRVINFO_SZ_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_DRVINFO_SZ_V1_8822B) & BIT_MASK_DRVINFO_SZ_V1_8822B)
+
+/* 2 REG_RX_DLK_TIME_8822B (RX DEADLOCK TIME REGISTER) */
+
+#define BIT_SHIFT_RX_DLK_TIME_8822B 0
+#define BIT_MASK_RX_DLK_TIME_8822B 0xff
+#define BIT_RX_DLK_TIME_8822B(x)                                               \
+	(((x) & BIT_MASK_RX_DLK_TIME_8822B) << BIT_SHIFT_RX_DLK_TIME_8822B)
+#define BIT_GET_RX_DLK_TIME_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_RX_DLK_TIME_8822B) & BIT_MASK_RX_DLK_TIME_8822B)
+
+/* 2 REG_RX_PKT_LIMIT_8822B (RX PACKET LENGTH LIMIT REGISTER) */
+
+#define BIT_SHIFT_RXPKTLMT_8822B 0
+#define BIT_MASK_RXPKTLMT_8822B 0x3f
+#define BIT_RXPKTLMT_8822B(x)                                                  \
+	(((x) & BIT_MASK_RXPKTLMT_8822B) << BIT_SHIFT_RXPKTLMT_8822B)
+#define BIT_GET_RXPKTLMT_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_RXPKTLMT_8822B) & BIT_MASK_RXPKTLMT_8822B)
+
+/* 2 REG_MACID_8822B (MAC ID REGISTER) */
+
+#define BIT_SHIFT_MACID_8822B 0
+#define BIT_MASK_MACID_8822B 0xffffffffffffL
+#define BIT_MACID_8822B(x)                                                     \
+	(((x) & BIT_MASK_MACID_8822B) << BIT_SHIFT_MACID_8822B)
+#define BIT_GET_MACID_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_MACID_8822B) & BIT_MASK_MACID_8822B)
+
+/* 2 REG_BSSID_8822B (BSSID REGISTER) */
+
+#define BIT_SHIFT_BSSID_8822B 0
+#define BIT_MASK_BSSID_8822B 0xffffffffffffL
+#define BIT_BSSID_8822B(x)                                                     \
+	(((x) & BIT_MASK_BSSID_8822B) << BIT_SHIFT_BSSID_8822B)
+#define BIT_GET_BSSID_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_BSSID_8822B) & BIT_MASK_BSSID_8822B)
+
+/* 2 REG_MAR_8822B (MULTICAST ADDRESS REGISTER) */
+
+#define BIT_SHIFT_MAR_8822B 0
+#define BIT_MASK_MAR_8822B 0xffffffffffffffffL
+#define BIT_MAR_8822B(x) (((x) & BIT_MASK_MAR_8822B) << BIT_SHIFT_MAR_8822B)
+#define BIT_GET_MAR_8822B(x) (((x) >> BIT_SHIFT_MAR_8822B) & BIT_MASK_MAR_8822B)
+
+/* 2 REG_MBIDCAMCFG_1_8822B (MBSSID CAM CONFIGURATION REGISTER) */
+
+#define BIT_SHIFT_MBIDCAM_RWDATA_L_8822B 0
+#define BIT_MASK_MBIDCAM_RWDATA_L_8822B 0xffffffffL
+#define BIT_MBIDCAM_RWDATA_L_8822B(x)                                          \
+	(((x) & BIT_MASK_MBIDCAM_RWDATA_L_8822B)                               \
+	 << BIT_SHIFT_MBIDCAM_RWDATA_L_8822B)
+#define BIT_GET_MBIDCAM_RWDATA_L_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_MBIDCAM_RWDATA_L_8822B) &                           \
+	 BIT_MASK_MBIDCAM_RWDATA_L_8822B)
+
+/* 2 REG_MBIDCAMCFG_2_8822B (MBSSID CAM CONFIGURATION REGISTER) */
+#define BIT_MBIDCAM_POLL_8822B BIT(31)
+#define BIT_MBIDCAM_WT_EN_8822B BIT(30)
+
+#define BIT_SHIFT_MBIDCAM_ADDR_8822B 24
+#define BIT_MASK_MBIDCAM_ADDR_8822B 0x1f
+#define BIT_MBIDCAM_ADDR_8822B(x)                                              \
+	(((x) & BIT_MASK_MBIDCAM_ADDR_8822B) << BIT_SHIFT_MBIDCAM_ADDR_8822B)
+#define BIT_GET_MBIDCAM_ADDR_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_MBIDCAM_ADDR_8822B) & BIT_MASK_MBIDCAM_ADDR_8822B)
+
+#define BIT_MBIDCAM_VALID_8822B BIT(23)
+#define BIT_LSIC_TXOP_EN_8822B BIT(17)
+#define BIT_CTS_EN_8822B BIT(16)
+
+#define BIT_SHIFT_MBIDCAM_RWDATA_H_8822B 0
+#define BIT_MASK_MBIDCAM_RWDATA_H_8822B 0xffff
+#define BIT_MBIDCAM_RWDATA_H_8822B(x)                                          \
+	(((x) & BIT_MASK_MBIDCAM_RWDATA_H_8822B)                               \
+	 << BIT_SHIFT_MBIDCAM_RWDATA_H_8822B)
+#define BIT_GET_MBIDCAM_RWDATA_H_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_MBIDCAM_RWDATA_H_8822B) &                           \
+	 BIT_MASK_MBIDCAM_RWDATA_H_8822B)
+
+/* 2 REG_ZLD_NUM_8822B */
+
+#define BIT_SHIFT_ZLD_NUM_8822B 0
+#define BIT_MASK_ZLD_NUM_8822B 0xff
+#define BIT_ZLD_NUM_8822B(x)                                                   \
+	(((x) & BIT_MASK_ZLD_NUM_8822B) << BIT_SHIFT_ZLD_NUM_8822B)
+#define BIT_GET_ZLD_NUM_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_ZLD_NUM_8822B) & BIT_MASK_ZLD_NUM_8822B)
+
+/* 2 REG_UDF_THSD_8822B */
+
+#define BIT_SHIFT_UDF_THSD_8822B 0
+#define BIT_MASK_UDF_THSD_8822B 0xff
+#define BIT_UDF_THSD_8822B(x)                                                  \
+	(((x) & BIT_MASK_UDF_THSD_8822B) << BIT_SHIFT_UDF_THSD_8822B)
+#define BIT_GET_UDF_THSD_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_UDF_THSD_8822B) & BIT_MASK_UDF_THSD_8822B)
+
+/* 2 REG_WMAC_TCR_TSFT_OFS_8822B */
+
+#define BIT_SHIFT_WMAC_TCR_TSFT_OFS_8822B 0
+#define BIT_MASK_WMAC_TCR_TSFT_OFS_8822B 0xffff
+#define BIT_WMAC_TCR_TSFT_OFS_8822B(x)                                         \
+	(((x) & BIT_MASK_WMAC_TCR_TSFT_OFS_8822B)                              \
+	 << BIT_SHIFT_WMAC_TCR_TSFT_OFS_8822B)
+#define BIT_GET_WMAC_TCR_TSFT_OFS_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_WMAC_TCR_TSFT_OFS_8822B) &                          \
+	 BIT_MASK_WMAC_TCR_TSFT_OFS_8822B)
+
+/* 2 REG_MCU_TEST_2_V1_8822B */
+
+#define BIT_SHIFT_MCU_RSVD_2_V1_8822B 0
+#define BIT_MASK_MCU_RSVD_2_V1_8822B 0xffff
+#define BIT_MCU_RSVD_2_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_MCU_RSVD_2_V1_8822B) << BIT_SHIFT_MCU_RSVD_2_V1_8822B)
+#define BIT_GET_MCU_RSVD_2_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_MCU_RSVD_2_V1_8822B) & BIT_MASK_MCU_RSVD_2_V1_8822B)
+
+/* 2 REG_WMAC_TXTIMEOUT_8822B */
+
+#define BIT_SHIFT_WMAC_TXTIMEOUT_8822B 0
+#define BIT_MASK_WMAC_TXTIMEOUT_8822B 0xff
+#define BIT_WMAC_TXTIMEOUT_8822B(x)                                            \
+	(((x) & BIT_MASK_WMAC_TXTIMEOUT_8822B)                                 \
+	 << BIT_SHIFT_WMAC_TXTIMEOUT_8822B)
+#define BIT_GET_WMAC_TXTIMEOUT_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_WMAC_TXTIMEOUT_8822B) &                             \
+	 BIT_MASK_WMAC_TXTIMEOUT_8822B)
+
+/* 2 REG_STMP_THSD_8822B */
+
+#define BIT_SHIFT_STMP_THSD_8822B 0
+#define BIT_MASK_STMP_THSD_8822B 0xff
+#define BIT_STMP_THSD_8822B(x)                                                 \
+	(((x) & BIT_MASK_STMP_THSD_8822B) << BIT_SHIFT_STMP_THSD_8822B)
+#define BIT_GET_STMP_THSD_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_STMP_THSD_8822B) & BIT_MASK_STMP_THSD_8822B)
+
+/* 2 REG_MAC_SPEC_SIFS_8822B (SPECIFICATION SIFS REGISTER) */
+
+#define BIT_SHIFT_SPEC_SIFS_OFDM_8822B 8
+#define BIT_MASK_SPEC_SIFS_OFDM_8822B 0xff
+#define BIT_SPEC_SIFS_OFDM_8822B(x)                                            \
+	(((x) & BIT_MASK_SPEC_SIFS_OFDM_8822B)                                 \
+	 << BIT_SHIFT_SPEC_SIFS_OFDM_8822B)
+#define BIT_GET_SPEC_SIFS_OFDM_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_SPEC_SIFS_OFDM_8822B) &                             \
+	 BIT_MASK_SPEC_SIFS_OFDM_8822B)
+
+#define BIT_SHIFT_SPEC_SIFS_CCK_8822B 0
+#define BIT_MASK_SPEC_SIFS_CCK_8822B 0xff
+#define BIT_SPEC_SIFS_CCK_8822B(x)                                             \
+	(((x) & BIT_MASK_SPEC_SIFS_CCK_8822B) << BIT_SHIFT_SPEC_SIFS_CCK_8822B)
+#define BIT_GET_SPEC_SIFS_CCK_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_SPEC_SIFS_CCK_8822B) & BIT_MASK_SPEC_SIFS_CCK_8822B)
+
+/* 2 REG_USTIME_EDCA_8822B (US TIME TUNING FOR EDCA REGISTER) */
+
+#define BIT_SHIFT_USTIME_EDCA_V1_8822B 0
+#define BIT_MASK_USTIME_EDCA_V1_8822B 0x1ff
+#define BIT_USTIME_EDCA_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_USTIME_EDCA_V1_8822B)                                 \
+	 << BIT_SHIFT_USTIME_EDCA_V1_8822B)
+#define BIT_GET_USTIME_EDCA_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_USTIME_EDCA_V1_8822B) &                             \
+	 BIT_MASK_USTIME_EDCA_V1_8822B)
+
+/* 2 REG_RESP_SIFS_OFDM_8822B (RESPONSE SIFS FOR OFDM REGISTER) */
+
+#define BIT_SHIFT_SIFS_R2T_OFDM_8822B 8
+#define BIT_MASK_SIFS_R2T_OFDM_8822B 0xff
+#define BIT_SIFS_R2T_OFDM_8822B(x)                                             \
+	(((x) & BIT_MASK_SIFS_R2T_OFDM_8822B) << BIT_SHIFT_SIFS_R2T_OFDM_8822B)
+#define BIT_GET_SIFS_R2T_OFDM_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_SIFS_R2T_OFDM_8822B) & BIT_MASK_SIFS_R2T_OFDM_8822B)
+
+#define BIT_SHIFT_SIFS_T2T_OFDM_8822B 0
+#define BIT_MASK_SIFS_T2T_OFDM_8822B 0xff
+#define BIT_SIFS_T2T_OFDM_8822B(x)                                             \
+	(((x) & BIT_MASK_SIFS_T2T_OFDM_8822B) << BIT_SHIFT_SIFS_T2T_OFDM_8822B)
+#define BIT_GET_SIFS_T2T_OFDM_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_SIFS_T2T_OFDM_8822B) & BIT_MASK_SIFS_T2T_OFDM_8822B)
+
+/* 2 REG_RESP_SIFS_CCK_8822B (RESPONSE SIFS FOR CCK REGISTER) */
+
+#define BIT_SHIFT_SIFS_R2T_CCK_8822B 8
+#define BIT_MASK_SIFS_R2T_CCK_8822B 0xff
+#define BIT_SIFS_R2T_CCK_8822B(x)                                              \
+	(((x) & BIT_MASK_SIFS_R2T_CCK_8822B) << BIT_SHIFT_SIFS_R2T_CCK_8822B)
+#define BIT_GET_SIFS_R2T_CCK_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_SIFS_R2T_CCK_8822B) & BIT_MASK_SIFS_R2T_CCK_8822B)
+
+#define BIT_SHIFT_SIFS_T2T_CCK_8822B 0
+#define BIT_MASK_SIFS_T2T_CCK_8822B 0xff
+#define BIT_SIFS_T2T_CCK_8822B(x)                                              \
+	(((x) & BIT_MASK_SIFS_T2T_CCK_8822B) << BIT_SHIFT_SIFS_T2T_CCK_8822B)
+#define BIT_GET_SIFS_T2T_CCK_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_SIFS_T2T_CCK_8822B) & BIT_MASK_SIFS_T2T_CCK_8822B)
+
+/* 2 REG_EIFS_8822B (EIFS REGISTER) */
+
+#define BIT_SHIFT_EIFS_8822B 0
+#define BIT_MASK_EIFS_8822B 0xffff
+#define BIT_EIFS_8822B(x) (((x) & BIT_MASK_EIFS_8822B) << BIT_SHIFT_EIFS_8822B)
+#define BIT_GET_EIFS_8822B(x)                                                  \
+	(((x) >> BIT_SHIFT_EIFS_8822B) & BIT_MASK_EIFS_8822B)
+
+/* 2 REG_CTS2TO_8822B (CTS2 TIMEOUT REGISTER) */
+
+#define BIT_SHIFT_CTS2TO_8822B 0
+#define BIT_MASK_CTS2TO_8822B 0xff
+#define BIT_CTS2TO_8822B(x)                                                    \
+	(((x) & BIT_MASK_CTS2TO_8822B) << BIT_SHIFT_CTS2TO_8822B)
+#define BIT_GET_CTS2TO_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_CTS2TO_8822B) & BIT_MASK_CTS2TO_8822B)
+
+/* 2 REG_ACKTO_8822B (ACK TIMEOUT REGISTER) */
+
+#define BIT_SHIFT_ACKTO_8822B 0
+#define BIT_MASK_ACKTO_8822B 0xff
+#define BIT_ACKTO_8822B(x)                                                     \
+	(((x) & BIT_MASK_ACKTO_8822B) << BIT_SHIFT_ACKTO_8822B)
+#define BIT_GET_ACKTO_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_ACKTO_8822B) & BIT_MASK_ACKTO_8822B)
+
+/* 2 REG_NAV_CTRL_8822B (NAV CONTROL REGISTER) */
+
+#define BIT_SHIFT_NAV_UPPER_8822B 16
+#define BIT_MASK_NAV_UPPER_8822B 0xff
+#define BIT_NAV_UPPER_8822B(x)                                                 \
+	(((x) & BIT_MASK_NAV_UPPER_8822B) << BIT_SHIFT_NAV_UPPER_8822B)
+#define BIT_GET_NAV_UPPER_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_NAV_UPPER_8822B) & BIT_MASK_NAV_UPPER_8822B)
+
+#define BIT_SHIFT_RXMYRTS_NAV_8822B 8
+#define BIT_MASK_RXMYRTS_NAV_8822B 0xf
+#define BIT_RXMYRTS_NAV_8822B(x)                                               \
+	(((x) & BIT_MASK_RXMYRTS_NAV_8822B) << BIT_SHIFT_RXMYRTS_NAV_8822B)
+#define BIT_GET_RXMYRTS_NAV_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_RXMYRTS_NAV_8822B) & BIT_MASK_RXMYRTS_NAV_8822B)
+
+#define BIT_SHIFT_RTSRST_8822B 0
+#define BIT_MASK_RTSRST_8822B 0xff
+#define BIT_RTSRST_8822B(x)                                                    \
+	(((x) & BIT_MASK_RTSRST_8822B) << BIT_SHIFT_RTSRST_8822B)
+#define BIT_GET_RTSRST_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_RTSRST_8822B) & BIT_MASK_RTSRST_8822B)
+
+/* 2 REG_BACAMCMD_8822B (BLOCK ACK CAM COMMAND REGISTER) */
+#define BIT_BACAM_POLL_8822B BIT(31)
+#define BIT_BACAM_RST_8822B BIT(17)
+#define BIT_BACAM_RW_8822B BIT(16)
+
+#define BIT_SHIFT_TXSBM_8822B 14
+#define BIT_MASK_TXSBM_8822B 0x3
+#define BIT_TXSBM_8822B(x)                                                     \
+	(((x) & BIT_MASK_TXSBM_8822B) << BIT_SHIFT_TXSBM_8822B)
+#define BIT_GET_TXSBM_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_TXSBM_8822B) & BIT_MASK_TXSBM_8822B)
+
+#define BIT_SHIFT_BACAM_ADDR_8822B 0
+#define BIT_MASK_BACAM_ADDR_8822B 0x3f
+#define BIT_BACAM_ADDR_8822B(x)                                                \
+	(((x) & BIT_MASK_BACAM_ADDR_8822B) << BIT_SHIFT_BACAM_ADDR_8822B)
+#define BIT_GET_BACAM_ADDR_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_BACAM_ADDR_8822B) & BIT_MASK_BACAM_ADDR_8822B)
+
+/* 2 REG_BACAMCONTENT_8822B (BLOCK ACK CAM CONTENT REGISTER) */
+
+#define BIT_SHIFT_BA_CONTENT_H_8822B (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_BA_CONTENT_H_8822B 0xffffffffL
+#define BIT_BA_CONTENT_H_8822B(x)                                              \
+	(((x) & BIT_MASK_BA_CONTENT_H_8822B) << BIT_SHIFT_BA_CONTENT_H_8822B)
+#define BIT_GET_BA_CONTENT_H_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_BA_CONTENT_H_8822B) & BIT_MASK_BA_CONTENT_H_8822B)
+
+#define BIT_SHIFT_BA_CONTENT_L_8822B 0
+#define BIT_MASK_BA_CONTENT_L_8822B 0xffffffffL
+#define BIT_BA_CONTENT_L_8822B(x)                                              \
+	(((x) & BIT_MASK_BA_CONTENT_L_8822B) << BIT_SHIFT_BA_CONTENT_L_8822B)
+#define BIT_GET_BA_CONTENT_L_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_BA_CONTENT_L_8822B) & BIT_MASK_BA_CONTENT_L_8822B)
+
+/* 2 REG_WMAC_BITMAP_CTL_8822B */
+#define BIT_BITMAP_VO_8822B BIT(7)
+#define BIT_BITMAP_VI_8822B BIT(6)
+#define BIT_BITMAP_BE_8822B BIT(5)
+#define BIT_BITMAP_BK_8822B BIT(4)
+
+#define BIT_SHIFT_BITMAP_CONDITION_8822B 2
+#define BIT_MASK_BITMAP_CONDITION_8822B 0x3
+#define BIT_BITMAP_CONDITION_8822B(x)                                          \
+	(((x) & BIT_MASK_BITMAP_CONDITION_8822B)                               \
+	 << BIT_SHIFT_BITMAP_CONDITION_8822B)
+#define BIT_GET_BITMAP_CONDITION_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_BITMAP_CONDITION_8822B) &                           \
+	 BIT_MASK_BITMAP_CONDITION_8822B)
+
+#define BIT_BITMAP_SSNBK_COUNTER_CLR_8822B BIT(1)
+#define BIT_BITMAP_FORCE_8822B BIT(0)
+
+/* 2 REG_TX_RX_8822B STATUS */
+
+#define BIT_SHIFT_RXPKT_TYPE_8822B 2
+#define BIT_MASK_RXPKT_TYPE_8822B 0x3f
+#define BIT_RXPKT_TYPE_8822B(x)                                                \
+	(((x) & BIT_MASK_RXPKT_TYPE_8822B) << BIT_SHIFT_RXPKT_TYPE_8822B)
+#define BIT_GET_RXPKT_TYPE_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_RXPKT_TYPE_8822B) & BIT_MASK_RXPKT_TYPE_8822B)
+
+#define BIT_TXACT_IND_8822B BIT(1)
+#define BIT_RXACT_IND_8822B BIT(0)
+
+/* 2 REG_WMAC_BACAM_RPMEN_8822B */
+
+#define BIT_SHIFT_BITMAP_SSNBK_COUNTER_8822B 2
+#define BIT_MASK_BITMAP_SSNBK_COUNTER_8822B 0x3f
+#define BIT_BITMAP_SSNBK_COUNTER_8822B(x)                                      \
+	(((x) & BIT_MASK_BITMAP_SSNBK_COUNTER_8822B)                           \
+	 << BIT_SHIFT_BITMAP_SSNBK_COUNTER_8822B)
+#define BIT_GET_BITMAP_SSNBK_COUNTER_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_BITMAP_SSNBK_COUNTER_8822B) &                       \
+	 BIT_MASK_BITMAP_SSNBK_COUNTER_8822B)
+
+#define BIT_BITMAP_EN_8822B BIT(1)
+#define BIT_WMAC_BACAM_RPMEN_8822B BIT(0)
+
+/* 2 REG_LBDLY_8822B (LOOPBACK DELAY REGISTER) */
+
+#define BIT_SHIFT_LBDLY_8822B 0
+#define BIT_MASK_LBDLY_8822B 0x1f
+#define BIT_LBDLY_8822B(x)                                                     \
+	(((x) & BIT_MASK_LBDLY_8822B) << BIT_SHIFT_LBDLY_8822B)
+#define BIT_GET_LBDLY_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_LBDLY_8822B) & BIT_MASK_LBDLY_8822B)
+
+/* 2 REG_RXERR_RPT_8822B (RX ERROR REPORT REGISTER) */
+
+#define BIT_SHIFT_RXERR_RPT_SEL_V1_3_0_8822B 28
+#define BIT_MASK_RXERR_RPT_SEL_V1_3_0_8822B 0xf
+#define BIT_RXERR_RPT_SEL_V1_3_0_8822B(x)                                      \
+	(((x) & BIT_MASK_RXERR_RPT_SEL_V1_3_0_8822B)                           \
+	 << BIT_SHIFT_RXERR_RPT_SEL_V1_3_0_8822B)
+#define BIT_GET_RXERR_RPT_SEL_V1_3_0_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_RXERR_RPT_SEL_V1_3_0_8822B) &                       \
+	 BIT_MASK_RXERR_RPT_SEL_V1_3_0_8822B)
+
+#define BIT_RXERR_RPT_RST_8822B BIT(27)
+#define BIT_RXERR_RPT_SEL_V1_4_8822B BIT(26)
+#define BIT_W1S_8822B BIT(23)
+#define BIT_UD_SELECT_BSSID_8822B BIT(22)
+
+#define BIT_SHIFT_UD_SUB_TYPE_8822B 18
+#define BIT_MASK_UD_SUB_TYPE_8822B 0xf
+#define BIT_UD_SUB_TYPE_8822B(x)                                               \
+	(((x) & BIT_MASK_UD_SUB_TYPE_8822B) << BIT_SHIFT_UD_SUB_TYPE_8822B)
+#define BIT_GET_UD_SUB_TYPE_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_UD_SUB_TYPE_8822B) & BIT_MASK_UD_SUB_TYPE_8822B)
+
+#define BIT_SHIFT_UD_TYPE_8822B 16
+#define BIT_MASK_UD_TYPE_8822B 0x3
+#define BIT_UD_TYPE_8822B(x)                                                   \
+	(((x) & BIT_MASK_UD_TYPE_8822B) << BIT_SHIFT_UD_TYPE_8822B)
+#define BIT_GET_UD_TYPE_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_UD_TYPE_8822B) & BIT_MASK_UD_TYPE_8822B)
+
+#define BIT_SHIFT_RPT_COUNTER_8822B 0
+#define BIT_MASK_RPT_COUNTER_8822B 0xffff
+#define BIT_RPT_COUNTER_8822B(x)                                               \
+	(((x) & BIT_MASK_RPT_COUNTER_8822B) << BIT_SHIFT_RPT_COUNTER_8822B)
+#define BIT_GET_RPT_COUNTER_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_RPT_COUNTER_8822B) & BIT_MASK_RPT_COUNTER_8822B)
+
+/* 2 REG_WMAC_TRXPTCL_CTL_8822B (WMAC TX/RX PROTOCOL CONTROL REGISTER) */
+
+#define BIT_SHIFT_ACKBA_TYPSEL_8822B (60 & CPU_OPT_WIDTH)
+#define BIT_MASK_ACKBA_TYPSEL_8822B 0xf
+#define BIT_ACKBA_TYPSEL_8822B(x)                                              \
+	(((x) & BIT_MASK_ACKBA_TYPSEL_8822B) << BIT_SHIFT_ACKBA_TYPSEL_8822B)
+#define BIT_GET_ACKBA_TYPSEL_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_ACKBA_TYPSEL_8822B) & BIT_MASK_ACKBA_TYPSEL_8822B)
+
+#define BIT_SHIFT_ACKBA_ACKPCHK_8822B (56 & CPU_OPT_WIDTH)
+#define BIT_MASK_ACKBA_ACKPCHK_8822B 0xf
+#define BIT_ACKBA_ACKPCHK_8822B(x)                                             \
+	(((x) & BIT_MASK_ACKBA_ACKPCHK_8822B) << BIT_SHIFT_ACKBA_ACKPCHK_8822B)
+#define BIT_GET_ACKBA_ACKPCHK_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_ACKBA_ACKPCHK_8822B) & BIT_MASK_ACKBA_ACKPCHK_8822B)
+
+#define BIT_SHIFT_ACKBAR_TYPESEL_8822B (48 & CPU_OPT_WIDTH)
+#define BIT_MASK_ACKBAR_TYPESEL_8822B 0xff
+#define BIT_ACKBAR_TYPESEL_8822B(x)                                            \
+	(((x) & BIT_MASK_ACKBAR_TYPESEL_8822B)                                 \
+	 << BIT_SHIFT_ACKBAR_TYPESEL_8822B)
+#define BIT_GET_ACKBAR_TYPESEL_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_ACKBAR_TYPESEL_8822B) &                             \
+	 BIT_MASK_ACKBAR_TYPESEL_8822B)
+
+#define BIT_SHIFT_ACKBAR_ACKPCHK_8822B (44 & CPU_OPT_WIDTH)
+#define BIT_MASK_ACKBAR_ACKPCHK_8822B 0xf
+#define BIT_ACKBAR_ACKPCHK_8822B(x)                                            \
+	(((x) & BIT_MASK_ACKBAR_ACKPCHK_8822B)                                 \
+	 << BIT_SHIFT_ACKBAR_ACKPCHK_8822B)
+#define BIT_GET_ACKBAR_ACKPCHK_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_ACKBAR_ACKPCHK_8822B) &                             \
+	 BIT_MASK_ACKBAR_ACKPCHK_8822B)
+
+#define BIT_RXBA_IGNOREA2_8822B BIT(42)
+#define BIT_EN_SAVE_ALL_TXOPADDR_8822B BIT(41)
+#define BIT_EN_TXCTS_TO_TXOPOWNER_INRXNAV_8822B BIT(40)
+#define BIT_DIS_TXBA_AMPDUFCSERR_8822B BIT(39)
+#define BIT_DIS_TXBA_RXBARINFULL_8822B BIT(38)
+#define BIT_DIS_TXCFE_INFULL_8822B BIT(37)
+#define BIT_DIS_TXCTS_INFULL_8822B BIT(36)
+#define BIT_EN_TXACKBA_IN_TX_RDG_8822B BIT(35)
+#define BIT_EN_TXACKBA_IN_TXOP_8822B BIT(34)
+#define BIT_EN_TXCTS_IN_RXNAV_8822B BIT(33)
+#define BIT_EN_TXCTS_INTXOP_8822B BIT(32)
+#define BIT_BLK_EDCA_BBSLP_8822B BIT(31)
+#define BIT_BLK_EDCA_BBSBY_8822B BIT(30)
+#define BIT_ACKTO_BLOCK_SCH_EN_8822B BIT(27)
+#define BIT_EIFS_BLOCK_SCH_EN_8822B BIT(26)
+#define BIT_PLCPCHK_RST_EIFS_8822B BIT(25)
+#define BIT_CCA_RST_EIFS_8822B BIT(24)
+#define BIT_DIS_UPD_MYRXPKTNAV_8822B BIT(23)
+#define BIT_EARLY_TXBA_8822B BIT(22)
+
+#define BIT_SHIFT_RESP_CHNBUSY_8822B 20
+#define BIT_MASK_RESP_CHNBUSY_8822B 0x3
+#define BIT_RESP_CHNBUSY_8822B(x)                                              \
+	(((x) & BIT_MASK_RESP_CHNBUSY_8822B) << BIT_SHIFT_RESP_CHNBUSY_8822B)
+#define BIT_GET_RESP_CHNBUSY_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_RESP_CHNBUSY_8822B) & BIT_MASK_RESP_CHNBUSY_8822B)
+
+#define BIT_RESP_DCTS_EN_8822B BIT(19)
+#define BIT_RESP_DCFE_EN_8822B BIT(18)
+#define BIT_RESP_SPLCPEN_8822B BIT(17)
+#define BIT_RESP_SGIEN_8822B BIT(16)
+#define BIT_RESP_LDPC_EN_8822B BIT(15)
+#define BIT_DIS_RESP_ACKINCCA_8822B BIT(14)
+#define BIT_DIS_RESP_CTSINCCA_8822B BIT(13)
+
+#define BIT_SHIFT_R_WMAC_SECOND_CCA_TIMER_8822B 10
+#define BIT_MASK_R_WMAC_SECOND_CCA_TIMER_8822B 0x7
+#define BIT_R_WMAC_SECOND_CCA_TIMER_8822B(x)                                   \
+	(((x) & BIT_MASK_R_WMAC_SECOND_CCA_TIMER_8822B)                        \
+	 << BIT_SHIFT_R_WMAC_SECOND_CCA_TIMER_8822B)
+#define BIT_GET_R_WMAC_SECOND_CCA_TIMER_8822B(x)                               \
+	(((x) >> BIT_SHIFT_R_WMAC_SECOND_CCA_TIMER_8822B) &                    \
+	 BIT_MASK_R_WMAC_SECOND_CCA_TIMER_8822B)
+
+#define BIT_SHIFT_RFMOD_8822B 7
+#define BIT_MASK_RFMOD_8822B 0x3
+#define BIT_RFMOD_8822B(x)                                                     \
+	(((x) & BIT_MASK_RFMOD_8822B) << BIT_SHIFT_RFMOD_8822B)
+#define BIT_GET_RFMOD_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_RFMOD_8822B) & BIT_MASK_RFMOD_8822B)
+
+#define BIT_SHIFT_RESP_CTS_DYNBW_SEL_8822B 5
+#define BIT_MASK_RESP_CTS_DYNBW_SEL_8822B 0x3
+#define BIT_RESP_CTS_DYNBW_SEL_8822B(x)                                        \
+	(((x) & BIT_MASK_RESP_CTS_DYNBW_SEL_8822B)                             \
+	 << BIT_SHIFT_RESP_CTS_DYNBW_SEL_8822B)
+#define BIT_GET_RESP_CTS_DYNBW_SEL_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_RESP_CTS_DYNBW_SEL_8822B) &                         \
+	 BIT_MASK_RESP_CTS_DYNBW_SEL_8822B)
+
+#define BIT_DLY_TX_WAIT_RXANTSEL_8822B BIT(4)
+#define BIT_TXRESP_BY_RXANTSEL_8822B BIT(3)
+
+#define BIT_SHIFT_ORIG_DCTS_CHK_8822B 0
+#define BIT_MASK_ORIG_DCTS_CHK_8822B 0x3
+#define BIT_ORIG_DCTS_CHK_8822B(x)                                             \
+	(((x) & BIT_MASK_ORIG_DCTS_CHK_8822B) << BIT_SHIFT_ORIG_DCTS_CHK_8822B)
+#define BIT_GET_ORIG_DCTS_CHK_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_ORIG_DCTS_CHK_8822B) & BIT_MASK_ORIG_DCTS_CHK_8822B)
+
+/* 2 REG_CAMCMD_8822B (CAM COMMAND REGISTER) */
+#define BIT_SECCAM_POLLING_8822B BIT(31)
+#define BIT_SECCAM_CLR_8822B BIT(30)
+#define BIT_MFBCAM_CLR_8822B BIT(29)
+#define BIT_SECCAM_WE_8822B BIT(16)
+
+#define BIT_SHIFT_SECCAM_ADDR_V2_8822B 0
+#define BIT_MASK_SECCAM_ADDR_V2_8822B 0x3ff
+#define BIT_SECCAM_ADDR_V2_8822B(x)                                            \
+	(((x) & BIT_MASK_SECCAM_ADDR_V2_8822B)                                 \
+	 << BIT_SHIFT_SECCAM_ADDR_V2_8822B)
+#define BIT_GET_SECCAM_ADDR_V2_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_SECCAM_ADDR_V2_8822B) &                             \
+	 BIT_MASK_SECCAM_ADDR_V2_8822B)
+
+/* 2 REG_CAMWRITE_8822B (CAM WRITE REGISTER) */
+
+#define BIT_SHIFT_CAMW_DATA_8822B 0
+#define BIT_MASK_CAMW_DATA_8822B 0xffffffffL
+#define BIT_CAMW_DATA_8822B(x)                                                 \
+	(((x) & BIT_MASK_CAMW_DATA_8822B) << BIT_SHIFT_CAMW_DATA_8822B)
+#define BIT_GET_CAMW_DATA_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_CAMW_DATA_8822B) & BIT_MASK_CAMW_DATA_8822B)
+
+/* 2 REG_CAMREAD_8822B (CAM READ REGISTER) */
+
+#define BIT_SHIFT_CAMR_DATA_8822B 0
+#define BIT_MASK_CAMR_DATA_8822B 0xffffffffL
+#define BIT_CAMR_DATA_8822B(x)                                                 \
+	(((x) & BIT_MASK_CAMR_DATA_8822B) << BIT_SHIFT_CAMR_DATA_8822B)
+#define BIT_GET_CAMR_DATA_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_CAMR_DATA_8822B) & BIT_MASK_CAMR_DATA_8822B)
+
+/* 2 REG_CAMDBG_8822B (CAM DEBUG REGISTER) */
+#define BIT_SECCAM_INFO_8822B BIT(31)
+#define BIT_SEC_KEYFOUND_8822B BIT(15)
+
+#define BIT_SHIFT_CAMDBG_SEC_TYPE_8822B 12
+#define BIT_MASK_CAMDBG_SEC_TYPE_8822B 0x7
+#define BIT_CAMDBG_SEC_TYPE_8822B(x)                                           \
+	(((x) & BIT_MASK_CAMDBG_SEC_TYPE_8822B)                                \
+	 << BIT_SHIFT_CAMDBG_SEC_TYPE_8822B)
+#define BIT_GET_CAMDBG_SEC_TYPE_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_CAMDBG_SEC_TYPE_8822B) &                            \
+	 BIT_MASK_CAMDBG_SEC_TYPE_8822B)
+
+#define BIT_CAMDBG_EXT_SECTYPE_8822B BIT(11)
+
+#define BIT_SHIFT_CAMDBG_MIC_KEY_IDX_8822B 5
+#define BIT_MASK_CAMDBG_MIC_KEY_IDX_8822B 0x1f
+#define BIT_CAMDBG_MIC_KEY_IDX_8822B(x)                                        \
+	(((x) & BIT_MASK_CAMDBG_MIC_KEY_IDX_8822B)                             \
+	 << BIT_SHIFT_CAMDBG_MIC_KEY_IDX_8822B)
+#define BIT_GET_CAMDBG_MIC_KEY_IDX_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_CAMDBG_MIC_KEY_IDX_8822B) &                         \
+	 BIT_MASK_CAMDBG_MIC_KEY_IDX_8822B)
+
+#define BIT_SHIFT_CAMDBG_SEC_KEY_IDX_8822B 0
+#define BIT_MASK_CAMDBG_SEC_KEY_IDX_8822B 0x1f
+#define BIT_CAMDBG_SEC_KEY_IDX_8822B(x)                                        \
+	(((x) & BIT_MASK_CAMDBG_SEC_KEY_IDX_8822B)                             \
+	 << BIT_SHIFT_CAMDBG_SEC_KEY_IDX_8822B)
+#define BIT_GET_CAMDBG_SEC_KEY_IDX_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_CAMDBG_SEC_KEY_IDX_8822B) &                         \
+	 BIT_MASK_CAMDBG_SEC_KEY_IDX_8822B)
+
+/* 2 REG_RXFILTER_ACTION_1_8822B */
+
+#define BIT_SHIFT_RXFILTER_ACTION_1_8822B 0
+#define BIT_MASK_RXFILTER_ACTION_1_8822B 0xff
+#define BIT_RXFILTER_ACTION_1_8822B(x)                                         \
+	(((x) & BIT_MASK_RXFILTER_ACTION_1_8822B)                              \
+	 << BIT_SHIFT_RXFILTER_ACTION_1_8822B)
+#define BIT_GET_RXFILTER_ACTION_1_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_RXFILTER_ACTION_1_8822B) &                          \
+	 BIT_MASK_RXFILTER_ACTION_1_8822B)
+
+/* 2 REG_RXFILTER_CATEGORY_1_8822B */
+
+#define BIT_SHIFT_RXFILTER_CATEGORY_1_8822B 0
+#define BIT_MASK_RXFILTER_CATEGORY_1_8822B 0xff
+#define BIT_RXFILTER_CATEGORY_1_8822B(x)                                       \
+	(((x) & BIT_MASK_RXFILTER_CATEGORY_1_8822B)                            \
+	 << BIT_SHIFT_RXFILTER_CATEGORY_1_8822B)
+#define BIT_GET_RXFILTER_CATEGORY_1_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_RXFILTER_CATEGORY_1_8822B) &                        \
+	 BIT_MASK_RXFILTER_CATEGORY_1_8822B)
+
+/* 2 REG_SECCFG_8822B (SECURITY CONFIGURATION REGISTER) */
+#define BIT_DIS_GCLK_WAPI_8822B BIT(15)
+#define BIT_DIS_GCLK_AES_8822B BIT(14)
+#define BIT_DIS_GCLK_TKIP_8822B BIT(13)
+#define BIT_AES_SEL_QC_1_8822B BIT(12)
+#define BIT_AES_SEL_QC_0_8822B BIT(11)
+#define BIT_CHK_BMC_8822B BIT(9)
+#define BIT_CHK_KEYID_8822B BIT(8)
+#define BIT_RXBCUSEDK_8822B BIT(7)
+#define BIT_TXBCUSEDK_8822B BIT(6)
+#define BIT_NOSKMC_8822B BIT(5)
+#define BIT_SKBYA2_8822B BIT(4)
+#define BIT_RXDEC_8822B BIT(3)
+#define BIT_TXENC_8822B BIT(2)
+#define BIT_RXUHUSEDK_8822B BIT(1)
+#define BIT_TXUHUSEDK_8822B BIT(0)
+
+/* 2 REG_RXFILTER_ACTION_3_8822B */
+
+#define BIT_SHIFT_RXFILTER_ACTION_3_8822B 0
+#define BIT_MASK_RXFILTER_ACTION_3_8822B 0xff
+#define BIT_RXFILTER_ACTION_3_8822B(x)                                         \
+	(((x) & BIT_MASK_RXFILTER_ACTION_3_8822B)                              \
+	 << BIT_SHIFT_RXFILTER_ACTION_3_8822B)
+#define BIT_GET_RXFILTER_ACTION_3_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_RXFILTER_ACTION_3_8822B) &                          \
+	 BIT_MASK_RXFILTER_ACTION_3_8822B)
+
+/* 2 REG_RXFILTER_CATEGORY_3_8822B */
+
+#define BIT_SHIFT_RXFILTER_CATEGORY_3_8822B 0
+#define BIT_MASK_RXFILTER_CATEGORY_3_8822B 0xff
+#define BIT_RXFILTER_CATEGORY_3_8822B(x)                                       \
+	(((x) & BIT_MASK_RXFILTER_CATEGORY_3_8822B)                            \
+	 << BIT_SHIFT_RXFILTER_CATEGORY_3_8822B)
+#define BIT_GET_RXFILTER_CATEGORY_3_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_RXFILTER_CATEGORY_3_8822B) &                        \
+	 BIT_MASK_RXFILTER_CATEGORY_3_8822B)
+
+/* 2 REG_RXFILTER_ACTION_2_8822B */
+
+#define BIT_SHIFT_RXFILTER_ACTION_2_8822B 0
+#define BIT_MASK_RXFILTER_ACTION_2_8822B 0xff
+#define BIT_RXFILTER_ACTION_2_8822B(x)                                         \
+	(((x) & BIT_MASK_RXFILTER_ACTION_2_8822B)                              \
+	 << BIT_SHIFT_RXFILTER_ACTION_2_8822B)
+#define BIT_GET_RXFILTER_ACTION_2_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_RXFILTER_ACTION_2_8822B) &                          \
+	 BIT_MASK_RXFILTER_ACTION_2_8822B)
+
+/* 2 REG_RXFILTER_CATEGORY_2_8822B */
+
+#define BIT_SHIFT_RXFILTER_CATEGORY_2_8822B 0
+#define BIT_MASK_RXFILTER_CATEGORY_2_8822B 0xff
+#define BIT_RXFILTER_CATEGORY_2_8822B(x)                                       \
+	(((x) & BIT_MASK_RXFILTER_CATEGORY_2_8822B)                            \
+	 << BIT_SHIFT_RXFILTER_CATEGORY_2_8822B)
+#define BIT_GET_RXFILTER_CATEGORY_2_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_RXFILTER_CATEGORY_2_8822B) &                        \
+	 BIT_MASK_RXFILTER_CATEGORY_2_8822B)
+
+/* 2 REG_RXFLTMAP4_8822B (RX FILTER MAP GROUP 4) */
+#define BIT_CTRLFLT15EN_FW_8822B BIT(15)
+#define BIT_CTRLFLT14EN_FW_8822B BIT(14)
+#define BIT_CTRLFLT13EN_FW_8822B BIT(13)
+#define BIT_CTRLFLT12EN_FW_8822B BIT(12)
+#define BIT_CTRLFLT11EN_FW_8822B BIT(11)
+#define BIT_CTRLFLT10EN_FW_8822B BIT(10)
+#define BIT_CTRLFLT9EN_FW_8822B BIT(9)
+#define BIT_CTRLFLT8EN_FW_8822B BIT(8)
+#define BIT_CTRLFLT7EN_FW_8822B BIT(7)
+#define BIT_CTRLFLT6EN_FW_8822B BIT(6)
+#define BIT_CTRLFLT5EN_FW_8822B BIT(5)
+#define BIT_CTRLFLT4EN_FW_8822B BIT(4)
+#define BIT_CTRLFLT3EN_FW_8822B BIT(3)
+#define BIT_CTRLFLT2EN_FW_8822B BIT(2)
+#define BIT_CTRLFLT1EN_FW_8822B BIT(1)
+#define BIT_CTRLFLT0EN_FW_8822B BIT(0)
+
+/* 2 REG_RXFLTMAP3_8822B (RX FILTER MAP GROUP 3) */
+#define BIT_MGTFLT15EN_FW_8822B BIT(15)
+#define BIT_MGTFLT14EN_FW_8822B BIT(14)
+#define BIT_MGTFLT13EN_FW_8822B BIT(13)
+#define BIT_MGTFLT12EN_FW_8822B BIT(12)
+#define BIT_MGTFLT11EN_FW_8822B BIT(11)
+#define BIT_MGTFLT10EN_FW_8822B BIT(10)
+#define BIT_MGTFLT9EN_FW_8822B BIT(9)
+#define BIT_MGTFLT8EN_FW_8822B BIT(8)
+#define BIT_MGTFLT7EN_FW_8822B BIT(7)
+#define BIT_MGTFLT6EN_FW_8822B BIT(6)
+#define BIT_MGTFLT5EN_FW_8822B BIT(5)
+#define BIT_MGTFLT4EN_FW_8822B BIT(4)
+#define BIT_MGTFLT3EN_FW_8822B BIT(3)
+#define BIT_MGTFLT2EN_FW_8822B BIT(2)
+#define BIT_MGTFLT1EN_FW_8822B BIT(1)
+#define BIT_MGTFLT0EN_FW_8822B BIT(0)
+
+/* 2 REG_RXFLTMAP6_8822B (RX FILTER MAP GROUP 3) */
+#define BIT_ACTIONFLT15EN_FW_8822B BIT(15)
+#define BIT_ACTIONFLT14EN_FW_8822B BIT(14)
+#define BIT_ACTIONFLT13EN_FW_8822B BIT(13)
+#define BIT_ACTIONFLT12EN_FW_8822B BIT(12)
+#define BIT_ACTIONFLT11EN_FW_8822B BIT(11)
+#define BIT_ACTIONFLT10EN_FW_8822B BIT(10)
+#define BIT_ACTIONFLT9EN_FW_8822B BIT(9)
+#define BIT_ACTIONFLT8EN_FW_8822B BIT(8)
+#define BIT_ACTIONFLT7EN_FW_8822B BIT(7)
+#define BIT_ACTIONFLT6EN_FW_8822B BIT(6)
+#define BIT_ACTIONFLT5EN_FW_8822B BIT(5)
+#define BIT_ACTIONFLT4EN_FW_8822B BIT(4)
+#define BIT_ACTIONFLT3EN_FW_8822B BIT(3)
+#define BIT_ACTIONFLT2EN_FW_8822B BIT(2)
+#define BIT_ACTIONFLT1EN_FW_8822B BIT(1)
+#define BIT_ACTIONFLT0EN_FW_8822B BIT(0)
+
+/* 2 REG_RXFLTMAP5_8822B (RX FILTER MAP GROUP 3) */
+#define BIT_DATAFLT15EN_FW_8822B BIT(15)
+#define BIT_DATAFLT14EN_FW_8822B BIT(14)
+#define BIT_DATAFLT13EN_FW_8822B BIT(13)
+#define BIT_DATAFLT12EN_FW_8822B BIT(12)
+#define BIT_DATAFLT11EN_FW_8822B BIT(11)
+#define BIT_DATAFLT10EN_FW_8822B BIT(10)
+#define BIT_DATAFLT9EN_FW_8822B BIT(9)
+#define BIT_DATAFLT8EN_FW_8822B BIT(8)
+#define BIT_DATAFLT7EN_FW_8822B BIT(7)
+#define BIT_DATAFLT6EN_FW_8822B BIT(6)
+#define BIT_DATAFLT5EN_FW_8822B BIT(5)
+#define BIT_DATAFLT4EN_FW_8822B BIT(4)
+#define BIT_DATAFLT3EN_FW_8822B BIT(3)
+#define BIT_DATAFLT2EN_FW_8822B BIT(2)
+#define BIT_DATAFLT1EN_FW_8822B BIT(1)
+#define BIT_DATAFLT0EN_FW_8822B BIT(0)
+
+/* 2 REG_WMMPS_UAPSD_TID_8822B (WMM POWER SAVE UAPSD TID REGISTER) */
+#define BIT_WMMPS_UAPSD_TID7_8822B BIT(7)
+#define BIT_WMMPS_UAPSD_TID6_8822B BIT(6)
+#define BIT_WMMPS_UAPSD_TID5_8822B BIT(5)
+#define BIT_WMMPS_UAPSD_TID4_8822B BIT(4)
+#define BIT_WMMPS_UAPSD_TID3_8822B BIT(3)
+#define BIT_WMMPS_UAPSD_TID2_8822B BIT(2)
+#define BIT_WMMPS_UAPSD_TID1_8822B BIT(1)
+#define BIT_WMMPS_UAPSD_TID0_8822B BIT(0)
+
+/* 2 REG_PS_RX_INFO_8822B (POWER SAVE RX INFORMATION REGISTER) */
+
+#define BIT_SHIFT_PORTSEL__PS_RX_INFO_8822B 5
+#define BIT_MASK_PORTSEL__PS_RX_INFO_8822B 0x7
+#define BIT_PORTSEL__PS_RX_INFO_8822B(x)                                       \
+	(((x) & BIT_MASK_PORTSEL__PS_RX_INFO_8822B)                            \
+	 << BIT_SHIFT_PORTSEL__PS_RX_INFO_8822B)
+#define BIT_GET_PORTSEL__PS_RX_INFO_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_PORTSEL__PS_RX_INFO_8822B) &                        \
+	 BIT_MASK_PORTSEL__PS_RX_INFO_8822B)
+
+#define BIT_RXCTRLIN0_8822B BIT(4)
+#define BIT_RXMGTIN0_8822B BIT(3)
+#define BIT_RXDATAIN2_8822B BIT(2)
+#define BIT_RXDATAIN1_8822B BIT(1)
+#define BIT_RXDATAIN0_8822B BIT(0)
+
+/* 2 REG_NAN_RX_TSF_FILTER_8822B(NAN_RX_TSF_ADDRESS_FILTER) */
+#define BIT_CHK_TSF_TA_8822B BIT(2)
+#define BIT_CHK_TSF_CBSSID_8822B BIT(1)
+#define BIT_CHK_TSF_EN_8822B BIT(0)
+
+/* 2 REG_WOW_CTRL_8822B (WAKE ON WLAN CONTROL REGISTER) */
+
+#define BIT_SHIFT_PSF_BSSIDSEL_B2B1_8822B 6
+#define BIT_MASK_PSF_BSSIDSEL_B2B1_8822B 0x3
+#define BIT_PSF_BSSIDSEL_B2B1_8822B(x)                                         \
+	(((x) & BIT_MASK_PSF_BSSIDSEL_B2B1_8822B)                              \
+	 << BIT_SHIFT_PSF_BSSIDSEL_B2B1_8822B)
+#define BIT_GET_PSF_BSSIDSEL_B2B1_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_PSF_BSSIDSEL_B2B1_8822B) &                          \
+	 BIT_MASK_PSF_BSSIDSEL_B2B1_8822B)
+
+#define BIT_WOWHCI_8822B BIT(5)
+#define BIT_PSF_BSSIDSEL_B0_8822B BIT(4)
+#define BIT_UWF_8822B BIT(3)
+#define BIT_MAGIC_8822B BIT(2)
+#define BIT_WOWEN_8822B BIT(1)
+#define BIT_FORCE_WAKEUP_8822B BIT(0)
+
+/* 2 REG_LPNAV_CTRL_8822B (LOW POWER NAV CONTROL REGISTER) */
+#define BIT_LPNAV_EN_8822B BIT(31)
+
+#define BIT_SHIFT_LPNAV_EARLY_8822B 16
+#define BIT_MASK_LPNAV_EARLY_8822B 0x7fff
+#define BIT_LPNAV_EARLY_8822B(x)                                               \
+	(((x) & BIT_MASK_LPNAV_EARLY_8822B) << BIT_SHIFT_LPNAV_EARLY_8822B)
+#define BIT_GET_LPNAV_EARLY_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_LPNAV_EARLY_8822B) & BIT_MASK_LPNAV_EARLY_8822B)
+
+#define BIT_SHIFT_LPNAV_TH_8822B 0
+#define BIT_MASK_LPNAV_TH_8822B 0xffff
+#define BIT_LPNAV_TH_8822B(x)                                                  \
+	(((x) & BIT_MASK_LPNAV_TH_8822B) << BIT_SHIFT_LPNAV_TH_8822B)
+#define BIT_GET_LPNAV_TH_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_LPNAV_TH_8822B) & BIT_MASK_LPNAV_TH_8822B)
+
+/* 2 REG_WKFMCAM_CMD_8822B (WAKEUP FRAME CAM COMMAND REGISTER) */
+#define BIT_WKFCAM_POLLING_V1_8822B BIT(31)
+#define BIT_WKFCAM_CLR_V1_8822B BIT(30)
+#define BIT_WKFCAM_WE_8822B BIT(16)
+
+#define BIT_SHIFT_WKFCAM_ADDR_V2_8822B 8
+#define BIT_MASK_WKFCAM_ADDR_V2_8822B 0xff
+#define BIT_WKFCAM_ADDR_V2_8822B(x)                                            \
+	(((x) & BIT_MASK_WKFCAM_ADDR_V2_8822B)                                 \
+	 << BIT_SHIFT_WKFCAM_ADDR_V2_8822B)
+#define BIT_GET_WKFCAM_ADDR_V2_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_WKFCAM_ADDR_V2_8822B) &                             \
+	 BIT_MASK_WKFCAM_ADDR_V2_8822B)
+
+#define BIT_SHIFT_WKFCAM_CAM_NUM_V1_8822B 0
+#define BIT_MASK_WKFCAM_CAM_NUM_V1_8822B 0xff
+#define BIT_WKFCAM_CAM_NUM_V1_8822B(x)                                         \
+	(((x) & BIT_MASK_WKFCAM_CAM_NUM_V1_8822B)                              \
+	 << BIT_SHIFT_WKFCAM_CAM_NUM_V1_8822B)
+#define BIT_GET_WKFCAM_CAM_NUM_V1_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_WKFCAM_CAM_NUM_V1_8822B) &                          \
+	 BIT_MASK_WKFCAM_CAM_NUM_V1_8822B)
+
+/* 2 REG_WKFMCAM_RWD_8822B (WAKEUP FRAME READ/WRITE DATA) */
+
+#define BIT_SHIFT_WKFMCAM_RWD_8822B 0
+#define BIT_MASK_WKFMCAM_RWD_8822B 0xffffffffL
+#define BIT_WKFMCAM_RWD_8822B(x)                                               \
+	(((x) & BIT_MASK_WKFMCAM_RWD_8822B) << BIT_SHIFT_WKFMCAM_RWD_8822B)
+#define BIT_GET_WKFMCAM_RWD_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_WKFMCAM_RWD_8822B) & BIT_MASK_WKFMCAM_RWD_8822B)
+
+/* 2 REG_RXFLTMAP1_8822B (RX FILTER MAP GROUP 1) */
+#define BIT_CTRLFLT15EN_8822B BIT(15)
+#define BIT_CTRLFLT14EN_8822B BIT(14)
+#define BIT_CTRLFLT13EN_8822B BIT(13)
+#define BIT_CTRLFLT12EN_8822B BIT(12)
+#define BIT_CTRLFLT11EN_8822B BIT(11)
+#define BIT_CTRLFLT10EN_8822B BIT(10)
+#define BIT_CTRLFLT9EN_8822B BIT(9)
+#define BIT_CTRLFLT8EN_8822B BIT(8)
+#define BIT_CTRLFLT7EN_8822B BIT(7)
+#define BIT_CTRLFLT6EN_8822B BIT(6)
+#define BIT_CTRLFLT5EN_8822B BIT(5)
+#define BIT_CTRLFLT4EN_8822B BIT(4)
+#define BIT_CTRLFLT3EN_8822B BIT(3)
+#define BIT_CTRLFLT2EN_8822B BIT(2)
+#define BIT_CTRLFLT1EN_8822B BIT(1)
+#define BIT_CTRLFLT0EN_8822B BIT(0)
+
+/* 2 REG_RXFLTMAP0_8822B (RX FILTER MAP GROUP 0) */
+#define BIT_MGTFLT15EN_8822B BIT(15)
+#define BIT_MGTFLT14EN_8822B BIT(14)
+#define BIT_MGTFLT13EN_8822B BIT(13)
+#define BIT_MGTFLT12EN_8822B BIT(12)
+#define BIT_MGTFLT11EN_8822B BIT(11)
+#define BIT_MGTFLT10EN_8822B BIT(10)
+#define BIT_MGTFLT9EN_8822B BIT(9)
+#define BIT_MGTFLT8EN_8822B BIT(8)
+#define BIT_MGTFLT7EN_8822B BIT(7)
+#define BIT_MGTFLT6EN_8822B BIT(6)
+#define BIT_MGTFLT5EN_8822B BIT(5)
+#define BIT_MGTFLT4EN_8822B BIT(4)
+#define BIT_MGTFLT3EN_8822B BIT(3)
+#define BIT_MGTFLT2EN_8822B BIT(2)
+#define BIT_MGTFLT1EN_8822B BIT(1)
+#define BIT_MGTFLT0EN_8822B BIT(0)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_RXFLTMAP_8822B (RX FILTER MAP GROUP 2) */
+#define BIT_DATAFLT15EN_8822B BIT(15)
+#define BIT_DATAFLT14EN_8822B BIT(14)
+#define BIT_DATAFLT13EN_8822B BIT(13)
+#define BIT_DATAFLT12EN_8822B BIT(12)
+#define BIT_DATAFLT11EN_8822B BIT(11)
+#define BIT_DATAFLT10EN_8822B BIT(10)
+#define BIT_DATAFLT9EN_8822B BIT(9)
+#define BIT_DATAFLT8EN_8822B BIT(8)
+#define BIT_DATAFLT7EN_8822B BIT(7)
+#define BIT_DATAFLT6EN_8822B BIT(6)
+#define BIT_DATAFLT5EN_8822B BIT(5)
+#define BIT_DATAFLT4EN_8822B BIT(4)
+#define BIT_DATAFLT3EN_8822B BIT(3)
+#define BIT_DATAFLT2EN_8822B BIT(2)
+#define BIT_DATAFLT1EN_8822B BIT(1)
+#define BIT_DATAFLT0EN_8822B BIT(0)
+
+/* 2 REG_BCN_PSR_RPT_8822B (BEACON PARSER REPORT REGISTER) */
+
+#define BIT_SHIFT_DTIM_CNT_8822B 24
+#define BIT_MASK_DTIM_CNT_8822B 0xff
+#define BIT_DTIM_CNT_8822B(x)                                                  \
+	(((x) & BIT_MASK_DTIM_CNT_8822B) << BIT_SHIFT_DTIM_CNT_8822B)
+#define BIT_GET_DTIM_CNT_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_DTIM_CNT_8822B) & BIT_MASK_DTIM_CNT_8822B)
+
+#define BIT_SHIFT_DTIM_PERIOD_8822B 16
+#define BIT_MASK_DTIM_PERIOD_8822B 0xff
+#define BIT_DTIM_PERIOD_8822B(x)                                               \
+	(((x) & BIT_MASK_DTIM_PERIOD_8822B) << BIT_SHIFT_DTIM_PERIOD_8822B)
+#define BIT_GET_DTIM_PERIOD_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_DTIM_PERIOD_8822B) & BIT_MASK_DTIM_PERIOD_8822B)
+
+#define BIT_DTIM_8822B BIT(15)
+#define BIT_TIM_8822B BIT(14)
+
+#define BIT_SHIFT_PS_AID_0_8822B 0
+#define BIT_MASK_PS_AID_0_8822B 0x7ff
+#define BIT_PS_AID_0_8822B(x)                                                  \
+	(((x) & BIT_MASK_PS_AID_0_8822B) << BIT_SHIFT_PS_AID_0_8822B)
+#define BIT_GET_PS_AID_0_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_PS_AID_0_8822B) & BIT_MASK_PS_AID_0_8822B)
+
+/* 2 REG_FLC_TRPC_8822B (TIMER OF FLC_RPC) */
+#define BIT_FLC_RPCT_V1_8822B BIT(7)
+#define BIT_MODE_8822B BIT(6)
+
+#define BIT_SHIFT_TRPCD_8822B 0
+#define BIT_MASK_TRPCD_8822B 0x3f
+#define BIT_TRPCD_8822B(x)                                                     \
+	(((x) & BIT_MASK_TRPCD_8822B) << BIT_SHIFT_TRPCD_8822B)
+#define BIT_GET_TRPCD_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_TRPCD_8822B) & BIT_MASK_TRPCD_8822B)
+
+/* 2 REG_FLC_PTS_8822B (PKT TYPE SELECTION OF FLC_RPC T) */
+#define BIT_CMF_8822B BIT(2)
+#define BIT_CCF_8822B BIT(1)
+#define BIT_CDF_8822B BIT(0)
+
+/* 2 REG_FLC_RPCT_8822B (FLC_RPC THRESHOLD) */
+
+#define BIT_SHIFT_FLC_RPCT_8822B 0
+#define BIT_MASK_FLC_RPCT_8822B 0xff
+#define BIT_FLC_RPCT_8822B(x)                                                  \
+	(((x) & BIT_MASK_FLC_RPCT_8822B) << BIT_SHIFT_FLC_RPCT_8822B)
+#define BIT_GET_FLC_RPCT_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_FLC_RPCT_8822B) & BIT_MASK_FLC_RPCT_8822B)
+
+/* 2 REG_FLC_RPC_8822B (FW LPS CONDITION -- RX PKT COUNTER) */
+
+#define BIT_SHIFT_FLC_RPC_8822B 0
+#define BIT_MASK_FLC_RPC_8822B 0xff
+#define BIT_FLC_RPC_8822B(x)                                                   \
+	(((x) & BIT_MASK_FLC_RPC_8822B) << BIT_SHIFT_FLC_RPC_8822B)
+#define BIT_GET_FLC_RPC_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_FLC_RPC_8822B) & BIT_MASK_FLC_RPC_8822B)
+
+/* 2 REG_RXPKTMON_CTRL_8822B */
+
+#define BIT_SHIFT_RXBKQPKT_SEQ_8822B 20
+#define BIT_MASK_RXBKQPKT_SEQ_8822B 0xf
+#define BIT_RXBKQPKT_SEQ_8822B(x)                                              \
+	(((x) & BIT_MASK_RXBKQPKT_SEQ_8822B) << BIT_SHIFT_RXBKQPKT_SEQ_8822B)
+#define BIT_GET_RXBKQPKT_SEQ_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_RXBKQPKT_SEQ_8822B) & BIT_MASK_RXBKQPKT_SEQ_8822B)
+
+#define BIT_SHIFT_RXBEQPKT_SEQ_8822B 16
+#define BIT_MASK_RXBEQPKT_SEQ_8822B 0xf
+#define BIT_RXBEQPKT_SEQ_8822B(x)                                              \
+	(((x) & BIT_MASK_RXBEQPKT_SEQ_8822B) << BIT_SHIFT_RXBEQPKT_SEQ_8822B)
+#define BIT_GET_RXBEQPKT_SEQ_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_RXBEQPKT_SEQ_8822B) & BIT_MASK_RXBEQPKT_SEQ_8822B)
+
+#define BIT_SHIFT_RXVIQPKT_SEQ_8822B 12
+#define BIT_MASK_RXVIQPKT_SEQ_8822B 0xf
+#define BIT_RXVIQPKT_SEQ_8822B(x)                                              \
+	(((x) & BIT_MASK_RXVIQPKT_SEQ_8822B) << BIT_SHIFT_RXVIQPKT_SEQ_8822B)
+#define BIT_GET_RXVIQPKT_SEQ_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_RXVIQPKT_SEQ_8822B) & BIT_MASK_RXVIQPKT_SEQ_8822B)
+
+#define BIT_SHIFT_RXVOQPKT_SEQ_8822B 8
+#define BIT_MASK_RXVOQPKT_SEQ_8822B 0xf
+#define BIT_RXVOQPKT_SEQ_8822B(x)                                              \
+	(((x) & BIT_MASK_RXVOQPKT_SEQ_8822B) << BIT_SHIFT_RXVOQPKT_SEQ_8822B)
+#define BIT_GET_RXVOQPKT_SEQ_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_RXVOQPKT_SEQ_8822B) & BIT_MASK_RXVOQPKT_SEQ_8822B)
+
+#define BIT_RXBKQPKT_ERR_8822B BIT(7)
+#define BIT_RXBEQPKT_ERR_8822B BIT(6)
+#define BIT_RXVIQPKT_ERR_8822B BIT(5)
+#define BIT_RXVOQPKT_ERR_8822B BIT(4)
+#define BIT_RXDMA_MON_EN_8822B BIT(2)
+#define BIT_RXPKT_MON_RST_8822B BIT(1)
+#define BIT_RXPKT_MON_EN_8822B BIT(0)
+
+/* 2 REG_STATE_MON_8822B */
+
+#define BIT_SHIFT_STATE_SEL_8822B 24
+#define BIT_MASK_STATE_SEL_8822B 0x1f
+#define BIT_STATE_SEL_8822B(x)                                                 \
+	(((x) & BIT_MASK_STATE_SEL_8822B) << BIT_SHIFT_STATE_SEL_8822B)
+#define BIT_GET_STATE_SEL_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_STATE_SEL_8822B) & BIT_MASK_STATE_SEL_8822B)
+
+#define BIT_SHIFT_STATE_INFO_8822B 8
+#define BIT_MASK_STATE_INFO_8822B 0xff
+#define BIT_STATE_INFO_8822B(x)                                                \
+	(((x) & BIT_MASK_STATE_INFO_8822B) << BIT_SHIFT_STATE_INFO_8822B)
+#define BIT_GET_STATE_INFO_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_STATE_INFO_8822B) & BIT_MASK_STATE_INFO_8822B)
+
+#define BIT_UPD_NXT_STATE_8822B BIT(7)
+
+#define BIT_SHIFT_CUR_STATE_8822B 0
+#define BIT_MASK_CUR_STATE_8822B 0x7f
+#define BIT_CUR_STATE_8822B(x)                                                 \
+	(((x) & BIT_MASK_CUR_STATE_8822B) << BIT_SHIFT_CUR_STATE_8822B)
+#define BIT_GET_CUR_STATE_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_CUR_STATE_8822B) & BIT_MASK_CUR_STATE_8822B)
+
+/* 2 REG_ERROR_MON_8822B */
+#define BIT_MACRX_ERR_1_8822B BIT(17)
+#define BIT_MACRX_ERR_0_8822B BIT(16)
+#define BIT_MACTX_ERR_3_8822B BIT(3)
+#define BIT_MACTX_ERR_2_8822B BIT(2)
+#define BIT_MACTX_ERR_1_8822B BIT(1)
+#define BIT_MACTX_ERR_0_8822B BIT(0)
+
+/* 2 REG_SEARCH_MACID_8822B */
+#define BIT_EN_TXRPTBUF_CLK_8822B BIT(31)
+
+#define BIT_SHIFT_INFO_INDEX_OFFSET_8822B 16
+#define BIT_MASK_INFO_INDEX_OFFSET_8822B 0x1fff
+#define BIT_INFO_INDEX_OFFSET_8822B(x)                                         \
+	(((x) & BIT_MASK_INFO_INDEX_OFFSET_8822B)                              \
+	 << BIT_SHIFT_INFO_INDEX_OFFSET_8822B)
+#define BIT_GET_INFO_INDEX_OFFSET_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_INFO_INDEX_OFFSET_8822B) &                          \
+	 BIT_MASK_INFO_INDEX_OFFSET_8822B)
+
+#define BIT_WMAC_SRCH_FIFOFULL_8822B BIT(15)
+#define BIT_DIS_INFOSRCH_8822B BIT(14)
+#define BIT_DISABLE_B0_8822B BIT(13)
+
+#define BIT_SHIFT_INFO_ADDR_OFFSET_8822B 0
+#define BIT_MASK_INFO_ADDR_OFFSET_8822B 0x1fff
+#define BIT_INFO_ADDR_OFFSET_8822B(x)                                          \
+	(((x) & BIT_MASK_INFO_ADDR_OFFSET_8822B)                               \
+	 << BIT_SHIFT_INFO_ADDR_OFFSET_8822B)
+#define BIT_GET_INFO_ADDR_OFFSET_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_INFO_ADDR_OFFSET_8822B) &                           \
+	 BIT_MASK_INFO_ADDR_OFFSET_8822B)
+
+/* 2 REG_BT_COEX_TABLE_8822B (BT-COEXISTENCE CONTROL REGISTER) */
+#define BIT_PRI_MASK_RX_RESP_8822B BIT(126)
+#define BIT_PRI_MASK_RXOFDM_8822B BIT(125)
+#define BIT_PRI_MASK_RXCCK_8822B BIT(124)
+
+#define BIT_SHIFT_PRI_MASK_TXAC_8822B (117 & CPU_OPT_WIDTH)
+#define BIT_MASK_PRI_MASK_TXAC_8822B 0x7f
+#define BIT_PRI_MASK_TXAC_8822B(x)                                             \
+	(((x) & BIT_MASK_PRI_MASK_TXAC_8822B) << BIT_SHIFT_PRI_MASK_TXAC_8822B)
+#define BIT_GET_PRI_MASK_TXAC_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_PRI_MASK_TXAC_8822B) & BIT_MASK_PRI_MASK_TXAC_8822B)
+
+#define BIT_SHIFT_PRI_MASK_NAV_8822B (109 & CPU_OPT_WIDTH)
+#define BIT_MASK_PRI_MASK_NAV_8822B 0xff
+#define BIT_PRI_MASK_NAV_8822B(x)                                              \
+	(((x) & BIT_MASK_PRI_MASK_NAV_8822B) << BIT_SHIFT_PRI_MASK_NAV_8822B)
+#define BIT_GET_PRI_MASK_NAV_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_PRI_MASK_NAV_8822B) & BIT_MASK_PRI_MASK_NAV_8822B)
+
+#define BIT_PRI_MASK_CCK_8822B BIT(108)
+#define BIT_PRI_MASK_OFDM_8822B BIT(107)
+#define BIT_PRI_MASK_RTY_8822B BIT(106)
+
+#define BIT_SHIFT_PRI_MASK_NUM_8822B (102 & CPU_OPT_WIDTH)
+#define BIT_MASK_PRI_MASK_NUM_8822B 0xf
+#define BIT_PRI_MASK_NUM_8822B(x)                                              \
+	(((x) & BIT_MASK_PRI_MASK_NUM_8822B) << BIT_SHIFT_PRI_MASK_NUM_8822B)
+#define BIT_GET_PRI_MASK_NUM_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_PRI_MASK_NUM_8822B) & BIT_MASK_PRI_MASK_NUM_8822B)
+
+#define BIT_SHIFT_PRI_MASK_TYPE_8822B (98 & CPU_OPT_WIDTH)
+#define BIT_MASK_PRI_MASK_TYPE_8822B 0xf
+#define BIT_PRI_MASK_TYPE_8822B(x)                                             \
+	(((x) & BIT_MASK_PRI_MASK_TYPE_8822B) << BIT_SHIFT_PRI_MASK_TYPE_8822B)
+#define BIT_GET_PRI_MASK_TYPE_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_PRI_MASK_TYPE_8822B) & BIT_MASK_PRI_MASK_TYPE_8822B)
+
+#define BIT_OOB_8822B BIT(97)
+#define BIT_ANT_SEL_8822B BIT(96)
+
+#define BIT_SHIFT_BREAK_TABLE_2_8822B (80 & CPU_OPT_WIDTH)
+#define BIT_MASK_BREAK_TABLE_2_8822B 0xffff
+#define BIT_BREAK_TABLE_2_8822B(x)                                             \
+	(((x) & BIT_MASK_BREAK_TABLE_2_8822B) << BIT_SHIFT_BREAK_TABLE_2_8822B)
+#define BIT_GET_BREAK_TABLE_2_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_BREAK_TABLE_2_8822B) & BIT_MASK_BREAK_TABLE_2_8822B)
+
+#define BIT_SHIFT_BREAK_TABLE_1_8822B (64 & CPU_OPT_WIDTH)
+#define BIT_MASK_BREAK_TABLE_1_8822B 0xffff
+#define BIT_BREAK_TABLE_1_8822B(x)                                             \
+	(((x) & BIT_MASK_BREAK_TABLE_1_8822B) << BIT_SHIFT_BREAK_TABLE_1_8822B)
+#define BIT_GET_BREAK_TABLE_1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_BREAK_TABLE_1_8822B) & BIT_MASK_BREAK_TABLE_1_8822B)
+
+#define BIT_SHIFT_COEX_TABLE_2_8822B (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_COEX_TABLE_2_8822B 0xffffffffL
+#define BIT_COEX_TABLE_2_8822B(x)                                              \
+	(((x) & BIT_MASK_COEX_TABLE_2_8822B) << BIT_SHIFT_COEX_TABLE_2_8822B)
+#define BIT_GET_COEX_TABLE_2_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_COEX_TABLE_2_8822B) & BIT_MASK_COEX_TABLE_2_8822B)
+
+#define BIT_SHIFT_COEX_TABLE_1_8822B 0
+#define BIT_MASK_COEX_TABLE_1_8822B 0xffffffffL
+#define BIT_COEX_TABLE_1_8822B(x)                                              \
+	(((x) & BIT_MASK_COEX_TABLE_1_8822B) << BIT_SHIFT_COEX_TABLE_1_8822B)
+#define BIT_GET_COEX_TABLE_1_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_COEX_TABLE_1_8822B) & BIT_MASK_COEX_TABLE_1_8822B)
+
+/* 2 REG_RXCMD_0_8822B */
+#define BIT_RXCMD_EN_8822B BIT(31)
+
+#define BIT_SHIFT_RXCMD_INFO_8822B 0
+#define BIT_MASK_RXCMD_INFO_8822B 0x7fffffffL
+#define BIT_RXCMD_INFO_8822B(x)                                                \
+	(((x) & BIT_MASK_RXCMD_INFO_8822B) << BIT_SHIFT_RXCMD_INFO_8822B)
+#define BIT_GET_RXCMD_INFO_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_RXCMD_INFO_8822B) & BIT_MASK_RXCMD_INFO_8822B)
+
+/* 2 REG_RXCMD_1_8822B */
+
+#define BIT_SHIFT_RXCMD_PRD_8822B 0
+#define BIT_MASK_RXCMD_PRD_8822B 0xffff
+#define BIT_RXCMD_PRD_8822B(x)                                                 \
+	(((x) & BIT_MASK_RXCMD_PRD_8822B) << BIT_SHIFT_RXCMD_PRD_8822B)
+#define BIT_GET_RXCMD_PRD_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_RXCMD_PRD_8822B) & BIT_MASK_RXCMD_PRD_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_WMAC_RESP_TXINFO_8822B (RESPONSE TXINFO REGISTER) */
+
+#define BIT_SHIFT_WMAC_RESP_MFB_8822B 25
+#define BIT_MASK_WMAC_RESP_MFB_8822B 0x7f
+#define BIT_WMAC_RESP_MFB_8822B(x)                                             \
+	(((x) & BIT_MASK_WMAC_RESP_MFB_8822B) << BIT_SHIFT_WMAC_RESP_MFB_8822B)
+#define BIT_GET_WMAC_RESP_MFB_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_WMAC_RESP_MFB_8822B) & BIT_MASK_WMAC_RESP_MFB_8822B)
+
+#define BIT_SHIFT_WMAC_ANTINF_SEL_8822B 23
+#define BIT_MASK_WMAC_ANTINF_SEL_8822B 0x3
+#define BIT_WMAC_ANTINF_SEL_8822B(x)                                           \
+	(((x) & BIT_MASK_WMAC_ANTINF_SEL_8822B)                                \
+	 << BIT_SHIFT_WMAC_ANTINF_SEL_8822B)
+#define BIT_GET_WMAC_ANTINF_SEL_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_WMAC_ANTINF_SEL_8822B) &                            \
+	 BIT_MASK_WMAC_ANTINF_SEL_8822B)
+
+#define BIT_SHIFT_WMAC_ANTSEL_SEL_8822B 21
+#define BIT_MASK_WMAC_ANTSEL_SEL_8822B 0x3
+#define BIT_WMAC_ANTSEL_SEL_8822B(x)                                           \
+	(((x) & BIT_MASK_WMAC_ANTSEL_SEL_8822B)                                \
+	 << BIT_SHIFT_WMAC_ANTSEL_SEL_8822B)
+#define BIT_GET_WMAC_ANTSEL_SEL_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_WMAC_ANTSEL_SEL_8822B) &                            \
+	 BIT_MASK_WMAC_ANTSEL_SEL_8822B)
+
+#define BIT_SHIFT_R_WMAC_RESP_TXPOWER_8822B 18
+#define BIT_MASK_R_WMAC_RESP_TXPOWER_8822B 0x7
+#define BIT_R_WMAC_RESP_TXPOWER_8822B(x)                                       \
+	(((x) & BIT_MASK_R_WMAC_RESP_TXPOWER_8822B)                            \
+	 << BIT_SHIFT_R_WMAC_RESP_TXPOWER_8822B)
+#define BIT_GET_R_WMAC_RESP_TXPOWER_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_R_WMAC_RESP_TXPOWER_8822B) &                        \
+	 BIT_MASK_R_WMAC_RESP_TXPOWER_8822B)
+
+#define BIT_SHIFT_WMAC_RESP_TXANT_8822B 0
+#define BIT_MASK_WMAC_RESP_TXANT_8822B 0x3ffff
+#define BIT_WMAC_RESP_TXANT_8822B(x)                                           \
+	(((x) & BIT_MASK_WMAC_RESP_TXANT_8822B)                                \
+	 << BIT_SHIFT_WMAC_RESP_TXANT_8822B)
+#define BIT_GET_WMAC_RESP_TXANT_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_WMAC_RESP_TXANT_8822B) &                            \
+	 BIT_MASK_WMAC_RESP_TXANT_8822B)
+
+/* 2 REG_BBPSF_CTRL_8822B */
+#define BIT_CTL_IDLE_CLR_CSI_RPT_8822B BIT(31)
+#define BIT_WMAC_USE_NDPARATE_8822B BIT(30)
+
+#define BIT_SHIFT_WMAC_CSI_RATE_8822B 24
+#define BIT_MASK_WMAC_CSI_RATE_8822B 0x3f
+#define BIT_WMAC_CSI_RATE_8822B(x)                                             \
+	(((x) & BIT_MASK_WMAC_CSI_RATE_8822B) << BIT_SHIFT_WMAC_CSI_RATE_8822B)
+#define BIT_GET_WMAC_CSI_RATE_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_WMAC_CSI_RATE_8822B) & BIT_MASK_WMAC_CSI_RATE_8822B)
+
+#define BIT_SHIFT_WMAC_RESP_TXRATE_8822B 16
+#define BIT_MASK_WMAC_RESP_TXRATE_8822B 0xff
+#define BIT_WMAC_RESP_TXRATE_8822B(x)                                          \
+	(((x) & BIT_MASK_WMAC_RESP_TXRATE_8822B)                               \
+	 << BIT_SHIFT_WMAC_RESP_TXRATE_8822B)
+#define BIT_GET_WMAC_RESP_TXRATE_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_WMAC_RESP_TXRATE_8822B) &                           \
+	 BIT_MASK_WMAC_RESP_TXRATE_8822B)
+
+#define BIT_BBPSF_MPDUCHKEN_8822B BIT(5)
+#define BIT_BBPSF_MHCHKEN_8822B BIT(4)
+#define BIT_BBPSF_ERRCHKEN_8822B BIT(3)
+
+#define BIT_SHIFT_BBPSF_ERRTHR_8822B 0
+#define BIT_MASK_BBPSF_ERRTHR_8822B 0x7
+#define BIT_BBPSF_ERRTHR_8822B(x)                                              \
+	(((x) & BIT_MASK_BBPSF_ERRTHR_8822B) << BIT_SHIFT_BBPSF_ERRTHR_8822B)
+#define BIT_GET_BBPSF_ERRTHR_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_BBPSF_ERRTHR_8822B) & BIT_MASK_BBPSF_ERRTHR_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_P2P_RX_BCN_NOA_8822B (P2P RX BEACON NOA REGISTER) */
+#define BIT_NOA_PARSER_EN_8822B BIT(15)
+#define BIT_BSSID_SEL_8822B BIT(14)
+
+#define BIT_SHIFT_P2P_OUI_TYPE_8822B 0
+#define BIT_MASK_P2P_OUI_TYPE_8822B 0xff
+#define BIT_P2P_OUI_TYPE_8822B(x)                                              \
+	(((x) & BIT_MASK_P2P_OUI_TYPE_8822B) << BIT_SHIFT_P2P_OUI_TYPE_8822B)
+#define BIT_GET_P2P_OUI_TYPE_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_P2P_OUI_TYPE_8822B) & BIT_MASK_P2P_OUI_TYPE_8822B)
+
+/* 2 REG_ASSOCIATED_BFMER0_INFO_8822B (ASSOCIATED BEAMFORMER0 INFO REGISTER) */
+
+#define BIT_SHIFT_R_WMAC_TXCSI_AID0_8822B (48 & CPU_OPT_WIDTH)
+#define BIT_MASK_R_WMAC_TXCSI_AID0_8822B 0x1ff
+#define BIT_R_WMAC_TXCSI_AID0_8822B(x)                                         \
+	(((x) & BIT_MASK_R_WMAC_TXCSI_AID0_8822B)                              \
+	 << BIT_SHIFT_R_WMAC_TXCSI_AID0_8822B)
+#define BIT_GET_R_WMAC_TXCSI_AID0_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_R_WMAC_TXCSI_AID0_8822B) &                          \
+	 BIT_MASK_R_WMAC_TXCSI_AID0_8822B)
+
+#define BIT_SHIFT_R_WMAC_SOUNDING_RXADD_R0_8822B 0
+#define BIT_MASK_R_WMAC_SOUNDING_RXADD_R0_8822B 0xffffffffffffL
+#define BIT_R_WMAC_SOUNDING_RXADD_R0_8822B(x)                                  \
+	(((x) & BIT_MASK_R_WMAC_SOUNDING_RXADD_R0_8822B)                       \
+	 << BIT_SHIFT_R_WMAC_SOUNDING_RXADD_R0_8822B)
+#define BIT_GET_R_WMAC_SOUNDING_RXADD_R0_8822B(x)                              \
+	(((x) >> BIT_SHIFT_R_WMAC_SOUNDING_RXADD_R0_8822B) &                   \
+	 BIT_MASK_R_WMAC_SOUNDING_RXADD_R0_8822B)
+
+/* 2 REG_ASSOCIATED_BFMER1_INFO_8822B (ASSOCIATED BEAMFORMER1 INFO REGISTER) */
+
+#define BIT_SHIFT_R_WMAC_TXCSI_AID1_8822B (48 & CPU_OPT_WIDTH)
+#define BIT_MASK_R_WMAC_TXCSI_AID1_8822B 0x1ff
+#define BIT_R_WMAC_TXCSI_AID1_8822B(x)                                         \
+	(((x) & BIT_MASK_R_WMAC_TXCSI_AID1_8822B)                              \
+	 << BIT_SHIFT_R_WMAC_TXCSI_AID1_8822B)
+#define BIT_GET_R_WMAC_TXCSI_AID1_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_R_WMAC_TXCSI_AID1_8822B) &                          \
+	 BIT_MASK_R_WMAC_TXCSI_AID1_8822B)
+
+#define BIT_SHIFT_R_WMAC_SOUNDING_RXADD_R1_8822B 0
+#define BIT_MASK_R_WMAC_SOUNDING_RXADD_R1_8822B 0xffffffffffffL
+#define BIT_R_WMAC_SOUNDING_RXADD_R1_8822B(x)                                  \
+	(((x) & BIT_MASK_R_WMAC_SOUNDING_RXADD_R1_8822B)                       \
+	 << BIT_SHIFT_R_WMAC_SOUNDING_RXADD_R1_8822B)
+#define BIT_GET_R_WMAC_SOUNDING_RXADD_R1_8822B(x)                              \
+	(((x) >> BIT_SHIFT_R_WMAC_SOUNDING_RXADD_R1_8822B) &                   \
+	 BIT_MASK_R_WMAC_SOUNDING_RXADD_R1_8822B)
+
+/* 2 REG_TX_CSI_RPT_PARAM_BW20_8822B (TX CSI REPORT PARAMETER REGISTER) */
+
+#define BIT_SHIFT_R_WMAC_BFINFO_20M_1_8822B 16
+#define BIT_MASK_R_WMAC_BFINFO_20M_1_8822B 0xfff
+#define BIT_R_WMAC_BFINFO_20M_1_8822B(x)                                       \
+	(((x) & BIT_MASK_R_WMAC_BFINFO_20M_1_8822B)                            \
+	 << BIT_SHIFT_R_WMAC_BFINFO_20M_1_8822B)
+#define BIT_GET_R_WMAC_BFINFO_20M_1_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_R_WMAC_BFINFO_20M_1_8822B) &                        \
+	 BIT_MASK_R_WMAC_BFINFO_20M_1_8822B)
+
+#define BIT_SHIFT_R_WMAC_BFINFO_20M_0_8822B 0
+#define BIT_MASK_R_WMAC_BFINFO_20M_0_8822B 0xfff
+#define BIT_R_WMAC_BFINFO_20M_0_8822B(x)                                       \
+	(((x) & BIT_MASK_R_WMAC_BFINFO_20M_0_8822B)                            \
+	 << BIT_SHIFT_R_WMAC_BFINFO_20M_0_8822B)
+#define BIT_GET_R_WMAC_BFINFO_20M_0_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_R_WMAC_BFINFO_20M_0_8822B) &                        \
+	 BIT_MASK_R_WMAC_BFINFO_20M_0_8822B)
+
+/* 2 REG_TX_CSI_RPT_PARAM_BW40_8822B (TX CSI REPORT PARAMETER_BW40 REGISTER) */
+
+#define BIT_SHIFT_WMAC_RESP_ANTCD_8822B 0
+#define BIT_MASK_WMAC_RESP_ANTCD_8822B 0xf
+#define BIT_WMAC_RESP_ANTCD_8822B(x)                                           \
+	(((x) & BIT_MASK_WMAC_RESP_ANTCD_8822B)                                \
+	 << BIT_SHIFT_WMAC_RESP_ANTCD_8822B)
+#define BIT_GET_WMAC_RESP_ANTCD_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_WMAC_RESP_ANTCD_8822B) &                            \
+	 BIT_MASK_WMAC_RESP_ANTCD_8822B)
+
+/* 2 REG_TX_CSI_RPT_PARAM_BW80_8822B (TX CSI REPORT PARAMETER_BW80 REGISTER) */
+
+/* 2 REG_BCN_PSR_RPT2_8822B (BEACON PARSER REPORT REGISTER2) */
+
+#define BIT_SHIFT_DTIM_CNT2_8822B 24
+#define BIT_MASK_DTIM_CNT2_8822B 0xff
+#define BIT_DTIM_CNT2_8822B(x)                                                 \
+	(((x) & BIT_MASK_DTIM_CNT2_8822B) << BIT_SHIFT_DTIM_CNT2_8822B)
+#define BIT_GET_DTIM_CNT2_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_DTIM_CNT2_8822B) & BIT_MASK_DTIM_CNT2_8822B)
+
+#define BIT_SHIFT_DTIM_PERIOD2_8822B 16
+#define BIT_MASK_DTIM_PERIOD2_8822B 0xff
+#define BIT_DTIM_PERIOD2_8822B(x)                                              \
+	(((x) & BIT_MASK_DTIM_PERIOD2_8822B) << BIT_SHIFT_DTIM_PERIOD2_8822B)
+#define BIT_GET_DTIM_PERIOD2_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_DTIM_PERIOD2_8822B) & BIT_MASK_DTIM_PERIOD2_8822B)
+
+#define BIT_DTIM2_8822B BIT(15)
+#define BIT_TIM2_8822B BIT(14)
+
+#define BIT_SHIFT_PS_AID_2_8822B 0
+#define BIT_MASK_PS_AID_2_8822B 0x7ff
+#define BIT_PS_AID_2_8822B(x)                                                  \
+	(((x) & BIT_MASK_PS_AID_2_8822B) << BIT_SHIFT_PS_AID_2_8822B)
+#define BIT_GET_PS_AID_2_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_PS_AID_2_8822B) & BIT_MASK_PS_AID_2_8822B)
+
+/* 2 REG_BCN_PSR_RPT3_8822B (BEACON PARSER REPORT REGISTER3) */
+
+#define BIT_SHIFT_DTIM_CNT3_8822B 24
+#define BIT_MASK_DTIM_CNT3_8822B 0xff
+#define BIT_DTIM_CNT3_8822B(x)                                                 \
+	(((x) & BIT_MASK_DTIM_CNT3_8822B) << BIT_SHIFT_DTIM_CNT3_8822B)
+#define BIT_GET_DTIM_CNT3_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_DTIM_CNT3_8822B) & BIT_MASK_DTIM_CNT3_8822B)
+
+#define BIT_SHIFT_DTIM_PERIOD3_8822B 16
+#define BIT_MASK_DTIM_PERIOD3_8822B 0xff
+#define BIT_DTIM_PERIOD3_8822B(x)                                              \
+	(((x) & BIT_MASK_DTIM_PERIOD3_8822B) << BIT_SHIFT_DTIM_PERIOD3_8822B)
+#define BIT_GET_DTIM_PERIOD3_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_DTIM_PERIOD3_8822B) & BIT_MASK_DTIM_PERIOD3_8822B)
+
+#define BIT_DTIM3_8822B BIT(15)
+#define BIT_TIM3_8822B BIT(14)
+
+#define BIT_SHIFT_PS_AID_3_8822B 0
+#define BIT_MASK_PS_AID_3_8822B 0x7ff
+#define BIT_PS_AID_3_8822B(x)                                                  \
+	(((x) & BIT_MASK_PS_AID_3_8822B) << BIT_SHIFT_PS_AID_3_8822B)
+#define BIT_GET_PS_AID_3_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_PS_AID_3_8822B) & BIT_MASK_PS_AID_3_8822B)
+
+/* 2 REG_BCN_PSR_RPT4_8822B (BEACON PARSER REPORT REGISTER4) */
+
+#define BIT_SHIFT_DTIM_CNT4_8822B 24
+#define BIT_MASK_DTIM_CNT4_8822B 0xff
+#define BIT_DTIM_CNT4_8822B(x)                                                 \
+	(((x) & BIT_MASK_DTIM_CNT4_8822B) << BIT_SHIFT_DTIM_CNT4_8822B)
+#define BIT_GET_DTIM_CNT4_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_DTIM_CNT4_8822B) & BIT_MASK_DTIM_CNT4_8822B)
+
+#define BIT_SHIFT_DTIM_PERIOD4_8822B 16
+#define BIT_MASK_DTIM_PERIOD4_8822B 0xff
+#define BIT_DTIM_PERIOD4_8822B(x)                                              \
+	(((x) & BIT_MASK_DTIM_PERIOD4_8822B) << BIT_SHIFT_DTIM_PERIOD4_8822B)
+#define BIT_GET_DTIM_PERIOD4_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_DTIM_PERIOD4_8822B) & BIT_MASK_DTIM_PERIOD4_8822B)
+
+#define BIT_DTIM4_8822B BIT(15)
+#define BIT_TIM4_8822B BIT(14)
+
+#define BIT_SHIFT_PS_AID_4_8822B 0
+#define BIT_MASK_PS_AID_4_8822B 0x7ff
+#define BIT_PS_AID_4_8822B(x)                                                  \
+	(((x) & BIT_MASK_PS_AID_4_8822B) << BIT_SHIFT_PS_AID_4_8822B)
+#define BIT_GET_PS_AID_4_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_PS_AID_4_8822B) & BIT_MASK_PS_AID_4_8822B)
+
+/* 2 REG_A1_ADDR_MASK_8822B (A1 ADDR MASK REGISTER) */
+
+#define BIT_SHIFT_A1_ADDR_MASK_8822B 0
+#define BIT_MASK_A1_ADDR_MASK_8822B 0xffffffffL
+#define BIT_A1_ADDR_MASK_8822B(x)                                              \
+	(((x) & BIT_MASK_A1_ADDR_MASK_8822B) << BIT_SHIFT_A1_ADDR_MASK_8822B)
+#define BIT_GET_A1_ADDR_MASK_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_A1_ADDR_MASK_8822B) & BIT_MASK_A1_ADDR_MASK_8822B)
+
+/* 2 REG_MACID2_8822B (MAC ID2 REGISTER) */
+
+#define BIT_SHIFT_MACID2_8822B 0
+#define BIT_MASK_MACID2_8822B 0xffffffffffffL
+#define BIT_MACID2_8822B(x)                                                    \
+	(((x) & BIT_MASK_MACID2_8822B) << BIT_SHIFT_MACID2_8822B)
+#define BIT_GET_MACID2_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_MACID2_8822B) & BIT_MASK_MACID2_8822B)
+
+/* 2 REG_BSSID2_8822B (BSSID2 REGISTER) */
+
+#define BIT_SHIFT_BSSID2_8822B 0
+#define BIT_MASK_BSSID2_8822B 0xffffffffffffL
+#define BIT_BSSID2_8822B(x)                                                    \
+	(((x) & BIT_MASK_BSSID2_8822B) << BIT_SHIFT_BSSID2_8822B)
+#define BIT_GET_BSSID2_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_BSSID2_8822B) & BIT_MASK_BSSID2_8822B)
+
+/* 2 REG_MACID3_8822B (MAC ID3 REGISTER) */
+
+#define BIT_SHIFT_MACID3_8822B 0
+#define BIT_MASK_MACID3_8822B 0xffffffffffffL
+#define BIT_MACID3_8822B(x)                                                    \
+	(((x) & BIT_MASK_MACID3_8822B) << BIT_SHIFT_MACID3_8822B)
+#define BIT_GET_MACID3_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_MACID3_8822B) & BIT_MASK_MACID3_8822B)
+
+/* 2 REG_BSSID3_8822B (BSSID3 REGISTER) */
+
+#define BIT_SHIFT_BSSID3_8822B 0
+#define BIT_MASK_BSSID3_8822B 0xffffffffffffL
+#define BIT_BSSID3_8822B(x)                                                    \
+	(((x) & BIT_MASK_BSSID3_8822B) << BIT_SHIFT_BSSID3_8822B)
+#define BIT_GET_BSSID3_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_BSSID3_8822B) & BIT_MASK_BSSID3_8822B)
+
+/* 2 REG_MACID4_8822B (MAC ID4 REGISTER) */
+
+#define BIT_SHIFT_MACID4_8822B 0
+#define BIT_MASK_MACID4_8822B 0xffffffffffffL
+#define BIT_MACID4_8822B(x)                                                    \
+	(((x) & BIT_MASK_MACID4_8822B) << BIT_SHIFT_MACID4_8822B)
+#define BIT_GET_MACID4_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_MACID4_8822B) & BIT_MASK_MACID4_8822B)
+
+/* 2 REG_BSSID4_8822B (BSSID4 REGISTER) */
+
+#define BIT_SHIFT_BSSID4_8822B 0
+#define BIT_MASK_BSSID4_8822B 0xffffffffffffL
+#define BIT_BSSID4_8822B(x)                                                    \
+	(((x) & BIT_MASK_BSSID4_8822B) << BIT_SHIFT_BSSID4_8822B)
+#define BIT_GET_BSSID4_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_BSSID4_8822B) & BIT_MASK_BSSID4_8822B)
+
+/* 2 REG_NOA_REPORT_8822B */
+
+/* 2 REG_PWRBIT_SETTING_8822B */
+#define BIT_CLI3_PWRBIT_OW_EN_8822B BIT(7)
+#define BIT_CLI3_PWR_ST_8822B BIT(6)
+#define BIT_CLI2_PWRBIT_OW_EN_8822B BIT(5)
+#define BIT_CLI2_PWR_ST_8822B BIT(4)
+#define BIT_CLI1_PWRBIT_OW_EN_8822B BIT(3)
+#define BIT_CLI1_PWR_ST_8822B BIT(2)
+#define BIT_CLI0_PWRBIT_OW_EN_8822B BIT(1)
+#define BIT_CLI0_PWR_ST_8822B BIT(0)
+
+/* 2 REG_WMAC_MU_BF_OPTION_8822B */
+#define BIT_WMAC_RESP_NONSTA1_DIS_8822B BIT(7)
+#define BIT_BIT_WMAC_TXMU_ACKPOLICY_EN_8822B BIT(6)
+
+#define BIT_SHIFT_WMAC_TXMU_ACKPOLICY_8822B 4
+#define BIT_MASK_WMAC_TXMU_ACKPOLICY_8822B 0x3
+#define BIT_WMAC_TXMU_ACKPOLICY_8822B(x)                                       \
+	(((x) & BIT_MASK_WMAC_TXMU_ACKPOLICY_8822B)                            \
+	 << BIT_SHIFT_WMAC_TXMU_ACKPOLICY_8822B)
+#define BIT_GET_WMAC_TXMU_ACKPOLICY_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_WMAC_TXMU_ACKPOLICY_8822B) &                        \
+	 BIT_MASK_WMAC_TXMU_ACKPOLICY_8822B)
+
+#define BIT_SHIFT_WMAC_MU_BFEE_PORT_SEL_8822B 1
+#define BIT_MASK_WMAC_MU_BFEE_PORT_SEL_8822B 0x7
+#define BIT_WMAC_MU_BFEE_PORT_SEL_8822B(x)                                     \
+	(((x) & BIT_MASK_WMAC_MU_BFEE_PORT_SEL_8822B)                          \
+	 << BIT_SHIFT_WMAC_MU_BFEE_PORT_SEL_8822B)
+#define BIT_GET_WMAC_MU_BFEE_PORT_SEL_8822B(x)                                 \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFEE_PORT_SEL_8822B) &                      \
+	 BIT_MASK_WMAC_MU_BFEE_PORT_SEL_8822B)
+
+#define BIT_WMAC_MU_BFEE_DIS_8822B BIT(0)
+
+/* 2 REG_NOT_VALID_8822B */
+
+#define BIT_SHIFT_WMAC_PAUSE_BB_CLR_TH_8822B 0
+#define BIT_MASK_WMAC_PAUSE_BB_CLR_TH_8822B 0xff
+#define BIT_WMAC_PAUSE_BB_CLR_TH_8822B(x)                                      \
+	(((x) & BIT_MASK_WMAC_PAUSE_BB_CLR_TH_8822B)                           \
+	 << BIT_SHIFT_WMAC_PAUSE_BB_CLR_TH_8822B)
+#define BIT_GET_WMAC_PAUSE_BB_CLR_TH_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_WMAC_PAUSE_BB_CLR_TH_8822B) &                       \
+	 BIT_MASK_WMAC_PAUSE_BB_CLR_TH_8822B)
+
+/* 2 REG_WMAC_MU_ARB_8822B */
+#define BIT_WMAC_ARB_HW_ADAPT_EN_8822B BIT(7)
+#define BIT_WMAC_ARB_SW_EN_8822B BIT(6)
+
+#define BIT_SHIFT_WMAC_ARB_SW_STATE_8822B 0
+#define BIT_MASK_WMAC_ARB_SW_STATE_8822B 0x3f
+#define BIT_WMAC_ARB_SW_STATE_8822B(x)                                         \
+	(((x) & BIT_MASK_WMAC_ARB_SW_STATE_8822B)                              \
+	 << BIT_SHIFT_WMAC_ARB_SW_STATE_8822B)
+#define BIT_GET_WMAC_ARB_SW_STATE_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_WMAC_ARB_SW_STATE_8822B) &                          \
+	 BIT_MASK_WMAC_ARB_SW_STATE_8822B)
+
+/* 2 REG_WMAC_MU_OPTION_8822B */
+
+#define BIT_SHIFT_WMAC_MU_DBGSEL_8822B 5
+#define BIT_MASK_WMAC_MU_DBGSEL_8822B 0x3
+#define BIT_WMAC_MU_DBGSEL_8822B(x)                                            \
+	(((x) & BIT_MASK_WMAC_MU_DBGSEL_8822B)                                 \
+	 << BIT_SHIFT_WMAC_MU_DBGSEL_8822B)
+#define BIT_GET_WMAC_MU_DBGSEL_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_WMAC_MU_DBGSEL_8822B) &                             \
+	 BIT_MASK_WMAC_MU_DBGSEL_8822B)
+
+#define BIT_SHIFT_WMAC_MU_CPRD_TIMEOUT_8822B 0
+#define BIT_MASK_WMAC_MU_CPRD_TIMEOUT_8822B 0x1f
+#define BIT_WMAC_MU_CPRD_TIMEOUT_8822B(x)                                      \
+	(((x) & BIT_MASK_WMAC_MU_CPRD_TIMEOUT_8822B)                           \
+	 << BIT_SHIFT_WMAC_MU_CPRD_TIMEOUT_8822B)
+#define BIT_GET_WMAC_MU_CPRD_TIMEOUT_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_WMAC_MU_CPRD_TIMEOUT_8822B) &                       \
+	 BIT_MASK_WMAC_MU_CPRD_TIMEOUT_8822B)
+
+/* 2 REG_WMAC_MU_BF_CTL_8822B */
+#define BIT_WMAC_INVLD_BFPRT_CHK_8822B BIT(15)
+#define BIT_WMAC_RETXBFRPTSEQ_UPD_8822B BIT(14)
+
+#define BIT_SHIFT_WMAC_MU_BFRPTSEG_SEL_8822B 12
+#define BIT_MASK_WMAC_MU_BFRPTSEG_SEL_8822B 0x3
+#define BIT_WMAC_MU_BFRPTSEG_SEL_8822B(x)                                      \
+	(((x) & BIT_MASK_WMAC_MU_BFRPTSEG_SEL_8822B)                           \
+	 << BIT_SHIFT_WMAC_MU_BFRPTSEG_SEL_8822B)
+#define BIT_GET_WMAC_MU_BFRPTSEG_SEL_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFRPTSEG_SEL_8822B) &                       \
+	 BIT_MASK_WMAC_MU_BFRPTSEG_SEL_8822B)
+
+#define BIT_SHIFT_WMAC_MU_BF_MYAID_8822B 0
+#define BIT_MASK_WMAC_MU_BF_MYAID_8822B 0xfff
+#define BIT_WMAC_MU_BF_MYAID_8822B(x)                                          \
+	(((x) & BIT_MASK_WMAC_MU_BF_MYAID_8822B)                               \
+	 << BIT_SHIFT_WMAC_MU_BF_MYAID_8822B)
+#define BIT_GET_WMAC_MU_BF_MYAID_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_WMAC_MU_BF_MYAID_8822B) &                           \
+	 BIT_MASK_WMAC_MU_BF_MYAID_8822B)
+
+/* 2 REG_WMAC_MU_BFRPT_PARA_8822B */
+
+#define BIT_SHIFT_BIT_BFRPT_PARA_USERID_SEL_8822B 12
+#define BIT_MASK_BIT_BFRPT_PARA_USERID_SEL_8822B 0x7
+#define BIT_BIT_BFRPT_PARA_USERID_SEL_8822B(x)                                 \
+	(((x) & BIT_MASK_BIT_BFRPT_PARA_USERID_SEL_8822B)                      \
+	 << BIT_SHIFT_BIT_BFRPT_PARA_USERID_SEL_8822B)
+#define BIT_GET_BIT_BFRPT_PARA_USERID_SEL_8822B(x)                             \
+	(((x) >> BIT_SHIFT_BIT_BFRPT_PARA_USERID_SEL_8822B) &                  \
+	 BIT_MASK_BIT_BFRPT_PARA_USERID_SEL_8822B)
+
+#define BIT_SHIFT_BFRPT_PARA_8822B 0
+#define BIT_MASK_BFRPT_PARA_8822B 0xfff
+#define BIT_BFRPT_PARA_8822B(x)                                                \
+	(((x) & BIT_MASK_BFRPT_PARA_8822B) << BIT_SHIFT_BFRPT_PARA_8822B)
+#define BIT_GET_BFRPT_PARA_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_BFRPT_PARA_8822B) & BIT_MASK_BFRPT_PARA_8822B)
+
+/* 2 REG_WMAC_ASSOCIATED_MU_BFMEE2_8822B */
+#define BIT_STATUS_BFEE2_8822B BIT(10)
+#define BIT_WMAC_MU_BFEE2_EN_8822B BIT(9)
+
+#define BIT_SHIFT_WMAC_MU_BFEE2_AID_8822B 0
+#define BIT_MASK_WMAC_MU_BFEE2_AID_8822B 0x1ff
+#define BIT_WMAC_MU_BFEE2_AID_8822B(x)                                         \
+	(((x) & BIT_MASK_WMAC_MU_BFEE2_AID_8822B)                              \
+	 << BIT_SHIFT_WMAC_MU_BFEE2_AID_8822B)
+#define BIT_GET_WMAC_MU_BFEE2_AID_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFEE2_AID_8822B) &                          \
+	 BIT_MASK_WMAC_MU_BFEE2_AID_8822B)
+
+/* 2 REG_WMAC_ASSOCIATED_MU_BFMEE3_8822B */
+#define BIT_STATUS_BFEE3_8822B BIT(10)
+#define BIT_WMAC_MU_BFEE3_EN_8822B BIT(9)
+
+#define BIT_SHIFT_WMAC_MU_BFEE3_AID_8822B 0
+#define BIT_MASK_WMAC_MU_BFEE3_AID_8822B 0x1ff
+#define BIT_WMAC_MU_BFEE3_AID_8822B(x)                                         \
+	(((x) & BIT_MASK_WMAC_MU_BFEE3_AID_8822B)                              \
+	 << BIT_SHIFT_WMAC_MU_BFEE3_AID_8822B)
+#define BIT_GET_WMAC_MU_BFEE3_AID_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFEE3_AID_8822B) &                          \
+	 BIT_MASK_WMAC_MU_BFEE3_AID_8822B)
+
+/* 2 REG_WMAC_ASSOCIATED_MU_BFMEE4_8822B */
+#define BIT_STATUS_BFEE4_8822B BIT(10)
+#define BIT_WMAC_MU_BFEE4_EN_8822B BIT(9)
+
+#define BIT_SHIFT_WMAC_MU_BFEE4_AID_8822B 0
+#define BIT_MASK_WMAC_MU_BFEE4_AID_8822B 0x1ff
+#define BIT_WMAC_MU_BFEE4_AID_8822B(x)                                         \
+	(((x) & BIT_MASK_WMAC_MU_BFEE4_AID_8822B)                              \
+	 << BIT_SHIFT_WMAC_MU_BFEE4_AID_8822B)
+#define BIT_GET_WMAC_MU_BFEE4_AID_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFEE4_AID_8822B) &                          \
+	 BIT_MASK_WMAC_MU_BFEE4_AID_8822B)
+
+/* 2 REG_WMAC_ASSOCIATED_MU_BFMEE5_8822B */
+#define BIT_STATUS_BFEE5_8822B BIT(10)
+#define BIT_WMAC_MU_BFEE5_EN_8822B BIT(9)
+
+#define BIT_SHIFT_WMAC_MU_BFEE5_AID_8822B 0
+#define BIT_MASK_WMAC_MU_BFEE5_AID_8822B 0x1ff
+#define BIT_WMAC_MU_BFEE5_AID_8822B(x)                                         \
+	(((x) & BIT_MASK_WMAC_MU_BFEE5_AID_8822B)                              \
+	 << BIT_SHIFT_WMAC_MU_BFEE5_AID_8822B)
+#define BIT_GET_WMAC_MU_BFEE5_AID_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFEE5_AID_8822B) &                          \
+	 BIT_MASK_WMAC_MU_BFEE5_AID_8822B)
+
+/* 2 REG_WMAC_ASSOCIATED_MU_BFMEE6_8822B */
+#define BIT_STATUS_BFEE6_8822B BIT(10)
+#define BIT_WMAC_MU_BFEE6_EN_8822B BIT(9)
+
+#define BIT_SHIFT_WMAC_MU_BFEE6_AID_8822B 0
+#define BIT_MASK_WMAC_MU_BFEE6_AID_8822B 0x1ff
+#define BIT_WMAC_MU_BFEE6_AID_8822B(x)                                         \
+	(((x) & BIT_MASK_WMAC_MU_BFEE6_AID_8822B)                              \
+	 << BIT_SHIFT_WMAC_MU_BFEE6_AID_8822B)
+#define BIT_GET_WMAC_MU_BFEE6_AID_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFEE6_AID_8822B) &                          \
+	 BIT_MASK_WMAC_MU_BFEE6_AID_8822B)
+
+/* 2 REG_WMAC_ASSOCIATED_MU_BFMEE7_8822B */
+#define BIT_BIT_STATUS_BFEE4_8822B BIT(10)
+#define BIT_WMAC_MU_BFEE7_EN_8822B BIT(9)
+
+#define BIT_SHIFT_WMAC_MU_BFEE7_AID_8822B 0
+#define BIT_MASK_WMAC_MU_BFEE7_AID_8822B 0x1ff
+#define BIT_WMAC_MU_BFEE7_AID_8822B(x)                                         \
+	(((x) & BIT_MASK_WMAC_MU_BFEE7_AID_8822B)                              \
+	 << BIT_SHIFT_WMAC_MU_BFEE7_AID_8822B)
+#define BIT_GET_WMAC_MU_BFEE7_AID_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_WMAC_MU_BFEE7_AID_8822B) &                          \
+	 BIT_MASK_WMAC_MU_BFEE7_AID_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+#define BIT_RST_ALL_COUNTER_8822B BIT(31)
+
+#define BIT_SHIFT_ABORT_RX_VBON_COUNTER_8822B 16
+#define BIT_MASK_ABORT_RX_VBON_COUNTER_8822B 0xff
+#define BIT_ABORT_RX_VBON_COUNTER_8822B(x)                                     \
+	(((x) & BIT_MASK_ABORT_RX_VBON_COUNTER_8822B)                          \
+	 << BIT_SHIFT_ABORT_RX_VBON_COUNTER_8822B)
+#define BIT_GET_ABORT_RX_VBON_COUNTER_8822B(x)                                 \
+	(((x) >> BIT_SHIFT_ABORT_RX_VBON_COUNTER_8822B) &                      \
+	 BIT_MASK_ABORT_RX_VBON_COUNTER_8822B)
+
+#define BIT_SHIFT_ABORT_RX_RDRDY_COUNTER_8822B 8
+#define BIT_MASK_ABORT_RX_RDRDY_COUNTER_8822B 0xff
+#define BIT_ABORT_RX_RDRDY_COUNTER_8822B(x)                                    \
+	(((x) & BIT_MASK_ABORT_RX_RDRDY_COUNTER_8822B)                         \
+	 << BIT_SHIFT_ABORT_RX_RDRDY_COUNTER_8822B)
+#define BIT_GET_ABORT_RX_RDRDY_COUNTER_8822B(x)                                \
+	(((x) >> BIT_SHIFT_ABORT_RX_RDRDY_COUNTER_8822B) &                     \
+	 BIT_MASK_ABORT_RX_RDRDY_COUNTER_8822B)
+
+#define BIT_SHIFT_VBON_EARLY_FALLING_COUNTER_8822B 0
+#define BIT_MASK_VBON_EARLY_FALLING_COUNTER_8822B 0xff
+#define BIT_VBON_EARLY_FALLING_COUNTER_8822B(x)                                \
+	(((x) & BIT_MASK_VBON_EARLY_FALLING_COUNTER_8822B)                     \
+	 << BIT_SHIFT_VBON_EARLY_FALLING_COUNTER_8822B)
+#define BIT_GET_VBON_EARLY_FALLING_COUNTER_8822B(x)                            \
+	(((x) >> BIT_SHIFT_VBON_EARLY_FALLING_COUNTER_8822B) &                 \
+	 BIT_MASK_VBON_EARLY_FALLING_COUNTER_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+#define BIT_WMAC_PLCP_TRX_SEL_8822B BIT(31)
+
+#define BIT_SHIFT_WMAC_PLCP_RDSIG_SEL_8822B 28
+#define BIT_MASK_WMAC_PLCP_RDSIG_SEL_8822B 0x7
+#define BIT_WMAC_PLCP_RDSIG_SEL_8822B(x)                                       \
+	(((x) & BIT_MASK_WMAC_PLCP_RDSIG_SEL_8822B)                            \
+	 << BIT_SHIFT_WMAC_PLCP_RDSIG_SEL_8822B)
+#define BIT_GET_WMAC_PLCP_RDSIG_SEL_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_WMAC_PLCP_RDSIG_SEL_8822B) &                        \
+	 BIT_MASK_WMAC_PLCP_RDSIG_SEL_8822B)
+
+#define BIT_SHIFT_WMAC_RATE_IDX_8822B 24
+#define BIT_MASK_WMAC_RATE_IDX_8822B 0xf
+#define BIT_WMAC_RATE_IDX_8822B(x)                                             \
+	(((x) & BIT_MASK_WMAC_RATE_IDX_8822B) << BIT_SHIFT_WMAC_RATE_IDX_8822B)
+#define BIT_GET_WMAC_RATE_IDX_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_WMAC_RATE_IDX_8822B) & BIT_MASK_WMAC_RATE_IDX_8822B)
+
+#define BIT_SHIFT_WMAC_PLCP_RDSIG_8822B 0
+#define BIT_MASK_WMAC_PLCP_RDSIG_8822B 0xffffff
+#define BIT_WMAC_PLCP_RDSIG_8822B(x)                                           \
+	(((x) & BIT_MASK_WMAC_PLCP_RDSIG_8822B)                                \
+	 << BIT_SHIFT_WMAC_PLCP_RDSIG_8822B)
+#define BIT_GET_WMAC_PLCP_RDSIG_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_WMAC_PLCP_RDSIG_8822B) &                            \
+	 BIT_MASK_WMAC_PLCP_RDSIG_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+#define BIT_WMAC_MUTX_IDX_8822B BIT(24)
+
+#define BIT_SHIFT_WMAC_PLCP_RDSIG_8822B 0
+#define BIT_MASK_WMAC_PLCP_RDSIG_8822B 0xffffff
+#define BIT_WMAC_PLCP_RDSIG_8822B(x)                                           \
+	(((x) & BIT_MASK_WMAC_PLCP_RDSIG_8822B)                                \
+	 << BIT_SHIFT_WMAC_PLCP_RDSIG_8822B)
+#define BIT_GET_WMAC_PLCP_RDSIG_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_WMAC_PLCP_RDSIG_8822B) &                            \
+	 BIT_MASK_WMAC_PLCP_RDSIG_8822B)
+
+/* 2 REG_TRANSMIT_ADDRSS_0_8822B (TA0 REGISTER) */
+
+#define BIT_SHIFT_TA0_8822B 0
+#define BIT_MASK_TA0_8822B 0xffffffffffffL
+#define BIT_TA0_8822B(x) (((x) & BIT_MASK_TA0_8822B) << BIT_SHIFT_TA0_8822B)
+#define BIT_GET_TA0_8822B(x) (((x) >> BIT_SHIFT_TA0_8822B) & BIT_MASK_TA0_8822B)
+
+/* 2 REG_TRANSMIT_ADDRSS_1_8822B (TA1 REGISTER) */
+
+#define BIT_SHIFT_TA1_8822B 0
+#define BIT_MASK_TA1_8822B 0xffffffffffffL
+#define BIT_TA1_8822B(x) (((x) & BIT_MASK_TA1_8822B) << BIT_SHIFT_TA1_8822B)
+#define BIT_GET_TA1_8822B(x) (((x) >> BIT_SHIFT_TA1_8822B) & BIT_MASK_TA1_8822B)
+
+/* 2 REG_TRANSMIT_ADDRSS_2_8822B (TA2 REGISTER) */
+
+#define BIT_SHIFT_TA2_8822B 0
+#define BIT_MASK_TA2_8822B 0xffffffffffffL
+#define BIT_TA2_8822B(x) (((x) & BIT_MASK_TA2_8822B) << BIT_SHIFT_TA2_8822B)
+#define BIT_GET_TA2_8822B(x) (((x) >> BIT_SHIFT_TA2_8822B) & BIT_MASK_TA2_8822B)
+
+/* 2 REG_TRANSMIT_ADDRSS_3_8822B (TA3 REGISTER) */
+
+#define BIT_SHIFT_TA3_8822B 0
+#define BIT_MASK_TA3_8822B 0xffffffffffffL
+#define BIT_TA3_8822B(x) (((x) & BIT_MASK_TA3_8822B) << BIT_SHIFT_TA3_8822B)
+#define BIT_GET_TA3_8822B(x) (((x) >> BIT_SHIFT_TA3_8822B) & BIT_MASK_TA3_8822B)
+
+/* 2 REG_TRANSMIT_ADDRSS_4_8822B (TA4 REGISTER) */
+
+#define BIT_SHIFT_TA4_8822B 0
+#define BIT_MASK_TA4_8822B 0xffffffffffffL
+#define BIT_TA4_8822B(x) (((x) & BIT_MASK_TA4_8822B) << BIT_SHIFT_TA4_8822B)
+#define BIT_GET_TA4_8822B(x) (((x) >> BIT_SHIFT_TA4_8822B) & BIT_MASK_TA4_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_MACID1_8822B */
+
+#define BIT_SHIFT_MACID1_8822B 0
+#define BIT_MASK_MACID1_8822B 0xffffffffffffL
+#define BIT_MACID1_8822B(x)                                                    \
+	(((x) & BIT_MASK_MACID1_8822B) << BIT_SHIFT_MACID1_8822B)
+#define BIT_GET_MACID1_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_MACID1_8822B) & BIT_MASK_MACID1_8822B)
+
+/* 2 REG_BSSID1_8822B */
+
+#define BIT_SHIFT_BSSID1_8822B 0
+#define BIT_MASK_BSSID1_8822B 0xffffffffffffL
+#define BIT_BSSID1_8822B(x)                                                    \
+	(((x) & BIT_MASK_BSSID1_8822B) << BIT_SHIFT_BSSID1_8822B)
+#define BIT_GET_BSSID1_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_BSSID1_8822B) & BIT_MASK_BSSID1_8822B)
+
+/* 2 REG_BCN_PSR_RPT1_8822B */
+
+#define BIT_SHIFT_DTIM_CNT1_8822B 24
+#define BIT_MASK_DTIM_CNT1_8822B 0xff
+#define BIT_DTIM_CNT1_8822B(x)                                                 \
+	(((x) & BIT_MASK_DTIM_CNT1_8822B) << BIT_SHIFT_DTIM_CNT1_8822B)
+#define BIT_GET_DTIM_CNT1_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_DTIM_CNT1_8822B) & BIT_MASK_DTIM_CNT1_8822B)
+
+#define BIT_SHIFT_DTIM_PERIOD1_8822B 16
+#define BIT_MASK_DTIM_PERIOD1_8822B 0xff
+#define BIT_DTIM_PERIOD1_8822B(x)                                              \
+	(((x) & BIT_MASK_DTIM_PERIOD1_8822B) << BIT_SHIFT_DTIM_PERIOD1_8822B)
+#define BIT_GET_DTIM_PERIOD1_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_DTIM_PERIOD1_8822B) & BIT_MASK_DTIM_PERIOD1_8822B)
+
+#define BIT_DTIM1_8822B BIT(15)
+#define BIT_TIM1_8822B BIT(14)
+
+#define BIT_SHIFT_PS_AID_1_8822B 0
+#define BIT_MASK_PS_AID_1_8822B 0x7ff
+#define BIT_PS_AID_1_8822B(x)                                                  \
+	(((x) & BIT_MASK_PS_AID_1_8822B) << BIT_SHIFT_PS_AID_1_8822B)
+#define BIT_GET_PS_AID_1_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_PS_AID_1_8822B) & BIT_MASK_PS_AID_1_8822B)
+
+/* 2 REG_ASSOCIATED_BFMEE_SEL_8822B */
+#define BIT_TXUSER_ID1_8822B BIT(25)
+
+#define BIT_SHIFT_AID1_8822B 16
+#define BIT_MASK_AID1_8822B 0x1ff
+#define BIT_AID1_8822B(x) (((x) & BIT_MASK_AID1_8822B) << BIT_SHIFT_AID1_8822B)
+#define BIT_GET_AID1_8822B(x)                                                  \
+	(((x) >> BIT_SHIFT_AID1_8822B) & BIT_MASK_AID1_8822B)
+
+#define BIT_TXUSER_ID0_8822B BIT(9)
+
+#define BIT_SHIFT_AID0_8822B 0
+#define BIT_MASK_AID0_8822B 0x1ff
+#define BIT_AID0_8822B(x) (((x) & BIT_MASK_AID0_8822B) << BIT_SHIFT_AID0_8822B)
+#define BIT_GET_AID0_8822B(x)                                                  \
+	(((x) >> BIT_SHIFT_AID0_8822B) & BIT_MASK_AID0_8822B)
+
+/* 2 REG_SND_PTCL_CTRL_8822B */
+
+#define BIT_SHIFT_NDP_RX_STANDBY_TIMER_8822B 24
+#define BIT_MASK_NDP_RX_STANDBY_TIMER_8822B 0xff
+#define BIT_NDP_RX_STANDBY_TIMER_8822B(x)                                      \
+	(((x) & BIT_MASK_NDP_RX_STANDBY_TIMER_8822B)                           \
+	 << BIT_SHIFT_NDP_RX_STANDBY_TIMER_8822B)
+#define BIT_GET_NDP_RX_STANDBY_TIMER_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_NDP_RX_STANDBY_TIMER_8822B) &                       \
+	 BIT_MASK_NDP_RX_STANDBY_TIMER_8822B)
+
+#define BIT_SHIFT_CSI_RPT_OFFSET_HT_8822B 16
+#define BIT_MASK_CSI_RPT_OFFSET_HT_8822B 0xff
+#define BIT_CSI_RPT_OFFSET_HT_8822B(x)                                         \
+	(((x) & BIT_MASK_CSI_RPT_OFFSET_HT_8822B)                              \
+	 << BIT_SHIFT_CSI_RPT_OFFSET_HT_8822B)
+#define BIT_GET_CSI_RPT_OFFSET_HT_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_CSI_RPT_OFFSET_HT_8822B) &                          \
+	 BIT_MASK_CSI_RPT_OFFSET_HT_8822B)
+
+#define BIT_SHIFT_R_WMAC_VHT_CATEGORY_8822B 8
+#define BIT_MASK_R_WMAC_VHT_CATEGORY_8822B 0xff
+#define BIT_R_WMAC_VHT_CATEGORY_8822B(x)                                       \
+	(((x) & BIT_MASK_R_WMAC_VHT_CATEGORY_8822B)                            \
+	 << BIT_SHIFT_R_WMAC_VHT_CATEGORY_8822B)
+#define BIT_GET_R_WMAC_VHT_CATEGORY_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_R_WMAC_VHT_CATEGORY_8822B) &                        \
+	 BIT_MASK_R_WMAC_VHT_CATEGORY_8822B)
+
+#define BIT_R_WMAC_USE_NSTS_8822B BIT(7)
+#define BIT_R_DISABLE_CHECK_VHTSIGB_CRC_8822B BIT(6)
+#define BIT_R_DISABLE_CHECK_VHTSIGA_CRC_8822B BIT(5)
+#define BIT_R_WMAC_BFPARAM_SEL_8822B BIT(4)
+#define BIT_R_WMAC_CSISEQ_SEL_8822B BIT(3)
+#define BIT_R_WMAC_CSI_WITHHTC_EN_8822B BIT(2)
+#define BIT_R_WMAC_HT_NDPA_EN_8822B BIT(1)
+#define BIT_R_WMAC_VHT_NDPA_EN_8822B BIT(0)
+
+/* 2 REG_RX_CSI_RPT_INFO_8822B */
+
+/* 2 REG_NS_ARP_CTRL_8822B */
+#define BIT_R_WMAC_NSARP_RSPEN_8822B BIT(15)
+#define BIT_R_WMAC_NSARP_RARP_8822B BIT(9)
+#define BIT_R_WMAC_NSARP_RIPV6_8822B BIT(8)
+
+#define BIT_SHIFT_R_WMAC_NSARP_MODEN_8822B 6
+#define BIT_MASK_R_WMAC_NSARP_MODEN_8822B 0x3
+#define BIT_R_WMAC_NSARP_MODEN_8822B(x)                                        \
+	(((x) & BIT_MASK_R_WMAC_NSARP_MODEN_8822B)                             \
+	 << BIT_SHIFT_R_WMAC_NSARP_MODEN_8822B)
+#define BIT_GET_R_WMAC_NSARP_MODEN_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_R_WMAC_NSARP_MODEN_8822B) &                         \
+	 BIT_MASK_R_WMAC_NSARP_MODEN_8822B)
+
+#define BIT_SHIFT_R_WMAC_NSARP_RSPFTP_8822B 4
+#define BIT_MASK_R_WMAC_NSARP_RSPFTP_8822B 0x3
+#define BIT_R_WMAC_NSARP_RSPFTP_8822B(x)                                       \
+	(((x) & BIT_MASK_R_WMAC_NSARP_RSPFTP_8822B)                            \
+	 << BIT_SHIFT_R_WMAC_NSARP_RSPFTP_8822B)
+#define BIT_GET_R_WMAC_NSARP_RSPFTP_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_R_WMAC_NSARP_RSPFTP_8822B) &                        \
+	 BIT_MASK_R_WMAC_NSARP_RSPFTP_8822B)
+
+#define BIT_SHIFT_R_WMAC_NSARP_RSPSEC_8822B 0
+#define BIT_MASK_R_WMAC_NSARP_RSPSEC_8822B 0xf
+#define BIT_R_WMAC_NSARP_RSPSEC_8822B(x)                                       \
+	(((x) & BIT_MASK_R_WMAC_NSARP_RSPSEC_8822B)                            \
+	 << BIT_SHIFT_R_WMAC_NSARP_RSPSEC_8822B)
+#define BIT_GET_R_WMAC_NSARP_RSPSEC_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_R_WMAC_NSARP_RSPSEC_8822B) &                        \
+	 BIT_MASK_R_WMAC_NSARP_RSPSEC_8822B)
+
+/* 2 REG_NS_ARP_INFO_8822B */
+#define BIT_REQ_IS_MCNS_8822B BIT(23)
+#define BIT_REQ_IS_UCNS_8822B BIT(22)
+#define BIT_REQ_IS_USNS_8822B BIT(21)
+#define BIT_REQ_IS_ARP_8822B BIT(20)
+#define BIT_EXPRSP_MH_WITHQC_8822B BIT(19)
+
+#define BIT_SHIFT_EXPRSP_SECTYPE_8822B 16
+#define BIT_MASK_EXPRSP_SECTYPE_8822B 0x7
+#define BIT_EXPRSP_SECTYPE_8822B(x)                                            \
+	(((x) & BIT_MASK_EXPRSP_SECTYPE_8822B)                                 \
+	 << BIT_SHIFT_EXPRSP_SECTYPE_8822B)
+#define BIT_GET_EXPRSP_SECTYPE_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_EXPRSP_SECTYPE_8822B) &                             \
+	 BIT_MASK_EXPRSP_SECTYPE_8822B)
+
+#define BIT_SHIFT_EXPRSP_CHKSM_7_TO_0_8822B 8
+#define BIT_MASK_EXPRSP_CHKSM_7_TO_0_8822B 0xff
+#define BIT_EXPRSP_CHKSM_7_TO_0_8822B(x)                                       \
+	(((x) & BIT_MASK_EXPRSP_CHKSM_7_TO_0_8822B)                            \
+	 << BIT_SHIFT_EXPRSP_CHKSM_7_TO_0_8822B)
+#define BIT_GET_EXPRSP_CHKSM_7_TO_0_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_EXPRSP_CHKSM_7_TO_0_8822B) &                        \
+	 BIT_MASK_EXPRSP_CHKSM_7_TO_0_8822B)
+
+#define BIT_SHIFT_EXPRSP_CHKSM_15_TO_8_8822B 0
+#define BIT_MASK_EXPRSP_CHKSM_15_TO_8_8822B 0xff
+#define BIT_EXPRSP_CHKSM_15_TO_8_8822B(x)                                      \
+	(((x) & BIT_MASK_EXPRSP_CHKSM_15_TO_8_8822B)                           \
+	 << BIT_SHIFT_EXPRSP_CHKSM_15_TO_8_8822B)
+#define BIT_GET_EXPRSP_CHKSM_15_TO_8_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_EXPRSP_CHKSM_15_TO_8_8822B) &                       \
+	 BIT_MASK_EXPRSP_CHKSM_15_TO_8_8822B)
+
+/* 2 REG_BEAMFORMING_INFO_NSARP_V1_8822B */
+
+#define BIT_SHIFT_WMAC_ARPIP_8822B 0
+#define BIT_MASK_WMAC_ARPIP_8822B 0xffffffffL
+#define BIT_WMAC_ARPIP_8822B(x)                                                \
+	(((x) & BIT_MASK_WMAC_ARPIP_8822B) << BIT_SHIFT_WMAC_ARPIP_8822B)
+#define BIT_GET_WMAC_ARPIP_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_WMAC_ARPIP_8822B) & BIT_MASK_WMAC_ARPIP_8822B)
+
+/* 2 REG_BEAMFORMING_INFO_NSARP_8822B */
+
+#define BIT_SHIFT_BEAMFORMING_INFO_8822B 0
+#define BIT_MASK_BEAMFORMING_INFO_8822B 0xffffffffL
+#define BIT_BEAMFORMING_INFO_8822B(x)                                          \
+	(((x) & BIT_MASK_BEAMFORMING_INFO_8822B)                               \
+	 << BIT_SHIFT_BEAMFORMING_INFO_8822B)
+#define BIT_GET_BEAMFORMING_INFO_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_BEAMFORMING_INFO_8822B) &                           \
+	 BIT_MASK_BEAMFORMING_INFO_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+#define BIT_SHIFT_R_WMAC_IPV6_MYIPAD_8822B 0
+#define BIT_MASK_R_WMAC_IPV6_MYIPAD_8822B 0xffffffffffffffffffffffffffffffffL
+#define BIT_R_WMAC_IPV6_MYIPAD_8822B(x)                                        \
+	(((x) & BIT_MASK_R_WMAC_IPV6_MYIPAD_8822B)                             \
+	 << BIT_SHIFT_R_WMAC_IPV6_MYIPAD_8822B)
+#define BIT_GET_R_WMAC_IPV6_MYIPAD_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_R_WMAC_IPV6_MYIPAD_8822B) &                         \
+	 BIT_MASK_R_WMAC_IPV6_MYIPAD_8822B)
+
+/* 2 REG_RSVD_0X740_8822B */
+
+/* 2 REG_WMAC_RTX_CTX_SUBTYPE_CFG_8822B */
+
+#define BIT_SHIFT_R_WMAC_CTX_SUBTYPE_8822B 4
+#define BIT_MASK_R_WMAC_CTX_SUBTYPE_8822B 0xf
+#define BIT_R_WMAC_CTX_SUBTYPE_8822B(x)                                        \
+	(((x) & BIT_MASK_R_WMAC_CTX_SUBTYPE_8822B)                             \
+	 << BIT_SHIFT_R_WMAC_CTX_SUBTYPE_8822B)
+#define BIT_GET_R_WMAC_CTX_SUBTYPE_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_R_WMAC_CTX_SUBTYPE_8822B) &                         \
+	 BIT_MASK_R_WMAC_CTX_SUBTYPE_8822B)
+
+#define BIT_SHIFT_R_WMAC_RTX_SUBTYPE_8822B 0
+#define BIT_MASK_R_WMAC_RTX_SUBTYPE_8822B 0xf
+#define BIT_R_WMAC_RTX_SUBTYPE_8822B(x)                                        \
+	(((x) & BIT_MASK_R_WMAC_RTX_SUBTYPE_8822B)                             \
+	 << BIT_SHIFT_R_WMAC_RTX_SUBTYPE_8822B)
+#define BIT_GET_R_WMAC_RTX_SUBTYPE_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_R_WMAC_RTX_SUBTYPE_8822B) &                         \
+	 BIT_MASK_R_WMAC_RTX_SUBTYPE_8822B)
+
+/* 2 REG_WMAC_SWAES_CFG_8822B */
+
+/* 2 REG_BT_COEX_V2_8822B */
+#define BIT_GNT_BT_POLARITY_8822B BIT(12)
+#define BIT_GNT_BT_BYPASS_PRIORITY_8822B BIT(8)
+
+#define BIT_SHIFT_TIMER_8822B 0
+#define BIT_MASK_TIMER_8822B 0xff
+#define BIT_TIMER_8822B(x)                                                     \
+	(((x) & BIT_MASK_TIMER_8822B) << BIT_SHIFT_TIMER_8822B)
+#define BIT_GET_TIMER_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_TIMER_8822B) & BIT_MASK_TIMER_8822B)
+
+/* 2 REG_BT_COEX_8822B */
+#define BIT_R_GNT_BT_RFC_SW_8822B BIT(12)
+#define BIT_R_GNT_BT_RFC_SW_EN_8822B BIT(11)
+#define BIT_R_GNT_BT_BB_SW_8822B BIT(10)
+#define BIT_R_GNT_BT_BB_SW_EN_8822B BIT(9)
+#define BIT_R_BT_CNT_THREN_8822B BIT(8)
+
+#define BIT_SHIFT_R_BT_CNT_THR_8822B 0
+#define BIT_MASK_R_BT_CNT_THR_8822B 0xff
+#define BIT_R_BT_CNT_THR_8822B(x)                                              \
+	(((x) & BIT_MASK_R_BT_CNT_THR_8822B) << BIT_SHIFT_R_BT_CNT_THR_8822B)
+#define BIT_GET_R_BT_CNT_THR_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_R_BT_CNT_THR_8822B) & BIT_MASK_R_BT_CNT_THR_8822B)
+
+/* 2 REG_WLAN_ACT_MASK_CTRL_8822B */
+#define BIT_WLRX_TER_BY_CTL_8822B BIT(43)
+#define BIT_WLRX_TER_BY_AD_8822B BIT(42)
+#define BIT_ANT_DIVERSITY_SEL_8822B BIT(41)
+#define BIT_ANTSEL_FOR_BT_CTRL_EN_8822B BIT(40)
+#define BIT_WLACT_LOW_GNTWL_EN_8822B BIT(34)
+#define BIT_WLACT_HIGH_GNTBT_EN_8822B BIT(33)
+#define BIT_NAV_UPPER_V1_8822B BIT(32)
+
+#define BIT_SHIFT_RXMYRTS_NAV_V1_8822B 8
+#define BIT_MASK_RXMYRTS_NAV_V1_8822B 0xff
+#define BIT_RXMYRTS_NAV_V1_8822B(x)                                            \
+	(((x) & BIT_MASK_RXMYRTS_NAV_V1_8822B)                                 \
+	 << BIT_SHIFT_RXMYRTS_NAV_V1_8822B)
+#define BIT_GET_RXMYRTS_NAV_V1_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_RXMYRTS_NAV_V1_8822B) &                             \
+	 BIT_MASK_RXMYRTS_NAV_V1_8822B)
+
+#define BIT_SHIFT_RTSRST_V1_8822B 0
+#define BIT_MASK_RTSRST_V1_8822B 0xff
+#define BIT_RTSRST_V1_8822B(x)                                                 \
+	(((x) & BIT_MASK_RTSRST_V1_8822B) << BIT_SHIFT_RTSRST_V1_8822B)
+#define BIT_GET_RTSRST_V1_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_RTSRST_V1_8822B) & BIT_MASK_RTSRST_V1_8822B)
+
+/* 2 REG_BT_COEX_ENHANCED_INTR_CTRL_8822B */
+
+#define BIT_SHIFT_BT_STAT_DELAY_8822B 12
+#define BIT_MASK_BT_STAT_DELAY_8822B 0xf
+#define BIT_BT_STAT_DELAY_8822B(x)                                             \
+	(((x) & BIT_MASK_BT_STAT_DELAY_8822B) << BIT_SHIFT_BT_STAT_DELAY_8822B)
+#define BIT_GET_BT_STAT_DELAY_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_BT_STAT_DELAY_8822B) & BIT_MASK_BT_STAT_DELAY_8822B)
+
+#define BIT_SHIFT_BT_TRX_INIT_DETECT_8822B 8
+#define BIT_MASK_BT_TRX_INIT_DETECT_8822B 0xf
+#define BIT_BT_TRX_INIT_DETECT_8822B(x)                                        \
+	(((x) & BIT_MASK_BT_TRX_INIT_DETECT_8822B)                             \
+	 << BIT_SHIFT_BT_TRX_INIT_DETECT_8822B)
+#define BIT_GET_BT_TRX_INIT_DETECT_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_BT_TRX_INIT_DETECT_8822B) &                         \
+	 BIT_MASK_BT_TRX_INIT_DETECT_8822B)
+
+#define BIT_SHIFT_BT_PRI_DETECT_TO_8822B 4
+#define BIT_MASK_BT_PRI_DETECT_TO_8822B 0xf
+#define BIT_BT_PRI_DETECT_TO_8822B(x)                                          \
+	(((x) & BIT_MASK_BT_PRI_DETECT_TO_8822B)                               \
+	 << BIT_SHIFT_BT_PRI_DETECT_TO_8822B)
+#define BIT_GET_BT_PRI_DETECT_TO_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_BT_PRI_DETECT_TO_8822B) &                           \
+	 BIT_MASK_BT_PRI_DETECT_TO_8822B)
+
+#define BIT_R_GRANTALL_WLMASK_8822B BIT(3)
+#define BIT_STATIS_BT_EN_8822B BIT(2)
+#define BIT_WL_ACT_MASK_ENABLE_8822B BIT(1)
+#define BIT_ENHANCED_BT_8822B BIT(0)
+
+/* 2 REG_BT_ACT_STATISTICS_8822B */
+
+#define BIT_SHIFT_STATIS_BT_LO_RX_8822B (48 & CPU_OPT_WIDTH)
+#define BIT_MASK_STATIS_BT_LO_RX_8822B 0xffff
+#define BIT_STATIS_BT_LO_RX_8822B(x)                                           \
+	(((x) & BIT_MASK_STATIS_BT_LO_RX_8822B)                                \
+	 << BIT_SHIFT_STATIS_BT_LO_RX_8822B)
+#define BIT_GET_STATIS_BT_LO_RX_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_STATIS_BT_LO_RX_8822B) &                            \
+	 BIT_MASK_STATIS_BT_LO_RX_8822B)
+
+#define BIT_SHIFT_STATIS_BT_LO_TX_8822B (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_STATIS_BT_LO_TX_8822B 0xffff
+#define BIT_STATIS_BT_LO_TX_8822B(x)                                           \
+	(((x) & BIT_MASK_STATIS_BT_LO_TX_8822B)                                \
+	 << BIT_SHIFT_STATIS_BT_LO_TX_8822B)
+#define BIT_GET_STATIS_BT_LO_TX_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_STATIS_BT_LO_TX_8822B) &                            \
+	 BIT_MASK_STATIS_BT_LO_TX_8822B)
+
+#define BIT_SHIFT_STATIS_BT_HI_RX_8822B 16
+#define BIT_MASK_STATIS_BT_HI_RX_8822B 0xffff
+#define BIT_STATIS_BT_HI_RX_8822B(x)                                           \
+	(((x) & BIT_MASK_STATIS_BT_HI_RX_8822B)                                \
+	 << BIT_SHIFT_STATIS_BT_HI_RX_8822B)
+#define BIT_GET_STATIS_BT_HI_RX_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_STATIS_BT_HI_RX_8822B) &                            \
+	 BIT_MASK_STATIS_BT_HI_RX_8822B)
+
+#define BIT_SHIFT_STATIS_BT_HI_TX_8822B 0
+#define BIT_MASK_STATIS_BT_HI_TX_8822B 0xffff
+#define BIT_STATIS_BT_HI_TX_8822B(x)                                           \
+	(((x) & BIT_MASK_STATIS_BT_HI_TX_8822B)                                \
+	 << BIT_SHIFT_STATIS_BT_HI_TX_8822B)
+#define BIT_GET_STATIS_BT_HI_TX_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_STATIS_BT_HI_TX_8822B) &                            \
+	 BIT_MASK_STATIS_BT_HI_TX_8822B)
+
+/* 2 REG_BT_STATISTICS_CONTROL_REGISTER_8822B */
+
+#define BIT_SHIFT_R_BT_CMD_RPT_8822B 16
+#define BIT_MASK_R_BT_CMD_RPT_8822B 0xffff
+#define BIT_R_BT_CMD_RPT_8822B(x)                                              \
+	(((x) & BIT_MASK_R_BT_CMD_RPT_8822B) << BIT_SHIFT_R_BT_CMD_RPT_8822B)
+#define BIT_GET_R_BT_CMD_RPT_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_R_BT_CMD_RPT_8822B) & BIT_MASK_R_BT_CMD_RPT_8822B)
+
+#define BIT_SHIFT_R_RPT_FROM_BT_8822B 8
+#define BIT_MASK_R_RPT_FROM_BT_8822B 0xff
+#define BIT_R_RPT_FROM_BT_8822B(x)                                             \
+	(((x) & BIT_MASK_R_RPT_FROM_BT_8822B) << BIT_SHIFT_R_RPT_FROM_BT_8822B)
+#define BIT_GET_R_RPT_FROM_BT_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_R_RPT_FROM_BT_8822B) & BIT_MASK_R_RPT_FROM_BT_8822B)
+
+#define BIT_SHIFT_BT_HID_ISR_SET_8822B 6
+#define BIT_MASK_BT_HID_ISR_SET_8822B 0x3
+#define BIT_BT_HID_ISR_SET_8822B(x)                                            \
+	(((x) & BIT_MASK_BT_HID_ISR_SET_8822B)                                 \
+	 << BIT_SHIFT_BT_HID_ISR_SET_8822B)
+#define BIT_GET_BT_HID_ISR_SET_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_BT_HID_ISR_SET_8822B) &                             \
+	 BIT_MASK_BT_HID_ISR_SET_8822B)
+
+#define BIT_TDMA_BT_START_NOTIFY_8822B BIT(5)
+#define BIT_ENABLE_TDMA_FW_MODE_8822B BIT(4)
+#define BIT_ENABLE_PTA_TDMA_MODE_8822B BIT(3)
+#define BIT_ENABLE_COEXIST_TAB_IN_TDMA_8822B BIT(2)
+#define BIT_GPIO2_GPIO3_EXANGE_OR_NO_BT_CCA_8822B BIT(1)
+#define BIT_RTK_BT_ENABLE_8822B BIT(0)
+
+/* 2 REG_BT_STATUS_REPORT_REGISTER_8822B */
+
+#define BIT_SHIFT_BT_PROFILE_8822B 24
+#define BIT_MASK_BT_PROFILE_8822B 0xff
+#define BIT_BT_PROFILE_8822B(x)                                                \
+	(((x) & BIT_MASK_BT_PROFILE_8822B) << BIT_SHIFT_BT_PROFILE_8822B)
+#define BIT_GET_BT_PROFILE_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_BT_PROFILE_8822B) & BIT_MASK_BT_PROFILE_8822B)
+
+#define BIT_SHIFT_BT_POWER_8822B 16
+#define BIT_MASK_BT_POWER_8822B 0xff
+#define BIT_BT_POWER_8822B(x)                                                  \
+	(((x) & BIT_MASK_BT_POWER_8822B) << BIT_SHIFT_BT_POWER_8822B)
+#define BIT_GET_BT_POWER_8822B(x)                                              \
+	(((x) >> BIT_SHIFT_BT_POWER_8822B) & BIT_MASK_BT_POWER_8822B)
+
+#define BIT_SHIFT_BT_PREDECT_STATUS_8822B 8
+#define BIT_MASK_BT_PREDECT_STATUS_8822B 0xff
+#define BIT_BT_PREDECT_STATUS_8822B(x)                                         \
+	(((x) & BIT_MASK_BT_PREDECT_STATUS_8822B)                              \
+	 << BIT_SHIFT_BT_PREDECT_STATUS_8822B)
+#define BIT_GET_BT_PREDECT_STATUS_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_BT_PREDECT_STATUS_8822B) &                          \
+	 BIT_MASK_BT_PREDECT_STATUS_8822B)
+
+#define BIT_SHIFT_BT_CMD_INFO_8822B 0
+#define BIT_MASK_BT_CMD_INFO_8822B 0xff
+#define BIT_BT_CMD_INFO_8822B(x)                                               \
+	(((x) & BIT_MASK_BT_CMD_INFO_8822B) << BIT_SHIFT_BT_CMD_INFO_8822B)
+#define BIT_GET_BT_CMD_INFO_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_BT_CMD_INFO_8822B) & BIT_MASK_BT_CMD_INFO_8822B)
+
+/* 2 REG_BT_INTERRUPT_CONTROL_REGISTER_8822B */
+#define BIT_EN_MAC_NULL_PKT_NOTIFY_8822B BIT(31)
+#define BIT_EN_WLAN_RPT_AND_BT_QUERY_8822B BIT(30)
+#define BIT_EN_BT_STSTUS_RPT_8822B BIT(29)
+#define BIT_EN_BT_POWER_8822B BIT(28)
+#define BIT_EN_BT_CHANNEL_8822B BIT(27)
+#define BIT_EN_BT_SLOT_CHANGE_8822B BIT(26)
+#define BIT_EN_BT_PROFILE_OR_HID_8822B BIT(25)
+#define BIT_WLAN_RPT_NOTIFY_8822B BIT(24)
+
+#define BIT_SHIFT_WLAN_RPT_DATA_8822B 16
+#define BIT_MASK_WLAN_RPT_DATA_8822B 0xff
+#define BIT_WLAN_RPT_DATA_8822B(x)                                             \
+	(((x) & BIT_MASK_WLAN_RPT_DATA_8822B) << BIT_SHIFT_WLAN_RPT_DATA_8822B)
+#define BIT_GET_WLAN_RPT_DATA_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_WLAN_RPT_DATA_8822B) & BIT_MASK_WLAN_RPT_DATA_8822B)
+
+#define BIT_SHIFT_CMD_ID_8822B 8
+#define BIT_MASK_CMD_ID_8822B 0xff
+#define BIT_CMD_ID_8822B(x)                                                    \
+	(((x) & BIT_MASK_CMD_ID_8822B) << BIT_SHIFT_CMD_ID_8822B)
+#define BIT_GET_CMD_ID_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_CMD_ID_8822B) & BIT_MASK_CMD_ID_8822B)
+
+#define BIT_SHIFT_BT_DATA_8822B 0
+#define BIT_MASK_BT_DATA_8822B 0xff
+#define BIT_BT_DATA_8822B(x)                                                   \
+	(((x) & BIT_MASK_BT_DATA_8822B) << BIT_SHIFT_BT_DATA_8822B)
+#define BIT_GET_BT_DATA_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_BT_DATA_8822B) & BIT_MASK_BT_DATA_8822B)
+
+/* 2 REG_WLAN_REPORT_TIME_OUT_CONTROL_REGISTER_8822B */
+
+#define BIT_SHIFT_WLAN_RPT_TO_8822B 0
+#define BIT_MASK_WLAN_RPT_TO_8822B 0xff
+#define BIT_WLAN_RPT_TO_8822B(x)                                               \
+	(((x) & BIT_MASK_WLAN_RPT_TO_8822B) << BIT_SHIFT_WLAN_RPT_TO_8822B)
+#define BIT_GET_WLAN_RPT_TO_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_WLAN_RPT_TO_8822B) & BIT_MASK_WLAN_RPT_TO_8822B)
+
+/* 2 REG_BT_ISOLATION_TABLE_REGISTER_REGISTER_8822B */
+
+#define BIT_SHIFT_ISOLATION_CHK_8822B 1
+#define BIT_MASK_ISOLATION_CHK_8822B 0x7fffffffffffffffffffL
+#define BIT_ISOLATION_CHK_8822B(x)                                             \
+	(((x) & BIT_MASK_ISOLATION_CHK_8822B) << BIT_SHIFT_ISOLATION_CHK_8822B)
+#define BIT_GET_ISOLATION_CHK_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_ISOLATION_CHK_8822B) & BIT_MASK_ISOLATION_CHK_8822B)
+
+#define BIT_ISOLATION_EN_8822B BIT(0)
+
+/* 2 REG_BT_INTERRUPT_STATUS_REGISTER_8822B */
+#define BIT_BT_HID_ISR_8822B BIT(7)
+#define BIT_BT_QUERY_ISR_8822B BIT(6)
+#define BIT_MAC_NULL_PKT_NOTIFY_ISR_8822B BIT(5)
+#define BIT_WLAN_RPT_ISR_8822B BIT(4)
+#define BIT_BT_POWER_ISR_8822B BIT(3)
+#define BIT_BT_CHANNEL_ISR_8822B BIT(2)
+#define BIT_BT_SLOT_CHANGE_ISR_8822B BIT(1)
+#define BIT_BT_PROFILE_ISR_8822B BIT(0)
+
+/* 2 REG_BT_TDMA_TIME_REGISTER_8822B */
+
+#define BIT_SHIFT_BT_TIME_8822B 6
+#define BIT_MASK_BT_TIME_8822B 0x3ffffff
+#define BIT_BT_TIME_8822B(x)                                                   \
+	(((x) & BIT_MASK_BT_TIME_8822B) << BIT_SHIFT_BT_TIME_8822B)
+#define BIT_GET_BT_TIME_8822B(x)                                               \
+	(((x) >> BIT_SHIFT_BT_TIME_8822B) & BIT_MASK_BT_TIME_8822B)
+
+#define BIT_SHIFT_BT_RPT_SAMPLE_RATE_8822B 0
+#define BIT_MASK_BT_RPT_SAMPLE_RATE_8822B 0x3f
+#define BIT_BT_RPT_SAMPLE_RATE_8822B(x)                                        \
+	(((x) & BIT_MASK_BT_RPT_SAMPLE_RATE_8822B)                             \
+	 << BIT_SHIFT_BT_RPT_SAMPLE_RATE_8822B)
+#define BIT_GET_BT_RPT_SAMPLE_RATE_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_BT_RPT_SAMPLE_RATE_8822B) &                         \
+	 BIT_MASK_BT_RPT_SAMPLE_RATE_8822B)
+
+/* 2 REG_BT_ACT_REGISTER_8822B */
+
+#define BIT_SHIFT_BT_EISR_EN_8822B 16
+#define BIT_MASK_BT_EISR_EN_8822B 0xff
+#define BIT_BT_EISR_EN_8822B(x)                                                \
+	(((x) & BIT_MASK_BT_EISR_EN_8822B) << BIT_SHIFT_BT_EISR_EN_8822B)
+#define BIT_GET_BT_EISR_EN_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_BT_EISR_EN_8822B) & BIT_MASK_BT_EISR_EN_8822B)
+
+#define BIT_BT_ACT_FALLING_ISR_8822B BIT(10)
+#define BIT_BT_ACT_RISING_ISR_8822B BIT(9)
+#define BIT_TDMA_TO_ISR_8822B BIT(8)
+
+#define BIT_SHIFT_BT_CH_8822B 0
+#define BIT_MASK_BT_CH_8822B 0xff
+#define BIT_BT_CH_8822B(x)                                                     \
+	(((x) & BIT_MASK_BT_CH_8822B) << BIT_SHIFT_BT_CH_8822B)
+#define BIT_GET_BT_CH_8822B(x)                                                 \
+	(((x) >> BIT_SHIFT_BT_CH_8822B) & BIT_MASK_BT_CH_8822B)
+
+/* 2 REG_OBFF_CTRL_BASIC_8822B */
+#define BIT_OBFF_EN_V1_8822B BIT(31)
+
+#define BIT_SHIFT_OBFF_STATE_V1_8822B 28
+#define BIT_MASK_OBFF_STATE_V1_8822B 0x3
+#define BIT_OBFF_STATE_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_OBFF_STATE_V1_8822B) << BIT_SHIFT_OBFF_STATE_V1_8822B)
+#define BIT_GET_OBFF_STATE_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_OBFF_STATE_V1_8822B) & BIT_MASK_OBFF_STATE_V1_8822B)
+
+#define BIT_OBFF_ACT_RXDMA_EN_8822B BIT(27)
+#define BIT_OBFF_BLOCK_INT_EN_8822B BIT(26)
+#define BIT_OBFF_AUTOACT_EN_8822B BIT(25)
+#define BIT_OBFF_AUTOIDLE_EN_8822B BIT(24)
+
+#define BIT_SHIFT_WAKE_MAX_PLS_8822B 20
+#define BIT_MASK_WAKE_MAX_PLS_8822B 0x7
+#define BIT_WAKE_MAX_PLS_8822B(x)                                              \
+	(((x) & BIT_MASK_WAKE_MAX_PLS_8822B) << BIT_SHIFT_WAKE_MAX_PLS_8822B)
+#define BIT_GET_WAKE_MAX_PLS_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_WAKE_MAX_PLS_8822B) & BIT_MASK_WAKE_MAX_PLS_8822B)
+
+#define BIT_SHIFT_WAKE_MIN_PLS_8822B 16
+#define BIT_MASK_WAKE_MIN_PLS_8822B 0x7
+#define BIT_WAKE_MIN_PLS_8822B(x)                                              \
+	(((x) & BIT_MASK_WAKE_MIN_PLS_8822B) << BIT_SHIFT_WAKE_MIN_PLS_8822B)
+#define BIT_GET_WAKE_MIN_PLS_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_WAKE_MIN_PLS_8822B) & BIT_MASK_WAKE_MIN_PLS_8822B)
+
+#define BIT_SHIFT_WAKE_MAX_F2F_8822B 12
+#define BIT_MASK_WAKE_MAX_F2F_8822B 0x7
+#define BIT_WAKE_MAX_F2F_8822B(x)                                              \
+	(((x) & BIT_MASK_WAKE_MAX_F2F_8822B) << BIT_SHIFT_WAKE_MAX_F2F_8822B)
+#define BIT_GET_WAKE_MAX_F2F_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_WAKE_MAX_F2F_8822B) & BIT_MASK_WAKE_MAX_F2F_8822B)
+
+#define BIT_SHIFT_WAKE_MIN_F2F_8822B 8
+#define BIT_MASK_WAKE_MIN_F2F_8822B 0x7
+#define BIT_WAKE_MIN_F2F_8822B(x)                                              \
+	(((x) & BIT_MASK_WAKE_MIN_F2F_8822B) << BIT_SHIFT_WAKE_MIN_F2F_8822B)
+#define BIT_GET_WAKE_MIN_F2F_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_WAKE_MIN_F2F_8822B) & BIT_MASK_WAKE_MIN_F2F_8822B)
+
+#define BIT_APP_CPU_ACT_V1_8822B BIT(3)
+#define BIT_APP_OBFF_V1_8822B BIT(2)
+#define BIT_APP_IDLE_V1_8822B BIT(1)
+#define BIT_APP_INIT_V1_8822B BIT(0)
+
+/* 2 REG_OBFF_CTRL2_TIMER_8822B */
+
+#define BIT_SHIFT_RX_HIGH_TIMER_IDX_8822B 24
+#define BIT_MASK_RX_HIGH_TIMER_IDX_8822B 0x7
+#define BIT_RX_HIGH_TIMER_IDX_8822B(x)                                         \
+	(((x) & BIT_MASK_RX_HIGH_TIMER_IDX_8822B)                              \
+	 << BIT_SHIFT_RX_HIGH_TIMER_IDX_8822B)
+#define BIT_GET_RX_HIGH_TIMER_IDX_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_RX_HIGH_TIMER_IDX_8822B) &                          \
+	 BIT_MASK_RX_HIGH_TIMER_IDX_8822B)
+
+#define BIT_SHIFT_RX_MED_TIMER_IDX_8822B 16
+#define BIT_MASK_RX_MED_TIMER_IDX_8822B 0x7
+#define BIT_RX_MED_TIMER_IDX_8822B(x)                                          \
+	(((x) & BIT_MASK_RX_MED_TIMER_IDX_8822B)                               \
+	 << BIT_SHIFT_RX_MED_TIMER_IDX_8822B)
+#define BIT_GET_RX_MED_TIMER_IDX_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_RX_MED_TIMER_IDX_8822B) &                           \
+	 BIT_MASK_RX_MED_TIMER_IDX_8822B)
+
+#define BIT_SHIFT_RX_LOW_TIMER_IDX_8822B 8
+#define BIT_MASK_RX_LOW_TIMER_IDX_8822B 0x7
+#define BIT_RX_LOW_TIMER_IDX_8822B(x)                                          \
+	(((x) & BIT_MASK_RX_LOW_TIMER_IDX_8822B)                               \
+	 << BIT_SHIFT_RX_LOW_TIMER_IDX_8822B)
+#define BIT_GET_RX_LOW_TIMER_IDX_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_RX_LOW_TIMER_IDX_8822B) &                           \
+	 BIT_MASK_RX_LOW_TIMER_IDX_8822B)
+
+#define BIT_SHIFT_OBFF_INT_TIMER_IDX_8822B 0
+#define BIT_MASK_OBFF_INT_TIMER_IDX_8822B 0x7
+#define BIT_OBFF_INT_TIMER_IDX_8822B(x)                                        \
+	(((x) & BIT_MASK_OBFF_INT_TIMER_IDX_8822B)                             \
+	 << BIT_SHIFT_OBFF_INT_TIMER_IDX_8822B)
+#define BIT_GET_OBFF_INT_TIMER_IDX_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_OBFF_INT_TIMER_IDX_8822B) &                         \
+	 BIT_MASK_OBFF_INT_TIMER_IDX_8822B)
+
+/* 2 REG_LTR_CTRL_BASIC_8822B */
+#define BIT_LTR_EN_V1_8822B BIT(31)
+#define BIT_LTR_HW_EN_V1_8822B BIT(30)
+#define BIT_LRT_ACT_CTS_EN_8822B BIT(29)
+#define BIT_LTR_ACT_RXPKT_EN_8822B BIT(28)
+#define BIT_LTR_ACT_RXDMA_EN_8822B BIT(27)
+#define BIT_LTR_IDLE_NO_SNOOP_8822B BIT(26)
+#define BIT_SPDUP_MGTPKT_8822B BIT(25)
+#define BIT_RX_AGG_EN_8822B BIT(24)
+#define BIT_APP_LTR_ACT_8822B BIT(23)
+#define BIT_APP_LTR_IDLE_8822B BIT(22)
+
+#define BIT_SHIFT_HIGH_RATE_TRIG_SEL_8822B 20
+#define BIT_MASK_HIGH_RATE_TRIG_SEL_8822B 0x3
+#define BIT_HIGH_RATE_TRIG_SEL_8822B(x)                                        \
+	(((x) & BIT_MASK_HIGH_RATE_TRIG_SEL_8822B)                             \
+	 << BIT_SHIFT_HIGH_RATE_TRIG_SEL_8822B)
+#define BIT_GET_HIGH_RATE_TRIG_SEL_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_HIGH_RATE_TRIG_SEL_8822B) &                         \
+	 BIT_MASK_HIGH_RATE_TRIG_SEL_8822B)
+
+#define BIT_SHIFT_MED_RATE_TRIG_SEL_8822B 18
+#define BIT_MASK_MED_RATE_TRIG_SEL_8822B 0x3
+#define BIT_MED_RATE_TRIG_SEL_8822B(x)                                         \
+	(((x) & BIT_MASK_MED_RATE_TRIG_SEL_8822B)                              \
+	 << BIT_SHIFT_MED_RATE_TRIG_SEL_8822B)
+#define BIT_GET_MED_RATE_TRIG_SEL_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_MED_RATE_TRIG_SEL_8822B) &                          \
+	 BIT_MASK_MED_RATE_TRIG_SEL_8822B)
+
+#define BIT_SHIFT_LOW_RATE_TRIG_SEL_8822B 16
+#define BIT_MASK_LOW_RATE_TRIG_SEL_8822B 0x3
+#define BIT_LOW_RATE_TRIG_SEL_8822B(x)                                         \
+	(((x) & BIT_MASK_LOW_RATE_TRIG_SEL_8822B)                              \
+	 << BIT_SHIFT_LOW_RATE_TRIG_SEL_8822B)
+#define BIT_GET_LOW_RATE_TRIG_SEL_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_LOW_RATE_TRIG_SEL_8822B) &                          \
+	 BIT_MASK_LOW_RATE_TRIG_SEL_8822B)
+
+#define BIT_SHIFT_HIGH_RATE_BD_IDX_8822B 8
+#define BIT_MASK_HIGH_RATE_BD_IDX_8822B 0x7f
+#define BIT_HIGH_RATE_BD_IDX_8822B(x)                                          \
+	(((x) & BIT_MASK_HIGH_RATE_BD_IDX_8822B)                               \
+	 << BIT_SHIFT_HIGH_RATE_BD_IDX_8822B)
+#define BIT_GET_HIGH_RATE_BD_IDX_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_HIGH_RATE_BD_IDX_8822B) &                           \
+	 BIT_MASK_HIGH_RATE_BD_IDX_8822B)
+
+#define BIT_SHIFT_LOW_RATE_BD_IDX_8822B 0
+#define BIT_MASK_LOW_RATE_BD_IDX_8822B 0x7f
+#define BIT_LOW_RATE_BD_IDX_8822B(x)                                           \
+	(((x) & BIT_MASK_LOW_RATE_BD_IDX_8822B)                                \
+	 << BIT_SHIFT_LOW_RATE_BD_IDX_8822B)
+#define BIT_GET_LOW_RATE_BD_IDX_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_LOW_RATE_BD_IDX_8822B) &                            \
+	 BIT_MASK_LOW_RATE_BD_IDX_8822B)
+
+/* 2 REG_LTR_CTRL2_TIMER_THRESHOLD_8822B */
+
+#define BIT_SHIFT_RX_EMPTY_TIMER_IDX_8822B 24
+#define BIT_MASK_RX_EMPTY_TIMER_IDX_8822B 0x7
+#define BIT_RX_EMPTY_TIMER_IDX_8822B(x)                                        \
+	(((x) & BIT_MASK_RX_EMPTY_TIMER_IDX_8822B)                             \
+	 << BIT_SHIFT_RX_EMPTY_TIMER_IDX_8822B)
+#define BIT_GET_RX_EMPTY_TIMER_IDX_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_RX_EMPTY_TIMER_IDX_8822B) &                         \
+	 BIT_MASK_RX_EMPTY_TIMER_IDX_8822B)
+
+#define BIT_SHIFT_RX_AFULL_TH_IDX_8822B 20
+#define BIT_MASK_RX_AFULL_TH_IDX_8822B 0x7
+#define BIT_RX_AFULL_TH_IDX_8822B(x)                                           \
+	(((x) & BIT_MASK_RX_AFULL_TH_IDX_8822B)                                \
+	 << BIT_SHIFT_RX_AFULL_TH_IDX_8822B)
+#define BIT_GET_RX_AFULL_TH_IDX_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_RX_AFULL_TH_IDX_8822B) &                            \
+	 BIT_MASK_RX_AFULL_TH_IDX_8822B)
+
+#define BIT_SHIFT_RX_HIGH_TH_IDX_8822B 16
+#define BIT_MASK_RX_HIGH_TH_IDX_8822B 0x7
+#define BIT_RX_HIGH_TH_IDX_8822B(x)                                            \
+	(((x) & BIT_MASK_RX_HIGH_TH_IDX_8822B)                                 \
+	 << BIT_SHIFT_RX_HIGH_TH_IDX_8822B)
+#define BIT_GET_RX_HIGH_TH_IDX_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_RX_HIGH_TH_IDX_8822B) &                             \
+	 BIT_MASK_RX_HIGH_TH_IDX_8822B)
+
+#define BIT_SHIFT_RX_MED_TH_IDX_8822B 12
+#define BIT_MASK_RX_MED_TH_IDX_8822B 0x7
+#define BIT_RX_MED_TH_IDX_8822B(x)                                             \
+	(((x) & BIT_MASK_RX_MED_TH_IDX_8822B) << BIT_SHIFT_RX_MED_TH_IDX_8822B)
+#define BIT_GET_RX_MED_TH_IDX_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_RX_MED_TH_IDX_8822B) & BIT_MASK_RX_MED_TH_IDX_8822B)
+
+#define BIT_SHIFT_RX_LOW_TH_IDX_8822B 8
+#define BIT_MASK_RX_LOW_TH_IDX_8822B 0x7
+#define BIT_RX_LOW_TH_IDX_8822B(x)                                             \
+	(((x) & BIT_MASK_RX_LOW_TH_IDX_8822B) << BIT_SHIFT_RX_LOW_TH_IDX_8822B)
+#define BIT_GET_RX_LOW_TH_IDX_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_RX_LOW_TH_IDX_8822B) & BIT_MASK_RX_LOW_TH_IDX_8822B)
+
+#define BIT_SHIFT_LTR_SPACE_IDX_8822B 4
+#define BIT_MASK_LTR_SPACE_IDX_8822B 0x3
+#define BIT_LTR_SPACE_IDX_8822B(x)                                             \
+	(((x) & BIT_MASK_LTR_SPACE_IDX_8822B) << BIT_SHIFT_LTR_SPACE_IDX_8822B)
+#define BIT_GET_LTR_SPACE_IDX_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_LTR_SPACE_IDX_8822B) & BIT_MASK_LTR_SPACE_IDX_8822B)
+
+#define BIT_SHIFT_LTR_IDLE_TIMER_IDX_8822B 0
+#define BIT_MASK_LTR_IDLE_TIMER_IDX_8822B 0x7
+#define BIT_LTR_IDLE_TIMER_IDX_8822B(x)                                        \
+	(((x) & BIT_MASK_LTR_IDLE_TIMER_IDX_8822B)                             \
+	 << BIT_SHIFT_LTR_IDLE_TIMER_IDX_8822B)
+#define BIT_GET_LTR_IDLE_TIMER_IDX_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_LTR_IDLE_TIMER_IDX_8822B) &                         \
+	 BIT_MASK_LTR_IDLE_TIMER_IDX_8822B)
+
+/* 2 REG_LTR_IDLE_LATENCY_V1_8822B */
+
+#define BIT_SHIFT_LTR_IDLE_L_8822B 0
+#define BIT_MASK_LTR_IDLE_L_8822B 0xffffffffL
+#define BIT_LTR_IDLE_L_8822B(x)                                                \
+	(((x) & BIT_MASK_LTR_IDLE_L_8822B) << BIT_SHIFT_LTR_IDLE_L_8822B)
+#define BIT_GET_LTR_IDLE_L_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_LTR_IDLE_L_8822B) & BIT_MASK_LTR_IDLE_L_8822B)
+
+/* 2 REG_LTR_ACTIVE_LATENCY_V1_8822B */
+
+#define BIT_SHIFT_LTR_ACT_L_8822B 0
+#define BIT_MASK_LTR_ACT_L_8822B 0xffffffffL
+#define BIT_LTR_ACT_L_8822B(x)                                                 \
+	(((x) & BIT_MASK_LTR_ACT_L_8822B) << BIT_SHIFT_LTR_ACT_L_8822B)
+#define BIT_GET_LTR_ACT_L_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_LTR_ACT_L_8822B) & BIT_MASK_LTR_ACT_L_8822B)
+
+/* 2 REG_ANTENNA_TRAINING_CONTROL_REGISTER_8822B */
+#define BIT_APPEND_MACID_IN_RESP_EN_8822B BIT(50)
+#define BIT_ADDR2_MATCH_EN_8822B BIT(49)
+#define BIT_ANTTRN_EN_8822B BIT(48)
+
+#define BIT_SHIFT_TRAIN_STA_ADDR_8822B 0
+#define BIT_MASK_TRAIN_STA_ADDR_8822B 0xffffffffffffL
+#define BIT_TRAIN_STA_ADDR_8822B(x)                                            \
+	(((x) & BIT_MASK_TRAIN_STA_ADDR_8822B)                                 \
+	 << BIT_SHIFT_TRAIN_STA_ADDR_8822B)
+#define BIT_GET_TRAIN_STA_ADDR_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_TRAIN_STA_ADDR_8822B) &                             \
+	 BIT_MASK_TRAIN_STA_ADDR_8822B)
+
+/* 2 REG_RSVD_0X7B4_8822B */
+
+/* 2 REG_WMAC_PKTCNT_RWD_8822B */
+
+#define BIT_SHIFT_PKTCNT_BSSIDMAP_8822B 4
+#define BIT_MASK_PKTCNT_BSSIDMAP_8822B 0xf
+#define BIT_PKTCNT_BSSIDMAP_8822B(x)                                           \
+	(((x) & BIT_MASK_PKTCNT_BSSIDMAP_8822B)                                \
+	 << BIT_SHIFT_PKTCNT_BSSIDMAP_8822B)
+#define BIT_GET_PKTCNT_BSSIDMAP_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_PKTCNT_BSSIDMAP_8822B) &                            \
+	 BIT_MASK_PKTCNT_BSSIDMAP_8822B)
+
+#define BIT_PKTCNT_CNTRST_8822B BIT(1)
+#define BIT_PKTCNT_CNTEN_8822B BIT(0)
+
+/* 2 REG_WMAC_PKTCNT_CTRL_8822B */
+#define BIT_WMAC_PKTCNT_TRST_8822B BIT(9)
+#define BIT_WMAC_PKTCNT_FEN_8822B BIT(8)
+
+#define BIT_SHIFT_WMAC_PKTCNT_CFGAD_8822B 0
+#define BIT_MASK_WMAC_PKTCNT_CFGAD_8822B 0xff
+#define BIT_WMAC_PKTCNT_CFGAD_8822B(x)                                         \
+	(((x) & BIT_MASK_WMAC_PKTCNT_CFGAD_8822B)                              \
+	 << BIT_SHIFT_WMAC_PKTCNT_CFGAD_8822B)
+#define BIT_GET_WMAC_PKTCNT_CFGAD_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_WMAC_PKTCNT_CFGAD_8822B) &                          \
+	 BIT_MASK_WMAC_PKTCNT_CFGAD_8822B)
+
+/* 2 REG_IQ_DUMP_8822B */
+
+#define BIT_SHIFT_R_WMAC_MATCH_REF_MAC_8822B (64 & CPU_OPT_WIDTH)
+#define BIT_MASK_R_WMAC_MATCH_REF_MAC_8822B 0xffffffffL
+#define BIT_R_WMAC_MATCH_REF_MAC_8822B(x)                                      \
+	(((x) & BIT_MASK_R_WMAC_MATCH_REF_MAC_8822B)                           \
+	 << BIT_SHIFT_R_WMAC_MATCH_REF_MAC_8822B)
+#define BIT_GET_R_WMAC_MATCH_REF_MAC_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_R_WMAC_MATCH_REF_MAC_8822B) &                       \
+	 BIT_MASK_R_WMAC_MATCH_REF_MAC_8822B)
+
+#define BIT_SHIFT_R_WMAC_MASK_LA_MAC_8822B (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_R_WMAC_MASK_LA_MAC_8822B 0xffffffffL
+#define BIT_R_WMAC_MASK_LA_MAC_8822B(x)                                        \
+	(((x) & BIT_MASK_R_WMAC_MASK_LA_MAC_8822B)                             \
+	 << BIT_SHIFT_R_WMAC_MASK_LA_MAC_8822B)
+#define BIT_GET_R_WMAC_MASK_LA_MAC_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_R_WMAC_MASK_LA_MAC_8822B) &                         \
+	 BIT_MASK_R_WMAC_MASK_LA_MAC_8822B)
+
+#define BIT_SHIFT_DUMP_OK_ADDR_8822B 15
+#define BIT_MASK_DUMP_OK_ADDR_8822B 0x1ffff
+#define BIT_DUMP_OK_ADDR_8822B(x)                                              \
+	(((x) & BIT_MASK_DUMP_OK_ADDR_8822B) << BIT_SHIFT_DUMP_OK_ADDR_8822B)
+#define BIT_GET_DUMP_OK_ADDR_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_DUMP_OK_ADDR_8822B) & BIT_MASK_DUMP_OK_ADDR_8822B)
+
+#define BIT_SHIFT_R_TRIG_TIME_SEL_8822B 8
+#define BIT_MASK_R_TRIG_TIME_SEL_8822B 0x7f
+#define BIT_R_TRIG_TIME_SEL_8822B(x)                                           \
+	(((x) & BIT_MASK_R_TRIG_TIME_SEL_8822B)                                \
+	 << BIT_SHIFT_R_TRIG_TIME_SEL_8822B)
+#define BIT_GET_R_TRIG_TIME_SEL_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_R_TRIG_TIME_SEL_8822B) &                            \
+	 BIT_MASK_R_TRIG_TIME_SEL_8822B)
+
+#define BIT_SHIFT_R_MAC_TRIG_SEL_8822B 6
+#define BIT_MASK_R_MAC_TRIG_SEL_8822B 0x3
+#define BIT_R_MAC_TRIG_SEL_8822B(x)                                            \
+	(((x) & BIT_MASK_R_MAC_TRIG_SEL_8822B)                                 \
+	 << BIT_SHIFT_R_MAC_TRIG_SEL_8822B)
+#define BIT_GET_R_MAC_TRIG_SEL_8822B(x)                                        \
+	(((x) >> BIT_SHIFT_R_MAC_TRIG_SEL_8822B) &                             \
+	 BIT_MASK_R_MAC_TRIG_SEL_8822B)
+
+#define BIT_MAC_TRIG_REG_8822B BIT(5)
+
+#define BIT_SHIFT_R_LEVEL_PULSE_SEL_8822B 3
+#define BIT_MASK_R_LEVEL_PULSE_SEL_8822B 0x3
+#define BIT_R_LEVEL_PULSE_SEL_8822B(x)                                         \
+	(((x) & BIT_MASK_R_LEVEL_PULSE_SEL_8822B)                              \
+	 << BIT_SHIFT_R_LEVEL_PULSE_SEL_8822B)
+#define BIT_GET_R_LEVEL_PULSE_SEL_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_R_LEVEL_PULSE_SEL_8822B) &                          \
+	 BIT_MASK_R_LEVEL_PULSE_SEL_8822B)
+
+#define BIT_EN_LA_MAC_8822B BIT(2)
+#define BIT_R_EN_IQDUMP_8822B BIT(1)
+#define BIT_R_IQDATA_DUMP_8822B BIT(0)
+
+/* 2 REG_WMAC_FTM_CTL_8822B */
+#define BIT_RXFTM_TXACK_SC_8822B BIT(6)
+#define BIT_RXFTM_TXACK_BW_8822B BIT(5)
+#define BIT_RXFTM_EN_8822B BIT(3)
+#define BIT_RXFTMREQ_BYDRV_8822B BIT(2)
+#define BIT_RXFTMREQ_EN_8822B BIT(1)
+#define BIT_FTM_EN_8822B BIT(0)
+
+/* 2 REG_WMAC_IQ_MDPK_FUNC_8822B */
+
+/* 2 REG_WMAC_OPTION_FUNCTION_8822B */
+
+#define BIT_SHIFT_R_WMAC_RX_FIL_LEN_8822B (64 & CPU_OPT_WIDTH)
+#define BIT_MASK_R_WMAC_RX_FIL_LEN_8822B 0xffff
+#define BIT_R_WMAC_RX_FIL_LEN_8822B(x)                                         \
+	(((x) & BIT_MASK_R_WMAC_RX_FIL_LEN_8822B)                              \
+	 << BIT_SHIFT_R_WMAC_RX_FIL_LEN_8822B)
+#define BIT_GET_R_WMAC_RX_FIL_LEN_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_R_WMAC_RX_FIL_LEN_8822B) &                          \
+	 BIT_MASK_R_WMAC_RX_FIL_LEN_8822B)
+
+#define BIT_SHIFT_R_WMAC_RXFIFO_FULL_TH_8822B (56 & CPU_OPT_WIDTH)
+#define BIT_MASK_R_WMAC_RXFIFO_FULL_TH_8822B 0xff
+#define BIT_R_WMAC_RXFIFO_FULL_TH_8822B(x)                                     \
+	(((x) & BIT_MASK_R_WMAC_RXFIFO_FULL_TH_8822B)                          \
+	 << BIT_SHIFT_R_WMAC_RXFIFO_FULL_TH_8822B)
+#define BIT_GET_R_WMAC_RXFIFO_FULL_TH_8822B(x)                                 \
+	(((x) >> BIT_SHIFT_R_WMAC_RXFIFO_FULL_TH_8822B) &                      \
+	 BIT_MASK_R_WMAC_RXFIFO_FULL_TH_8822B)
+
+#define BIT_R_WMAC_RX_SYNCFIFO_SYNC_8822B BIT(55)
+#define BIT_R_WMAC_RXRST_DLY_8822B BIT(54)
+#define BIT_R_WMAC_SRCH_TXRPT_REF_DROP_8822B BIT(53)
+#define BIT_R_WMAC_SRCH_TXRPT_UA1_8822B BIT(52)
+#define BIT_R_WMAC_SRCH_TXRPT_TYPE_8822B BIT(51)
+#define BIT_R_WMAC_NDP_RST_8822B BIT(50)
+#define BIT_R_WMAC_POWINT_EN_8822B BIT(49)
+#define BIT_R_WMAC_SRCH_TXRPT_PERPKT_8822B BIT(48)
+#define BIT_R_WMAC_SRCH_TXRPT_MID_8822B BIT(47)
+#define BIT_R_WMAC_PFIN_TOEN_8822B BIT(46)
+#define BIT_R_WMAC_FIL_SECERR_8822B BIT(45)
+#define BIT_R_WMAC_FIL_CTLPKTLEN_8822B BIT(44)
+#define BIT_R_WMAC_FIL_FCTYPE_8822B BIT(43)
+#define BIT_R_WMAC_FIL_FCPROVER_8822B BIT(42)
+#define BIT_R_WMAC_PHYSTS_SNIF_8822B BIT(41)
+#define BIT_R_WMAC_PHYSTS_PLCP_8822B BIT(40)
+#define BIT_R_MAC_TCR_VBONF_RD_8822B BIT(39)
+#define BIT_R_WMAC_TCR_MPAR_NDP_8822B BIT(38)
+#define BIT_R_WMAC_NDP_FILTER_8822B BIT(37)
+#define BIT_R_WMAC_RXLEN_SEL_8822B BIT(36)
+#define BIT_R_WMAC_RXLEN_SEL1_8822B BIT(35)
+#define BIT_R_OFDM_FILTER_8822B BIT(34)
+#define BIT_R_WMAC_CHK_OFDM_LEN_8822B BIT(33)
+#define BIT_R_WMAC_CHK_CCK_LEN_8822B BIT(32)
+
+#define BIT_SHIFT_R_OFDM_LEN_8822B 26
+#define BIT_MASK_R_OFDM_LEN_8822B 0x3f
+#define BIT_R_OFDM_LEN_8822B(x)                                                \
+	(((x) & BIT_MASK_R_OFDM_LEN_8822B) << BIT_SHIFT_R_OFDM_LEN_8822B)
+#define BIT_GET_R_OFDM_LEN_8822B(x)                                            \
+	(((x) >> BIT_SHIFT_R_OFDM_LEN_8822B) & BIT_MASK_R_OFDM_LEN_8822B)
+
+#define BIT_SHIFT_R_CCK_LEN_8822B 0
+#define BIT_MASK_R_CCK_LEN_8822B 0xffff
+#define BIT_R_CCK_LEN_8822B(x)                                                 \
+	(((x) & BIT_MASK_R_CCK_LEN_8822B) << BIT_SHIFT_R_CCK_LEN_8822B)
+#define BIT_GET_R_CCK_LEN_8822B(x)                                             \
+	(((x) >> BIT_SHIFT_R_CCK_LEN_8822B) & BIT_MASK_R_CCK_LEN_8822B)
+
+/* 2 REG_RX_FILTER_FUNCTION_8822B */
+#define BIT_R_WMAC_MHRDDY_LATCH_8822B BIT(14)
+#define BIT_R_WMAC_MHRDDY_CLR_8822B BIT(13)
+#define BIT_R_RXPKTCTL_FSM_BASED_MPDURDY1_8822B BIT(12)
+#define BIT_WMAC_DIS_VHT_PLCP_CHK_MU_8822B BIT(11)
+#define BIT_R_CHK_DELIMIT_LEN_8822B BIT(10)
+#define BIT_R_REAPTER_ADDR_MATCH_8822B BIT(9)
+#define BIT_R_RXPKTCTL_FSM_BASED_MPDURDY_8822B BIT(8)
+#define BIT_R_LATCH_MACHRDY_8822B BIT(7)
+#define BIT_R_WMAC_RXFIL_REND_8822B BIT(6)
+#define BIT_R_WMAC_MPDURDY_CLR_8822B BIT(5)
+#define BIT_R_WMAC_CLRRXSEC_8822B BIT(4)
+#define BIT_R_WMAC_RXFIL_RDEL_8822B BIT(3)
+#define BIT_R_WMAC_RXFIL_FCSE_8822B BIT(2)
+#define BIT_R_WMAC_RXFIL_MESH_DEL_8822B BIT(1)
+#define BIT_R_WMAC_RXFIL_MASKM_8822B BIT(0)
+
+/* 2 REG_NDP_SIG_8822B */
+
+#define BIT_SHIFT_R_WMAC_TXNDP_SIGB_8822B 0
+#define BIT_MASK_R_WMAC_TXNDP_SIGB_8822B 0x1fffff
+#define BIT_R_WMAC_TXNDP_SIGB_8822B(x)                                         \
+	(((x) & BIT_MASK_R_WMAC_TXNDP_SIGB_8822B)                              \
+	 << BIT_SHIFT_R_WMAC_TXNDP_SIGB_8822B)
+#define BIT_GET_R_WMAC_TXNDP_SIGB_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_R_WMAC_TXNDP_SIGB_8822B) &                          \
+	 BIT_MASK_R_WMAC_TXNDP_SIGB_8822B)
+
+/* 2 REG_TXCMD_INFO_FOR_RSP_PKT_8822B */
+
+#define BIT_SHIFT_R_MAC_DEBUG_8822B (32 & CPU_OPT_WIDTH)
+#define BIT_MASK_R_MAC_DEBUG_8822B 0xffffffffL
+#define BIT_R_MAC_DEBUG_8822B(x)                                               \
+	(((x) & BIT_MASK_R_MAC_DEBUG_8822B) << BIT_SHIFT_R_MAC_DEBUG_8822B)
+#define BIT_GET_R_MAC_DEBUG_8822B(x)                                           \
+	(((x) >> BIT_SHIFT_R_MAC_DEBUG_8822B) & BIT_MASK_R_MAC_DEBUG_8822B)
+
+#define BIT_SHIFT_R_MAC_DBG_SHIFT_8822B 8
+#define BIT_MASK_R_MAC_DBG_SHIFT_8822B 0x7
+#define BIT_R_MAC_DBG_SHIFT_8822B(x)                                           \
+	(((x) & BIT_MASK_R_MAC_DBG_SHIFT_8822B)                                \
+	 << BIT_SHIFT_R_MAC_DBG_SHIFT_8822B)
+#define BIT_GET_R_MAC_DBG_SHIFT_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_R_MAC_DBG_SHIFT_8822B) &                            \
+	 BIT_MASK_R_MAC_DBG_SHIFT_8822B)
+
+#define BIT_SHIFT_R_MAC_DBG_SEL_8822B 0
+#define BIT_MASK_R_MAC_DBG_SEL_8822B 0x3
+#define BIT_R_MAC_DBG_SEL_8822B(x)                                             \
+	(((x) & BIT_MASK_R_MAC_DBG_SEL_8822B) << BIT_SHIFT_R_MAC_DBG_SEL_8822B)
+#define BIT_GET_R_MAC_DBG_SEL_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_R_MAC_DBG_SEL_8822B) & BIT_MASK_R_MAC_DBG_SEL_8822B)
+
+/* 2 REG_RTS_ADDRESS_0_8822B */
+
+/* 2 REG_RTS_ADDRESS_1_8822B */
+
+/* 2 REG__RPFM_MAP1_8822B
+ * (RX PAYLOAD FILTER MAP FRAME TYPE CONTROL REGISTER GROUP 1
+ */
+#define BIT_DATA_RPFM15EN_8822B BIT(15)
+#define BIT_DATA_RPFM14EN_8822B BIT(14)
+#define BIT_DATA_RPFM13EN_8822B BIT(13)
+#define BIT_DATA_RPFM12EN_8822B BIT(12)
+#define BIT_DATA_RPFM11EN_8822B BIT(11)
+#define BIT_DATA_RPFM10EN_8822B BIT(10)
+#define BIT_DATA_RPFM9EN_8822B BIT(9)
+#define BIT_DATA_RPFM8EN_8822B BIT(8)
+#define BIT_DATA_RPFM7EN_8822B BIT(7)
+#define BIT_DATA_RPFM6EN_8822B BIT(6)
+#define BIT_DATA_RPFM5EN_8822B BIT(5)
+#define BIT_DATA_RPFM4EN_8822B BIT(4)
+#define BIT_DATA_RPFM3EN_8822B BIT(3)
+#define BIT_DATA_RPFM2EN_8822B BIT(2)
+#define BIT_DATA_RPFM1EN_8822B BIT(1)
+#define BIT_DATA_RPFM0EN_8822B BIT(0)
+
+/* 2 REG_WL2LTECOEX_INDIRECT_ACCESS_CTRL_V1_8822B */
+#define BIT_LTECOEX_ACCESS_START_V1_8822B BIT(31)
+#define BIT_LTECOEX_WRITE_MODE_V1_8822B BIT(30)
+#define BIT_LTECOEX_READY_BIT_V1_8822B BIT(29)
+
+#define BIT_SHIFT_WRITE_BYTE_EN_V1_8822B 16
+#define BIT_MASK_WRITE_BYTE_EN_V1_8822B 0xf
+#define BIT_WRITE_BYTE_EN_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_WRITE_BYTE_EN_V1_8822B)                               \
+	 << BIT_SHIFT_WRITE_BYTE_EN_V1_8822B)
+#define BIT_GET_WRITE_BYTE_EN_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_WRITE_BYTE_EN_V1_8822B) &                           \
+	 BIT_MASK_WRITE_BYTE_EN_V1_8822B)
+
+#define BIT_SHIFT_LTECOEX_REG_ADDR_V1_8822B 0
+#define BIT_MASK_LTECOEX_REG_ADDR_V1_8822B 0xffff
+#define BIT_LTECOEX_REG_ADDR_V1_8822B(x)                                       \
+	(((x) & BIT_MASK_LTECOEX_REG_ADDR_V1_8822B)                            \
+	 << BIT_SHIFT_LTECOEX_REG_ADDR_V1_8822B)
+#define BIT_GET_LTECOEX_REG_ADDR_V1_8822B(x)                                   \
+	(((x) >> BIT_SHIFT_LTECOEX_REG_ADDR_V1_8822B) &                        \
+	 BIT_MASK_LTECOEX_REG_ADDR_V1_8822B)
+
+/* 2 REG_WL2LTECOEX_INDIRECT_ACCESS_WRITE_DATA_V1_8822B */
+
+#define BIT_SHIFT_LTECOEX_W_DATA_V1_8822B 0
+#define BIT_MASK_LTECOEX_W_DATA_V1_8822B 0xffffffffL
+#define BIT_LTECOEX_W_DATA_V1_8822B(x)                                         \
+	(((x) & BIT_MASK_LTECOEX_W_DATA_V1_8822B)                              \
+	 << BIT_SHIFT_LTECOEX_W_DATA_V1_8822B)
+#define BIT_GET_LTECOEX_W_DATA_V1_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_LTECOEX_W_DATA_V1_8822B) &                          \
+	 BIT_MASK_LTECOEX_W_DATA_V1_8822B)
+
+/* 2 REG_WL2LTECOEX_INDIRECT_ACCESS_READ_DATA_V1_8822B */
+
+#define BIT_SHIFT_LTECOEX_R_DATA_V1_8822B 0
+#define BIT_MASK_LTECOEX_R_DATA_V1_8822B 0xffffffffL
+#define BIT_LTECOEX_R_DATA_V1_8822B(x)                                         \
+	(((x) & BIT_MASK_LTECOEX_R_DATA_V1_8822B)                              \
+	 << BIT_SHIFT_LTECOEX_R_DATA_V1_8822B)
+#define BIT_GET_LTECOEX_R_DATA_V1_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_LTECOEX_R_DATA_V1_8822B) &                          \
+	 BIT_MASK_LTECOEX_R_DATA_V1_8822B)
+
+/* 2 REG_NOT_VALID_8822B */
+
+/* 2 REG_SDIO_TX_CTRL_8822B */
+
+#define BIT_SHIFT_SDIO_INT_TIMEOUT_8822B 16
+#define BIT_MASK_SDIO_INT_TIMEOUT_8822B 0xffff
+#define BIT_SDIO_INT_TIMEOUT_8822B(x)                                          \
+	(((x) & BIT_MASK_SDIO_INT_TIMEOUT_8822B)                               \
+	 << BIT_SHIFT_SDIO_INT_TIMEOUT_8822B)
+#define BIT_GET_SDIO_INT_TIMEOUT_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_SDIO_INT_TIMEOUT_8822B) &                           \
+	 BIT_MASK_SDIO_INT_TIMEOUT_8822B)
+
+#define BIT_IO_ERR_STATUS_8822B BIT(15)
+#define BIT_REPLY_ERRCRC_IN_DATA_8822B BIT(9)
+#define BIT_EN_CMD53_OVERLAP_8822B BIT(8)
+#define BIT_REPLY_ERR_IN_R5_8822B BIT(7)
+#define BIT_R18A_EN_8822B BIT(6)
+#define BIT_INIT_CMD_EN_8822B BIT(5)
+#define BIT_EN_RXDMA_MASK_INT_8822B BIT(2)
+#define BIT_EN_MASK_TIMER_8822B BIT(1)
+#define BIT_CMD_ERR_STOP_INT_EN_8822B BIT(0)
+
+/* 2 REG_SDIO_HIMR_8822B */
+#define BIT_SDIO_CRCERR_MSK_8822B BIT(31)
+#define BIT_SDIO_HSISR3_IND_MSK_8822B BIT(30)
+#define BIT_SDIO_HSISR2_IND_MSK_8822B BIT(29)
+#define BIT_SDIO_HEISR_IND_MSK_8822B BIT(28)
+#define BIT_SDIO_CTWEND_MSK_8822B BIT(27)
+#define BIT_SDIO_ATIMEND_E_MSK_8822B BIT(26)
+#define BIT_SDIIO_ATIMEND_MSK_8822B BIT(25)
+#define BIT_SDIO_OCPINT_MSK_8822B BIT(24)
+#define BIT_SDIO_PSTIMEOUT_MSK_8822B BIT(23)
+#define BIT_SDIO_GTINT4_MSK_8822B BIT(22)
+#define BIT_SDIO_GTINT3_MSK_8822B BIT(21)
+#define BIT_SDIO_HSISR_IND_MSK_8822B BIT(20)
+#define BIT_SDIO_CPWM2_MSK_8822B BIT(19)
+#define BIT_SDIO_CPWM1_MSK_8822B BIT(18)
+#define BIT_SDIO_C2HCMD_INT_MSK_8822B BIT(17)
+#define BIT_SDIO_BCNERLY_INT_MSK_8822B BIT(16)
+#define BIT_SDIO_TXBCNERR_MSK_8822B BIT(7)
+#define BIT_SDIO_TXBCNOK_MSK_8822B BIT(6)
+#define BIT_SDIO_RXFOVW_MSK_8822B BIT(5)
+#define BIT_SDIO_TXFOVW_MSK_8822B BIT(4)
+#define BIT_SDIO_RXERR_MSK_8822B BIT(3)
+#define BIT_SDIO_TXERR_MSK_8822B BIT(2)
+#define BIT_SDIO_AVAL_MSK_8822B BIT(1)
+#define BIT_RX_REQUEST_MSK_8822B BIT(0)
+
+/* 2 REG_SDIO_HISR_8822B */
+#define BIT_SDIO_CRCERR_8822B BIT(31)
+#define BIT_SDIO_HSISR3_IND_8822B BIT(30)
+#define BIT_SDIO_HSISR2_IND_8822B BIT(29)
+#define BIT_SDIO_HEISR_IND_8822B BIT(28)
+#define BIT_SDIO_CTWEND_8822B BIT(27)
+#define BIT_SDIO_ATIMEND_E_8822B BIT(26)
+#define BIT_SDIO_ATIMEND_8822B BIT(25)
+#define BIT_SDIO_OCPINT_8822B BIT(24)
+#define BIT_SDIO_PSTIMEOUT_8822B BIT(23)
+#define BIT_SDIO_GTINT4_8822B BIT(22)
+#define BIT_SDIO_GTINT3_8822B BIT(21)
+#define BIT_SDIO_HSISR_IND_8822B BIT(20)
+#define BIT_SDIO_CPWM2_8822B BIT(19)
+#define BIT_SDIO_CPWM1_8822B BIT(18)
+#define BIT_SDIO_C2HCMD_INT_8822B BIT(17)
+#define BIT_SDIO_BCNERLY_INT_8822B BIT(16)
+#define BIT_SDIO_TXBCNERR_8822B BIT(7)
+#define BIT_SDIO_TXBCNOK_8822B BIT(6)
+#define BIT_SDIO_RXFOVW_8822B BIT(5)
+#define BIT_SDIO_TXFOVW_8822B BIT(4)
+#define BIT_SDIO_RXERR_8822B BIT(3)
+#define BIT_SDIO_TXERR_8822B BIT(2)
+#define BIT_SDIO_AVAL_8822B BIT(1)
+#define BIT_RX_REQUEST_8822B BIT(0)
+
+/* 2 REG_SDIO_RX_REQ_LEN_8822B */
+
+#define BIT_SHIFT_RX_REQ_LEN_V1_8822B 0
+#define BIT_MASK_RX_REQ_LEN_V1_8822B 0x3ffff
+#define BIT_RX_REQ_LEN_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_RX_REQ_LEN_V1_8822B) << BIT_SHIFT_RX_REQ_LEN_V1_8822B)
+#define BIT_GET_RX_REQ_LEN_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_RX_REQ_LEN_V1_8822B) & BIT_MASK_RX_REQ_LEN_V1_8822B)
+
+/* 2 REG_SDIO_FREE_TXPG_SEQ_V1_8822B */
+
+#define BIT_SHIFT_FREE_TXPG_SEQ_8822B 0
+#define BIT_MASK_FREE_TXPG_SEQ_8822B 0xff
+#define BIT_FREE_TXPG_SEQ_8822B(x)                                             \
+	(((x) & BIT_MASK_FREE_TXPG_SEQ_8822B) << BIT_SHIFT_FREE_TXPG_SEQ_8822B)
+#define BIT_GET_FREE_TXPG_SEQ_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_FREE_TXPG_SEQ_8822B) & BIT_MASK_FREE_TXPG_SEQ_8822B)
+
+/* 2 REG_SDIO_FREE_TXPG_8822B */
+
+#define BIT_SHIFT_MID_FREEPG_V1_8822B 16
+#define BIT_MASK_MID_FREEPG_V1_8822B 0xfff
+#define BIT_MID_FREEPG_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_MID_FREEPG_V1_8822B) << BIT_SHIFT_MID_FREEPG_V1_8822B)
+#define BIT_GET_MID_FREEPG_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_MID_FREEPG_V1_8822B) & BIT_MASK_MID_FREEPG_V1_8822B)
+
+#define BIT_SHIFT_HIQ_FREEPG_V1_8822B 0
+#define BIT_MASK_HIQ_FREEPG_V1_8822B 0xfff
+#define BIT_HIQ_FREEPG_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_HIQ_FREEPG_V1_8822B) << BIT_SHIFT_HIQ_FREEPG_V1_8822B)
+#define BIT_GET_HIQ_FREEPG_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_HIQ_FREEPG_V1_8822B) & BIT_MASK_HIQ_FREEPG_V1_8822B)
+
+/* 2 REG_SDIO_FREE_TXPG2_8822B */
+
+#define BIT_SHIFT_PUB_FREEPG_V1_8822B 16
+#define BIT_MASK_PUB_FREEPG_V1_8822B 0xfff
+#define BIT_PUB_FREEPG_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_PUB_FREEPG_V1_8822B) << BIT_SHIFT_PUB_FREEPG_V1_8822B)
+#define BIT_GET_PUB_FREEPG_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_PUB_FREEPG_V1_8822B) & BIT_MASK_PUB_FREEPG_V1_8822B)
+
+#define BIT_SHIFT_LOW_FREEPG_V1_8822B 0
+#define BIT_MASK_LOW_FREEPG_V1_8822B 0xfff
+#define BIT_LOW_FREEPG_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_LOW_FREEPG_V1_8822B) << BIT_SHIFT_LOW_FREEPG_V1_8822B)
+#define BIT_GET_LOW_FREEPG_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_LOW_FREEPG_V1_8822B) & BIT_MASK_LOW_FREEPG_V1_8822B)
+
+/* 2 REG_SDIO_OQT_FREE_TXPG_V1_8822B */
+
+#define BIT_SHIFT_NOAC_OQT_FREEPG_V1_8822B 24
+#define BIT_MASK_NOAC_OQT_FREEPG_V1_8822B 0xff
+#define BIT_NOAC_OQT_FREEPG_V1_8822B(x)                                        \
+	(((x) & BIT_MASK_NOAC_OQT_FREEPG_V1_8822B)                             \
+	 << BIT_SHIFT_NOAC_OQT_FREEPG_V1_8822B)
+#define BIT_GET_NOAC_OQT_FREEPG_V1_8822B(x)                                    \
+	(((x) >> BIT_SHIFT_NOAC_OQT_FREEPG_V1_8822B) &                         \
+	 BIT_MASK_NOAC_OQT_FREEPG_V1_8822B)
+
+#define BIT_SHIFT_AC_OQT_FREEPG_V1_8822B 16
+#define BIT_MASK_AC_OQT_FREEPG_V1_8822B 0xff
+#define BIT_AC_OQT_FREEPG_V1_8822B(x)                                          \
+	(((x) & BIT_MASK_AC_OQT_FREEPG_V1_8822B)                               \
+	 << BIT_SHIFT_AC_OQT_FREEPG_V1_8822B)
+#define BIT_GET_AC_OQT_FREEPG_V1_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_AC_OQT_FREEPG_V1_8822B) &                           \
+	 BIT_MASK_AC_OQT_FREEPG_V1_8822B)
+
+#define BIT_SHIFT_EXQ_FREEPG_V1_8822B 0
+#define BIT_MASK_EXQ_FREEPG_V1_8822B 0xfff
+#define BIT_EXQ_FREEPG_V1_8822B(x)                                             \
+	(((x) & BIT_MASK_EXQ_FREEPG_V1_8822B) << BIT_SHIFT_EXQ_FREEPG_V1_8822B)
+#define BIT_GET_EXQ_FREEPG_V1_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_EXQ_FREEPG_V1_8822B) & BIT_MASK_EXQ_FREEPG_V1_8822B)
+
+/* 2 REG_SDIO_HTSFR_INFO_8822B */
+
+#define BIT_SHIFT_HTSFR1_8822B 16
+#define BIT_MASK_HTSFR1_8822B 0xffff
+#define BIT_HTSFR1_8822B(x)                                                    \
+	(((x) & BIT_MASK_HTSFR1_8822B) << BIT_SHIFT_HTSFR1_8822B)
+#define BIT_GET_HTSFR1_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_HTSFR1_8822B) & BIT_MASK_HTSFR1_8822B)
+
+#define BIT_SHIFT_HTSFR0_8822B 0
+#define BIT_MASK_HTSFR0_8822B 0xffff
+#define BIT_HTSFR0_8822B(x)                                                    \
+	(((x) & BIT_MASK_HTSFR0_8822B) << BIT_SHIFT_HTSFR0_8822B)
+#define BIT_GET_HTSFR0_8822B(x)                                                \
+	(((x) >> BIT_SHIFT_HTSFR0_8822B) & BIT_MASK_HTSFR0_8822B)
+
+/* 2 REG_SDIO_HCPWM1_V2_8822B */
+#define BIT_TOGGLING_8822B BIT(7)
+#define BIT_ACK_8822B BIT(6)
+#define BIT_SYS_CLK_8822B BIT(0)
+
+/* 2 REG_SDIO_HCPWM2_V2_8822B */
+
+/* 2 REG_SDIO_INDIRECT_REG_CFG_8822B */
+#define BIT_INDIRECT_REG_RDY_8822B BIT(20)
+#define BIT_INDIRECT_REG_R_8822B BIT(19)
+#define BIT_INDIRECT_REG_W_8822B BIT(18)
+
+#define BIT_SHIFT_INDIRECT_REG_SIZE_8822B 16
+#define BIT_MASK_INDIRECT_REG_SIZE_8822B 0x3
+#define BIT_INDIRECT_REG_SIZE_8822B(x)                                         \
+	(((x) & BIT_MASK_INDIRECT_REG_SIZE_8822B)                              \
+	 << BIT_SHIFT_INDIRECT_REG_SIZE_8822B)
+#define BIT_GET_INDIRECT_REG_SIZE_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_INDIRECT_REG_SIZE_8822B) &                          \
+	 BIT_MASK_INDIRECT_REG_SIZE_8822B)
+
+#define BIT_SHIFT_INDIRECT_REG_ADDR_8822B 0
+#define BIT_MASK_INDIRECT_REG_ADDR_8822B 0xffff
+#define BIT_INDIRECT_REG_ADDR_8822B(x)                                         \
+	(((x) & BIT_MASK_INDIRECT_REG_ADDR_8822B)                              \
+	 << BIT_SHIFT_INDIRECT_REG_ADDR_8822B)
+#define BIT_GET_INDIRECT_REG_ADDR_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_INDIRECT_REG_ADDR_8822B) &                          \
+	 BIT_MASK_INDIRECT_REG_ADDR_8822B)
+
+/* 2 REG_SDIO_INDIRECT_REG_DATA_8822B */
+
+#define BIT_SHIFT_INDIRECT_REG_DATA_8822B 0
+#define BIT_MASK_INDIRECT_REG_DATA_8822B 0xffffffffL
+#define BIT_INDIRECT_REG_DATA_8822B(x)                                         \
+	(((x) & BIT_MASK_INDIRECT_REG_DATA_8822B)                              \
+	 << BIT_SHIFT_INDIRECT_REG_DATA_8822B)
+#define BIT_GET_INDIRECT_REG_DATA_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_INDIRECT_REG_DATA_8822B) &                          \
+	 BIT_MASK_INDIRECT_REG_DATA_8822B)
+
+/* 2 REG_SDIO_H2C_8822B */
+
+#define BIT_SHIFT_SDIO_H2C_MSG_8822B 0
+#define BIT_MASK_SDIO_H2C_MSG_8822B 0xffffffffL
+#define BIT_SDIO_H2C_MSG_8822B(x)                                              \
+	(((x) & BIT_MASK_SDIO_H2C_MSG_8822B) << BIT_SHIFT_SDIO_H2C_MSG_8822B)
+#define BIT_GET_SDIO_H2C_MSG_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_SDIO_H2C_MSG_8822B) & BIT_MASK_SDIO_H2C_MSG_8822B)
+
+/* 2 REG_SDIO_C2H_8822B */
+
+#define BIT_SHIFT_SDIO_C2H_MSG_8822B 0
+#define BIT_MASK_SDIO_C2H_MSG_8822B 0xffffffffL
+#define BIT_SDIO_C2H_MSG_8822B(x)                                              \
+	(((x) & BIT_MASK_SDIO_C2H_MSG_8822B) << BIT_SHIFT_SDIO_C2H_MSG_8822B)
+#define BIT_GET_SDIO_C2H_MSG_8822B(x)                                          \
+	(((x) >> BIT_SHIFT_SDIO_C2H_MSG_8822B) & BIT_MASK_SDIO_C2H_MSG_8822B)
+
+/* 2 REG_SDIO_HRPWM1_8822B */
+#define BIT_TOGGLING_8822B BIT(7)
+#define BIT_ACK_8822B BIT(6)
+#define BIT_32K_PERMISSION_8822B BIT(0)
+
+/* 2 REG_SDIO_HRPWM2_8822B */
+
+/* 2 REG_SDIO_HPS_CLKR_8822B */
+
+/* 2 REG_SDIO_BUS_CTRL_8822B */
+#define BIT_PAD_CLK_XHGE_EN_8822B BIT(3)
+#define BIT_INTER_CLK_EN_8822B BIT(2)
+#define BIT_EN_RPT_TXCRC_8822B BIT(1)
+#define BIT_DIS_RXDMA_STS_8822B BIT(0)
+
+/* 2 REG_SDIO_HSUS_CTRL_8822B */
+#define BIT_INTR_CTRL_8822B BIT(4)
+#define BIT_SDIO_VOLTAGE_8822B BIT(3)
+#define BIT_BYPASS_INIT_8822B BIT(2)
+#define BIT_HCI_RESUME_RDY_8822B BIT(1)
+#define BIT_HCI_SUS_REQ_8822B BIT(0)
+
+/* 2 REG_SDIO_RESPONSE_TIMER_8822B */
+
+#define BIT_SHIFT_CMDIN_2RESP_TIMER_8822B 0
+#define BIT_MASK_CMDIN_2RESP_TIMER_8822B 0xffff
+#define BIT_CMDIN_2RESP_TIMER_8822B(x)                                         \
+	(((x) & BIT_MASK_CMDIN_2RESP_TIMER_8822B)                              \
+	 << BIT_SHIFT_CMDIN_2RESP_TIMER_8822B)
+#define BIT_GET_CMDIN_2RESP_TIMER_8822B(x)                                     \
+	(((x) >> BIT_SHIFT_CMDIN_2RESP_TIMER_8822B) &                          \
+	 BIT_MASK_CMDIN_2RESP_TIMER_8822B)
+
+/* 2 REG_SDIO_CMD_CRC_8822B */
+
+#define BIT_SHIFT_SDIO_CMD_CRC_V1_8822B 0
+#define BIT_MASK_SDIO_CMD_CRC_V1_8822B 0xff
+#define BIT_SDIO_CMD_CRC_V1_8822B(x)                                           \
+	(((x) & BIT_MASK_SDIO_CMD_CRC_V1_8822B)                                \
+	 << BIT_SHIFT_SDIO_CMD_CRC_V1_8822B)
+#define BIT_GET_SDIO_CMD_CRC_V1_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_SDIO_CMD_CRC_V1_8822B) &                            \
+	 BIT_MASK_SDIO_CMD_CRC_V1_8822B)
+
+/* 2 REG_SDIO_HSISR_8822B */
+#define BIT_DRV_WLAN_INT_CLR_8822B BIT(1)
+#define BIT_DRV_WLAN_INT_8822B BIT(0)
+
+/* 2 REG_SDIO_HSIMR_8822B */
+#define BIT_HISR_MASK_8822B BIT(0)
+
+/* 2 REG_SDIO_ERR_RPT_8822B */
+#define BIT_HR_FF_OVF_8822B BIT(6)
+#define BIT_HR_FF_UDN_8822B BIT(5)
+#define BIT_TXDMA_BUSY_ERR_8822B BIT(4)
+#define BIT_TXDMA_VLD_ERR_8822B BIT(3)
+#define BIT_QSEL_UNKNOWN_ERR_8822B BIT(2)
+#define BIT_QSEL_MIS_ERR_8822B BIT(1)
+#define BIT_SDIO_OVERRD_ERR_8822B BIT(0)
+
+/* 2 REG_SDIO_CMD_ERRCNT_8822B */
+
+#define BIT_SHIFT_CMD_CRC_ERR_CNT_8822B 0
+#define BIT_MASK_CMD_CRC_ERR_CNT_8822B 0xff
+#define BIT_CMD_CRC_ERR_CNT_8822B(x)                                           \
+	(((x) & BIT_MASK_CMD_CRC_ERR_CNT_8822B)                                \
+	 << BIT_SHIFT_CMD_CRC_ERR_CNT_8822B)
+#define BIT_GET_CMD_CRC_ERR_CNT_8822B(x)                                       \
+	(((x) >> BIT_SHIFT_CMD_CRC_ERR_CNT_8822B) &                            \
+	 BIT_MASK_CMD_CRC_ERR_CNT_8822B)
+
+/* 2 REG_SDIO_DATA_ERRCNT_8822B */
+
+#define BIT_SHIFT_DATA_CRC_ERR_CNT_8822B 0
+#define BIT_MASK_DATA_CRC_ERR_CNT_8822B 0xff
+#define BIT_DATA_CRC_ERR_CNT_8822B(x)                                          \
+	(((x) & BIT_MASK_DATA_CRC_ERR_CNT_8822B)                               \
+	 << BIT_SHIFT_DATA_CRC_ERR_CNT_8822B)
+#define BIT_GET_DATA_CRC_ERR_CNT_8822B(x)                                      \
+	(((x) >> BIT_SHIFT_DATA_CRC_ERR_CNT_8822B) &                           \
+	 BIT_MASK_DATA_CRC_ERR_CNT_8822B)
+
+/* 2 REG_SDIO_CMD_ERR_CONTENT_8822B */
+
+#define BIT_SHIFT_SDIO_CMD_ERR_CONTENT_8822B 0
+#define BIT_MASK_SDIO_CMD_ERR_CONTENT_8822B 0xffffffffffL
+#define BIT_SDIO_CMD_ERR_CONTENT_8822B(x)                                      \
+	(((x) & BIT_MASK_SDIO_CMD_ERR_CONTENT_8822B)                           \
+	 << BIT_SHIFT_SDIO_CMD_ERR_CONTENT_8822B)
+#define BIT_GET_SDIO_CMD_ERR_CONTENT_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_SDIO_CMD_ERR_CONTENT_8822B) &                       \
+	 BIT_MASK_SDIO_CMD_ERR_CONTENT_8822B)
+
+/* 2 REG_SDIO_CRC_ERR_IDX_8822B */
+#define BIT_D3_CRC_ERR_8822B BIT(4)
+#define BIT_D2_CRC_ERR_8822B BIT(3)
+#define BIT_D1_CRC_ERR_8822B BIT(2)
+#define BIT_D0_CRC_ERR_8822B BIT(1)
+#define BIT_CMD_CRC_ERR_8822B BIT(0)
+
+/* 2 REG_SDIO_DATA_CRC_8822B */
+
+#define BIT_SHIFT_SDIO_DATA_CRC_8822B 0
+#define BIT_MASK_SDIO_DATA_CRC_8822B 0xff
+#define BIT_SDIO_DATA_CRC_8822B(x)                                             \
+	(((x) & BIT_MASK_SDIO_DATA_CRC_8822B) << BIT_SHIFT_SDIO_DATA_CRC_8822B)
+#define BIT_GET_SDIO_DATA_CRC_8822B(x)                                         \
+	(((x) >> BIT_SHIFT_SDIO_DATA_CRC_8822B) & BIT_MASK_SDIO_DATA_CRC_8822B)
+
+/* 2 REG_SDIO_DATA_REPLY_TIME_8822B */
+
+#define BIT_SHIFT_SDIO_DATA_REPLY_TIME_8822B 0
+#define BIT_MASK_SDIO_DATA_REPLY_TIME_8822B 0x7
+#define BIT_SDIO_DATA_REPLY_TIME_8822B(x)                                      \
+	(((x) & BIT_MASK_SDIO_DATA_REPLY_TIME_8822B)                           \
+	 << BIT_SHIFT_SDIO_DATA_REPLY_TIME_8822B)
+#define BIT_GET_SDIO_DATA_REPLY_TIME_8822B(x)                                  \
+	(((x) >> BIT_SHIFT_SDIO_DATA_REPLY_TIME_8822B) &                       \
+	 BIT_MASK_SDIO_DATA_REPLY_TIME_8822B)
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_fw_info.h b/drivers/staging/rtlwifi/halmac/halmac_fw_info.h
new file mode 100644
index 000000000000..dad8be311ff2
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_fw_info.h
@@ -0,0 +1,122 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_FW_INFO_H_
+#define _HALMAC_FW_INFO_H_
+
+#define H2C_FORMAT_VERSION 6
+
+#define H2C_ACK_HDR_CONTENT_LENGTH 8
+#define CFG_PARAMETER_ACK_CONTENT_LENGTH 16
+#define SCAN_STATUS_RPT_CONTENT_LENGTH 4
+#define C2H_DBG_HEADER_LENGTH 4
+#define C2H_DBG_CONTENT_MAX_LENGTH 228
+
+#define C2H_DBG_CONTENT_SEQ_OFFSET 1
+
+/* Rename from FW SysHalCom_Debug_RAM.h */
+#define FW_REG_H2CPKT_DONE_SEQ 0x1C8
+#define fw_reg_wow_reason 0x1C7
+
+enum halmac_data_type {
+	HALMAC_DATA_TYPE_MAC_REG = 0x00,
+	HALMAC_DATA_TYPE_BB_REG = 0x01,
+	HALMAC_DATA_TYPE_RADIO_A = 0x02,
+	HALMAC_DATA_TYPE_RADIO_B = 0x03,
+	HALMAC_DATA_TYPE_RADIO_C = 0x04,
+	HALMAC_DATA_TYPE_RADIO_D = 0x05,
+
+	HALMAC_DATA_TYPE_DRV_DEFINE_0 = 0x80,
+	HALMAC_DATA_TYPE_DRV_DEFINE_1 = 0x81,
+	HALMAC_DATA_TYPE_DRV_DEFINE_2 = 0x82,
+	HALMAC_DATA_TYPE_DRV_DEFINE_3 = 0x83,
+	HALMAC_DATA_TYPE_UNDEFINE = 0x7FFFFFFF,
+};
+
+enum halmac_packet_id {
+	HALMAC_PACKET_PROBE_REQ = 0x00,
+	HALMAC_PACKET_SYNC_BCN = 0x01,
+	HALMAC_PACKET_DISCOVERY_BCN = 0x02,
+
+	HALMAC_PACKET_UNDEFINE = 0x7FFFFFFF,
+};
+
+/* Channel Switch Action ID */
+enum halmac_cs_action_id {
+	HALMAC_CS_ACTION_NONE = 0x00,
+	HALMAC_CS_ACTIVE_SCAN = 0x01,
+	HALMAC_CS_NAN_NONMASTER_DW = 0x02,
+	HALMAC_CS_NAN_NONMASTER_NONDW = 0x03,
+	HALMAC_CS_NAN_MASTER_NONDW = 0x04,
+	HALMAC_CS_NAN_MASTER_DW = 0x05,
+
+	HALMAC_CS_ACTION_UNDEFINE = 0x7FFFFFFF,
+};
+
+/* Channel Switch Extra Action ID */
+enum halmac_cs_extra_action_id {
+	HALMAC_CS_EXTRA_ACTION_NONE = 0x00,
+	HALMAC_CS_EXTRA_UPDATE_PROBE = 0x01,
+	HALMAC_CS_EXTRA_UPDATE_BEACON = 0x02,
+
+	HALMAC_CS_EXTRA_ACTION_UNDEFINE = 0x7FFFFFFF,
+};
+
+enum halmac_h2c_return_code {
+	HALMAC_H2C_RETURN_SUCCESS = 0x00,
+	HALMAC_H2C_RETURN_CFG_ERR_LEN = 0x01,
+	HALMAC_H2C_RETURN_CFG_ERR_CMD = 0x02,
+
+	HALMAC_H2C_RETURN_EFUSE_ERR_DUMP = 0x03,
+
+	HALMAC_H2C_RETURN_DATAPACK_ERR_FULL = 0x04, /* DMEM buffer full */
+	HALMAC_H2C_RETURN_DATAPACK_ERR_ID = 0x05, /* Invalid pack id */
+
+	HALMAC_H2C_RETURN_RUN_ERR_EMPTY =
+		0x06, /* No data in dedicated buffer */
+	HALMAC_H2C_RETURN_RUN_ERR_LEN = 0x07,
+	HALMAC_H2C_RETURN_RUN_ERR_CMD = 0x08,
+	HALMAC_H2C_RETURN_RUN_ERR_ID = 0x09, /* Invalid pack id */
+
+	HALMAC_H2C_RETURN_PACKET_ERR_FULL = 0x0A, /* DMEM buffer full */
+	HALMAC_H2C_RETURN_PACKET_ERR_ID = 0x0B, /* Invalid packet id */
+
+	HALMAC_H2C_RETURN_SCAN_ERR_FULL = 0x0C, /* DMEM buffer full */
+	HALMAC_H2C_RETURN_SCAN_ERR_PHYDM = 0x0D, /* PHYDM API return fail */
+
+	HALMAC_H2C_RETURN_ORIG_ERR_ID = 0x0E, /* Invalid original H2C cmd id */
+
+	HALMAC_H2C_RETURN_UNDEFINE = 0x7FFFFFFF,
+};
+
+enum halmac_scan_report_code {
+	HALMAC_SCAN_REPORT_DONE = 0x00,
+	HALMAC_SCAN_REPORT_ERR_PHYDM = 0x01, /* PHYDM API return fail */
+	HALMAC_SCAN_REPORT_ERR_ID = 0x02, /* Invalid ActionID */
+	HALMAC_SCAN_REPORT_ERR_TX = 0x03, /* Tx RsvdPage fail */
+
+	HALMAC_SCAN_REPORT_UNDEFINE = 0x7FFFFFFF,
+};
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_fw_offload_c2h_nic.h b/drivers/staging/rtlwifi/halmac/halmac_fw_offload_c2h_nic.h
new file mode 100644
index 000000000000..0e99967f3663
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_fw_offload_c2h_nic.h
@@ -0,0 +1,184 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HAL_FWOFFLOADC2HFORMAT_H2C_C2H_NIC_H_
+#define _HAL_FWOFFLOADC2HFORMAT_H2C_C2H_NIC_H_
+#define C2H_SUB_CMD_ID_C2H_DBG 0X00
+#define C2H_SUB_CMD_ID_BT_COEX_INFO 0X02
+#define C2H_SUB_CMD_ID_SCAN_STATUS_RPT 0X03
+#define C2H_SUB_CMD_ID_H2C_ACK_HDR 0X01
+#define C2H_SUB_CMD_ID_CFG_PARAMETER_ACK 0X01
+#define C2H_SUB_CMD_ID_BT_COEX_ACK 0X01
+#define C2H_SUB_CMD_ID_DUMP_PHYSICAL_EFUSE_ACK 0X01
+#define C2H_SUB_CMD_ID_UPDATE_PACKET_ACK 0X01
+#define C2H_SUB_CMD_ID_UPDATE_DATAPACK_ACK 0X01
+#define C2H_SUB_CMD_ID_RUN_DATAPACK_ACK 0X01
+#define C2H_SUB_CMD_ID_CHANNEL_SWITCH_ACK 0X01
+#define C2H_SUB_CMD_ID_IQK_ACK 0X01
+#define C2H_SUB_CMD_ID_POWER_TRACKING_ACK 0X01
+#define C2H_SUB_CMD_ID_PSD_ACK 0X01
+#define C2H_SUB_CMD_ID_PSD_DATA 0X04
+#define C2H_SUB_CMD_ID_EFUSE_DATA 0X05
+#define C2H_SUB_CMD_ID_IQK_DATA 0X06
+#define C2H_SUB_CMD_ID_C2H_PKT_FTM_DBG 0X07
+#define C2H_SUB_CMD_ID_C2H_PKT_FTM_2_DBG 0X08
+#define C2H_SUB_CMD_ID_C2H_PKT_FTM_3_DBG 0X09
+#define C2H_SUB_CMD_ID_C2H_PKT_FTM_4_DBG 0X0A
+#define C2H_SUB_CMD_ID_FTMACKRPT_HDL_DBG 0X0B
+#define C2H_SUB_CMD_ID_FTMC2H_RPT 0X0C
+#define C2H_SUB_CMD_ID_DRVFTMC2H_RPT 0X0D
+#define C2H_SUB_CMD_ID_C2H_PKT_FTM_5_DBG 0X0E
+#define C2H_SUB_CMD_ID_CCX_RPT 0X0F
+#define C2H_SUB_CMD_ID_C2H_PKT_NAN_RPT 0X10
+#define H2C_SUB_CMD_ID_CFG_PARAMETER_ACK SUB_CMD_ID_CFG_PARAMETER
+#define H2C_SUB_CMD_ID_BT_COEX_ACK SUB_CMD_ID_BT_COEX
+#define H2C_SUB_CMD_ID_DUMP_PHYSICAL_EFUSE_ACK SUB_CMD_ID_DUMP_PHYSICAL_EFUSE
+#define H2C_SUB_CMD_ID_UPDATE_PACKET_ACK SUB_CMD_ID_UPDATE_PACKET
+#define H2C_SUB_CMD_ID_UPDATE_DATAPACK_ACK SUB_CMD_ID_UPDATE_DATAPACK
+#define H2C_SUB_CMD_ID_RUN_DATAPACK_ACK SUB_CMD_ID_RUN_DATAPACK
+#define H2C_SUB_CMD_ID_CHANNEL_SWITCH_ACK SUB_CMD_ID_CHANNEL_SWITCH
+#define H2C_SUB_CMD_ID_IQK_ACK SUB_CMD_ID_IQK
+#define H2C_SUB_CMD_ID_POWER_TRACKING_ACK SUB_CMD_ID_POWER_TRACKING
+#define H2C_SUB_CMD_ID_PSD_ACK SUB_CMD_ID_PSD
+#define H2C_SUB_CMD_ID_CCX_RPT SUB_CMD_ID_CCX_RPT
+#define H2C_CMD_ID_CFG_PARAMETER_ACK 0XFF
+#define H2C_CMD_ID_BT_COEX_ACK 0XFF
+#define H2C_CMD_ID_DUMP_PHYSICAL_EFUSE_ACK 0XFF
+#define H2C_CMD_ID_UPDATE_PACKET_ACK 0XFF
+#define H2C_CMD_ID_UPDATE_DATAPACK_ACK 0XFF
+#define H2C_CMD_ID_RUN_DATAPACK_ACK 0XFF
+#define H2C_CMD_ID_CHANNEL_SWITCH_ACK 0XFF
+#define H2C_CMD_ID_IQK_ACK 0XFF
+#define H2C_CMD_ID_POWER_TRACKING_ACK 0XFF
+#define H2C_CMD_ID_PSD_ACK 0XFF
+#define H2C_CMD_ID_CCX_RPT 0XFF
+#define C2H_HDR_GET_CMD_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 0, 8)
+#define C2H_HDR_SET_CMD_ID(__c2h, __value)                                     \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 0, 8, __value)
+#define C2H_HDR_GET_SEQ(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 8, 8)
+#define C2H_HDR_SET_SEQ(__c2h, __value)                                        \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 8, 8, __value)
+#define C2H_HDR_GET_C2H_SUB_CMD_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 16, 8)
+#define C2H_HDR_SET_C2H_SUB_CMD_ID(__c2h, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 16, 8, __value)
+#define C2H_HDR_GET_LEN(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 24, 8)
+#define C2H_HDR_SET_LEN(__c2h, __value)                                        \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 24, 8, __value)
+#define C2H_DBG_GET_DBG_MSG(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 0, 8)
+#define C2H_DBG_SET_DBG_MSG(__c2h, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 0, 8, __value)
+#define BT_COEX_INFO_GET_DATA_START(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 0, 8)
+#define BT_COEX_INFO_SET_DATA_START(__c2h, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 0, 8, __value)
+#define SCAN_STATUS_RPT_GET_H2C_RETURN_CODE(__c2h)                             \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 0, 8)
+#define SCAN_STATUS_RPT_SET_H2C_RETURN_CODE(__c2h, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 0, 8, __value)
+#define SCAN_STATUS_RPT_GET_H2C_SEQ(__c2h)                                     \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 16, 16)
+#define SCAN_STATUS_RPT_SET_H2C_SEQ(__c2h, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 16, 16, __value)
+#define H2C_ACK_HDR_GET_H2C_RETURN_CODE(__c2h)                                 \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 0, 8)
+#define H2C_ACK_HDR_SET_H2C_RETURN_CODE(__c2h, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 0, 8, __value)
+#define H2C_ACK_HDR_GET_H2C_CMD_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 8, 8)
+#define H2C_ACK_HDR_SET_H2C_CMD_ID(__c2h, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 8, 8, __value)
+#define H2C_ACK_HDR_GET_H2C_SUB_CMD_ID(__c2h)                                  \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 16, 16)
+#define H2C_ACK_HDR_SET_H2C_SUB_CMD_ID(__c2h, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 16, 16, __value)
+#define H2C_ACK_HDR_GET_H2C_SEQ(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X08, 0, 16)
+#define H2C_ACK_HDR_SET_H2C_SEQ(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 0, 16, __value)
+#define CFG_PARAMETER_ACK_GET_OFFSET_ACCUMULATION(__c2h)                       \
+	LE_BITS_TO_4BYTE(__c2h + 0XC, 0, 32)
+#define CFG_PARAMETER_ACK_SET_OFFSET_ACCUMULATION(__c2h, __value)              \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0XC, 0, 32, __value)
+#define CFG_PARAMETER_ACK_GET_VALUE_ACCUMULATION(__c2h)                        \
+	LE_BITS_TO_4BYTE(__c2h + 0X10, 0, 32)
+#define CFG_PARAMETER_ACK_SET_VALUE_ACCUMULATION(__c2h, __value)               \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X10, 0, 32, __value)
+#define BT_COEX_ACK_GET_DATA_START(__c2h) LE_BITS_TO_4BYTE(__c2h + 0XC, 0, 8)
+#define BT_COEX_ACK_SET_DATA_START(__c2h, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0XC, 0, 8, __value)
+#define PSD_DATA_GET_SEGMENT_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 0, 7)
+#define PSD_DATA_SET_SEGMENT_ID(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 0, 7, __value)
+#define PSD_DATA_GET_END_SEGMENT(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 7, 1)
+#define PSD_DATA_SET_END_SEGMENT(__c2h, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 7, 1, __value)
+#define PSD_DATA_GET_SEGMENT_SIZE(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 8, 8)
+#define PSD_DATA_SET_SEGMENT_SIZE(__c2h, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 8, 8, __value)
+#define PSD_DATA_GET_TOTAL_SIZE(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 16, 16)
+#define PSD_DATA_SET_TOTAL_SIZE(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 16, 16, __value)
+#define PSD_DATA_GET_H2C_SEQ(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X8, 0, 16)
+#define PSD_DATA_SET_H2C_SEQ(__c2h, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X8, 0, 16, __value)
+#define PSD_DATA_GET_DATA_START(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X8, 16, 8)
+#define PSD_DATA_SET_DATA_START(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X8, 16, 8, __value)
+#define EFUSE_DATA_GET_SEGMENT_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 0, 7)
+#define EFUSE_DATA_SET_SEGMENT_ID(__c2h, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 0, 7, __value)
+#define EFUSE_DATA_GET_END_SEGMENT(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 7, 1)
+#define EFUSE_DATA_SET_END_SEGMENT(__c2h, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 7, 1, __value)
+#define EFUSE_DATA_GET_SEGMENT_SIZE(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 8, 8)
+#define EFUSE_DATA_SET_SEGMENT_SIZE(__c2h, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 8, 8, __value)
+#define EFUSE_DATA_GET_TOTAL_SIZE(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 16, 16)
+#define EFUSE_DATA_SET_TOTAL_SIZE(__c2h, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 16, 16, __value)
+#define EFUSE_DATA_GET_H2C_SEQ(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X8, 0, 16)
+#define EFUSE_DATA_SET_H2C_SEQ(__c2h, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X8, 0, 16, __value)
+#define EFUSE_DATA_GET_DATA_START(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X8, 16, 8)
+#define EFUSE_DATA_SET_DATA_START(__c2h, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X8, 16, 8, __value)
+#define IQK_DATA_GET_SEGMENT_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 0, 7)
+#define IQK_DATA_SET_SEGMENT_ID(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 0, 7, __value)
+#define IQK_DATA_GET_END_SEGMENT(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 7, 1)
+#define IQK_DATA_SET_END_SEGMENT(__c2h, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 7, 1, __value)
+#define IQK_DATA_GET_SEGMENT_SIZE(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 8, 8)
+#define IQK_DATA_SET_SEGMENT_SIZE(__c2h, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 8, 8, __value)
+#define IQK_DATA_GET_TOTAL_SIZE(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 16, 16)
+#define IQK_DATA_SET_TOTAL_SIZE(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 16, 16, __value)
+#define IQK_DATA_GET_H2C_SEQ(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X8, 0, 16)
+#define IQK_DATA_SET_H2C_SEQ(__c2h, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X8, 0, 16, __value)
+#define IQK_DATA_GET_DATA_START(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X8, 16, 8)
+#define IQK_DATA_SET_DATA_START(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X8, 16, 8, __value)
+#define CCX_RPT_GET_CCX_RPT(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X4, 0, 129)
+#define CCX_RPT_SET_CCX_RPT(__c2h, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X4, 0, 129, __value)
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_fw_offload_h2c_nic.h b/drivers/staging/rtlwifi/halmac/halmac_fw_offload_h2c_nic.h
new file mode 100644
index 000000000000..7adc3cdb38c9
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_fw_offload_h2c_nic.h
@@ -0,0 +1,515 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HAL_FWOFFLOADH2CFORMAT_H2C_C2H_NIC_H_
+#define _HAL_FWOFFLOADH2CFORMAT_H2C_C2H_NIC_H_
+#define CMD_ID_FW_OFFLOAD_H2C 0XFF
+#define CMD_ID_CHANNEL_SWITCH 0XFF
+#define CMD_ID_DUMP_PHYSICAL_EFUSE 0XFF
+#define CMD_ID_UPDATE_BEACON_PARSING_INFO 0XFF
+#define CMD_ID_CFG_PARAMETER 0XFF
+#define CMD_ID_UPDATE_DATAPACK 0XFF
+#define CMD_ID_RUN_DATAPACK 0XFF
+#define CMD_ID_DOWNLOAD_FLASH 0XFF
+#define CMD_ID_UPDATE_PACKET 0XFF
+#define CMD_ID_GENERAL_INFO 0XFF
+#define CMD_ID_IQK 0XFF
+#define CMD_ID_POWER_TRACKING 0XFF
+#define CMD_ID_PSD 0XFF
+#define CMD_ID_P2PPS 0XFF
+#define CMD_ID_BT_COEX 0XFF
+#define CMD_ID_NAN_CTRL 0XFF
+#define CMD_ID_NAN_CHANNEL_PLAN_0 0XFF
+#define CMD_ID_NAN_CHANNEL_PLAN_1 0XFF
+#define CATEGORY_H2C_CMD_HEADER 0X00
+#define CATEGORY_FW_OFFLOAD_H2C 0X01
+#define CATEGORY_CHANNEL_SWITCH 0X01
+#define CATEGORY_DUMP_PHYSICAL_EFUSE 0X01
+#define CATEGORY_UPDATE_BEACON_PARSING_INFO 0X01
+#define CATEGORY_CFG_PARAMETER 0X01
+#define CATEGORY_UPDATE_DATAPACK 0X01
+#define CATEGORY_RUN_DATAPACK 0X01
+#define CATEGORY_DOWNLOAD_FLASH 0X01
+#define CATEGORY_UPDATE_PACKET 0X01
+#define CATEGORY_GENERAL_INFO 0X01
+#define CATEGORY_IQK 0X01
+#define CATEGORY_POWER_TRACKING 0X01
+#define CATEGORY_PSD 0X01
+#define CATEGORY_P2PPS 0X01
+#define CATEGORY_BT_COEX 0X01
+#define CATEGORY_NAN_CTRL 0X01
+#define CATEGORY_NAN_CHANNEL_PLAN_0 0X01
+#define CATEGORY_NAN_CHANNEL_PLAN_1 0X01
+#define SUB_CMD_ID_CHANNEL_SWITCH 0X02
+#define SUB_CMD_ID_DUMP_PHYSICAL_EFUSE 0X03
+#define SUB_CMD_ID_UPDATE_BEACON_PARSING_INFO 0X05
+#define SUB_CMD_ID_CFG_PARAMETER 0X08
+#define SUB_CMD_ID_UPDATE_DATAPACK 0X09
+#define SUB_CMD_ID_RUN_DATAPACK 0X0A
+#define SUB_CMD_ID_DOWNLOAD_FLASH 0X0B
+#define SUB_CMD_ID_UPDATE_PACKET 0X0C
+#define SUB_CMD_ID_GENERAL_INFO 0X0D
+#define SUB_CMD_ID_IQK 0X0E
+#define SUB_CMD_ID_POWER_TRACKING 0X0F
+#define SUB_CMD_ID_PSD 0X10
+#define SUB_CMD_ID_P2PPS 0X24
+#define SUB_CMD_ID_BT_COEX 0X60
+#define SUB_CMD_ID_NAN_CTRL 0XB2
+#define SUB_CMD_ID_NAN_CHANNEL_PLAN_0 0XB4
+#define SUB_CMD_ID_NAN_CHANNEL_PLAN_1 0XB5
+#define H2C_CMD_HEADER_GET_CATEGORY(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 7)
+#define H2C_CMD_HEADER_SET_CATEGORY(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 7, __value)
+#define H2C_CMD_HEADER_GET_ACK(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 7, 1)
+#define H2C_CMD_HEADER_SET_ACK(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 7, 1, __value)
+#define H2C_CMD_HEADER_GET_TOTAL_LEN(__h2c)                                    \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 16)
+#define H2C_CMD_HEADER_SET_TOTAL_LEN(__h2c, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 16, __value)
+#define H2C_CMD_HEADER_GET_SEQ_NUM(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 16, 16)
+#define H2C_CMD_HEADER_SET_SEQ_NUM(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 16, 16, __value)
+#define FW_OFFLOAD_H2C_GET_CATEGORY(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 7)
+#define FW_OFFLOAD_H2C_SET_CATEGORY(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 7, __value)
+#define FW_OFFLOAD_H2C_GET_ACK(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 7, 1)
+#define FW_OFFLOAD_H2C_SET_ACK(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 7, 1, __value)
+#define FW_OFFLOAD_H2C_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define FW_OFFLOAD_H2C_SET_CMD_ID(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define FW_OFFLOAD_H2C_GET_SUB_CMD_ID(__h2c)                                   \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 16)
+#define FW_OFFLOAD_H2C_SET_SUB_CMD_ID(__h2c, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 16, __value)
+#define FW_OFFLOAD_H2C_GET_TOTAL_LEN(__h2c)                                    \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 16)
+#define FW_OFFLOAD_H2C_SET_TOTAL_LEN(__h2c, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 16, __value)
+#define FW_OFFLOAD_H2C_GET_SEQ_NUM(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 16, 16)
+#define FW_OFFLOAD_H2C_SET_SEQ_NUM(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 16, 16, __value)
+#define CHANNEL_SWITCH_GET_SWITCH_START(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 1)
+#define CHANNEL_SWITCH_SET_SWITCH_START(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 1, __value)
+#define CHANNEL_SWITCH_GET_DEST_CH_EN(__h2c)                                   \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 1, 1)
+#define CHANNEL_SWITCH_SET_DEST_CH_EN(__h2c, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 1, 1, __value)
+#define CHANNEL_SWITCH_GET_ABSOLUTE_TIME(__h2c)                                \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 2, 1)
+#define CHANNEL_SWITCH_SET_ABSOLUTE_TIME(__h2c, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 2, 1, __value)
+#define CHANNEL_SWITCH_GET_PERIODIC_OPTION(__h2c)                              \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 3, 2)
+#define CHANNEL_SWITCH_SET_PERIODIC_OPTION(__h2c, __value)                     \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 3, 2, __value)
+#define CHANNEL_SWITCH_GET_CHANNEL_INFO_LOC(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 8, 8)
+#define CHANNEL_SWITCH_SET_CHANNEL_INFO_LOC(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 8, 8, __value)
+#define CHANNEL_SWITCH_GET_CHANNEL_NUM(__h2c)                                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 16, 8)
+#define CHANNEL_SWITCH_SET_CHANNEL_NUM(__h2c, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 16, 8, __value)
+#define CHANNEL_SWITCH_GET_PRI_CH_IDX(__h2c)                                   \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 24, 4)
+#define CHANNEL_SWITCH_SET_PRI_CH_IDX(__h2c, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 24, 4, __value)
+#define CHANNEL_SWITCH_GET_DEST_BW(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 28, 4)
+#define CHANNEL_SWITCH_SET_DEST_BW(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 28, 4, __value)
+#define CHANNEL_SWITCH_GET_DEST_CH(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X0C, 0, 8)
+#define CHANNEL_SWITCH_SET_DEST_CH(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 0, 8, __value)
+#define CHANNEL_SWITCH_GET_NORMAL_PERIOD(__h2c)                                \
+	LE_BITS_TO_4BYTE(__h2c + 0X0C, 8, 8)
+#define CHANNEL_SWITCH_SET_NORMAL_PERIOD(__h2c, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 8, 8, __value)
+#define CHANNEL_SWITCH_GET_SLOW_PERIOD(__h2c)                                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X0C, 16, 8)
+#define CHANNEL_SWITCH_SET_SLOW_PERIOD(__h2c, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 16, 8, __value)
+#define CHANNEL_SWITCH_GET_NORMAL_CYCLE(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X0C, 24, 8)
+#define CHANNEL_SWITCH_SET_NORMAL_CYCLE(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 24, 8, __value)
+#define CHANNEL_SWITCH_GET_TSF_HIGH(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X10, 0, 32)
+#define CHANNEL_SWITCH_SET_TSF_HIGH(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X10, 0, 32, __value)
+#define CHANNEL_SWITCH_GET_TSF_LOW(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X14, 0, 32)
+#define CHANNEL_SWITCH_SET_TSF_LOW(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X14, 0, 32, __value)
+#define CHANNEL_SWITCH_GET_CHANNEL_INFO_SIZE(__h2c)                            \
+	LE_BITS_TO_4BYTE(__h2c + 0X18, 0, 16)
+#define CHANNEL_SWITCH_SET_CHANNEL_INFO_SIZE(__h2c, __value)                   \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X18, 0, 16, __value)
+#define UPDATE_BEACON_PARSING_INFO_GET_FUNC_EN(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 1)
+#define UPDATE_BEACON_PARSING_INFO_SET_FUNC_EN(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 1, __value)
+#define UPDATE_BEACON_PARSING_INFO_GET_SIZE_TH(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 8, 4)
+#define UPDATE_BEACON_PARSING_INFO_SET_SIZE_TH(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 8, 4, __value)
+#define UPDATE_BEACON_PARSING_INFO_GET_TIMEOUT(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 12, 4)
+#define UPDATE_BEACON_PARSING_INFO_SET_TIMEOUT(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 12, 4, __value)
+#define UPDATE_BEACON_PARSING_INFO_GET_IE_ID_BMP_0(__h2c)                      \
+	LE_BITS_TO_4BYTE(__h2c + 0X0C, 0, 32)
+#define UPDATE_BEACON_PARSING_INFO_SET_IE_ID_BMP_0(__h2c, __value)             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 0, 32, __value)
+#define UPDATE_BEACON_PARSING_INFO_GET_IE_ID_BMP_1(__h2c)                      \
+	LE_BITS_TO_4BYTE(__h2c + 0X10, 0, 32)
+#define UPDATE_BEACON_PARSING_INFO_SET_IE_ID_BMP_1(__h2c, __value)             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X10, 0, 32, __value)
+#define UPDATE_BEACON_PARSING_INFO_GET_IE_ID_BMP_2(__h2c)                      \
+	LE_BITS_TO_4BYTE(__h2c + 0X14, 0, 32)
+#define UPDATE_BEACON_PARSING_INFO_SET_IE_ID_BMP_2(__h2c, __value)             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X14, 0, 32, __value)
+#define UPDATE_BEACON_PARSING_INFO_GET_IE_ID_BMP_3(__h2c)                      \
+	LE_BITS_TO_4BYTE(__h2c + 0X18, 0, 32)
+#define UPDATE_BEACON_PARSING_INFO_SET_IE_ID_BMP_3(__h2c, __value)             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X18, 0, 32, __value)
+#define UPDATE_BEACON_PARSING_INFO_GET_IE_ID_BMP_4(__h2c)                      \
+	LE_BITS_TO_4BYTE(__h2c + 0X1C, 0, 32)
+#define UPDATE_BEACON_PARSING_INFO_SET_IE_ID_BMP_4(__h2c, __value)             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X1C, 0, 32, __value)
+#define CFG_PARAMETER_GET_NUM(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 16)
+#define CFG_PARAMETER_SET_NUM(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 16, __value)
+#define CFG_PARAMETER_GET_INIT_CASE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 16, 1)
+#define CFG_PARAMETER_SET_INIT_CASE(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 16, 1, __value)
+#define CFG_PARAMETER_GET_PHY_PARAMETER_LOC(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 24, 8)
+#define CFG_PARAMETER_SET_PHY_PARAMETER_LOC(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 24, 8, __value)
+#define UPDATE_DATAPACK_GET_SIZE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 16)
+#define UPDATE_DATAPACK_SET_SIZE(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 16, __value)
+#define UPDATE_DATAPACK_GET_DATAPACK_ID(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 16, 8)
+#define UPDATE_DATAPACK_SET_DATAPACK_ID(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 16, 8, __value)
+#define UPDATE_DATAPACK_GET_DATAPACK_LOC(__h2c)                                \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 24, 8)
+#define UPDATE_DATAPACK_SET_DATAPACK_LOC(__h2c, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 24, 8, __value)
+#define UPDATE_DATAPACK_GET_DATAPACK_SEGMENT(__h2c)                            \
+	LE_BITS_TO_4BYTE(__h2c + 0X0C, 0, 8)
+#define UPDATE_DATAPACK_SET_DATAPACK_SEGMENT(__h2c, __value)                   \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 0, 8, __value)
+#define UPDATE_DATAPACK_GET_END_SEGMENT(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X0C, 8, 1)
+#define UPDATE_DATAPACK_SET_END_SEGMENT(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 8, 1, __value)
+#define RUN_DATAPACK_GET_DATAPACK_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 8)
+#define RUN_DATAPACK_SET_DATAPACK_ID(__h2c, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 8, __value)
+#define DOWNLOAD_FLASH_GET_SPI_CMD(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 8)
+#define DOWNLOAD_FLASH_SET_SPI_CMD(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 8, __value)
+#define DOWNLOAD_FLASH_GET_LOCATION(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 8, 16)
+#define DOWNLOAD_FLASH_SET_LOCATION(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 8, 16, __value)
+#define DOWNLOAD_FLASH_GET_SIZE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X0C, 0, 32)
+#define DOWNLOAD_FLASH_SET_SIZE(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 0, 32, __value)
+#define DOWNLOAD_FLASH_GET_START_ADDR(__h2c)                                   \
+	LE_BITS_TO_4BYTE(__h2c + 0X10, 0, 32)
+#define DOWNLOAD_FLASH_SET_START_ADDR(__h2c, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X10, 0, 32, __value)
+#define UPDATE_PACKET_GET_SIZE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 16)
+#define UPDATE_PACKET_SET_SIZE(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 16, __value)
+#define UPDATE_PACKET_GET_PACKET_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 16, 8)
+#define UPDATE_PACKET_SET_PACKET_ID(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 16, 8, __value)
+#define UPDATE_PACKET_GET_PACKET_LOC(__h2c)                                    \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 24, 8)
+#define UPDATE_PACKET_SET_PACKET_LOC(__h2c, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 24, 8, __value)
+#define GENERAL_INFO_GET_REF_TYPE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 8)
+#define GENERAL_INFO_SET_REF_TYPE(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 8, __value)
+#define GENERAL_INFO_GET_RF_TYPE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 8, 9)
+#define GENERAL_INFO_SET_RF_TYPE(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 8, 9, __value)
+#define GENERAL_INFO_GET_FW_TX_BOUNDARY(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 16, 8)
+#define GENERAL_INFO_SET_FW_TX_BOUNDARY(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 16, 8, __value)
+#define IQK_GET_CLEAR(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 1)
+#define IQK_SET_CLEAR(__h2c, __value)                                          \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 1, __value)
+#define IQK_GET_SEGMENT_IQK(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 1, 1)
+#define IQK_SET_SEGMENT_IQK(__h2c, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 1, 1, __value)
+#define POWER_TRACKING_GET_ENABLE_A(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 1)
+#define POWER_TRACKING_SET_ENABLE_A(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 1, __value)
+#define POWER_TRACKING_GET_ENABLE_B(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 1, 1)
+#define POWER_TRACKING_SET_ENABLE_B(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 1, 1, __value)
+#define POWER_TRACKING_GET_ENABLE_C(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 2, 1)
+#define POWER_TRACKING_SET_ENABLE_C(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 2, 1, __value)
+#define POWER_TRACKING_GET_ENABLE_D(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 3, 1)
+#define POWER_TRACKING_SET_ENABLE_D(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 3, 1, __value)
+#define POWER_TRACKING_GET_TYPE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 4, 3)
+#define POWER_TRACKING_SET_TYPE(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 4, 3, __value)
+#define POWER_TRACKING_GET_BBSWING_INDEX(__h2c)                                \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 8, 8)
+#define POWER_TRACKING_SET_BBSWING_INDEX(__h2c, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 8, 8, __value)
+#define POWER_TRACKING_GET_TX_PWR_INDEX_A(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X0C, 0, 8)
+#define POWER_TRACKING_SET_TX_PWR_INDEX_A(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 0, 8, __value)
+#define POWER_TRACKING_GET_PWR_TRACKING_OFFSET_VALUE_A(__h2c)                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X0C, 8, 8)
+#define POWER_TRACKING_SET_PWR_TRACKING_OFFSET_VALUE_A(__h2c, __value)         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 8, 8, __value)
+#define POWER_TRACKING_GET_TSSI_VALUE_A(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X0C, 16, 8)
+#define POWER_TRACKING_SET_TSSI_VALUE_A(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 16, 8, __value)
+#define POWER_TRACKING_GET_TX_PWR_INDEX_B(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X10, 0, 8)
+#define POWER_TRACKING_SET_TX_PWR_INDEX_B(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X10, 0, 8, __value)
+#define POWER_TRACKING_GET_PWR_TRACKING_OFFSET_VALUE_B(__h2c)                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X10, 8, 8)
+#define POWER_TRACKING_SET_PWR_TRACKING_OFFSET_VALUE_B(__h2c, __value)         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X10, 8, 8, __value)
+#define POWER_TRACKING_GET_TSSI_VALUE_B(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X10, 16, 8)
+#define POWER_TRACKING_SET_TSSI_VALUE_B(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X10, 16, 8, __value)
+#define POWER_TRACKING_GET_TX_PWR_INDEX_C(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X14, 0, 8)
+#define POWER_TRACKING_SET_TX_PWR_INDEX_C(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X14, 0, 8, __value)
+#define POWER_TRACKING_GET_PWR_TRACKING_OFFSET_VALUE_C(__h2c)                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X14, 8, 8)
+#define POWER_TRACKING_SET_PWR_TRACKING_OFFSET_VALUE_C(__h2c, __value)         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X14, 8, 8, __value)
+#define POWER_TRACKING_GET_TSSI_VALUE_C(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X14, 16, 8)
+#define POWER_TRACKING_SET_TSSI_VALUE_C(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X14, 16, 8, __value)
+#define POWER_TRACKING_GET_TX_PWR_INDEX_D(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X18, 0, 8)
+#define POWER_TRACKING_SET_TX_PWR_INDEX_D(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X18, 0, 8, __value)
+#define POWER_TRACKING_GET_PWR_TRACKING_OFFSET_VALUE_D(__h2c)                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X18, 8, 8)
+#define POWER_TRACKING_SET_PWR_TRACKING_OFFSET_VALUE_D(__h2c, __value)         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X18, 8, 8, __value)
+#define POWER_TRACKING_GET_TSSI_VALUE_D(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X18, 16, 8)
+#define POWER_TRACKING_SET_TSSI_VALUE_D(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X18, 16, 8, __value)
+#define PSD_GET_START_PSD(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 16)
+#define PSD_SET_START_PSD(__h2c, __value)                                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 16, __value)
+#define PSD_GET_END_PSD(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 16, 16)
+#define PSD_SET_END_PSD(__h2c, __value)                                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 16, 16, __value)
+#define P2PPS_GET_OFFLOAD_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 1)
+#define P2PPS_SET_OFFLOAD_EN(__h2c, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 1, __value)
+#define P2PPS_GET_ROLE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 1, 1)
+#define P2PPS_SET_ROLE(__h2c, __value)                                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 1, 1, __value)
+#define P2PPS_GET_CTWINDOW_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 2, 1)
+#define P2PPS_SET_CTWINDOW_EN(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 2, 1, __value)
+#define P2PPS_GET_NOA_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 3, 1)
+#define P2PPS_SET_NOA_EN(__h2c, __value)                                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 3, 1, __value)
+#define P2PPS_GET_NOA_SEL(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 4, 1)
+#define P2PPS_SET_NOA_SEL(__h2c, __value)                                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 4, 1, __value)
+#define P2PPS_GET_ALLSTASLEEP(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 5, 1)
+#define P2PPS_SET_ALLSTASLEEP(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 5, 1, __value)
+#define P2PPS_GET_DISCOVERY(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 6, 1)
+#define P2PPS_SET_DISCOVERY(__h2c, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 6, 1, __value)
+#define P2PPS_GET_P2P_PORT_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 8, 8)
+#define P2PPS_SET_P2P_PORT_ID(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 8, 8, __value)
+#define P2PPS_GET_P2P_GROUP(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 16, 8)
+#define P2PPS_SET_P2P_GROUP(__h2c, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 16, 8, __value)
+#define P2PPS_GET_P2P_MACID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 24, 8)
+#define P2PPS_SET_P2P_MACID(__h2c, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 24, 8, __value)
+#define P2PPS_GET_CTWINDOW_LENGTH(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X0C, 0, 8)
+#define P2PPS_SET_CTWINDOW_LENGTH(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 0, 8, __value)
+#define P2PPS_GET_NOA_DURATION_PARA(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X10, 0, 32)
+#define P2PPS_SET_NOA_DURATION_PARA(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X10, 0, 32, __value)
+#define P2PPS_GET_NOA_INTERVAL_PARA(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X14, 0, 32)
+#define P2PPS_SET_NOA_INTERVAL_PARA(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X14, 0, 32, __value)
+#define P2PPS_GET_NOA_START_TIME_PARA(__h2c)                                   \
+	LE_BITS_TO_4BYTE(__h2c + 0X18, 0, 32)
+#define P2PPS_SET_NOA_START_TIME_PARA(__h2c, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X18, 0, 32, __value)
+#define P2PPS_GET_NOA_COUNT_PARA(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X1C, 0, 32)
+#define P2PPS_SET_NOA_COUNT_PARA(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X1C, 0, 32, __value)
+#define BT_COEX_GET_DATA_START(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 8)
+#define BT_COEX_SET_DATA_START(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 8, __value)
+#define NAN_CTRL_GET_NAN_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 2)
+#define NAN_CTRL_SET_NAN_EN(__h2c, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 2, __value)
+#define NAN_CTRL_GET_SUPPORT_BAND(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 8, 2)
+#define NAN_CTRL_SET_SUPPORT_BAND(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 8, 2, __value)
+#define NAN_CTRL_GET_DISABLE_2G_DISC_BCN(__h2c)                                \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 10, 1)
+#define NAN_CTRL_SET_DISABLE_2G_DISC_BCN(__h2c, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 10, 1, __value)
+#define NAN_CTRL_GET_DISABLE_5G_DISC_BCN(__h2c)                                \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 11, 1)
+#define NAN_CTRL_SET_DISABLE_5G_DISC_BCN(__h2c, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 11, 1, __value)
+#define NAN_CTRL_GET_BCN_RSVD_PAGE_OFFSET(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 16, 8)
+#define NAN_CTRL_SET_BCN_RSVD_PAGE_OFFSET(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 16, 8, __value)
+#define NAN_CTRL_GET_CHANNEL_2G(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X08, 24, 8)
+#define NAN_CTRL_SET_CHANNEL_2G(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 24, 8, __value)
+#define NAN_CTRL_GET_CHANNEL_5G(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X0C, 0, 8)
+#define NAN_CTRL_SET_CHANNEL_5G(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 0, 8, __value)
+#define NAN_CHANNEL_PLAN_0_GET_CHANNEL_NUMBER_0(__h2c)                         \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 8)
+#define NAN_CHANNEL_PLAN_0_SET_CHANNEL_NUMBER_0(__h2c, __value)                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 8, __value)
+#define NAN_CHANNEL_PLAN_0_GET_UNPAUSE_MACID_0(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 8, 8)
+#define NAN_CHANNEL_PLAN_0_SET_UNPAUSE_MACID_0(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 8, 8, __value)
+#define NAN_CHANNEL_PLAN_0_GET_START_TIME_SLOT_0(__h2c)                        \
+	LE_BITS_TO_4BYTE(__h2c + 0X0C, 0, 16)
+#define NAN_CHANNEL_PLAN_0_SET_START_TIME_SLOT_0(__h2c, __value)               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 0, 16, __value)
+#define NAN_CHANNEL_PLAN_0_GET_DURATION_0(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X0C, 16, 16)
+#define NAN_CHANNEL_PLAN_0_SET_DURATION_0(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 16, 16, __value)
+#define NAN_CHANNEL_PLAN_0_GET_CHANNEL_NUMBER_1(__h2c)                         \
+	LE_BITS_TO_4BYTE(__h2c + 0X10, 0, 8)
+#define NAN_CHANNEL_PLAN_0_SET_CHANNEL_NUMBER_1(__h2c, __value)                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X10, 0, 8, __value)
+#define NAN_CHANNEL_PLAN_0_GET_UNPAUSE_MACID_1(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X10, 8, 8)
+#define NAN_CHANNEL_PLAN_0_SET_UNPAUSE_MACID_1(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X10, 8, 8, __value)
+#define NAN_CHANNEL_PLAN_0_GET_START_TIME_SLOT_1(__h2c)                        \
+	LE_BITS_TO_4BYTE(__h2c + 0X14, 0, 16)
+#define NAN_CHANNEL_PLAN_0_SET_START_TIME_SLOT_1(__h2c, __value)               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X14, 0, 16, __value)
+#define NAN_CHANNEL_PLAN_0_GET_DURATION_1(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X14, 16, 16)
+#define NAN_CHANNEL_PLAN_0_SET_DURATION_1(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X14, 16, 16, __value)
+#define NAN_CHANNEL_PLAN_0_GET_CHANNEL_NUMBER_2(__h2c)                         \
+	LE_BITS_TO_4BYTE(__h2c + 0X18, 0, 8)
+#define NAN_CHANNEL_PLAN_0_SET_CHANNEL_NUMBER_2(__h2c, __value)                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X18, 0, 8, __value)
+#define NAN_CHANNEL_PLAN_0_GET_UNPAUSE_MACID_2(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X18, 8, 8)
+#define NAN_CHANNEL_PLAN_0_SET_UNPAUSE_MACID_2(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X18, 8, 8, __value)
+#define NAN_CHANNEL_PLAN_0_GET_START_TIME_SLOT_2(__h2c)                        \
+	LE_BITS_TO_4BYTE(__h2c + 0X1C, 0, 16)
+#define NAN_CHANNEL_PLAN_0_SET_START_TIME_SLOT_2(__h2c, __value)               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X1C, 0, 16, __value)
+#define NAN_CHANNEL_PLAN_0_GET_DURATION_2(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X1C, 16, 16)
+#define NAN_CHANNEL_PLAN_0_SET_DURATION_2(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X1C, 16, 16, __value)
+#define NAN_CHANNEL_PLAN_1_GET_CHANNEL_NUMBER_3(__h2c)                         \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 0, 8)
+#define NAN_CHANNEL_PLAN_1_SET_CHANNEL_NUMBER_3(__h2c, __value)                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 0, 8, __value)
+#define NAN_CHANNEL_PLAN_1_GET_UNPAUSE_MACID_3(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X08, 8, 8)
+#define NAN_CHANNEL_PLAN_1_SET_UNPAUSE_MACID_3(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X08, 8, 8, __value)
+#define NAN_CHANNEL_PLAN_1_GET_START_TIME_SLOT_3(__h2c)                        \
+	LE_BITS_TO_4BYTE(__h2c + 0X0C, 0, 16)
+#define NAN_CHANNEL_PLAN_1_SET_START_TIME_SLOT_3(__h2c, __value)               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 0, 16, __value)
+#define NAN_CHANNEL_PLAN_1_GET_DURATION_3(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X0C, 16, 16)
+#define NAN_CHANNEL_PLAN_1_SET_DURATION_3(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X0C, 16, 16, __value)
+#define NAN_CHANNEL_PLAN_1_GET_CHANNEL_NUMBER_4(__h2c)                         \
+	LE_BITS_TO_4BYTE(__h2c + 0X10, 0, 8)
+#define NAN_CHANNEL_PLAN_1_SET_CHANNEL_NUMBER_4(__h2c, __value)                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X10, 0, 8, __value)
+#define NAN_CHANNEL_PLAN_1_GET_UNPAUSE_MACID_4(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X10, 8, 8)
+#define NAN_CHANNEL_PLAN_1_SET_UNPAUSE_MACID_4(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X10, 8, 8, __value)
+#define NAN_CHANNEL_PLAN_1_GET_START_TIME_SLOT_4(__h2c)                        \
+	LE_BITS_TO_4BYTE(__h2c + 0X14, 0, 16)
+#define NAN_CHANNEL_PLAN_1_SET_START_TIME_SLOT_4(__h2c, __value)               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X14, 0, 16, __value)
+#define NAN_CHANNEL_PLAN_1_GET_DURATION_4(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X14, 16, 16)
+#define NAN_CHANNEL_PLAN_1_SET_DURATION_4(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X14, 16, 16, __value)
+#define NAN_CHANNEL_PLAN_1_GET_CHANNEL_NUMBER_5(__h2c)                         \
+	LE_BITS_TO_4BYTE(__h2c + 0X18, 0, 8)
+#define NAN_CHANNEL_PLAN_1_SET_CHANNEL_NUMBER_5(__h2c, __value)                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X18, 0, 8, __value)
+#define NAN_CHANNEL_PLAN_1_GET_UNPAUSE_MACID_5(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X18, 8, 8)
+#define NAN_CHANNEL_PLAN_1_SET_UNPAUSE_MACID_5(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X18, 8, 8, __value)
+#define NAN_CHANNEL_PLAN_1_GET_START_TIME_SLOT_5(__h2c)                        \
+	LE_BITS_TO_4BYTE(__h2c + 0X1C, 0, 16)
+#define NAN_CHANNEL_PLAN_1_SET_START_TIME_SLOT_5(__h2c, __value)               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X1C, 0, 16, __value)
+#define NAN_CHANNEL_PLAN_1_GET_DURATION_5(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X1C, 16, 16)
+#define NAN_CHANNEL_PLAN_1_SET_DURATION_5(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X1C, 16, 16, __value)
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_h2c_extra_info_nic.h b/drivers/staging/rtlwifi/halmac/halmac_h2c_extra_info_nic.h
new file mode 100644
index 000000000000..5f23cba6d067
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_h2c_extra_info_nic.h
@@ -0,0 +1,115 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HAL_H2CEXTRAINFO_H2C_C2H_NIC_H_
+#define _HAL_H2CEXTRAINFO_H2C_C2H_NIC_H_
+#define PHY_PARAMETER_INFO_GET_LENGTH(__extra_info)                            \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 0, 8)
+#define PHY_PARAMETER_INFO_SET_LENGTH(__extra_info, __value)                   \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 0, 8, __value)
+#define PHY_PARAMETER_INFO_GET_IO_CMD(__extra_info)                            \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 8, 7)
+#define PHY_PARAMETER_INFO_SET_IO_CMD(__extra_info, __value)                   \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 8, 7, __value)
+#define PHY_PARAMETER_INFO_GET_MSK_EN(__extra_info)                            \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 15, 1)
+#define PHY_PARAMETER_INFO_SET_MSK_EN(__extra_info, __value)                   \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 15, 1, __value)
+#define PHY_PARAMETER_INFO_GET_LLT_PG_BNDY(__extra_info)                       \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 16, 8)
+#define PHY_PARAMETER_INFO_SET_LLT_PG_BNDY(__extra_info, __value)              \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 16, 8, __value)
+#define PHY_PARAMETER_INFO_GET_EFUSE_RSVDPAGE_LOC(__extra_info)                \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 16, 8)
+#define PHY_PARAMETER_INFO_SET_EFUSE_RSVDPAGE_LOC(__extra_info, __value)       \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 16, 8, __value)
+#define PHY_PARAMETER_INFO_GET_EFUSE_PATCH_EN(__extra_info)                    \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 16, 8)
+#define PHY_PARAMETER_INFO_SET_EFUSE_PATCH_EN(__extra_info, __value)           \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 16, 8, __value)
+#define PHY_PARAMETER_INFO_GET_RF_ADDR(__extra_info)                           \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 16, 8)
+#define PHY_PARAMETER_INFO_SET_RF_ADDR(__extra_info, __value)                  \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 16, 8, __value)
+#define PHY_PARAMETER_INFO_GET_IO_ADDR(__extra_info)                           \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 16, 16)
+#define PHY_PARAMETER_INFO_SET_IO_ADDR(__extra_info, __value)                  \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 16, 16, __value)
+#define PHY_PARAMETER_INFO_GET_DELAY_VALUE(__extra_info)                       \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 16, 16)
+#define PHY_PARAMETER_INFO_SET_DELAY_VALUE(__extra_info, __value)              \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 16, 16, __value)
+#define PHY_PARAMETER_INFO_GET_RF_PATH(__extra_info)                           \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 24, 8)
+#define PHY_PARAMETER_INFO_SET_RF_PATH(__extra_info, __value)                  \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 24, 8, __value)
+#define PHY_PARAMETER_INFO_GET_DATA(__extra_info)                              \
+	LE_BITS_TO_4BYTE(__extra_info + 0X04, 0, 32)
+#define PHY_PARAMETER_INFO_SET_DATA(__extra_info, __value)                     \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X04, 0, 32, __value)
+#define PHY_PARAMETER_INFO_GET_MASK(__extra_info)                              \
+	LE_BITS_TO_4BYTE(__extra_info + 0X08, 0, 32)
+#define PHY_PARAMETER_INFO_SET_MASK(__extra_info, __value)                     \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X08, 0, 32, __value)
+#define CHANNEL_INFO_GET_CHANNEL(__extra_info)                                 \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 0, 8)
+#define CHANNEL_INFO_SET_CHANNEL(__extra_info, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 0, 8, __value)
+#define CHANNEL_INFO_GET_PRI_CH_IDX(__extra_info)                              \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 8, 4)
+#define CHANNEL_INFO_SET_PRI_CH_IDX(__extra_info, __value)                     \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 8, 4, __value)
+#define CHANNEL_INFO_GET_BANDWIDTH(__extra_info)                               \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 12, 4)
+#define CHANNEL_INFO_SET_BANDWIDTH(__extra_info, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 12, 4, __value)
+#define CHANNEL_INFO_GET_TIMEOUT(__extra_info)                                 \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 16, 8)
+#define CHANNEL_INFO_SET_TIMEOUT(__extra_info, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 16, 8, __value)
+#define CHANNEL_INFO_GET_ACTION_ID(__extra_info)                               \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 24, 7)
+#define CHANNEL_INFO_SET_ACTION_ID(__extra_info, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 24, 7, __value)
+#define CHANNEL_INFO_GET_CH_EXTRA_INFO(__extra_info)                           \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 31, 1)
+#define CHANNEL_INFO_SET_CH_EXTRA_INFO(__extra_info, __value)                  \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 31, 1, __value)
+#define CH_EXTRA_INFO_GET_CH_EXTRA_INFO_ID(__extra_info)                       \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 0, 7)
+#define CH_EXTRA_INFO_SET_CH_EXTRA_INFO_ID(__extra_info, __value)              \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 0, 7, __value)
+#define CH_EXTRA_INFO_GET_CH_EXTRA_INFO(__extra_info)                          \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 7, 1)
+#define CH_EXTRA_INFO_SET_CH_EXTRA_INFO(__extra_info, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 7, 1, __value)
+#define CH_EXTRA_INFO_GET_CH_EXTRA_INFO_SIZE(__extra_info)                     \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 8, 8)
+#define CH_EXTRA_INFO_SET_CH_EXTRA_INFO_SIZE(__extra_info, __value)            \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 8, 8, __value)
+#define CH_EXTRA_INFO_GET_CH_EXTRA_INFO_DATA(__extra_info)                     \
+	LE_BITS_TO_4BYTE(__extra_info + 0X00, 16, 1)
+#define CH_EXTRA_INFO_SET_CH_EXTRA_INFO_DATA(__extra_info, __value)            \
+	SET_BITS_TO_LE_4BYTE(__extra_info + 0X00, 16, 1, __value)
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_intf_phy_cmd.h b/drivers/staging/rtlwifi/halmac/halmac_intf_phy_cmd.h
new file mode 100644
index 000000000000..273d4c0e338a
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_intf_phy_cmd.h
@@ -0,0 +1,54 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef HALMAC_INTF_PHY_CMD
+#define HALMAC_INTF_PHY_CMD
+
+/* Cut mask */
+enum halmac_intf_phy_cut {
+	HALMAC_INTF_PHY_CUT_TESTCHIP = BIT(0),
+	HALMAC_INTF_PHY_CUT_A = BIT(1),
+	HALMAC_INTF_PHY_CUT_B = BIT(2),
+	HALMAC_INTF_PHY_CUT_C = BIT(3),
+	HALMAC_INTF_PHY_CUT_D = BIT(4),
+	HALMAC_INTF_PHY_CUT_E = BIT(5),
+	HALMAC_INTF_PHY_CUT_F = BIT(6),
+	HALMAC_INTF_PHY_CUT_G = BIT(7),
+	HALMAC_INTF_PHY_CUT_ALL = 0x7FFF,
+};
+
+/* IP selection */
+enum halmac_ip_sel {
+	HALMAC_IP_SEL_INTF_PHY = 0,
+	HALMAC_IP_SEL_MAC = 1,
+	HALMAC_IP_SEL_PCIE_DBI = 2,
+	HALMAC_IP_SEL_UNDEFINE = 0x7FFF,
+};
+
+/* Platform mask */
+enum halmac_intf_phy_platform {
+	HALMAC_INTF_PHY_PLATFORM_ALL = 0x7FFF,
+};
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_original_c2h_nic.h b/drivers/staging/rtlwifi/halmac/halmac_original_c2h_nic.h
new file mode 100644
index 000000000000..4331e2ae14c2
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_original_c2h_nic.h
@@ -0,0 +1,403 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HAL_ORIGINALC2HFORMAT_H2C_C2H_NIC_H_
+#define _HAL_ORIGINALC2HFORMAT_H2C_C2H_NIC_H_
+#define CMD_ID_C2H 0X00
+#define CMD_ID_DBG 0X00
+#define CMD_ID_C2H_LB 0X01
+#define CMD_ID_C2H_SND_TXBF 0X02
+#define CMD_ID_C2H_CCX_RPT 0X03
+#define CMD_ID_C2H_AP_REQ_TXRPT 0X04
+#define CMD_ID_C2H_INITIAL_RATE_COLLECTION 0X05
+#define CMD_ID_C2H_RA_RPT 0X0C
+#define CMD_ID_C2H_SPECIAL_STATISTICS 0X0D
+#define CMD_ID_C2H_RA_PARA_RPT 0X0E
+#define CMD_ID_C2H_CUR_CHANNEL 0X10
+#define CMD_ID_C2H_GPIO_WAKEUP 0X14
+#define C2H_GET_CMD_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 0, 8)
+#define C2H_SET_CMD_ID(__c2h, __value)                                         \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 0, 8, __value)
+#define C2H_GET_SEQ(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 8, 8)
+#define C2H_SET_SEQ(__c2h, __value)                                            \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 8, 8, __value)
+#define DBG_GET_CMD_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 0, 8)
+#define DBG_SET_CMD_ID(__c2h, __value)                                         \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 0, 8, __value)
+#define DBG_GET_SEQ(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 8, 8)
+#define DBG_SET_SEQ(__c2h, __value)                                            \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 8, 8, __value)
+#define DBG_GET_DBG_STR1(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 16, 8)
+#define DBG_SET_DBG_STR1(__c2h, __value)                                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 16, 8, __value)
+#define DBG_GET_DBG_STR2(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 24, 8)
+#define DBG_SET_DBG_STR2(__c2h, __value)                                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 24, 8, __value)
+#define DBG_GET_DBG_STR3(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 0, 8)
+#define DBG_SET_DBG_STR3(__c2h, __value)                                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 0, 8, __value)
+#define DBG_GET_DBG_STR4(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 8, 8)
+#define DBG_SET_DBG_STR4(__c2h, __value)                                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 8, 8, __value)
+#define DBG_GET_DBG_STR5(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 16, 8)
+#define DBG_SET_DBG_STR5(__c2h, __value)                                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 16, 8, __value)
+#define DBG_GET_DBG_STR6(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 24, 8)
+#define DBG_SET_DBG_STR6(__c2h, __value)                                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 24, 8, __value)
+#define DBG_GET_DBG_STR7(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X08, 0, 8)
+#define DBG_SET_DBG_STR7(__c2h, __value)                                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 0, 8, __value)
+#define DBG_GET_DBG_STR8(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X08, 8, 8)
+#define DBG_SET_DBG_STR8(__c2h, __value)                                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 8, 8, __value)
+#define DBG_GET_DBG_STR9(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X08, 16, 8)
+#define DBG_SET_DBG_STR9(__c2h, __value)                                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 16, 8, __value)
+#define DBG_GET_DBG_STR10(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X08, 24, 8)
+#define DBG_SET_DBG_STR10(__c2h, __value)                                      \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 24, 8, __value)
+#define DBG_GET_DBG_STR11(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 0, 8)
+#define DBG_SET_DBG_STR11(__c2h, __value)                                      \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 0, 8, __value)
+#define DBG_GET_DBG_STR12(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 8, 8)
+#define DBG_SET_DBG_STR12(__c2h, __value)                                      \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 8, 8, __value)
+#define DBG_GET_LEN(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 16, 8)
+#define DBG_SET_LEN(__c2h, __value)                                            \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 16, 8, __value)
+#define DBG_GET_TRIGGER(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 24, 8)
+#define DBG_SET_TRIGGER(__c2h, __value)                                        \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 24, 8, __value)
+#define C2H_LB_GET_CMD_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 0, 8)
+#define C2H_LB_SET_CMD_ID(__c2h, __value)                                      \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 0, 8, __value)
+#define C2H_LB_GET_SEQ(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 8, 8)
+#define C2H_LB_SET_SEQ(__c2h, __value)                                         \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 8, 8, __value)
+#define C2H_LB_GET_PAYLOAD1(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 16, 16)
+#define C2H_LB_SET_PAYLOAD1(__c2h, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 16, 16, __value)
+#define C2H_LB_GET_PAYLOAD2(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 0, 32)
+#define C2H_LB_SET_PAYLOAD2(__c2h, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 0, 32, __value)
+#define C2H_LB_GET_LEN(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 16, 8)
+#define C2H_LB_SET_LEN(__c2h, __value)                                         \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 16, 8, __value)
+#define C2H_LB_GET_TRIGGER(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 24, 8)
+#define C2H_LB_SET_TRIGGER(__c2h, __value)                                     \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 24, 8, __value)
+#define C2H_SND_TXBF_GET_CMD_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 0, 8)
+#define C2H_SND_TXBF_SET_CMD_ID(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 0, 8, __value)
+#define C2H_SND_TXBF_GET_SEQ(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 8, 8)
+#define C2H_SND_TXBF_SET_SEQ(__c2h, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 8, 8, __value)
+#define C2H_SND_TXBF_GET_SND_RESULT(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 16, 1)
+#define C2H_SND_TXBF_SET_SND_RESULT(__c2h, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 16, 1, __value)
+#define C2H_SND_TXBF_GET_LEN(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 16, 8)
+#define C2H_SND_TXBF_SET_LEN(__c2h, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 16, 8, __value)
+#define C2H_SND_TXBF_GET_TRIGGER(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 24, 8)
+#define C2H_SND_TXBF_SET_TRIGGER(__c2h, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 24, 8, __value)
+#define C2H_CCX_RPT_GET_CMD_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 0, 8)
+#define C2H_CCX_RPT_SET_CMD_ID(__c2h, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 0, 8, __value)
+#define C2H_CCX_RPT_GET_SEQ(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 8, 8)
+#define C2H_CCX_RPT_SET_SEQ(__c2h, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 8, 8, __value)
+#define C2H_CCX_RPT_GET_QSEL(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 16, 5)
+#define C2H_CCX_RPT_SET_QSEL(__c2h, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 16, 5, __value)
+#define C2H_CCX_RPT_GET_BMC(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 21, 1)
+#define C2H_CCX_RPT_SET_BMC(__c2h, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 21, 1, __value)
+#define C2H_CCX_RPT_GET_LIFE_TIME_OVER(__c2h)                                  \
+	LE_BITS_TO_4BYTE(__c2h + 0X00, 22, 1)
+#define C2H_CCX_RPT_SET_LIFE_TIME_OVER(__c2h, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 22, 1, __value)
+#define C2H_CCX_RPT_GET_RETRY_OVER(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 23, 1)
+#define C2H_CCX_RPT_SET_RETRY_OVER(__c2h, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 23, 1, __value)
+#define C2H_CCX_RPT_GET_MACID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 24, 8)
+#define C2H_CCX_RPT_SET_MACID(__c2h, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 24, 8, __value)
+#define C2H_CCX_RPT_GET_DATA_RETRY_CNT(__c2h)                                  \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 0, 6)
+#define C2H_CCX_RPT_SET_DATA_RETRY_CNT(__c2h, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 0, 6, __value)
+#define C2H_CCX_RPT_GET_QUEUE7_0(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 8, 8)
+#define C2H_CCX_RPT_SET_QUEUE7_0(__c2h, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 8, 8, __value)
+#define C2H_CCX_RPT_GET_QUEUE15_8(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 16, 8)
+#define C2H_CCX_RPT_SET_QUEUE15_8(__c2h, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 16, 8, __value)
+#define C2H_CCX_RPT_GET_FINAL_DATA_RATE(__c2h)                                 \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 24, 8)
+#define C2H_CCX_RPT_SET_FINAL_DATA_RATE(__c2h, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 24, 8, __value)
+#define C2H_CCX_RPT_GET_SW_DEFINE_0(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X08, 0, 8)
+#define C2H_CCX_RPT_SET_SW_DEFINE_0(__c2h, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 0, 8, __value)
+#define C2H_CCX_RPT_GET_SW_DEFINE_1(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X08, 8, 4)
+#define C2H_CCX_RPT_SET_SW_DEFINE_1(__c2h, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 8, 4, __value)
+#define C2H_CCX_RPT_GET_LEN(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 16, 8)
+#define C2H_CCX_RPT_SET_LEN(__c2h, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 16, 8, __value)
+#define C2H_CCX_RPT_GET_TRIGGER(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 24, 8)
+#define C2H_CCX_RPT_SET_TRIGGER(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 24, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_CMD_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 0, 8)
+#define C2H_AP_REQ_TXRPT_SET_CMD_ID(__c2h, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 0, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_SEQ(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 8, 8)
+#define C2H_AP_REQ_TXRPT_SET_SEQ(__c2h, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 8, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_STA1_MACID(__c2h)                                 \
+	LE_BITS_TO_4BYTE(__c2h + 0X00, 16, 8)
+#define C2H_AP_REQ_TXRPT_SET_STA1_MACID(__c2h, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 16, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_TX_OK1_0(__c2h)                                   \
+	LE_BITS_TO_4BYTE(__c2h + 0X00, 24, 8)
+#define C2H_AP_REQ_TXRPT_SET_TX_OK1_0(__c2h, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 24, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_TX_OK1_1(__c2h)                                   \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 0, 8)
+#define C2H_AP_REQ_TXRPT_SET_TX_OK1_1(__c2h, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 0, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_TX_FAIL1_0(__c2h)                                 \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 8, 8)
+#define C2H_AP_REQ_TXRPT_SET_TX_FAIL1_0(__c2h, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 8, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_TX_FAIL1_1(__c2h)                                 \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 16, 8)
+#define C2H_AP_REQ_TXRPT_SET_TX_FAIL1_1(__c2h, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 16, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_INITIAL_RATE1(__c2h)                              \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 24, 8)
+#define C2H_AP_REQ_TXRPT_SET_INITIAL_RATE1(__c2h, __value)                     \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 24, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_STA2_MACID(__c2h)                                 \
+	LE_BITS_TO_4BYTE(__c2h + 0X08, 0, 8)
+#define C2H_AP_REQ_TXRPT_SET_STA2_MACID(__c2h, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 0, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_TX_OK2_0(__c2h)                                   \
+	LE_BITS_TO_4BYTE(__c2h + 0X08, 8, 8)
+#define C2H_AP_REQ_TXRPT_SET_TX_OK2_0(__c2h, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 8, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_TX_OK2_1(__c2h)                                   \
+	LE_BITS_TO_4BYTE(__c2h + 0X08, 16, 8)
+#define C2H_AP_REQ_TXRPT_SET_TX_OK2_1(__c2h, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 16, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_TX_FAIL2_0(__c2h)                                 \
+	LE_BITS_TO_4BYTE(__c2h + 0X08, 24, 8)
+#define C2H_AP_REQ_TXRPT_SET_TX_FAIL2_0(__c2h, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 24, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_TX_FAIL2_1(__c2h)                                 \
+	LE_BITS_TO_4BYTE(__c2h + 0X0C, 0, 8)
+#define C2H_AP_REQ_TXRPT_SET_TX_FAIL2_1(__c2h, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 0, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_INITIAL_RATE2(__c2h)                              \
+	LE_BITS_TO_4BYTE(__c2h + 0X0C, 8, 8)
+#define C2H_AP_REQ_TXRPT_SET_INITIAL_RATE2(__c2h, __value)                     \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 8, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_LEN(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 16, 8)
+#define C2H_AP_REQ_TXRPT_SET_LEN(__c2h, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 16, 8, __value)
+#define C2H_AP_REQ_TXRPT_GET_TRIGGER(__c2h)                                    \
+	LE_BITS_TO_4BYTE(__c2h + 0X0C, 24, 8)
+#define C2H_AP_REQ_TXRPT_SET_TRIGGER(__c2h, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 24, 8, __value)
+#define C2H_INITIAL_RATE_COLLECTION_GET_CMD_ID(__c2h)                          \
+	LE_BITS_TO_4BYTE(__c2h + 0X00, 0, 8)
+#define C2H_INITIAL_RATE_COLLECTION_SET_CMD_ID(__c2h, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 0, 8, __value)
+#define C2H_INITIAL_RATE_COLLECTION_GET_SEQ(__c2h)                             \
+	LE_BITS_TO_4BYTE(__c2h + 0X00, 8, 8)
+#define C2H_INITIAL_RATE_COLLECTION_SET_SEQ(__c2h, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 8, 8, __value)
+#define C2H_INITIAL_RATE_COLLECTION_GET_TRYING_BITMAP(__c2h)                   \
+	LE_BITS_TO_4BYTE(__c2h + 0X00, 16, 7)
+#define C2H_INITIAL_RATE_COLLECTION_SET_TRYING_BITMAP(__c2h, __value)          \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 16, 7, __value)
+#define C2H_INITIAL_RATE_COLLECTION_GET_INITIAL_RATE1(__c2h)                   \
+	LE_BITS_TO_4BYTE(__c2h + 0X00, 24, 8)
+#define C2H_INITIAL_RATE_COLLECTION_SET_INITIAL_RATE1(__c2h, __value)          \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 24, 8, __value)
+#define C2H_INITIAL_RATE_COLLECTION_GET_INITIAL_RATE2(__c2h)                   \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 0, 8)
+#define C2H_INITIAL_RATE_COLLECTION_SET_INITIAL_RATE2(__c2h, __value)          \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 0, 8, __value)
+#define C2H_INITIAL_RATE_COLLECTION_GET_INITIAL_RATE3(__c2h)                   \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 8, 8)
+#define C2H_INITIAL_RATE_COLLECTION_SET_INITIAL_RATE3(__c2h, __value)          \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 8, 8, __value)
+#define C2H_INITIAL_RATE_COLLECTION_GET_INITIAL_RATE4(__c2h)                   \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 16, 8)
+#define C2H_INITIAL_RATE_COLLECTION_SET_INITIAL_RATE4(__c2h, __value)          \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 16, 8, __value)
+#define C2H_INITIAL_RATE_COLLECTION_GET_INITIAL_RATE5(__c2h)                   \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 24, 8)
+#define C2H_INITIAL_RATE_COLLECTION_SET_INITIAL_RATE5(__c2h, __value)          \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 24, 8, __value)
+#define C2H_INITIAL_RATE_COLLECTION_GET_INITIAL_RATE6(__c2h)                   \
+	LE_BITS_TO_4BYTE(__c2h + 0X08, 0, 8)
+#define C2H_INITIAL_RATE_COLLECTION_SET_INITIAL_RATE6(__c2h, __value)          \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 0, 8, __value)
+#define C2H_INITIAL_RATE_COLLECTION_GET_INITIAL_RATE7(__c2h)                   \
+	LE_BITS_TO_4BYTE(__c2h + 0X08, 8, 8)
+#define C2H_INITIAL_RATE_COLLECTION_SET_INITIAL_RATE7(__c2h, __value)          \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 8, 8, __value)
+#define C2H_INITIAL_RATE_COLLECTION_GET_LEN(__c2h)                             \
+	LE_BITS_TO_4BYTE(__c2h + 0X0C, 16, 8)
+#define C2H_INITIAL_RATE_COLLECTION_SET_LEN(__c2h, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 16, 8, __value)
+#define C2H_INITIAL_RATE_COLLECTION_GET_TRIGGER(__c2h)                         \
+	LE_BITS_TO_4BYTE(__c2h + 0X0C, 24, 8)
+#define C2H_INITIAL_RATE_COLLECTION_SET_TRIGGER(__c2h, __value)                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 24, 8, __value)
+#define C2H_RA_RPT_GET_CMD_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 0, 8)
+#define C2H_RA_RPT_SET_CMD_ID(__c2h, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 0, 8, __value)
+#define C2H_RA_RPT_GET_SEQ(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 8, 8)
+#define C2H_RA_RPT_SET_SEQ(__c2h, __value)                                     \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 8, 8, __value)
+#define C2H_RA_RPT_GET_RATE(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 16, 8)
+#define C2H_RA_RPT_SET_RATE(__c2h, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 16, 8, __value)
+#define C2H_RA_RPT_GET_MACID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 24, 8)
+#define C2H_RA_RPT_SET_MACID(__c2h, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 24, 8, __value)
+#define C2H_RA_RPT_GET_USE_LDPC(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 0, 1)
+#define C2H_RA_RPT_SET_USE_LDPC(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 0, 1, __value)
+#define C2H_RA_RPT_GET_USE_TXBF(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X04, 1, 1)
+#define C2H_RA_RPT_SET_USE_TXBF(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 1, 1, __value)
+#define C2H_RA_RPT_GET_COLLISION_STATE(__c2h)                                  \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 8, 8)
+#define C2H_RA_RPT_SET_COLLISION_STATE(__c2h, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 8, 8, __value)
+#define C2H_RA_RPT_GET_LEN(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 16, 8)
+#define C2H_RA_RPT_SET_LEN(__c2h, __value)                                     \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 16, 8, __value)
+#define C2H_RA_RPT_GET_TRIGGER(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 24, 8)
+#define C2H_RA_RPT_SET_TRIGGER(__c2h, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 24, 8, __value)
+#define C2H_SPECIAL_STATISTICS_GET_CMD_ID(__c2h)                               \
+	LE_BITS_TO_4BYTE(__c2h + 0X00, 0, 8)
+#define C2H_SPECIAL_STATISTICS_SET_CMD_ID(__c2h, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 0, 8, __value)
+#define C2H_SPECIAL_STATISTICS_GET_SEQ(__c2h)                                  \
+	LE_BITS_TO_4BYTE(__c2h + 0X00, 8, 8)
+#define C2H_SPECIAL_STATISTICS_SET_SEQ(__c2h, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 8, 8, __value)
+#define C2H_SPECIAL_STATISTICS_GET_STATISTICS_IDX(__c2h)                       \
+	LE_BITS_TO_4BYTE(__c2h + 0X00, 16, 8)
+#define C2H_SPECIAL_STATISTICS_SET_STATISTICS_IDX(__c2h, __value)              \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 16, 8, __value)
+#define C2H_SPECIAL_STATISTICS_GET_DATA0(__c2h)                                \
+	LE_BITS_TO_4BYTE(__c2h + 0X00, 24, 8)
+#define C2H_SPECIAL_STATISTICS_SET_DATA0(__c2h, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 24, 8, __value)
+#define C2H_SPECIAL_STATISTICS_GET_DATA1(__c2h)                                \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 0, 8)
+#define C2H_SPECIAL_STATISTICS_SET_DATA1(__c2h, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 0, 8, __value)
+#define C2H_SPECIAL_STATISTICS_GET_DATA2(__c2h)                                \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 8, 8)
+#define C2H_SPECIAL_STATISTICS_SET_DATA2(__c2h, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 8, 8, __value)
+#define C2H_SPECIAL_STATISTICS_GET_DATA3(__c2h)                                \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 16, 8)
+#define C2H_SPECIAL_STATISTICS_SET_DATA3(__c2h, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 16, 8, __value)
+#define C2H_SPECIAL_STATISTICS_GET_DATA4(__c2h)                                \
+	LE_BITS_TO_4BYTE(__c2h + 0X04, 24, 8)
+#define C2H_SPECIAL_STATISTICS_SET_DATA4(__c2h, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X04, 24, 8, __value)
+#define C2H_SPECIAL_STATISTICS_GET_DATA5(__c2h)                                \
+	LE_BITS_TO_4BYTE(__c2h + 0X08, 0, 8)
+#define C2H_SPECIAL_STATISTICS_SET_DATA5(__c2h, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 0, 8, __value)
+#define C2H_SPECIAL_STATISTICS_GET_DATA6(__c2h)                                \
+	LE_BITS_TO_4BYTE(__c2h + 0X08, 8, 8)
+#define C2H_SPECIAL_STATISTICS_SET_DATA6(__c2h, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 8, 8, __value)
+#define C2H_SPECIAL_STATISTICS_GET_DATA7(__c2h)                                \
+	LE_BITS_TO_4BYTE(__c2h + 0X08, 16, 8)
+#define C2H_SPECIAL_STATISTICS_SET_DATA7(__c2h, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X08, 16, 8, __value)
+#define C2H_SPECIAL_STATISTICS_GET_LEN(__c2h)                                  \
+	LE_BITS_TO_4BYTE(__c2h + 0X0C, 16, 8)
+#define C2H_SPECIAL_STATISTICS_SET_LEN(__c2h, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 16, 8, __value)
+#define C2H_SPECIAL_STATISTICS_GET_TRIGGER(__c2h)                              \
+	LE_BITS_TO_4BYTE(__c2h + 0X0C, 24, 8)
+#define C2H_SPECIAL_STATISTICS_SET_TRIGGER(__c2h, __value)                     \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 24, 8, __value)
+#define C2H_RA_PARA_RPT_GET_CMD_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 0, 8)
+#define C2H_RA_PARA_RPT_SET_CMD_ID(__c2h, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 0, 8, __value)
+#define C2H_RA_PARA_RPT_GET_SEQ(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 8, 8)
+#define C2H_RA_PARA_RPT_SET_SEQ(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 8, 8, __value)
+#define C2H_RA_PARA_RPT_GET_LEN(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 16, 8)
+#define C2H_RA_PARA_RPT_SET_LEN(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 16, 8, __value)
+#define C2H_RA_PARA_RPT_GET_TRIGGER(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 24, 8)
+#define C2H_RA_PARA_RPT_SET_TRIGGER(__c2h, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 24, 8, __value)
+#define C2H_CUR_CHANNEL_GET_CMD_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 0, 8)
+#define C2H_CUR_CHANNEL_SET_CMD_ID(__c2h, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 0, 8, __value)
+#define C2H_CUR_CHANNEL_GET_SEQ(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 8, 8)
+#define C2H_CUR_CHANNEL_SET_SEQ(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 8, 8, __value)
+#define C2H_CUR_CHANNEL_GET_CHANNEL_NUM(__c2h)                                 \
+	LE_BITS_TO_4BYTE(__c2h + 0X00, 16, 8)
+#define C2H_CUR_CHANNEL_SET_CHANNEL_NUM(__c2h, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 16, 8, __value)
+#define C2H_CUR_CHANNEL_GET_LEN(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 16, 8)
+#define C2H_CUR_CHANNEL_SET_LEN(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 16, 8, __value)
+#define C2H_CUR_CHANNEL_GET_TRIGGER(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 24, 8)
+#define C2H_CUR_CHANNEL_SET_TRIGGER(__c2h, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 24, 8, __value)
+#define C2H_GPIO_WAKEUP_GET_CMD_ID(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 0, 8)
+#define C2H_GPIO_WAKEUP_SET_CMD_ID(__c2h, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 0, 8, __value)
+#define C2H_GPIO_WAKEUP_GET_SEQ(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X00, 8, 8)
+#define C2H_GPIO_WAKEUP_SET_SEQ(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X00, 8, 8, __value)
+#define C2H_GPIO_WAKEUP_GET_LEN(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 16, 8)
+#define C2H_GPIO_WAKEUP_SET_LEN(__c2h, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 16, 8, __value)
+#define C2H_GPIO_WAKEUP_GET_TRIGGER(__c2h) LE_BITS_TO_4BYTE(__c2h + 0X0C, 24, 8)
+#define C2H_GPIO_WAKEUP_SET_TRIGGER(__c2h, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__c2h + 0X0C, 24, 8, __value)
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_original_h2c_nic.h b/drivers/staging/rtlwifi/halmac/halmac_original_h2c_nic.h
new file mode 100644
index 000000000000..db7aac4de843
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_original_h2c_nic.h
@@ -0,0 +1,1011 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HAL_ORIGINALH2CFORMAT_H2C_C2H_NIC_H_
+#define _HAL_ORIGINALH2CFORMAT_H2C_C2H_NIC_H_
+#define CMD_ID_ORIGINAL_H2C 0X00
+#define CMD_ID_H2C2H_LB 0X0
+#define CMD_ID_D0_SCAN_OFFLOAD_CTRL 0X06
+#define CMD_ID_RSVD_PAGE 0X0
+#define CMD_ID_MEDIA_STATUS_RPT 0X01
+#define CMD_ID_KEEP_ALIVE 0X03
+#define CMD_ID_DISCONNECT_DECISION 0X04
+#define CMD_ID_AP_OFFLOAD 0X08
+#define CMD_ID_BCN_RSVDPAGE 0X09
+#define CMD_ID_PROBE_RSP_RSVDPAGE 0X0A
+#define CMD_ID_SET_PWR_MODE 0X00
+#define CMD_ID_PS_TUNING_PARA 0X01
+#define CMD_ID_PS_TUNING_PARA_II 0X02
+#define CMD_ID_PS_LPS_PARA 0X03
+#define CMD_ID_P2P_PS_OFFLOAD 0X04
+#define CMD_ID_PS_SCAN_EN 0X05
+#define CMD_ID_SAP_PS 0X06
+#define CMD_ID_INACTIVE_PS 0X07
+#define CMD_ID_MACID_CFG 0X00
+#define CMD_ID_TXBF 0X01
+#define CMD_ID_RSSI_SETTING 0X02
+#define CMD_ID_AP_REQ_TXRPT 0X03
+#define CMD_ID_INIT_RATE_COLLECTION 0X04
+#define CMD_ID_IQK_OFFLOAD 0X05
+#define CMD_ID_MACID_CFG_3SS 0X06
+#define CMD_ID_RA_PARA_ADJUST 0X07
+#define CMD_ID_WWLAN 0X00
+#define CMD_ID_REMOTE_WAKE_CTRL 0X01
+#define CMD_ID_AOAC_GLOBAL_INFO 0X02
+#define CMD_ID_AOAC_RSVD_PAGE 0X03
+#define CMD_ID_AOAC_RSVD_PAGE2 0X04
+#define CMD_ID_D0_SCAN_OFFLOAD_INFO 0X05
+#define CMD_ID_CHANNEL_SWITCH_OFFLOAD 0X07
+#define CMD_ID_AOAC_RSVD_PAGE3 0X08
+#define CLASS_ORIGINAL_H2C 0X00
+#define CLASS_H2C2H_LB 0X07
+#define CLASS_D0_SCAN_OFFLOAD_CTRL 0X04
+#define CLASS_RSVD_PAGE 0X0
+#define CLASS_MEDIA_STATUS_RPT 0X0
+#define CLASS_KEEP_ALIVE 0X0
+#define CLASS_DISCONNECT_DECISION 0X0
+#define CLASS_AP_OFFLOAD 0X0
+#define CLASS_BCN_RSVDPAGE 0X0
+#define CLASS_PROBE_RSP_RSVDPAGE 0X0
+#define CLASS_SET_PWR_MODE 0X01
+#define CLASS_PS_TUNING_PARA 0X01
+#define CLASS_PS_TUNING_PARA_II 0X01
+#define CLASS_PS_LPS_PARA 0X01
+#define CLASS_P2P_PS_OFFLOAD 0X01
+#define CLASS_PS_SCAN_EN 0X1
+#define CLASS_SAP_PS 0X1
+#define CLASS_INACTIVE_PS 0X1
+#define CLASS_MACID_CFG 0X2
+#define CLASS_TXBF 0X2
+#define CLASS_RSSI_SETTING 0X2
+#define CLASS_AP_REQ_TXRPT 0X2
+#define CLASS_INIT_RATE_COLLECTION 0X2
+#define CLASS_IQK_OFFLOAD 0X2
+#define CLASS_MACID_CFG_3SS 0X2
+#define CLASS_RA_PARA_ADJUST 0X02
+#define CLASS_WWLAN 0X4
+#define CLASS_REMOTE_WAKE_CTRL 0X4
+#define CLASS_AOAC_GLOBAL_INFO 0X04
+#define CLASS_AOAC_RSVD_PAGE 0X04
+#define CLASS_AOAC_RSVD_PAGE2 0X04
+#define CLASS_D0_SCAN_OFFLOAD_INFO 0X04
+#define CLASS_CHANNEL_SWITCH_OFFLOAD 0X04
+#define CLASS_AOAC_RSVD_PAGE3 0X04
+#define ORIGINAL_H2C_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define ORIGINAL_H2C_SET_CMD_ID(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define ORIGINAL_H2C_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define ORIGINAL_H2C_SET_CLASS(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define H2C2H_LB_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define H2C2H_LB_SET_CMD_ID(__h2c, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define H2C2H_LB_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define H2C2H_LB_SET_CLASS(__h2c, __value)                                     \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define H2C2H_LB_GET_SEQ(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define H2C2H_LB_SET_SEQ(__h2c, __value)                                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define H2C2H_LB_GET_PAYLOAD1(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 16)
+#define H2C2H_LB_SET_PAYLOAD1(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 16, __value)
+#define H2C2H_LB_GET_PAYLOAD2(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 32)
+#define H2C2H_LB_SET_PAYLOAD2(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 32, __value)
+#define D0_SCAN_OFFLOAD_CTRL_GET_CMD_ID(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define D0_SCAN_OFFLOAD_CTRL_SET_CMD_ID(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define D0_SCAN_OFFLOAD_CTRL_GET_CLASS(__h2c)                                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define D0_SCAN_OFFLOAD_CTRL_SET_CLASS(__h2c, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define D0_SCAN_OFFLOAD_CTRL_GET_D0_SCAN_FUN_EN(__h2c)                         \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 1)
+#define D0_SCAN_OFFLOAD_CTRL_SET_D0_SCAN_FUN_EN(__h2c, __value)                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 1, __value)
+#define D0_SCAN_OFFLOAD_CTRL_GET_RTD3FUN_EN(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 9, 1)
+#define D0_SCAN_OFFLOAD_CTRL_SET_RTD3FUN_EN(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 9, 1, __value)
+#define D0_SCAN_OFFLOAD_CTRL_GET_U3_SCAN_FUN_EN(__h2c)                         \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 10, 1)
+#define D0_SCAN_OFFLOAD_CTRL_SET_U3_SCAN_FUN_EN(__h2c, __value)                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 10, 1, __value)
+#define D0_SCAN_OFFLOAD_CTRL_GET_NLO_FUN_EN(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 11, 1)
+#define D0_SCAN_OFFLOAD_CTRL_SET_NLO_FUN_EN(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 11, 1, __value)
+#define D0_SCAN_OFFLOAD_CTRL_GET_IPS_DEPENDENT(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 12, 1)
+#define D0_SCAN_OFFLOAD_CTRL_SET_IPS_DEPENDENT(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 12, 1, __value)
+#define D0_SCAN_OFFLOAD_CTRL_GET_LOC_PROBE_PACKET(__h2c)                       \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 17)
+#define D0_SCAN_OFFLOAD_CTRL_SET_LOC_PROBE_PACKET(__h2c, __value)              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 17, __value)
+#define D0_SCAN_OFFLOAD_CTRL_GET_LOC_SCAN_INFO(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define D0_SCAN_OFFLOAD_CTRL_SET_LOC_SCAN_INFO(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define D0_SCAN_OFFLOAD_CTRL_GET_LOC_SSID_INFO(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 8)
+#define D0_SCAN_OFFLOAD_CTRL_SET_LOC_SSID_INFO(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 8, __value)
+#define RSVD_PAGE_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define RSVD_PAGE_SET_CMD_ID(__h2c, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define RSVD_PAGE_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define RSVD_PAGE_SET_CLASS(__h2c, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define RSVD_PAGE_GET_LOC_PROBE_RSP(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define RSVD_PAGE_SET_LOC_PROBE_RSP(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define RSVD_PAGE_GET_LOC_PS_POLL(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define RSVD_PAGE_SET_LOC_PS_POLL(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define RSVD_PAGE_GET_LOC_NULL_DATA(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define RSVD_PAGE_SET_LOC_NULL_DATA(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define RSVD_PAGE_GET_LOC_QOS_NULL(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 8)
+#define RSVD_PAGE_SET_LOC_QOS_NULL(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 8, __value)
+#define RSVD_PAGE_GET_LOC_BT_QOS_NULL(__h2c)                                   \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 8, 8)
+#define RSVD_PAGE_SET_LOC_BT_QOS_NULL(__h2c, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 8, 8, __value)
+#define RSVD_PAGE_GET_LOC_CTS2SELF(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 16, 8)
+#define RSVD_PAGE_SET_LOC_CTS2SELF(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 16, 8, __value)
+#define RSVD_PAGE_GET_LOC_LTECOEX_QOSNULL(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 24, 8)
+#define RSVD_PAGE_SET_LOC_LTECOEX_QOSNULL(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 24, 8, __value)
+#define MEDIA_STATUS_RPT_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define MEDIA_STATUS_RPT_SET_CMD_ID(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define MEDIA_STATUS_RPT_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define MEDIA_STATUS_RPT_SET_CLASS(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define MEDIA_STATUS_RPT_GET_OP_MODE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 1)
+#define MEDIA_STATUS_RPT_SET_OP_MODE(__h2c, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 1, __value)
+#define MEDIA_STATUS_RPT_GET_MACID_IN(__h2c)                                   \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 9, 1)
+#define MEDIA_STATUS_RPT_SET_MACID_IN(__h2c, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 9, 1, __value)
+#define MEDIA_STATUS_RPT_GET_MACID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define MEDIA_STATUS_RPT_SET_MACID(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define MEDIA_STATUS_RPT_GET_MACID_END(__h2c)                                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define MEDIA_STATUS_RPT_SET_MACID_END(__h2c, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define KEEP_ALIVE_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define KEEP_ALIVE_SET_CMD_ID(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define KEEP_ALIVE_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define KEEP_ALIVE_SET_CLASS(__h2c, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define KEEP_ALIVE_GET_ENABLE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 1)
+#define KEEP_ALIVE_SET_ENABLE(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 1, __value)
+#define KEEP_ALIVE_GET_ADOPT_USER_SETTING(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 9, 1)
+#define KEEP_ALIVE_SET_ADOPT_USER_SETTING(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 9, 1, __value)
+#define KEEP_ALIVE_GET_PKT_TYPE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 10, 1)
+#define KEEP_ALIVE_SET_PKT_TYPE(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 10, 1, __value)
+#define KEEP_ALIVE_GET_KEEP_ALIVE_CHECK_PERIOD(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define KEEP_ALIVE_SET_KEEP_ALIVE_CHECK_PERIOD(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define DISCONNECT_DECISION_GET_CMD_ID(__h2c)                                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define DISCONNECT_DECISION_SET_CMD_ID(__h2c, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define DISCONNECT_DECISION_GET_CLASS(__h2c)                                   \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define DISCONNECT_DECISION_SET_CLASS(__h2c, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define DISCONNECT_DECISION_GET_ENABLE(__h2c)                                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 1)
+#define DISCONNECT_DECISION_SET_ENABLE(__h2c, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 1, __value)
+#define DISCONNECT_DECISION_GET_ADOPT_USER_SETTING(__h2c)                      \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 9, 1)
+#define DISCONNECT_DECISION_SET_ADOPT_USER_SETTING(__h2c, __value)             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 9, 1, __value)
+#define DISCONNECT_DECISION_GET_TRY_OK_BCN_FAIL_COUNT_EN(__h2c)                \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 10, 1)
+#define DISCONNECT_DECISION_SET_TRY_OK_BCN_FAIL_COUNT_EN(__h2c, __value)       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 10, 1, __value)
+#define DISCONNECT_DECISION_GET_DISCONNECT_EN(__h2c)                           \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 11, 1)
+#define DISCONNECT_DECISION_SET_DISCONNECT_EN(__h2c, __value)                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 11, 1, __value)
+#define DISCONNECT_DECISION_GET_DISCON_DECISION_CHECK_PERIOD(__h2c)            \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define DISCONNECT_DECISION_SET_DISCON_DECISION_CHECK_PERIOD(__h2c, __value)   \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define DISCONNECT_DECISION_GET_TRY_PKT_NUM(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define DISCONNECT_DECISION_SET_TRY_PKT_NUM(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define DISCONNECT_DECISION_GET_TRY_OK_BCN_FAIL_COUNT_LIMIT(__h2c)             \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 8)
+#define DISCONNECT_DECISION_SET_TRY_OK_BCN_FAIL_COUNT_LIMIT(__h2c, __value)    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 8, __value)
+#define AP_OFFLOAD_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define AP_OFFLOAD_SET_CMD_ID(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define AP_OFFLOAD_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define AP_OFFLOAD_SET_CLASS(__h2c, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define AP_OFFLOAD_GET_ON(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 1)
+#define AP_OFFLOAD_SET_ON(__h2c, __value)                                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 1, __value)
+#define AP_OFFLOAD_GET_CFG_MIFI_PLATFORM(__h2c)                                \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 9, 1)
+#define AP_OFFLOAD_SET_CFG_MIFI_PLATFORM(__h2c, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 9, 1, __value)
+#define AP_OFFLOAD_GET_LINKED(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 10, 1)
+#define AP_OFFLOAD_SET_LINKED(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 10, 1, __value)
+#define AP_OFFLOAD_GET_EN_AUTO_WAKE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 11, 1)
+#define AP_OFFLOAD_SET_EN_AUTO_WAKE(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 11, 1, __value)
+#define AP_OFFLOAD_GET_WAKE_FLAG(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 12, 1)
+#define AP_OFFLOAD_SET_WAKE_FLAG(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 12, 1, __value)
+#define AP_OFFLOAD_GET_HIDDEN_ROOT(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 1)
+#define AP_OFFLOAD_SET_HIDDEN_ROOT(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 1, __value)
+#define AP_OFFLOAD_GET_HIDDEN_VAP1(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 17, 1)
+#define AP_OFFLOAD_SET_HIDDEN_VAP1(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 17, 1, __value)
+#define AP_OFFLOAD_GET_HIDDEN_VAP2(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 18, 1)
+#define AP_OFFLOAD_SET_HIDDEN_VAP2(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 18, 1, __value)
+#define AP_OFFLOAD_GET_HIDDEN_VAP3(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 19, 1)
+#define AP_OFFLOAD_SET_HIDDEN_VAP3(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 19, 1, __value)
+#define AP_OFFLOAD_GET_HIDDEN_VAP4(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 20, 1)
+#define AP_OFFLOAD_SET_HIDDEN_VAP4(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 20, 1, __value)
+#define AP_OFFLOAD_GET_DENYANY_ROOT(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 1)
+#define AP_OFFLOAD_SET_DENYANY_ROOT(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 1, __value)
+#define AP_OFFLOAD_GET_DENYANY_VAP1(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 25, 1)
+#define AP_OFFLOAD_SET_DENYANY_VAP1(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 25, 1, __value)
+#define AP_OFFLOAD_GET_DENYANY_VAP2(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 26, 1)
+#define AP_OFFLOAD_SET_DENYANY_VAP2(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 26, 1, __value)
+#define AP_OFFLOAD_GET_DENYANY_VAP3(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 27, 1)
+#define AP_OFFLOAD_SET_DENYANY_VAP3(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 27, 1, __value)
+#define AP_OFFLOAD_GET_DENYANY_VAP4(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 28, 1)
+#define AP_OFFLOAD_SET_DENYANY_VAP4(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 28, 1, __value)
+#define AP_OFFLOAD_GET_WAIT_TBTT_CNT(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 8)
+#define AP_OFFLOAD_SET_WAIT_TBTT_CNT(__h2c, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 8, __value)
+#define AP_OFFLOAD_GET_WAKE_TIMEOUT(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 8, 8)
+#define AP_OFFLOAD_SET_WAKE_TIMEOUT(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 8, 8, __value)
+#define AP_OFFLOAD_GET_LEN_IV_PAIR(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 16, 8)
+#define AP_OFFLOAD_SET_LEN_IV_PAIR(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 16, 8, __value)
+#define AP_OFFLOAD_GET_LEN_IV_GRP(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 24, 8)
+#define AP_OFFLOAD_SET_LEN_IV_GRP(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 24, 8, __value)
+#define BCN_RSVDPAGE_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define BCN_RSVDPAGE_SET_CMD_ID(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define BCN_RSVDPAGE_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define BCN_RSVDPAGE_SET_CLASS(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define BCN_RSVDPAGE_GET_LOC_ROOT(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define BCN_RSVDPAGE_SET_LOC_ROOT(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define BCN_RSVDPAGE_GET_LOC_VAP1(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define BCN_RSVDPAGE_SET_LOC_VAP1(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define BCN_RSVDPAGE_GET_LOC_VAP2(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define BCN_RSVDPAGE_SET_LOC_VAP2(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define BCN_RSVDPAGE_GET_LOC_VAP3(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 8)
+#define BCN_RSVDPAGE_SET_LOC_VAP3(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 8, __value)
+#define BCN_RSVDPAGE_GET_LOC_VAP4(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 8, 8)
+#define BCN_RSVDPAGE_SET_LOC_VAP4(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 8, 8, __value)
+#define PROBE_RSP_RSVDPAGE_GET_CMD_ID(__h2c)                                   \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define PROBE_RSP_RSVDPAGE_SET_CMD_ID(__h2c, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define PROBE_RSP_RSVDPAGE_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define PROBE_RSP_RSVDPAGE_SET_CLASS(__h2c, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define PROBE_RSP_RSVDPAGE_GET_LOC_ROOT(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define PROBE_RSP_RSVDPAGE_SET_LOC_ROOT(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define PROBE_RSP_RSVDPAGE_GET_LOC_VAP1(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define PROBE_RSP_RSVDPAGE_SET_LOC_VAP1(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define PROBE_RSP_RSVDPAGE_GET_LOC_VAP2(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define PROBE_RSP_RSVDPAGE_SET_LOC_VAP2(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define PROBE_RSP_RSVDPAGE_GET_LOC_VAP3(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 8)
+#define PROBE_RSP_RSVDPAGE_SET_LOC_VAP3(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 8, __value)
+#define PROBE_RSP_RSVDPAGE_GET_LOC_VAP4(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 8, 8)
+#define PROBE_RSP_RSVDPAGE_SET_LOC_VAP4(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 8, 8, __value)
+#define SET_PWR_MODE_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define SET_PWR_MODE_SET_CMD_ID(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define SET_PWR_MODE_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define SET_PWR_MODE_SET_CLASS(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define SET_PWR_MODE_GET_MODE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 7)
+#define SET_PWR_MODE_SET_MODE(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 7, __value)
+#define SET_PWR_MODE_GET_CLK_REQUEST(__h2c)                                    \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 15, 1)
+#define SET_PWR_MODE_SET_CLK_REQUEST(__h2c, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 15, 1, __value)
+#define SET_PWR_MODE_GET_RLBM(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 4)
+#define SET_PWR_MODE_SET_RLBM(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 4, __value)
+#define SET_PWR_MODE_GET_SMART_PS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 20, 4)
+#define SET_PWR_MODE_SET_SMART_PS(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 20, 4, __value)
+#define SET_PWR_MODE_GET_AWAKE_INTERVAL(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define SET_PWR_MODE_SET_AWAKE_INTERVAL(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define SET_PWR_MODE_GET_B_ALL_QUEUE_UAPSD(__h2c)                              \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 1)
+#define SET_PWR_MODE_SET_B_ALL_QUEUE_UAPSD(__h2c, __value)                     \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 1, __value)
+#define SET_PWR_MODE_GET_BCN_EARLY_RPT(__h2c)                                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 2, 1)
+#define SET_PWR_MODE_SET_BCN_EARLY_RPT(__h2c, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 2, 1, __value)
+#define SET_PWR_MODE_GET_PORT_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 5, 3)
+#define SET_PWR_MODE_SET_PORT_ID(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 5, 3, __value)
+#define SET_PWR_MODE_GET_PWR_STATE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 8, 8)
+#define SET_PWR_MODE_SET_PWR_STATE(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 8, 8, __value)
+#define SET_PWR_MODE_GET_LOW_POWER_RX_BCN(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 16, 1)
+#define SET_PWR_MODE_SET_LOW_POWER_RX_BCN(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 16, 1, __value)
+#define SET_PWR_MODE_GET_ANT_AUTO_SWITCH(__h2c)                                \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 17, 1)
+#define SET_PWR_MODE_SET_ANT_AUTO_SWITCH(__h2c, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 17, 1, __value)
+#define SET_PWR_MODE_GET_PS_ALLOW_BT_HIGH_PRIORITY(__h2c)                      \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 18, 1)
+#define SET_PWR_MODE_SET_PS_ALLOW_BT_HIGH_PRIORITY(__h2c, __value)             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 18, 1, __value)
+#define SET_PWR_MODE_GET_PROTECT_BCN(__h2c)                                    \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 19, 1)
+#define SET_PWR_MODE_SET_PROTECT_BCN(__h2c, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 19, 1, __value)
+#define SET_PWR_MODE_GET_SILENCE_PERIOD(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 20, 1)
+#define SET_PWR_MODE_SET_SILENCE_PERIOD(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 20, 1, __value)
+#define SET_PWR_MODE_GET_FAST_BT_CONNECT(__h2c)                                \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 21, 1)
+#define SET_PWR_MODE_SET_FAST_BT_CONNECT(__h2c, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 21, 1, __value)
+#define SET_PWR_MODE_GET_TWO_ANTENNA_EN(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 22, 1)
+#define SET_PWR_MODE_SET_TWO_ANTENNA_EN(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 22, 1, __value)
+#define SET_PWR_MODE_GET_ADOPT_USER_SETTING(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 24, 1)
+#define SET_PWR_MODE_SET_ADOPT_USER_SETTING(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 24, 1, __value)
+#define SET_PWR_MODE_GET_DRV_BCN_EARLY_SHIFT(__h2c)                            \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 25, 3)
+#define SET_PWR_MODE_SET_DRV_BCN_EARLY_SHIFT(__h2c, __value)                   \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 25, 3, __value)
+#define SET_PWR_MODE_GET_DRV_BCN_EARLY_SHIFT2(__h2c)                           \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 28, 4)
+#define SET_PWR_MODE_SET_DRV_BCN_EARLY_SHIFT2(__h2c, __value)                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 28, 4, __value)
+#define PS_TUNING_PARA_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define PS_TUNING_PARA_SET_CMD_ID(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define PS_TUNING_PARA_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define PS_TUNING_PARA_SET_CLASS(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define PS_TUNING_PARA_GET_BCN_TO_LIMIT(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 7)
+#define PS_TUNING_PARA_SET_BCN_TO_LIMIT(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 7, __value)
+#define PS_TUNING_PARA_GET_DTIM_TIME_OUT(__h2c)                                \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 15, 1)
+#define PS_TUNING_PARA_SET_DTIM_TIME_OUT(__h2c, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 15, 1, __value)
+#define PS_TUNING_PARA_GET_PS_TIME_OUT(__h2c)                                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 4)
+#define PS_TUNING_PARA_SET_PS_TIME_OUT(__h2c, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 4, __value)
+#define PS_TUNING_PARA_GET_ADOPT(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define PS_TUNING_PARA_SET_ADOPT(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define PS_TUNING_PARA_II_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define PS_TUNING_PARA_II_SET_CMD_ID(__h2c, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define PS_TUNING_PARA_II_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define PS_TUNING_PARA_II_SET_CLASS(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define PS_TUNING_PARA_II_GET_BCN_TO_PERIOD(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 7)
+#define PS_TUNING_PARA_II_SET_BCN_TO_PERIOD(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 7, __value)
+#define PS_TUNING_PARA_II_GET_ADOPT(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 15, 1)
+#define PS_TUNING_PARA_II_SET_ADOPT(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 15, 1, __value)
+#define PS_TUNING_PARA_II_GET_DRV_EARLY_IVL(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define PS_TUNING_PARA_II_SET_DRV_EARLY_IVL(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define PS_LPS_PARA_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define PS_LPS_PARA_SET_CMD_ID(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define PS_LPS_PARA_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define PS_LPS_PARA_SET_CLASS(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define PS_LPS_PARA_GET_LPS_CONTROL(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define PS_LPS_PARA_SET_LPS_CONTROL(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define P2P_PS_OFFLOAD_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define P2P_PS_OFFLOAD_SET_CMD_ID(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define P2P_PS_OFFLOAD_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define P2P_PS_OFFLOAD_SET_CLASS(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define P2P_PS_OFFLOAD_GET_OFFLOAD_EN(__h2c)                                   \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 1)
+#define P2P_PS_OFFLOAD_SET_OFFLOAD_EN(__h2c, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 1, __value)
+#define P2P_PS_OFFLOAD_GET_ROLE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 9, 1)
+#define P2P_PS_OFFLOAD_SET_ROLE(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 9, 1, __value)
+#define P2P_PS_OFFLOAD_GET_CTWINDOW_EN(__h2c)                                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 10, 1)
+#define P2P_PS_OFFLOAD_SET_CTWINDOW_EN(__h2c, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 10, 1, __value)
+#define P2P_PS_OFFLOAD_GET_NOA0_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 11, 1)
+#define P2P_PS_OFFLOAD_SET_NOA0_EN(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 11, 1, __value)
+#define P2P_PS_OFFLOAD_GET_NOA1_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 12, 1)
+#define P2P_PS_OFFLOAD_SET_NOA1_EN(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 12, 1, __value)
+#define P2P_PS_OFFLOAD_GET_ALL_STA_SLEEP(__h2c)                                \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 13, 1)
+#define P2P_PS_OFFLOAD_SET_ALL_STA_SLEEP(__h2c, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 13, 1, __value)
+#define P2P_PS_OFFLOAD_GET_DISCOVERY(__h2c)                                    \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 14, 1)
+#define P2P_PS_OFFLOAD_SET_DISCOVERY(__h2c, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 14, 1, __value)
+#define PS_SCAN_EN_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define PS_SCAN_EN_SET_CMD_ID(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define PS_SCAN_EN_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define PS_SCAN_EN_SET_CLASS(__h2c, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define PS_SCAN_EN_GET_ENABLE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 1)
+#define PS_SCAN_EN_SET_ENABLE(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 1, __value)
+#define SAP_PS_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define SAP_PS_SET_CMD_ID(__h2c, __value)                                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define SAP_PS_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define SAP_PS_SET_CLASS(__h2c, __value)                                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define SAP_PS_GET_ENABLE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 1)
+#define SAP_PS_SET_ENABLE(__h2c, __value)                                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 1, __value)
+#define SAP_PS_GET_EN_PS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 9, 1)
+#define SAP_PS_SET_EN_PS(__h2c, __value)                                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 9, 1, __value)
+#define SAP_PS_GET_EN_LP_RX(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 10, 1)
+#define SAP_PS_SET_EN_LP_RX(__h2c, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 10, 1, __value)
+#define SAP_PS_GET_MANUAL_32K(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 11, 1)
+#define SAP_PS_SET_MANUAL_32K(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 11, 1, __value)
+#define SAP_PS_GET_DURATION(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define SAP_PS_SET_DURATION(__h2c, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define INACTIVE_PS_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define INACTIVE_PS_SET_CMD_ID(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define INACTIVE_PS_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define INACTIVE_PS_SET_CLASS(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define INACTIVE_PS_GET_ENABLE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 1)
+#define INACTIVE_PS_SET_ENABLE(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 1, __value)
+#define INACTIVE_PS_GET_IGNORE_PS_CONDITION(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 9, 1)
+#define INACTIVE_PS_SET_IGNORE_PS_CONDITION(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 9, 1, __value)
+#define INACTIVE_PS_GET_FREQUENCY(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define INACTIVE_PS_SET_FREQUENCY(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define INACTIVE_PS_GET_DURATION(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define INACTIVE_PS_SET_DURATION(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define MACID_CFG_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define MACID_CFG_SET_CMD_ID(__h2c, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define MACID_CFG_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define MACID_CFG_SET_CLASS(__h2c, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define MACID_CFG_GET_MAC_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define MACID_CFG_SET_MAC_ID(__h2c, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define MACID_CFG_GET_RATE_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 5)
+#define MACID_CFG_SET_RATE_ID(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 5, __value)
+#define MACID_CFG_GET_SGI(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 23, 1)
+#define MACID_CFG_SET_SGI(__h2c, __value)                                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 23, 1, __value)
+#define MACID_CFG_GET_BW(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 2)
+#define MACID_CFG_SET_BW(__h2c, __value)                                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 2, __value)
+#define MACID_CFG_GET_LDPC_CAP(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 26, 1)
+#define MACID_CFG_SET_LDPC_CAP(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 26, 1, __value)
+#define MACID_CFG_GET_NO_UPDATE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 27, 1)
+#define MACID_CFG_SET_NO_UPDATE(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 27, 1, __value)
+#define MACID_CFG_GET_WHT_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 28, 2)
+#define MACID_CFG_SET_WHT_EN(__h2c, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 28, 2, __value)
+#define MACID_CFG_GET_DISPT(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 30, 1)
+#define MACID_CFG_SET_DISPT(__h2c, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 30, 1, __value)
+#define MACID_CFG_GET_DISRA(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 31, 1)
+#define MACID_CFG_SET_DISRA(__h2c, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 31, 1, __value)
+#define MACID_CFG_GET_RATE_MASK7_0(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 8)
+#define MACID_CFG_SET_RATE_MASK7_0(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 8, __value)
+#define MACID_CFG_GET_RATE_MASK15_8(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 8, 8)
+#define MACID_CFG_SET_RATE_MASK15_8(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 8, 8, __value)
+#define MACID_CFG_GET_RATE_MASK23_16(__h2c)                                    \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 16, 8)
+#define MACID_CFG_SET_RATE_MASK23_16(__h2c, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 16, 8, __value)
+#define MACID_CFG_GET_RATE_MASK31_24(__h2c)                                    \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 24, 8)
+#define MACID_CFG_SET_RATE_MASK31_24(__h2c, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 24, 8, __value)
+#define TXBF_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define TXBF_SET_CMD_ID(__h2c, __value)                                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define TXBF_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define TXBF_SET_CLASS(__h2c, __value)                                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define TXBF_GET_NDPA0_HEAD_PAGE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define TXBF_SET_NDPA0_HEAD_PAGE(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define TXBF_GET_NDPA1_HEAD_PAGE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define TXBF_SET_NDPA1_HEAD_PAGE(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define TXBF_GET_PERIOD_0(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define TXBF_SET_PERIOD_0(__h2c, __value)                                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define RSSI_SETTING_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define RSSI_SETTING_SET_CMD_ID(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define RSSI_SETTING_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define RSSI_SETTING_SET_CLASS(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define RSSI_SETTING_GET_MAC_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define RSSI_SETTING_SET_MAC_ID(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define RSSI_SETTING_GET_RSSI(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 7)
+#define RSSI_SETTING_SET_RSSI(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 7, __value)
+#define RSSI_SETTING_GET_RA_INFO(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 8)
+#define RSSI_SETTING_SET_RA_INFO(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 8, __value)
+#define AP_REQ_TXRPT_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define AP_REQ_TXRPT_SET_CMD_ID(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define AP_REQ_TXRPT_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define AP_REQ_TXRPT_SET_CLASS(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define AP_REQ_TXRPT_GET_STA1_MACID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define AP_REQ_TXRPT_SET_STA1_MACID(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define AP_REQ_TXRPT_GET_STA2_MACID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define AP_REQ_TXRPT_SET_STA2_MACID(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define AP_REQ_TXRPT_GET_RTY_OK_TOTAL(__h2c)                                   \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 1)
+#define AP_REQ_TXRPT_SET_RTY_OK_TOTAL(__h2c, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 1, __value)
+#define AP_REQ_TXRPT_GET_RTY_CNT_MACID(__h2c)                                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 25, 1)
+#define AP_REQ_TXRPT_SET_RTY_CNT_MACID(__h2c, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 25, 1, __value)
+#define INIT_RATE_COLLECTION_GET_CMD_ID(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define INIT_RATE_COLLECTION_SET_CMD_ID(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define INIT_RATE_COLLECTION_GET_CLASS(__h2c)                                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define INIT_RATE_COLLECTION_SET_CLASS(__h2c, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define INIT_RATE_COLLECTION_GET_STA1_MACID(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define INIT_RATE_COLLECTION_SET_STA1_MACID(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define INIT_RATE_COLLECTION_GET_STA2_MACID(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define INIT_RATE_COLLECTION_SET_STA2_MACID(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define INIT_RATE_COLLECTION_GET_STA3_MACID(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define INIT_RATE_COLLECTION_SET_STA3_MACID(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define INIT_RATE_COLLECTION_GET_STA4_MACID(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 8)
+#define INIT_RATE_COLLECTION_SET_STA4_MACID(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 8, __value)
+#define INIT_RATE_COLLECTION_GET_STA5_MACID(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 8, 8)
+#define INIT_RATE_COLLECTION_SET_STA5_MACID(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 8, 8, __value)
+#define INIT_RATE_COLLECTION_GET_STA6_MACID(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 16, 8)
+#define INIT_RATE_COLLECTION_SET_STA6_MACID(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 16, 8, __value)
+#define INIT_RATE_COLLECTION_GET_STA7_MACID(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 24, 8)
+#define INIT_RATE_COLLECTION_SET_STA7_MACID(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 24, 8, __value)
+#define IQK_OFFLOAD_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define IQK_OFFLOAD_SET_CMD_ID(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define IQK_OFFLOAD_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define IQK_OFFLOAD_SET_CLASS(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define IQK_OFFLOAD_GET_CHANNEL(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define IQK_OFFLOAD_SET_CHANNEL(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define IQK_OFFLOAD_GET_BWBAND(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define IQK_OFFLOAD_SET_BWBAND(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define IQK_OFFLOAD_GET_EXTPALNA(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define IQK_OFFLOAD_SET_EXTPALNA(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define MACID_CFG_3SS_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define MACID_CFG_3SS_SET_CMD_ID(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define MACID_CFG_3SS_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define MACID_CFG_3SS_SET_CLASS(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define MACID_CFG_3SS_GET_MACID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define MACID_CFG_3SS_SET_MACID(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define MACID_CFG_3SS_GET_RATE_MASK_39_32(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 8)
+#define MACID_CFG_3SS_SET_RATE_MASK_39_32(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 8, __value)
+#define MACID_CFG_3SS_GET_RATE_MASK_47_40(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 8, 8)
+#define MACID_CFG_3SS_SET_RATE_MASK_47_40(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 8, 8, __value)
+#define RA_PARA_ADJUST_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define RA_PARA_ADJUST_SET_CMD_ID(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define RA_PARA_ADJUST_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define RA_PARA_ADJUST_SET_CLASS(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define RA_PARA_ADJUST_GET_MAC_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define RA_PARA_ADJUST_SET_MAC_ID(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define RA_PARA_ADJUST_GET_PARAMETER_INDEX(__h2c)                              \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define RA_PARA_ADJUST_SET_PARAMETER_INDEX(__h2c, __value)                     \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define RA_PARA_ADJUST_GET_RATE_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define RA_PARA_ADJUST_SET_RATE_ID(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define RA_PARA_ADJUST_GET_VALUE_BYTE0(__h2c)                                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 8)
+#define RA_PARA_ADJUST_SET_VALUE_BYTE0(__h2c, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 8, __value)
+#define RA_PARA_ADJUST_GET_VALUE_BYTE1(__h2c)                                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 8, 8)
+#define RA_PARA_ADJUST_SET_VALUE_BYTE1(__h2c, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 8, 8, __value)
+#define RA_PARA_ADJUST_GET_ASK_FW_FOR_FW_PARA(__h2c)                           \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 16, 8)
+#define RA_PARA_ADJUST_SET_ASK_FW_FOR_FW_PARA(__h2c, __value)                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 16, 8, __value)
+#define WWLAN_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define WWLAN_SET_CMD_ID(__h2c, __value)                                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define WWLAN_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define WWLAN_SET_CLASS(__h2c, __value)                                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define WWLAN_GET_FUNC_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 1)
+#define WWLAN_SET_FUNC_EN(__h2c, __value)                                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 1, __value)
+#define WWLAN_GET_PATTERM_MAT_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 9, 1)
+#define WWLAN_SET_PATTERM_MAT_EN(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 9, 1, __value)
+#define WWLAN_GET_MAGIC_PKT_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 10, 1)
+#define WWLAN_SET_MAGIC_PKT_EN(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 10, 1, __value)
+#define WWLAN_GET_UNICAST_WAKEUP_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 11, 1)
+#define WWLAN_SET_UNICAST_WAKEUP_EN(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 11, 1, __value)
+#define WWLAN_GET_ALL_PKT_DROP(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 12, 1)
+#define WWLAN_SET_ALL_PKT_DROP(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 12, 1, __value)
+#define WWLAN_GET_GPIO_ACTIVE(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 13, 1)
+#define WWLAN_SET_GPIO_ACTIVE(__h2c, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 13, 1, __value)
+#define WWLAN_GET_REKEY_WAKEUP_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 14, 1)
+#define WWLAN_SET_REKEY_WAKEUP_EN(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 14, 1, __value)
+#define WWLAN_GET_DEAUTH_WAKEUP_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 15, 1)
+#define WWLAN_SET_DEAUTH_WAKEUP_EN(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 15, 1, __value)
+#define WWLAN_GET_GPIO_NUM(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 7)
+#define WWLAN_SET_GPIO_NUM(__h2c, __value)                                     \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 7, __value)
+#define WWLAN_GET_DATAPIN_WAKEUP_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 23, 1)
+#define WWLAN_SET_DATAPIN_WAKEUP_EN(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 23, 1, __value)
+#define WWLAN_GET_GPIO_DURATION(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define WWLAN_SET_GPIO_DURATION(__h2c, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define WWLAN_GET_GPIO_PLUS_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 1)
+#define WWLAN_SET_GPIO_PLUS_EN(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 1, __value)
+#define WWLAN_GET_GPIO_PULSE_COUNT(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 1, 7)
+#define WWLAN_SET_GPIO_PULSE_COUNT(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 1, 7, __value)
+#define WWLAN_GET_DISABLE_UPHY(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 8, 1)
+#define WWLAN_SET_DISABLE_UPHY(__h2c, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 8, 1, __value)
+#define WWLAN_GET_HST2DEV_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 9, 1)
+#define WWLAN_SET_HST2DEV_EN(__h2c, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 9, 1, __value)
+#define WWLAN_GET_GPIO_DURATION_MS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X04, 10, 1)
+#define WWLAN_SET_GPIO_DURATION_MS(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 10, 1, __value)
+#define REMOTE_WAKE_CTRL_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define REMOTE_WAKE_CTRL_SET_CMD_ID(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define REMOTE_WAKE_CTRL_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define REMOTE_WAKE_CTRL_SET_CLASS(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define REMOTE_WAKE_CTRL_GET_REMOTE_WAKE_CTRL_EN(__h2c)                        \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 1)
+#define REMOTE_WAKE_CTRL_SET_REMOTE_WAKE_CTRL_EN(__h2c, __value)               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 1, __value)
+#define REMOTE_WAKE_CTRL_GET_ARP_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 9, 1)
+#define REMOTE_WAKE_CTRL_SET_ARP_EN(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 9, 1, __value)
+#define REMOTE_WAKE_CTRL_GET_NDP_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 10, 1)
+#define REMOTE_WAKE_CTRL_SET_NDP_EN(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 10, 1, __value)
+#define REMOTE_WAKE_CTRL_GET_GTK_EN(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 11, 1)
+#define REMOTE_WAKE_CTRL_SET_GTK_EN(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 11, 1, __value)
+#define REMOTE_WAKE_CTRL_GET_NLO_OFFLOAD_EN(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 12, 1)
+#define REMOTE_WAKE_CTRL_SET_NLO_OFFLOAD_EN(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 12, 1, __value)
+#define REMOTE_WAKE_CTRL_GET_REAL_WOW_V1_EN(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 13, 1)
+#define REMOTE_WAKE_CTRL_SET_REAL_WOW_V1_EN(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 13, 1, __value)
+#define REMOTE_WAKE_CTRL_GET_REAL_WOW_V2_EN(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 14, 1)
+#define REMOTE_WAKE_CTRL_SET_REAL_WOW_V2_EN(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 14, 1, __value)
+#define REMOTE_WAKE_CTRL_GET_FW_UNICAST(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 15, 1)
+#define REMOTE_WAKE_CTRL_SET_FW_UNICAST(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 15, 1, __value)
+#define REMOTE_WAKE_CTRL_GET_P2P_OFFLOAD_EN(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 1)
+#define REMOTE_WAKE_CTRL_SET_P2P_OFFLOAD_EN(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 1, __value)
+#define REMOTE_WAKE_CTRL_GET_RUNTIME_PM_EN(__h2c)                              \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 17, 1)
+#define REMOTE_WAKE_CTRL_SET_RUNTIME_PM_EN(__h2c, __value)                     \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 17, 1, __value)
+#define REMOTE_WAKE_CTRL_GET_NET_BIOS_DROP_EN(__h2c)                           \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 18, 1)
+#define REMOTE_WAKE_CTRL_SET_NET_BIOS_DROP_EN(__h2c, __value)                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 18, 1, __value)
+#define REMOTE_WAKE_CTRL_GET_ARP_ACTION(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 1)
+#define REMOTE_WAKE_CTRL_SET_ARP_ACTION(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 1, __value)
+#define REMOTE_WAKE_CTRL_GET_FW_PARSING_UNTIL_WAKEUP(__h2c)                    \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 28, 1)
+#define REMOTE_WAKE_CTRL_SET_FW_PARSING_UNTIL_WAKEUP(__h2c, __value)           \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 28, 1, __value)
+#define REMOTE_WAKE_CTRL_GET_FW_PARSING_AFTER_WAKEUP(__h2c)                    \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 29, 1)
+#define REMOTE_WAKE_CTRL_SET_FW_PARSING_AFTER_WAKEUP(__h2c, __value)           \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 29, 1, __value)
+#define AOAC_GLOBAL_INFO_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define AOAC_GLOBAL_INFO_SET_CMD_ID(__h2c, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define AOAC_GLOBAL_INFO_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define AOAC_GLOBAL_INFO_SET_CLASS(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define AOAC_GLOBAL_INFO_GET_PAIR_WISE_ENC_ALG(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define AOAC_GLOBAL_INFO_SET_PAIR_WISE_ENC_ALG(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define AOAC_GLOBAL_INFO_GET_GROUP_ENC_ALG(__h2c)                              \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define AOAC_GLOBAL_INFO_SET_GROUP_ENC_ALG(__h2c, __value)                     \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define AOAC_RSVD_PAGE_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define AOAC_RSVD_PAGE_SET_CMD_ID(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define AOAC_RSVD_PAGE_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define AOAC_RSVD_PAGE_SET_CLASS(__h2c, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define AOAC_RSVD_PAGE_GET_LOC_REMOTE_CTRL_INFO(__h2c)                         \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define AOAC_RSVD_PAGE_SET_LOC_REMOTE_CTRL_INFO(__h2c, __value)                \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define AOAC_RSVD_PAGE_GET_LOC_ARP_RESPONSE(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define AOAC_RSVD_PAGE_SET_LOC_ARP_RESPONSE(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define AOAC_RSVD_PAGE_GET_LOC_NEIGHBOR_ADVERTISEMENT(__h2c)                   \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define AOAC_RSVD_PAGE_SET_LOC_NEIGHBOR_ADVERTISEMENT(__h2c, __value)          \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define AOAC_RSVD_PAGE_GET_LOC_GTK_RSP(__h2c)                                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 8)
+#define AOAC_RSVD_PAGE_SET_LOC_GTK_RSP(__h2c, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 8, __value)
+#define AOAC_RSVD_PAGE_GET_LOC_GTK_INFO(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 8, 8)
+#define AOAC_RSVD_PAGE_SET_LOC_GTK_INFO(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 8, 8, __value)
+#define AOAC_RSVD_PAGE_GET_LOC_GTK_EXT_MEM(__h2c)                              \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 16, 8)
+#define AOAC_RSVD_PAGE_SET_LOC_GTK_EXT_MEM(__h2c, __value)                     \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 16, 8, __value)
+#define AOAC_RSVD_PAGE_GET_LOC_NDP_INFO(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 24, 8)
+#define AOAC_RSVD_PAGE_SET_LOC_NDP_INFO(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 24, 8, __value)
+#define AOAC_RSVD_PAGE2_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define AOAC_RSVD_PAGE2_SET_CMD_ID(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define AOAC_RSVD_PAGE2_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define AOAC_RSVD_PAGE2_SET_CLASS(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define AOAC_RSVD_PAGE2_GET_LOC_ROUTER_SOLICATION(__h2c)                       \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define AOAC_RSVD_PAGE2_SET_LOC_ROUTER_SOLICATION(__h2c, __value)              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define AOAC_RSVD_PAGE2_GET_LOC_BUBBLE_PACKET(__h2c)                           \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define AOAC_RSVD_PAGE2_SET_LOC_BUBBLE_PACKET(__h2c, __value)                  \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define AOAC_RSVD_PAGE2_GET_LOC_TEREDO_INFO(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define AOAC_RSVD_PAGE2_SET_LOC_TEREDO_INFO(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define AOAC_RSVD_PAGE2_GET_LOC_REALWOW_INFO(__h2c)                            \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 0, 8)
+#define AOAC_RSVD_PAGE2_SET_LOC_REALWOW_INFO(__h2c, __value)                   \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 0, 8, __value)
+#define AOAC_RSVD_PAGE2_GET_LOC_KEEP_ALIVE_PKT(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 8, 8)
+#define AOAC_RSVD_PAGE2_SET_LOC_KEEP_ALIVE_PKT(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 8, 8, __value)
+#define AOAC_RSVD_PAGE2_GET_LOC_ACK_PATTERN(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 16, 8)
+#define AOAC_RSVD_PAGE2_SET_LOC_ACK_PATTERN(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 16, 8, __value)
+#define AOAC_RSVD_PAGE2_GET_LOC_WAKEUP_PATTERN(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X04, 24, 8)
+#define AOAC_RSVD_PAGE2_SET_LOC_WAKEUP_PATTERN(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X04, 24, 8, __value)
+#define D0_SCAN_OFFLOAD_INFO_GET_CMD_ID(__h2c)                                 \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define D0_SCAN_OFFLOAD_INFO_SET_CMD_ID(__h2c, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define D0_SCAN_OFFLOAD_INFO_GET_CLASS(__h2c)                                  \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define D0_SCAN_OFFLOAD_INFO_SET_CLASS(__h2c, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define D0_SCAN_OFFLOAD_INFO_GET_LOC_CHANNEL_INFO(__h2c)                       \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define D0_SCAN_OFFLOAD_INFO_SET_LOC_CHANNEL_INFO(__h2c, __value)              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define CHANNEL_SWITCH_OFFLOAD_GET_CMD_ID(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define CHANNEL_SWITCH_OFFLOAD_SET_CMD_ID(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define CHANNEL_SWITCH_OFFLOAD_GET_CLASS(__h2c)                                \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define CHANNEL_SWITCH_OFFLOAD_SET_CLASS(__h2c, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define CHANNEL_SWITCH_OFFLOAD_GET_CHANNEL_NUM(__h2c)                          \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define CHANNEL_SWITCH_OFFLOAD_SET_CHANNEL_NUM(__h2c, __value)                 \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define CHANNEL_SWITCH_OFFLOAD_GET_EN_RFE(__h2c)                               \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define CHANNEL_SWITCH_OFFLOAD_SET_EN_RFE(__h2c, __value)                      \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#define CHANNEL_SWITCH_OFFLOAD_GET_RFE_TYPE(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 24, 8)
+#define CHANNEL_SWITCH_OFFLOAD_SET_RFE_TYPE(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 24, 8, __value)
+#define AOAC_RSVD_PAGE3_GET_CMD_ID(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 0, 5)
+#define AOAC_RSVD_PAGE3_SET_CMD_ID(__h2c, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 0, 5, __value)
+#define AOAC_RSVD_PAGE3_GET_CLASS(__h2c) LE_BITS_TO_4BYTE(__h2c + 0X00, 5, 3)
+#define AOAC_RSVD_PAGE3_SET_CLASS(__h2c, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 5, 3, __value)
+#define AOAC_RSVD_PAGE3_GET_LOC_NLO_INFO(__h2c)                                \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 8, 8)
+#define AOAC_RSVD_PAGE3_SET_LOC_NLO_INFO(__h2c, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 8, 8, __value)
+#define AOAC_RSVD_PAGE3_GET_LOC_AOAC_REPORT(__h2c)                             \
+	LE_BITS_TO_4BYTE(__h2c + 0X00, 16, 8)
+#define AOAC_RSVD_PAGE3_SET_LOC_AOAC_REPORT(__h2c, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__h2c + 0X00, 16, 8, __value)
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_pcie_reg.h b/drivers/staging/rtlwifi/halmac/halmac_pcie_reg.h
new file mode 100644
index 000000000000..41780676508e
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_pcie_reg.h
@@ -0,0 +1,28 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __HALMAC_PCIE_REG_H__
+#define __HALMAC_PCIE_REG_H__
+
+#endif /* __HALMAC_PCIE_REG_H__ */
diff --git a/drivers/staging/rtlwifi/halmac/halmac_pwr_seq_cmd.h b/drivers/staging/rtlwifi/halmac/halmac_pwr_seq_cmd.h
new file mode 100644
index 000000000000..13a65a4754b0
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_pwr_seq_cmd.h
@@ -0,0 +1,116 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef HALMAC_POWER_SEQUENCE_CMD
+#define HALMAC_POWER_SEQUENCE_CMD
+
+#include "halmac_2_platform.h"
+#include "halmac_type.h"
+
+#define HALMAC_POLLING_READY_TIMEOUT_COUNT 20000
+
+/* The value of cmd : 4 bits */
+
+/* offset : the read register offset
+ * msk : the mask of the read value
+ * value : N/A, left by 0
+ * Note : dirver shall implement this function by read & msk
+ */
+#define HALMAC_PWR_CMD_READ 0x00
+/*
+ * offset: the read register offset
+ * msk: the mask of the write bits
+ * value: write value
+ * Note: driver shall implement this cmd by read & msk after write
+ */
+#define HALMAC_PWR_CMD_WRITE 0x01
+/* offset: the read register offset
+ * msk: the mask of the polled value
+ * value: the value to be polled, masked by the msd field.
+ * Note: driver shall implement this cmd by
+ * do{
+ * if( (Read(offset) & msk) == (value & msk) )
+ * break;
+ * } while(not timeout);
+ */
+#define HALMAC_PWR_CMD_POLLING 0x02
+/* offset: the value to delay
+ * msk: N/A
+ * value: the unit of delay, 0: us, 1: ms
+ */
+#define HALMAC_PWR_CMD_DELAY 0x03
+/* offset: N/A
+ * msk: N/A
+ * value: N/A
+ */
+#define HALMAC_PWR_CMD_END 0x04
+
+/* The value of base : 4 bits */
+
+/* define the base address of each block */
+#define HALMAC_PWR_BASEADDR_MAC 0x00
+#define HALMAC_PWR_BASEADDR_USB 0x01
+#define HALMAC_PWR_BASEADDR_PCIE 0x02
+#define HALMAC_PWR_BASEADDR_SDIO 0x03
+
+/* The value of interface_msk : 4 bits */
+#define HALMAC_PWR_INTF_SDIO_MSK BIT(0)
+#define HALMAC_PWR_INTF_USB_MSK BIT(1)
+#define HALMAC_PWR_INTF_PCI_MSK BIT(2)
+#define HALMAC_PWR_INTF_ALL_MSK (BIT(0) | BIT(1) | BIT(2) | BIT(3))
+
+/* The value of fab_msk : 4 bits */
+#define HALMAC_PWR_FAB_TSMC_MSK BIT(0)
+#define HALMAC_PWR_FAB_UMC_MSK BIT(1)
+#define HALMAC_PWR_FAB_ALL_MSK (BIT(0) | BIT(1) | BIT(2) | BIT(3))
+
+/* The value of cut_msk : 8 bits */
+#define HALMAC_PWR_CUT_TESTCHIP_MSK BIT(0)
+#define HALMAC_PWR_CUT_A_MSK BIT(1)
+#define HALMAC_PWR_CUT_B_MSK BIT(2)
+#define HALMAC_PWR_CUT_C_MSK BIT(3)
+#define HALMAC_PWR_CUT_D_MSK BIT(4)
+#define HALMAC_PWR_CUT_E_MSK BIT(5)
+#define HALMAC_PWR_CUT_F_MSK BIT(6)
+#define HALMAC_PWR_CUT_G_MSK BIT(7)
+#define HALMAC_PWR_CUT_ALL_MSK 0xFF
+
+enum halmac_pwrseq_cmd_delay_unit_ {
+	HALMAC_PWRSEQ_DELAY_US,
+	HALMAC_PWRSEQ_DELAY_MS,
+};
+
+/*Don't care endian issue, because element of pwer seq vector is fixed address*/
+struct halmac_wl_pwr_cfg_ {
+	u16 offset;
+	u8 cut_msk;
+	u8 fab_msk : 4;
+	u8 interface_msk : 4;
+	u8 base : 4;
+	u8 cmd : 4;
+	u8 msk;
+	u8 value;
+};
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_reg2.h b/drivers/staging/rtlwifi/halmac/halmac_reg2.h
new file mode 100644
index 000000000000..bebf974ed949
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_reg2.h
@@ -0,0 +1,1132 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __HALMAC_COM_REG_H__
+#define __HALMAC_COM_REG_H__
+/*-------------------------Modification Log-----------------------------------
+ *	For Page0, it is based on Combo_And_WL_Only_Page0_Reg.xls SVN524
+ *	The supported IC are 8723A, 8881A, 8723B, 8192E, 8881A
+ *	8812A and 8188E is not included in page0 register
+ *
+ *	For other pages, it is based on MAC_Register.doc SVN502
+ *	Most IC is the same with 8812A
+ *-------------------------Modification Log-----------------------------------
+ */
+
+/*--------------------------Include File--------------------------------------*/
+/*--------------------------Include File--------------------------------------*/
+
+#define REG_SYS_ISO_CTRL				0x0000
+
+#define REG_SDIO_TX_CTRL				0x10250000
+
+#define REG_SYS_FUNC_EN				0x0002
+#define REG_SYS_PW_CTRL				0x0004
+#define REG_SYS_CLK_CTRL				0x0008
+#define REG_SYS_EEPROM_CTRL				0x000A
+#define REG_EE_VPD					0x000C
+#define REG_SYS_SWR_CTRL1				0x0010
+#define REG_SYS_SWR_CTRL2				0x0014
+
+#define REG_SDIO_HIMR					0x10250014
+
+#define REG_SYS_SWR_CTRL3				0x0018
+
+#define REG_SDIO_HISR					0x10250018
+
+#define REG_RSV_CTRL					0x001C
+
+#define REG_SDIO_RX_REQ_LEN				0x1025001C
+
+#define REG_RF_CTRL					0x001F
+
+#define REG_SDIO_FREE_TXPG_SEQ_V1			0x1025001F
+
+#define REG_AFE_LDO_CTRL				0x0020
+
+#define REG_SDIO_FREE_TXPG				0x10250020
+
+#define REG_AFE_CTRL1					0x0024
+
+#define REG_SDIO_FREE_TXPG2				0x10250024
+
+#define REG_AFE_CTRL2					0x0028
+
+#define REG_SDIO_OQT_FREE_TXPG_V1			0x10250028
+
+#define REG_AFE_CTRL3					0x002C
+#define REG_EFUSE_CTRL					0x0030
+
+#define REG_SDIO_HTSFR_INFO				0x10250030
+
+#define REG_LDO_EFUSE_CTRL				0x0034
+#define REG_PWR_OPTION_CTRL				0x0038
+
+#define REG_SDIO_HCPWM1_V2				0x10250038
+#define REG_SDIO_HCPWM2_V2				0x1025003A
+
+#define REG_CAL_TIMER					0x003C
+#define REG_ACLK_MON					0x003E
+#define REG_GPIO_MUXCFG				0x0040
+
+#define REG_SDIO_INDIRECT_REG_CFG			0x10250040
+
+#define REG_GPIO_PIN_CTRL				0x0044
+
+#define REG_SDIO_INDIRECT_REG_DATA			0x10250044
+
+#define REG_GPIO_INTM					0x0048
+#define REG_LED_CFG					0x004C
+#define REG_FSIMR					0x0050
+#define REG_FSISR					0x0054
+#define REG_HSIMR					0x0058
+#define REG_HSISR					0x005C
+#define REG_GPIO_EXT_CTRL				0x0060
+
+#define REG_SDIO_H2C					0x10250060
+
+#define REG_PAD_CTRL1					0x0064
+
+#define REG_SDIO_C2H					0x10250064
+
+#define REG_WL_BT_PWR_CTRL				0x0068
+
+#define REG_SDM_DEBUG					0x006C
+
+#define REG_SYS_SDIO_CTRL				0x0070
+
+#define REG_HCI_OPT_CTRL				0x0074
+
+#define REG_AFE_CTRL4					0x0078
+
+#define REG_LDO_SWR_CTRL				0x007C
+
+#define REG_MCUFW_CTRL					0x0080
+
+#define REG_SDIO_HRPWM1				0x10250080
+#define REG_SDIO_HRPWM2				0x10250082
+
+#define REG_MCU_TST_CFG				0x0084
+
+#define REG_SDIO_HPS_CLKR				0x10250084
+#define REG_SDIO_BUS_CTRL				0x10250085
+
+#define REG_SDIO_HSUS_CTRL				0x10250086
+
+#define REG_HMEBOX_E0_E1				0x0088
+
+#define REG_SDIO_RESPONSE_TIMER			0x10250088
+
+#define REG_SDIO_CMD_CRC				0x1025008A
+
+#define REG_HMEBOX_E2_E3				0x008C
+#define REG_WLLPS_CTRL					0x0090
+
+#define REG_SDIO_HSISR					0x10250090
+#define REG_SDIO_HSIMR					0x10250091
+
+#define REG_AFE_CTRL5					0x0094
+
+#define REG_GPIO_DEBOUNCE_CTRL				0x0098
+#define REG_RPWM2					0x009C
+#define REG_SYSON_FSM_MON				0x00A0
+
+#define REG_AFE_CTRL6					0x00A4
+
+#define REG_PMC_DBG_CTRL1				0x00A8
+
+#define REG_AFE_CTRL7					0x00AC
+
+#define REG_HIMR0					0x00B0
+#define REG_HISR0					0x00B4
+#define REG_HIMR1					0x00B8
+#define REG_HISR1					0x00BC
+#define REG_DBG_PORT_SEL				0x00C0
+
+#define REG_SDIO_ERR_RPT				0x102500C0
+#define REG_SDIO_CMD_ERRCNT				0x102500C1
+#define REG_SDIO_DATA_ERRCNT				0x102500C2
+
+#define REG_PAD_CTRL2					0x00C4
+
+#define REG_SDIO_CMD_ERR_CONTENT			0x102500C4
+
+#define REG_SDIO_CRC_ERR_IDX				0x102500C9
+#define REG_SDIO_DATA_CRC				0x102500CA
+#define REG_SDIO_DATA_REPLY_TIME			0x102500CB
+
+#define REG_PMC_DBG_CTRL2				0x00CC
+#define REG_BIST_CTRL					0x00D0
+#define REG_BIST_RPT					0x00D4
+#define REG_MEM_CTRL					0x00D8
+
+#define REG_AFE_CTRL8					0x00DC
+
+#define REG_USB_SIE_INTF				0x00E0
+#define REG_PCIE_MIO_INTF				0x00E4
+#define REG_PCIE_MIO_INTD				0x00E8
+
+#define REG_WLRF1					0x00EC
+
+#define REG_SYS_CFG1					0x00F0
+#define REG_SYS_STATUS1				0x00F4
+#define REG_SYS_STATUS2				0x00F8
+#define REG_SYS_CFG2					0x00FC
+#define REG_CR						0x0100
+
+#define REG_PKT_BUFF_ACCESS_CTRL			0x0106
+
+#define REG_TSF_CLK_STATE				0x0108
+#define REG_TXDMA_PQ_MAP				0x010C
+#define REG_TRXFF_BNDY					0x0114
+
+#define REG_PTA_I2C_MBOX				0x0118
+
+#define REG_RXFF_BNDY					0x011C
+
+#define REG_FE1IMR					0x0120
+
+#define REG_FE1ISR					0x0124
+
+#define REG_CPWM					0x012C
+#define REG_FWIMR					0x0130
+#define REG_FWISR					0x0134
+#define REG_FTIMR					0x0138
+#define REG_FTISR					0x013C
+#define REG_PKTBUF_DBG_CTRL				0x0140
+#define REG_PKTBUF_DBG_DATA_L				0x0144
+#define REG_PKTBUF_DBG_DATA_H				0x0148
+#define REG_CPWM2					0x014C
+#define REG_TC0_CTRL					0x0150
+#define REG_TC1_CTRL					0x0154
+#define REG_TC2_CTRL					0x0158
+#define REG_TC3_CTRL					0x015C
+#define REG_TC4_CTRL					0x0160
+#define REG_TCUNIT_BASE				0x0164
+#define REG_TC5_CTRL					0x0168
+#define REG_TC6_CTRL					0x016C
+#define REG_MBIST_FAIL					0x0170
+#define REG_MBIST_START_PAUSE				0x0174
+#define REG_MBIST_DONE					0x0178
+
+#define REG_MBIST_FAIL_NRML				0x017C
+
+#define REG_AES_DECRPT_DATA				0x0180
+#define REG_AES_DECRPT_CFG				0x0184
+
+#define REG_TMETER					0x0190
+#define REG_OSC_32K_CTRL				0x0194
+#define REG_32K_CAL_REG1				0x0198
+#define REG_C2HEVT					0x01A0
+
+#define REG_C2HEVT_1					0x01A4
+#define REG_C2HEVT_2					0x01A8
+#define REG_C2HEVT_3					0x01AC
+
+#define REG_SW_DEFINED_PAGE1				0x01B8
+
+#define REG_MCUTST_I					0x01C0
+#define REG_MCUTST_II					0x01C4
+#define REG_FMETHR					0x01C8
+#define REG_HMETFR					0x01CC
+#define REG_HMEBOX0					0x01D0
+#define REG_HMEBOX1					0x01D4
+#define REG_HMEBOX2					0x01D8
+#define REG_HMEBOX3					0x01DC
+#define REG_LLT_INIT					0x01E0
+
+#define REG_LLT_INIT_ADDR				0x01E4
+
+#define REG_BB_ACCESS_CTRL				0x01E8
+#define REG_BB_ACCESS_DATA				0x01EC
+#define REG_HMEBOX_E0					0x01F0
+#define REG_HMEBOX_E1					0x01F4
+#define REG_HMEBOX_E2					0x01F8
+#define REG_HMEBOX_E3					0x01FC
+
+#define REG_FIFOPAGE_CTRL_1				0x0200
+
+#define REG_FIFOPAGE_CTRL_2				0x0204
+
+#define REG_AUTO_LLT_V1				0x0208
+
+#define REG_TXDMA_OFFSET_CHK				0x020C
+#define REG_TXDMA_STATUS				0x0210
+
+#define REG_TX_DMA_DBG					0x0214
+
+#define REG_TQPNT1					0x0218
+#define REG_TQPNT2					0x021C
+
+#define REG_TQPNT3					0x0220
+
+#define REG_TQPNT4					0x0224
+
+#define REG_RQPN_CTRL_1				0x0228
+#define REG_RQPN_CTRL_2				0x022C
+#define REG_FIFOPAGE_INFO_1				0x0230
+#define REG_FIFOPAGE_INFO_2				0x0234
+#define REG_FIFOPAGE_INFO_3				0x0238
+#define REG_FIFOPAGE_INFO_4				0x023C
+#define REG_FIFOPAGE_INFO_5				0x0240
+
+#define REG_H2C_HEAD					0x0244
+#define REG_H2C_TAIL					0x0248
+#define REG_H2C_READ_ADDR				0x024C
+#define REG_H2C_WR_ADDR				0x0250
+#define REG_H2C_INFO					0x0254
+
+#define REG_RXDMA_AGG_PG_TH				0x0280
+#define REG_RXPKT_NUM					0x0284
+#define REG_RXDMA_STATUS				0x0288
+#define REG_RXDMA_DPR					0x028C
+#define REG_RXDMA_MODE					0x0290
+#define REG_C2H_PKT					0x0294
+
+#define REG_FWFF_C2H					0x0298
+#define REG_FWFF_CTRL					0x029C
+#define REG_FWFF_PKT_INFO				0x02A0
+
+#define REG_PCIE_CTRL					0x0300
+
+#define REG_INT_MIG					0x0304
+#define REG_BCNQ_TXBD_DESA				0x0308
+#define REG_MGQ_TXBD_DESA				0x0310
+#define REG_VOQ_TXBD_DESA				0x0318
+#define REG_VIQ_TXBD_DESA				0x0320
+#define REG_BEQ_TXBD_DESA				0x0328
+#define REG_BKQ_TXBD_DESA				0x0330
+#define REG_RXQ_RXBD_DESA				0x0338
+#define REG_HI0Q_TXBD_DESA				0x0340
+#define REG_HI1Q_TXBD_DESA				0x0348
+#define REG_HI2Q_TXBD_DESA				0x0350
+#define REG_HI3Q_TXBD_DESA				0x0358
+#define REG_HI4Q_TXBD_DESA				0x0360
+#define REG_HI5Q_TXBD_DESA				0x0368
+#define REG_HI6Q_TXBD_DESA				0x0370
+#define REG_HI7Q_TXBD_DESA				0x0378
+#define REG_MGQ_TXBD_NUM				0x0380
+#define REG_RX_RXBD_NUM				0x0382
+#define REG_VOQ_TXBD_NUM				0x0384
+#define REG_VIQ_TXBD_NUM				0x0386
+#define REG_BEQ_TXBD_NUM				0x0388
+#define REG_BKQ_TXBD_NUM				0x038A
+#define REG_HI0Q_TXBD_NUM				0x038C
+#define REG_HI1Q_TXBD_NUM				0x038E
+#define REG_HI2Q_TXBD_NUM				0x0390
+#define REG_HI3Q_TXBD_NUM				0x0392
+#define REG_HI4Q_TXBD_NUM				0x0394
+#define REG_HI5Q_TXBD_NUM				0x0396
+#define REG_HI6Q_TXBD_NUM				0x0398
+#define REG_HI7Q_TXBD_NUM				0x039A
+#define REG_TSFTIMER_HCI				0x039C
+#define REG_BD_RWPTR_CLR				0x039C
+#define REG_VOQ_TXBD_IDX				0x03A0
+#define REG_VIQ_TXBD_IDX				0x03A4
+#define REG_BEQ_TXBD_IDX				0x03A8
+#define REG_BKQ_TXBD_IDX				0x03AC
+#define REG_MGQ_TXBD_IDX				0x03B0
+#define REG_RXQ_RXBD_IDX				0x03B4
+#define REG_HI0Q_TXBD_IDX				0x03B8
+#define REG_HI1Q_TXBD_IDX				0x03BC
+#define REG_HI2Q_TXBD_IDX				0x03C0
+#define REG_HI3Q_TXBD_IDX				0x03C4
+#define REG_HI4Q_TXBD_IDX				0x03C8
+#define REG_HI5Q_TXBD_IDX				0x03CC
+#define REG_HI6Q_TXBD_IDX				0x03D0
+#define REG_HI7Q_TXBD_IDX				0x03D4
+
+#define REG_DBG_SEL_V1					0x03D8
+
+#define REG_PCIE_HRPWM1_V1				0x03D9
+
+#define REG_PCIE_HCPWM1_V1				0x03DA
+
+#define REG_PCIE_CTRL2					0x03DB
+
+#define REG_PCIE_HRPWM2_V1				0x03DC
+
+#define REG_PCIE_HCPWM2_V1				0x03DE
+
+#define REG_PCIE_H2C_MSG_V1				0x03E0
+
+#define REG_PCIE_C2H_MSG_V1				0x03E4
+
+#define REG_DBI_WDATA_V1				0x03E8
+
+#define REG_DBI_RDATA_V1				0x03EC
+
+#define REG_DBI_FLAG_V1				0x03F0
+
+#define REG_MDIO_V1					0x03F4
+
+#define REG_PCIE_MIX_CFG				0x03F8
+
+#define REG_HCI_MIX_CFG				0x03FC
+
+#define REG_Q0_INFO					0x0400
+#define REG_Q1_INFO					0x0404
+#define REG_Q2_INFO					0x0408
+#define REG_Q3_INFO					0x040C
+#define REG_MGQ_INFO					0x0410
+#define REG_HIQ_INFO					0x0414
+#define REG_BCNQ_INFO					0x0418
+#define REG_TXPKT_EMPTY				0x041A
+#define REG_CPU_MGQ_INFO				0x041C
+#define REG_FWHW_TXQ_CTRL				0x0420
+
+#define REG_DATAFB_SEL					0x0423
+
+#define REG_BCNQ_BDNY_V1				0x0424
+
+#define REG_LIFETIME_EN				0x0426
+
+#define REG_SPEC_SIFS					0x0428
+#define REG_RETRY_LIMIT				0x042A
+#define REG_TXBF_CTRL					0x042C
+#define REG_DARFRC					0x0430
+#define REG_RARFRC					0x0438
+#define REG_RRSR					0x0440
+#define REG_ARFR0					0x0444
+#define REG_ARFR1_V1					0x044C
+#define REG_CCK_CHECK					0x0454
+
+#define REG_AMPDU_MAX_TIME_V1				0x0455
+
+#define REG_BCNQ1_BDNY_V1				0x0456
+
+#define REG_AMPDU_MAX_LENGTH				0x0458
+#define REG_ACQ_STOP					0x045C
+
+#define REG_NDPA_RATE					0x045D
+
+#define REG_TX_HANG_CTRL				0x045E
+#define REG_NDPA_OPT_CTRL				0x045F
+
+#define REG_RD_RESP_PKT_TH				0x0463
+#define REG_CMDQ_INFO					0x0464
+#define REG_Q4_INFO					0x0468
+#define REG_Q5_INFO					0x046C
+#define REG_Q6_INFO					0x0470
+#define REG_Q7_INFO					0x0474
+
+#define REG_WMAC_LBK_BUF_HD_V1				0x0478
+#define REG_MGQ_BDNY_V1				0x047A
+
+#define REG_TXRPT_CTRL					0x047C
+#define REG_INIRTS_RATE_SEL				0x0480
+#define REG_BASIC_CFEND_RATE				0x0481
+#define REG_STBC_CFEND_RATE				0x0482
+#define REG_DATA_SC					0x0483
+#define REG_MACID_SLEEP3				0x0484
+#define REG_MACID_SLEEP1				0x0488
+#define REG_ARFR2_V1					0x048C
+#define REG_ARFR3_V1					0x0494
+#define REG_ARFR4					0x049C
+#define REG_ARFR5					0x04A4
+#define REG_TXRPT_START_OFFSET				0x04AC
+
+#define REG_POWER_STAGE1				0x04B4
+
+#define REG_POWER_STAGE2				0x04B8
+
+#define REG_SW_AMPDU_BURST_MODE_CTRL			0x04BC
+#define REG_PKT_LIFE_TIME				0x04C0
+#define REG_STBC_SETTING				0x04C4
+#define REG_STBC_SETTING2				0x04C5
+#define REG_QUEUE_CTRL					0x04C6
+#define REG_SINGLE_AMPDU_CTRL				0x04C7
+#define REG_PROT_MODE_CTRL				0x04C8
+#define REG_BAR_MODE_CTRL				0x04CC
+#define REG_RA_TRY_RATE_AGG_LMT			0x04CF
+#define REG_MACID_SLEEP2				0x04D0
+#define REG_MACID_SLEEP				0x04D4
+
+#define REG_HW_SEQ0					0x04D8
+#define REG_HW_SEQ1					0x04DA
+#define REG_HW_SEQ2					0x04DC
+#define REG_HW_SEQ3					0x04DE
+
+#define REG_NULL_PKT_STATUS_V1				0x04E0
+
+#define REG_PTCL_ERR_STATUS				0x04E2
+
+#define REG_NULL_PKT_STATUS_EXTEND			0x04E3
+
+#define REG_VIDEO_ENHANCEMENT_FUN			0x04E4
+
+#define REG_BT_POLLUTE_PKT_CNT				0x04E8
+#define REG_PTCL_DBG					0x04EC
+
+#define REG_CPUMGQ_TIMER_CTRL2				0x04F4
+
+#define REG_DUMMY_PAGE4_V1				0x04FC
+#define REG_MOREDATA					0x04FE
+
+#define REG_EDCA_VO_PARAM				0x0500
+#define REG_EDCA_VI_PARAM				0x0504
+#define REG_EDCA_BE_PARAM				0x0508
+#define REG_EDCA_BK_PARAM				0x050C
+#define REG_BCNTCFG					0x0510
+#define REG_PIFS					0x0512
+#define REG_RDG_PIFS					0x0513
+#define REG_SIFS					0x0514
+#define REG_TSFTR_SYN_OFFSET				0x0518
+#define REG_AGGR_BREAK_TIME				0x051A
+#define REG_SLOT					0x051B
+#define REG_TX_PTCL_CTRL				0x0520
+#define REG_TXPAUSE					0x0522
+#define REG_DIS_TXREQ_CLR				0x0523
+#define REG_RD_CTRL					0x0524
+#define REG_MBSSID_CTRL				0x0526
+#define REG_P2PPS_CTRL					0x0527
+#define REG_PKT_LIFETIME_CTRL				0x0528
+#define REG_P2PPS_SPEC_STATE				0x052B
+
+#define REG_BAR_TX_CTRL				0x0530
+
+#define REG_QUEUE_INCOL_THR				0x0538
+#define REG_QUEUE_INCOL_EN				0x053C
+
+#define REG_TBTT_PROHIBIT				0x0540
+#define REG_P2PPS_STATE				0x0543
+#define REG_RD_NAV_NXT					0x0544
+#define REG_NAV_PROT_LEN				0x0546
+
+#define REG_BCN_CTRL					0x0550
+
+#define REG_BCN_CTRL_CLINT0				0x0551
+
+#define REG_MBID_NUM					0x0552
+#define REG_DUAL_TSF_RST				0x0553
+#define REG_MBSSID_BCN_SPACE				0x0554
+#define REG_DRVERLYINT					0x0558
+#define REG_BCNDMATIM					0x0559
+#define REG_ATIMWND					0x055A
+#define REG_USTIME_TSF					0x055C
+#define REG_BCN_MAX_ERR				0x055D
+#define REG_RXTSF_OFFSET_CCK				0x055E
+#define REG_RXTSF_OFFSET_OFDM				0x055F
+#define REG_TSFTR					0x0560
+
+#define REG_FREERUN_CNT				0x0568
+
+#define REG_ATIMWND1_V1				0x0570
+
+#define REG_TBTT_PROHIBIT_INFRA			0x0571
+
+#define REG_CTWND					0x0572
+#define REG_BCNIVLCUNT					0x0573
+#define REG_BCNDROPCTRL				0x0574
+#define REG_HGQ_TIMEOUT_PERIOD				0x0575
+
+#define REG_TXCMD_TIMEOUT_PERIOD			0x0576
+#define REG_MISC_CTRL					0x0577
+#define REG_BCN_CTRL_CLINT1				0x0578
+#define REG_BCN_CTRL_CLINT2				0x0579
+#define REG_BCN_CTRL_CLINT3				0x057A
+
+#define REG_EXTEND_CTRL				0x057B
+
+#define REG_P2PPS1_SPEC_STATE				0x057C
+#define REG_P2PPS1_STATE				0x057D
+#define REG_P2PPS2_SPEC_STATE				0x057E
+#define REG_P2PPS2_STATE				0x057F
+
+#define REG_PS_TIMER0					0x0580
+
+#define REG_PS_TIMER1					0x0584
+
+#define REG_PS_TIMER2					0x0588
+
+#define REG_TBTT_CTN_AREA				0x058C
+#define REG_FORCE_BCN_IFS				0x058E
+#define REG_TXOP_MIN					0x0590
+#define REG_PRE_BKF_TIME				0x0592
+#define REG_CROSS_TXOP_CTRL				0x0593
+
+#define REG_ATIMWND2					0x05A0
+#define REG_ATIMWND3					0x05A1
+#define REG_ATIMWND4					0x05A2
+#define REG_ATIMWND5					0x05A3
+#define REG_ATIMWND6					0x05A4
+#define REG_ATIMWND7					0x05A5
+#define REG_ATIMUGT					0x05A6
+#define REG_HIQ_NO_LMT_EN				0x05A7
+#define REG_DTIM_COUNTER_ROOT				0x05A8
+#define REG_DTIM_COUNTER_VAP1				0x05A9
+#define REG_DTIM_COUNTER_VAP2				0x05AA
+#define REG_DTIM_COUNTER_VAP3				0x05AB
+#define REG_DTIM_COUNTER_VAP4				0x05AC
+#define REG_DTIM_COUNTER_VAP5				0x05AD
+#define REG_DTIM_COUNTER_VAP6				0x05AE
+#define REG_DTIM_COUNTER_VAP7				0x05AF
+#define REG_DIS_ATIM					0x05B0
+
+#define REG_EARLY_128US				0x05B1
+#define REG_P2PPS1_CTRL				0x05B2
+#define REG_P2PPS2_CTRL				0x05B3
+#define REG_TIMER0_SRC_SEL				0x05B4
+#define REG_NOA_UNIT_SEL				0x05B5
+#define REG_P2POFF_DIS_TXTIME				0x05B7
+#define REG_MBSSID_BCN_SPACE2				0x05B8
+#define REG_MBSSID_BCN_SPACE3				0x05BC
+
+#define REG_ACMHWCTRL					0x05C0
+#define REG_ACMRSTCTRL					0x05C1
+#define REG_ACMAVG					0x05C2
+#define REG_VO_ADMTIME					0x05C4
+#define REG_VI_ADMTIME					0x05C6
+#define REG_BE_ADMTIME					0x05C8
+#define REG_EDCA_RANDOM_GEN				0x05CC
+#define REG_TXCMD_NOA_SEL				0x05CF
+#define REG_NOA_PARAM					0x05E0
+
+#define REG_P2P_RST					0x05F0
+#define REG_SCHEDULER_RST				0x05F1
+
+#define REG_SCH_TXCMD					0x05F8
+#define REG_PAGE5_DUMMY				0x05FC
+#define REG_WMAC_CR					0x0600
+
+#define REG_WMAC_FWPKT_CR				0x0601
+
+#define REG_BWOPMODE					0x0603
+
+#define REG_TCR					0x0604
+#define REG_RCR					0x0608
+#define REG_RX_PKT_LIMIT				0x060C
+#define REG_RX_DLK_TIME				0x060D
+#define REG_RX_DRVINFO_SZ				0x060F
+#define REG_MACID					0x0610
+#define REG_BSSID					0x0618
+#define REG_MAR					0x0620
+#define REG_MBIDCAMCFG_1				0x0628
+#define REG_MBIDCAMCFG_2				0x062C
+
+#define REG_WMAC_TCR_TSFT_OFS				0x0630
+#define REG_UDF_THSD					0x0632
+#define REG_ZLD_NUM					0x0633
+
+#define REG_STMP_THSD					0x0634
+#define REG_WMAC_TXTIMEOUT				0x0635
+#define REG_MCU_TEST_2_V1				0x0636
+
+#define REG_USTIME_EDCA				0x0638
+
+#define REG_MAC_SPEC_SIFS				0x063A
+#define REG_RESP_SIFS_CCK				0x063C
+#define REG_RESP_SIFS_OFDM				0x063E
+#define REG_ACKTO					0x0640
+#define REG_CTS2TO					0x0641
+#define REG_EIFS					0x0642
+
+#define REG_NAV_CTRL					0x0650
+#define REG_BACAMCMD					0x0654
+#define REG_BACAMCONTENT				0x0658
+#define REG_LBDLY					0x0660
+
+#define REG_WMAC_BACAM_RPMEN				0x0661
+
+#define REG_TX_RX					0x0662
+
+#define REG_WMAC_BITMAP_CTL				0x0663
+
+#define REG_RXERR_RPT					0x0664
+#define REG_WMAC_TRXPTCL_CTL				0x0668
+#define REG_CAMCMD					0x0670
+#define REG_CAMWRITE					0x0674
+#define REG_CAMREAD					0x0678
+#define REG_CAMDBG					0x067C
+#define REG_SECCFG					0x0680
+
+#define REG_RXFILTER_CATEGORY_1			0x0682
+#define REG_RXFILTER_ACTION_1				0x0683
+#define REG_RXFILTER_CATEGORY_2			0x0684
+#define REG_RXFILTER_ACTION_2				0x0685
+#define REG_RXFILTER_CATEGORY_3			0x0686
+#define REG_RXFILTER_ACTION_3				0x0687
+#define REG_RXFLTMAP3					0x0688
+#define REG_RXFLTMAP4					0x068A
+#define REG_RXFLTMAP5					0x068C
+#define REG_RXFLTMAP6					0x068E
+
+#define REG_WOW_CTRL					0x0690
+
+#define REG_NAN_RX_TSF_FILTER				0x0691
+
+#define REG_PS_RX_INFO					0x0692
+#define REG_WMMPS_UAPSD_TID				0x0693
+#define REG_LPNAV_CTRL					0x0694
+
+#define REG_WKFMCAM_CMD				0x0698
+#define REG_WKFMCAM_RWD				0x069C
+
+#define REG_RXFLTMAP0					0x06A0
+#define REG_RXFLTMAP1					0x06A2
+#define REG_RXFLTMAP					0x06A4
+#define REG_BCN_PSR_RPT				0x06A8
+
+#define REG_FLC_RPC					0x06AC
+#define REG_FLC_RPCT					0x06AD
+#define REG_FLC_PTS					0x06AE
+#define REG_FLC_TRPC					0x06AF
+
+#define REG_RXPKTMON_CTRL				0x06B0
+
+#define REG_STATE_MON					0x06B4
+
+#define REG_ERROR_MON					0x06B8
+#define REG_SEARCH_MACID				0x06BC
+
+#define REG_BT_COEX_TABLE				0x06C0
+
+#define REG_RXCMD_0					0x06D0
+#define REG_RXCMD_1					0x06D4
+
+#define REG_WMAC_RESP_TXINFO				0x06D8
+
+#define REG_BBPSF_CTRL					0x06DC
+
+#define REG_P2P_RX_BCN_NOA				0x06E0
+#define REG_ASSOCIATED_BFMER0_INFO			0x06E4
+#define REG_ASSOCIATED_BFMER1_INFO			0x06EC
+#define REG_TX_CSI_RPT_PARAM_BW20			0x06F4
+#define REG_TX_CSI_RPT_PARAM_BW40			0x06F8
+#define REG_TX_CSI_RPT_PARAM_BW80			0x06FC
+#define REG_MACID1					0x0700
+
+#define REG_BSSID1					0x0708
+
+#define REG_BCN_PSR_RPT1				0x0710
+#define REG_ASSOCIATED_BFMEE_SEL			0x0714
+#define REG_SND_PTCL_CTRL				0x0718
+#define REG_RX_CSI_RPT_INFO				0x071C
+#define REG_NS_ARP_CTRL				0x0720
+#define REG_NS_ARP_INFO				0x0724
+
+#define REG_BEAMFORMING_INFO_NSARP_V1			0x0728
+
+#define REG_BEAMFORMING_INFO_NSARP			0x072C
+
+#define REG_WMAC_RTX_CTX_SUBTYPE_CFG			0x0750
+
+#define REG_WMAC_SWAES_CFG				0x0760
+
+#define REG_BT_COEX_V2					0x0762
+
+#define REG_BT_COEX					0x0764
+
+#define REG_WLAN_ACT_MASK_CTRL				0x0768
+
+#define REG_BT_COEX_ENHANCED_INTR_CTRL			0x076E
+
+#define REG_BT_ACT_STATISTICS				0x0770
+
+#define REG_BT_STATISTICS_CONTROL_REGISTER		0x0778
+
+#define REG_BT_STATUS_REPORT_REGISTER			0x077C
+
+#define REG_BT_INTERRUPT_CONTROL_REGISTER		0x0780
+
+#define REG_WLAN_REPORT_TIME_OUT_CONTROL_REGISTER	0x0784
+
+#define REG_BT_ISOLATION_TABLE_REGISTER_REGISTER	0x0785
+
+#define REG_BT_INTERRUPT_STATUS_REGISTER		0x078F
+
+#define REG_BT_TDMA_TIME_REGISTER			0x0790
+
+#define REG_BT_ACT_REGISTER				0x0794
+
+#define REG_OBFF_CTRL_BASIC				0x0798
+
+#define REG_OBFF_CTRL2_TIMER				0x079C
+
+#define REG_LTR_CTRL_BASIC				0x07A0
+
+#define REG_LTR_CTRL2_TIMER_THRESHOLD			0x07A4
+
+#define REG_LTR_IDLE_LATENCY_V1			0x07A8
+#define REG_LTR_ACTIVE_LATENCY_V1			0x07AC
+
+#define REG_ANTENNA_TRAINING_CONTROL_REGISTER		0x07B0
+
+#define REG_WMAC_PKTCNT_RWD				0x07B8
+#define REG_WMAC_PKTCNT_CTRL				0x07BC
+
+#define REG_IQ_DUMP					0x07C0
+
+#define REG_WMAC_FTM_CTL				0x07CC
+
+#define REG_WMAC_IQ_MDPK_FUNC				0x07CE
+
+#define REG_WMAC_OPTION_FUNCTION			0x07D0
+
+#define REG_RX_FILTER_FUNCTION				0x07DA
+
+#define REG_NDP_SIG					0x07E0
+#define REG_TXCMD_INFO_FOR_RSP_PKT			0x07E4
+
+#define REG_RTS_ADDRESS_0				0x07F0
+
+#define REG_RTS_ADDRESS_1				0x07F8
+
+#define REG__RPFM_MAP1					0x07FE
+
+#define REG_SYS_CFG3					0x1000
+#define REG_SYS_CFG4					0x1034
+
+#define REG_SYS_CFG5					0x1070
+
+#define REG_CPU_DMEM_CON				0x1080
+
+#define REG_BOOT_REASON				0x1088
+#define REG_NFCPAD_CTRL				0x10A8
+
+#define REG_HIMR2					0x10B0
+#define REG_HISR2					0x10B4
+#define REG_HIMR3					0x10B8
+#define REG_HISR3					0x10BC
+#define REG_SW_MDIO					0x10C0
+#define REG_SW_FLUSH					0x10C4
+
+#define REG_H2C_PKT_READADDR				0x10D0
+#define REG_H2C_PKT_WRITEADDR				0x10D4
+
+#define REG_MEM_PWR_CRTL				0x10D8
+
+#define REG_FW_DBG0					0x10E0
+#define REG_FW_DBG1					0x10E4
+#define REG_FW_DBG2					0x10E8
+#define REG_FW_DBG3					0x10EC
+#define REG_FW_DBG4					0x10F0
+#define REG_FW_DBG5					0x10F4
+#define REG_FW_DBG6					0x10F8
+#define REG_FW_DBG7					0x10FC
+#define REG_CR_EXT					0x1100
+#define REG_FWFF					0x1114
+
+#define REG_RXFF_PTR_V1				0x1118
+#define REG_RXFF_WTR_V1				0x111C
+
+#define REG_FE2IMR					0x1120
+#define REG_FE2ISR					0x1124
+#define REG_FE3IMR					0x1128
+#define REG_FE3ISR					0x112C
+#define REG_FE4IMR					0x1130
+#define REG_FE4ISR					0x1134
+#define REG_FT1IMR					0x1138
+#define REG_FT1ISR					0x113C
+#define REG_SPWR0					0x1140
+#define REG_SPWR1					0x1144
+#define REG_SPWR2					0x1148
+#define REG_SPWR3					0x114C
+#define REG_POWSEQ					0x1150
+
+#define REG_TC7_CTRL_V1				0x1158
+#define REG_TC8_CTRL_V1				0x115C
+
+#define REG_FT2IMR					0x11E0
+#define REG_FT2ISR					0x11E4
+
+#define REG_MSG2					0x11F0
+#define REG_MSG3					0x11F4
+#define REG_MSG4					0x11F8
+#define REG_MSG5					0x11FC
+#define REG_DDMA_CH0SA					0x1200
+#define REG_DDMA_CH0DA					0x1204
+#define REG_DDMA_CH0CTRL				0x1208
+#define REG_DDMA_CH1SA					0x1210
+#define REG_DDMA_CH1DA					0x1214
+#define REG_DDMA_CH1CTRL				0x1218
+#define REG_DDMA_CH2SA					0x1220
+#define REG_DDMA_CH2DA					0x1224
+#define REG_DDMA_CH2CTRL				0x1228
+#define REG_DDMA_CH3SA					0x1230
+#define REG_DDMA_CH3DA					0x1234
+#define REG_DDMA_CH3CTRL				0x1238
+#define REG_DDMA_CH4SA					0x1240
+#define REG_DDMA_CH4DA					0x1244
+#define REG_DDMA_CH4CTRL				0x1248
+#define REG_DDMA_CH5SA					0x1250
+#define REG_DDMA_CH5DA					0x1254
+
+#define REG_REG_DDMA_CH5CTRL				0x1258
+
+#define REG_DDMA_INT_MSK				0x12E0
+#define REG_DDMA_CHSTATUS				0x12E8
+#define REG_DDMA_CHKSUM				0x12F0
+#define REG_DDMA_MONITOR				0x12FC
+
+#define REG_STC_INT_CS					0x1300
+#define REG_ST_INT_CFG					0x1304
+#define REG_CMU_DLY_CTRL				0x1310
+#define REG_CMU_DLY_CFG				0x1314
+#define REG_H2CQ_TXBD_DESA				0x1320
+#define REG_H2CQ_TXBD_NUM				0x1328
+#define REG_H2CQ_TXBD_IDX				0x132C
+#define REG_H2CQ_CSR					0x1330
+
+#define REG_CHANGE_PCIE_SPEED				0x1350
+
+#define REG_OLD_DEHANG					0x13F4
+
+#define REG_Q0_Q1_INFO					0x1400
+#define REG_Q2_Q3_INFO					0x1404
+#define REG_Q4_Q5_INFO					0x1408
+#define REG_Q6_Q7_INFO					0x140C
+#define REG_MGQ_HIQ_INFO				0x1410
+#define REG_CMDQ_BCNQ_INFO				0x1414
+#define REG_USEREG_SETTING				0x1420
+#define REG_AESIV_SETTING				0x1424
+#define REG_BF0_TIME_SETTING				0x1428
+#define REG_BF1_TIME_SETTING				0x142C
+#define REG_BF_TIMEOUT_EN				0x1430
+#define REG_MACID_RELEASE0				0x1434
+#define REG_MACID_RELEASE1				0x1438
+#define REG_MACID_RELEASE2				0x143C
+#define REG_MACID_RELEASE3				0x1440
+#define REG_MACID_RELEASE_SETTING			0x1444
+#define REG_FAST_EDCA_VOVI_SETTING			0x1448
+#define REG_FAST_EDCA_BEBK_SETTING			0x144C
+#define REG_MACID_DROP0				0x1450
+#define REG_MACID_DROP1				0x1454
+#define REG_MACID_DROP2				0x1458
+#define REG_MACID_DROP3				0x145C
+
+#define REG_R_MACID_RELEASE_SUCCESS_0			0x1460
+#define REG_R_MACID_RELEASE_SUCCESS_1			0x1464
+#define REG_R_MACID_RELEASE_SUCCESS_2			0x1468
+#define REG_R_MACID_RELEASE_SUCCESS_3			0x146C
+#define REG_MGG_FIFO_CRTL				0x1470
+#define REG_MGG_FIFO_INT				0x1474
+#define REG_MGG_FIFO_LIFETIME				0x1478
+#define REG_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET	0x147C
+
+#define REG_MACID_SHCUT_OFFSET				0x1480
+
+#define REG_MU_TX_CTL					0x14C0
+#define REG_MU_STA_GID_VLD				0x14C4
+#define REG_MU_STA_USER_POS_INFO			0x14C8
+#define REG_MU_TRX_DBG_CNT				0x14D0
+
+#define REG_CPUMGQ_TX_TIMER				0x1500
+#define REG_PS_TIMER_A					0x1504
+#define REG_PS_TIMER_B					0x1508
+#define REG_PS_TIMER_C					0x150C
+#define REG_PS_TIMER_ABC_CPUMGQ_TIMER_CRTL		0x1510
+#define REG_CPUMGQ_TX_TIMER_EARLY			0x1514
+#define REG_PS_TIMER_A_EARLY				0x1515
+#define REG_PS_TIMER_B_EARLY				0x1516
+#define REG_PS_TIMER_C_EARLY				0x1517
+
+#define REG_BCN_PSR_RPT2				0x1600
+#define REG_BCN_PSR_RPT3				0x1604
+#define REG_BCN_PSR_RPT4				0x1608
+#define REG_A1_ADDR_MASK				0x160C
+#define REG_MACID2					0x1620
+#define REG_BSSID2					0x1628
+#define REG_MACID3					0x1630
+#define REG_BSSID3					0x1638
+#define REG_MACID4					0x1640
+#define REG_BSSID4					0x1648
+
+#define REG_NOA_REPORT					0x1650
+#define REG_PWRBIT_SETTING				0x1660
+#define REG_WMAC_MU_BF_OPTION				0x167C
+
+#define REG_WMAC_MU_ARB				0x167E
+#define REG_WMAC_MU_OPTION				0x167F
+#define REG_WMAC_MU_BF_CTL				0x1680
+
+#define REG_WMAC_MU_BFRPT_PARA				0x1682
+
+#define REG_WMAC_ASSOCIATED_MU_BFMEE2			0x1684
+#define REG_WMAC_ASSOCIATED_MU_BFMEE3			0x1686
+#define REG_WMAC_ASSOCIATED_MU_BFMEE4			0x1688
+#define REG_WMAC_ASSOCIATED_MU_BFMEE5			0x168A
+#define REG_WMAC_ASSOCIATED_MU_BFMEE6			0x168C
+#define REG_WMAC_ASSOCIATED_MU_BFMEE7			0x168E
+
+#define REG_TRANSMIT_ADDRSS_0				0x16A0
+#define REG_TRANSMIT_ADDRSS_1				0x16A8
+#define REG_TRANSMIT_ADDRSS_2				0x16B0
+#define REG_TRANSMIT_ADDRSS_3				0x16B8
+#define REG_TRANSMIT_ADDRSS_4				0x16C0
+
+#define REG_WL2LTECOEX_INDIRECT_ACCESS_CTRL_V1	0x1700
+#define REG_WL2LTECOEX_INDIRECT_ACCESS_WRITE_DATA_V1	0x1704
+#define REG_WL2LTECOEX_INDIRECT_ACCESS_READ_DATA_V1	0x1708
+
+/* ----------------------------------------------------- */
+/*	*/
+/* 0xFB00h ~ 0xFCFFh	TX/RX packet buffer affress */
+/*	*/
+/* ----------------------------------------------------- */
+#define REG_RXPKTBUF_STARTADDR	0xFB00
+#define REG_TXPKTBUF_STARTADDR	0xFC00
+
+/* ----------------------------------------------------- */
+/*	*/
+/* 0xFD00h ~ 0xFDFFh	8051 CPU Local REG */
+/*	*/
+/* ----------------------------------------------------- */
+#define REG_SYS_CTRL		0xFD00
+#define REG_PONSTS_RPT1		0xFD01
+#define REG_PONSTS_RPT2		0xFD02
+#define REG_PONSTS_RPT3		0xFD03
+#define REG_PONSTS_RPT4		0xFD04	/* 0x84 */
+#define REG_PONSTS_RPT5		0xFD05	/* 0x85 */
+#define REG_8051ERRFLAG		0xFD08
+#define REG_8051ERRFLAG_MASK	0xFD09
+#define REG_TXADDRH		0xFD10	/* Tx Packet High address */
+#define REG_RXADDRH		0xFD11	/* Rx Packet High address */
+#define REG_TXADDRH_EXT		0xFD12	/* 0xFD12[0] : for 8051 access txpktbuf
+					 * high64k as external register
+					 */
+
+#define REG_U3_STATE		0xFD48	/* (Read only)
+					 * [7:4] : usb3 changed last state.
+					 * [3:0] : usb3 state
+					 */
+
+/* for MAILBOX */
+#define REG_OUTDATA0		0xFD50
+#define REG_OUTDATA1		0xFD54
+#define REG_OUTRDY		0xFD58	/* bit[0] : OutReady,
+					 * bit[1] : OutEmptyIntEn
+					 */
+
+#define REG_INDATA0		0xFD60
+#define REG_INDATA1		0xFD64
+#define REG_INRDY		0xFD68	/* bit[0] : InReady,
+					 * bit[1] : InRdyIntEn
+					 */
+
+/* MCU ERROR debug REG */
+#define REG_MCUERR_PCLSB	0xFD90	/* PC[7:0] */
+#define REG_MCUERR_PCMSB	0xFD91	/* PC[15:8] */
+#define REG_MCUERR_ACC		0xFD92
+#define REG_MCUERR_B		0xFD93
+#define REG_MCUERR_DPTRLSB	0xFD94	/* DPTR[7:0] */
+#define REG_MCUERR_DPTRMSB	0xFD95	/* DPTR[15:8] */
+#define REG_MCUERR_SP		0xFD96	/* SP[7:0] */
+#define REG_MCUERR_IE		0xFD97	/* IE[7:0] */
+#define REG_MCUERR_EIE		0xFD98	/* EIE[7:0] */
+#define REG_VERA_SIM		0xFD9F
+/* 0xFD99~0xFD9F are reserved.. */
+
+/* ----------------------------------------------------- */
+/*	*/
+/* 0xFE00h ~ 0xFEFFh	USB Configuration */
+/*	*/
+/* ----------------------------------------------------- */
+
+/* RTS5101 USB Register Definition */
+#define REG_USB_SETUP_DEC_INT		0xFE00
+#define REG_USB_DMACTL			0xFE01
+#define REG_USB_IRQSTAT0		0xFE02
+#define REG_USB_IRQSTAT1		0xFE03
+#define REG_USB_IRQEN0			0xFE04
+#define REG_USB_IRQEN1			0xFE05
+#define REG_USB_AUTOPTRL		0xFE06
+#define REG_USB_AUTOPTRH		0xFE07
+#define REG_USB_AUTODAT			0xFE08
+
+#define REG_USB_SCRATCH0		0xFE09
+#define REG_USB_SCRATCH1		0xFE0A
+#define REG_USB_SEEPROM			0xFE0B
+#define REG_USB_GPIO0			0xFE0C
+#define REG_USB_GPIO0DIR		0xFE0D
+#define REG_USB_CLKSEL			0xFE0E
+#define REG_USB_BOOTCTL			0xFE0F
+
+#define REG_USB_USBCTL			0xFE10
+#define REG_USB_USBSTAT			0xFE11
+#define REG_USB_DEVADDR			0xFE12
+#define REG_USB_USBTEST			0xFE13
+#define REG_USB_FNUM0			0xFE14
+#define REG_USB_FNUM1			0xFE15
+
+#define REG_USB_EP_IDX			0xFE20
+#define REG_USB_EP_CFG			0xFE21
+#define REG_USB_EP_CTL			0xFE22
+#define REG_USB_EP_STAT			0xFE23
+#define REG_USB_EP_IRQ			0xFE24
+#define REG_USB_EP_IRQEN		0xFE25
+#define REG_USB_EP_MAXPKT0		0xFE26
+#define REG_USB_EP_MAXPKT1		0xFE27
+#define REG_USB_EP_DAT			0xFE28
+#define REG_USB_EP_BC0			0xFE29
+#define REG_USB_EP_BC1			0xFE2A
+#define REG_USB_EP_TC0			0xFE2B
+#define REG_USB_EP_TC1			0xFE2C
+#define REG_USB_EP_TC2			0xFE2D
+#define REG_USB_EP_CTL2			0xFE2E
+
+#define REG_USB_INFO			0xFE17
+#define REG_USB_SPECIAL_OPTION		0xFE55
+#define REG_USB_DMA_AGG_TO		0xFE5B
+#define REG_USB_AGG_TO			0xFE5C
+#define REG_USB_AGG_TH			0xFE5D
+
+#define REG_USB_VID			0xFE60
+#define REG_USB_PID			0xFE62
+#define REG_USB_OPT			0xFE64
+#define REG_USB_CONFIG			0xFE65	/* RX EP setting.
+						 * 0xFE65 Bit[3:0] : RXQ,
+						 *        Bit[7:4] : INTQ
+						 */
+						/* TX EP setting.
+						 * 0xFE66 Bit[3:0] : TXQ0,
+						 *        Bit[7:4] : TXQ1,
+						 * 0xFE67 Bit[3:0] : TXQ2
+						 */
+#define REG_USB_PHY_PARA1 0xFE68 /* Bit[7:4]: XCVR_SEN	(USB PHY 0xE2[7:4]),
+				  * Bit[3:0]: XCVR_SH	(USB PHY 0xE2[3:0])
+				  */
+#define REG_USB_PHY_PARA2 0xFE69 /* Bit[7:5]: XCVR_BG	(USB PHY 0xE3[5:3]),
+				  * Bit[4:2]: XCVR_DR	(USB PHY 0xE3[2:0]),
+				  * Bit[1]: SE0_LVL	(USB PHY 0xE5[7]),
+				  * Bit[0]: FORCE_XTL_ON (USB PHY 0xE5[1])
+				  */
+#define REG_USB_PHY_PARA3 0xFE6A /* Bit[7:5]: XCVR_SRC	(USB PHY 0xE5[4:2]),
+				  * Bit[4]: LATE_DLLEN	(USB PHY 0xF0[4]),
+				  * Bit[3]: HS_LP_MODE	(USB PHY 0xF0[3]),
+				  * Bit[2]: UTMI_POS_OUT (USB PHY 0xF1 [7]),
+				  * Bit[1:0]: TX_DELAY	(USB PHY 0xF1 [2:1])
+				  */
+#define REG_USB_PHY_PARA4		0xFE6B	/* (USB PHY 0xE7[7:0]) */
+#define REG_USB_OPT2			0xFE6C
+#define REG_USB_MAC_ADDR			0xFE70	/* 0xFE70~0xFE75 */
+#define REG_USB_MANUFACTURE_SETTING	0xFE80	/* 0xFE80~0xFE90 Max: 32 bytes*/
+#define REG_USB_PRODUCT_STRING		0xFEA0	/* 0xFEA0~0xFECF Max: 48 bytes*/
+#define REG_USB_SERIAL_NUMBER_STRING	0xFED0	/* 0xFED0~0xFEDF Max: 12 bytes*/
+
+#define REG_USB_ALTERNATE_SETTING	0xFE4F
+#define REG_USB_INT_BINTERVAL		0xFE6E
+#define REG_USB_GPS_EP_CONFIG		0xFE6D
+
+#endif	/* __HALMAC_COM_REG_H__ */
diff --git a/drivers/staging/rtlwifi/halmac/halmac_reg_8822b.h b/drivers/staging/rtlwifi/halmac/halmac_reg_8822b.h
new file mode 100644
index 000000000000..4bc59b127412
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_reg_8822b.h
@@ -0,0 +1,728 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __INC_HALMAC_REG_8822B_H
+#define __INC_HALMAC_REG_8822B_H
+
+#define REG_SYS_ISO_CTRL_8822B 0x0000
+#define REG_SYS_FUNC_EN_8822B 0x0002
+#define REG_SYS_PW_CTRL_8822B 0x0004
+#define REG_SYS_CLK_CTRL_8822B 0x0008
+#define REG_SYS_EEPROM_CTRL_8822B 0x000A
+#define REG_EE_VPD_8822B 0x000C
+#define REG_SYS_SWR_CTRL1_8822B 0x0010
+#define REG_SYS_SWR_CTRL2_8822B 0x0014
+#define REG_SYS_SWR_CTRL3_8822B 0x0018
+#define REG_RSV_CTRL_8822B 0x001C
+#define REG_RF_CTRL_8822B 0x001F
+#define REG_AFE_LDO_CTRL_8822B 0x0020
+#define REG_AFE_CTRL1_8822B 0x0024
+#define REG_AFE_CTRL2_8822B 0x0028
+#define REG_AFE_CTRL3_8822B 0x002C
+#define REG_EFUSE_CTRL_8822B 0x0030
+#define REG_LDO_EFUSE_CTRL_8822B 0x0034
+#define REG_PWR_OPTION_CTRL_8822B 0x0038
+#define REG_CAL_TIMER_8822B 0x003C
+#define REG_ACLK_MON_8822B 0x003E
+#define REG_GPIO_MUXCFG_8822B 0x0040
+#define REG_GPIO_PIN_CTRL_8822B 0x0044
+#define REG_GPIO_INTM_8822B 0x0048
+#define REG_LED_CFG_8822B 0x004C
+#define REG_FSIMR_8822B 0x0050
+#define REG_FSISR_8822B 0x0054
+#define REG_HSIMR_8822B 0x0058
+#define REG_HSISR_8822B 0x005C
+#define REG_GPIO_EXT_CTRL_8822B 0x0060
+#define REG_PAD_CTRL1_8822B 0x0064
+#define REG_WL_BT_PWR_CTRL_8822B 0x0068
+#define REG_SDM_DEBUG_8822B 0x006C
+#define REG_SYS_SDIO_CTRL_8822B 0x0070
+#define REG_HCI_OPT_CTRL_8822B 0x0074
+#define REG_AFE_CTRL4_8822B 0x0078
+#define REG_LDO_SWR_CTRL_8822B 0x007C
+#define REG_MCUFW_CTRL_8822B 0x0080
+#define REG_MCU_TST_CFG_8822B 0x0084
+#define REG_HMEBOX_E0_E1_8822B 0x0088
+#define REG_HMEBOX_E2_E3_8822B 0x008C
+#define REG_WLLPS_CTRL_8822B 0x0090
+#define REG_AFE_CTRL5_8822B 0x0094
+#define REG_GPIO_DEBOUNCE_CTRL_8822B 0x0098
+#define REG_RPWM2_8822B 0x009C
+#define REG_SYSON_FSM_MON_8822B 0x00A0
+#define REG_AFE_CTRL6_8822B 0x00A4
+#define REG_PMC_DBG_CTRL1_8822B 0x00A8
+#define REG_AFE_CTRL7_8822B 0x00AC
+#define REG_HIMR0_8822B 0x00B0
+#define REG_HISR0_8822B 0x00B4
+#define REG_HIMR1_8822B 0x00B8
+#define REG_HISR1_8822B 0x00BC
+#define REG_DBG_PORT_SEL_8822B 0x00C0
+#define REG_PAD_CTRL2_8822B 0x00C4
+#define REG_PMC_DBG_CTRL2_8822B 0x00CC
+#define REG_BIST_CTRL_8822B 0x00D0
+#define REG_BIST_RPT_8822B 0x00D4
+#define REG_MEM_CTRL_8822B 0x00D8
+#define REG_AFE_CTRL8_8822B 0x00DC
+#define REG_USB_SIE_INTF_8822B 0x00E0
+#define REG_PCIE_MIO_INTF_8822B 0x00E4
+#define REG_PCIE_MIO_INTD_8822B 0x00E8
+#define REG_WLRF1_8822B 0x00EC
+#define REG_SYS_CFG1_8822B 0x00F0
+#define REG_SYS_STATUS1_8822B 0x00F4
+#define REG_SYS_STATUS2_8822B 0x00F8
+#define REG_SYS_CFG2_8822B 0x00FC
+#define REG_SYS_CFG3_8822B 0x1000
+#define REG_SYS_CFG4_8822B 0x1034
+#define REG_SYS_CFG5_8822B 0x1070
+#define REG_CPU_DMEM_CON_8822B 0x1080
+#define REG_BOOT_REASON_8822B 0x1088
+#define REG_NFCPAD_CTRL_8822B 0x10A8
+#define REG_HIMR2_8822B 0x10B0
+#define REG_HISR2_8822B 0x10B4
+#define REG_HIMR3_8822B 0x10B8
+#define REG_HISR3_8822B 0x10BC
+#define REG_SW_MDIO_8822B 0x10C0
+#define REG_SW_FLUSH_8822B 0x10C4
+#define REG_H2C_PKT_READADDR_8822B 0x10D0
+#define REG_H2C_PKT_WRITEADDR_8822B 0x10D4
+#define REG_MEM_PWR_CRTL_8822B 0x10D8
+#define REG_FW_DBG0_8822B 0x10E0
+#define REG_FW_DBG1_8822B 0x10E4
+#define REG_FW_DBG2_8822B 0x10E8
+#define REG_FW_DBG3_8822B 0x10EC
+#define REG_FW_DBG4_8822B 0x10F0
+#define REG_FW_DBG5_8822B 0x10F4
+#define REG_FW_DBG6_8822B 0x10F8
+#define REG_FW_DBG7_8822B 0x10FC
+#define REG_CR_8822B 0x0100
+#define REG_PKT_BUFF_ACCESS_CTRL_8822B 0x0106
+#define REG_TSF_CLK_STATE_8822B 0x0108
+#define REG_TXDMA_PQ_MAP_8822B 0x010C
+#define REG_TRXFF_BNDY_8822B 0x0114
+#define REG_PTA_I2C_MBOX_8822B 0x0118
+#define REG_RXFF_BNDY_8822B 0x011C
+#define REG_FE1IMR_8822B 0x0120
+#define REG_FE1ISR_8822B 0x0124
+#define REG_CPWM_8822B 0x012C
+#define REG_FWIMR_8822B 0x0130
+#define REG_FWISR_8822B 0x0134
+#define REG_FTIMR_8822B 0x0138
+#define REG_FTISR_8822B 0x013C
+#define REG_PKTBUF_DBG_CTRL_8822B 0x0140
+#define REG_PKTBUF_DBG_DATA_L_8822B 0x0144
+#define REG_PKTBUF_DBG_DATA_H_8822B 0x0148
+#define REG_CPWM2_8822B 0x014C
+#define REG_TC0_CTRL_8822B 0x0150
+#define REG_TC1_CTRL_8822B 0x0154
+#define REG_TC2_CTRL_8822B 0x0158
+#define REG_TC3_CTRL_8822B 0x015C
+#define REG_TC4_CTRL_8822B 0x0160
+#define REG_TCUNIT_BASE_8822B 0x0164
+#define REG_TC5_CTRL_8822B 0x0168
+#define REG_TC6_CTRL_8822B 0x016C
+#define REG_MBIST_FAIL_8822B 0x0170
+#define REG_MBIST_START_PAUSE_8822B 0x0174
+#define REG_MBIST_DONE_8822B 0x0178
+#define REG_MBIST_FAIL_NRML_8822B 0x017C
+#define REG_AES_DECRPT_DATA_8822B 0x0180
+#define REG_AES_DECRPT_CFG_8822B 0x0184
+#define REG_TMETER_8822B 0x0190
+#define REG_OSC_32K_CTRL_8822B 0x0194
+#define REG_32K_CAL_REG1_8822B 0x0198
+#define REG_C2HEVT_8822B 0x01A0
+#define REG_SW_DEFINED_PAGE1_8822B 0x01B8
+#define REG_MCUTST_I_8822B 0x01C0
+#define REG_MCUTST_II_8822B 0x01C4
+#define REG_FMETHR_8822B 0x01C8
+#define REG_HMETFR_8822B 0x01CC
+#define REG_HMEBOX0_8822B 0x01D0
+#define REG_HMEBOX1_8822B 0x01D4
+#define REG_HMEBOX2_8822B 0x01D8
+#define REG_HMEBOX3_8822B 0x01DC
+#define REG_LLT_INIT_8822B 0x01E0
+#define REG_LLT_INIT_ADDR_8822B 0x01E4
+#define REG_BB_ACCESS_CTRL_8822B 0x01E8
+#define REG_BB_ACCESS_DATA_8822B 0x01EC
+#define REG_HMEBOX_E0_8822B 0x01F0
+#define REG_HMEBOX_E1_8822B 0x01F4
+#define REG_HMEBOX_E2_8822B 0x01F8
+#define REG_HMEBOX_E3_8822B 0x01FC
+#define REG_CR_EXT_8822B 0x1100
+#define REG_FWFF_8822B 0x1114
+#define REG_RXFF_PTR_V1_8822B 0x1118
+#define REG_RXFF_WTR_V1_8822B 0x111C
+#define REG_FE2IMR_8822B 0x1120
+#define REG_FE2ISR_8822B 0x1124
+#define REG_FE3IMR_8822B 0x1128
+#define REG_FE3ISR_8822B 0x112C
+#define REG_FE4IMR_8822B 0x1130
+#define REG_FE4ISR_8822B 0x1134
+#define REG_FT1IMR_8822B 0x1138
+#define REG_FT1ISR_8822B 0x113C
+#define REG_SPWR0_8822B 0x1140
+#define REG_SPWR1_8822B 0x1144
+#define REG_SPWR2_8822B 0x1148
+#define REG_SPWR3_8822B 0x114C
+#define REG_POWSEQ_8822B 0x1150
+#define REG_TC7_CTRL_V1_8822B 0x1158
+#define REG_TC8_CTRL_V1_8822B 0x115C
+#define REG_FT2IMR_8822B 0x11E0
+#define REG_FT2ISR_8822B 0x11E4
+#define REG_MSG2_8822B 0x11F0
+#define REG_MSG3_8822B 0x11F4
+#define REG_MSG4_8822B 0x11F8
+#define REG_MSG5_8822B 0x11FC
+#define REG_FIFOPAGE_CTRL_1_8822B 0x0200
+#define REG_FIFOPAGE_CTRL_2_8822B 0x0204
+#define REG_AUTO_LLT_V1_8822B 0x0208
+#define REG_TXDMA_OFFSET_CHK_8822B 0x020C
+#define REG_TXDMA_STATUS_8822B 0x0210
+#define REG_TX_DMA_DBG_8822B 0x0214
+#define REG_TQPNT1_8822B 0x0218
+#define REG_TQPNT2_8822B 0x021C
+#define REG_TQPNT3_8822B 0x0220
+#define REG_TQPNT4_8822B 0x0224
+#define REG_RQPN_CTRL_1_8822B 0x0228
+#define REG_RQPN_CTRL_2_8822B 0x022C
+#define REG_FIFOPAGE_INFO_1_8822B 0x0230
+#define REG_FIFOPAGE_INFO_2_8822B 0x0234
+#define REG_FIFOPAGE_INFO_3_8822B 0x0238
+#define REG_FIFOPAGE_INFO_4_8822B 0x023C
+#define REG_FIFOPAGE_INFO_5_8822B 0x0240
+#define REG_H2C_HEAD_8822B 0x0244
+#define REG_H2C_TAIL_8822B 0x0248
+#define REG_H2C_READ_ADDR_8822B 0x024C
+#define REG_H2C_WR_ADDR_8822B 0x0250
+#define REG_H2C_INFO_8822B 0x0254
+#define REG_RXDMA_AGG_PG_TH_8822B 0x0280
+#define REG_RXPKT_NUM_8822B 0x0284
+#define REG_RXDMA_STATUS_8822B 0x0288
+#define REG_RXDMA_DPR_8822B 0x028C
+#define REG_RXDMA_MODE_8822B 0x0290
+#define REG_C2H_PKT_8822B 0x0294
+#define REG_FWFF_C2H_8822B 0x0298
+#define REG_FWFF_CTRL_8822B 0x029C
+#define REG_FWFF_PKT_INFO_8822B 0x02A0
+#define REG_DDMA_CH0SA_8822B 0x1200
+#define REG_DDMA_CH0DA_8822B 0x1204
+#define REG_DDMA_CH0CTRL_8822B 0x1208
+#define REG_DDMA_CH1SA_8822B 0x1210
+#define REG_DDMA_CH1DA_8822B 0x1214
+#define REG_DDMA_CH1CTRL_8822B 0x1218
+#define REG_DDMA_CH2SA_8822B 0x1220
+#define REG_DDMA_CH2DA_8822B 0x1224
+#define REG_DDMA_CH2CTRL_8822B 0x1228
+#define REG_DDMA_CH3SA_8822B 0x1230
+#define REG_DDMA_CH3DA_8822B 0x1234
+#define REG_DDMA_CH3CTRL_8822B 0x1238
+#define REG_DDMA_CH4SA_8822B 0x1240
+#define REG_DDMA_CH4DA_8822B 0x1244
+#define REG_DDMA_CH4CTRL_8822B 0x1248
+#define REG_DDMA_CH5SA_8822B 0x1250
+#define REG_DDMA_CH5DA_8822B 0x1254
+#define REG_REG_DDMA_CH5CTRL_8822B 0x1258
+#define REG_DDMA_INT_MSK_8822B 0x12E0
+#define REG_DDMA_CHSTATUS_8822B 0x12E8
+#define REG_DDMA_CHKSUM_8822B 0x12F0
+#define REG_DDMA_MONITOR_8822B 0x12FC
+#define REG_PCIE_CTRL_8822B 0x0300
+#define REG_INT_MIG_8822B 0x0304
+#define REG_BCNQ_TXBD_DESA_8822B 0x0308
+#define REG_MGQ_TXBD_DESA_8822B 0x0310
+#define REG_VOQ_TXBD_DESA_8822B 0x0318
+#define REG_VIQ_TXBD_DESA_8822B 0x0320
+#define REG_BEQ_TXBD_DESA_8822B 0x0328
+#define REG_BKQ_TXBD_DESA_8822B 0x0330
+#define REG_RXQ_RXBD_DESA_8822B 0x0338
+#define REG_HI0Q_TXBD_DESA_8822B 0x0340
+#define REG_HI1Q_TXBD_DESA_8822B 0x0348
+#define REG_HI2Q_TXBD_DESA_8822B 0x0350
+#define REG_HI3Q_TXBD_DESA_8822B 0x0358
+#define REG_HI4Q_TXBD_DESA_8822B 0x0360
+#define REG_HI5Q_TXBD_DESA_8822B 0x0368
+#define REG_HI6Q_TXBD_DESA_8822B 0x0370
+#define REG_HI7Q_TXBD_DESA_8822B 0x0378
+#define REG_MGQ_TXBD_NUM_8822B 0x0380
+#define REG_RX_RXBD_NUM_8822B 0x0382
+#define REG_VOQ_TXBD_NUM_8822B 0x0384
+#define REG_VIQ_TXBD_NUM_8822B 0x0386
+#define REG_BEQ_TXBD_NUM_8822B 0x0388
+#define REG_BKQ_TXBD_NUM_8822B 0x038A
+#define REG_HI0Q_TXBD_NUM_8822B 0x038C
+#define REG_HI1Q_TXBD_NUM_8822B 0x038E
+#define REG_HI2Q_TXBD_NUM_8822B 0x0390
+#define REG_HI3Q_TXBD_NUM_8822B 0x0392
+#define REG_HI4Q_TXBD_NUM_8822B 0x0394
+#define REG_HI5Q_TXBD_NUM_8822B 0x0396
+#define REG_HI6Q_TXBD_NUM_8822B 0x0398
+#define REG_HI7Q_TXBD_NUM_8822B 0x039A
+#define REG_TSFTIMER_HCI_8822B 0x039C
+#define REG_BD_RWPTR_CLR_8822B 0x039C
+#define REG_VOQ_TXBD_IDX_8822B 0x03A0
+#define REG_VIQ_TXBD_IDX_8822B 0x03A4
+#define REG_BEQ_TXBD_IDX_8822B 0x03A8
+#define REG_BKQ_TXBD_IDX_8822B 0x03AC
+#define REG_MGQ_TXBD_IDX_8822B 0x03B0
+#define REG_RXQ_RXBD_IDX_8822B 0x03B4
+#define REG_HI0Q_TXBD_IDX_8822B 0x03B8
+#define REG_HI1Q_TXBD_IDX_8822B 0x03BC
+#define REG_HI2Q_TXBD_IDX_8822B 0x03C0
+#define REG_HI3Q_TXBD_IDX_8822B 0x03C4
+#define REG_HI4Q_TXBD_IDX_8822B 0x03C8
+#define REG_HI5Q_TXBD_IDX_8822B 0x03CC
+#define REG_HI6Q_TXBD_IDX_8822B 0x03D0
+#define REG_HI7Q_TXBD_IDX_8822B 0x03D4
+#define REG_DBG_SEL_V1_8822B 0x03D8
+#define REG_PCIE_HRPWM1_V1_8822B 0x03D9
+#define REG_PCIE_HCPWM1_V1_8822B 0x03DA
+#define REG_PCIE_CTRL2_8822B 0x03DB
+#define REG_PCIE_HRPWM2_V1_8822B 0x03DC
+#define REG_PCIE_HCPWM2_V1_8822B 0x03DE
+#define REG_PCIE_H2C_MSG_V1_8822B 0x03E0
+#define REG_PCIE_C2H_MSG_V1_8822B 0x03E4
+#define REG_DBI_WDATA_V1_8822B 0x03E8
+#define REG_DBI_RDATA_V1_8822B 0x03EC
+#define REG_DBI_FLAG_V1_8822B 0x03F0
+#define REG_MDIO_V1_8822B 0x03F4
+#define REG_PCIE_MIX_CFG_8822B 0x03F8
+#define REG_HCI_MIX_CFG_8822B 0x03FC
+#define REG_STC_INT_CS_8822B 0x1300
+#define REG_ST_INT_CFG_8822B 0x1304
+#define REG_CMU_DLY_CTRL_8822B 0x1310
+#define REG_CMU_DLY_CFG_8822B 0x1314
+#define REG_H2CQ_TXBD_DESA_8822B 0x1320
+#define REG_H2CQ_TXBD_NUM_8822B 0x1328
+#define REG_H2CQ_TXBD_IDX_8822B 0x132C
+#define REG_H2CQ_CSR_8822B 0x1330
+#define REG_CHANGE_PCIE_SPEED_8822B 0x1350
+#define REG_OLD_DEHANG_8822B 0x13F4
+#define REG_Q0_INFO_8822B 0x0400
+#define REG_Q1_INFO_8822B 0x0404
+#define REG_Q2_INFO_8822B 0x0408
+#define REG_Q3_INFO_8822B 0x040C
+#define REG_MGQ_INFO_8822B 0x0410
+#define REG_HIQ_INFO_8822B 0x0414
+#define REG_BCNQ_INFO_8822B 0x0418
+#define REG_TXPKT_EMPTY_8822B 0x041A
+#define REG_CPU_MGQ_INFO_8822B 0x041C
+#define REG_FWHW_TXQ_CTRL_8822B 0x0420
+#define REG_DATAFB_SEL_8822B 0x0423
+#define REG_BCNQ_BDNY_V1_8822B 0x0424
+#define REG_LIFETIME_EN_8822B 0x0426
+#define REG_SPEC_SIFS_8822B 0x0428
+#define REG_RETRY_LIMIT_8822B 0x042A
+#define REG_TXBF_CTRL_8822B 0x042C
+#define REG_DARFRC_8822B 0x0430
+#define REG_RARFRC_8822B 0x0438
+#define REG_RRSR_8822B 0x0440
+#define REG_ARFR0_8822B 0x0444
+#define REG_ARFR1_V1_8822B 0x044C
+#define REG_CCK_CHECK_8822B 0x0454
+#define REG_AMPDU_MAX_TIME_V1_8822B 0x0455
+#define REG_BCNQ1_BDNY_V1_8822B 0x0456
+#define REG_AMPDU_MAX_LENGTH_8822B 0x0458
+#define REG_ACQ_STOP_8822B 0x045C
+#define REG_NDPA_RATE_8822B 0x045D
+#define REG_TX_HANG_CTRL_8822B 0x045E
+#define REG_NDPA_OPT_CTRL_8822B 0x045F
+#define REG_RD_RESP_PKT_TH_8822B 0x0463
+#define REG_CMDQ_INFO_8822B 0x0464
+#define REG_Q4_INFO_8822B 0x0468
+#define REG_Q5_INFO_8822B 0x046C
+#define REG_Q6_INFO_8822B 0x0470
+#define REG_Q7_INFO_8822B 0x0474
+#define REG_WMAC_LBK_BUF_HD_V1_8822B 0x0478
+#define REG_MGQ_BDNY_V1_8822B 0x047A
+#define REG_TXRPT_CTRL_8822B 0x047C
+#define REG_INIRTS_RATE_SEL_8822B 0x0480
+#define REG_BASIC_CFEND_RATE_8822B 0x0481
+#define REG_STBC_CFEND_RATE_8822B 0x0482
+#define REG_DATA_SC_8822B 0x0483
+#define REG_MACID_SLEEP3_8822B 0x0484
+#define REG_MACID_SLEEP1_8822B 0x0488
+#define REG_ARFR2_V1_8822B 0x048C
+#define REG_ARFR3_V1_8822B 0x0494
+#define REG_ARFR4_8822B 0x049C
+#define REG_ARFR5_8822B 0x04A4
+#define REG_TXRPT_START_OFFSET_8822B 0x04AC
+#define REG_POWER_STAGE1_8822B 0x04B4
+#define REG_POWER_STAGE2_8822B 0x04B8
+#define REG_SW_AMPDU_BURST_MODE_CTRL_8822B 0x04BC
+#define REG_PKT_LIFE_TIME_8822B 0x04C0
+#define REG_STBC_SETTING_8822B 0x04C4
+#define REG_STBC_SETTING2_8822B 0x04C5
+#define REG_QUEUE_CTRL_8822B 0x04C6
+#define REG_SINGLE_AMPDU_CTRL_8822B 0x04C7
+#define REG_PROT_MODE_CTRL_8822B 0x04C8
+#define REG_BAR_MODE_CTRL_8822B 0x04CC
+#define REG_RA_TRY_RATE_AGG_LMT_8822B 0x04CF
+#define REG_MACID_SLEEP2_8822B 0x04D0
+#define REG_MACID_SLEEP_8822B 0x04D4
+#define REG_HW_SEQ0_8822B 0x04D8
+#define REG_HW_SEQ1_8822B 0x04DA
+#define REG_HW_SEQ2_8822B 0x04DC
+#define REG_HW_SEQ3_8822B 0x04DE
+#define REG_NULL_PKT_STATUS_V1_8822B 0x04E0
+#define REG_PTCL_ERR_STATUS_8822B 0x04E2
+#define REG_NULL_PKT_STATUS_EXTEND_8822B 0x04E3
+#define REG_VIDEO_ENHANCEMENT_FUN_8822B 0x04E4
+#define REG_BT_POLLUTE_PKT_CNT_8822B 0x04E8
+#define REG_PTCL_DBG_8822B 0x04EC
+#define REG_CPUMGQ_TIMER_CTRL2_8822B 0x04F4
+#define REG_DUMMY_PAGE4_V1_8822B 0x04FC
+#define REG_MOREDATA_8822B 0x04FE
+#define REG_Q0_Q1_INFO_8822B 0x1400
+#define REG_Q2_Q3_INFO_8822B 0x1404
+#define REG_Q4_Q5_INFO_8822B 0x1408
+#define REG_Q6_Q7_INFO_8822B 0x140C
+#define REG_MGQ_HIQ_INFO_8822B 0x1410
+#define REG_CMDQ_BCNQ_INFO_8822B 0x1414
+#define REG_USEREG_SETTING_8822B 0x1420
+#define REG_AESIV_SETTING_8822B 0x1424
+#define REG_BF0_TIME_SETTING_8822B 0x1428
+#define REG_BF1_TIME_SETTING_8822B 0x142C
+#define REG_BF_TIMEOUT_EN_8822B 0x1430
+#define REG_MACID_RELEASE0_8822B 0x1434
+#define REG_MACID_RELEASE1_8822B 0x1438
+#define REG_MACID_RELEASE2_8822B 0x143C
+#define REG_MACID_RELEASE3_8822B 0x1440
+#define REG_MACID_RELEASE_SETTING_8822B 0x1444
+#define REG_FAST_EDCA_VOVI_SETTING_8822B 0x1448
+#define REG_FAST_EDCA_BEBK_SETTING_8822B 0x144C
+#define REG_MACID_DROP0_8822B 0x1450
+#define REG_MACID_DROP1_8822B 0x1454
+#define REG_MACID_DROP2_8822B 0x1458
+#define REG_MACID_DROP3_8822B 0x145C
+#define REG_R_MACID_RELEASE_SUCCESS_0_8822B 0x1460
+#define REG_R_MACID_RELEASE_SUCCESS_1_8822B 0x1464
+#define REG_R_MACID_RELEASE_SUCCESS_2_8822B 0x1468
+#define REG_R_MACID_RELEASE_SUCCESS_3_8822B 0x146C
+#define REG_MGG_FIFO_CRTL_8822B 0x1470
+#define REG_MGG_FIFO_INT_8822B 0x1474
+#define REG_MGG_FIFO_LIFETIME_8822B 0x1478
+#define REG_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET_8822B 0x147C
+#define REG_MACID_SHCUT_OFFSET_8822B 0x1480
+#define REG_MU_TX_CTL_8822B 0x14C0
+#define REG_MU_STA_GID_VLD_8822B 0x14C4
+#define REG_MU_STA_USER_POS_INFO_8822B 0x14C8
+#define REG_MU_TRX_DBG_CNT_8822B 0x14D0
+#define REG_EDCA_VO_PARAM_8822B 0x0500
+#define REG_EDCA_VI_PARAM_8822B 0x0504
+#define REG_EDCA_BE_PARAM_8822B 0x0508
+#define REG_EDCA_BK_PARAM_8822B 0x050C
+#define REG_BCNTCFG_8822B 0x0510
+#define REG_PIFS_8822B 0x0512
+#define REG_RDG_PIFS_8822B 0x0513
+#define REG_SIFS_8822B 0x0514
+#define REG_TSFTR_SYN_OFFSET_8822B 0x0518
+#define REG_AGGR_BREAK_TIME_8822B 0x051A
+#define REG_SLOT_8822B 0x051B
+#define REG_TX_PTCL_CTRL_8822B 0x0520
+#define REG_TXPAUSE_8822B 0x0522
+#define REG_DIS_TXREQ_CLR_8822B 0x0523
+#define REG_RD_CTRL_8822B 0x0524
+#define REG_MBSSID_CTRL_8822B 0x0526
+#define REG_P2PPS_CTRL_8822B 0x0527
+#define REG_PKT_LIFETIME_CTRL_8822B 0x0528
+#define REG_P2PPS_SPEC_STATE_8822B 0x052B
+#define REG_BAR_TX_CTRL_8822B 0x0530
+#define REG_QUEUE_INCOL_THR_8822B 0x0538
+#define REG_QUEUE_INCOL_EN_8822B 0x053C
+#define REG_TBTT_PROHIBIT_8822B 0x0540
+#define REG_P2PPS_STATE_8822B 0x0543
+#define REG_RD_NAV_NXT_8822B 0x0544
+#define REG_NAV_PROT_LEN_8822B 0x0546
+#define REG_BCN_CTRL_8822B 0x0550
+#define REG_BCN_CTRL_CLINT0_8822B 0x0551
+#define REG_MBID_NUM_8822B 0x0552
+#define REG_DUAL_TSF_RST_8822B 0x0553
+#define REG_MBSSID_BCN_SPACE_8822B 0x0554
+#define REG_DRVERLYINT_8822B 0x0558
+#define REG_BCNDMATIM_8822B 0x0559
+#define REG_ATIMWND_8822B 0x055A
+#define REG_USTIME_TSF_8822B 0x055C
+#define REG_BCN_MAX_ERR_8822B 0x055D
+#define REG_RXTSF_OFFSET_CCK_8822B 0x055E
+#define REG_RXTSF_OFFSET_OFDM_8822B 0x055F
+#define REG_TSFTR_8822B 0x0560
+#define REG_FREERUN_CNT_8822B 0x0568
+#define REG_ATIMWND1_V1_8822B 0x0570
+#define REG_TBTT_PROHIBIT_INFRA_8822B 0x0571
+#define REG_CTWND_8822B 0x0572
+#define REG_BCNIVLCUNT_8822B 0x0573
+#define REG_BCNDROPCTRL_8822B 0x0574
+#define REG_HGQ_TIMEOUT_PERIOD_8822B 0x0575
+#define REG_TXCMD_TIMEOUT_PERIOD_8822B 0x0576
+#define REG_MISC_CTRL_8822B 0x0577
+#define REG_BCN_CTRL_CLINT1_8822B 0x0578
+#define REG_BCN_CTRL_CLINT2_8822B 0x0579
+#define REG_BCN_CTRL_CLINT3_8822B 0x057A
+#define REG_EXTEND_CTRL_8822B 0x057B
+#define REG_P2PPS1_SPEC_STATE_8822B 0x057C
+#define REG_P2PPS1_STATE_8822B 0x057D
+#define REG_P2PPS2_SPEC_STATE_8822B 0x057E
+#define REG_P2PPS2_STATE_8822B 0x057F
+#define REG_PS_TIMER0_8822B 0x0580
+#define REG_PS_TIMER1_8822B 0x0584
+#define REG_PS_TIMER2_8822B 0x0588
+#define REG_TBTT_CTN_AREA_8822B 0x058C
+#define REG_FORCE_BCN_IFS_8822B 0x058E
+#define REG_TXOP_MIN_8822B 0x0590
+#define REG_PRE_BKF_TIME_8822B 0x0592
+#define REG_CROSS_TXOP_CTRL_8822B 0x0593
+#define REG_ATIMWND2_8822B 0x05A0
+#define REG_ATIMWND3_8822B 0x05A1
+#define REG_ATIMWND4_8822B 0x05A2
+#define REG_ATIMWND5_8822B 0x05A3
+#define REG_ATIMWND6_8822B 0x05A4
+#define REG_ATIMWND7_8822B 0x05A5
+#define REG_ATIMUGT_8822B 0x05A6
+#define REG_HIQ_NO_LMT_EN_8822B 0x05A7
+#define REG_DTIM_COUNTER_ROOT_8822B 0x05A8
+#define REG_DTIM_COUNTER_VAP1_8822B 0x05A9
+#define REG_DTIM_COUNTER_VAP2_8822B 0x05AA
+#define REG_DTIM_COUNTER_VAP3_8822B 0x05AB
+#define REG_DTIM_COUNTER_VAP4_8822B 0x05AC
+#define REG_DTIM_COUNTER_VAP5_8822B 0x05AD
+#define REG_DTIM_COUNTER_VAP6_8822B 0x05AE
+#define REG_DTIM_COUNTER_VAP7_8822B 0x05AF
+#define REG_DIS_ATIM_8822B 0x05B0
+#define REG_EARLY_128US_8822B 0x05B1
+#define REG_P2PPS1_CTRL_8822B 0x05B2
+#define REG_P2PPS2_CTRL_8822B 0x05B3
+#define REG_TIMER0_SRC_SEL_8822B 0x05B4
+#define REG_NOA_UNIT_SEL_8822B 0x05B5
+#define REG_P2POFF_DIS_TXTIME_8822B 0x05B7
+#define REG_MBSSID_BCN_SPACE2_8822B 0x05B8
+#define REG_MBSSID_BCN_SPACE3_8822B 0x05BC
+#define REG_ACMHWCTRL_8822B 0x05C0
+#define REG_ACMRSTCTRL_8822B 0x05C1
+#define REG_ACMAVG_8822B 0x05C2
+#define REG_VO_ADMTIME_8822B 0x05C4
+#define REG_VI_ADMTIME_8822B 0x05C6
+#define REG_BE_ADMTIME_8822B 0x05C8
+#define REG_EDCA_RANDOM_GEN_8822B 0x05CC
+#define REG_TXCMD_NOA_SEL_8822B 0x05CF
+#define REG_NOA_PARAM_8822B 0x05E0
+#define REG_P2P_RST_8822B 0x05F0
+#define REG_SCHEDULER_RST_8822B 0x05F1
+#define REG_SCH_TXCMD_8822B 0x05F8
+#define REG_PAGE5_DUMMY_8822B 0x05FC
+#define REG_CPUMGQ_TX_TIMER_8822B 0x1500
+#define REG_PS_TIMER_A_8822B 0x1504
+#define REG_PS_TIMER_B_8822B 0x1508
+#define REG_PS_TIMER_C_8822B 0x150C
+#define REG_PS_TIMER_ABC_CPUMGQ_TIMER_CRTL_8822B 0x1510
+#define REG_CPUMGQ_TX_TIMER_EARLY_8822B 0x1514
+#define REG_PS_TIMER_A_EARLY_8822B 0x1515
+#define REG_PS_TIMER_B_EARLY_8822B 0x1516
+#define REG_PS_TIMER_C_EARLY_8822B 0x1517
+#define REG_WMAC_CR_8822B 0x0600
+#define REG_WMAC_FWPKT_CR_8822B 0x0601
+#define REG_BWOPMODE_8822B 0x0603
+#define REG_TCR_8822B 0x0604
+#define REG_RCR_8822B 0x0608
+#define REG_RX_PKT_LIMIT_8822B 0x060C
+#define REG_RX_DLK_TIME_8822B 0x060D
+#define REG_RX_DRVINFO_SZ_8822B 0x060F
+#define REG_MACID_8822B 0x0610
+#define REG_BSSID_8822B 0x0618
+#define REG_MAR_8822B 0x0620
+#define REG_MBIDCAMCFG_1_8822B 0x0628
+#define REG_MBIDCAMCFG_2_8822B 0x062C
+#define REG_WMAC_TCR_TSFT_OFS_8822B 0x0630
+#define REG_UDF_THSD_8822B 0x0632
+#define REG_ZLD_NUM_8822B 0x0633
+#define REG_STMP_THSD_8822B 0x0634
+#define REG_WMAC_TXTIMEOUT_8822B 0x0635
+#define REG_MCU_TEST_2_V1_8822B 0x0636
+#define REG_USTIME_EDCA_8822B 0x0638
+#define REG_MAC_SPEC_SIFS_8822B 0x063A
+#define REG_RESP_SIFS_CCK_8822B 0x063C
+#define REG_RESP_SIFS_OFDM_8822B 0x063E
+#define REG_ACKTO_8822B 0x0640
+#define REG_CTS2TO_8822B 0x0641
+#define REG_EIFS_8822B 0x0642
+#define REG_NAV_CTRL_8822B 0x0650
+#define REG_BACAMCMD_8822B 0x0654
+#define REG_BACAMCONTENT_8822B 0x0658
+#define REG_LBDLY_8822B 0x0660
+#define REG_WMAC_BACAM_RPMEN_8822B 0x0661
+#define REG_TX_RX_8822B 0x0662
+#define REG_WMAC_BITMAP_CTL_8822B 0x0663
+#define REG_RXERR_RPT_8822B 0x0664
+#define REG_WMAC_TRXPTCL_CTL_8822B 0x0668
+#define REG_CAMCMD_8822B 0x0670
+#define REG_CAMWRITE_8822B 0x0674
+#define REG_CAMREAD_8822B 0x0678
+#define REG_CAMDBG_8822B 0x067C
+#define REG_SECCFG_8822B 0x0680
+#define REG_RXFILTER_CATEGORY_1_8822B 0x0682
+#define REG_RXFILTER_ACTION_1_8822B 0x0683
+#define REG_RXFILTER_CATEGORY_2_8822B 0x0684
+#define REG_RXFILTER_ACTION_2_8822B 0x0685
+#define REG_RXFILTER_CATEGORY_3_8822B 0x0686
+#define REG_RXFILTER_ACTION_3_8822B 0x0687
+#define REG_RXFLTMAP3_8822B 0x0688
+#define REG_RXFLTMAP4_8822B 0x068A
+#define REG_RXFLTMAP5_8822B 0x068C
+#define REG_RXFLTMAP6_8822B 0x068E
+#define REG_WOW_CTRL_8822B 0x0690
+#define REG_NAN_RX_TSF_FILTER_8822B 0x0691
+#define REG_PS_RX_INFO_8822B 0x0692
+#define REG_WMMPS_UAPSD_TID_8822B 0x0693
+#define REG_LPNAV_CTRL_8822B 0x0694
+#define REG_WKFMCAM_CMD_8822B 0x0698
+#define REG_WKFMCAM_RWD_8822B 0x069C
+#define REG_RXFLTMAP0_8822B 0x06A0
+#define REG_RXFLTMAP1_8822B 0x06A2
+#define REG_RXFLTMAP_8822B 0x06A4
+#define REG_BCN_PSR_RPT_8822B 0x06A8
+#define REG_FLC_RPC_8822B 0x06AC
+#define REG_FLC_RPCT_8822B 0x06AD
+#define REG_FLC_PTS_8822B 0x06AE
+#define REG_FLC_TRPC_8822B 0x06AF
+#define REG_RXPKTMON_CTRL_8822B 0x06B0
+#define REG_STATE_MON_8822B 0x06B4
+#define REG_ERROR_MON_8822B 0x06B8
+#define REG_SEARCH_MACID_8822B 0x06BC
+#define REG_BT_COEX_TABLE_8822B 0x06C0
+#define REG_RXCMD_0_8822B 0x06D0
+#define REG_RXCMD_1_8822B 0x06D4
+#define REG_WMAC_RESP_TXINFO_8822B 0x06D8
+#define REG_BBPSF_CTRL_8822B 0x06DC
+#define REG_P2P_RX_BCN_NOA_8822B 0x06E0
+#define REG_ASSOCIATED_BFMER0_INFO_8822B 0x06E4
+#define REG_ASSOCIATED_BFMER1_INFO_8822B 0x06EC
+#define REG_TX_CSI_RPT_PARAM_BW20_8822B 0x06F4
+#define REG_TX_CSI_RPT_PARAM_BW40_8822B 0x06F8
+#define REG_TX_CSI_RPT_PARAM_BW80_8822B 0x06FC
+#define REG_BCN_PSR_RPT2_8822B 0x1600
+#define REG_BCN_PSR_RPT3_8822B 0x1604
+#define REG_BCN_PSR_RPT4_8822B 0x1608
+#define REG_A1_ADDR_MASK_8822B 0x160C
+#define REG_MACID2_8822B 0x1620
+#define REG_BSSID2_8822B 0x1628
+#define REG_MACID3_8822B 0x1630
+#define REG_BSSID3_8822B 0x1638
+#define REG_MACID4_8822B 0x1640
+#define REG_BSSID4_8822B 0x1648
+#define REG_NOA_REPORT_8822B 0x1650
+#define REG_PWRBIT_SETTING_8822B 0x1660
+#define REG_WMAC_MU_BF_OPTION_8822B 0x167C
+#define REG_WMAC_MU_ARB_8822B 0x167E
+#define REG_WMAC_MU_OPTION_8822B 0x167F
+#define REG_WMAC_MU_BF_CTL_8822B 0x1680
+#define REG_WMAC_MU_BFRPT_PARA_8822B 0x1682
+#define REG_WMAC_ASSOCIATED_MU_BFMEE2_8822B 0x1684
+#define REG_WMAC_ASSOCIATED_MU_BFMEE3_8822B 0x1686
+#define REG_WMAC_ASSOCIATED_MU_BFMEE4_8822B 0x1688
+#define REG_WMAC_ASSOCIATED_MU_BFMEE5_8822B 0x168A
+#define REG_WMAC_ASSOCIATED_MU_BFMEE6_8822B 0x168C
+#define REG_WMAC_ASSOCIATED_MU_BFMEE7_8822B 0x168E
+#define REG_TRANSMIT_ADDRSS_0_8822B 0x16A0
+#define REG_TRANSMIT_ADDRSS_1_8822B 0x16A8
+#define REG_TRANSMIT_ADDRSS_2_8822B 0x16B0
+#define REG_TRANSMIT_ADDRSS_3_8822B 0x16B8
+#define REG_TRANSMIT_ADDRSS_4_8822B 0x16C0
+#define REG_MACID1_8822B 0x0700
+#define REG_BSSID1_8822B 0x0708
+#define REG_BCN_PSR_RPT1_8822B 0x0710
+#define REG_ASSOCIATED_BFMEE_SEL_8822B 0x0714
+#define REG_SND_PTCL_CTRL_8822B 0x0718
+#define REG_RX_CSI_RPT_INFO_8822B 0x071C
+#define REG_NS_ARP_CTRL_8822B 0x0720
+#define REG_NS_ARP_INFO_8822B 0x0724
+#define REG_BEAMFORMING_INFO_NSARP_V1_8822B 0x0728
+#define REG_BEAMFORMING_INFO_NSARP_8822B 0x072C
+#define REG_WMAC_RTX_CTX_SUBTYPE_CFG_8822B 0x0750
+#define REG_WMAC_SWAES_CFG_8822B 0x0760
+#define REG_BT_COEX_V2_8822B 0x0762
+#define REG_BT_COEX_8822B 0x0764
+#define REG_WLAN_ACT_MASK_CTRL_8822B 0x0768
+#define REG_BT_COEX_ENHANCED_INTR_CTRL_8822B 0x076E
+#define REG_BT_ACT_STATISTICS_8822B 0x0770
+#define REG_BT_STATISTICS_CONTROL_REGISTER_8822B 0x0778
+#define REG_BT_STATUS_REPORT_REGISTER_8822B 0x077C
+#define REG_BT_INTERRUPT_CONTROL_REGISTER_8822B 0x0780
+#define REG_WLAN_REPORT_TIME_OUT_CONTROL_REGISTER_8822B 0x0784
+#define REG_BT_ISOLATION_TABLE_REGISTER_REGISTER_8822B 0x0785
+#define REG_BT_INTERRUPT_STATUS_REGISTER_8822B 0x078F
+#define REG_BT_TDMA_TIME_REGISTER_8822B 0x0790
+#define REG_BT_ACT_REGISTER_8822B 0x0794
+#define REG_OBFF_CTRL_BASIC_8822B 0x0798
+#define REG_OBFF_CTRL2_TIMER_8822B 0x079C
+#define REG_LTR_CTRL_BASIC_8822B 0x07A0
+#define REG_LTR_CTRL2_TIMER_THRESHOLD_8822B 0x07A4
+#define REG_LTR_IDLE_LATENCY_V1_8822B 0x07A8
+#define REG_LTR_ACTIVE_LATENCY_V1_8822B 0x07AC
+#define REG_ANTENNA_TRAINING_CONTROL_REGISTER_8822B 0x07B0
+#define REG_WMAC_PKTCNT_RWD_8822B 0x07B8
+#define REG_WMAC_PKTCNT_CTRL_8822B 0x07BC
+#define REG_IQ_DUMP_8822B 0x07C0
+#define REG_WMAC_FTM_CTL_8822B 0x07CC
+#define REG_WMAC_IQ_MDPK_FUNC_8822B 0x07CE
+#define REG_WMAC_OPTION_FUNCTION_8822B 0x07D0
+#define REG_RX_FILTER_FUNCTION_8822B 0x07DA
+#define REG_NDP_SIG_8822B 0x07E0
+#define REG_TXCMD_INFO_FOR_RSP_PKT_8822B 0x07E4
+#define REG_RTS_ADDRESS_0_8822B 0x07F0
+#define REG_RTS_ADDRESS_1_8822B 0x07F8
+#define REG__RPFM_MAP1_8822B 0x07FE
+#define REG_WL2LTECOEX_INDIRECT_ACCESS_CTRL_V1_8822B 0x1700
+#define REG_WL2LTECOEX_INDIRECT_ACCESS_WRITE_DATA_V1_8822B 0x1704
+#define REG_WL2LTECOEX_INDIRECT_ACCESS_READ_DATA_V1_8822B 0x1708
+#define REG_SDIO_TX_CTRL_8822B 0x10250000
+#define REG_SDIO_HIMR_8822B 0x10250014
+#define REG_SDIO_HISR_8822B 0x10250018
+#define REG_SDIO_RX_REQ_LEN_8822B 0x1025001C
+#define REG_SDIO_FREE_TXPG_SEQ_V1_8822B 0x1025001F
+#define REG_SDIO_FREE_TXPG_8822B 0x10250020
+#define REG_SDIO_FREE_TXPG2_8822B 0x10250024
+#define REG_SDIO_OQT_FREE_TXPG_V1_8822B 0x10250028
+#define REG_SDIO_HTSFR_INFO_8822B 0x10250030
+#define REG_SDIO_HCPWM1_V2_8822B 0x10250038
+#define REG_SDIO_HCPWM2_V2_8822B 0x1025003A
+#define REG_SDIO_INDIRECT_REG_CFG_8822B 0x10250040
+#define REG_SDIO_INDIRECT_REG_DATA_8822B 0x10250044
+#define REG_SDIO_H2C_8822B 0x10250060
+#define REG_SDIO_C2H_8822B 0x10250064
+#define REG_SDIO_HRPWM1_8822B 0x10250080
+#define REG_SDIO_HRPWM2_8822B 0x10250082
+#define REG_SDIO_HPS_CLKR_8822B 0x10250084
+#define REG_SDIO_BUS_CTRL_8822B 0x10250085
+#define REG_SDIO_HSUS_CTRL_8822B 0x10250086
+#define REG_SDIO_RESPONSE_TIMER_8822B 0x10250088
+#define REG_SDIO_CMD_CRC_8822B 0x1025008A
+#define REG_SDIO_HSISR_8822B 0x10250090
+#define REG_SDIO_HSIMR_8822B 0x10250091
+#define REG_SDIO_ERR_RPT_8822B 0x102500C0
+#define REG_SDIO_CMD_ERRCNT_8822B 0x102500C1
+#define REG_SDIO_DATA_ERRCNT_8822B 0x102500C2
+#define REG_SDIO_CMD_ERR_CONTENT_8822B 0x102500C4
+#define REG_SDIO_CRC_ERR_IDX_8822B 0x102500C9
+#define REG_SDIO_DATA_CRC_8822B 0x102500CA
+#define REG_SDIO_DATA_REPLY_TIME_8822B 0x102500CB
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_rx_bd_chip.h b/drivers/staging/rtlwifi/halmac/halmac_rx_bd_chip.h
new file mode 100644
index 000000000000..59ff1fecf73f
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_rx_bd_chip.h
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_RX_BD_CHIP_H_
+#define _HALMAC_RX_BD_CHIP_H_
+
+/*TXBD_DW0*/
+
+#define GET_RX_BD_RXFAIL_8822B(__rx_bd) GET_RX_BD_RXFAIL(__rx_bd)
+#define GET_RX_BD_TOTALRXPKTSIZE_8822B(__rx_bd)                                \
+	GET_RX_BD_TOTALRXPKTSIZE(__rx_bd)
+#define GET_RX_BD_RXTAG_8822B(__rx_bd) GET_RX_BD_RXTAG(__rx_bd)
+#define GET_RX_BD_FS_8822B(__rx_bd) GET_RX_BD_FS(__rx_bd)
+#define GET_RX_BD_LS_8822B(__rx_bd) GET_RX_BD_LS(__rx_bd)
+#define GET_RX_BD_RXBUFFSIZE_8822B(__rx_bd) GET_RX_BD_RXBUFFSIZE(__rx_bd)
+
+/*TXBD_DW1*/
+
+#define GET_RX_BD_PHYSICAL_ADDR_LOW_8822B(__rx_bd)                             \
+	GET_RX_BD_PHYSICAL_ADDR_LOW(__rx_bd)
+
+/*TXBD_DW2*/
+
+#define GET_RX_BD_PHYSICAL_ADDR_HIGH_8822B(__rx_bd)                            \
+	GET_RX_BD_PHYSICAL_ADDR_HIGH(__rx_bd)
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_rx_bd_nic.h b/drivers/staging/rtlwifi/halmac/halmac_rx_bd_nic.h
new file mode 100644
index 000000000000..62817d808fbb
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_rx_bd_nic.h
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_RX_BD_NIC_H_
+#define _HALMAC_RX_BD_NIC_H_
+
+/*TXBD_DW0*/
+
+#define GET_RX_BD_RXFAIL(__rx_bd) LE_BITS_TO_4BYTE(__rx_bd + 0x00, 31, 1)
+#define GET_RX_BD_TOTALRXPKTSIZE(__rx_bd)                                      \
+	LE_BITS_TO_4BYTE(__rx_bd + 0x00, 16, 13)
+#define GET_RX_BD_RXTAG(__rx_bd) LE_BITS_TO_4BYTE(__rx_bd + 0x00, 16, 13)
+#define GET_RX_BD_FS(__rx_bd) LE_BITS_TO_4BYTE(__rx_bd + 0x00, 15, 1)
+#define GET_RX_BD_LS(__rx_bd) LE_BITS_TO_4BYTE(__rx_bd + 0x00, 14, 1)
+#define GET_RX_BD_RXBUFFSIZE(__rx_bd) LE_BITS_TO_4BYTE(__rx_bd + 0x00, 0, 14)
+
+/*TXBD_DW1*/
+
+#define GET_RX_BD_PHYSICAL_ADDR_LOW(__rx_bd)                                   \
+	LE_BITS_TO_4BYTE(__rx_bd + 0x04, 0, 32)
+
+/*TXBD_DW2*/
+
+#define GET_RX_BD_PHYSICAL_ADDR_HIGH(__rx_bd)                                  \
+	LE_BITS_TO_4BYTE(__rx_bd + 0x08, 0, 32)
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_rx_desc_chip.h b/drivers/staging/rtlwifi/halmac/halmac_rx_desc_chip.h
new file mode 100644
index 000000000000..442120a14839
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_rx_desc_chip.h
@@ -0,0 +1,118 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_RX_DESC_CHIP_H_
+#define _HALMAC_RX_DESC_CHIP_H_
+
+/*RXDESC_WORD0*/
+
+#define GET_RX_DESC_EOR_8822B(__rx_desc) GET_RX_DESC_EOR(__rx_desc)
+#define GET_RX_DESC_PHYPKTIDC_8822B(__rx_desc) GET_RX_DESC_PHYPKTIDC(__rx_desc)
+#define GET_RX_DESC_SWDEC_8822B(__rx_desc) GET_RX_DESC_SWDEC(__rx_desc)
+#define GET_RX_DESC_PHYST_8822B(__rx_desc) GET_RX_DESC_PHYST(__rx_desc)
+#define GET_RX_DESC_SHIFT_8822B(__rx_desc) GET_RX_DESC_SHIFT(__rx_desc)
+#define GET_RX_DESC_QOS_8822B(__rx_desc) GET_RX_DESC_QOS(__rx_desc)
+#define GET_RX_DESC_SECURITY_8822B(__rx_desc) GET_RX_DESC_SECURITY(__rx_desc)
+#define GET_RX_DESC_DRV_INFO_SIZE_8822B(__rx_desc)                             \
+	GET_RX_DESC_DRV_INFO_SIZE(__rx_desc)
+#define GET_RX_DESC_ICV_ERR_8822B(__rx_desc) GET_RX_DESC_ICV_ERR(__rx_desc)
+#define GET_RX_DESC_CRC32_8822B(__rx_desc) GET_RX_DESC_CRC32(__rx_desc)
+#define GET_RX_DESC_PKT_LEN_8822B(__rx_desc) GET_RX_DESC_PKT_LEN(__rx_desc)
+
+/*RXDESC_WORD1*/
+
+#define GET_RX_DESC_BC_8822B(__rx_desc) GET_RX_DESC_BC(__rx_desc)
+#define GET_RX_DESC_MC_8822B(__rx_desc) GET_RX_DESC_MC(__rx_desc)
+#define GET_RX_DESC_TY_PE_8822B(__rx_desc) GET_RX_DESC_TY_PE(__rx_desc)
+#define GET_RX_DESC_MF_8822B(__rx_desc) GET_RX_DESC_MF(__rx_desc)
+#define GET_RX_DESC_MD_8822B(__rx_desc) GET_RX_DESC_MD(__rx_desc)
+#define GET_RX_DESC_PWR_8822B(__rx_desc) GET_RX_DESC_PWR(__rx_desc)
+#define GET_RX_DESC_PAM_8822B(__rx_desc) GET_RX_DESC_PAM(__rx_desc)
+#define GET_RX_DESC_CHK_VLD_8822B(__rx_desc) GET_RX_DESC_CHK_VLD(__rx_desc)
+#define GET_RX_DESC_RX_IS_TCP_UDP_8822B(__rx_desc)                             \
+	GET_RX_DESC_RX_IS_TCP_UDP(__rx_desc)
+#define GET_RX_DESC_RX_IPV_8822B(__rx_desc) GET_RX_DESC_RX_IPV(__rx_desc)
+#define GET_RX_DESC_CHKERR_8822B(__rx_desc) GET_RX_DESC_CHKERR(__rx_desc)
+#define GET_RX_DESC_PAGGR_8822B(__rx_desc) GET_RX_DESC_PAGGR(__rx_desc)
+#define GET_RX_DESC_RXID_MATCH_8822B(__rx_desc)                                \
+	GET_RX_DESC_RXID_MATCH(__rx_desc)
+#define GET_RX_DESC_AMSDU_8822B(__rx_desc) GET_RX_DESC_AMSDU(__rx_desc)
+#define GET_RX_DESC_MACID_VLD_8822B(__rx_desc) GET_RX_DESC_MACID_VLD(__rx_desc)
+#define GET_RX_DESC_TID_8822B(__rx_desc) GET_RX_DESC_TID(__rx_desc)
+#define GET_RX_DESC_EXT_SECTYPE_8822B(__rx_desc)                               \
+	GET_RX_DESC_EXT_SECTYPE(__rx_desc)
+#define GET_RX_DESC_MACID_8822B(__rx_desc) GET_RX_DESC_MACID(__rx_desc)
+
+/*RXDESC_WORD2*/
+
+#define GET_RX_DESC_FCS_OK_8822B(__rx_desc) GET_RX_DESC_FCS_OK(__rx_desc)
+#define GET_RX_DESC_PPDU_CNT_8822B(__rx_desc) GET_RX_DESC_PPDU_CNT(__rx_desc)
+#define GET_RX_DESC_C2H_8822B(__rx_desc) GET_RX_DESC_C2H(__rx_desc)
+#define GET_RX_DESC_HWRSVD_8822B(__rx_desc) GET_RX_DESC_HWRSVD(__rx_desc)
+#define GET_RX_DESC_WLANHD_IV_LEN_8822B(__rx_desc)                             \
+	GET_RX_DESC_WLANHD_IV_LEN(__rx_desc)
+#define GET_RX_DESC_RX_IS_QOS_8822B(__rx_desc) GET_RX_DESC_RX_IS_QOS(__rx_desc)
+#define GET_RX_DESC_FRAG_8822B(__rx_desc) GET_RX_DESC_FRAG(__rx_desc)
+#define GET_RX_DESC_SEQ_8822B(__rx_desc) GET_RX_DESC_SEQ(__rx_desc)
+
+/*RXDESC_WORD3*/
+
+#define GET_RX_DESC_MAGIC_WAKE_8822B(__rx_desc)                                \
+	GET_RX_DESC_MAGIC_WAKE(__rx_desc)
+#define GET_RX_DESC_UNICAST_WAKE_8822B(__rx_desc)                              \
+	GET_RX_DESC_UNICAST_WAKE(__rx_desc)
+#define GET_RX_DESC_PATTERN_MATCH_8822B(__rx_desc)                             \
+	GET_RX_DESC_PATTERN_MATCH(__rx_desc)
+#define GET_RX_DESC_RXPAYLOAD_MATCH_8822B(__rx_desc)                           \
+	GET_RX_DESC_RXPAYLOAD_MATCH(__rx_desc)
+#define GET_RX_DESC_RXPAYLOAD_ID_8822B(__rx_desc)                              \
+	GET_RX_DESC_RXPAYLOAD_ID(__rx_desc)
+#define GET_RX_DESC_DMA_AGG_NUM_8822B(__rx_desc)                               \
+	GET_RX_DESC_DMA_AGG_NUM(__rx_desc)
+#define GET_RX_DESC_BSSID_FIT_1_0_8822B(__rx_desc)                             \
+	GET_RX_DESC_BSSID_FIT_1_0(__rx_desc)
+#define GET_RX_DESC_EOSP_8822B(__rx_desc) GET_RX_DESC_EOSP(__rx_desc)
+#define GET_RX_DESC_HTC_8822B(__rx_desc) GET_RX_DESC_HTC(__rx_desc)
+#define GET_RX_DESC_BSSID_FIT_4_2_8822B(__rx_desc)                             \
+	GET_RX_DESC_BSSID_FIT_4_2(__rx_desc)
+#define GET_RX_DESC_RX_RATE_8822B(__rx_desc) GET_RX_DESC_RX_RATE(__rx_desc)
+
+/*RXDESC_WORD4*/
+
+#define GET_RX_DESC_A1_FIT_8822B(__rx_desc) GET_RX_DESC_A1_FIT(__rx_desc)
+#define GET_RX_DESC_MACID_RPT_BUFF_8822B(__rx_desc)                            \
+	GET_RX_DESC_MACID_RPT_BUFF(__rx_desc)
+#define GET_RX_DESC_RX_PRE_NDP_VLD_8822B(__rx_desc)                            \
+	GET_RX_DESC_RX_PRE_NDP_VLD(__rx_desc)
+#define GET_RX_DESC_RX_SCRAMBLER_8822B(__rx_desc)                              \
+	GET_RX_DESC_RX_SCRAMBLER(__rx_desc)
+#define GET_RX_DESC_RX_EOF_8822B(__rx_desc) GET_RX_DESC_RX_EOF(__rx_desc)
+#define GET_RX_DESC_PATTERN_IDX_8822B(__rx_desc)                               \
+	GET_RX_DESC_PATTERN_IDX(__rx_desc)
+
+/*RXDESC_WORD5*/
+
+#define GET_RX_DESC_TSFL_8822B(__rx_desc) GET_RX_DESC_TSFL(__rx_desc)
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_rx_desc_nic.h b/drivers/staging/rtlwifi/halmac/halmac_rx_desc_nic.h
new file mode 100644
index 000000000000..8256c3605072
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_rx_desc_nic.h
@@ -0,0 +1,133 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_RX_DESC_NIC_H_
+#define _HALMAC_RX_DESC_NIC_H_
+
+/*RXDESC_WORD0*/
+
+#define GET_RX_DESC_EOR(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x00, 30, 1)
+#define GET_RX_DESC_PHYPKTIDC(__rx_desc)                                       \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x00, 28, 1)
+#define GET_RX_DESC_SWDEC(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x00, 27, 1)
+#define GET_RX_DESC_PHYST(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x00, 26, 1)
+#define GET_RX_DESC_SHIFT(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x00, 24, 2)
+#define GET_RX_DESC_QOS(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x00, 23, 1)
+#define GET_RX_DESC_SECURITY(__rx_desc)                                        \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x00, 20, 3)
+#define GET_RX_DESC_DRV_INFO_SIZE(__rx_desc)                                   \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x00, 16, 4)
+#define GET_RX_DESC_ICV_ERR(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x00, 15, 1)
+#define GET_RX_DESC_CRC32(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x00, 14, 1)
+#define GET_RX_DESC_PKT_LEN(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x00, 0, 14)
+
+/*RXDESC_WORD1*/
+
+#define GET_RX_DESC_BC(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x04, 31, 1)
+#define GET_RX_DESC_MC(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x04, 30, 1)
+#define GET_RX_DESC_TY_PE(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x04, 28, 2)
+#define GET_RX_DESC_MF(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x04, 27, 1)
+#define GET_RX_DESC_MD(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x04, 26, 1)
+#define GET_RX_DESC_PWR(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x04, 25, 1)
+#define GET_RX_DESC_PAM(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x04, 24, 1)
+#define GET_RX_DESC_CHK_VLD(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x04, 23, 1)
+#define GET_RX_DESC_RX_IS_TCP_UDP(__rx_desc)                                   \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x04, 22, 1)
+#define GET_RX_DESC_RX_IPV(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x04, 21, 1)
+#define GET_RX_DESC_CHKERR(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x04, 20, 1)
+#define GET_RX_DESC_PAGGR(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x04, 15, 1)
+#define GET_RX_DESC_RXID_MATCH(__rx_desc)                                      \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x04, 14, 1)
+#define GET_RX_DESC_AMSDU(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x04, 13, 1)
+#define GET_RX_DESC_MACID_VLD(__rx_desc)                                       \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x04, 12, 1)
+#define GET_RX_DESC_TID(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x04, 8, 4)
+
+#define GET_RX_DESC_EXT_SECTYPE(__rx_desc)                                     \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x04, 7, 1)
+
+#define GET_RX_DESC_MACID(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x04, 0, 7)
+
+/*RXDESC_WORD2*/
+
+#define GET_RX_DESC_FCS_OK(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x08, 31, 1)
+
+#define GET_RX_DESC_PPDU_CNT(__rx_desc)                                        \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x08, 29, 2)
+
+#define GET_RX_DESC_C2H(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x08, 28, 1)
+#define GET_RX_DESC_HWRSVD(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x08, 24, 4)
+#define GET_RX_DESC_WLANHD_IV_LEN(__rx_desc)                                   \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x08, 18, 6)
+#define GET_RX_DESC_RX_IS_QOS(__rx_desc)                                       \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x08, 16, 1)
+#define GET_RX_DESC_FRAG(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x08, 12, 4)
+#define GET_RX_DESC_SEQ(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x08, 0, 12)
+
+/*RXDESC_WORD3*/
+
+#define GET_RX_DESC_MAGIC_WAKE(__rx_desc)                                      \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x0C, 31, 1)
+#define GET_RX_DESC_UNICAST_WAKE(__rx_desc)                                    \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x0C, 30, 1)
+#define GET_RX_DESC_PATTERN_MATCH(__rx_desc)                                   \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x0C, 29, 1)
+
+#define GET_RX_DESC_RXPAYLOAD_MATCH(__rx_desc)                                 \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x0C, 28, 1)
+#define GET_RX_DESC_RXPAYLOAD_ID(__rx_desc)                                    \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x0C, 24, 4)
+
+#define GET_RX_DESC_DMA_AGG_NUM(__rx_desc)                                     \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x0C, 16, 8)
+#define GET_RX_DESC_BSSID_FIT_1_0(__rx_desc)                                   \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x0C, 12, 2)
+#define GET_RX_DESC_EOSP(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x0C, 11, 1)
+#define GET_RX_DESC_HTC(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x0C, 10, 1)
+
+#define GET_RX_DESC_BSSID_FIT_4_2(__rx_desc)                                   \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x0C, 7, 3)
+
+#define GET_RX_DESC_RX_RATE(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x0C, 0, 7)
+
+/*RXDESC_WORD4*/
+
+#define GET_RX_DESC_A1_FIT(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x10, 24, 5)
+
+#define GET_RX_DESC_MACID_RPT_BUFF(__rx_desc)                                  \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x10, 17, 7)
+#define GET_RX_DESC_RX_PRE_NDP_VLD(__rx_desc)                                  \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x10, 16, 1)
+#define GET_RX_DESC_RX_SCRAMBLER(__rx_desc)                                    \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x10, 9, 7)
+#define GET_RX_DESC_RX_EOF(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x10, 8, 1)
+
+#define GET_RX_DESC_PATTERN_IDX(__rx_desc)                                     \
+	LE_BITS_TO_4BYTE(__rx_desc + 0x10, 0, 8)
+
+/*RXDESC_WORD5*/
+
+#define GET_RX_DESC_TSFL(__rx_desc) LE_BITS_TO_4BYTE(__rx_desc + 0x14, 0, 32)
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_sdio_reg.h b/drivers/staging/rtlwifi/halmac/halmac_sdio_reg.h
new file mode 100644
index 000000000000..8967699e3784
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_sdio_reg.h
@@ -0,0 +1,62 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __HALMAC_SDIO_REG_H__
+#define __HALMAC_SDIO_REG_H__
+
+/* SDIO CMD address mapping */
+
+#define HALMAC_SDIO_4BYTE_LEN_MASK 0x1FFF
+#define HALMAC_SDIO_LOCAL_MSK 0x0FFF
+#define HALMAC_WLAN_MAC_REG_MSK 0xFFFF
+#define HALMAC_WLAN_IOREG_MSK 0xFFFF
+
+/* Sdio address for SDIO Local Reg, TRX FIFO, MAC Reg */
+enum halmac_sdio_cmd_addr {
+	HALMAC_SDIO_CMD_ADDR_SDIO_REG = 0,
+	HALMAC_SDIO_CMD_ADDR_MAC_REG = 8,
+	HALMAC_SDIO_CMD_ADDR_TXFF_HIGH = 4,
+	HALMAC_SDIO_CMD_ADDR_TXFF_LOW = 6,
+	HALMAC_SDIO_CMD_ADDR_TXFF_NORMAL = 5,
+	HALMAC_SDIO_CMD_ADDR_TXFF_EXTRA = 7,
+	HALMAC_SDIO_CMD_ADDR_RXFF = 7,
+};
+
+/* IO Bus domain address mapping */
+#define SDIO_LOCAL_OFFSET 0x10250000
+#define WLAN_IOREG_OFFSET 0x10260000
+#define FW_FIFO_OFFSET 0x10270000
+#define TX_HIQ_OFFSET 0x10310000
+#define TX_MIQ_OFFSET 0x10320000
+#define TX_LOQ_OFFSET 0x10330000
+#define TX_EXQ_OFFSET 0x10350000
+#define RX_RXOFF_OFFSET 0x10340000
+
+/* Get TX WLAN FIFO information in CMD53 addr  */
+#define GET_WLAN_TXFF_DEVICE_ID(__cmd53_addr)                                  \
+	LE_BITS_TO_4BYTE((u32 *)__cmd53_addr, 13, 4)
+#define GET_WLAN_TXFF_PKT_SIZE(__cmd53_addr)                                   \
+	(LE_BITS_TO_4BYTE((u32 *)__cmd53_addr, 0, 13) << 2)
+
+#endif /* __HALMAC_SDIO_REG_H__ */
diff --git a/drivers/staging/rtlwifi/halmac/halmac_tx_bd_chip.h b/drivers/staging/rtlwifi/halmac/halmac_tx_bd_chip.h
new file mode 100644
index 000000000000..d5c9da247ca3
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_tx_bd_chip.h
@@ -0,0 +1,118 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_TX_BD_CHIP_H_
+#define _HALMAC_TX_BD_CHIP_H_
+
+/*TXBD_DW0*/
+
+#define SET_TX_BD_OWN_8822B(__tx_bd, __value) SET_TX_BD_OWN(__tx_bd, __value)
+#define GET_TX_BD_OWN_8822B(__tx_bd) GET_TX_BD_OWN(__tx_bd)
+#define SET_TX_BD_PSB_8822B(__tx_bd, __value) SET_TX_BD_PSB(__tx_bd, __value)
+#define GET_TX_BD_PSB_8822B(__tx_bd) GET_TX_BD_PSB(__tx_bd)
+#define SET_TX_BD_TX_BUFF_SIZE0_8822B(__tx_bd, __value)                        \
+	SET_TX_BD_TX_BUFF_SIZE0(__tx_bd, __value)
+#define GET_TX_BD_TX_BUFF_SIZE0_8822B(__tx_bd) GET_TX_BD_TX_BUFF_SIZE0(__tx_bd)
+
+/*TXBD_DW1*/
+
+#define SET_TX_BD_PHYSICAL_ADDR0_LOW_8822B(__tx_bd, __value)                   \
+	SET_TX_BD_PHYSICAL_ADDR0_LOW(__tx_bd, __value)
+#define GET_TX_BD_PHYSICAL_ADDR0_LOW_8822B(__tx_bd)                            \
+	GET_TX_BD_PHYSICAL_ADDR0_LOW(__tx_bd)
+
+/*TXBD_DW2*/
+
+#define SET_TX_BD_PHYSICAL_ADDR0_HIGH_8822B(__tx_bd, __value)                  \
+	SET_TX_BD_PHYSICAL_ADDR0_HIGH(__tx_bd, __value)
+#define GET_TX_BD_PHYSICAL_ADDR0_HIGH_8822B(__tx_bd)                           \
+	GET_TX_BD_PHYSICAL_ADDR0_HIGH(__tx_bd)
+
+/*TXBD_DW4*/
+
+#define SET_TX_BD_A1_8822B(__tx_bd, __value) SET_TX_BD_A1(__tx_bd, __value)
+#define GET_TX_BD_A1_8822B(__tx_bd) GET_TX_BD_A1(__tx_bd)
+#define SET_TX_BD_TX_BUFF_SIZE1_8822B(__tx_bd, __value)                        \
+	SET_TX_BD_TX_BUFF_SIZE1(__tx_bd, __value)
+#define GET_TX_BD_TX_BUFF_SIZE1_8822B(__tx_bd) GET_TX_BD_TX_BUFF_SIZE1(__tx_bd)
+
+/*TXBD_DW5*/
+
+#define SET_TX_BD_PHYSICAL_ADDR1_LOW_8822B(__tx_bd, __value)                   \
+	SET_TX_BD_PHYSICAL_ADDR1_LOW(__tx_bd, __value)
+#define GET_TX_BD_PHYSICAL_ADDR1_LOW_8822B(__tx_bd)                            \
+	GET_TX_BD_PHYSICAL_ADDR1_LOW(__tx_bd)
+
+/*TXBD_DW6*/
+
+#define SET_TX_BD_PHYSICAL_ADDR1_HIGH_8822B(__tx_bd, __value)                  \
+	SET_TX_BD_PHYSICAL_ADDR1_HIGH(__tx_bd, __value)
+#define GET_TX_BD_PHYSICAL_ADDR1_HIGH_8822B(__tx_bd)                           \
+	GET_TX_BD_PHYSICAL_ADDR1_HIGH(__tx_bd)
+
+/*TXBD_DW8*/
+
+#define SET_TX_BD_A2_8822B(__tx_bd, __value) SET_TX_BD_A2(__tx_bd, __value)
+#define GET_TX_BD_A2_8822B(__tx_bd) GET_TX_BD_A2(__tx_bd)
+#define SET_TX_BD_TX_BUFF_SIZE2_8822B(__tx_bd, __value)                        \
+	SET_TX_BD_TX_BUFF_SIZE2(__tx_bd, __value)
+#define GET_TX_BD_TX_BUFF_SIZE2_8822B(__tx_bd) GET_TX_BD_TX_BUFF_SIZE2(__tx_bd)
+
+/*TXBD_DW9*/
+
+#define SET_TX_BD_PHYSICAL_ADDR2_LOW_8822B(__tx_bd, __value)                   \
+	SET_TX_BD_PHYSICAL_ADDR2_LOW(__tx_bd, __value)
+#define GET_TX_BD_PHYSICAL_ADDR2_LOW_8822B(__tx_bd)                            \
+	GET_TX_BD_PHYSICAL_ADDR2_LOW(__tx_bd)
+
+/*TXBD_DW10*/
+
+#define SET_TX_BD_PHYSICAL_ADDR2_HIGH_8822B(__tx_bd, __value)                  \
+	SET_TX_BD_PHYSICAL_ADDR2_HIGH(__tx_bd, __value)
+#define GET_TX_BD_PHYSICAL_ADDR2_HIGH_8822B(__tx_bd)                           \
+	GET_TX_BD_PHYSICAL_ADDR2_HIGH(__tx_bd)
+
+/*TXBD_DW12*/
+
+#define SET_TX_BD_A3_8822B(__tx_bd, __value) SET_TX_BD_A3(__tx_bd, __value)
+#define GET_TX_BD_A3_8822B(__tx_bd) GET_TX_BD_A3(__tx_bd)
+#define SET_TX_BD_TX_BUFF_SIZE3_8822B(__tx_bd, __value)                        \
+	SET_TX_BD_TX_BUFF_SIZE3(__tx_bd, __value)
+#define GET_TX_BD_TX_BUFF_SIZE3_8822B(__tx_bd) GET_TX_BD_TX_BUFF_SIZE3(__tx_bd)
+
+/*TXBD_DW13*/
+
+#define SET_TX_BD_PHYSICAL_ADDR3_LOW_8822B(__tx_bd, __value)                   \
+	SET_TX_BD_PHYSICAL_ADDR3_LOW(__tx_bd, __value)
+#define GET_TX_BD_PHYSICAL_ADDR3_LOW_8822B(__tx_bd)                            \
+	GET_TX_BD_PHYSICAL_ADDR3_LOW(__tx_bd)
+
+/*TXBD_DW14*/
+
+#define SET_TX_BD_PHYSICAL_ADDR3_HIGH_8822B(__tx_bd, __value)                  \
+	SET_TX_BD_PHYSICAL_ADDR3_HIGH(__tx_bd, __value)
+#define GET_TX_BD_PHYSICAL_ADDR3_HIGH_8822B(__tx_bd)                           \
+	GET_TX_BD_PHYSICAL_ADDR3_HIGH(__tx_bd)
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_tx_bd_nic.h b/drivers/staging/rtlwifi/halmac/halmac_tx_bd_nic.h
new file mode 100644
index 000000000000..43c2261ab083
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_tx_bd_nic.h
@@ -0,0 +1,123 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_TX_BD_NIC_H_
+#define _HALMAC_TX_BD_NIC_H_
+
+/*TXBD_DW0*/
+
+#define SET_TX_BD_OWN(__tx_bd, __value)                                        \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x00, 31, 1, __value)
+#define GET_TX_BD_OWN(__tx_bd) LE_BITS_TO_4BYTE(__tx_bd + 0x00, 31, 1)
+#define SET_TX_BD_PSB(__tx_bd, __value)                                        \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x00, 16, 8, __value)
+#define GET_TX_BD_PSB(__tx_bd) LE_BITS_TO_4BYTE(__tx_bd + 0x00, 16, 8)
+#define SET_TX_BD_TX_BUFF_SIZE0(__tx_bd, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x00, 0, 16, __value)
+#define GET_TX_BD_TX_BUFF_SIZE0(__tx_bd) LE_BITS_TO_4BYTE(__tx_bd + 0x00, 0, 16)
+
+/*TXBD_DW1*/
+
+#define SET_TX_BD_PHYSICAL_ADDR0_LOW(__tx_bd, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x04, 0, 32, __value)
+#define GET_TX_BD_PHYSICAL_ADDR0_LOW(__tx_bd)                                  \
+	LE_BITS_TO_4BYTE(__tx_bd + 0x04, 0, 32)
+
+/*TXBD_DW2*/
+
+#define SET_TX_BD_PHYSICAL_ADDR0_HIGH(__tx_bd, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x08, 0, 32, __value)
+#define GET_TX_BD_PHYSICAL_ADDR0_HIGH(__tx_bd)                                 \
+	LE_BITS_TO_4BYTE(__tx_bd + 0x08, 0, 32)
+
+/*TXBD_DW4*/
+
+#define SET_TX_BD_A1(__tx_bd, __value)                                         \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x10, 31, 1, __value)
+#define GET_TX_BD_A1(__tx_bd) LE_BITS_TO_4BYTE(__tx_bd + 0x10, 31, 1)
+#define SET_TX_BD_TX_BUFF_SIZE1(__tx_bd, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x10, 0, 16, __value)
+#define GET_TX_BD_TX_BUFF_SIZE1(__tx_bd) LE_BITS_TO_4BYTE(__tx_bd + 0x10, 0, 16)
+
+/*TXBD_DW5*/
+
+#define SET_TX_BD_PHYSICAL_ADDR1_LOW(__tx_bd, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x14, 0, 32, __value)
+#define GET_TX_BD_PHYSICAL_ADDR1_LOW(__tx_bd)                                  \
+	LE_BITS_TO_4BYTE(__tx_bd + 0x14, 0, 32)
+
+/*TXBD_DW6*/
+
+#define SET_TX_BD_PHYSICAL_ADDR1_HIGH(__tx_bd, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x18, 0, 32, __value)
+#define GET_TX_BD_PHYSICAL_ADDR1_HIGH(__tx_bd)                                 \
+	LE_BITS_TO_4BYTE(__tx_bd + 0x18, 0, 32)
+
+/*TXBD_DW8*/
+
+#define SET_TX_BD_A2(__tx_bd, __value)                                         \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x20, 31, 1, __value)
+#define GET_TX_BD_A2(__tx_bd) LE_BITS_TO_4BYTE(__tx_bd + 0x20, 31, 1)
+#define SET_TX_BD_TX_BUFF_SIZE2(__tx_bd, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x20, 0, 16, __value)
+#define GET_TX_BD_TX_BUFF_SIZE2(__tx_bd) LE_BITS_TO_4BYTE(__tx_bd + 0x20, 0, 16)
+
+/*TXBD_DW9*/
+
+#define SET_TX_BD_PHYSICAL_ADDR2_LOW(__tx_bd, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x24, 0, 32, __value)
+#define GET_TX_BD_PHYSICAL_ADDR2_LOW(__tx_bd)                                  \
+	LE_BITS_TO_4BYTE(__tx_bd + 0x24, 0, 32)
+
+/*TXBD_DW10*/
+
+#define SET_TX_BD_PHYSICAL_ADDR2_HIGH(__tx_bd, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x28, 0, 32, __value)
+#define GET_TX_BD_PHYSICAL_ADDR2_HIGH(__tx_bd)                                 \
+	LE_BITS_TO_4BYTE(__tx_bd + 0x28, 0, 32)
+
+/*TXBD_DW12*/
+
+#define SET_TX_BD_A3(__tx_bd, __value)                                         \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x30, 31, 1, __value)
+#define GET_TX_BD_A3(__tx_bd) LE_BITS_TO_4BYTE(__tx_bd + 0x30, 31, 1)
+#define SET_TX_BD_TX_BUFF_SIZE3(__tx_bd, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x30, 0, 16, __value)
+#define GET_TX_BD_TX_BUFF_SIZE3(__tx_bd) LE_BITS_TO_4BYTE(__tx_bd + 0x30, 0, 16)
+
+/*TXBD_DW13*/
+
+#define SET_TX_BD_PHYSICAL_ADDR3_LOW(__tx_bd, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x34, 0, 32, __value)
+#define GET_TX_BD_PHYSICAL_ADDR3_LOW(__tx_bd)                                  \
+	LE_BITS_TO_4BYTE(__tx_bd + 0x34, 0, 32)
+
+/*TXBD_DW14*/
+
+#define SET_TX_BD_PHYSICAL_ADDR3_HIGH(__tx_bd, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__tx_bd + 0x38, 0, 32, __value)
+#define GET_TX_BD_PHYSICAL_ADDR3_HIGH(__tx_bd)                                 \
+	LE_BITS_TO_4BYTE(__tx_bd + 0x38, 0, 32)
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_tx_desc_chip.h b/drivers/staging/rtlwifi/halmac/halmac_tx_desc_chip.h
new file mode 100644
index 000000000000..fd1aa39c4bed
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_tx_desc_chip.h
@@ -0,0 +1,444 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_TX_DESC_CHIP_H_
+#define _HALMAC_TX_DESC_CHIP_H_
+
+/*TXDESC_WORD0*/
+
+#define SET_TX_DESC_DISQSELSEQ_8822B(__tx_desc, __value)                       \
+	SET_TX_DESC_DISQSELSEQ(__tx_desc, __value)
+#define GET_TX_DESC_DISQSELSEQ_8822B(__tx_desc)                                \
+	GET_TX_DESC_DISQSELSEQ(__tx_desc)
+#define SET_TX_DESC_GF_8822B(__tx_desc, __value)                               \
+	SET_TX_DESC_GF(__tx_desc, __value)
+#define GET_TX_DESC_GF_8822B(__tx_desc) GET_TX_DESC_GF(__tx_desc)
+#define SET_TX_DESC_NO_ACM_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_NO_ACM(__tx_desc, __value)
+#define GET_TX_DESC_NO_ACM_8822B(__tx_desc) GET_TX_DESC_NO_ACM(__tx_desc)
+#define SET_TX_DESC_BCNPKT_TSF_CTRL_8822B(__tx_desc, __value)                  \
+	SET_TX_DESC_BCNPKT_TSF_CTRL(__tx_desc, __value)
+#define GET_TX_DESC_BCNPKT_TSF_CTRL_8822B(__tx_desc)                           \
+	GET_TX_DESC_BCNPKT_TSF_CTRL(__tx_desc)
+#define SET_TX_DESC_AMSDU_PAD_EN_8822B(__tx_desc, __value)                     \
+	SET_TX_DESC_AMSDU_PAD_EN(__tx_desc, __value)
+#define GET_TX_DESC_AMSDU_PAD_EN_8822B(__tx_desc)                              \
+	GET_TX_DESC_AMSDU_PAD_EN(__tx_desc)
+#define SET_TX_DESC_LS_8822B(__tx_desc, __value)                               \
+	SET_TX_DESC_LS(__tx_desc, __value)
+#define GET_TX_DESC_LS_8822B(__tx_desc) GET_TX_DESC_LS(__tx_desc)
+#define SET_TX_DESC_HTC_8822B(__tx_desc, __value)                              \
+	SET_TX_DESC_HTC(__tx_desc, __value)
+#define GET_TX_DESC_HTC_8822B(__tx_desc) GET_TX_DESC_HTC(__tx_desc)
+#define SET_TX_DESC_BMC_8822B(__tx_desc, __value)                              \
+	SET_TX_DESC_BMC(__tx_desc, __value)
+#define GET_TX_DESC_BMC_8822B(__tx_desc) GET_TX_DESC_BMC(__tx_desc)
+#define SET_TX_DESC_OFFSET_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_OFFSET(__tx_desc, __value)
+#define GET_TX_DESC_OFFSET_8822B(__tx_desc) GET_TX_DESC_OFFSET(__tx_desc)
+#define SET_TX_DESC_TXPKTSIZE_8822B(__tx_desc, __value)                        \
+	SET_TX_DESC_TXPKTSIZE(__tx_desc, __value)
+#define GET_TX_DESC_TXPKTSIZE_8822B(__tx_desc) GET_TX_DESC_TXPKTSIZE(__tx_desc)
+
+/*TXDESC_WORD1*/
+
+#define SET_TX_DESC_MOREDATA_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_MOREDATA(__tx_desc, __value)
+#define GET_TX_DESC_MOREDATA_8822B(__tx_desc) GET_TX_DESC_MOREDATA(__tx_desc)
+#define SET_TX_DESC_PKT_OFFSET_8822B(__tx_desc, __value)                       \
+	SET_TX_DESC_PKT_OFFSET(__tx_desc, __value)
+#define GET_TX_DESC_PKT_OFFSET_8822B(__tx_desc)                                \
+	GET_TX_DESC_PKT_OFFSET(__tx_desc)
+#define SET_TX_DESC_SEC_TYPE_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_SEC_TYPE(__tx_desc, __value)
+#define GET_TX_DESC_SEC_TYPE_8822B(__tx_desc) GET_TX_DESC_SEC_TYPE(__tx_desc)
+#define SET_TX_DESC_EN_DESC_ID_8822B(__tx_desc, __value)                       \
+	SET_TX_DESC_EN_DESC_ID(__tx_desc, __value)
+#define GET_TX_DESC_EN_DESC_ID_8822B(__tx_desc)                                \
+	GET_TX_DESC_EN_DESC_ID(__tx_desc)
+#define SET_TX_DESC_RATE_ID_8822B(__tx_desc, __value)                          \
+	SET_TX_DESC_RATE_ID(__tx_desc, __value)
+#define GET_TX_DESC_RATE_ID_8822B(__tx_desc) GET_TX_DESC_RATE_ID(__tx_desc)
+#define SET_TX_DESC_PIFS_8822B(__tx_desc, __value)                             \
+	SET_TX_DESC_PIFS(__tx_desc, __value)
+#define GET_TX_DESC_PIFS_8822B(__tx_desc) GET_TX_DESC_PIFS(__tx_desc)
+#define SET_TX_DESC_LSIG_TXOP_EN_8822B(__tx_desc, __value)                     \
+	SET_TX_DESC_LSIG_TXOP_EN(__tx_desc, __value)
+#define GET_TX_DESC_LSIG_TXOP_EN_8822B(__tx_desc)                              \
+	GET_TX_DESC_LSIG_TXOP_EN(__tx_desc)
+#define SET_TX_DESC_RD_NAV_EXT_8822B(__tx_desc, __value)                       \
+	SET_TX_DESC_RD_NAV_EXT(__tx_desc, __value)
+#define GET_TX_DESC_RD_NAV_EXT_8822B(__tx_desc)                                \
+	GET_TX_DESC_RD_NAV_EXT(__tx_desc)
+#define SET_TX_DESC_QSEL_8822B(__tx_desc, __value)                             \
+	SET_TX_DESC_QSEL(__tx_desc, __value)
+#define GET_TX_DESC_QSEL_8822B(__tx_desc) GET_TX_DESC_QSEL(__tx_desc)
+#define SET_TX_DESC_MACID_8822B(__tx_desc, __value)                            \
+	SET_TX_DESC_MACID(__tx_desc, __value)
+#define GET_TX_DESC_MACID_8822B(__tx_desc) GET_TX_DESC_MACID(__tx_desc)
+
+/*TXDESC_WORD2*/
+
+#define SET_TX_DESC_HW_AES_IV_8822B(__tx_desc, __value)                        \
+	SET_TX_DESC_HW_AES_IV(__tx_desc, __value)
+#define GET_TX_DESC_HW_AES_IV_8822B(__tx_desc) GET_TX_DESC_HW_AES_IV(__tx_desc)
+#define SET_TX_DESC_FTM_EN_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_FTM_EN(__tx_desc, __value)
+#define GET_TX_DESC_FTM_EN_8822B(__tx_desc) GET_TX_DESC_FTM_EN(__tx_desc)
+#define SET_TX_DESC_G_ID_8822B(__tx_desc, __value)                             \
+	SET_TX_DESC_G_ID(__tx_desc, __value)
+#define GET_TX_DESC_G_ID_8822B(__tx_desc) GET_TX_DESC_G_ID(__tx_desc)
+#define SET_TX_DESC_BT_NULL_8822B(__tx_desc, __value)                          \
+	SET_TX_DESC_BT_NULL(__tx_desc, __value)
+#define GET_TX_DESC_BT_NULL_8822B(__tx_desc) GET_TX_DESC_BT_NULL(__tx_desc)
+#define SET_TX_DESC_AMPDU_DENSITY_8822B(__tx_desc, __value)                    \
+	SET_TX_DESC_AMPDU_DENSITY(__tx_desc, __value)
+#define GET_TX_DESC_AMPDU_DENSITY_8822B(__tx_desc)                             \
+	GET_TX_DESC_AMPDU_DENSITY(__tx_desc)
+#define SET_TX_DESC_SPE_RPT_8822B(__tx_desc, __value)                          \
+	SET_TX_DESC_SPE_RPT(__tx_desc, __value)
+#define GET_TX_DESC_SPE_RPT_8822B(__tx_desc) GET_TX_DESC_SPE_RPT(__tx_desc)
+#define SET_TX_DESC_RAW_8822B(__tx_desc, __value)                              \
+	SET_TX_DESC_RAW(__tx_desc, __value)
+#define GET_TX_DESC_RAW_8822B(__tx_desc) GET_TX_DESC_RAW(__tx_desc)
+#define SET_TX_DESC_MOREFRAG_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_MOREFRAG(__tx_desc, __value)
+#define GET_TX_DESC_MOREFRAG_8822B(__tx_desc) GET_TX_DESC_MOREFRAG(__tx_desc)
+#define SET_TX_DESC_BK_8822B(__tx_desc, __value)                               \
+	SET_TX_DESC_BK(__tx_desc, __value)
+#define GET_TX_DESC_BK_8822B(__tx_desc) GET_TX_DESC_BK(__tx_desc)
+#define SET_TX_DESC_NULL_1_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_NULL_1(__tx_desc, __value)
+#define GET_TX_DESC_NULL_1_8822B(__tx_desc) GET_TX_DESC_NULL_1(__tx_desc)
+#define SET_TX_DESC_NULL_0_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_NULL_0(__tx_desc, __value)
+#define GET_TX_DESC_NULL_0_8822B(__tx_desc) GET_TX_DESC_NULL_0(__tx_desc)
+#define SET_TX_DESC_RDG_EN_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_RDG_EN(__tx_desc, __value)
+#define GET_TX_DESC_RDG_EN_8822B(__tx_desc) GET_TX_DESC_RDG_EN(__tx_desc)
+#define SET_TX_DESC_AGG_EN_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_AGG_EN(__tx_desc, __value)
+#define GET_TX_DESC_AGG_EN_8822B(__tx_desc) GET_TX_DESC_AGG_EN(__tx_desc)
+#define SET_TX_DESC_CCA_RTS_8822B(__tx_desc, __value)                          \
+	SET_TX_DESC_CCA_RTS(__tx_desc, __value)
+#define GET_TX_DESC_CCA_RTS_8822B(__tx_desc) GET_TX_DESC_CCA_RTS(__tx_desc)
+#define SET_TX_DESC_TRI_FRAME_8822B(__tx_desc, __value)                        \
+	SET_TX_DESC_TRI_FRAME(__tx_desc, __value)
+#define GET_TX_DESC_TRI_FRAME_8822B(__tx_desc) GET_TX_DESC_TRI_FRAME(__tx_desc)
+#define SET_TX_DESC_P_AID_8822B(__tx_desc, __value)                            \
+	SET_TX_DESC_P_AID(__tx_desc, __value)
+#define GET_TX_DESC_P_AID_8822B(__tx_desc) GET_TX_DESC_P_AID(__tx_desc)
+
+/*TXDESC_WORD3*/
+
+#define SET_TX_DESC_AMPDU_MAX_TIME_8822B(__tx_desc, __value)                   \
+	SET_TX_DESC_AMPDU_MAX_TIME(__tx_desc, __value)
+#define GET_TX_DESC_AMPDU_MAX_TIME_8822B(__tx_desc)                            \
+	GET_TX_DESC_AMPDU_MAX_TIME(__tx_desc)
+#define SET_TX_DESC_NDPA_8822B(__tx_desc, __value)                             \
+	SET_TX_DESC_NDPA(__tx_desc, __value)
+#define GET_TX_DESC_NDPA_8822B(__tx_desc) GET_TX_DESC_NDPA(__tx_desc)
+#define SET_TX_DESC_MAX_AGG_NUM_8822B(__tx_desc, __value)                      \
+	SET_TX_DESC_MAX_AGG_NUM(__tx_desc, __value)
+#define GET_TX_DESC_MAX_AGG_NUM_8822B(__tx_desc)                               \
+	GET_TX_DESC_MAX_AGG_NUM(__tx_desc)
+#define SET_TX_DESC_USE_MAX_TIME_EN_8822B(__tx_desc, __value)                  \
+	SET_TX_DESC_USE_MAX_TIME_EN(__tx_desc, __value)
+#define GET_TX_DESC_USE_MAX_TIME_EN_8822B(__tx_desc)                           \
+	GET_TX_DESC_USE_MAX_TIME_EN(__tx_desc)
+#define SET_TX_DESC_NAVUSEHDR_8822B(__tx_desc, __value)                        \
+	SET_TX_DESC_NAVUSEHDR(__tx_desc, __value)
+#define GET_TX_DESC_NAVUSEHDR_8822B(__tx_desc) GET_TX_DESC_NAVUSEHDR(__tx_desc)
+#define SET_TX_DESC_CHK_EN_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_CHK_EN(__tx_desc, __value)
+#define GET_TX_DESC_CHK_EN_8822B(__tx_desc) GET_TX_DESC_CHK_EN(__tx_desc)
+#define SET_TX_DESC_HW_RTS_EN_8822B(__tx_desc, __value)                        \
+	SET_TX_DESC_HW_RTS_EN(__tx_desc, __value)
+#define GET_TX_DESC_HW_RTS_EN_8822B(__tx_desc) GET_TX_DESC_HW_RTS_EN(__tx_desc)
+#define SET_TX_DESC_RTSEN_8822B(__tx_desc, __value)                            \
+	SET_TX_DESC_RTSEN(__tx_desc, __value)
+#define GET_TX_DESC_RTSEN_8822B(__tx_desc) GET_TX_DESC_RTSEN(__tx_desc)
+#define SET_TX_DESC_CTS2SELF_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_CTS2SELF(__tx_desc, __value)
+#define GET_TX_DESC_CTS2SELF_8822B(__tx_desc) GET_TX_DESC_CTS2SELF(__tx_desc)
+#define SET_TX_DESC_DISDATAFB_8822B(__tx_desc, __value)                        \
+	SET_TX_DESC_DISDATAFB(__tx_desc, __value)
+#define GET_TX_DESC_DISDATAFB_8822B(__tx_desc) GET_TX_DESC_DISDATAFB(__tx_desc)
+#define SET_TX_DESC_DISRTSFB_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_DISRTSFB(__tx_desc, __value)
+#define GET_TX_DESC_DISRTSFB_8822B(__tx_desc) GET_TX_DESC_DISRTSFB(__tx_desc)
+#define SET_TX_DESC_USE_RATE_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_USE_RATE(__tx_desc, __value)
+#define GET_TX_DESC_USE_RATE_8822B(__tx_desc) GET_TX_DESC_USE_RATE(__tx_desc)
+#define SET_TX_DESC_HW_SSN_SEL_8822B(__tx_desc, __value)                       \
+	SET_TX_DESC_HW_SSN_SEL(__tx_desc, __value)
+#define GET_TX_DESC_HW_SSN_SEL_8822B(__tx_desc)                                \
+	GET_TX_DESC_HW_SSN_SEL(__tx_desc)
+#define SET_TX_DESC_WHEADER_LEN_8822B(__tx_desc, __value)                      \
+	SET_TX_DESC_WHEADER_LEN(__tx_desc, __value)
+#define GET_TX_DESC_WHEADER_LEN_8822B(__tx_desc)                               \
+	GET_TX_DESC_WHEADER_LEN(__tx_desc)
+
+/*TXDESC_WORD4*/
+
+#define SET_TX_DESC_PCTS_MASK_IDX_8822B(__tx_desc, __value)                    \
+	SET_TX_DESC_PCTS_MASK_IDX(__tx_desc, __value)
+#define GET_TX_DESC_PCTS_MASK_IDX_8822B(__tx_desc)                             \
+	GET_TX_DESC_PCTS_MASK_IDX(__tx_desc)
+#define SET_TX_DESC_PCTS_EN_8822B(__tx_desc, __value)                          \
+	SET_TX_DESC_PCTS_EN(__tx_desc, __value)
+#define GET_TX_DESC_PCTS_EN_8822B(__tx_desc) GET_TX_DESC_PCTS_EN(__tx_desc)
+#define SET_TX_DESC_RTSRATE_8822B(__tx_desc, __value)                          \
+	SET_TX_DESC_RTSRATE(__tx_desc, __value)
+#define GET_TX_DESC_RTSRATE_8822B(__tx_desc) GET_TX_DESC_RTSRATE(__tx_desc)
+#define SET_TX_DESC_RTS_DATA_RTY_LMT_8822B(__tx_desc, __value)                 \
+	SET_TX_DESC_RTS_DATA_RTY_LMT(__tx_desc, __value)
+#define GET_TX_DESC_RTS_DATA_RTY_LMT_8822B(__tx_desc)                          \
+	GET_TX_DESC_RTS_DATA_RTY_LMT(__tx_desc)
+#define SET_TX_DESC_RTY_LMT_EN_8822B(__tx_desc, __value)                       \
+	SET_TX_DESC_RTY_LMT_EN(__tx_desc, __value)
+#define GET_TX_DESC_RTY_LMT_EN_8822B(__tx_desc)                                \
+	GET_TX_DESC_RTY_LMT_EN(__tx_desc)
+#define SET_TX_DESC_RTS_RTY_LOWEST_RATE_8822B(__tx_desc, __value)              \
+	SET_TX_DESC_RTS_RTY_LOWEST_RATE(__tx_desc, __value)
+#define GET_TX_DESC_RTS_RTY_LOWEST_RATE_8822B(__tx_desc)                       \
+	GET_TX_DESC_RTS_RTY_LOWEST_RATE(__tx_desc)
+#define SET_TX_DESC_DATA_RTY_LOWEST_RATE_8822B(__tx_desc, __value)             \
+	SET_TX_DESC_DATA_RTY_LOWEST_RATE(__tx_desc, __value)
+#define GET_TX_DESC_DATA_RTY_LOWEST_RATE_8822B(__tx_desc)                      \
+	GET_TX_DESC_DATA_RTY_LOWEST_RATE(__tx_desc)
+#define SET_TX_DESC_TRY_RATE_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_TRY_RATE(__tx_desc, __value)
+#define GET_TX_DESC_TRY_RATE_8822B(__tx_desc) GET_TX_DESC_TRY_RATE(__tx_desc)
+#define SET_TX_DESC_DATARATE_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_DATARATE(__tx_desc, __value)
+#define GET_TX_DESC_DATARATE_8822B(__tx_desc) GET_TX_DESC_DATARATE(__tx_desc)
+
+/*TXDESC_WORD5*/
+
+#define SET_TX_DESC_POLLUTED_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_POLLUTED(__tx_desc, __value)
+#define GET_TX_DESC_POLLUTED_8822B(__tx_desc) GET_TX_DESC_POLLUTED(__tx_desc)
+#define SET_TX_DESC_TXPWR_OFSET_8822B(__tx_desc, __value)                      \
+	SET_TX_DESC_TXPWR_OFSET(__tx_desc, __value)
+#define GET_TX_DESC_TXPWR_OFSET_8822B(__tx_desc)                               \
+	GET_TX_DESC_TXPWR_OFSET(__tx_desc)
+#define SET_TX_DESC_TX_ANT_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_TX_ANT(__tx_desc, __value)
+#define GET_TX_DESC_TX_ANT_8822B(__tx_desc) GET_TX_DESC_TX_ANT(__tx_desc)
+#define SET_TX_DESC_PORT_ID_8822B(__tx_desc, __value)                          \
+	SET_TX_DESC_PORT_ID(__tx_desc, __value)
+#define GET_TX_DESC_PORT_ID_8822B(__tx_desc) GET_TX_DESC_PORT_ID(__tx_desc)
+#define SET_TX_DESC_MULTIPLE_PORT_8822B(__tx_desc, __value)                    \
+	SET_TX_DESC_MULTIPLE_PORT(__tx_desc, __value)
+#define GET_TX_DESC_MULTIPLE_PORT_8822B(__tx_desc)                             \
+	GET_TX_DESC_MULTIPLE_PORT(__tx_desc)
+#define SET_TX_DESC_SIGNALING_TAPKT_EN_8822B(__tx_desc, __value)               \
+	SET_TX_DESC_SIGNALING_TAPKT_EN(__tx_desc, __value)
+#define GET_TX_DESC_SIGNALING_TAPKT_EN_8822B(__tx_desc)                        \
+	GET_TX_DESC_SIGNALING_TAPKT_EN(__tx_desc)
+#define SET_TX_DESC_RTS_SC_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_RTS_SC(__tx_desc, __value)
+#define GET_TX_DESC_RTS_SC_8822B(__tx_desc) GET_TX_DESC_RTS_SC(__tx_desc)
+#define SET_TX_DESC_RTS_SHORT_8822B(__tx_desc, __value)                        \
+	SET_TX_DESC_RTS_SHORT(__tx_desc, __value)
+#define GET_TX_DESC_RTS_SHORT_8822B(__tx_desc) GET_TX_DESC_RTS_SHORT(__tx_desc)
+#define SET_TX_DESC_VCS_STBC_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_VCS_STBC(__tx_desc, __value)
+#define GET_TX_DESC_VCS_STBC_8822B(__tx_desc) GET_TX_DESC_VCS_STBC(__tx_desc)
+#define SET_TX_DESC_DATA_STBC_8822B(__tx_desc, __value)                        \
+	SET_TX_DESC_DATA_STBC(__tx_desc, __value)
+#define GET_TX_DESC_DATA_STBC_8822B(__tx_desc) GET_TX_DESC_DATA_STBC(__tx_desc)
+#define SET_TX_DESC_DATA_LDPC_8822B(__tx_desc, __value)                        \
+	SET_TX_DESC_DATA_LDPC(__tx_desc, __value)
+#define GET_TX_DESC_DATA_LDPC_8822B(__tx_desc) GET_TX_DESC_DATA_LDPC(__tx_desc)
+#define SET_TX_DESC_DATA_BW_8822B(__tx_desc, __value)                          \
+	SET_TX_DESC_DATA_BW(__tx_desc, __value)
+#define GET_TX_DESC_DATA_BW_8822B(__tx_desc) GET_TX_DESC_DATA_BW(__tx_desc)
+#define SET_TX_DESC_DATA_SHORT_8822B(__tx_desc, __value)                       \
+	SET_TX_DESC_DATA_SHORT(__tx_desc, __value)
+#define GET_TX_DESC_DATA_SHORT_8822B(__tx_desc)                                \
+	GET_TX_DESC_DATA_SHORT(__tx_desc)
+#define SET_TX_DESC_DATA_SC_8822B(__tx_desc, __value)                          \
+	SET_TX_DESC_DATA_SC(__tx_desc, __value)
+#define GET_TX_DESC_DATA_SC_8822B(__tx_desc) GET_TX_DESC_DATA_SC(__tx_desc)
+
+/*TXDESC_WORD6*/
+
+#define SET_TX_DESC_ANTSEL_D_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_ANTSEL_D(__tx_desc, __value)
+#define GET_TX_DESC_ANTSEL_D_8822B(__tx_desc) GET_TX_DESC_ANTSEL_D(__tx_desc)
+#define SET_TX_DESC_ANT_MAPD_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_ANT_MAPD(__tx_desc, __value)
+#define GET_TX_DESC_ANT_MAPD_8822B(__tx_desc) GET_TX_DESC_ANT_MAPD(__tx_desc)
+#define SET_TX_DESC_ANT_MAPC_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_ANT_MAPC(__tx_desc, __value)
+#define GET_TX_DESC_ANT_MAPC_8822B(__tx_desc) GET_TX_DESC_ANT_MAPC(__tx_desc)
+#define SET_TX_DESC_ANT_MAPB_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_ANT_MAPB(__tx_desc, __value)
+#define GET_TX_DESC_ANT_MAPB_8822B(__tx_desc) GET_TX_DESC_ANT_MAPB(__tx_desc)
+#define SET_TX_DESC_ANT_MAPA_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_ANT_MAPA(__tx_desc, __value)
+#define GET_TX_DESC_ANT_MAPA_8822B(__tx_desc) GET_TX_DESC_ANT_MAPA(__tx_desc)
+#define SET_TX_DESC_ANTSEL_C_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_ANTSEL_C(__tx_desc, __value)
+#define GET_TX_DESC_ANTSEL_C_8822B(__tx_desc) GET_TX_DESC_ANTSEL_C(__tx_desc)
+#define SET_TX_DESC_ANTSEL_B_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_ANTSEL_B(__tx_desc, __value)
+#define GET_TX_DESC_ANTSEL_B_8822B(__tx_desc) GET_TX_DESC_ANTSEL_B(__tx_desc)
+#define SET_TX_DESC_ANTSEL_A_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_ANTSEL_A(__tx_desc, __value)
+#define GET_TX_DESC_ANTSEL_A_8822B(__tx_desc) GET_TX_DESC_ANTSEL_A(__tx_desc)
+#define SET_TX_DESC_MBSSID_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_MBSSID(__tx_desc, __value)
+#define GET_TX_DESC_MBSSID_8822B(__tx_desc) GET_TX_DESC_MBSSID(__tx_desc)
+#define SET_TX_DESC_SW_DEFINE_8822B(__tx_desc, __value)                        \
+	SET_TX_DESC_SW_DEFINE(__tx_desc, __value)
+#define GET_TX_DESC_SW_DEFINE_8822B(__tx_desc) GET_TX_DESC_SW_DEFINE(__tx_desc)
+
+/*TXDESC_WORD7*/
+
+#define SET_TX_DESC_DMA_TXAGG_NUM_8822B(__tx_desc, __value)                    \
+	SET_TX_DESC_DMA_TXAGG_NUM(__tx_desc, __value)
+#define GET_TX_DESC_DMA_TXAGG_NUM_8822B(__tx_desc)                             \
+	GET_TX_DESC_DMA_TXAGG_NUM(__tx_desc)
+#define SET_TX_DESC_FINAL_DATA_RATE_8822B(__tx_desc, __value)                  \
+	SET_TX_DESC_FINAL_DATA_RATE(__tx_desc, __value)
+#define GET_TX_DESC_FINAL_DATA_RATE_8822B(__tx_desc)                           \
+	GET_TX_DESC_FINAL_DATA_RATE(__tx_desc)
+#define SET_TX_DESC_NTX_MAP_8822B(__tx_desc, __value)                          \
+	SET_TX_DESC_NTX_MAP(__tx_desc, __value)
+#define GET_TX_DESC_NTX_MAP_8822B(__tx_desc) GET_TX_DESC_NTX_MAP(__tx_desc)
+#define SET_TX_DESC_TX_BUFF_SIZE_8822B(__tx_desc, __value)                     \
+	SET_TX_DESC_TX_BUFF_SIZE(__tx_desc, __value)
+#define GET_TX_DESC_TX_BUFF_SIZE_8822B(__tx_desc)                              \
+	GET_TX_DESC_TX_BUFF_SIZE(__tx_desc)
+#define SET_TX_DESC_TXDESC_CHECKSUM_8822B(__tx_desc, __value)                  \
+	SET_TX_DESC_TXDESC_CHECKSUM(__tx_desc, __value)
+#define GET_TX_DESC_TXDESC_CHECKSUM_8822B(__tx_desc)                           \
+	GET_TX_DESC_TXDESC_CHECKSUM(__tx_desc)
+#define SET_TX_DESC_TIMESTAMP_8822B(__tx_desc, __value)                        \
+	SET_TX_DESC_TIMESTAMP(__tx_desc, __value)
+#define GET_TX_DESC_TIMESTAMP_8822B(__tx_desc) GET_TX_DESC_TIMESTAMP(__tx_desc)
+
+/*TXDESC_WORD8*/
+
+#define SET_TX_DESC_TXWIFI_CP_8822B(__tx_desc, __value)                        \
+	SET_TX_DESC_TXWIFI_CP(__tx_desc, __value)
+#define GET_TX_DESC_TXWIFI_CP_8822B(__tx_desc) GET_TX_DESC_TXWIFI_CP(__tx_desc)
+#define SET_TX_DESC_MAC_CP_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_MAC_CP(__tx_desc, __value)
+#define GET_TX_DESC_MAC_CP_8822B(__tx_desc) GET_TX_DESC_MAC_CP(__tx_desc)
+#define SET_TX_DESC_STW_PKTRE_DIS_8822B(__tx_desc, __value)                    \
+	SET_TX_DESC_STW_PKTRE_DIS(__tx_desc, __value)
+#define GET_TX_DESC_STW_PKTRE_DIS_8822B(__tx_desc)                             \
+	GET_TX_DESC_STW_PKTRE_DIS(__tx_desc)
+#define SET_TX_DESC_STW_RB_DIS_8822B(__tx_desc, __value)                       \
+	SET_TX_DESC_STW_RB_DIS(__tx_desc, __value)
+#define GET_TX_DESC_STW_RB_DIS_8822B(__tx_desc)                                \
+	GET_TX_DESC_STW_RB_DIS(__tx_desc)
+#define SET_TX_DESC_STW_RATE_DIS_8822B(__tx_desc, __value)                     \
+	SET_TX_DESC_STW_RATE_DIS(__tx_desc, __value)
+#define GET_TX_DESC_STW_RATE_DIS_8822B(__tx_desc)                              \
+	GET_TX_DESC_STW_RATE_DIS(__tx_desc)
+#define SET_TX_DESC_STW_ANT_DIS_8822B(__tx_desc, __value)                      \
+	SET_TX_DESC_STW_ANT_DIS(__tx_desc, __value)
+#define GET_TX_DESC_STW_ANT_DIS_8822B(__tx_desc)                               \
+	GET_TX_DESC_STW_ANT_DIS(__tx_desc)
+#define SET_TX_DESC_STW_EN_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_STW_EN(__tx_desc, __value)
+#define GET_TX_DESC_STW_EN_8822B(__tx_desc) GET_TX_DESC_STW_EN(__tx_desc)
+#define SET_TX_DESC_SMH_EN_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_SMH_EN(__tx_desc, __value)
+#define GET_TX_DESC_SMH_EN_8822B(__tx_desc) GET_TX_DESC_SMH_EN(__tx_desc)
+#define SET_TX_DESC_TAILPAGE_L_8822B(__tx_desc, __value)                       \
+	SET_TX_DESC_TAILPAGE_L(__tx_desc, __value)
+#define GET_TX_DESC_TAILPAGE_L_8822B(__tx_desc)                                \
+	GET_TX_DESC_TAILPAGE_L(__tx_desc)
+#define SET_TX_DESC_SDIO_DMASEQ_8822B(__tx_desc, __value)                      \
+	SET_TX_DESC_SDIO_DMASEQ(__tx_desc, __value)
+#define GET_TX_DESC_SDIO_DMASEQ_8822B(__tx_desc)                               \
+	GET_TX_DESC_SDIO_DMASEQ(__tx_desc)
+#define SET_TX_DESC_NEXTHEADPAGE_L_8822B(__tx_desc, __value)                   \
+	SET_TX_DESC_NEXTHEADPAGE_L(__tx_desc, __value)
+#define GET_TX_DESC_NEXTHEADPAGE_L_8822B(__tx_desc)                            \
+	GET_TX_DESC_NEXTHEADPAGE_L(__tx_desc)
+#define SET_TX_DESC_EN_HWSEQ_8822B(__tx_desc, __value)                         \
+	SET_TX_DESC_EN_HWSEQ(__tx_desc, __value)
+#define GET_TX_DESC_EN_HWSEQ_8822B(__tx_desc) GET_TX_DESC_EN_HWSEQ(__tx_desc)
+#define SET_TX_DESC_EN_HWEXSEQ_8822B(__tx_desc, __value)                       \
+	SET_TX_DESC_EN_HWEXSEQ(__tx_desc, __value)
+#define GET_TX_DESC_EN_HWEXSEQ_8822B(__tx_desc)                                \
+	GET_TX_DESC_EN_HWEXSEQ(__tx_desc)
+#define SET_TX_DESC_DATA_RC_8822B(__tx_desc, __value)                          \
+	SET_TX_DESC_DATA_RC(__tx_desc, __value)
+#define GET_TX_DESC_DATA_RC_8822B(__tx_desc) GET_TX_DESC_DATA_RC(__tx_desc)
+#define SET_TX_DESC_BAR_RTY_TH_8822B(__tx_desc, __value)                       \
+	SET_TX_DESC_BAR_RTY_TH(__tx_desc, __value)
+#define GET_TX_DESC_BAR_RTY_TH_8822B(__tx_desc)                                \
+	GET_TX_DESC_BAR_RTY_TH(__tx_desc)
+#define SET_TX_DESC_RTS_RC_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_RTS_RC(__tx_desc, __value)
+#define GET_TX_DESC_RTS_RC_8822B(__tx_desc) GET_TX_DESC_RTS_RC(__tx_desc)
+
+/*TXDESC_WORD9*/
+
+#define SET_TX_DESC_TAILPAGE_H_8822B(__tx_desc, __value)                       \
+	SET_TX_DESC_TAILPAGE_H(__tx_desc, __value)
+#define GET_TX_DESC_TAILPAGE_H_8822B(__tx_desc)                                \
+	GET_TX_DESC_TAILPAGE_H(__tx_desc)
+#define SET_TX_DESC_NEXTHEADPAGE_H_8822B(__tx_desc, __value)                   \
+	SET_TX_DESC_NEXTHEADPAGE_H(__tx_desc, __value)
+#define GET_TX_DESC_NEXTHEADPAGE_H_8822B(__tx_desc)                            \
+	GET_TX_DESC_NEXTHEADPAGE_H(__tx_desc)
+#define SET_TX_DESC_SW_SEQ_8822B(__tx_desc, __value)                           \
+	SET_TX_DESC_SW_SEQ(__tx_desc, __value)
+#define GET_TX_DESC_SW_SEQ_8822B(__tx_desc) GET_TX_DESC_SW_SEQ(__tx_desc)
+#define SET_TX_DESC_TXBF_PATH_8822B(__tx_desc, __value)                        \
+	SET_TX_DESC_TXBF_PATH(__tx_desc, __value)
+#define GET_TX_DESC_TXBF_PATH_8822B(__tx_desc) GET_TX_DESC_TXBF_PATH(__tx_desc)
+#define SET_TX_DESC_PADDING_LEN_8822B(__tx_desc, __value)                      \
+	SET_TX_DESC_PADDING_LEN(__tx_desc, __value)
+#define GET_TX_DESC_PADDING_LEN_8822B(__tx_desc)                               \
+	GET_TX_DESC_PADDING_LEN(__tx_desc)
+#define SET_TX_DESC_GROUP_BIT_IE_OFFSET_8822B(__tx_desc, __value)              \
+	SET_TX_DESC_GROUP_BIT_IE_OFFSET(__tx_desc, __value)
+#define GET_TX_DESC_GROUP_BIT_IE_OFFSET_8822B(__tx_desc)                       \
+	GET_TX_DESC_GROUP_BIT_IE_OFFSET(__tx_desc)
+
+/*WORD10*/
+
+#define SET_TX_DESC_MU_DATARATE_8822B(__tx_desc, __value)                      \
+	SET_TX_DESC_MU_DATARATE(__tx_desc, __value)
+#define GET_TX_DESC_MU_DATARATE_8822B(__tx_desc)                               \
+	GET_TX_DESC_MU_DATARATE(__tx_desc)
+#define SET_TX_DESC_MU_RC_8822B(__tx_desc, __value)                            \
+	SET_TX_DESC_MU_RC(__tx_desc, __value)
+#define GET_TX_DESC_MU_RC_8822B(__tx_desc) GET_TX_DESC_MU_RC(__tx_desc)
+#define SET_TX_DESC_SND_PKT_SEL_8822B(__tx_desc, __value)                      \
+	SET_TX_DESC_SND_PKT_SEL(__tx_desc, __value)
+#define GET_TX_DESC_SND_PKT_SEL_8822B(__tx_desc)                               \
+	GET_TX_DESC_SND_PKT_SEL(__tx_desc)
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_tx_desc_nic.h b/drivers/staging/rtlwifi/halmac/halmac_tx_desc_nic.h
new file mode 100644
index 000000000000..02177c5faddf
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_tx_desc_nic.h
@@ -0,0 +1,506 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_TX_DESC_NIC_H_
+#define _HALMAC_TX_DESC_NIC_H_
+
+/*TXDESC_WORD0*/
+
+#define SET_TX_DESC_DISQSELSEQ(__tx_desc, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x00, 31, 1, __value)
+#define GET_TX_DESC_DISQSELSEQ(__tx_desc)                                      \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x00, 31, 1)
+
+#define SET_TX_DESC_GF(__tx_desc, __value)                                     \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x00, 30, 1, __value)
+#define GET_TX_DESC_GF(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x00, 30, 1)
+#define SET_TX_DESC_NO_ACM(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x00, 29, 1, __value)
+#define GET_TX_DESC_NO_ACM(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x00, 29, 1)
+
+#define SET_TX_DESC_BCNPKT_TSF_CTRL(__tx_desc, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x00, 28, 1, __value)
+#define GET_TX_DESC_BCNPKT_TSF_CTRL(__tx_desc)                                 \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x00, 28, 1)
+
+#define SET_TX_DESC_AMSDU_PAD_EN(__tx_desc, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x00, 27, 1, __value)
+#define GET_TX_DESC_AMSDU_PAD_EN(__tx_desc)                                    \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x00, 27, 1)
+
+#define SET_TX_DESC_LS(__tx_desc, __value)                                     \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x00, 26, 1, __value)
+#define GET_TX_DESC_LS(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x00, 26, 1)
+#define SET_TX_DESC_HTC(__tx_desc, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x00, 25, 1, __value)
+#define GET_TX_DESC_HTC(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x00, 25, 1)
+#define SET_TX_DESC_BMC(__tx_desc, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x00, 24, 1, __value)
+#define GET_TX_DESC_BMC(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x00, 24, 1)
+#define SET_TX_DESC_OFFSET(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x00, 16, 8, __value)
+#define GET_TX_DESC_OFFSET(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x00, 16, 8)
+#define SET_TX_DESC_TXPKTSIZE(__tx_desc, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x00, 0, 16, __value)
+#define GET_TX_DESC_TXPKTSIZE(__tx_desc)                                       \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x00, 0, 16)
+
+/*TXDESC_WORD1*/
+
+#define SET_TX_DESC_MOREDATA(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x04, 29, 1, __value)
+#define GET_TX_DESC_MOREDATA(__tx_desc)                                        \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x04, 29, 1)
+#define SET_TX_DESC_PKT_OFFSET(__tx_desc, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x04, 24, 5, __value)
+#define GET_TX_DESC_PKT_OFFSET(__tx_desc)                                      \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x04, 24, 5)
+#define SET_TX_DESC_SEC_TYPE(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x04, 22, 2, __value)
+#define GET_TX_DESC_SEC_TYPE(__tx_desc)                                        \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x04, 22, 2)
+#define SET_TX_DESC_EN_DESC_ID(__tx_desc, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x04, 21, 1, __value)
+#define GET_TX_DESC_EN_DESC_ID(__tx_desc)                                      \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x04, 21, 1)
+#define SET_TX_DESC_RATE_ID(__tx_desc, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x04, 16, 5, __value)
+#define GET_TX_DESC_RATE_ID(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x04, 16, 5)
+#define SET_TX_DESC_PIFS(__tx_desc, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x04, 15, 1, __value)
+#define GET_TX_DESC_PIFS(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x04, 15, 1)
+#define SET_TX_DESC_LSIG_TXOP_EN(__tx_desc, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x04, 14, 1, __value)
+#define GET_TX_DESC_LSIG_TXOP_EN(__tx_desc)                                    \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x04, 14, 1)
+#define SET_TX_DESC_RD_NAV_EXT(__tx_desc, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x04, 13, 1, __value)
+#define GET_TX_DESC_RD_NAV_EXT(__tx_desc)                                      \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x04, 13, 1)
+#define SET_TX_DESC_QSEL(__tx_desc, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x04, 8, 5, __value)
+#define GET_TX_DESC_QSEL(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x04, 8, 5)
+#define SET_TX_DESC_MACID(__tx_desc, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x04, 0, 7, __value)
+#define GET_TX_DESC_MACID(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x04, 0, 7)
+
+/*TXDESC_WORD2*/
+
+#define SET_TX_DESC_HW_AES_IV(__tx_desc, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 31, 1, __value)
+#define GET_TX_DESC_HW_AES_IV(__tx_desc)                                       \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x08, 31, 1)
+
+#define SET_TX_DESC_FTM_EN(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 30, 1, __value)
+#define GET_TX_DESC_FTM_EN(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x08, 30, 1)
+
+#define SET_TX_DESC_G_ID(__tx_desc, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 24, 6, __value)
+#define GET_TX_DESC_G_ID(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x08, 24, 6)
+#define SET_TX_DESC_BT_NULL(__tx_desc, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 23, 1, __value)
+#define GET_TX_DESC_BT_NULL(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x08, 23, 1)
+#define SET_TX_DESC_AMPDU_DENSITY(__tx_desc, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 20, 3, __value)
+#define GET_TX_DESC_AMPDU_DENSITY(__tx_desc)                                   \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x08, 20, 3)
+#ifdef SET_TX_DESC_SPE_RPT
+#undef SET_TX_DESC_SPE_RPT
+#endif
+#define SET_TX_DESC_SPE_RPT(__tx_desc, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 19, 1, __value)
+#define GET_TX_DESC_SPE_RPT(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x08, 19, 1)
+#define SET_TX_DESC_RAW(__tx_desc, __value)                                    \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 18, 1, __value)
+#define GET_TX_DESC_RAW(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x08, 18, 1)
+#define SET_TX_DESC_MOREFRAG(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 17, 1, __value)
+#define GET_TX_DESC_MOREFRAG(__tx_desc)                                        \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x08, 17, 1)
+#define SET_TX_DESC_BK(__tx_desc, __value)                                     \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 16, 1, __value)
+#define GET_TX_DESC_BK(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x08, 16, 1)
+#define SET_TX_DESC_NULL_1(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 15, 1, __value)
+#define GET_TX_DESC_NULL_1(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x08, 15, 1)
+#define SET_TX_DESC_NULL_0(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 14, 1, __value)
+#define GET_TX_DESC_NULL_0(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x08, 14, 1)
+#define SET_TX_DESC_RDG_EN(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 13, 1, __value)
+#define GET_TX_DESC_RDG_EN(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x08, 13, 1)
+#define SET_TX_DESC_AGG_EN(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 12, 1, __value)
+#define GET_TX_DESC_AGG_EN(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x08, 12, 1)
+#define SET_TX_DESC_CCA_RTS(__tx_desc, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 10, 2, __value)
+#define GET_TX_DESC_CCA_RTS(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x08, 10, 2)
+
+#define SET_TX_DESC_TRI_FRAME(__tx_desc, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 9, 1, __value)
+#define GET_TX_DESC_TRI_FRAME(__tx_desc)                                       \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x08, 9, 1)
+
+#define SET_TX_DESC_P_AID(__tx_desc, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x08, 0, 9, __value)
+#define GET_TX_DESC_P_AID(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x08, 0, 9)
+
+/*TXDESC_WORD3*/
+
+#define SET_TX_DESC_AMPDU_MAX_TIME(__tx_desc, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x0C, 24, 8, __value)
+#define GET_TX_DESC_AMPDU_MAX_TIME(__tx_desc)                                  \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x0C, 24, 8)
+#define SET_TX_DESC_NDPA(__tx_desc, __value)                                   \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x0C, 22, 2, __value)
+#define GET_TX_DESC_NDPA(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x0C, 22, 2)
+#define SET_TX_DESC_MAX_AGG_NUM(__tx_desc, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x0C, 17, 5, __value)
+#define GET_TX_DESC_MAX_AGG_NUM(__tx_desc)                                     \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x0C, 17, 5)
+#define SET_TX_DESC_USE_MAX_TIME_EN(__tx_desc, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x0C, 16, 1, __value)
+#define GET_TX_DESC_USE_MAX_TIME_EN(__tx_desc)                                 \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x0C, 16, 1)
+#define SET_TX_DESC_NAVUSEHDR(__tx_desc, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x0C, 15, 1, __value)
+#define GET_TX_DESC_NAVUSEHDR(__tx_desc)                                       \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x0C, 15, 1)
+
+#define SET_TX_DESC_CHK_EN(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x0C, 14, 1, __value)
+#define GET_TX_DESC_CHK_EN(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x0C, 14, 1)
+
+#define SET_TX_DESC_HW_RTS_EN(__tx_desc, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x0C, 13, 1, __value)
+#define GET_TX_DESC_HW_RTS_EN(__tx_desc)                                       \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x0C, 13, 1)
+#define SET_TX_DESC_RTSEN(__tx_desc, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x0C, 12, 1, __value)
+#define GET_TX_DESC_RTSEN(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x0C, 12, 1)
+#define SET_TX_DESC_CTS2SELF(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x0C, 11, 1, __value)
+#define GET_TX_DESC_CTS2SELF(__tx_desc)                                        \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x0C, 11, 1)
+#define SET_TX_DESC_DISDATAFB(__tx_desc, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x0C, 10, 1, __value)
+#define GET_TX_DESC_DISDATAFB(__tx_desc)                                       \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x0C, 10, 1)
+#define SET_TX_DESC_DISRTSFB(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x0C, 9, 1, __value)
+#define GET_TX_DESC_DISRTSFB(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x0C, 9, 1)
+#define SET_TX_DESC_USE_RATE(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x0C, 8, 1, __value)
+#define GET_TX_DESC_USE_RATE(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x0C, 8, 1)
+#define SET_TX_DESC_HW_SSN_SEL(__tx_desc, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x0C, 6, 2, __value)
+#define GET_TX_DESC_HW_SSN_SEL(__tx_desc)                                      \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x0C, 6, 2)
+
+#define SET_TX_DESC_WHEADER_LEN(__tx_desc, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x0C, 0, 5, __value)
+#define GET_TX_DESC_WHEADER_LEN(__tx_desc)                                     \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x0C, 0, 5)
+
+/*TXDESC_WORD4*/
+
+#define SET_TX_DESC_PCTS_MASK_IDX(__tx_desc, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x10, 30, 2, __value)
+#define GET_TX_DESC_PCTS_MASK_IDX(__tx_desc)                                   \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x10, 30, 2)
+#define SET_TX_DESC_PCTS_EN(__tx_desc, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x10, 29, 1, __value)
+#define GET_TX_DESC_PCTS_EN(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x10, 29, 1)
+#define SET_TX_DESC_RTSRATE(__tx_desc, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x10, 24, 5, __value)
+#define GET_TX_DESC_RTSRATE(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x10, 24, 5)
+#define SET_TX_DESC_RTS_DATA_RTY_LMT(__tx_desc, __value)                       \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x10, 18, 6, __value)
+#define GET_TX_DESC_RTS_DATA_RTY_LMT(__tx_desc)                                \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x10, 18, 6)
+#define SET_TX_DESC_RTY_LMT_EN(__tx_desc, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x10, 17, 1, __value)
+#define GET_TX_DESC_RTY_LMT_EN(__tx_desc)                                      \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x10, 17, 1)
+#define SET_TX_DESC_RTS_RTY_LOWEST_RATE(__tx_desc, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x10, 13, 4, __value)
+#define GET_TX_DESC_RTS_RTY_LOWEST_RATE(__tx_desc)                             \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x10, 13, 4)
+#define SET_TX_DESC_DATA_RTY_LOWEST_RATE(__tx_desc, __value)                   \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x10, 8, 5, __value)
+#define GET_TX_DESC_DATA_RTY_LOWEST_RATE(__tx_desc)                            \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x10, 8, 5)
+#define SET_TX_DESC_TRY_RATE(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x10, 7, 1, __value)
+#define GET_TX_DESC_TRY_RATE(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x10, 7, 1)
+#define SET_TX_DESC_DATARATE(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x10, 0, 7, __value)
+#define GET_TX_DESC_DATARATE(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x10, 0, 7)
+
+/*TXDESC_WORD5*/
+
+#define SET_TX_DESC_POLLUTED(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x14, 31, 1, __value)
+#define GET_TX_DESC_POLLUTED(__tx_desc)                                        \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x14, 31, 1)
+
+#define SET_TX_DESC_TXPWR_OFSET(__tx_desc, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x14, 28, 3, __value)
+#define GET_TX_DESC_TXPWR_OFSET(__tx_desc)                                     \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x14, 28, 3)
+#define SET_TX_DESC_TX_ANT(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x14, 24, 4, __value)
+#define GET_TX_DESC_TX_ANT(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x14, 24, 4)
+#define SET_TX_DESC_PORT_ID(__tx_desc, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x14, 21, 3, __value)
+#define GET_TX_DESC_PORT_ID(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x14, 21, 3)
+
+#define SET_TX_DESC_MULTIPLE_PORT(__tx_desc, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x14, 18, 3, __value)
+#define GET_TX_DESC_MULTIPLE_PORT(__tx_desc)                                   \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x14, 18, 3)
+
+#define SET_TX_DESC_SIGNALING_TAPKT_EN(__tx_desc, __value)                     \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x14, 17, 1, __value)
+#define GET_TX_DESC_SIGNALING_TAPKT_EN(__tx_desc)                              \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x14, 17, 1)
+
+#define SET_TX_DESC_RTS_SC(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x14, 13, 4, __value)
+#define GET_TX_DESC_RTS_SC(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x14, 13, 4)
+#define SET_TX_DESC_RTS_SHORT(__tx_desc, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x14, 12, 1, __value)
+#define GET_TX_DESC_RTS_SHORT(__tx_desc)                                       \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x14, 12, 1)
+
+#define SET_TX_DESC_VCS_STBC(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x14, 10, 2, __value)
+#define GET_TX_DESC_VCS_STBC(__tx_desc)                                        \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x14, 10, 2)
+
+#define SET_TX_DESC_DATA_STBC(__tx_desc, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x14, 8, 2, __value)
+#define GET_TX_DESC_DATA_STBC(__tx_desc)                                       \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x14, 8, 2)
+
+#define SET_TX_DESC_DATA_LDPC(__tx_desc, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x14, 7, 1, __value)
+#define GET_TX_DESC_DATA_LDPC(__tx_desc)                                       \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x14, 7, 1)
+
+#define SET_TX_DESC_DATA_BW(__tx_desc, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x14, 5, 2, __value)
+#define GET_TX_DESC_DATA_BW(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x14, 5, 2)
+#define SET_TX_DESC_DATA_SHORT(__tx_desc, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x14, 4, 1, __value)
+#define GET_TX_DESC_DATA_SHORT(__tx_desc)                                      \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x14, 4, 1)
+#define SET_TX_DESC_DATA_SC(__tx_desc, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x14, 0, 4, __value)
+#define GET_TX_DESC_DATA_SC(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x14, 0, 4)
+
+/*TXDESC_WORD6*/
+
+#define SET_TX_DESC_ANTSEL_D(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x18, 30, 2, __value)
+#define GET_TX_DESC_ANTSEL_D(__tx_desc)                                        \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x18, 30, 2)
+#define SET_TX_DESC_ANT_MAPD(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x18, 28, 2, __value)
+#define GET_TX_DESC_ANT_MAPD(__tx_desc)                                        \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x18, 28, 2)
+#define SET_TX_DESC_ANT_MAPC(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x18, 26, 2, __value)
+#define GET_TX_DESC_ANT_MAPC(__tx_desc)                                        \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x18, 26, 2)
+#define SET_TX_DESC_ANT_MAPB(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x18, 24, 2, __value)
+#define GET_TX_DESC_ANT_MAPB(__tx_desc)                                        \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x18, 24, 2)
+#define SET_TX_DESC_ANT_MAPA(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x18, 22, 2, __value)
+#define GET_TX_DESC_ANT_MAPA(__tx_desc)                                        \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x18, 22, 2)
+#define SET_TX_DESC_ANTSEL_C(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x18, 20, 2, __value)
+#define GET_TX_DESC_ANTSEL_C(__tx_desc)                                        \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x18, 20, 2)
+#define SET_TX_DESC_ANTSEL_B(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x18, 18, 2, __value)
+#define GET_TX_DESC_ANTSEL_B(__tx_desc)                                        \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x18, 18, 2)
+
+#define SET_TX_DESC_ANTSEL_A(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x18, 16, 2, __value)
+#define GET_TX_DESC_ANTSEL_A(__tx_desc)                                        \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x18, 16, 2)
+#define SET_TX_DESC_MBSSID(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x18, 12, 4, __value)
+#define GET_TX_DESC_MBSSID(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x18, 12, 4)
+#ifdef SET_TX_DESC_SW_DEFINE
+#undef SET_TX_DESC_SW_DEFINE
+#endif
+#define SET_TX_DESC_SW_DEFINE(__tx_desc, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x18, 0, 12, __value)
+#define GET_TX_DESC_SW_DEFINE(__tx_desc)                                       \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x18, 0, 12)
+
+/*TXDESC_WORD7*/
+
+#define SET_TX_DESC_DMA_TXAGG_NUM(__tx_desc, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x1C, 24, 8, __value)
+#define GET_TX_DESC_DMA_TXAGG_NUM(__tx_desc)                                   \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x1C, 24, 8)
+
+#define SET_TX_DESC_FINAL_DATA_RATE(__tx_desc, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x1C, 24, 8, __value)
+#define GET_TX_DESC_FINAL_DATA_RATE(__tx_desc)                                 \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x1C, 24, 8)
+#define SET_TX_DESC_NTX_MAP(__tx_desc, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x1C, 20, 4, __value)
+#define GET_TX_DESC_NTX_MAP(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x1C, 20, 4)
+
+#define SET_TX_DESC_TX_BUFF_SIZE(__tx_desc, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x1C, 0, 16, __value)
+#define GET_TX_DESC_TX_BUFF_SIZE(__tx_desc)                                    \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x1C, 0, 16)
+#define SET_TX_DESC_TXDESC_CHECKSUM(__tx_desc, __value)                        \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x1C, 0, 16, __value)
+#define GET_TX_DESC_TXDESC_CHECKSUM(__tx_desc)                                 \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x1C, 0, 16)
+#define SET_TX_DESC_TIMESTAMP(__tx_desc, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x1C, 0, 16, __value)
+#define GET_TX_DESC_TIMESTAMP(__tx_desc)                                       \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x1C, 0, 16)
+
+/*TXDESC_WORD8*/
+
+#define SET_TX_DESC_TXWIFI_CP(__tx_desc, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 31, 1, __value)
+#define GET_TX_DESC_TXWIFI_CP(__tx_desc)                                       \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x20, 31, 1)
+#define SET_TX_DESC_MAC_CP(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 30, 1, __value)
+#define GET_TX_DESC_MAC_CP(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x20, 30, 1)
+#define SET_TX_DESC_STW_PKTRE_DIS(__tx_desc, __value)                          \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 29, 1, __value)
+#define GET_TX_DESC_STW_PKTRE_DIS(__tx_desc)                                   \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x20, 29, 1)
+#define SET_TX_DESC_STW_RB_DIS(__tx_desc, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 28, 1, __value)
+#define GET_TX_DESC_STW_RB_DIS(__tx_desc)                                      \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x20, 28, 1)
+#define SET_TX_DESC_STW_RATE_DIS(__tx_desc, __value)                           \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 27, 1, __value)
+#define GET_TX_DESC_STW_RATE_DIS(__tx_desc)                                    \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x20, 27, 1)
+#define SET_TX_DESC_STW_ANT_DIS(__tx_desc, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 26, 1, __value)
+#define GET_TX_DESC_STW_ANT_DIS(__tx_desc)                                     \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x20, 26, 1)
+#define SET_TX_DESC_STW_EN(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 25, 1, __value)
+#define GET_TX_DESC_STW_EN(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x20, 25, 1)
+#define SET_TX_DESC_SMH_EN(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 24, 1, __value)
+#define GET_TX_DESC_SMH_EN(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x20, 24, 1)
+
+#define SET_TX_DESC_TAILPAGE_L(__tx_desc, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 24, 8, __value)
+#define GET_TX_DESC_TAILPAGE_L(__tx_desc)                                      \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x20, 24, 8)
+
+#define SET_TX_DESC_SDIO_DMASEQ(__tx_desc, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 16, 8, __value)
+#define GET_TX_DESC_SDIO_DMASEQ(__tx_desc)                                     \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x20, 16, 8)
+
+#define SET_TX_DESC_NEXTHEADPAGE_L(__tx_desc, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 16, 8, __value)
+#define GET_TX_DESC_NEXTHEADPAGE_L(__tx_desc)                                  \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x20, 16, 8)
+#define SET_TX_DESC_EN_HWSEQ(__tx_desc, __value)                               \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 15, 1, __value)
+#define GET_TX_DESC_EN_HWSEQ(__tx_desc)                                        \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x20, 15, 1)
+
+#define SET_TX_DESC_EN_HWEXSEQ(__tx_desc, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 14, 1, __value)
+#define GET_TX_DESC_EN_HWEXSEQ(__tx_desc)                                      \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x20, 14, 1)
+
+#define SET_TX_DESC_DATA_RC(__tx_desc, __value)                                \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 8, 6, __value)
+#define GET_TX_DESC_DATA_RC(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x20, 8, 6)
+#define SET_TX_DESC_BAR_RTY_TH(__tx_desc, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 6, 2, __value)
+#define GET_TX_DESC_BAR_RTY_TH(__tx_desc)                                      \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x20, 6, 2)
+#define SET_TX_DESC_RTS_RC(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x20, 0, 6, __value)
+#define GET_TX_DESC_RTS_RC(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x20, 0, 6)
+
+/*TXDESC_WORD9*/
+
+#define SET_TX_DESC_TAILPAGE_H(__tx_desc, __value)                             \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x24, 28, 4, __value)
+#define GET_TX_DESC_TAILPAGE_H(__tx_desc)                                      \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x24, 28, 4)
+#define SET_TX_DESC_NEXTHEADPAGE_H(__tx_desc, __value)                         \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x24, 24, 4, __value)
+#define GET_TX_DESC_NEXTHEADPAGE_H(__tx_desc)                                  \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x24, 24, 4)
+
+#define SET_TX_DESC_SW_SEQ(__tx_desc, __value)                                 \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x24, 12, 12, __value)
+#define GET_TX_DESC_SW_SEQ(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x24, 12, 12)
+#define SET_TX_DESC_TXBF_PATH(__tx_desc, __value)                              \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x24, 11, 1, __value)
+#define GET_TX_DESC_TXBF_PATH(__tx_desc)                                       \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x24, 11, 1)
+#define SET_TX_DESC_PADDING_LEN(__tx_desc, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x24, 0, 11, __value)
+#define GET_TX_DESC_PADDING_LEN(__tx_desc)                                     \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x24, 0, 11)
+#define SET_TX_DESC_GROUP_BIT_IE_OFFSET(__tx_desc, __value)                    \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x24, 0, 8, __value)
+#define GET_TX_DESC_GROUP_BIT_IE_OFFSET(__tx_desc)                             \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x24, 0, 8)
+
+/*WORD10*/
+
+#define SET_TX_DESC_MU_DATARATE(__tx_desc, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x28, 8, 8, __value)
+#define GET_TX_DESC_MU_DATARATE(__tx_desc)                                     \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x28, 8, 8)
+#define SET_TX_DESC_MU_RC(__tx_desc, __value)                                  \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x28, 4, 4, __value)
+#define GET_TX_DESC_MU_RC(__tx_desc) LE_BITS_TO_4BYTE(__tx_desc + 0x28, 4, 4)
+#define SET_TX_DESC_SND_PKT_SEL(__tx_desc, __value)                            \
+	SET_BITS_TO_LE_4BYTE(__tx_desc + 0x28, 0, 2, __value)
+#define GET_TX_DESC_SND_PKT_SEL(__tx_desc)                                     \
+	LE_BITS_TO_4BYTE(__tx_desc + 0x28, 0, 2)
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_type.h b/drivers/staging/rtlwifi/halmac/halmac_type.h
new file mode 100644
index 000000000000..0bf842435080
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_type.h
@@ -0,0 +1,1934 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _HALMAC_TYPE_H_
+#define _HALMAC_TYPE_H_
+
+#include "halmac_2_platform.h"
+#include "halmac_fw_info.h"
+#include "halmac_intf_phy_cmd.h"
+
+#define HALMAC_SCAN_CH_NUM_MAX 28
+#define HALMAC_BCN_IE_BMP_SIZE 24 /* ID0~ID191, 192/8=24 */
+#define HALMAC_PHY_PARAMETER_SIZE 12
+#define HALMAC_PHY_PARAMETER_MAX_NUM 128
+#define HALMAC_MAX_SSID_LEN 32
+#define HALMAC_SUPPORT_NLO_NUM 16
+#define HALMAC_SUPPORT_PROBE_REQ_NUM 8
+#define HALMC_DDMA_POLLING_COUNT 1000
+#define API_ARRAY_SIZE 32
+
+/* platform api */
+#define PLATFORM_SDIO_CMD52_READ                                               \
+	halmac_adapter->halmac_platform_api->SDIO_CMD52_READ
+#define PLATFORM_SDIO_CMD53_READ_8                                             \
+	halmac_adapter->halmac_platform_api->SDIO_CMD53_READ_8
+#define PLATFORM_SDIO_CMD53_READ_16                                            \
+	halmac_adapter->halmac_platform_api->SDIO_CMD53_READ_16
+#define PLATFORM_SDIO_CMD53_READ_32                                            \
+	halmac_adapter->halmac_platform_api->SDIO_CMD53_READ_32
+#define PLATFORM_SDIO_CMD53_READ_N                                             \
+	halmac_adapter->halmac_platform_api->SDIO_CMD53_READ_N
+#define PLATFORM_SDIO_CMD52_WRITE                                              \
+	halmac_adapter->halmac_platform_api->SDIO_CMD52_WRITE
+#define PLATFORM_SDIO_CMD53_WRITE_8                                            \
+	halmac_adapter->halmac_platform_api->SDIO_CMD53_WRITE_8
+#define PLATFORM_SDIO_CMD53_WRITE_16                                           \
+	halmac_adapter->halmac_platform_api->SDIO_CMD53_WRITE_16
+#define PLATFORM_SDIO_CMD53_WRITE_32                                           \
+	halmac_adapter->halmac_platform_api->SDIO_CMD53_WRITE_32
+
+#define PLATFORM_REG_READ_8 halmac_adapter->halmac_platform_api->REG_READ_8
+#define PLATFORM_REG_READ_16 halmac_adapter->halmac_platform_api->REG_READ_16
+#define PLATFORM_REG_READ_32 halmac_adapter->halmac_platform_api->REG_READ_32
+#define PLATFORM_REG_WRITE_8 halmac_adapter->halmac_platform_api->REG_WRITE_8
+#define PLATFORM_REG_WRITE_16 halmac_adapter->halmac_platform_api->REG_WRITE_16
+#define PLATFORM_REG_WRITE_32 halmac_adapter->halmac_platform_api->REG_WRITE_32
+
+#define PLATFORM_SEND_RSVD_PAGE                                                \
+	halmac_adapter->halmac_platform_api->SEND_RSVD_PAGE
+#define PLATFORM_SEND_H2C_PKT halmac_adapter->halmac_platform_api->SEND_H2C_PKT
+
+#define PLATFORM_EVENT_INDICATION                                              \
+	halmac_adapter->halmac_platform_api->EVENT_INDICATION
+
+#define HALMAC_RT_TRACE(drv_adapter, comp, level, fmt, ...)                    \
+	RT_TRACE(drv_adapter, COMP_HALMAC, level, fmt, ##__VA_ARGS__)
+
+#define HALMAC_REG_READ_8 halmac_api->halmac_reg_read_8
+#define HALMAC_REG_READ_16 halmac_api->halmac_reg_read_16
+#define HALMAC_REG_READ_32 halmac_api->halmac_reg_read_32
+#define HALMAC_REG_WRITE_8 halmac_api->halmac_reg_write_8
+#define HALMAC_REG_WRITE_16 halmac_api->halmac_reg_write_16
+#define HALMAC_REG_WRITE_32 halmac_api->halmac_reg_write_32
+#define HALMAC_REG_SDIO_CMD53_READ_N halmac_api->halmac_reg_sdio_cmd53_read_n
+
+/* Swap Little-endian <-> Big-endia*/
+
+/*1->Little endian 0->Big endian*/
+#if HALMAC_SYSTEM_ENDIAN
+#else
+#endif
+
+#define HALMAC_ALIGN(x, a) HALMAC_ALIGN_MASK(x, (a) - 1)
+#define HALMAC_ALIGN_MASK(x, mask) (((x) + (mask)) & ~(mask))
+
+/* HALMAC API return status*/
+enum halmac_ret_status {
+	HALMAC_RET_SUCCESS = 0x00,
+	HALMAC_RET_SUCCESS_ENQUEUE = 0x01,
+	HALMAC_RET_PLATFORM_API_NULL = 0x02,
+	HALMAC_RET_EFUSE_SIZE_INCORRECT = 0x03,
+	HALMAC_RET_MALLOC_FAIL = 0x04,
+	HALMAC_RET_ADAPTER_INVALID = 0x05,
+	HALMAC_RET_ITF_INCORRECT = 0x06,
+	HALMAC_RET_DLFW_FAIL = 0x07,
+	HALMAC_RET_PORT_NOT_SUPPORT = 0x08,
+	HALMAC_RET_TRXMODE_NOT_SUPPORT = 0x09,
+	HALMAC_RET_INIT_LLT_FAIL = 0x0A,
+	HALMAC_RET_POWER_STATE_INVALID = 0x0B,
+	HALMAC_RET_H2C_ACK_NOT_RECEIVED = 0x0C,
+	HALMAC_RET_DL_RSVD_PAGE_FAIL = 0x0D,
+	HALMAC_RET_EFUSE_R_FAIL = 0x0E,
+	HALMAC_RET_EFUSE_W_FAIL = 0x0F,
+	HALMAC_RET_H2C_SW_RES_FAIL = 0x10,
+	HALMAC_RET_SEND_H2C_FAIL = 0x11,
+	HALMAC_RET_PARA_NOT_SUPPORT = 0x12,
+	HALMAC_RET_PLATFORM_API_INCORRECT = 0x13,
+	HALMAC_RET_ENDIAN_ERR = 0x14,
+	HALMAC_RET_FW_SIZE_ERR = 0x15,
+	HALMAC_RET_TRX_MODE_NOT_SUPPORT = 0x16,
+	HALMAC_RET_FAIL = 0x17,
+	HALMAC_RET_CHANGE_PS_FAIL = 0x18,
+	HALMAC_RET_CFG_PARA_FAIL = 0x19,
+	HALMAC_RET_UPDATE_PROBE_FAIL = 0x1A,
+	HALMAC_RET_SCAN_FAIL = 0x1B,
+	HALMAC_RET_STOP_SCAN_FAIL = 0x1C,
+	HALMAC_RET_BCN_PARSER_CMD_FAIL = 0x1D,
+	HALMAC_RET_POWER_ON_FAIL = 0x1E,
+	HALMAC_RET_POWER_OFF_FAIL = 0x1F,
+	HALMAC_RET_RX_AGG_MODE_FAIL = 0x20,
+	HALMAC_RET_DATA_BUF_NULL = 0x21,
+	HALMAC_RET_DATA_SIZE_INCORRECT = 0x22,
+	HALMAC_RET_QSEL_INCORRECT = 0x23,
+	HALMAC_RET_DMA_MAP_INCORRECT = 0x24,
+	HALMAC_RET_SEND_ORIGINAL_H2C_FAIL = 0x25,
+	HALMAC_RET_DDMA_FAIL = 0x26,
+	HALMAC_RET_FW_CHECKSUM_FAIL = 0x27,
+	HALMAC_RET_PWRSEQ_POLLING_FAIL = 0x28,
+	HALMAC_RET_PWRSEQ_CMD_INCORRECT = 0x29,
+	HALMAC_RET_WRITE_DATA_FAIL = 0x2A,
+	HALMAC_RET_DUMP_FIFOSIZE_INCORRECT = 0x2B,
+	HALMAC_RET_NULL_POINTER = 0x2C,
+	HALMAC_RET_PROBE_NOT_FOUND = 0x2D,
+	HALMAC_RET_FW_NO_MEMORY = 0x2E,
+	HALMAC_RET_H2C_STATUS_ERR = 0x2F,
+	HALMAC_RET_GET_H2C_SPACE_ERR = 0x30,
+	HALMAC_RET_H2C_SPACE_FULL = 0x31,
+	HALMAC_RET_DATAPACK_NO_FOUND = 0x32,
+	HALMAC_RET_CANNOT_FIND_H2C_RESOURCE = 0x33,
+	HALMAC_RET_TX_DMA_ERR = 0x34,
+	HALMAC_RET_RX_DMA_ERR = 0x35,
+	HALMAC_RET_CHIP_NOT_SUPPORT = 0x36,
+	HALMAC_RET_FREE_SPACE_NOT_ENOUGH = 0x37,
+	HALMAC_RET_CH_SW_SEQ_WRONG = 0x38,
+	HALMAC_RET_CH_SW_NO_BUF = 0x39,
+	HALMAC_RET_SW_CASE_NOT_SUPPORT = 0x3A,
+	HALMAC_RET_CONVERT_SDIO_OFFSET_FAIL = 0x3B,
+	HALMAC_RET_INVALID_SOUNDING_SETTING = 0x3C,
+	HALMAC_RET_GEN_INFO_NOT_SENT = 0x3D,
+	HALMAC_RET_STATE_INCORRECT = 0x3E,
+	HALMAC_RET_H2C_BUSY = 0x3F,
+	HALMAC_RET_INVALID_FEATURE_ID = 0x40,
+	HALMAC_RET_BUFFER_TOO_SMALL = 0x41,
+	HALMAC_RET_ZERO_LEN_RSVD_PACKET = 0x42,
+	HALMAC_RET_BUSY_STATE = 0x43,
+	HALMAC_RET_ERROR_STATE = 0x44,
+	HALMAC_RET_API_INVALID = 0x45,
+	HALMAC_RET_POLLING_BCN_VALID_FAIL = 0x46,
+	HALMAC_RET_SDIO_LEAVE_SUSPEND_FAIL = 0x47,
+	HALMAC_RET_EEPROM_PARSING_FAIL = 0x48,
+	HALMAC_RET_EFUSE_NOT_ENOUGH = 0x49,
+	HALMAC_RET_WRONG_ARGUMENT = 0x4A,
+	HALMAC_RET_NOT_SUPPORT = 0x4B,
+	HALMAC_RET_C2H_NOT_HANDLED = 0x4C,
+	HALMAC_RET_PARA_SENDING = 0x4D,
+	HALMAC_RET_CFG_DLFW_SIZE_FAIL = 0x4E,
+	HALMAC_RET_CFG_TXFIFO_PAGE_FAIL = 0x4F,
+	HALMAC_RET_SWITCH_CASE_ERROR = 0x50,
+	HALMAC_RET_EFUSE_BANK_INCORRECT = 0x51,
+	HALMAC_RET_SWITCH_EFUSE_BANK_FAIL = 0x52,
+	HALMAC_RET_USB_MODE_UNCHANGE = 0x53,
+	HALMAC_RET_NO_DLFW = 0x54,
+	HALMAC_RET_USB2_3_SWITCH_UNSUPPORT = 0x55,
+	HALMAC_RET_BIP_NO_SUPPORT = 0x56,
+	HALMAC_RET_ENTRY_INDEX_ERROR = 0x57,
+	HALMAC_RET_ENTRY_KEY_ID_ERROR = 0x58,
+	HALMAC_RET_DRV_DL_ERR = 0x59,
+	HALMAC_RET_OQT_NOT_ENOUGH = 0x5A,
+	HALMAC_RET_PWR_UNCHANGE = 0x5B,
+	HALMAC_RET_FW_NO_SUPPORT = 0x60,
+	HALMAC_RET_TXFIFO_NO_EMPTY = 0x61,
+};
+
+enum halmac_mac_clock_hw_def {
+	HALMAC_MAC_CLOCK_HW_DEF_80M = 0,
+	HALMAC_MAC_CLOCK_HW_DEF_40M = 1,
+	HALMAC_MAC_CLOCK_HW_DEF_20M = 2,
+};
+
+/* Rx aggregation parameters */
+enum halmac_normal_rxagg_th_to {
+	HALMAC_NORMAL_RXAGG_THRESHOLD = 0xFF,
+	HALMAC_NORMAL_RXAGG_TIMEOUT = 0x01,
+};
+
+enum halmac_loopback_rxagg_th_to {
+	HALMAC_LOOPBACK_RXAGG_THRESHOLD = 0xFF,
+	HALMAC_LOOPBACK_RXAGG_TIMEOUT = 0x01,
+};
+
+/* Chip ID*/
+enum halmac_chip_id {
+	HALMAC_CHIP_ID_8822B = 0,
+	HALMAC_CHIP_ID_8821C = 1,
+	HALMAC_CHIP_ID_8814B = 2,
+	HALMAC_CHIP_ID_8197F = 3,
+	HALMAC_CHIP_ID_UNDEFINE = 0x7F,
+};
+
+enum halmac_chip_id_hw_def {
+	HALMAC_CHIP_ID_HW_DEF_8723A = 0x01,
+	HALMAC_CHIP_ID_HW_DEF_8188E = 0x02,
+	HALMAC_CHIP_ID_HW_DEF_8881A = 0x03,
+	HALMAC_CHIP_ID_HW_DEF_8812A = 0x04,
+	HALMAC_CHIP_ID_HW_DEF_8821A = 0x05,
+	HALMAC_CHIP_ID_HW_DEF_8723B = 0x06,
+	HALMAC_CHIP_ID_HW_DEF_8192E = 0x07,
+	HALMAC_CHIP_ID_HW_DEF_8814A = 0x08,
+	HALMAC_CHIP_ID_HW_DEF_8821C = 0x09,
+	HALMAC_CHIP_ID_HW_DEF_8822B = 0x0A,
+	HALMAC_CHIP_ID_HW_DEF_8703B = 0x0B,
+	HALMAC_CHIP_ID_HW_DEF_8188F = 0x0C,
+	HALMAC_CHIP_ID_HW_DEF_8192F = 0x0D,
+	HALMAC_CHIP_ID_HW_DEF_8197F = 0x0E,
+	HALMAC_CHIP_ID_HW_DEF_8723D = 0x0F,
+	HALMAC_CHIP_ID_HW_DEF_8814B = 0x10,
+	HALMAC_CHIP_ID_HW_DEF_UNDEFINE = 0x7F,
+	HALMAC_CHIP_ID_HW_DEF_PS = 0xEA,
+};
+
+/* Chip Version*/
+enum halmac_chip_ver {
+	HALMAC_CHIP_VER_A_CUT = 0x00,
+	HALMAC_CHIP_VER_B_CUT = 0x01,
+	HALMAC_CHIP_VER_C_CUT = 0x02,
+	HALMAC_CHIP_VER_D_CUT = 0x03,
+	HALMAC_CHIP_VER_E_CUT = 0x04,
+	HALMAC_CHIP_VER_F_CUT = 0x05,
+	HALMAC_CHIP_VER_TEST = 0xFF,
+	HALMAC_CHIP_VER_UNDEFINE = 0x7FFF,
+};
+
+/* Network type select */
+enum halmac_network_type_select {
+	HALMAC_NETWORK_NO_LINK = 0,
+	HALMAC_NETWORK_ADHOC = 1,
+	HALMAC_NETWORK_INFRASTRUCTURE = 2,
+	HALMAC_NETWORK_AP = 3,
+	HALMAC_NETWORK_UNDEFINE = 0x7F,
+};
+
+/* Transfer mode select */
+enum halmac_trnsfer_mode_select {
+	HALMAC_TRNSFER_NORMAL = 0x0,
+	HALMAC_TRNSFER_LOOPBACK_DIRECT = 0xB,
+	HALMAC_TRNSFER_LOOPBACK_DELAY = 0x3,
+	HALMAC_TRNSFER_UNDEFINE = 0x7F,
+};
+
+/* Queue select */
+enum halmac_dma_mapping {
+	HALMAC_DMA_MAPPING_EXTRA = 0,
+	HALMAC_DMA_MAPPING_LOW = 1,
+	HALMAC_DMA_MAPPING_NORMAL = 2,
+	HALMAC_DMA_MAPPING_HIGH = 3,
+	HALMAC_DMA_MAPPING_UNDEFINE = 0x7F,
+};
+
+#define HALMAC_MAP2_HQ HALMAC_DMA_MAPPING_HIGH
+#define HALMAC_MAP2_NQ HALMAC_DMA_MAPPING_NORMAL
+#define HALMAC_MAP2_LQ HALMAC_DMA_MAPPING_LOW
+#define HALMAC_MAP2_EXQ HALMAC_DMA_MAPPING_EXTRA
+#define HALMAC_MAP2_UNDEF HALMAC_DMA_MAPPING_UNDEFINE
+
+/* TXDESC queue select TID */
+enum halmac_txdesc_queue_tid {
+	HALMAC_TXDESC_QSEL_TID0 = 0,
+	HALMAC_TXDESC_QSEL_TID1 = 1,
+	HALMAC_TXDESC_QSEL_TID2 = 2,
+	HALMAC_TXDESC_QSEL_TID3 = 3,
+	HALMAC_TXDESC_QSEL_TID4 = 4,
+	HALMAC_TXDESC_QSEL_TID5 = 5,
+	HALMAC_TXDESC_QSEL_TID6 = 6,
+	HALMAC_TXDESC_QSEL_TID7 = 7,
+	HALMAC_TXDESC_QSEL_TID8 = 8,
+	HALMAC_TXDESC_QSEL_TID9 = 9,
+	HALMAC_TXDESC_QSEL_TIDA = 10,
+	HALMAC_TXDESC_QSEL_TIDB = 11,
+	HALMAC_TXDESC_QSEL_TIDC = 12,
+	HALMAC_TXDESC_QSEL_TIDD = 13,
+	HALMAC_TXDESC_QSEL_TIDE = 14,
+	HALMAC_TXDESC_QSEL_TIDF = 15,
+
+	HALMAC_TXDESC_QSEL_BEACON = 0x10,
+	HALMAC_TXDESC_QSEL_HIGH = 0x11,
+	HALMAC_TXDESC_QSEL_MGT = 0x12,
+	HALMAC_TXDESC_QSEL_H2C_CMD = 0x13,
+
+	HALMAC_TXDESC_QSEL_UNDEFINE = 0x7F,
+};
+
+enum halmac_ptcl_queue {
+	HALMAC_PTCL_QUEUE_VO = 0x0,
+	HALMAC_PTCL_QUEUE_VI = 0x1,
+	HALMAC_PTCL_QUEUE_BE = 0x2,
+	HALMAC_PTCL_QUEUE_BK = 0x3,
+	HALMAC_PTCL_QUEUE_MG = 0x4,
+	HALMAC_PTCL_QUEUE_HI = 0x5,
+	HALMAC_PTCL_QUEUE_NUM = 0x6,
+	HALMAC_PTCL_QUEUE_UNDEFINE = 0x7F,
+};
+
+enum halmac_queue_select {
+	HALMAC_QUEUE_SELECT_VO = HALMAC_TXDESC_QSEL_TID6,
+	HALMAC_QUEUE_SELECT_VI = HALMAC_TXDESC_QSEL_TID4,
+	HALMAC_QUEUE_SELECT_BE = HALMAC_TXDESC_QSEL_TID0,
+	HALMAC_QUEUE_SELECT_BK = HALMAC_TXDESC_QSEL_TID1,
+	HALMAC_QUEUE_SELECT_VO_V2 = HALMAC_TXDESC_QSEL_TID7,
+	HALMAC_QUEUE_SELECT_VI_V2 = HALMAC_TXDESC_QSEL_TID5,
+	HALMAC_QUEUE_SELECT_BE_V2 = HALMAC_TXDESC_QSEL_TID3,
+	HALMAC_QUEUE_SELECT_BK_V2 = HALMAC_TXDESC_QSEL_TID2,
+	HALMAC_QUEUE_SELECT_BCN = HALMAC_TXDESC_QSEL_BEACON,
+	HALMAC_QUEUE_SELECT_HIGH = HALMAC_TXDESC_QSEL_HIGH,
+	HALMAC_QUEUE_SELECT_MGNT = HALMAC_TXDESC_QSEL_MGT,
+	HALMAC_QUEUE_SELECT_CMD = HALMAC_TXDESC_QSEL_H2C_CMD,
+	HALMAC_QUEUE_SELECT_UNDEFINE = 0x7F,
+};
+
+/* USB burst size */
+enum halmac_usb_burst_size {
+	HALMAC_USB_BURST_SIZE_3_0 = 0x0,
+	HALMAC_USB_BURST_SIZE_2_0_HSPEED = 0x1,
+	HALMAC_USB_BURST_SIZE_2_0_FSPEED = 0x2,
+	HALMAC_USB_BURST_SIZE_2_0_OTHERS = 0x3,
+	HALMAC_USB_BURST_SIZE_UNDEFINE = 0x7F,
+};
+
+/* HAL API  function parameters*/
+enum halmac_interface {
+	HALMAC_INTERFACE_PCIE = 0x0,
+	HALMAC_INTERFACE_USB = 0x1,
+	HALMAC_INTERFACE_SDIO = 0x2,
+	HALMAC_INTERFACE_AXI = 0x3,
+	HALMAC_INTERFACE_UNDEFINE = 0x7F,
+};
+
+enum halmac_rx_agg_mode {
+	HALMAC_RX_AGG_MODE_NONE = 0x0,
+	HALMAC_RX_AGG_MODE_DMA = 0x1,
+	HALMAC_RX_AGG_MODE_USB = 0x2,
+	HALMAC_RX_AGG_MODE_UNDEFINE = 0x7F,
+};
+
+struct halmac_rxagg_th {
+	u8 drv_define;
+	u8 timeout;
+	u8 size;
+};
+
+struct halmac_rxagg_cfg {
+	enum halmac_rx_agg_mode mode;
+	struct halmac_rxagg_th threshold;
+};
+
+enum halmac_mac_power {
+	HALMAC_MAC_POWER_OFF = 0x0,
+	HALMAC_MAC_POWER_ON = 0x1,
+	HALMAC_MAC_POWER_UNDEFINE = 0x7F,
+};
+
+enum halmac_ps_state {
+	HALMAC_PS_STATE_ACT = 0x0,
+	HALMAC_PS_STATE_LPS = 0x1,
+	HALMAC_PS_STATE_IPS = 0x2,
+	HALMAC_PS_STATE_UNDEFINE = 0x7F,
+};
+
+enum halmac_trx_mode {
+	HALMAC_TRX_MODE_NORMAL = 0x0,
+	HALMAC_TRX_MODE_TRXSHARE = 0x1,
+	HALMAC_TRX_MODE_WMM = 0x2,
+	HALMAC_TRX_MODE_P2P = 0x3,
+	HALMAC_TRX_MODE_LOOPBACK = 0x4,
+	HALMAC_TRX_MODE_DELAY_LOOPBACK = 0x5,
+	HALMAC_TRX_MODE_MAX = 0x6,
+	HALMAC_TRX_MODE_WMM_LINUX = 0x7E,
+	HALMAC_TRX_MODE_UNDEFINE = 0x7F,
+};
+
+enum halmac_wireless_mode {
+	HALMAC_WIRELESS_MODE_B = 0x0,
+	HALMAC_WIRELESS_MODE_G = 0x1,
+	HALMAC_WIRELESS_MODE_N = 0x2,
+	HALMAC_WIRELESS_MODE_AC = 0x3,
+	HALMAC_WIRELESS_MODE_UNDEFINE = 0x7F,
+};
+
+enum halmac_bw {
+	HALMAC_BW_20 = 0x00,
+	HALMAC_BW_40 = 0x01,
+	HALMAC_BW_80 = 0x02,
+	HALMAC_BW_160 = 0x03,
+	HALMAC_BW_5 = 0x04,
+	HALMAC_BW_10 = 0x05,
+	HALMAC_BW_MAX = 0x06,
+	HALMAC_BW_UNDEFINE = 0x7F,
+};
+
+enum halmac_efuse_read_cfg {
+	HALMAC_EFUSE_R_AUTO = 0x00,
+	HALMAC_EFUSE_R_DRV = 0x01,
+	HALMAC_EFUSE_R_FW = 0x02,
+	HALMAC_EFUSE_R_UNDEFINE = 0x7F,
+};
+
+enum halmac_dlfw_mem {
+	HALMAC_DLFW_MEM_EMEM = 0x00,
+	HALMAC_DLFW_MEM_UNDEFINE = 0x7F,
+};
+
+struct halmac_tx_desc {
+	u32 dword0;
+	u32 dword1;
+	u32 dword2;
+	u32 dword3;
+	u32 dword4;
+	u32 dword5;
+	u32 dword6;
+	u32 dword7;
+	u32 dword8;
+	u32 dword9;
+	u32 dword10;
+	u32 dword11;
+};
+
+struct halmac_rx_desc {
+	u32 dword0;
+	u32 dword1;
+	u32 dword2;
+	u32 dword3;
+	u32 dword4;
+	u32 dword5;
+};
+
+struct halmac_fwlps_option {
+	u8 mode;
+	u8 clk_request;
+	u8 rlbm;
+	u8 smart_ps;
+	u8 awake_interval;
+	u8 all_queue_uapsd;
+	u8 pwr_state;
+	u8 low_pwr_rx_beacon;
+	u8 ant_auto_switch;
+	u8 ps_allow_bt_high_priority;
+	u8 protect_bcn;
+	u8 silence_period;
+	u8 fast_bt_connect;
+	u8 two_antenna_en;
+	u8 adopt_user_setting;
+	u8 drv_bcn_early_shift;
+	bool enter_32K;
+};
+
+struct halmac_fwips_option {
+	u8 adopt_user_setting;
+};
+
+struct halmac_wowlan_option {
+	u8 adopt_user_setting;
+};
+
+struct halmac_bcn_ie_info {
+	u8 func_en;
+	u8 size_th;
+	u8 timeout;
+	u8 ie_bmp[HALMAC_BCN_IE_BMP_SIZE];
+};
+
+enum halmac_reg_type {
+	HALMAC_REG_TYPE_MAC = 0x0,
+	HALMAC_REG_TYPE_BB = 0x1,
+	HALMAC_REG_TYPE_RF = 0x2,
+	HALMAC_REG_TYPE_UNDEFINE = 0x7F,
+};
+
+enum halmac_parameter_cmd {
+	/* HALMAC_PARAMETER_CMD_LLT				= 0x1, */
+	/* HALMAC_PARAMETER_CMD_R_EFUSE			= 0x2, */
+	/* HALMAC_PARAMETER_CMD_EFUSE_PATCH	= 0x3, */
+	HALMAC_PARAMETER_CMD_MAC_W8 = 0x4,
+	HALMAC_PARAMETER_CMD_MAC_W16 = 0x5,
+	HALMAC_PARAMETER_CMD_MAC_W32 = 0x6,
+	HALMAC_PARAMETER_CMD_RF_W = 0x7,
+	HALMAC_PARAMETER_CMD_BB_W8 = 0x8,
+	HALMAC_PARAMETER_CMD_BB_W16 = 0x9,
+	HALMAC_PARAMETER_CMD_BB_W32 = 0XA,
+	HALMAC_PARAMETER_CMD_DELAY_US = 0X10,
+	HALMAC_PARAMETER_CMD_DELAY_MS = 0X11,
+	HALMAC_PARAMETER_CMD_END = 0XFF,
+};
+
+union halmac_parameter_content {
+	struct _MAC_REG_W {
+		u32 value;
+		u32 msk;
+		u16 offset;
+		u8 msk_en;
+	} MAC_REG_W;
+	struct _BB_REG_W {
+		u32 value;
+		u32 msk;
+		u16 offset;
+		u8 msk_en;
+	} BB_REG_W;
+	struct _RF_REG_W {
+		u32 value;
+		u32 msk;
+		u8 offset;
+		u8 msk_en;
+		u8 rf_path;
+	} RF_REG_W;
+	struct _DELAY_TIME {
+		u32 rsvd1;
+		u32 rsvd2;
+		u16 delay_time;
+		u8 rsvd3;
+	} DELAY_TIME;
+};
+
+struct halmac_phy_parameter_info {
+	enum halmac_parameter_cmd cmd_id;
+	union halmac_parameter_content content;
+};
+
+struct halmac_h2c_info {
+	u16 h2c_seq_num; /* H2C sequence number */
+	u8 in_use; /* 0 : empty 1 : used */
+	enum halmac_h2c_return_code status;
+};
+
+struct halmac_pg_efuse_info {
+	u8 *efuse_map;
+	u32 efuse_map_size;
+	u8 *efuse_mask;
+	u32 efuse_mask_size;
+};
+
+struct halmac_txagg_buff_info {
+	u8 *tx_agg_buf;
+	u8 *curr_pkt_buf;
+	u32 avai_buf_size;
+	u32 total_pkt_size;
+	u8 agg_num;
+};
+
+struct halmac_config_para_info {
+	u32 para_buf_size; /* Parameter buffer size */
+	u8 *cfg_para_buf; /* Buffer for config parameter */
+	u8 *para_buf_w; /* Write pointer of the parameter buffer */
+	u32 para_num; /* Parameter numbers in parameter buffer */
+	u32 avai_para_buf_size; /* Free size of parameter buffer */
+	u32 offset_accumulation;
+	u32 value_accumulation;
+	enum halmac_data_type data_type; /*DataType which is passed to FW*/
+	u8 datapack_segment; /*DataPack Segment, from segment0...*/
+	bool full_fifo_mode; /* Used full tx fifo to save cfg parameter */
+};
+
+struct halmac_hw_config_info {
+	u32 efuse_size; /* Record efuse size */
+	u32 eeprom_size; /* Record eeprom size */
+	u32 bt_efuse_size; /* Record BT efuse size */
+	u32 tx_fifo_size; /* Record tx fifo size */
+	u32 rx_fifo_size; /* Record rx fifo size */
+	u8 txdesc_size; /* Record tx desc size */
+	u8 rxdesc_size; /* Record rx desc size */
+	u32 page_size; /* Record page size */
+	u16 tx_align_size;
+	u8 page_size_2_power;
+	u8 cam_entry_num; /* Record CAM entry number */
+};
+
+struct halmac_sdio_free_space {
+	u16 high_queue_number; /* Free space of HIQ */
+	u16 normal_queue_number; /* Free space of MIDQ */
+	u16 low_queue_number; /* Free space of LOWQ */
+	u16 public_queue_number; /* Free space of PUBQ */
+	u16 extra_queue_number; /* Free space of EXBQ */
+	u8 ac_oqt_number;
+	u8 non_ac_oqt_number;
+	u8 ac_empty;
+};
+
+enum hal_fifo_sel {
+	HAL_FIFO_SEL_TX,
+	HAL_FIFO_SEL_RX,
+	HAL_FIFO_SEL_RSVD_PAGE,
+	HAL_FIFO_SEL_REPORT,
+	HAL_FIFO_SEL_LLT,
+};
+
+enum halmac_drv_info {
+	HALMAC_DRV_INFO_NONE, /* No information is appended in rx_pkt */
+	HALMAC_DRV_INFO_PHY_STATUS, /* PHY status is appended after rx_desc */
+	HALMAC_DRV_INFO_PHY_SNIFFER, /* PHY status and sniffer info appended */
+	HALMAC_DRV_INFO_PHY_PLCP, /* PHY status and plcp header are appended */
+	HALMAC_DRV_INFO_UNDEFINE,
+};
+
+struct halmac_bt_coex_cmd {
+	u8 element_id;
+	u8 op_code;
+	u8 op_code_ver;
+	u8 req_num;
+	u8 data0;
+	u8 data1;
+	u8 data2;
+	u8 data3;
+	u8 data4;
+};
+
+enum halmac_pri_ch_idx {
+	HALMAC_CH_IDX_UNDEFINE = 0,
+	HALMAC_CH_IDX_1 = 1,
+	HALMAC_CH_IDX_2 = 2,
+	HALMAC_CH_IDX_3 = 3,
+	HALMAC_CH_IDX_4 = 4,
+	HALMAC_CH_IDX_MAX = 5,
+};
+
+struct halmac_ch_info {
+	enum halmac_cs_action_id action_id;
+	enum halmac_bw bw;
+	enum halmac_pri_ch_idx pri_ch_idx;
+	u8 channel;
+	u8 timeout;
+	u8 extra_info;
+};
+
+struct halmac_ch_extra_info {
+	u8 extra_info;
+	enum halmac_cs_extra_action_id extra_action_id;
+	u8 extra_info_size;
+	u8 *extra_info_data;
+};
+
+enum halmac_cs_periodic_option {
+	HALMAC_CS_PERIODIC_NONE,
+	HALMAC_CS_PERIODIC_NORMAL,
+	HALMAC_CS_PERIODIC_2_PHASE,
+	HALMAC_CS_PERIODIC_SEAMLESS,
+};
+
+struct halmac_ch_switch_option {
+	enum halmac_bw dest_bw;
+	enum halmac_cs_periodic_option periodic_option;
+	enum halmac_pri_ch_idx dest_pri_ch_idx;
+	/* u32 tsf_high; */
+	u32 tsf_low;
+	bool switch_en;
+	u8 dest_ch_en;
+	u8 absolute_time_en;
+	u8 dest_ch;
+	u8 normal_period;
+	u8 normal_cycle;
+	u8 phase_2_period;
+};
+
+struct halmac_fw_version {
+	u16 version;
+	u8 sub_version;
+	u8 sub_index;
+	u16 h2c_version;
+};
+
+enum halmac_rf_type {
+	HALMAC_RF_1T2R = 0,
+	HALMAC_RF_2T4R = 1,
+	HALMAC_RF_2T2R = 2,
+	HALMAC_RF_2T3R = 3,
+	HALMAC_RF_1T1R = 4,
+	HALMAC_RF_2T2R_GREEN = 5,
+	HALMAC_RF_3T3R = 6,
+	HALMAC_RF_3T4R = 7,
+	HALMAC_RF_4T4R = 8,
+	HALMAC_RF_MAX_TYPE = 0xF,
+};
+
+struct halmac_general_info {
+	u8 rfe_type;
+	enum halmac_rf_type rf_type;
+};
+
+struct halmac_pwr_tracking_para {
+	u8 enable;
+	u8 tx_pwr_index;
+	u8 pwr_tracking_offset_value;
+	u8 tssi_value;
+};
+
+struct halmac_pwr_tracking_option {
+	u8 type;
+	u8 bbswing_index;
+	struct halmac_pwr_tracking_para
+		pwr_tracking_para[4]; /* pathA, pathB, pathC, pathD */
+};
+
+struct halmac_nlo_cfg {
+	u8 num_of_ssid;
+	u8 num_of_hidden_ap;
+	u8 rsvd[2];
+	u32 pattern_check;
+	u32 rsvd1;
+	u32 rsvd2;
+	u8 ssid_len[HALMAC_SUPPORT_NLO_NUM];
+	u8 chiper_type[HALMAC_SUPPORT_NLO_NUM];
+	u8 rsvd3[HALMAC_SUPPORT_NLO_NUM];
+	u8 loc_probe_req[HALMAC_SUPPORT_PROBE_REQ_NUM];
+	u8 rsvd4[56];
+	u8 ssid[HALMAC_SUPPORT_NLO_NUM][HALMAC_MAX_SSID_LEN];
+};
+
+enum halmac_data_rate {
+	HALMAC_CCK1,
+	HALMAC_CCK2,
+	HALMAC_CCK5_5,
+	HALMAC_CCK11,
+	HALMAC_OFDM6,
+	HALMAC_OFDM9,
+	HALMAC_OFDM12,
+	HALMAC_OFDM18,
+	HALMAC_OFDM24,
+	HALMAC_OFDM36,
+	HALMAC_OFDM48,
+	HALMAC_OFDM54,
+	HALMAC_MCS0,
+	HALMAC_MCS1,
+	HALMAC_MCS2,
+	HALMAC_MCS3,
+	HALMAC_MCS4,
+	HALMAC_MCS5,
+	HALMAC_MCS6,
+	HALMAC_MCS7,
+	HALMAC_MCS8,
+	HALMAC_MCS9,
+	HALMAC_MCS10,
+	HALMAC_MCS11,
+	HALMAC_MCS12,
+	HALMAC_MCS13,
+	HALMAC_MCS14,
+	HALMAC_MCS15,
+	HALMAC_MCS16,
+	HALMAC_MCS17,
+	HALMAC_MCS18,
+	HALMAC_MCS19,
+	HALMAC_MCS20,
+	HALMAC_MCS21,
+	HALMAC_MCS22,
+	HALMAC_MCS23,
+	HALMAC_MCS24,
+	HALMAC_MCS25,
+	HALMAC_MCS26,
+	HALMAC_MCS27,
+	HALMAC_MCS28,
+	HALMAC_MCS29,
+	HALMAC_MCS30,
+	HALMAC_MCS31,
+	HALMAC_VHT_NSS1_MCS0,
+	HALMAC_VHT_NSS1_MCS1,
+	HALMAC_VHT_NSS1_MCS2,
+	HALMAC_VHT_NSS1_MCS3,
+	HALMAC_VHT_NSS1_MCS4,
+	HALMAC_VHT_NSS1_MCS5,
+	HALMAC_VHT_NSS1_MCS6,
+	HALMAC_VHT_NSS1_MCS7,
+	HALMAC_VHT_NSS1_MCS8,
+	HALMAC_VHT_NSS1_MCS9,
+	HALMAC_VHT_NSS2_MCS0,
+	HALMAC_VHT_NSS2_MCS1,
+	HALMAC_VHT_NSS2_MCS2,
+	HALMAC_VHT_NSS2_MCS3,
+	HALMAC_VHT_NSS2_MCS4,
+	HALMAC_VHT_NSS2_MCS5,
+	HALMAC_VHT_NSS2_MCS6,
+	HALMAC_VHT_NSS2_MCS7,
+	HALMAC_VHT_NSS2_MCS8,
+	HALMAC_VHT_NSS2_MCS9,
+	HALMAC_VHT_NSS3_MCS0,
+	HALMAC_VHT_NSS3_MCS1,
+	HALMAC_VHT_NSS3_MCS2,
+	HALMAC_VHT_NSS3_MCS3,
+	HALMAC_VHT_NSS3_MCS4,
+	HALMAC_VHT_NSS3_MCS5,
+	HALMAC_VHT_NSS3_MCS6,
+	HALMAC_VHT_NSS3_MCS7,
+	HALMAC_VHT_NSS3_MCS8,
+	HALMAC_VHT_NSS3_MCS9,
+	HALMAC_VHT_NSS4_MCS0,
+	HALMAC_VHT_NSS4_MCS1,
+	HALMAC_VHT_NSS4_MCS2,
+	HALMAC_VHT_NSS4_MCS3,
+	HALMAC_VHT_NSS4_MCS4,
+	HALMAC_VHT_NSS4_MCS5,
+	HALMAC_VHT_NSS4_MCS6,
+	HALMAC_VHT_NSS4_MCS7,
+	HALMAC_VHT_NSS4_MCS8,
+	HALMAC_VHT_NSS4_MCS9
+};
+
+enum halmac_rf_path {
+	HALMAC_RF_PATH_A,
+	HALMAC_RF_PATH_B,
+	HALMAC_RF_PATH_C,
+	HALMAC_RF_PATH_D
+};
+
+enum halmac_snd_pkt_sel {
+	HALMAC_UNI_NDPA,
+	HALMAC_BMC_NDPA,
+	HALMAC_NON_FINAL_BFRPRPOLL,
+	HALMAC_FINAL_BFRPTPOLL,
+};
+
+enum hal_security_type {
+	HAL_SECURITY_TYPE_NONE = 0,
+	HAL_SECURITY_TYPE_WEP40 = 1,
+	HAL_SECURITY_TYPE_WEP104 = 2,
+	HAL_SECURITY_TYPE_TKIP = 3,
+	HAL_SECURITY_TYPE_AES128 = 4,
+	HAL_SECURITY_TYPE_WAPI = 5,
+	HAL_SECURITY_TYPE_AES256 = 6,
+	HAL_SECURITY_TYPE_GCMP128 = 7,
+	HAL_SECURITY_TYPE_GCMP256 = 8,
+	HAL_SECURITY_TYPE_GCMSMS4 = 9,
+	HAL_SECURITY_TYPE_BIP = 10,
+	HAL_SECURITY_TYPE_UNDEFINE = 0x7F,
+};
+
+enum hal_intf_phy {
+	HAL_INTF_PHY_USB2 = 0,
+	HAL_INTF_PHY_USB3 = 1,
+	HAL_INTF_PHY_PCIE_GEN1 = 2,
+	HAL_INTF_PHY_PCIE_GEN2 = 3,
+	HAL_INTF_PHY_UNDEFINE = 0x7F,
+};
+
+enum halmac_dbg_msg_info {
+	HALMAC_DBG_ERR,
+	HALMAC_DBG_WARN,
+	HALMAC_DBG_TRACE,
+};
+
+enum halmac_dbg_msg_type {
+	HALMAC_MSG_INIT,
+	HALMAC_MSG_EFUSE,
+	HALMAC_MSG_FW,
+	HALMAC_MSG_H2C,
+	HALMAC_MSG_PWR,
+	HALMAC_MSG_SND,
+	HALMAC_MSG_COMMON,
+	HALMAC_MSG_DBI,
+	HALMAC_MSG_MDIO,
+	HALMAC_MSG_USB
+};
+
+enum halmac_cmd_process_status {
+	HALMAC_CMD_PROCESS_IDLE = 0x01, /* Init status */
+	HALMAC_CMD_PROCESS_SENDING = 0x02, /* Wait ack */
+	HALMAC_CMD_PROCESS_RCVD = 0x03, /* Rcvd ack */
+	HALMAC_CMD_PROCESS_DONE = 0x04, /* Event done */
+	HALMAC_CMD_PROCESS_ERROR = 0x05, /* Return code error */
+	HALMAC_CMD_PROCESS_UNDEFINE = 0x7F,
+};
+
+enum halmac_feature_id {
+	HALMAC_FEATURE_CFG_PARA, /* Support */
+	HALMAC_FEATURE_DUMP_PHYSICAL_EFUSE, /* Support */
+	HALMAC_FEATURE_DUMP_LOGICAL_EFUSE, /* Support */
+	HALMAC_FEATURE_UPDATE_PACKET, /* Support */
+	HALMAC_FEATURE_UPDATE_DATAPACK,
+	HALMAC_FEATURE_RUN_DATAPACK,
+	HALMAC_FEATURE_CHANNEL_SWITCH, /* Support */
+	HALMAC_FEATURE_IQK, /* Support */
+	HALMAC_FEATURE_POWER_TRACKING, /* Support */
+	HALMAC_FEATURE_PSD, /* Support */
+	HALMAC_FEATURE_ALL, /* Support, only for reset */
+};
+
+enum halmac_drv_rsvd_pg_num {
+	HALMAC_RSVD_PG_NUM16, /* 2K */
+	HALMAC_RSVD_PG_NUM24, /* 3K */
+	HALMAC_RSVD_PG_NUM32, /* 4K */
+};
+
+enum halmac_pcie_cfg {
+	HALMAC_PCIE_GEN1,
+	HALMAC_PCIE_GEN2,
+	HALMAC_PCIE_CFG_UNDEFINE,
+};
+
+enum halmac_portid {
+	HALMAC_PORTID0 = 0,
+	HALMAC_PORTID1 = 1,
+	HALMAC_PORTID2 = 2,
+	HALMAC_PORTID3 = 3,
+	HALMAC_PORTID4 = 4,
+	HALMAC_PORTIDMAX
+};
+
+struct halmac_p2pps {
+	/*DW0*/
+	u8 offload_en : 1;
+	u8 role : 1;
+	u8 ctwindow_en : 1;
+	u8 noa_en : 1;
+	u8 noa_sel : 1;
+	u8 all_sta_sleep : 1;
+	u8 discovery : 1;
+	u8 rsvd2 : 1;
+	u8 p2p_port_id;
+	u8 p2p_group;
+	u8 p2p_macid;
+
+	/*DW1*/
+	u8 ctwindow_length;
+	u8 rsvd3;
+	u8 rsvd4;
+	u8 rsvd5;
+
+	/*DW2*/
+	u32 noa_duration_para;
+
+	/*DW3*/
+	u32 noa_interval_para;
+
+	/*DW4*/
+	u32 noa_start_time_para;
+
+	/*DW5*/
+	u32 noa_count_para;
+};
+
+/* Platform API setting */
+struct halmac_platform_api {
+	/* R/W register */
+	u8 (*SDIO_CMD52_READ)(void *driver_adapter, u32 offset);
+	u8 (*SDIO_CMD53_READ_8)(void *driver_adapter, u32 offset);
+	u16 (*SDIO_CMD53_READ_16)(void *driver_adapter, u32 offset);
+	u32 (*SDIO_CMD53_READ_32)(void *driver_adapter, u32 offset);
+	u8 (*SDIO_CMD53_READ_N)(void *driver_adapter, u32 offset, u32 size,
+				u8 *data);
+	void (*SDIO_CMD52_WRITE)(void *driver_adapter, u32 offset, u8 value);
+	void (*SDIO_CMD53_WRITE_8)(void *driver_adapter, u32 offset, u8 value);
+	void (*SDIO_CMD53_WRITE_16)(void *driver_adapter, u32 offset,
+				    u16 value);
+	void (*SDIO_CMD53_WRITE_32)(void *driver_adapter, u32 offset,
+				    u32 value);
+	u8 (*REG_READ_8)(void *driver_adapter, u32 offset);
+	u16 (*REG_READ_16)(void *driver_adapter, u32 offset);
+	u32 (*REG_READ_32)(void *driver_adapter, u32 offset);
+	void (*REG_WRITE_8)(void *driver_adapter, u32 offset, u8 value);
+	void (*REG_WRITE_16)(void *driver_adapter, u32 offset, u16 value);
+	void (*REG_WRITE_32)(void *driver_adapter, u32 offset, u32 value);
+
+	/* send buf to reserved page, the tx_desc is not included in buf,
+	 * driver need to fill tx_desc with qsel = bcn
+	 */
+	bool (*SEND_RSVD_PAGE)(void *driver_adapter, u8 *buf, u32 size);
+	/* send buf to h2c queue, the tx_desc is not included in buf,
+	 * driver need to fill tx_desc with qsel = h2c
+	 */
+	bool (*SEND_H2C_PKT)(void *driver_adapter, u8 *buf, u32 size);
+
+	bool (*EVENT_INDICATION)(void *driver_adapter,
+				 enum halmac_feature_id feature_id,
+				 enum halmac_cmd_process_status process_status,
+				 u8 *buf, u32 size);
+};
+
+/*1->Little endian 0->Big endian*/
+#if HALMAC_SYSTEM_ENDIAN
+
+#else
+
+#endif
+
+/* User can not use members in address_l_h, use address[6] is mandatory */
+union halmac_wlan_addr {
+	u8 address[6]; /* WLAN address (MACID, BSSID, Brodcast ID).
+			* address[0] is lowest, address[5] is highest
+			*/
+	struct {
+		union {
+			u32 address_low;
+			__le32 le_address_low;
+			u8 address_low_b[4];
+		};
+		union {
+			u16 address_high;
+			__le16 le_address_high;
+			u8 address_high_b[2];
+		};
+	} address_l_h;
+};
+
+enum halmac_snd_role {
+	HAL_BFER = 0,
+	HAL_BFEE = 1,
+};
+
+enum halmac_csi_seg_len {
+	HAL_CSI_SEG_4K = 0,
+	HAL_CSI_SEG_8K = 1,
+	HAL_CSI_SEG_11K = 2,
+};
+
+struct halmac_cfg_mumimo_para {
+	enum halmac_snd_role role;
+	bool sounding_sts[6];
+	u16 grouping_bitmap;
+	bool mu_tx_en;
+	u32 given_gid_tab[2];
+	u32 given_user_pos[4];
+};
+
+struct halmac_su_bfer_init_para {
+	u8 userid;
+	u16 paid;
+	u16 csi_para;
+	union halmac_wlan_addr bfer_address;
+};
+
+struct halmac_mu_bfee_init_para {
+	u8 userid;
+	u16 paid;
+	u32 user_position_l;
+	u32 user_position_h;
+};
+
+struct halmac_mu_bfer_init_para {
+	u16 paid;
+	u16 csi_para;
+	u16 my_aid;
+	enum halmac_csi_seg_len csi_length_sel;
+	union halmac_wlan_addr bfer_address;
+};
+
+struct halmac_snd_info {
+	u16 paid;
+	u8 userid;
+	enum halmac_data_rate ndpa_rate;
+	u16 csi_para;
+	u16 my_aid;
+	enum halmac_data_rate csi_rate;
+	enum halmac_csi_seg_len csi_length_sel;
+	enum halmac_snd_role role;
+	union halmac_wlan_addr bfer_address;
+	enum halmac_bw bw;
+	u8 txbf_en;
+	struct halmac_su_bfer_init_para *su_bfer_init;
+	struct halmac_mu_bfer_init_para *mu_bfer_init;
+	struct halmac_mu_bfee_init_para *mu_bfee_init;
+};
+
+struct halmac_cs_info {
+	u8 *ch_info_buf;
+	u8 *ch_info_buf_w;
+	u8 extra_info_en;
+	u32 buf_size; /* buffer size */
+	u32 avai_buf_size; /* buffer size */
+	u32 total_size;
+	u32 accu_timeout;
+	u32 ch_num;
+};
+
+struct halmac_restore_info {
+	u32 mac_register;
+	u32 value;
+	u8 length;
+};
+
+struct halmac_event_trigger {
+	u32 physical_efuse_map : 1;
+	u32 logical_efuse_map : 1;
+	u32 rsvd1 : 28;
+};
+
+struct halmac_h2c_header_info {
+	u16 sub_cmd_id;
+	u16 content_size;
+	bool ack;
+};
+
+enum halmac_dlfw_state {
+	HALMAC_DLFW_NONE = 0,
+	HALMAC_DLFW_DONE = 1,
+	HALMAC_GEN_INFO_SENT = 2,
+	HALMAC_DLFW_UNDEFINED = 0x7F,
+};
+
+enum halmac_efuse_cmd_construct_state {
+	HALMAC_EFUSE_CMD_CONSTRUCT_IDLE = 0,
+	HALMAC_EFUSE_CMD_CONSTRUCT_BUSY = 1,
+	HALMAC_EFUSE_CMD_CONSTRUCT_H2C_SENT = 2,
+	HALMAC_EFUSE_CMD_CONSTRUCT_STATE_NUM = 3,
+	HALMAC_EFUSE_CMD_CONSTRUCT_UNDEFINED = 0x7F,
+};
+
+enum halmac_cfg_para_cmd_construct_state {
+	HALMAC_CFG_PARA_CMD_CONSTRUCT_IDLE = 0,
+	HALMAC_CFG_PARA_CMD_CONSTRUCT_CONSTRUCTING = 1,
+	HALMAC_CFG_PARA_CMD_CONSTRUCT_H2C_SENT = 2,
+	HALMAC_CFG_PARA_CMD_CONSTRUCT_NUM = 3,
+	HALMAC_CFG_PARA_CMD_CONSTRUCT_UNDEFINED = 0x7F,
+};
+
+enum halmac_scan_cmd_construct_state {
+	HALMAC_SCAN_CMD_CONSTRUCT_IDLE = 0,
+	HALMAC_SCAN_CMD_CONSTRUCT_BUFFER_CLEARED = 1,
+	HALMAC_SCAN_CMD_CONSTRUCT_CONSTRUCTING = 2,
+	HALMAC_SCAN_CMD_CONSTRUCT_H2C_SENT = 3,
+	HALMAC_SCAN_CMD_CONSTRUCT_STATE_NUM = 4,
+	HALMAC_SCAN_CMD_CONSTRUCT_UNDEFINED = 0x7F,
+};
+
+enum halmac_api_state {
+	HALMAC_API_STATE_INIT = 0,
+	HALMAC_API_STATE_HALT = 1,
+	HALMAC_API_STATE_UNDEFINED = 0x7F,
+};
+
+struct halmac_efuse_state_set {
+	enum halmac_efuse_cmd_construct_state efuse_cmd_construct_state;
+	enum halmac_cmd_process_status process_status;
+	u8 fw_return_code;
+	u16 seq_num;
+};
+
+struct halmac_cfg_para_state_set {
+	enum halmac_cfg_para_cmd_construct_state cfg_para_cmd_construct_state;
+	enum halmac_cmd_process_status process_status;
+	u8 fw_return_code;
+	u16 seq_num;
+};
+
+struct halmac_scan_state_set {
+	enum halmac_scan_cmd_construct_state scan_cmd_construct_state;
+	enum halmac_cmd_process_status process_status;
+	u8 fw_return_code;
+	u16 seq_num;
+};
+
+struct halmac_update_packet_state_set {
+	enum halmac_cmd_process_status process_status;
+	u8 fw_return_code;
+	u16 seq_num;
+};
+
+struct halmac_iqk_state_set {
+	enum halmac_cmd_process_status process_status;
+	u8 fw_return_code;
+	u16 seq_num;
+};
+
+struct halmac_power_tracking_state_set {
+	enum halmac_cmd_process_status process_status;
+	u8 fw_return_code;
+	u16 seq_num;
+};
+
+struct halmac_psd_state_set {
+	enum halmac_cmd_process_status process_status;
+	u16 data_size;
+	u16 segment_size;
+	u8 *data;
+	u8 fw_return_code;
+	u16 seq_num;
+};
+
+struct halmac_state {
+	struct halmac_efuse_state_set
+		efuse_state_set; /* State machine + cmd process status */
+	struct halmac_cfg_para_state_set
+		cfg_para_state_set; /* State machine + cmd process status */
+	struct halmac_scan_state_set
+		scan_state_set; /* State machine + cmd process status */
+	struct halmac_update_packet_state_set
+		update_packet_set; /* cmd process status */
+	struct halmac_iqk_state_set iqk_set; /* cmd process status */
+	struct halmac_power_tracking_state_set
+		power_tracking_set; /* cmd process status */
+	struct halmac_psd_state_set psd_set; /* cmd process status */
+	enum halmac_api_state api_state; /* Halmac api state */
+	enum halmac_mac_power mac_power; /* 0 : power off, 1 : power on*/
+	enum halmac_ps_state ps_state; /* power saving state */
+	enum halmac_dlfw_state dlfw_state; /* download FW state */
+};
+
+struct halmac_ver {
+	u8 major_ver;
+	u8 prototype_ver;
+	u8 minor_ver;
+};
+
+enum halmac_api_id {
+	/*stuff, need to be the 1st*/
+	HALMAC_API_STUFF = 0x0,
+	/*stuff, need to be the 1st*/
+	HALMAC_API_MAC_POWER_SWITCH = 0x1,
+	HALMAC_API_DOWNLOAD_FIRMWARE = 0x2,
+	HALMAC_API_CFG_MAC_ADDR = 0x3,
+	HALMAC_API_CFG_BSSID = 0x4,
+	HALMAC_API_CFG_MULTICAST_ADDR = 0x5,
+	HALMAC_API_PRE_INIT_SYSTEM_CFG = 0x6,
+	HALMAC_API_INIT_SYSTEM_CFG = 0x7,
+	HALMAC_API_INIT_TRX_CFG = 0x8,
+	HALMAC_API_CFG_RX_AGGREGATION = 0x9,
+	HALMAC_API_INIT_PROTOCOL_CFG = 0xA,
+	HALMAC_API_INIT_EDCA_CFG = 0xB,
+	HALMAC_API_CFG_OPERATION_MODE = 0xC,
+	HALMAC_API_CFG_CH_BW = 0xD,
+	HALMAC_API_CFG_BW = 0xE,
+	HALMAC_API_INIT_WMAC_CFG = 0xF,
+	HALMAC_API_INIT_MAC_CFG = 0x10,
+	HALMAC_API_INIT_SDIO_CFG = 0x11,
+	HALMAC_API_INIT_USB_CFG = 0x12,
+	HALMAC_API_INIT_PCIE_CFG = 0x13,
+	HALMAC_API_INIT_INTERFACE_CFG = 0x14,
+	HALMAC_API_DEINIT_SDIO_CFG = 0x15,
+	HALMAC_API_DEINIT_USB_CFG = 0x16,
+	HALMAC_API_DEINIT_PCIE_CFG = 0x17,
+	HALMAC_API_DEINIT_INTERFACE_CFG = 0x18,
+	HALMAC_API_GET_EFUSE_SIZE = 0x19,
+	HALMAC_API_DUMP_EFUSE_MAP = 0x1A,
+	HALMAC_API_WRITE_EFUSE = 0x1B,
+	HALMAC_API_READ_EFUSE = 0x1C,
+	HALMAC_API_GET_LOGICAL_EFUSE_SIZE = 0x1D,
+	HALMAC_API_DUMP_LOGICAL_EFUSE_MAP = 0x1E,
+	HALMAC_API_WRITE_LOGICAL_EFUSE = 0x1F,
+	HALMAC_API_READ_LOGICAL_EFUSE = 0x20,
+	HALMAC_API_PG_EFUSE_BY_MAP = 0x21,
+	HALMAC_API_GET_C2H_INFO = 0x22,
+	HALMAC_API_CFG_FWLPS_OPTION = 0x23,
+	HALMAC_API_CFG_FWIPS_OPTION = 0x24,
+	HALMAC_API_ENTER_WOWLAN = 0x25,
+	HALMAC_API_LEAVE_WOWLAN = 0x26,
+	HALMAC_API_ENTER_PS = 0x27,
+	HALMAC_API_LEAVE_PS = 0x28,
+	HALMAC_API_H2C_LB = 0x29,
+	HALMAC_API_DEBUG = 0x2A,
+	HALMAC_API_CFG_PARAMETER = 0x2B,
+	HALMAC_API_UPDATE_PACKET = 0x2C,
+	HALMAC_API_BCN_IE_FILTER = 0x2D,
+	HALMAC_API_REG_READ_8 = 0x2E,
+	HALMAC_API_REG_WRITE_8 = 0x2F,
+	HALMAC_API_REG_READ_16 = 0x30,
+	HALMAC_API_REG_WRITE_16 = 0x31,
+	HALMAC_API_REG_READ_32 = 0x32,
+	HALMAC_API_REG_WRITE_32 = 0x33,
+	HALMAC_API_TX_ALLOWED_SDIO = 0x34,
+	HALMAC_API_SET_BULKOUT_NUM = 0x35,
+	HALMAC_API_GET_SDIO_TX_ADDR = 0x36,
+	HALMAC_API_GET_USB_BULKOUT_ID = 0x37,
+	HALMAC_API_TIMER_2S = 0x38,
+	HALMAC_API_FILL_TXDESC_CHECKSUM = 0x39,
+	HALMAC_API_SEND_ORIGINAL_H2C = 0x3A,
+	HALMAC_API_UPDATE_DATAPACK = 0x3B,
+	HALMAC_API_RUN_DATAPACK = 0x3C,
+	HALMAC_API_CFG_DRV_INFO = 0x3D,
+	HALMAC_API_SEND_BT_COEX = 0x3E,
+	HALMAC_API_VERIFY_PLATFORM_API = 0x3F,
+	HALMAC_API_GET_FIFO_SIZE = 0x40,
+	HALMAC_API_DUMP_FIFO = 0x41,
+	HALMAC_API_CFG_TXBF = 0x42,
+	HALMAC_API_CFG_MUMIMO = 0x43,
+	HALMAC_API_CFG_SOUNDING = 0x44,
+	HALMAC_API_DEL_SOUNDING = 0x45,
+	HALMAC_API_SU_BFER_ENTRY_INIT = 0x46,
+	HALMAC_API_SU_BFEE_ENTRY_INIT = 0x47,
+	HALMAC_API_MU_BFER_ENTRY_INIT = 0x48,
+	HALMAC_API_MU_BFEE_ENTRY_INIT = 0x49,
+	HALMAC_API_SU_BFER_ENTRY_DEL = 0x4A,
+	HALMAC_API_SU_BFEE_ENTRY_DEL = 0x4B,
+	HALMAC_API_MU_BFER_ENTRY_DEL = 0x4C,
+	HALMAC_API_MU_BFEE_ENTRY_DEL = 0x4D,
+
+	HALMAC_API_ADD_CH_INFO = 0x4E,
+	HALMAC_API_ADD_EXTRA_CH_INFO = 0x4F,
+	HALMAC_API_CTRL_CH_SWITCH = 0x50,
+	HALMAC_API_CLEAR_CH_INFO = 0x51,
+
+	HALMAC_API_SEND_GENERAL_INFO = 0x52,
+	HALMAC_API_START_IQK = 0x53,
+	HALMAC_API_CTRL_PWR_TRACKING = 0x54,
+	HALMAC_API_PSD = 0x55,
+	HALMAC_API_CFG_TX_AGG_ALIGN = 0x56,
+
+	HALMAC_API_QUERY_STATE = 0x57,
+	HALMAC_API_RESET_FEATURE = 0x58,
+	HALMAC_API_CHECK_FW_STATUS = 0x59,
+	HALMAC_API_DUMP_FW_DMEM = 0x5A,
+	HALMAC_API_CFG_MAX_DL_SIZE = 0x5B,
+
+	HALMAC_API_INIT_OBJ = 0x5C,
+	HALMAC_API_DEINIT_OBJ = 0x5D,
+	HALMAC_API_CFG_LA_MODE = 0x5E,
+	HALMAC_API_GET_HW_VALUE = 0x5F,
+	HALMAC_API_SET_HW_VALUE = 0x60,
+	HALMAC_API_CFG_DRV_RSVD_PG_NUM = 0x61,
+	HALMAC_API_SWITCH_EFUSE_BANK = 0x62,
+	HALMAC_API_WRITE_EFUSE_BT = 0x63,
+	HALMAC_API_DUMP_EFUSE_MAP_BT = 0x64,
+	HALMAC_API_DL_DRV_RSVD_PG = 0x65,
+	HALMAC_API_PCIE_SWITCH = 0x66,
+	HALMAC_API_PHY_CFG = 0x67,
+	HALMAC_API_CFG_RX_FIFO_EXPANDING_MODE = 0x68,
+	HALMAC_API_CFG_CSI_RATE = 0x69,
+	HALMAC_API_MAX
+};
+
+struct halmac_api_record {
+	enum halmac_api_id api_array[API_ARRAY_SIZE];
+	u8 array_wptr;
+};
+
+enum halmac_la_mode {
+	HALMAC_LA_MODE_DISABLE = 0,
+	HALMAC_LA_MODE_PARTIAL = 1,
+	HALMAC_LA_MODE_FULL = 2,
+	HALMAC_LA_MODE_UNDEFINE = 0x7F,
+};
+
+enum halmac_rx_fifo_expanding_mode {
+	HALMAC_RX_FIFO_EXPANDING_MODE_DISABLE = 0,
+	HALMAC_RX_FIFO_EXPANDING_MODE_1_BLOCK = 1,
+	HALMAC_RX_FIFO_EXPANDING_MODE_2_BLOCK = 2,
+	HALMAC_RX_FIFO_EXPANDING_MODE_3_BLOCK = 3,
+	HALMAC_RX_FIFO_EXPANDING_MODE_UNDEFINE = 0x7F,
+};
+
+enum halmac_sdio_cmd53_4byte_mode {
+	HALMAC_SDIO_CMD53_4BYTE_MODE_DISABLE = 0,
+	HALMAC_SDIO_CMD53_4BYTE_MODE_RW = 1,
+	HALMAC_SDIO_CMD53_4BYTE_MODE_R = 2,
+	HALMAC_SDIO_CMD53_4BYTE_MODE_W = 3,
+	HALMAC_SDIO_CMD53_4BYTE_MODE_UNDEFINE = 0x7F,
+};
+
+enum halmac_usb_mode {
+	HALMAC_USB_MODE_U2 = 1,
+	HALMAC_USB_MODE_U3 = 2,
+};
+
+enum halmac_hw_id {
+	/* Get HW value */
+	HALMAC_HW_RQPN_MAPPING = 0x00,
+	HALMAC_HW_EFUSE_SIZE = 0x01,
+	HALMAC_HW_EEPROM_SIZE = 0x02,
+	HALMAC_HW_BT_BANK_EFUSE_SIZE = 0x03,
+	HALMAC_HW_BT_BANK1_EFUSE_SIZE = 0x04,
+	HALMAC_HW_BT_BANK2_EFUSE_SIZE = 0x05,
+	HALMAC_HW_TXFIFO_SIZE = 0x06,
+	HALMAC_HW_RSVD_PG_BNDY = 0x07,
+	HALMAC_HW_CAM_ENTRY_NUM = 0x08,
+	HALMAC_HW_IC_VERSION = 0x09,
+	HALMAC_HW_PAGE_SIZE = 0x0A,
+	HALMAC_HW_TX_AGG_ALIGN_SIZE = 0x0B,
+	HALMAC_HW_RX_AGG_ALIGN_SIZE = 0x0C,
+	HALMAC_HW_DRV_INFO_SIZE = 0x0D,
+	HALMAC_HW_TXFF_ALLOCATION = 0x0E,
+	HALMAC_HW_RSVD_EFUSE_SIZE = 0x0F,
+	HALMAC_HW_FW_HDR_SIZE = 0x10,
+	HALMAC_HW_TX_DESC_SIZE = 0x11,
+	HALMAC_HW_RX_DESC_SIZE = 0x12,
+	HALMAC_HW_WLAN_EFUSE_AVAILABLE_SIZE = 0x13,
+	/* Set HW value */
+	HALMAC_HW_USB_MODE = 0x60,
+	HALMAC_HW_SEQ_EN = 0x61,
+	HALMAC_HW_BANDWIDTH = 0x62,
+	HALMAC_HW_CHANNEL = 0x63,
+	HALMAC_HW_PRI_CHANNEL_IDX = 0x64,
+	HALMAC_HW_EN_BB_RF = 0x65,
+	HALMAC_HW_SDIO_TX_PAGE_THRESHOLD = 0x66,
+	HALMAC_HW_AMPDU_CONFIG = 0x67,
+
+	HALMAC_HW_ID_UNDEFINE = 0x7F,
+};
+
+enum halmac_efuse_bank {
+	HALMAC_EFUSE_BANK_WIFI = 0,
+	HALMAC_EFUSE_BANK_BT = 1,
+	HALMAC_EFUSE_BANK_BT_1 = 2,
+	HALMAC_EFUSE_BANK_BT_2 = 3,
+	HALMAC_EFUSE_BANK_MAX,
+	HALMAC_EFUSE_BANK_UNDEFINE = 0X7F,
+};
+
+struct halmac_txff_allocation {
+	u16 tx_fifo_pg_num;
+	u16 rsvd_pg_num;
+	u16 rsvd_drv_pg_num;
+	u16 ac_q_pg_num;
+	u16 high_queue_pg_num;
+	u16 low_queue_pg_num;
+	u16 normal_queue_pg_num;
+	u16 extra_queue_pg_num;
+	u16 pub_queue_pg_num;
+	u16 rsvd_pg_bndy;
+	u16 rsvd_drv_pg_bndy;
+	u16 rsvd_h2c_extra_info_pg_bndy;
+	u16 rsvd_h2c_queue_pg_bndy;
+	u16 rsvd_cpu_instr_pg_bndy;
+	u16 rsvd_fw_txbuff_pg_bndy;
+	enum halmac_la_mode la_mode;
+	enum halmac_rx_fifo_expanding_mode rx_fifo_expanding_mode;
+};
+
+struct halmac_rqpn_map {
+	enum halmac_dma_mapping dma_map_vo;
+	enum halmac_dma_mapping dma_map_vi;
+	enum halmac_dma_mapping dma_map_be;
+	enum halmac_dma_mapping dma_map_bk;
+	enum halmac_dma_mapping dma_map_mg;
+	enum halmac_dma_mapping dma_map_hi;
+};
+
+struct halmac_security_setting {
+	u8 tx_encryption;
+	u8 rx_decryption;
+	u8 bip_enable;
+};
+
+struct halmac_cam_entry_info {
+	enum hal_security_type security_type;
+	u32 key[4];
+	u32 key_ext[4];
+	u8 mac_address[6];
+	u8 unicast;
+	u8 key_id;
+	u8 valid;
+};
+
+struct halmac_cam_entry_format {
+	u16 key_id : 2;
+	u16 type : 3;
+	u16 mic : 1;
+	u16 grp : 1;
+	u16 spp_mode : 1;
+	u16 rpt_md : 1;
+	u16 ext_sectype : 1;
+	u16 mgnt : 1;
+	u16 rsvd1 : 4;
+	u16 valid : 1;
+	u8 mac_address[6];
+	u32 key[4];
+	u32 rsvd[2];
+};
+
+struct halmac_tx_page_threshold_info {
+	u32 threshold;
+	enum halmac_dma_mapping dma_queue_sel;
+};
+
+struct halmac_ampdu_config {
+	u8 max_agg_num;
+};
+
+struct halmac_port_cfg {
+	u8 port0_sync_tsf;
+	u8 port1_sync_tsf;
+};
+
+struct halmac_rqpn_ {
+	enum halmac_trx_mode mode;
+	enum halmac_dma_mapping dma_map_vo;
+	enum halmac_dma_mapping dma_map_vi;
+	enum halmac_dma_mapping dma_map_be;
+	enum halmac_dma_mapping dma_map_bk;
+	enum halmac_dma_mapping dma_map_mg;
+	enum halmac_dma_mapping dma_map_hi;
+};
+
+struct halmac_pg_num_ {
+	enum halmac_trx_mode mode;
+	u16 hq_num;
+	u16 nq_num;
+	u16 lq_num;
+	u16 exq_num;
+	u16 gap_num; /*used for loopback mode*/
+};
+
+struct halmac_intf_phy_para_ {
+	u16 offset;
+	u16 value;
+	u16 ip_sel;
+	u16 cut;
+	u16 plaform;
+};
+
+struct halmac_iqk_para_ {
+	u8 clear;
+	u8 segment_iqk;
+};
+
+/* Hal mac adapter */
+struct halmac_adapter {
+	/* Dma mapping of protocol queues */
+	enum halmac_dma_mapping halmac_ptcl_queue[HALMAC_PTCL_QUEUE_NUM];
+	/* low power state option */
+	struct halmac_fwlps_option fwlps_option;
+	/* mac address information, suppot 2 ports */
+	union halmac_wlan_addr hal_mac_addr[HALMAC_PORTIDMAX];
+	/* bss address information, suppot 2 ports */
+	union halmac_wlan_addr hal_bss_addr[HALMAC_PORTIDMAX];
+	/* Protect h2c_packet_seq packet*/
+	spinlock_t h2c_seq_lock;
+	/* Protect Efuse map memory of halmac_adapter */
+	spinlock_t efuse_lock;
+	struct halmac_config_para_info config_para_info;
+	struct halmac_cs_info ch_sw_info;
+	struct halmac_event_trigger event_trigger;
+	/* HW related information */
+	struct halmac_hw_config_info hw_config_info;
+	struct halmac_sdio_free_space sdio_free_space;
+	struct halmac_snd_info snd_info;
+	/* Backup HalAdapter address */
+	void *hal_adapter_backup;
+	/* Driver or FW adapter address. Do not write this memory*/
+	void *driver_adapter;
+	u8 *hal_efuse_map;
+	/* Record function pointer of halmac api */
+	void *halmac_api;
+	/* Record function pointer of platform api */
+	struct halmac_platform_api *halmac_platform_api;
+	/* Record efuse used memory */
+	u32 efuse_end;
+	u32 h2c_buf_free_space;
+	u32 h2c_buff_size;
+	u32 max_download_size;
+	/* Chip ID, 8822B, 8821C... */
+	enum halmac_chip_id chip_id;
+	/* A cut, B cut... */
+	enum halmac_chip_ver chip_version;
+	struct halmac_fw_version fw_version;
+	struct halmac_state halmac_state;
+	/* Interface information, get from driver */
+	enum halmac_interface halmac_interface;
+	/* Noraml, WMM, P2P, LoopBack... */
+	enum halmac_trx_mode trx_mode;
+	struct halmac_txff_allocation txff_allocation;
+	u8 h2c_packet_seq; /* current h2c packet sequence number */
+	u16 ack_h2c_packet_seq; /*the acked h2c packet sequence number */
+	bool hal_efuse_map_valid;
+	u8 efuse_segment_size;
+	u8 rpwm_record; /* record rpwm value */
+	bool low_clk; /*LPS 32K or IPS 32K*/
+	u8 halmac_bulkout_num; /* USB bulkout num */
+	struct halmac_api_record api_record; /* API record */
+	bool gen_info_valid;
+	struct halmac_general_info general_info;
+	u8 drv_info_size;
+	enum halmac_sdio_cmd53_4byte_mode sdio_cmd53_4byte;
+};
+
+/* Function pointer of  Hal mac API */
+struct halmac_api {
+	enum halmac_ret_status (*halmac_mac_power_switch)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_mac_power halmac_power);
+	enum halmac_ret_status (*halmac_download_firmware)(
+		struct halmac_adapter *halmac_adapter, u8 *hamacl_fw,
+		u32 halmac_fw_size);
+	enum halmac_ret_status (*halmac_free_download_firmware)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_dlfw_mem dlfw_mem, u8 *hamacl_fw,
+		u32 halmac_fw_size);
+	enum halmac_ret_status (*halmac_get_fw_version)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_fw_version *fw_version);
+	enum halmac_ret_status (*halmac_cfg_mac_addr)(
+		struct halmac_adapter *halmac_adapter, u8 halmac_port,
+		union halmac_wlan_addr *hal_address);
+	enum halmac_ret_status (*halmac_cfg_bssid)(
+		struct halmac_adapter *halmac_adapter, u8 halmac_port,
+		union halmac_wlan_addr *hal_address);
+	enum halmac_ret_status (*halmac_cfg_multicast_addr)(
+		struct halmac_adapter *halmac_adapter,
+		union halmac_wlan_addr *hal_address);
+	enum halmac_ret_status (*halmac_pre_init_system_cfg)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_init_system_cfg)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_init_trx_cfg)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_trx_mode mode);
+	enum halmac_ret_status (*halmac_init_h2c)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_cfg_rx_aggregation)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_rxagg_cfg *phalmac_rxagg_cfg);
+	enum halmac_ret_status (*halmac_init_protocol_cfg)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_init_edca_cfg)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_cfg_operation_mode)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_wireless_mode wireless_mode);
+	enum halmac_ret_status (*halmac_cfg_ch_bw)(
+		struct halmac_adapter *halmac_adapter, u8 channel,
+		enum halmac_pri_ch_idx pri_ch_idx, enum halmac_bw bw);
+	enum halmac_ret_status (*halmac_cfg_bw)(
+		struct halmac_adapter *halmac_adapter, enum halmac_bw bw);
+	enum halmac_ret_status (*halmac_init_wmac_cfg)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_init_mac_cfg)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_trx_mode mode);
+	enum halmac_ret_status (*halmac_init_sdio_cfg)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_init_usb_cfg)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_init_pcie_cfg)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_init_interface_cfg)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_deinit_sdio_cfg)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_deinit_usb_cfg)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_deinit_pcie_cfg)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_deinit_interface_cfg)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_get_efuse_size)(
+		struct halmac_adapter *halmac_adapter, u32 *halmac_size);
+	enum halmac_ret_status (*halmac_get_efuse_available_size)(
+		struct halmac_adapter *halmac_adapter, u32 *halmac_size);
+	enum halmac_ret_status (*halmac_dump_efuse_map)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_efuse_read_cfg cfg);
+	enum halmac_ret_status (*halmac_dump_efuse_map_bt)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_efuse_bank halmac_efues_bank, u32 bt_efuse_map_size,
+		u8 *bt_efuse_map);
+	enum halmac_ret_status (*halmac_write_efuse)(
+		struct halmac_adapter *halmac_adapter, u32 halmac_offset,
+		u8 halmac_value);
+	enum halmac_ret_status (*halmac_read_efuse)(
+		struct halmac_adapter *halmac_adapter, u32 halmac_offset,
+		u8 *value);
+	enum halmac_ret_status (*halmac_switch_efuse_bank)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_efuse_bank halmac_efues_bank);
+	enum halmac_ret_status (*halmac_write_efuse_bt)(
+		struct halmac_adapter *halmac_adapter, u32 halmac_offset,
+		u8 halmac_value, enum halmac_efuse_bank halmac_efues_bank);
+	enum halmac_ret_status (*halmac_get_logical_efuse_size)(
+		struct halmac_adapter *halmac_adapter, u32 *halmac_size);
+	enum halmac_ret_status (*halmac_dump_logical_efuse_map)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_efuse_read_cfg cfg);
+	enum halmac_ret_status (*halmac_write_logical_efuse)(
+		struct halmac_adapter *halmac_adapter, u32 halmac_offset,
+		u8 halmac_value);
+	enum halmac_ret_status (*halmac_read_logical_efuse)(
+		struct halmac_adapter *halmac_adapter, u32 halmac_offset,
+		u8 *value);
+	enum halmac_ret_status (*halmac_pg_efuse_by_map)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_pg_efuse_info *pg_efuse_info,
+		enum halmac_efuse_read_cfg cfg);
+	enum halmac_ret_status (*halmac_get_c2h_info)(
+		struct halmac_adapter *halmac_adapter, u8 *halmac_buf,
+		u32 halmac_size);
+	enum halmac_ret_status (*halmac_cfg_fwlps_option)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_fwlps_option *lps_option);
+	enum halmac_ret_status (*halmac_cfg_fwips_option)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_fwips_option *ips_option);
+	enum halmac_ret_status (*halmac_enter_wowlan)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_wowlan_option *wowlan_option);
+	enum halmac_ret_status (*halmac_leave_wowlan)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_enter_ps)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_ps_state ps_state);
+	enum halmac_ret_status (*halmac_leave_ps)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_h2c_lb)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_debug)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_cfg_parameter)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_phy_parameter_info *para_info, u8 full_fifo);
+	enum halmac_ret_status (*halmac_update_packet)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_packet_id pkt_id, u8 *pkt, u32 pkt_size);
+	enum halmac_ret_status (*halmac_bcn_ie_filter)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_bcn_ie_info *bcn_ie_info);
+	u8 (*halmac_reg_read_8)(struct halmac_adapter *halmac_adapter,
+				u32 halmac_offset);
+	enum halmac_ret_status (*halmac_reg_write_8)(
+		struct halmac_adapter *halmac_adapter, u32 halmac_offset,
+		u8 halmac_data);
+	u16 (*halmac_reg_read_16)(struct halmac_adapter *halmac_adapter,
+				  u32 halmac_offset);
+	enum halmac_ret_status (*halmac_reg_write_16)(
+		struct halmac_adapter *halmac_adapter, u32 halmac_offset,
+		u16 halmac_data);
+	u32 (*halmac_reg_read_32)(struct halmac_adapter *halmac_adapter,
+				  u32 halmac_offset);
+	u32 (*halmac_reg_read_indirect_32)(
+		struct halmac_adapter *halmac_adapter, u32 halmac_offset);
+	u8 (*halmac_reg_sdio_cmd53_read_n)(
+		struct halmac_adapter *halmac_adapter, u32 halmac_offset,
+		u32 halmac_size, u8 *halmac_data);
+	enum halmac_ret_status (*halmac_reg_write_32)(
+		struct halmac_adapter *halmac_adapter, u32 halmac_offset,
+		u32 halmac_data);
+	enum halmac_ret_status (*halmac_tx_allowed_sdio)(
+		struct halmac_adapter *halmac_adapter, u8 *halmac_buf,
+		u32 halmac_size);
+	enum halmac_ret_status (*halmac_set_bulkout_num)(
+		struct halmac_adapter *halmac_adapter, u8 bulkout_num);
+	enum halmac_ret_status (*halmac_get_sdio_tx_addr)(
+		struct halmac_adapter *halmac_adapter, u8 *halmac_buf,
+		u32 halmac_size, u32 *pcmd53_addr);
+	enum halmac_ret_status (*halmac_get_usb_bulkout_id)(
+		struct halmac_adapter *halmac_adapter, u8 *halmac_buf,
+		u32 halmac_size, u8 *bulkout_id);
+	enum halmac_ret_status (*halmac_timer_2s)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_fill_txdesc_checksum)(
+		struct halmac_adapter *halmac_adapter, u8 *cur_desc);
+	enum halmac_ret_status (*halmac_update_datapack)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_data_type halmac_data_type,
+		struct halmac_phy_parameter_info *para_info);
+	enum halmac_ret_status (*halmac_run_datapack)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_data_type halmac_data_type);
+	enum halmac_ret_status (*halmac_cfg_drv_info)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_drv_info halmac_drv_info);
+	enum halmac_ret_status (*halmac_send_bt_coex)(
+		struct halmac_adapter *halmac_adapter, u8 *bt_buf, u32 bt_size,
+		u8 ack);
+	enum halmac_ret_status (*halmac_verify_platform_api)(
+		struct halmac_adapter *halmac_adapte);
+	u32 (*halmac_get_fifo_size)(struct halmac_adapter *halmac_adapter,
+				    enum hal_fifo_sel halmac_fifo_sel);
+	enum halmac_ret_status (*halmac_dump_fifo)(
+		struct halmac_adapter *halmac_adapter,
+		enum hal_fifo_sel halmac_fifo_sel, u32 halmac_start_addr,
+		u32 halmac_fifo_dump_size, u8 *fifo_map);
+	enum halmac_ret_status (*halmac_cfg_txbf)(
+		struct halmac_adapter *halmac_adapter, u8 userid,
+		enum halmac_bw bw, u8 txbf_en);
+	enum halmac_ret_status (*halmac_cfg_mumimo)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_cfg_mumimo_para *cfgmu);
+	enum halmac_ret_status (*halmac_cfg_sounding)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_snd_role role, enum halmac_data_rate datarate);
+	enum halmac_ret_status (*halmac_del_sounding)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_snd_role role);
+	enum halmac_ret_status (*halmac_su_bfer_entry_init)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_su_bfer_init_para *su_bfer_init);
+	enum halmac_ret_status (*halmac_su_bfee_entry_init)(
+		struct halmac_adapter *halmac_adapter, u8 userid, u16 paid);
+	enum halmac_ret_status (*halmac_mu_bfer_entry_init)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_mu_bfer_init_para *mu_bfer_init);
+	enum halmac_ret_status (*halmac_mu_bfee_entry_init)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_mu_bfee_init_para *mu_bfee_init);
+	enum halmac_ret_status (*halmac_su_bfer_entry_del)(
+		struct halmac_adapter *halmac_adapter, u8 userid);
+	enum halmac_ret_status (*halmac_su_bfee_entry_del)(
+		struct halmac_adapter *halmac_adapter, u8 userid);
+	enum halmac_ret_status (*halmac_mu_bfer_entry_del)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_mu_bfee_entry_del)(
+		struct halmac_adapter *halmac_adapter, u8 userid);
+	enum halmac_ret_status (*halmac_add_ch_info)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_ch_info *ch_info);
+	enum halmac_ret_status (*halmac_add_extra_ch_info)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_ch_extra_info *ch_extra_info);
+	enum halmac_ret_status (*halmac_ctrl_ch_switch)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_ch_switch_option *cs_option);
+	enum halmac_ret_status (*halmac_p2pps)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_p2pps *p2p_ps);
+	enum halmac_ret_status (*halmac_clear_ch_info)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_send_general_info)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_general_info *pg_general_info);
+	enum halmac_ret_status (*halmac_start_iqk)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_iqk_para_ *iqk_para);
+	enum halmac_ret_status (*halmac_ctrl_pwr_tracking)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_pwr_tracking_option *pwr_tracking_opt);
+	enum halmac_ret_status (*halmac_psd)(
+		struct halmac_adapter *halmac_adapter, u16 start_psd,
+		u16 end_psd);
+	enum halmac_ret_status (*halmac_cfg_tx_agg_align)(
+		struct halmac_adapter *halmac_adapter, u8 enable,
+		u16 align_size);
+	enum halmac_ret_status (*halmac_query_status)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_feature_id feature_id,
+		enum halmac_cmd_process_status *process_status, u8 *data,
+		u32 *size);
+	enum halmac_ret_status (*halmac_reset_feature)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_feature_id feature_id);
+	enum halmac_ret_status (*halmac_check_fw_status)(
+		struct halmac_adapter *halmac_adapter, bool *fw_status);
+	enum halmac_ret_status (*halmac_dump_fw_dmem)(
+		struct halmac_adapter *halmac_adapter, u8 *dmem, u32 *size);
+	enum halmac_ret_status (*halmac_cfg_max_dl_size)(
+		struct halmac_adapter *halmac_adapter, u32 size);
+	enum halmac_ret_status (*halmac_cfg_la_mode)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_la_mode la_mode);
+	enum halmac_ret_status (*halmac_cfg_rx_fifo_expanding_mode)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_rx_fifo_expanding_mode rx_fifo_expanding_mode);
+	enum halmac_ret_status (*halmac_config_security)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_security_setting *sec_setting);
+	u8 (*halmac_get_used_cam_entry_num)(
+		struct halmac_adapter *halmac_adapter,
+		enum hal_security_type sec_type);
+	enum halmac_ret_status (*halmac_write_cam)(
+		struct halmac_adapter *halmac_adapter, u32 entry_index,
+		struct halmac_cam_entry_info *cam_entry_info);
+	enum halmac_ret_status (*halmac_read_cam_entry)(
+		struct halmac_adapter *halmac_adapter, u32 entry_index,
+		struct halmac_cam_entry_format *content);
+	enum halmac_ret_status (*halmac_clear_cam_entry)(
+		struct halmac_adapter *halmac_adapter, u32 entry_index);
+	enum halmac_ret_status (*halmac_get_hw_value)(
+		struct halmac_adapter *halmac_adapter, enum halmac_hw_id hw_id,
+		void *pvalue);
+	enum halmac_ret_status (*halmac_set_hw_value)(
+		struct halmac_adapter *halmac_adapter, enum halmac_hw_id hw_id,
+		void *pvalue);
+	enum halmac_ret_status (*halmac_cfg_drv_rsvd_pg_num)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_drv_rsvd_pg_num pg_num);
+	enum halmac_ret_status (*halmac_get_chip_version)(
+		struct halmac_adapter *halmac_adapter,
+		struct halmac_ver *version);
+	enum halmac_ret_status (*halmac_chk_txdesc)(
+		struct halmac_adapter *halmac_adapter, u8 *halmac_buf,
+		u32 halmac_size);
+	enum halmac_ret_status (*halmac_dl_drv_rsvd_page)(
+		struct halmac_adapter *halmac_adapter, u8 pg_offset,
+		u8 *hal_buf, u32 size);
+	enum halmac_ret_status (*halmac_pcie_switch)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_pcie_cfg pcie_cfg);
+	enum halmac_ret_status (*halmac_phy_cfg)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_intf_phy_platform platform);
+	enum halmac_ret_status (*halmac_cfg_csi_rate)(
+		struct halmac_adapter *halmac_adapter, u8 rssi, u8 current_rate,
+		u8 fixrate_en, u8 *new_rate);
+	enum halmac_ret_status (*halmac_sdio_cmd53_4byte)(
+		struct halmac_adapter *halmac_adapter,
+		enum halmac_sdio_cmd53_4byte_mode cmd53_4byte_mode);
+	enum halmac_ret_status (*halmac_interface_integration_tuning)(
+		struct halmac_adapter *halmac_adapter);
+	enum halmac_ret_status (*halmac_txfifo_is_empty)(
+		struct halmac_adapter *halmac_adapter, u32 chk_num);
+};
+
+#define HALMAC_GET_API(phalmac_adapter)                                        \
+	((struct halmac_api *)phalmac_adapter->halmac_api)
+
+static inline enum halmac_ret_status
+halmac_adapter_validate(struct halmac_adapter *halmac_adapter)
+{
+	if ((!halmac_adapter) ||
+	    (halmac_adapter->hal_adapter_backup != halmac_adapter))
+		return HALMAC_RET_ADAPTER_INVALID;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static inline enum halmac_ret_status
+halmac_api_validate(struct halmac_adapter *halmac_adapter)
+{
+	if (halmac_adapter->halmac_state.api_state != HALMAC_API_STATE_INIT)
+		return HALMAC_RET_API_INVALID;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+static inline enum halmac_ret_status
+halmac_fw_validate(struct halmac_adapter *halmac_adapter)
+{
+	if (halmac_adapter->halmac_state.dlfw_state != HALMAC_DLFW_DONE &&
+	    halmac_adapter->halmac_state.dlfw_state != HALMAC_GEN_INFO_SENT)
+		return HALMAC_RET_NO_DLFW;
+
+	return HALMAC_RET_SUCCESS;
+}
+
+#endif
diff --git a/drivers/staging/rtlwifi/halmac/halmac_usb_reg.h b/drivers/staging/rtlwifi/halmac/halmac_usb_reg.h
new file mode 100644
index 000000000000..d6e721ea7463
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/halmac_usb_reg.h
@@ -0,0 +1,28 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef __HALMAC_USB_REG_H__
+#define __HALMAC_USB_REG_H__
+
+#endif /* __HALMAC_USB_REG_H__ */
diff --git a/drivers/staging/rtlwifi/halmac/rtl_halmac.c b/drivers/staging/rtlwifi/halmac/rtl_halmac.c
new file mode 100644
index 000000000000..031bf2c6078f
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/rtl_halmac.c
@@ -0,0 +1,1410 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#include "halmac_api.h"
+#include "rtl_halmac.h"
+#include <linux/module.h>
+#include <linux/vmalloc.h>
+
+#define DEFAULT_INDICATOR_TIMELMT msecs_to_jiffies(1000) /* ms */
+#define FIRMWARE_MAX_SIZE HALMAC_FW_SIZE_MAX_88XX
+
+static struct rtl_halmac_ops rtl_halmac_operation = {
+	.halmac_init_adapter = rtl_halmac_init_adapter,
+	.halmac_deinit_adapter = rtl_halmac_deinit_adapter,
+	.halmac_init_hal = rtl_halmac_init_hal,
+	.halmac_deinit_hal = rtl_halmac_deinit_hal,
+	.halmac_poweron = rtl_halmac_poweron,
+	.halmac_poweroff = rtl_halmac_poweroff,
+
+	.halmac_phy_power_switch = rtl_halmac_phy_power_switch,
+	.halmac_set_mac_address = rtl_halmac_set_mac_address,
+	.halmac_set_bssid = rtl_halmac_set_bssid,
+
+	.halmac_get_physical_efuse_size = rtl_halmac_get_physical_efuse_size,
+	.halmac_read_physical_efuse_map = rtl_halmac_read_physical_efuse_map,
+	.halmac_get_logical_efuse_size = rtl_halmac_get_logical_efuse_size,
+	.halmac_read_logical_efuse_map = rtl_halmac_read_logical_efuse_map,
+
+	.halmac_set_bandwidth = rtl_halmac_set_bandwidth,
+
+	.halmac_c2h_handle = rtl_halmac_c2h_handle,
+
+	.halmac_chk_txdesc = rtl_halmac_chk_txdesc,
+};
+
+struct rtl_halmac_ops *rtl_halmac_get_ops_pointer(void)
+{
+	return &rtl_halmac_operation;
+}
+EXPORT_SYMBOL(rtl_halmac_get_ops_pointer);
+
+/*
+ * Driver API for HALMAC operations
+ */
+
+static u8 _halmac_reg_read_8(void *p, u32 offset)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)p;
+
+	return rtl_read_byte(rtlpriv, offset);
+}
+
+static u16 _halmac_reg_read_16(void *p, u32 offset)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)p;
+
+	return rtl_read_word(rtlpriv, offset);
+}
+
+static u32 _halmac_reg_read_32(void *p, u32 offset)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)p;
+
+	return rtl_read_dword(rtlpriv, offset);
+}
+
+static void _halmac_reg_write_8(void *p, u32 offset, u8 val)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)p;
+
+	rtl_write_byte(rtlpriv, offset, val);
+}
+
+static void _halmac_reg_write_16(void *p, u32 offset, u16 val)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)p;
+
+	rtl_write_word(rtlpriv, offset, val);
+}
+
+static void _halmac_reg_write_32(void *p, u32 offset, u32 val)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)p;
+
+	rtl_write_dword(rtlpriv, offset, val);
+}
+
+static bool _halmac_write_data_rsvd_page(void *p, u8 *buf, u32 size)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)p;
+
+	if (rtlpriv->cfg->ops->halmac_cb_write_data_rsvd_page &&
+	    rtlpriv->cfg->ops->halmac_cb_write_data_rsvd_page(rtlpriv, buf,
+							      size))
+		return true;
+
+	return false;
+}
+
+static bool _halmac_write_data_h2c(void *p, u8 *buf, u32 size)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)p;
+
+	if (rtlpriv->cfg->ops->halmac_cb_write_data_h2c &&
+	    rtlpriv->cfg->ops->halmac_cb_write_data_h2c(rtlpriv, buf, size))
+		return true;
+
+	return false;
+}
+
+static const char *const RTL_HALMAC_FEATURE_NAME[] = {
+	"HALMAC_FEATURE_CFG_PARA",
+	"HALMAC_FEATURE_DUMP_PHYSICAL_EFUSE",
+	"HALMAC_FEATURE_DUMP_LOGICAL_EFUSE",
+	"HALMAC_FEATURE_UPDATE_PACKET",
+	"HALMAC_FEATURE_UPDATE_DATAPACK",
+	"HALMAC_FEATURE_RUN_DATAPACK",
+	"HALMAC_FEATURE_CHANNEL_SWITCH",
+	"HALMAC_FEATURE_IQK",
+	"HALMAC_FEATURE_POWER_TRACKING",
+	"HALMAC_FEATURE_PSD",
+	"HALMAC_FEATURE_ALL"};
+
+static inline bool is_valid_id_status(struct rtl_priv *rtlpriv,
+				      enum halmac_feature_id id,
+				      enum halmac_cmd_process_status status)
+{
+	switch (id) {
+	case HALMAC_FEATURE_CFG_PARA:
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD, "%s: %s\n", __func__,
+			 RTL_HALMAC_FEATURE_NAME[id]);
+		break;
+	case HALMAC_FEATURE_DUMP_PHYSICAL_EFUSE:
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD, "%s: %s\n", __func__,
+			 RTL_HALMAC_FEATURE_NAME[id]);
+		if (status != HALMAC_CMD_PROCESS_DONE) {
+			RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD,
+				 "%s: <WARN> id(%d) unspecified status(%d)!\n",
+				 __func__, id, status);
+		}
+		break;
+	case HALMAC_FEATURE_DUMP_LOGICAL_EFUSE:
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD, "%s: %s\n", __func__,
+			 RTL_HALMAC_FEATURE_NAME[id]);
+		if (status != HALMAC_CMD_PROCESS_DONE) {
+			RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD,
+				 "%s: <WARN> id(%d) unspecified status(%d)!\n",
+				 __func__, id, status);
+		}
+		break;
+	case HALMAC_FEATURE_UPDATE_PACKET:
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD, "%s: %s\n", __func__,
+			 RTL_HALMAC_FEATURE_NAME[id]);
+		break;
+	case HALMAC_FEATURE_UPDATE_DATAPACK:
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD, "%s: %s\n", __func__,
+			 RTL_HALMAC_FEATURE_NAME[id]);
+		break;
+	case HALMAC_FEATURE_RUN_DATAPACK:
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD, "%s: %s\n", __func__,
+			 RTL_HALMAC_FEATURE_NAME[id]);
+		break;
+	case HALMAC_FEATURE_CHANNEL_SWITCH:
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD, "%s: %s\n", __func__,
+			 RTL_HALMAC_FEATURE_NAME[id]);
+		break;
+	case HALMAC_FEATURE_IQK:
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD, "%s: %s\n", __func__,
+			 RTL_HALMAC_FEATURE_NAME[id]);
+		break;
+	case HALMAC_FEATURE_POWER_TRACKING:
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD, "%s: %s\n", __func__,
+			 RTL_HALMAC_FEATURE_NAME[id]);
+		break;
+	case HALMAC_FEATURE_PSD:
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD, "%s: %s\n", __func__,
+			 RTL_HALMAC_FEATURE_NAME[id]);
+		break;
+	case HALMAC_FEATURE_ALL:
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD, "%s: %s\n", __func__,
+			 RTL_HALMAC_FEATURE_NAME[id]);
+		break;
+	default:
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD,
+			 "%s: unknown feature id(%d)\n", __func__, id);
+		return false;
+	}
+
+	return true;
+}
+
+static int init_halmac_event_with_waittime(struct rtl_priv *rtlpriv,
+					   enum halmac_feature_id id, u8 *buf,
+					   u32 size, u32 time)
+{
+	struct completion *comp;
+
+	if (!rtlpriv->halmac.indicator[id].comp) {
+		comp = kzalloc(sizeof(*comp), GFP_KERNEL);
+		if (!comp)
+			return -1;
+	} else {
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD,
+			 "%s: <WARN> id(%d) sctx is not NULL!!\n", __func__,
+			 id);
+		comp = rtlpriv->halmac.indicator[id].comp;
+		rtlpriv->halmac.indicator[id].comp = NULL;
+	}
+
+	init_completion(comp);
+	rtlpriv->halmac.indicator[id].wait_ms = time;
+
+	rtlpriv->halmac.indicator[id].buffer = buf;
+	rtlpriv->halmac.indicator[id].buf_size = size;
+	rtlpriv->halmac.indicator[id].ret_size = 0;
+	rtlpriv->halmac.indicator[id].status = 0;
+	/* fill sctx at least to sure other variables are all ready! */
+	rtlpriv->halmac.indicator[id].comp = comp;
+
+	return 0;
+}
+
+static inline int init_halmac_event(struct rtl_priv *rtlpriv,
+				    enum halmac_feature_id id, u8 *buf,
+				    u32 size)
+{
+	return init_halmac_event_with_waittime(rtlpriv, id, buf, size,
+					       DEFAULT_INDICATOR_TIMELMT);
+}
+
+static void free_halmac_event(struct rtl_priv *rtlpriv,
+			      enum halmac_feature_id id)
+{
+	struct completion *comp;
+
+	if (!rtlpriv->halmac.indicator[id].comp)
+		return;
+
+	comp = rtlpriv->halmac.indicator[id].comp;
+	rtlpriv->halmac.indicator[id].comp = NULL;
+	kfree(comp);
+}
+
+static int wait_halmac_event(struct rtl_priv *rtlpriv,
+			     enum halmac_feature_id id)
+{
+	struct completion *comp;
+	int ret;
+
+	comp = rtlpriv->halmac.indicator[id].comp;
+	if (!comp)
+		return -1;
+
+	ret = wait_for_completion_timeout(
+		comp, rtlpriv->halmac.indicator[id].wait_ms);
+	free_halmac_event(rtlpriv, id);
+	if (ret > 0)
+		return 0;
+
+	return -1;
+}
+
+/*
+ * Return:
+ *	Always return true, HALMAC don't care the return value.
+ */
+static bool
+_halmac_event_indication(void *p, enum halmac_feature_id feature_id,
+			 enum halmac_cmd_process_status process_status, u8 *buf,
+			 u32 size)
+{
+	struct rtl_priv *rtlpriv;
+	struct rtl_halmac_indicator *tbl, *indicator;
+	struct completion *comp;
+	u32 cpsz;
+	bool ret;
+
+	rtlpriv = (struct rtl_priv *)p;
+	tbl = rtlpriv->halmac.indicator;
+
+	ret = is_valid_id_status(rtlpriv, feature_id, process_status);
+	if (!ret)
+		goto exit;
+
+	indicator = &tbl[feature_id];
+	indicator->status = process_status;
+	indicator->ret_size = size;
+	if (!indicator->comp) {
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD,
+			 "%s: No feature id(%d) waiting!!\n", __func__,
+			 feature_id);
+		goto exit;
+	}
+	comp = indicator->comp;
+
+	if (process_status == HALMAC_CMD_PROCESS_ERROR) {
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD,
+			 "%s: Something wrong id(%d)!!\n", __func__,
+			 feature_id);
+		complete(comp); /* may provide error code */
+		goto exit;
+	}
+
+	if (size > indicator->buf_size) {
+		RT_TRACE(
+			rtlpriv, COMP_HALMAC, DBG_LOUD,
+			"%s: <WARN> id(%d) buffer is not enough(%d<%d), data will be truncated!\n",
+			__func__, feature_id, indicator->buf_size, size);
+		cpsz = indicator->buf_size;
+	} else {
+		cpsz = size;
+	}
+
+	if (cpsz && indicator->buffer)
+		memcpy(indicator->buffer, buf, cpsz);
+
+	complete(comp);
+
+exit:
+	return true;
+}
+
+static struct halmac_platform_api rtl_halmac_platform_api = {
+	/* R/W register */
+	.REG_READ_8 = _halmac_reg_read_8,
+	.REG_READ_16 = _halmac_reg_read_16,
+	.REG_READ_32 = _halmac_reg_read_32,
+	.REG_WRITE_8 = _halmac_reg_write_8,
+	.REG_WRITE_16 = _halmac_reg_write_16,
+	.REG_WRITE_32 = _halmac_reg_write_32,
+
+	/* Write data */
+	/* impletement in HAL-IC level */
+	.SEND_RSVD_PAGE = _halmac_write_data_rsvd_page,
+	.SEND_H2C_PKT = _halmac_write_data_h2c,
+
+	.EVENT_INDICATION = _halmac_event_indication,
+};
+
+static int init_priv(struct rtl_halmac *halmac)
+{
+	struct rtl_halmac_indicator *indicator;
+	u32 count, size;
+
+	halmac->send_general_info = 0;
+
+	count = HALMAC_FEATURE_ALL + 1;
+	size = sizeof(*indicator) * count;
+	indicator = kzalloc(size, GFP_KERNEL);
+	if (!indicator)
+		return -1;
+	halmac->indicator = indicator;
+
+	return 0;
+}
+
+static void deinit_priv(struct rtl_halmac *halmac)
+{
+	struct rtl_halmac_indicator *indicator;
+
+	indicator = halmac->indicator;
+	halmac->indicator = NULL;
+	if (indicator) {
+		u32 count, size;
+
+		count = HALMAC_FEATURE_ALL + 1;
+#ifdef CONFIG_RTL_DEBUG
+		{
+			struct submit_ctx *sctx;
+			u32 i;
+
+			for (i = 0; i < count; i++) {
+				if (!indicator[i].sctx)
+					continue;
+
+				RT_TRACE(
+					rtlpriv, COMP_HALMAC, DBG_LOUD,
+					"%s: <WARN> %s id(%d) sctx still exist!!\n",
+					__func__, RTL_HALMAC_FEATURE_NAME[i],
+					i);
+				sctx = indicator[i].sctx;
+				indicator[i].sctx = NULL;
+				rtl_mfree((u8 *)sctx, sizeof(*sctx));
+			}
+		}
+#endif /* !CONFIG_RTL_DEBUG */
+		size = sizeof(*indicator) * count;
+		kfree((u8 *)indicator);
+	}
+}
+
+int rtl_halmac_init_adapter(struct rtl_priv *rtlpriv)
+{
+	struct halmac_adapter *halmac;
+	struct halmac_api *api;
+	enum halmac_interface intf;
+	enum halmac_ret_status status;
+	int err = 0;
+	struct halmac_platform_api *pf_api = &rtl_halmac_platform_api;
+
+	halmac = rtlpriv_to_halmac(rtlpriv);
+	if (halmac) {
+		err = 0;
+		goto out;
+	}
+
+	err = init_priv(&rtlpriv->halmac);
+	if (err)
+		goto out;
+
+	intf = HALMAC_INTERFACE_PCIE;
+	status = halmac_init_adapter(rtlpriv, pf_api, intf, &halmac, &api);
+	if (status != HALMAC_RET_SUCCESS) {
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD,
+			 "%s: halmac_init_adapter fail!(status=%d)\n", __func__,
+			 status);
+		err = -1;
+		goto out;
+	}
+
+	rtlpriv->halmac.internal = halmac;
+
+out:
+	if (err)
+		rtl_halmac_deinit_adapter(rtlpriv);
+
+	return err;
+}
+
+int rtl_halmac_deinit_adapter(struct rtl_priv *rtlpriv)
+{
+	struct halmac_adapter *halmac;
+	enum halmac_ret_status status;
+	int err = 0;
+
+	halmac = rtlpriv_to_halmac(rtlpriv);
+	if (!halmac) {
+		err = 0;
+		goto out;
+	}
+
+	deinit_priv(&rtlpriv->halmac);
+
+	halmac_halt_api(halmac);
+
+	status = halmac_deinit_adapter(halmac);
+	rtlpriv->halmac.internal = NULL;
+	if (status != HALMAC_RET_SUCCESS) {
+		err = -1;
+		goto out;
+	}
+
+out:
+	return err;
+}
+
+int rtl_halmac_poweron(struct rtl_priv *rtlpriv)
+{
+	struct halmac_adapter *halmac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	int err = -1;
+
+	halmac = rtlpriv_to_halmac(rtlpriv);
+	if (!halmac)
+		goto out;
+
+	api = HALMAC_GET_API(halmac);
+
+	status = api->halmac_pre_init_system_cfg(halmac);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+	status = api->halmac_mac_power_switch(halmac, HALMAC_MAC_POWER_ON);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+	status = api->halmac_init_system_cfg(halmac);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+	err = 0;
+out:
+	return err;
+}
+
+int rtl_halmac_poweroff(struct rtl_priv *rtlpriv)
+{
+	struct halmac_adapter *halmac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	int err = -1;
+
+	halmac = rtlpriv_to_halmac(rtlpriv);
+	if (!halmac)
+		goto out;
+
+	api = HALMAC_GET_API(halmac);
+
+	status = api->halmac_mac_power_switch(halmac, HALMAC_MAC_POWER_OFF);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+	err = 0;
+out:
+	return err;
+}
+
+/*
+ * Note:
+ *	When this function return, the register REG_RCR may be changed.
+ */
+int rtl_halmac_config_rx_info(struct rtl_priv *rtlpriv,
+			      enum halmac_drv_info info)
+{
+	struct halmac_adapter *halmac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	int err = -1;
+
+	halmac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(halmac);
+
+	status = api->halmac_cfg_drv_info(halmac, info);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+	err = 0;
+out:
+	return err;
+}
+
+static enum halmac_ret_status init_mac_flow(struct rtl_priv *rtlpriv)
+{
+	struct halmac_adapter *halmac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	u8 wifi_test = 0;
+	int err;
+
+	halmac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(halmac);
+
+	if (wifi_test)
+		status = api->halmac_init_mac_cfg(halmac, HALMAC_TRX_MODE_WMM);
+	else
+		status = api->halmac_init_mac_cfg(halmac,
+						  HALMAC_TRX_MODE_NORMAL);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+	err = rtl_halmac_rx_agg_switch(rtlpriv, true);
+	if (err)
+		goto out;
+
+	if (rtlpriv->cfg->maps[RTL_RC_VHT_RATE_1SS_MCS7])
+		status = api->halmac_cfg_operation_mode(
+			halmac, HALMAC_WIRELESS_MODE_AC);
+	else if (rtlpriv->cfg->maps[RTL_RC_HT_RATEMCS7])
+		status = api->halmac_cfg_operation_mode(halmac,
+							HALMAC_WIRELESS_MODE_N);
+	else if (rtlpriv->cfg->maps[RTL_RC_OFDM_RATE6M])
+		status = api->halmac_cfg_operation_mode(halmac,
+							HALMAC_WIRELESS_MODE_G);
+	else
+		status = api->halmac_cfg_operation_mode(halmac,
+							HALMAC_WIRELESS_MODE_B);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+out:
+	return status;
+}
+
+static inline enum halmac_rf_type _rf_type_drv2halmac(enum rf_type rf_drv)
+{
+	enum halmac_rf_type rf_mac;
+
+	switch (rf_drv) {
+	case RF_1T2R:
+		rf_mac = HALMAC_RF_1T2R;
+		break;
+	case RF_2T2R:
+		rf_mac = HALMAC_RF_2T2R;
+		break;
+	case RF_1T1R:
+		rf_mac = HALMAC_RF_1T1R;
+		break;
+	case RF_2T2R_GREEN:
+		rf_mac = HALMAC_RF_2T2R_GREEN;
+		break;
+	default:
+		rf_mac = (enum halmac_rf_type)rf_drv;
+		break;
+	}
+
+	return rf_mac;
+}
+
+static int _send_general_info(struct rtl_priv *rtlpriv)
+{
+	struct halmac_adapter *halmac;
+	struct halmac_api *api;
+	struct halmac_general_info info;
+	enum halmac_ret_status status;
+
+	halmac = rtlpriv_to_halmac(rtlpriv);
+	if (!halmac)
+		return -1;
+	api = HALMAC_GET_API(halmac);
+
+	memset(&info, 0, sizeof(info));
+	info.rfe_type = rtlpriv->rtlhal.rfe_type;
+	info.rf_type = _rf_type_drv2halmac(rtlpriv->phy.rf_type);
+
+	status = api->halmac_send_general_info(halmac, &info);
+	switch (status) {
+	case HALMAC_RET_SUCCESS:
+		break;
+	case HALMAC_RET_NO_DLFW:
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_WARNING,
+			 "%s: halmac_send_general_info() fail because fw not dl!\n",
+			 __func__);
+	/* fallthrough here */
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * Notices:
+ *	Make sure
+ *	1. rtl_hal_get_hwreg(HW_VAR_RF_TYPE)
+ *	2. HAL_DATA_TYPE.rfe_type
+ *	already ready for use before calling this function.
+ */
+static int _halmac_init_hal(struct rtl_priv *rtlpriv, u8 *fw, u32 fwsize)
+{
+	struct halmac_adapter *halmac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	bool ok;
+	bool fw_ok = false;
+	int err, err_ret = -1;
+
+	halmac = rtlpriv_to_halmac(rtlpriv);
+	if (!halmac)
+		goto out;
+	api = HALMAC_GET_API(halmac);
+
+	/* StatePowerOff */
+
+	/* SKIP: halmac_init_adapter (Already done before) */
+
+	/* halmac_pre_Init_system_cfg */
+	/* halmac_mac_power_switch(on) */
+	/* halmac_Init_system_cfg */
+	err = rtl_halmac_poweron(rtlpriv);
+	if (err)
+		goto out;
+
+	/* StatePowerOn */
+
+	/* DownloadFW */
+	rtlpriv->halmac.send_general_info = 0;
+	if (fw && fwsize) {
+		err = rtl_halmac_dlfw(rtlpriv, fw, fwsize);
+		if (err)
+			goto out;
+		fw_ok = true;
+	}
+
+	/* InitMACFlow */
+	status = init_mac_flow(rtlpriv);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+	/* halmac_send_general_info */
+	if (fw_ok) {
+		rtlpriv->halmac.send_general_info = 0;
+		err = _send_general_info(rtlpriv);
+		if (err)
+			goto out;
+	} else {
+		rtlpriv->halmac.send_general_info = 1;
+	}
+
+	/* Init Phy parameter-MAC */
+	if (rtlpriv->cfg->ops->halmac_cb_init_mac_register)
+		ok = rtlpriv->cfg->ops->halmac_cb_init_mac_register(rtlpriv);
+	else
+		ok = false;
+
+	if (!ok)
+		goto out;
+
+	/* StateMacInitialized */
+
+	/* halmac_cfg_drv_info */
+	err = rtl_halmac_config_rx_info(rtlpriv, HALMAC_DRV_INFO_PHY_STATUS);
+	if (err)
+		goto out;
+
+	/* halmac_set_hw_value(HALMAC_HW_EN_BB_RF) */
+	/* Init BB, RF */
+	if (rtlpriv->cfg->ops->halmac_cb_init_bb_rf_register)
+		ok = rtlpriv->cfg->ops->halmac_cb_init_bb_rf_register(rtlpriv);
+	else
+		ok = false;
+
+	if (!ok)
+		goto out;
+
+	status = api->halmac_init_interface_cfg(halmac);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+	/* SKIP: halmac_verify_platform_api */
+	/* SKIP: halmac_h2c_lb */
+
+	/* StateRxIdle */
+
+	err_ret = 0;
+out:
+	return err_ret;
+}
+
+int rtl_halmac_init_hal(struct rtl_priv *rtlpriv)
+{
+	if (!rtlpriv->rtlhal.pfirmware || rtlpriv->rtlhal.fwsize == 0)
+		return -1;
+
+	return _halmac_init_hal(rtlpriv, rtlpriv->rtlhal.pfirmware,
+				rtlpriv->rtlhal.fwsize);
+}
+
+int rtl_halmac_deinit_hal(struct rtl_priv *rtlpriv)
+{
+	struct halmac_adapter *halmac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	int err = -1;
+
+	halmac = rtlpriv_to_halmac(rtlpriv);
+	if (!halmac)
+		goto out;
+	api = HALMAC_GET_API(halmac);
+
+	status = api->halmac_deinit_interface_cfg(halmac);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+	/* rtw_hal_power_off(adapter); */
+	status = api->halmac_mac_power_switch(halmac, HALMAC_MAC_POWER_OFF);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+	err = 0;
+out:
+	return err;
+}
+
+int rtl_halmac_self_verify(struct rtl_priv *rtlpriv)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	int err = -1;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+
+	status = api->halmac_verify_platform_api(mac);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+	status = api->halmac_h2c_lb(mac);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+	err = 0;
+out:
+	return err;
+}
+
+int rtl_halmac_dlfw(struct rtl_priv *rtlpriv, u8 *fw, u32 fwsize)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	struct halmac_fw_version fw_version;
+	int err = 0;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+
+	if ((!fw) || (!fwsize))
+		return -1;
+
+	/* 1. Driver Stop Tx */
+	/* ToDo */
+
+	/* 2. Driver Check Tx FIFO is empty */
+	/* ToDo */
+
+	/* 3. Config MAX download size */
+	api->halmac_cfg_max_dl_size(mac, 0x1000);
+
+	/* 4. Download Firmware */
+	mac->h2c_packet_seq = 0;
+	status = api->halmac_download_firmware(mac, fw, fwsize);
+	if (status != HALMAC_RET_SUCCESS)
+		return -1;
+
+	status = api->halmac_get_fw_version(mac, &fw_version);
+	if (status == HALMAC_RET_SUCCESS) {
+		rtlpriv->rtlhal.fw_version = fw_version.version;
+		rtlpriv->rtlhal.fw_subversion =
+			(fw_version.sub_version << 8) | (fw_version.sub_index);
+
+		RT_TRACE(
+			rtlpriv, COMP_HALMAC, DBG_DMESG,
+			"halmac report firmware version %04X.%04X\n",
+			rtlpriv->rtlhal.fw_version,
+			rtlpriv->rtlhal.fw_subversion);
+	}
+
+	if (rtlpriv->halmac.send_general_info) {
+		rtlpriv->halmac.send_general_info = 0;
+		err = _send_general_info(rtlpriv);
+	}
+
+	/* 5. Driver resume TX if needed */
+	/* ToDo */
+
+	/* 6. Reset driver variables if needed */
+	/*hal->LastHMEBoxNum = 0;*/
+
+	return err;
+}
+
+/*
+ * Description:
+ *	Power on/off BB/RF domain.
+ *
+ * Parameters:
+ *	enable	true/false for power on/off
+ *
+ * Return:
+ *	0	Success
+ *	others	Fail
+ */
+int rtl_halmac_phy_power_switch(struct rtl_priv *rtlpriv, u8 enable)
+{
+	struct halmac_adapter *halmac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+
+	halmac = rtlpriv_to_halmac(rtlpriv);
+	if (!halmac)
+		return -1;
+	api = HALMAC_GET_API(halmac);
+
+	status = api->halmac_set_hw_value(halmac, HALMAC_HW_EN_BB_RF, &enable);
+	if (status != HALMAC_RET_SUCCESS)
+		return -1;
+
+	return 0;
+}
+
+static bool _is_fw_read_cmd_down(struct rtl_priv *rtlpriv, u8 msgbox_num)
+{
+	bool read_down = false;
+	int retry_cnts = 100;
+	u8 valid;
+
+	RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD,
+		 "%s, reg_1cc(%x), msg_box(%d)...\n", __func__,
+		 rtl_read_byte(rtlpriv, REG_HMETFR), msgbox_num);
+
+	do {
+		valid = rtl_read_byte(rtlpriv, REG_HMETFR) & BIT(msgbox_num);
+		if (valid == 0)
+			read_down = true;
+		else
+			schedule();
+	} while ((!read_down) && (retry_cnts--));
+
+	return read_down;
+}
+
+int rtl_halmac_send_h2c(struct rtl_priv *rtlpriv, u8 *h2c)
+{
+	u8 h2c_box_num = 0;
+	u32 msgbox_addr = 0;
+	u32 msgbox_ex_addr = 0;
+	__le32 h2c_cmd = 0;
+	__le32 h2c_cmd_ex = 0;
+	s32 ret = -1;
+	unsigned long flag = 0;
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+	if (!h2c) {
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD, "%s: pbuf is NULL\n",
+			 __func__);
+		return ret;
+	}
+
+	spin_lock_irqsave(&rtlpriv->locks.h2c_lock, flag);
+
+	/* pay attention to if race condition happened in  H2C cmd setting */
+	h2c_box_num = rtlhal->last_hmeboxnum;
+
+	if (!_is_fw_read_cmd_down(rtlpriv, h2c_box_num)) {
+		RT_TRACE(rtlpriv, COMP_HALMAC, DBG_LOUD,
+			 " fw read cmd failed...\n");
+		goto exit;
+	}
+
+	/* Write Ext command(byte 4 -7) */
+	msgbox_ex_addr = REG_HMEBOX_E0 + (h2c_box_num * EX_MESSAGE_BOX_SIZE);
+	memcpy((u8 *)(&h2c_cmd_ex), h2c + 4, EX_MESSAGE_BOX_SIZE);
+	rtl_write_dword(rtlpriv, msgbox_ex_addr, le32_to_cpu(h2c_cmd_ex));
+
+	/* Write command (byte 0 -3 ) */
+	msgbox_addr = REG_HMEBOX0 + (h2c_box_num * MESSAGE_BOX_SIZE);
+	memcpy((u8 *)(&h2c_cmd), h2c, 4);
+	rtl_write_dword(rtlpriv, msgbox_addr, le32_to_cpu(h2c_cmd));
+
+	/* update last msg box number */
+	rtlhal->last_hmeboxnum = (h2c_box_num + 1) % MAX_H2C_BOX_NUMS;
+	ret = 0;
+
+exit:
+	spin_unlock_irqrestore(&rtlpriv->locks.h2c_lock, flag);
+	return ret;
+}
+
+int rtl_halmac_c2h_handle(struct rtl_priv *rtlpriv, u8 *c2h, u32 size)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+
+	status = api->halmac_get_c2h_info(mac, c2h, size);
+	if (status != HALMAC_RET_SUCCESS)
+		return -1;
+
+	return 0;
+}
+
+int rtl_halmac_get_physical_efuse_size(struct rtl_priv *rtlpriv, u32 *size)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	u32 val;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+
+	status = api->halmac_get_efuse_size(mac, &val);
+	if (status != HALMAC_RET_SUCCESS)
+		return -1;
+
+	*size = val;
+	return 0;
+}
+
+int rtl_halmac_read_physical_efuse_map(struct rtl_priv *rtlpriv, u8 *map,
+				       u32 size)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	enum halmac_feature_id id;
+	int ret;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+	id = HALMAC_FEATURE_DUMP_PHYSICAL_EFUSE;
+
+	ret = init_halmac_event(rtlpriv, id, map, size);
+	if (ret)
+		return -1;
+
+	status = api->halmac_dump_efuse_map(mac, HALMAC_EFUSE_R_DRV);
+	if (status != HALMAC_RET_SUCCESS) {
+		free_halmac_event(rtlpriv, id);
+		return -1;
+	}
+
+	ret = wait_halmac_event(rtlpriv, id);
+	if (ret)
+		return -1;
+
+	return 0;
+}
+
+int rtl_halmac_read_physical_efuse(struct rtl_priv *rtlpriv, u32 offset,
+				   u32 cnt, u8 *data)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	u8 v;
+	u32 i;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+
+	for (i = 0; i < cnt; i++) {
+		status = api->halmac_read_efuse(mac, offset + i, &v);
+		if (status != HALMAC_RET_SUCCESS)
+			return -1;
+		data[i] = v;
+	}
+
+	return 0;
+}
+
+int rtl_halmac_write_physical_efuse(struct rtl_priv *rtlpriv, u32 offset,
+				    u32 cnt, u8 *data)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	u32 i;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+
+	for (i = 0; i < cnt; i++) {
+		status = api->halmac_write_efuse(mac, offset + i, data[i]);
+		if (status != HALMAC_RET_SUCCESS)
+			return -1;
+	}
+
+	return 0;
+}
+
+int rtl_halmac_get_logical_efuse_size(struct rtl_priv *rtlpriv, u32 *size)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	u32 val;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+
+	status = api->halmac_get_logical_efuse_size(mac, &val);
+	if (status != HALMAC_RET_SUCCESS)
+		return -1;
+
+	*size = val;
+	return 0;
+}
+
+int rtl_halmac_read_logical_efuse_map(struct rtl_priv *rtlpriv, u8 *map,
+				      u32 size)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	enum halmac_feature_id id;
+	int ret;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+	id = HALMAC_FEATURE_DUMP_LOGICAL_EFUSE;
+
+	ret = init_halmac_event(rtlpriv, id, map, size);
+	if (ret)
+		return -1;
+
+	status = api->halmac_dump_logical_efuse_map(mac, HALMAC_EFUSE_R_AUTO);
+	if (status != HALMAC_RET_SUCCESS) {
+		free_halmac_event(rtlpriv, id);
+		return -1;
+	}
+
+	ret = wait_halmac_event(rtlpriv, id);
+	if (ret)
+		return -1;
+
+	return 0;
+}
+
+int rtl_halmac_write_logical_efuse_map(struct rtl_priv *rtlpriv, u8 *map,
+				       u32 size, u8 *maskmap, u32 masksize)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	struct halmac_pg_efuse_info pginfo;
+	enum halmac_ret_status status;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+
+	pginfo.efuse_map = map;
+	pginfo.efuse_map_size = size;
+	pginfo.efuse_mask = maskmap;
+	pginfo.efuse_mask_size = masksize;
+
+	status = api->halmac_pg_efuse_by_map(mac, &pginfo, HALMAC_EFUSE_R_AUTO);
+	if (status != HALMAC_RET_SUCCESS)
+		return -1;
+
+	return 0;
+}
+
+int rtl_halmac_read_logical_efuse(struct rtl_priv *rtlpriv, u32 offset, u32 cnt,
+				  u8 *data)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	u8 v;
+	u32 i;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+
+	for (i = 0; i < cnt; i++) {
+		status = api->halmac_read_logical_efuse(mac, offset + i, &v);
+		if (status != HALMAC_RET_SUCCESS)
+			return -1;
+		data[i] = v;
+	}
+
+	return 0;
+}
+
+int rtl_halmac_write_logical_efuse(struct rtl_priv *rtlpriv, u32 offset,
+				   u32 cnt, u8 *data)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	u32 i;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+
+	for (i = 0; i < cnt; i++) {
+		status = api->halmac_write_logical_efuse(mac, offset + i,
+							 data[i]);
+		if (status != HALMAC_RET_SUCCESS)
+			return -1;
+	}
+
+	return 0;
+}
+
+int rtl_halmac_set_mac_address(struct rtl_priv *rtlpriv, u8 hwport, u8 *addr)
+{
+	struct halmac_adapter *halmac;
+	struct halmac_api *api;
+	u8 port;
+	union halmac_wlan_addr hwa;
+	enum halmac_ret_status status;
+	int err = -1;
+
+	halmac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(halmac);
+
+	port = hwport;
+	memset(&hwa, 0, sizeof(hwa));
+	memcpy(hwa.address, addr, 6);
+
+	status = api->halmac_cfg_mac_addr(halmac, port, &hwa);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+	err = 0;
+out:
+	return err;
+}
+
+int rtl_halmac_set_bssid(struct rtl_priv *rtlpriv, u8 hwport, u8 *addr)
+{
+	struct halmac_adapter *halmac;
+	struct halmac_api *api;
+	u8 port;
+	union halmac_wlan_addr hwa;
+	enum halmac_ret_status status;
+	int err = -1;
+
+	halmac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(halmac);
+	port = hwport;
+
+	memset(&hwa, 0, sizeof(union halmac_wlan_addr));
+	memcpy(hwa.address, addr, 6);
+	status = api->halmac_cfg_bssid(halmac, port, &hwa);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+	err = 0;
+out:
+	return err;
+}
+
+int rtl_halmac_set_bandwidth(struct rtl_priv *rtlpriv, u8 channel,
+			     u8 pri_ch_idx, u8 bw)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+
+	status = api->halmac_cfg_ch_bw(mac, channel, pri_ch_idx, bw);
+	if (status != HALMAC_RET_SUCCESS)
+		return -1;
+
+	return 0;
+}
+
+int rtl_halmac_get_hw_value(struct rtl_priv *rtlpriv, enum halmac_hw_id hw_id,
+			    void *pvalue)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+
+	status = api->halmac_get_hw_value(mac, hw_id, pvalue);
+	if (status != HALMAC_RET_SUCCESS)
+		return -1;
+
+	return 0;
+}
+
+int rtl_halmac_dump_fifo(struct rtl_priv *rtlpriv,
+			 enum hal_fifo_sel halmac_fifo_sel)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+	u8 *pfifo_map = NULL;
+	u32 fifo_size = 0;
+	s8 ret = 0;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+
+	fifo_size = api->halmac_get_fifo_size(mac, halmac_fifo_sel);
+	if (fifo_size)
+		pfifo_map = vmalloc(fifo_size);
+	if (!pfifo_map)
+		return -1;
+
+	status = api->halmac_dump_fifo(mac, halmac_fifo_sel, 0, fifo_size,
+				       pfifo_map);
+
+	if (status != HALMAC_RET_SUCCESS) {
+		ret = -1;
+		goto _exit;
+	}
+
+_exit:
+	if (pfifo_map)
+		vfree(pfifo_map);
+	return ret;
+}
+
+int rtl_halmac_rx_agg_switch(struct rtl_priv *rtlpriv, bool enable)
+{
+	struct halmac_adapter *halmac;
+	struct halmac_api *api;
+	struct halmac_rxagg_cfg rxaggcfg;
+	enum halmac_ret_status status;
+	int err = -1;
+
+	halmac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(halmac);
+	memset((void *)&rxaggcfg, 0, sizeof(rxaggcfg));
+
+	if (enable) {
+		/* enable RX agg. */
+		/* PCIE do nothing */
+	} else {
+		/* disable RX agg. */
+		rxaggcfg.mode = HALMAC_RX_AGG_MODE_NONE;
+	}
+
+	status = api->halmac_cfg_rx_aggregation(halmac, &rxaggcfg);
+	if (status != HALMAC_RET_SUCCESS)
+		goto out;
+
+	err = 0;
+out:
+	return err;
+}
+
+int rtl_halmac_get_wow_reason(struct rtl_priv *rtlpriv, u8 *reason)
+{
+	u8 val8;
+	int err = -1;
+
+	val8 = rtl_read_byte(rtlpriv, 0x1C7);
+	if (val8 == 0xEA)
+		goto out;
+
+	*reason = val8;
+	err = 0;
+out:
+	return err;
+}
+
+/*
+ * Description:
+ *	Get RX driver info size. RX driver info is a small memory space between
+ *	scriptor and RX payload.
+ *
+ *	+-------------------------+
+ *	| RX descriptor           |
+ *	| usually 24 bytes        |
+ *	+-------------------------+
+ *	| RX driver info          |
+ *	| depends on driver cfg   |
+ *	+-------------------------+
+ *	| RX paylad               |
+ *	|                         |
+ *	+-------------------------+
+ *
+ * Parameter:
+ *	d	pointer to struct dvobj_priv of driver
+ *	sz	rx driver info size in bytes.
+ *
+ * Rteurn:
+ *	0	Success
+ *	other	Fail
+ */
+int rtl_halmac_get_drv_info_sz(struct rtl_priv *rtlpriv, u8 *sz)
+{
+	/*	enum halmac_ret_status status; */
+	u8 dw = 6; /* max number */
+
+	*sz = dw * 8;
+	return 0;
+}
+
+int rtl_halmac_get_rsvd_drv_pg_bndy(struct rtl_priv *rtlpriv, u16 *drv_pg)
+{
+	enum halmac_ret_status status;
+	struct halmac_adapter *halmac = rtlpriv_to_halmac(rtlpriv);
+	struct halmac_api *api = HALMAC_GET_API(halmac);
+
+	status = api->halmac_get_hw_value(halmac, HALMAC_HW_RSVD_PG_BNDY,
+					  drv_pg);
+	if (status != HALMAC_RET_SUCCESS)
+		return -1;
+
+	return 0;
+}
+
+int rtl_halmac_chk_txdesc(struct rtl_priv *rtlpriv, u8 *txdesc, u32 size)
+{
+	struct halmac_adapter *mac;
+	struct halmac_api *api;
+	enum halmac_ret_status status;
+
+	mac = rtlpriv_to_halmac(rtlpriv);
+	api = HALMAC_GET_API(mac);
+
+	status = api->halmac_chk_txdesc(mac, txdesc, size);
+
+	if (status != HALMAC_RET_SUCCESS)
+		return -1;
+
+	return 0;
+}
+
+MODULE_AUTHOR("Realtek WlanFAE	<wlanfae@realtek.com>");
+MODULE_AUTHOR("Larry Finger	<Larry.FInger@lwfinger.net>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Realtek 802.11n PCI wireless core");
diff --git a/drivers/staging/rtlwifi/halmac/rtl_halmac.h b/drivers/staging/rtlwifi/halmac/rtl_halmac.h
new file mode 100644
index 000000000000..51a3684f30d8
--- /dev/null
+++ b/drivers/staging/rtlwifi/halmac/rtl_halmac.h
@@ -0,0 +1,94 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2016  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+#ifndef _RTL_HALMAC_H_
+#define _RTL_HALMAC_H_
+
+#include "halmac_api.h"
+
+#define rtlpriv_to_halmac(priv)                                                \
+	((struct halmac_adapter *)((priv)->halmac.internal))
+
+/* for H2C cmd */
+#define MAX_H2C_BOX_NUMS 4
+#define MESSAGE_BOX_SIZE 4
+#define EX_MESSAGE_BOX_SIZE 4
+
+/* HALMAC API for Driver(HAL) */
+int rtl_halmac_init_adapter(struct rtl_priv *rtlpriv);
+int rtl_halmac_deinit_adapter(struct rtl_priv *rtlpriv);
+int rtl_halmac_poweron(struct rtl_priv *rtlpriv);
+int rtl_halmac_poweroff(struct rtl_priv *rtlpriv);
+int rtl_halmac_init_hal(struct rtl_priv *rtlpriv);
+int rtl_halmac_init_hal_fw(struct rtl_priv *rtlpriv, u8 *fw, u32 fwsize);
+int rtl_halmac_init_hal_fw_file(struct rtl_priv *rtlpriv, u8 *fwpath);
+int rtl_halmac_deinit_hal(struct rtl_priv *rtlpriv);
+int rtl_halmac_self_verify(struct rtl_priv *rtlpriv);
+int rtl_halmac_dlfw(struct rtl_priv *rtlpriv, u8 *fw, u32 fwsize);
+int rtl_halmac_dlfw_from_file(struct rtl_priv *rtlpriv, u8 *fwpath);
+int rtl_halmac_phy_power_switch(struct rtl_priv *rtlpriv, u8 enable);
+int rtl_halmac_send_h2c(struct rtl_priv *rtlpriv, u8 *h2c);
+int rtl_halmac_c2h_handle(struct rtl_priv *rtlpriv, u8 *c2h, u32 size);
+
+int rtl_halmac_get_physical_efuse_size(struct rtl_priv *rtlpriv, u32 *size);
+int rtl_halmac_read_physical_efuse_map(struct rtl_priv *rtlpriv, u8 *map,
+				       u32 size);
+int rtl_halmac_read_physical_efuse(struct rtl_priv *rtlpriv, u32 offset,
+				   u32 cnt, u8 *data);
+int rtl_halmac_write_physical_efuse(struct rtl_priv *rtlpriv, u32 offset,
+				    u32 cnt, u8 *data);
+int rtl_halmac_get_logical_efuse_size(struct rtl_priv *rtlpriv, u32 *size);
+int rtl_halmac_read_logical_efuse_map(struct rtl_priv *rtlpriv, u8 *map,
+				      u32 size);
+int rtl_halmac_write_logical_efuse_map(struct rtl_priv *rtlpriv, u8 *map,
+				       u32 size, u8 *maskmap, u32 masksize);
+int rtl_halmac_read_logical_efuse(struct rtl_priv *rtlpriv, u32 offset, u32 cnt,
+				  u8 *data);
+int rtl_halmac_write_logical_efuse(struct rtl_priv *rtlpriv, u32 offset,
+				   u32 cnt, u8 *data);
+
+int rtl_halmac_config_rx_info(struct rtl_priv *rtlpriv, enum halmac_drv_info);
+int rtl_halmac_set_mac_address(struct rtl_priv *rtlpriv, u8 hwport, u8 *addr);
+int rtl_halmac_set_bssid(struct rtl_priv *d, u8 hwport, u8 *addr);
+
+int rtl_halmac_set_bandwidth(struct rtl_priv *rtlpriv, u8 channel,
+			     u8 pri_ch_idx, u8 bw);
+int rtl_halmac_rx_agg_switch(struct rtl_priv *rtlpriv, bool enable);
+int rtl_halmac_get_hw_value(struct rtl_priv *d, enum halmac_hw_id hw_id,
+			    void *pvalue);
+int rtl_halmac_dump_fifo(struct rtl_priv *rtlpriv,
+			 enum hal_fifo_sel halmac_fifo_sel);
+
+int rtl_halmac_get_wow_reason(struct rtl_priv *rtlpriv, u8 *reason);
+int rtl_halmac_get_drv_info_sz(struct rtl_priv *d, u8 *sz);
+
+int rtl_halmac_get_rsvd_drv_pg_bndy(struct rtl_priv *dvobj, u16 *drv_pg);
+int rtl_halmac_download_rsvd_page(struct rtl_priv *dvobj, u8 pg_offset,
+				  u8 *pbuf, u32 size);
+
+int rtl_halmac_chk_txdesc(struct rtl_priv *rtlpriv, u8 *txdesc, u32 size);
+
+struct rtl_halmac_ops *rtl_halmac_get_ops_pointer(void);
+
+#endif /* _RTL_HALMAC_H_ */
-- 
2.19.1

