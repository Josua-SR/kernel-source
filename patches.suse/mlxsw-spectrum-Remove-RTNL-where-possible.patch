From: Ido Schimmel <idosch@mellanox.com>
Date: Fri, 21 Feb 2020 19:54:15 +0200
Subject: mlxsw: spectrum: Remove RTNL where possible
Patch-mainline: v5.7-rc1
Git-commit: 9811f7a2c9f498b7bb769f3908935212d12b6951
References: bsc#1176774

After introducing the router lock in previous patches and making sure it
protects internal router structures, we no longer need to rely on RTNL
to serialize access to these structures.

Remove RTNL from call sites that no longer require it.

Two calls sites that keep taking the lock are
mlxsw_sp_router_fibmr_event_work() and mlxsw_sp_inet6addr_event_work().
The first calls into ACL code that still assumes RTNL is taken. The
second potentially calls into the FID code that also relies on RTNL.
Removing RTNL from these two call sites is the subject of future work.

Signed-off-by: Ido Schimmel <idosch@mellanox.com>
Acked-by: Jiri Pirko <jiri@mellanox.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/mellanox/mlxsw/spectrum_dpipe.c  |   17 -----------------
 drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c |   12 ------------
 2 files changed, 29 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_dpipe.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_dpipe.c
@@ -211,7 +211,6 @@ mlxsw_sp_dpipe_table_erif_entries_dump(v
 		return err;
 
 	rif_count = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS);
-	rtnl_lock();
 	mutex_lock(&mlxsw_sp->router->lock);
 	i = 0;
 start_again:
@@ -244,7 +243,6 @@ start_again:
 	if (i != rif_count)
 		goto start_again;
 	mutex_unlock(&mlxsw_sp->router->lock);
-	rtnl_unlock();
 
 	devlink_dpipe_entry_clear(&entry);
 	return 0;
@@ -252,7 +250,6 @@ err_entry_append:
 err_entry_get:
 err_ctx_prepare:
 	mutex_unlock(&mlxsw_sp->router->lock);
-	rtnl_unlock();
 	devlink_dpipe_entry_clear(&entry);
 	return err;
 }
@@ -262,7 +259,6 @@ static int mlxsw_sp_dpipe_table_erif_cou
 	struct mlxsw_sp *mlxsw_sp = priv;
 	int i;
 
-	rtnl_lock();
 	mutex_lock(&mlxsw_sp->router->lock);
 	for (i = 0; i < MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS); i++) {
 		struct mlxsw_sp_rif *rif = mlxsw_sp_rif_by_index(mlxsw_sp, i);
@@ -277,7 +273,6 @@ static int mlxsw_sp_dpipe_table_erif_cou
 						  MLXSW_SP_RIF_COUNTER_EGRESS);
 	}
 	mutex_unlock(&mlxsw_sp->router->lock);
-	rtnl_unlock();
 	return 0;
 }
 
@@ -552,7 +547,6 @@ mlxsw_sp_dpipe_table_host_entries_get(st
 	int i, j;
 	int err;
 
-	rtnl_lock();
 	mutex_lock(&mlxsw_sp->router->lock);
 	i = 0;
 	rif_count = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS);
@@ -610,13 +604,11 @@ out:
 		goto start_again;
 
 	mutex_unlock(&mlxsw_sp->router->lock);
-	rtnl_unlock();
 	return 0;
 
 err_ctx_prepare:
 err_entry_append:
 	mutex_unlock(&mlxsw_sp->router->lock);
-	rtnl_unlock();
 	return err;
 }
 
@@ -671,7 +663,6 @@ mlxsw_sp_dpipe_table_host_counters_updat
 {
 	int i;
 
-	rtnl_lock();
 	mutex_lock(&mlxsw_sp->router->lock);
 	for (i = 0; i < MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS); i++) {
 		struct mlxsw_sp_rif *rif = mlxsw_sp_rif_by_index(mlxsw_sp, i);
@@ -695,7 +686,6 @@ mlxsw_sp_dpipe_table_host_counters_updat
 		}
 	}
 	mutex_unlock(&mlxsw_sp->router->lock);
-	rtnl_unlock();
 }
 
 static int mlxsw_sp_dpipe_table_host4_counters_update(void *priv, bool enable)
@@ -712,7 +702,6 @@ mlxsw_sp_dpipe_table_host_size_get(struc
 	u64 size = 0;
 	int i;
 
-	rtnl_lock();
 	mutex_lock(&mlxsw_sp->router->lock);
 	for (i = 0; i < MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS); i++) {
 		struct mlxsw_sp_rif *rif = mlxsw_sp_rif_by_index(mlxsw_sp, i);
@@ -734,7 +723,6 @@ mlxsw_sp_dpipe_table_host_size_get(struc
 		}
 	}
 	mutex_unlock(&mlxsw_sp->router->lock);
-	rtnl_unlock();
 
 	return size;
 }
@@ -1106,7 +1094,6 @@ mlxsw_sp_dpipe_table_adj_entries_get(str
 	int j;
 	int err;
 
-	rtnl_lock();
 	mutex_lock(&mlxsw_sp->router->lock);
 	nh_count_max = mlxsw_sp_dpipe_table_adj_size(mlxsw_sp);
 start_again:
@@ -1145,14 +1132,12 @@ skip:
 	if (nh_count != nh_count_max)
 		goto start_again;
 	mutex_unlock(&mlxsw_sp->router->lock);
-	rtnl_unlock();
 
 	return 0;
 
 err_ctx_prepare:
 err_entry_append:
 	mutex_unlock(&mlxsw_sp->router->lock);
-	rtnl_unlock();
 	return err;
 }
 
@@ -1222,11 +1207,9 @@ mlxsw_sp_dpipe_table_adj_size_get(void *
 	struct mlxsw_sp *mlxsw_sp = priv;
 	u64 size;
 
-	rtnl_lock();
 	mutex_lock(&mlxsw_sp->router->lock);
 	size = mlxsw_sp_dpipe_table_adj_size(mlxsw_sp);
 	mutex_unlock(&mlxsw_sp->router->lock);
-	rtnl_unlock();
 
 	return size;
 }
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@ -2307,7 +2307,6 @@ __mlxsw_sp_router_neighs_update_rauhtd(s
 	int i, num_rec;
 	int err;
 
-	rtnl_lock();
 	/* Ensure the RIF we read from the device does not change mid-dump. */
 	mutex_lock(&mlxsw_sp->router->lock);
 	do {
@@ -2324,7 +2323,6 @@ __mlxsw_sp_router_neighs_update_rauhtd(s
 							  i);
 	} while (mlxsw_sp_router_rauhtd_is_full(rauhtd_pl));
 	mutex_unlock(&mlxsw_sp->router->lock);
-	rtnl_unlock();
 
 	return err;
 }
@@ -2355,7 +2353,6 @@ static void mlxsw_sp_router_neighs_updat
 {
 	struct mlxsw_sp_neigh_entry *neigh_entry;
 
-	rtnl_lock();
 	mutex_lock(&mlxsw_sp->router->lock);
 	list_for_each_entry(neigh_entry, &mlxsw_sp->router->nexthop_neighs_list,
 			    nexthop_neighs_list_node)
@@ -2364,7 +2361,6 @@ static void mlxsw_sp_router_neighs_updat
 		 */
 		neigh_event_send(neigh_entry->key.n, NULL);
 	mutex_unlock(&mlxsw_sp->router->lock);
-	rtnl_unlock();
 }
 
 static void
@@ -2405,14 +2401,12 @@ static void mlxsw_sp_router_probe_unreso
 	 * but it wouldn't get resolved ever in case traffic is flowing in HW
 	 * using different nexthop.
 	 */
-	rtnl_lock();
 	mutex_lock(&router->lock);
 	list_for_each_entry(neigh_entry, &router->nexthop_neighs_list,
 			    nexthop_neighs_list_node)
 		if (!neigh_entry->connected)
 			neigh_event_send(neigh_entry->key.n, NULL);
 	mutex_unlock(&router->lock);
-	rtnl_unlock();
 
 	mlxsw_core_schedule_dw(&router->nexthop_probe_dw,
 			       MLXSW_SP_UNRESOLVED_NH_PROBE_INTERVAL);
@@ -2550,7 +2544,6 @@ static void mlxsw_sp_router_neigh_event_
 	dead = n->dead;
 	read_unlock_bh(&n->lock);
 
-	rtnl_lock();
 	mutex_lock(&mlxsw_sp->router->lock);
 	mlxsw_sp_span_respin(mlxsw_sp);
 
@@ -2574,7 +2567,6 @@ static void mlxsw_sp_router_neigh_event_
 
 out:
 	mutex_unlock(&mlxsw_sp->router->lock);
-	rtnl_unlock();
 	neigh_release(n);
 	kfree(net_work);
 }
@@ -5981,7 +5973,6 @@ static void mlxsw_sp_router_fib4_event_w
 	struct mlxsw_sp *mlxsw_sp = fib_work->mlxsw_sp;
 	int err;
 
-	rtnl_lock();
 	mutex_lock(&mlxsw_sp->router->lock);
 	mlxsw_sp_span_respin(mlxsw_sp);
 
@@ -6005,7 +5996,6 @@ static void mlxsw_sp_router_fib4_event_w
 		break;
 	}
 	mutex_unlock(&mlxsw_sp->router->lock);
-	rtnl_unlock();
 	kfree(fib_work);
 }
 
@@ -6016,7 +6006,6 @@ static void mlxsw_sp_router_fib6_event_w
 	struct mlxsw_sp *mlxsw_sp = fib_work->mlxsw_sp;
 	int err;
 
-	rtnl_lock();
 	mutex_lock(&mlxsw_sp->router->lock);
 	mlxsw_sp_span_respin(mlxsw_sp);
 
@@ -6045,7 +6034,6 @@ static void mlxsw_sp_router_fib6_event_w
 		break;
 	}
 	mutex_unlock(&mlxsw_sp->router->lock);
-	rtnl_unlock();
 	kfree(fib_work);
 }
 
