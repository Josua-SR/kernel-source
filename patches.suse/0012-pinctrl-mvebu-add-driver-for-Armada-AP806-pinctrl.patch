From: Hanna Hawa <hannah@marvell.com>
Date: Mon, 12 Jun 2017 17:34:56 +0200
Subject: pinctrl: mvebu: add driver for Armada AP806 pinctrl

Git-commit: 86fbd09440f39d7eacf30684985ebe9370f5f813
Patch-mainline: v4.13-rc1
References: fate#326470

This commit adds a pinctrl driver for the pin-muxing controller found in
the AP806 part of the Marvell Armada 7K and 8K SoCs. Its register
interface is compatible with the one used by previous mvebu pin
controllers, so the common logic in drivers/pinctrl/mvebu/pinctrl-mvebu.c
is used.

Signed-off-by: Hanna Hawa <hannah@marvell.com>
Reviewed-by: Shadi Ammouri <shadi@marvell.com>
[updated for mvebu pinctrl changes
 - converted to simple_mmio
 - removed unimplemented .remove function
 - removed DTS description
  - converted  to use syscon/regmap
 --rmk]
Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
Reviewed-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

Signed-off-by: Mian Yousaf Kaukab <yousaf.kaukab@suse.com>
---
 drivers/pinctrl/mvebu/Kconfig                |   4 +
 drivers/pinctrl/mvebu/Makefile               |   1 +
 drivers/pinctrl/mvebu/pinctrl-armada-ap806.c | 140 +++++++++++++++++++++++++++
 3 files changed, 145 insertions(+)
 create mode 100644 drivers/pinctrl/mvebu/pinctrl-armada-ap806.c

diff --git a/drivers/pinctrl/mvebu/Kconfig b/drivers/pinctrl/mvebu/Kconfig
index 8cb444b60ae9..0e0b009f2b71 100644
--- a/drivers/pinctrl/mvebu/Kconfig
+++ b/drivers/pinctrl/mvebu/Kconfig
@@ -28,6 +28,10 @@ config PINCTRL_ARMADA_39X
 	bool
 	select PINCTRL_MVEBU
 
+config PINCTRL_ARMADA_AP806
+	bool
+	select PINCTRL_MVEBU
+
 config PINCTRL_ARMADA_XP
 	bool
 	select PINCTRL_MVEBU
diff --git a/drivers/pinctrl/mvebu/Makefile b/drivers/pinctrl/mvebu/Makefile
index 60c245a60f39..455db274b53d 100644
--- a/drivers/pinctrl/mvebu/Makefile
+++ b/drivers/pinctrl/mvebu/Makefile
@@ -5,6 +5,7 @@ obj-$(CONFIG_PINCTRL_ARMADA_370) += pinctrl-armada-370.o
 obj-$(CONFIG_PINCTRL_ARMADA_375) += pinctrl-armada-375.o
 obj-$(CONFIG_PINCTRL_ARMADA_38X) += pinctrl-armada-38x.o
 obj-$(CONFIG_PINCTRL_ARMADA_39X) += pinctrl-armada-39x.o
+obj-$(CONFIG_PINCTRL_ARMADA_AP806) += pinctrl-armada-ap806.o
 obj-$(CONFIG_PINCTRL_ARMADA_XP)  += pinctrl-armada-xp.o
 obj-$(CONFIG_PINCTRL_ARMADA_37XX)  += pinctrl-armada-37xx.o
 obj-$(CONFIG_PINCTRL_ORION)  += pinctrl-orion.o
diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c b/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c
new file mode 100644
index 000000000000..66e442260a4e
--- /dev/null
+++ b/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c
@@ -0,0 +1,140 @@
+/*
+ * Marvell Armada ap806 pinctrl driver based on mvebu pinctrl core
+ *
+ * Copyright (C) 2017 Marvell
+ *
+ * Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
+ * Hanna Hawa <hannah@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/pinctrl.h>
+
+#include "pinctrl-mvebu.h"
+
+static struct mvebu_mpp_mode armada_ap806_mpp_modes[] = {
+	MPP_MODE(0,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "clk"),
+		 MPP_FUNCTION(3, "spi0",    "clk")),
+	MPP_MODE(1,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "cmd"),
+		 MPP_FUNCTION(3, "spi0",    "miso")),
+	MPP_MODE(2,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d0"),
+		 MPP_FUNCTION(3, "spi0",    "mosi")),
+	MPP_MODE(3,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d1"),
+		 MPP_FUNCTION(3, "spi0",    "cs0n")),
+	MPP_MODE(4,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d2"),
+		 MPP_FUNCTION(3, "i2c0",    "sda")),
+	MPP_MODE(5,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d3"),
+		 MPP_FUNCTION(3, "i2c0",    "sdk")),
+	MPP_MODE(6,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "ds")),
+	MPP_MODE(7,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d4"),
+		 MPP_FUNCTION(3, "uart1",   "rxd")),
+	MPP_MODE(8,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d5"),
+		 MPP_FUNCTION(3, "uart1",   "txd")),
+	MPP_MODE(9,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d6"),
+		 MPP_FUNCTION(3, "spi0",    "cs1n")),
+	MPP_MODE(10,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d7")),
+	MPP_MODE(11,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(3, "uart0",   "txd")),
+	MPP_MODE(12,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "pw_off"),
+		 MPP_FUNCTION(2, "sdio",    "hw_rst")),
+	MPP_MODE(13,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(14,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(15,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(16,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(17,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(18,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(19,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(3, "uart0",   "rxd"),
+		 MPP_FUNCTION(4, "sdio",    "pw_off")),
+};
+
+static struct mvebu_pinctrl_soc_info armada_ap806_pinctrl_info;
+
+static const struct of_device_id armada_ap806_pinctrl_of_match[] = {
+	{
+		.compatible = "marvell,ap806-pinctrl",
+	},
+	{ },
+};
+
+static const struct mvebu_mpp_ctrl armada_ap806_mpp_controls[] = {
+	MPP_FUNC_CTRL(0, 19, NULL, mvebu_regmap_mpp_ctrl),
+};
+
+static struct pinctrl_gpio_range armada_ap806_mpp_gpio_ranges[] = {
+	MPP_GPIO_RANGE(0,   0,  0, 20),
+};
+
+static int armada_ap806_pinctrl_probe(struct platform_device *pdev)
+{
+	struct mvebu_pinctrl_soc_info *soc = &armada_ap806_pinctrl_info;
+	const struct of_device_id *match =
+		of_match_device(armada_ap806_pinctrl_of_match, &pdev->dev);
+
+	if (!match || !pdev->dev.parent)
+		return -ENODEV;
+
+	soc->variant = 0; /* no variants for Armada AP806 */
+	soc->controls = armada_ap806_mpp_controls;
+	soc->ncontrols = ARRAY_SIZE(armada_ap806_mpp_controls);
+	soc->gpioranges = armada_ap806_mpp_gpio_ranges;
+	soc->ngpioranges = ARRAY_SIZE(armada_ap806_mpp_gpio_ranges);
+	soc->modes = armada_ap806_mpp_modes;
+	soc->nmodes = armada_ap806_mpp_controls[0].npins;
+
+	pdev->dev.platform_data = soc;
+
+	return mvebu_pinctrl_simple_regmap_probe(pdev, pdev->dev.parent, 0);
+}
+
+static struct platform_driver armada_ap806_pinctrl_driver = {
+	.driver = {
+		.name = "armada-ap806-pinctrl",
+		.of_match_table = of_match_ptr(armada_ap806_pinctrl_of_match),
+	},
+	.probe = armada_ap806_pinctrl_probe,
+};
+
+builtin_platform_driver(armada_ap806_pinctrl_driver);
-- 
2.11.0

