From: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date: Tue, 16 May 2017 11:05:09 +0300
Subject: drm/omap: use DRM_MODE_ROTATE_* instead of OMAP_DSS_ROT_*
Git-commit: 0bd97c42d975a1e0849105bb8f23a68490683aab
Patch-mainline: v4.13-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

At the moment the dispc driver uses a custom enum for rotation. Change
it to use the DRM's DRM_MODE_ROTATE_*.

Note that mirroring is at the moment handled as a separate boolean in
the dispc driver, so we only use the DRM_MODE_ROTATE_* values.

Note, DSS HW uses clockwise rotation, DRM counter-clockwise.

Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/omapdrm/dss/dispc.c   |   60 +++++++++++++++++-----------------
 drivers/gpu/drm/omapdrm/dss/omapdss.h |    8 ----
 drivers/gpu/drm/omapdrm/omap_plane.c  |    2 -
 3 files changed, 31 insertions(+), 39 deletions(-)

--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -41,6 +41,7 @@
 #include <linux/of.h>
 #include <linux/component.h>
 #include <drm/drm_fourcc.h>
+#include <drm/drm_blend.h>
 
 #include "omapdss.h"
 #include "dss.h"
@@ -1600,22 +1601,21 @@ static void dispc_ovl_set_accu_uv(enum o
 		{  0, 1, 0, 1, -1, 1, 0, 1 },
 	};
 
-	switch (rotation) {
-	case OMAP_DSS_ROT_0:
+	/* Note: DSS HW rotates clockwise, DRM_MODE_ROTATE_* counter-clockwise */
+	switch (rotation & DRM_MODE_ROTATE_MASK) {
+	default:
+	case DRM_MODE_ROTATE_0:
 		idx = 0;
 		break;
-	case OMAP_DSS_ROT_90:
-		idx = 1;
+	case DRM_MODE_ROTATE_90:
+		idx = 3;
 		break;
-	case OMAP_DSS_ROT_180:
+	case DRM_MODE_ROTATE_180:
 		idx = 2;
 		break;
-	case OMAP_DSS_ROT_270:
-		idx = 3;
+	case DRM_MODE_ROTATE_270:
+		idx = 1;
 		break;
-	default:
-		BUG();
-		return;
 	}
 
 	switch (fourcc) {
@@ -1742,8 +1742,7 @@ static void dispc_ovl_set_scaling_uv(enu
 	case DRM_FORMAT_YUYV:
 	case DRM_FORMAT_UYVY:
 		/* For YUV422 with 90/270 rotation, we don't upsample chroma */
-		if (rotation == OMAP_DSS_ROT_0 ||
-				rotation == OMAP_DSS_ROT_180) {
+		if (!drm_rotation_90_or_270(rotation)) {
 			if (chroma_upscale)
 				/* UV is subsampled by 2 horizontally */
 				orig_width >>= 1;
@@ -1753,7 +1752,7 @@ static void dispc_ovl_set_scaling_uv(enu
 		}
 
 		/* must use FIR for YUV422 if rotated */
-		if (rotation != OMAP_DSS_ROT_0)
+		if ((rotation & DRM_MODE_ROTATE_MASK) != DRM_MODE_ROTATE_0)
 			scale_x = scale_y = true;
 
 		break;
@@ -1812,41 +1811,42 @@ static void dispc_ovl_set_rotation_attrs
 	bool row_repeat = false;
 	int vidrot = 0;
 
+	/* Note: DSS HW rotates clockwise, DRM_MODE_ROTATE_* counter-clockwise */
 	if (fourcc == DRM_FORMAT_YUYV || fourcc == DRM_FORMAT_UYVY) {
 
 		if (mirroring) {
-			switch (rotation) {
-			case OMAP_DSS_ROT_0:
+			switch (rotation & DRM_MODE_ROTATE_MASK) {
+			case DRM_MODE_ROTATE_0:
 				vidrot = 2;
 				break;
-			case OMAP_DSS_ROT_90:
-				vidrot = 1;
+			case DRM_MODE_ROTATE_90:
+				vidrot = 3;
 				break;
-			case OMAP_DSS_ROT_180:
+			case DRM_MODE_ROTATE_180:
 				vidrot = 0;
 				break;
-			case OMAP_DSS_ROT_270:
-				vidrot = 3;
+			case DRM_MODE_ROTATE_270:
+				vidrot = 1;
 				break;
 			}
 		} else {
-			switch (rotation) {
-			case OMAP_DSS_ROT_0:
+			switch (rotation & DRM_MODE_ROTATE_MASK) {
+			case DRM_MODE_ROTATE_0:
 				vidrot = 0;
 				break;
-			case OMAP_DSS_ROT_90:
-				vidrot = 1;
+			case DRM_MODE_ROTATE_90:
+				vidrot = 3;
 				break;
-			case OMAP_DSS_ROT_180:
+			case DRM_MODE_ROTATE_180:
 				vidrot = 2;
 				break;
-			case OMAP_DSS_ROT_270:
-				vidrot = 3;
+			case DRM_MODE_ROTATE_270:
+				vidrot = 1;
 				break;
 			}
 		}
 
-		if (rotation == OMAP_DSS_ROT_90 || rotation == OMAP_DSS_ROT_270)
+		if (drm_rotation_90_or_270(rotation))
 			row_repeat = true;
 		else
 			row_repeat = false;
@@ -1869,7 +1869,7 @@ static void dispc_ovl_set_rotation_attrs
 		bool doublestride =
 			fourcc == DRM_FORMAT_NV12 &&
 			rotation_type == OMAP_DSS_ROT_TILER &&
-			(rotation == OMAP_DSS_ROT_0 || rotation == OMAP_DSS_ROT_180);
+			!drm_rotation_90_or_270(rotation);
 
 		/* DOUBLESTRIDE */
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), doublestride, 22, 22);
@@ -3916,7 +3916,7 @@ static const struct dispc_errata_i734_da
 		.screen_width = 1,
 		.width = 1, .height = 1,
 		.fourcc = DRM_FORMAT_XRGB8888,
-		.rotation = OMAP_DSS_ROT_0,
+		.rotation = DRM_MODE_ROTATE_0,
 		.rotation_type = OMAP_DSS_ROT_NONE,
 		.mirror = 0,
 		.pos_x = 0, .pos_y = 0,
--- a/drivers/gpu/drm/omapdrm/dss/omapdss.h
+++ b/drivers/gpu/drm/omapdrm/dss/omapdss.h
@@ -149,14 +149,6 @@ enum omap_dss_rotation_type {
 	OMAP_DSS_ROT_TILER	= 1 << 0,
 };
 
-/* clockwise rotation angle */
-enum omap_dss_rotation_angle {
-	OMAP_DSS_ROT_0   = 0,
-	OMAP_DSS_ROT_90  = 1,
-	OMAP_DSS_ROT_180 = 2,
-	OMAP_DSS_ROT_270 = 3,
-};
-
 enum omap_overlay_caps {
 	OMAP_DSS_OVL_CAP_SCALE = 1 << 0,
 	OMAP_DSS_OVL_CAP_GLOBAL_ALPHA = 1 << 1,
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -65,7 +65,7 @@ static void omap_plane_atomic_update(str
 
 	memset(&info, 0, sizeof(info));
 	info.rotation_type = OMAP_DSS_ROT_NONE;
-	info.rotation = OMAP_DSS_ROT_0;
+	info.rotation = DRM_MODE_ROTATE_0;
 	info.global_alpha = 0xff;
 	info.mirror = 0;
 	info.zorder = state->zpos;
