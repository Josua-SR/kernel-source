From: Chuck Lever <chuck.lever@oracle.com>
Date: Tue, 27 Mar 2018 10:50:07 -0400
Subject: sunrpc: Move trace_svc_xprt_dequeue()
Patch-mainline: v4.17-rc1
Git-commit: caa3e106dc623eb41542e6221abecf9956e8a0e6
References: bsc#1103992 FATE#326009

Reduce the amount of noise generated by trace_svc_xprt_dequeue by
moving it to the end of svc_get_next_xprt. This generates exactly
one trace event when a ready xprt is found, rather than spurious
events when there is no work to do. The empty events contain no
information that can't be obtained simply by tracing function calls
to svc_xprt_dequeue.

A small additional benefit is simplification of the svc_xprt_event
trace class, which no longer has to handle the case when the @xprt
parameter is NULL.

Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
Signed-off-by: J. Bruce Fields <bfields@redhat.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 include/trace/events/sunrpc.h |   16 +++++-----------
 net/sunrpc/svc_xprt.c         |    9 ++++-----
 2 files changed, 9 insertions(+), 16 deletions(-)

--- a/include/trace/events/sunrpc.h
+++ b/include/trace/events/sunrpc.h
@@ -597,24 +597,18 @@ DECLARE_EVENT_CLASS(svc_xprt_event,
 	TP_STRUCT__entry(
 		__field(struct svc_xprt *, xprt)
 		__field(unsigned long, flags)
-		__dynamic_array(unsigned char, addr, xprt != NULL ?
-			xprt->xpt_remotelen : 0)
+		__dynamic_array(unsigned char, addr, xprt->xpt_remotelen)
 	),
 
 	TP_fast_assign(
 		__entry->xprt = xprt;
-		if (xprt) {
-			memcpy(__get_dynamic_array(addr),
-					&xprt->xpt_remote,
-					xprt->xpt_remotelen);
-			__entry->flags = xprt->xpt_flags;
-		} else
-			__entry->flags = 0;
+		__entry->flags = xprt->xpt_flags;
+		memcpy(__get_dynamic_array(addr),
+		       &xprt->xpt_remote, xprt->xpt_remotelen);
 	),
 
 	TP_printk("xprt=0x%p addr=%pIScp flags=%s", __entry->xprt,
-		__get_dynamic_array_len(addr) != 0 ?
-			(struct sockaddr *)__get_dynamic_array(addr) : NULL,
+		(struct sockaddr *)__get_dynamic_array(addr),
 		show_svc_xprt_flags(__entry->flags))
 );
 
--- a/net/sunrpc/svc_xprt.c
+++ b/net/sunrpc/svc_xprt.c
@@ -488,13 +488,9 @@ static struct svc_xprt *svc_xprt_dequeue
 					struct svc_xprt, xpt_ready);
 		list_del_init(&xprt->xpt_ready);
 		svc_xprt_get(xprt);
-
-		dprintk("svc: transport %p dequeued, inuse=%d\n",
-			xprt, kref_read(&xprt->xpt_ref));
 	}
 	spin_unlock_bh(&pool->sp_lock);
 out:
-	trace_svc_xprt_dequeue(xprt);
 	return xprt;
 }
 
@@ -741,6 +737,7 @@ static struct svc_xprt *svc_get_next_xpr
 		 */
 		rqstp->rq_chandle.thread_wait = 1*HZ;
 		clear_bit(SP_TASK_PENDING, &pool->sp_flags);
+		trace_svc_xprt_dequeue(xprt);
 		return xprt;
 	}
 
@@ -764,8 +761,10 @@ static struct svc_xprt *svc_get_next_xpr
 	spin_unlock_bh(&rqstp->rq_lock);
 
 	xprt = rqstp->rq_xprt;
-	if (xprt != NULL)
+	if (xprt != NULL) {
+		trace_svc_xprt_dequeue(xprt);
 		return xprt;
+	}
 
 	if (!time_left)
 		atomic_long_inc(&pool->sp_stats.threads_timedout);
