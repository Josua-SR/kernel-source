From: Rex Zhu <Rex.Zhu@amd.com>
Date: Wed, 7 Mar 2018 16:14:38 +0800
Subject: drm/amd/pp: Add rv_copy_table_from/to_smc to smu backend function
 table
Git-commit: 0d8a81d926ec76546d34efcb1fd104c117785000
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/amd/powerplay/hwmgr/rv_hwmgr.c   |    3 -
 drivers/gpu/drm/amd/powerplay/inc/smumgr.h       |    5 +
 drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.c |   61 +++++++++++++----------
 drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h |   11 ----
 4 files changed, 44 insertions(+), 36 deletions(-)

--- a/drivers/gpu/drm/amd/powerplay/hwmgr/rv_hwmgr.c
+++ b/drivers/gpu/drm/amd/powerplay/hwmgr/rv_hwmgr.c
@@ -34,7 +34,6 @@
 #include "rv_ppsmc.h"
 #include "rv_hwmgr.h"
 #include "power_state.h"
-#include "rv_smumgr.h"
 #include "pp_soc15.h"
 
 #define RAVEN_MAX_DEEPSLEEP_DIVIDER_ID     5
@@ -347,7 +346,7 @@ static int rv_populate_clock_table(struc
 	DpmClocks_t  *table = &(rv_data->clock_table);
 	struct rv_clock_voltage_information *pinfo = &(rv_data->clock_vol_info);
 
-	result = rv_copy_table_from_smc(hwmgr, (uint8_t *)table, CLOCKTABLE);
+	result = smum_smc_table_manager(hwmgr, (uint8_t *)table, SMU10_CLOCKTABLE, true);
 
 	PP_ASSERT_WITH_CODE((0 == result),
 			"Attempt to copy clock table from smc failed",
--- a/drivers/gpu/drm/amd/powerplay/inc/smumgr.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/smumgr.h
@@ -69,6 +69,11 @@ enum SMU_MAC_DEFINITION {
 	SMU_UVD_MCLK_HANDSHAKE_DISABLE,
 };
 
+enum SMU10_TABLE_ID {
+	SMU10_WMTABLE = 0,
+	SMU10_CLOCKTABLE,
+};
+
 extern int smum_get_argument(struct pp_hwmgr *hwmgr);
 
 extern int smum_download_powerplay_table(struct pp_hwmgr *hwmgr, void **table);
--- a/drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.c
@@ -125,7 +125,7 @@ static int rv_send_msg_to_smc_with_param
 	return 0;
 }
 
-int rv_copy_table_from_smc(struct pp_hwmgr *hwmgr,
+static int rv_copy_table_from_smc(struct pp_hwmgr *hwmgr,
 		uint8_t *table, int16_t table_id)
 {
 	struct rv_smumgr *priv =
@@ -153,7 +153,7 @@ int rv_copy_table_from_smc(struct pp_hwm
 	return 0;
 }
 
-int rv_copy_table_to_smc(struct pp_hwmgr *hwmgr,
+static int rv_copy_table_to_smc(struct pp_hwmgr *hwmgr,
 		uint8_t *table, int16_t table_id)
 {
 	struct rv_smumgr *priv =
@@ -232,12 +232,12 @@ static int rv_smu_fini(struct pp_hwmgr *
 	if (priv) {
 		rv_smc_disable_sdma(hwmgr);
 		rv_smc_disable_vcn(hwmgr);
-		amdgpu_bo_free_kernel(&priv->smu_tables.entry[WMTABLE].handle,
-					&priv->smu_tables.entry[WMTABLE].mc_addr,
-					priv->smu_tables.entry[WMTABLE].table);
-		amdgpu_bo_free_kernel(&priv->smu_tables.entry[CLOCKTABLE].handle,
-					&priv->smu_tables.entry[CLOCKTABLE].mc_addr,
-					priv->smu_tables.entry[CLOCKTABLE].table);
+		amdgpu_bo_free_kernel(&priv->smu_tables.entry[SMU10_WMTABLE].handle,
+					&priv->smu_tables.entry[SMU10_WMTABLE].mc_addr,
+					priv->smu_tables.entry[SMU10_WMTABLE].table);
+		amdgpu_bo_free_kernel(&priv->smu_tables.entry[SMU10_CLOCKTABLE].handle,
+					&priv->smu_tables.entry[SMU10_CLOCKTABLE].mc_addr,
+					priv->smu_tables.entry[SMU10_CLOCKTABLE].table);
 		kfree(hwmgr->smu_backend);
 		hwmgr->smu_backend = NULL;
 	}
@@ -279,45 +279,57 @@ static int rv_smu_init(struct pp_hwmgr *
 			sizeof(Watermarks_t),
 			PAGE_SIZE,
 			AMDGPU_GEM_DOMAIN_VRAM,
-			&priv->smu_tables.entry[WMTABLE].handle,
-			&priv->smu_tables.entry[WMTABLE].mc_addr,
-			&priv->smu_tables.entry[WMTABLE].table);
+			&priv->smu_tables.entry[SMU10_WMTABLE].handle,
+			&priv->smu_tables.entry[SMU10_WMTABLE].mc_addr,
+			&priv->smu_tables.entry[SMU10_WMTABLE].table);
 
 	if (r)
 		goto err0;
 
-	priv->smu_tables.entry[WMTABLE].version = 0x01;
-	priv->smu_tables.entry[WMTABLE].size = sizeof(Watermarks_t);
-	priv->smu_tables.entry[WMTABLE].table_id = TABLE_WATERMARKS;
-
+	priv->smu_tables.entry[SMU10_WMTABLE].version = 0x01;
+	priv->smu_tables.entry[SMU10_WMTABLE].size = sizeof(Watermarks_t);
+	priv->smu_tables.entry[SMU10_WMTABLE].table_id = TABLE_WATERMARKS;
 
 	/* allocate space for watermarks table */
 	r = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,
 			sizeof(DpmClocks_t),
 			PAGE_SIZE,
 			AMDGPU_GEM_DOMAIN_VRAM,
-			&priv->smu_tables.entry[CLOCKTABLE].handle,
-			&priv->smu_tables.entry[CLOCKTABLE].mc_addr,
-			&priv->smu_tables.entry[CLOCKTABLE].table);
+			&priv->smu_tables.entry[SMU10_CLOCKTABLE].handle,
+			&priv->smu_tables.entry[SMU10_CLOCKTABLE].mc_addr,
+			&priv->smu_tables.entry[SMU10_CLOCKTABLE].table);
 
 	if (r)
 		goto err1;
 
-	priv->smu_tables.entry[CLOCKTABLE].version = 0x01;
-	priv->smu_tables.entry[CLOCKTABLE].size = sizeof(DpmClocks_t);
-	priv->smu_tables.entry[CLOCKTABLE].table_id = TABLE_DPMCLOCKS;
+	priv->smu_tables.entry[SMU10_CLOCKTABLE].version = 0x01;
+	priv->smu_tables.entry[SMU10_CLOCKTABLE].size = sizeof(DpmClocks_t);
+	priv->smu_tables.entry[SMU10_CLOCKTABLE].table_id = TABLE_DPMCLOCKS;
 
 	return 0;
 
 err1:
-	amdgpu_bo_free_kernel(&priv->smu_tables.entry[WMTABLE].handle,
-				&priv->smu_tables.entry[WMTABLE].mc_addr,
-				&priv->smu_tables.entry[WMTABLE].table);
+	amdgpu_bo_free_kernel(&priv->smu_tables.entry[SMU10_WMTABLE].handle,
+				&priv->smu_tables.entry[SMU10_WMTABLE].mc_addr,
+				&priv->smu_tables.entry[SMU10_WMTABLE].table);
 err0:
 	kfree(priv);
 	return -EINVAL;
 }
 
+static int rv_smc_table_manager(struct pp_hwmgr *hwmgr, uint8_t *table, uint16_t table_id, bool rw)
+{
+	int ret;
+
+	if (rw)
+		ret = rv_copy_table_from_smc(hwmgr, table, table_id);
+	else
+		ret = rv_copy_table_to_smc(hwmgr, table, table_id);
+
+	return ret;
+}
+
+
 const struct pp_smumgr_func rv_smu_funcs = {
 	.smu_init = &rv_smu_init,
 	.smu_fini = &rv_smu_fini,
@@ -328,6 +340,7 @@ const struct pp_smumgr_func rv_smu_funcs
 	.download_pptable_settings = NULL,
 	.upload_pptable_settings = NULL,
 	.get_argument = rv_read_arg_from_smc,
+	.smc_table_manager = rv_smc_table_manager,
 };
 
 
--- a/drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h
@@ -27,11 +27,7 @@
 #include "rv_ppsmc.h"
 #include "smu10_driver_if.h"
 
-enum SMU_TABLE_ID {
-	WMTABLE = 0,
-	CLOCKTABLE,
-	MAX_SMU_TABLE,
-};
+#define MAX_SMU_TABLE 2
 
 struct smu_table_entry {
 	uint32_t version;
@@ -50,10 +46,5 @@ struct rv_smumgr {
 	struct smu_table_array            smu_tables;
 };
 
-int rv_copy_table_from_smc(struct pp_hwmgr *hwmgr,
-		uint8_t *table, int16_t table_id);
-int rv_copy_table_to_smc(struct pp_hwmgr *hwmgr,
-		uint8_t *table, int16_t table_id);
-
 
 #endif
