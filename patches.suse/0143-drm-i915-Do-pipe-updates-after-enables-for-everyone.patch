From bec702a70213d8e236f23ad55556273f2cc1b8fb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Fri, 13 Mar 2020 18:48:29 +0200
Subject: drm/i915: Do pipe updates after enables for everyone
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 1ff241ea2b26b6485587e3d1b6997999ab7ea285
Patch-mainline: v5.8-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

Currently only port sync pipes do the sequence such that
we first do the modeset part for every pipe and then do
the plane/etc. updates. Let's follow that apporach for
all pipes in skl+ so that we can properly integrate the
port sync into the normal modeset flow.

v2: Remove now stale TODO of port sync slave entries[]
    s/oldnew/new/

Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200313164831.5980-12-ville.syrjala@linux.intel.com
Reviewed-by: José Roberto de Souza <jose.souza@intel.com>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/i915/display/intel_display.c | 44 ++++++++++----------
 1 file changed, 21 insertions(+), 23 deletions(-)

diff --git a/drivers/gpu/drm/i915/display/intel_display.c b/drivers/gpu/drm/i915/display/intel_display.c
index 1a99246c555d..b67cdefd386c 100644
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@ -15152,17 +15152,6 @@ static void intel_update_trans_port_sync_crtcs(struct intel_atomic_state *state,
 
 	usleep_range(200, 400);
 	intel_set_dp_tp_ctl_normal(state, crtc);
-
-	for_each_new_intel_crtc_in_state(state, slave_crtc,
-					 new_slave_crtc_state, i) {
-		if (new_slave_crtc_state->master_transcoder !=
-		    new_crtc_state->cpu_transcoder)
-			continue;
-
-		intel_update_crtc(state, slave_crtc);
-	}
-
-	intel_update_crtc(state, crtc);
 }
 
 static void icl_dbuf_slice_pre_update(struct intel_atomic_state *state)
@@ -15251,6 +15240,8 @@ static void skl_commit_modeset_enables(struct intel_atomic_state *state)
 		}
 	}
 
+	update_pipes = modeset_pipes;
+
 	/*
 	 * Enable all pipes that needs a modeset and do not depends on other
 	 * pipes
@@ -15265,10 +15256,6 @@ static void skl_commit_modeset_enables(struct intel_atomic_state *state)
 		    is_trans_port_sync_slave(new_crtc_state))
 			continue;
 
-		drm_WARN_ON(&dev_priv->drm, skl_ddb_allocation_overlaps(&new_crtc_state->wm.skl.ddb,
-									entries, I915_MAX_PIPES, pipe));
-
-		entries[pipe] = new_crtc_state->wm.skl.ddb;
 		modeset_pipes &= ~BIT(pipe);
 
 		if (is_trans_port_sync_mode(new_crtc_state)) {
@@ -15284,19 +15271,17 @@ static void skl_commit_modeset_enables(struct intel_atomic_state *state)
 				    new_crtc_state->cpu_transcoder)
 					continue;
 
-				/* TODO: update entries[] of slave */
 				modeset_pipes &= ~BIT(slave_crtc->pipe);
 			}
 		} else {
 			intel_enable_crtc(state, crtc);
-			intel_update_crtc(state, crtc);
 		}
 	}
 
 	/*
-	 * Finally enable all pipes that needs a modeset and depends on
-	 * other pipes, right now it is only MST slaves as both port sync slave
-	 * and master are enabled together
+	 * Then we enable all remaining pipes that depend on other
+	 * pipes, right now it is only MST slaves as both port sync
+	 * slave and master are enabled together
 	 */
 	for_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {
 		enum pipe pipe = crtc->pipe;
@@ -15304,18 +15289,31 @@ static void skl_commit_modeset_enables(struct intel_atomic_state *state)
 		if ((modeset_pipes & BIT(pipe)) == 0)
 			continue;
 
+		modeset_pipes &= ~BIT(pipe);
+
+		intel_enable_crtc(state, crtc);
+	}
+
+	/*
+	 * Finally we do the plane updates/etc. for all pipes that got enabled.
+	 */
+	for_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {
+		enum pipe pipe = crtc->pipe;
+
+		if ((update_pipes & BIT(pipe)) == 0)
+			continue;
+
 		drm_WARN_ON(&dev_priv->drm, skl_ddb_allocation_overlaps(&new_crtc_state->wm.skl.ddb,
 									entries, I915_MAX_PIPES, pipe));
 
 		entries[pipe] = new_crtc_state->wm.skl.ddb;
-		modeset_pipes &= ~BIT(pipe);
+		update_pipes &= ~BIT(pipe);
 
-		intel_enable_crtc(state, crtc);
 		intel_update_crtc(state, crtc);
 	}
 
 	drm_WARN_ON(&dev_priv->drm, modeset_pipes);
-
+	drm_WARN_ON(&dev_priv->drm, update_pipes);
 }
 
 static void intel_atomic_helper_free_state(struct drm_i915_private *dev_priv)
-- 
2.28.0

