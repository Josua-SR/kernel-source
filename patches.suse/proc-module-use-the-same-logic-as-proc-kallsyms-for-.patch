From: Linus Torvalds <torvalds@linux-foundation.org>
Date: Sun, 12 Nov 2017 18:44:23 -0800
Subject: /proc/module: use the same logic as /proc/kallsyms for address
 exposure
Patch-mainline: v4.15-rc1
Git-commit: 516fb7f2e73dcc303fb97fc3593209fcacf2d982
References: bsc#1109837

The (alleged) users of the module addresses are the same: kernel
profiling.

So just expose the same helper and format macros, and unify the logic.

Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 include/linux/kallsyms.h |    8 ++++++++
 kernel/kallsyms.c        |    8 +-------
 kernel/module.c          |   20 ++++++++++++++++++--
 3 files changed, 27 insertions(+), 9 deletions(-)

--- a/include/linux/kallsyms.h
+++ b/include/linux/kallsyms.h
@@ -13,6 +13,14 @@
 #define KSYM_SYMBOL_LEN (sizeof("%s+%#lx/%#lx [%s]") + (KSYM_NAME_LEN - 1) + \
 			 2*(BITS_PER_LONG*3/10) + (MODULE_NAME_LEN - 1) + 1)
 
+/* How and when do we show kallsyms values? */
+extern int kallsyms_show_value(void);
+#ifndef CONFIG_64BIT
+# define KALLSYM_FMT "%08lx"
+#else
+# define KALLSYM_FMT "%016lx"
+#endif
+
 struct module;
 
 #ifdef CONFIG_KALLSYMS
--- a/kernel/kallsyms.c
+++ b/kernel/kallsyms.c
@@ -587,12 +587,6 @@ static void s_stop(struct seq_file *m, v
 {
 }
 
-#ifndef CONFIG_64BIT
-# define KALLSYM_FMT "%08lx"
-#else
-# define KALLSYM_FMT "%016lx"
-#endif
-
 static int s_show(struct seq_file *m, void *p)
 {
 	unsigned long value;
@@ -646,7 +640,7 @@ static inline int kallsyms_for_perf(void
  * Otherwise, require CAP_SYSLOG (assuming kptr_restrict isn't set to
  * block even that).
  */
-static int kallsyms_show_value(void)
+int kallsyms_show_value(void)
 {
 	switch (kptr_restrict) {
 	case 0:
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -4129,6 +4129,7 @@ static int m_show(struct seq_file *m, vo
 {
 	struct module *mod = list_entry(p, struct module, list);
 	char buf[MODULE_FLAGS_BUF_SIZE];
+	unsigned long value;
 
 	/* We always ignore unformed modules. */
 	if (mod->state == MODULE_STATE_UNFORMED)
@@ -4144,7 +4145,8 @@ static int m_show(struct seq_file *m, vo
 		   mod->state == MODULE_STATE_COMING ? "Loading" :
 		   "Live");
 	/* Used by oprofile and other similar tools. */
-	seq_printf(m, " 0x%pK", mod->core_layout.base);
+	value = m->private ? 0 : (unsigned long)mod->core_layout.base;
+	seq_printf(m, " 0x" KALLSYM_FMT, value);
 
 	/* Taints info */
 	if (mod->taints)
@@ -4166,9 +4168,23 @@ static const struct seq_operations modul
 	.show	= m_show
 };
 
+/*
+ * This also sets the "private" pointer to non-NULL if the
+ * kernel pointers should be hidden (so you can just test
+ * "m->private" to see if you should keep the values private).
+ *
+ * We use the same logic as for /proc/kallsyms.
+ */
 static int modules_open(struct inode *inode, struct file *file)
 {
-	return seq_open(file, &modules_op);
+	int err = seq_open(file, &modules_op);
+
+	if (!err) {
+		struct seq_file *m = file->private_data;
+		m->private = kallsyms_show_value() ? NULL : (void *)8ul;
+	}
+
+	return 0;
 }
 
 static const struct file_operations proc_modules_operations = {
