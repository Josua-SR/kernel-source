From: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date: Thu, 10 Aug 2017 09:33:07 +0300
Subject: drm/omap: add OMAP5 DSIPHY lane-enable support
Git-commit: eeb45f85cd25b9bbb91e966b5f8faca6589d2752
Patch-mainline: v4.14-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

We are missing OMAP5 DSIPHY lane-enable support, which has prevented
OMAP5 DSI working in mainline. This patch adds the lane-enable similarly
to the recently added OMAP4 version.

Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/omapdrm/dss/dsi.c |   47 +++++++++++++++++++++++++++++++-------
 1 file changed, 39 insertions(+), 8 deletions(-)

--- a/drivers/gpu/drm/omapdrm/dss/dsi.c
+++ b/drivers/gpu/drm/omapdrm/dss/dsi.c
@@ -2108,9 +2108,6 @@ static int dsi_omap4_mux_pads(struct dsi
 	u32 enable_mask, enable_shift;
 	u32 pipd_mask, pipd_shift;
 
-	if (!dsi->syscon)
-		return 0;
-
 	if (dsi->module_id == 0) {
 		enable_mask = OMAP4_DSI1_LANEENABLE_MASK;
 		enable_shift = OMAP4_DSI1_LANEENABLE_SHIFT;
@@ -2130,14 +2127,45 @@ static int dsi_omap4_mux_pads(struct dsi
 		(lanes << enable_shift) | (lanes << pipd_shift));
 }
 
+/* OMAP5 CONTROL_DSIPHY */
+
+#define OMAP5_DSIPHY_SYSCON_OFFSET	0x74
+
+#define OMAP5_DSI1_LANEENABLE_SHIFT	24
+#define OMAP5_DSI2_LANEENABLE_SHIFT	19
+#define OMAP5_DSI_LANEENABLE_MASK	0x1f
+
+static int dsi_omap5_mux_pads(struct dsi_data *dsi, unsigned int lanes)
+{
+	u32 enable_shift;
+
+	if (dsi->module_id == 0)
+		enable_shift = OMAP5_DSI1_LANEENABLE_SHIFT;
+	else if (dsi->module_id == 1)
+		enable_shift = OMAP5_DSI2_LANEENABLE_SHIFT;
+	else
+		return -ENODEV;
+
+	return regmap_update_bits(dsi->syscon, OMAP5_DSIPHY_SYSCON_OFFSET,
+		OMAP5_DSI_LANEENABLE_MASK << enable_shift,
+		lanes << enable_shift);
+}
+
 static int dsi_enable_pads(struct dsi_data *dsi, unsigned int lane_mask)
 {
-	return dsi_omap4_mux_pads(dsi, lane_mask);
+	if (dsi->data->model == DSI_MODEL_OMAP4)
+		return dsi_omap4_mux_pads(dsi, lane_mask);
+	if (dsi->data->model == DSI_MODEL_OMAP5)
+		return dsi_omap5_mux_pads(dsi, lane_mask);
+	return 0;
 }
 
 static void dsi_disable_pads(struct dsi_data *dsi)
 {
-	dsi_omap4_mux_pads(dsi, 0);
+	if (dsi->data->model == DSI_MODEL_OMAP4)
+		dsi_omap4_mux_pads(dsi, 0);
+	else if (dsi->data->model == DSI_MODEL_OMAP5)
+		dsi_omap5_mux_pads(dsi, 0);
 }
 
 static int dsi_cio_init(struct platform_device *dsidev)
@@ -5471,14 +5499,17 @@ static int dsi_bind(struct device *dev,
 
 	dsi->module_id = d->id;
 
-	if (dsi->data->model == DSI_MODEL_OMAP4) {
+	if (dsi->data->model == DSI_MODEL_OMAP4 ||
+	    dsi->data->model == DSI_MODEL_OMAP5) {
 		struct device_node *np;
 
 		/*
-		 * The OMAP4 display DT bindings don't reference the padconf
+		 * The OMAP4/5 display DT bindings don't reference the padconf
 		 * syscon. Our only option to retrieve it is to find it by name.
 		 */
-		np = of_find_node_by_name(NULL, "omap4_padconf_global");
+		np = of_find_node_by_name(NULL,
+			dsi->data->model == DSI_MODEL_OMAP4 ?
+			"omap4_padconf_global" : "omap5_padconf_global");
 		if (!np)
 			return -ENODEV;
 
