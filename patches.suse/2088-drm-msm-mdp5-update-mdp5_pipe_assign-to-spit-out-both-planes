From: Archit Taneja <architt@codeaurora.org>
Date: Fri, 27 Oct 2017 16:27:30 +0530
Subject: drm/msm/mdp5: Update mdp5_pipe_assign to spit out both planes
Git-commit: b14892801078085cb54dcbe3389057e12c1746a2
Patch-mainline: v4.15-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

We currently call mdp5_pipe_assign() twice to assign the left and right
hwpipes for our drm_plane. When merging 2 hwpipes, there are a few
constraints that we need to keep in mind:

- Only the same types of SSPPs are preferred. I.e, a RGB pipe should
  be paired with another RGB pipe, VIG with VIG etc.
- The hwpipe staged on the left should have a higher priority than
  the hwpipe staged on the right. The priorities are as follows:
  VIG0 > VIG1 > VIG2 > VIG3
  RGB0 > RGB1 > RGB2 > RGB3
  DMA0 > DMA1

We can't apply these constraints easily if mdp5_pipe_assign() is
called twice. Update mdp5_pipe_assign() to find both hwpipes in
one go, and add the extra constraints needed.

Signed-off-by: Archit Taneja <architt@codeaurora.org>
Signed-off-by: Rob Clark <robdclark@gmail.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/msm/mdp/mdp5/mdp5_pipe.c  |   45 +++++++++++++++++++++++++++---
 drivers/gpu/drm/msm/mdp/mdp5/mdp5_pipe.h  |    7 ++--
 drivers/gpu/drm/msm/mdp/mdp5/mdp5_plane.c |   25 ++++++++--------
 3 files changed, 57 insertions(+), 20 deletions(-)

--- a/drivers/gpu/drm/msm/mdp/mdp5/mdp5_pipe.c
+++ b/drivers/gpu/drm/msm/mdp/mdp5/mdp5_pipe.c
@@ -19,13 +19,14 @@
 
 int mdp5_pipe_assign(struct drm_atomic_state *s, struct drm_plane *plane,
 		     uint32_t caps, uint32_t blkcfg,
-		     struct mdp5_hw_pipe **hwpipe)
+		     struct mdp5_hw_pipe **hwpipe,
+		     struct mdp5_hw_pipe **r_hwpipe)
 {
 	struct msm_drm_private *priv = s->dev->dev_private;
 	struct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(priv->kms));
 	struct mdp5_state *state;
 	struct mdp5_hw_pipe_state *old_state, *new_state;
-	int i;
+	int i, j;
 
 	state = mdp5_get_state(s);
 	if (IS_ERR(state))
@@ -65,16 +66,46 @@ int mdp5_pipe_assign(struct drm_atomic_s
 		 * fewest unneeded caps bits set:
 		 */
 		if (!(*hwpipe) || (hweight_long(cur->caps & ~caps) <
-				   hweight_long((*hwpipe)->caps & ~caps)))
-			*hwpipe = cur;
+				   hweight_long((*hwpipe)->caps & ~caps))) {
+			bool r_found = false;
+
+			if (r_hwpipe) {
+				for (j = i + 1; j < mdp5_kms->num_hwpipes;
+				     j++) {
+					struct mdp5_hw_pipe *r_cur =
+							mdp5_kms->hwpipes[j];
+
+					/* reject different types of hwpipes */
+					if (r_cur->caps != cur->caps)
+						continue;
+
+					/* respect priority, eg. VIG0 > VIG1 */
+					if (cur->pipe > r_cur->pipe)
+						continue;
+
+					*r_hwpipe = r_cur;
+					r_found = true;
+					break;
+				}
+			}
+
+			if (!r_hwpipe || r_found)
+				*hwpipe = cur;
+		}
 	}
 
 	if (!(*hwpipe))
 		return -ENOMEM;
 
+	if (r_hwpipe && !(*r_hwpipe))
+		return -ENOMEM;
+
 	if (mdp5_kms->smp) {
 		int ret;
 
+		/* We don't support SMP and 2 hwpipes/plane together */
+		WARN_ON(r_hwpipe);
+
 		DBG("%s: alloc SMP blocks", (*hwpipe)->name);
 		ret = mdp5_smp_assign(mdp5_kms->smp, &state->smp,
 				(*hwpipe)->pipe, blkcfg);
@@ -88,6 +119,12 @@ int mdp5_pipe_assign(struct drm_atomic_s
 			(*hwpipe)->name, plane->name, caps);
 	new_state->hwpipe_to_plane[(*hwpipe)->idx] = plane;
 
+	if (r_hwpipe) {
+		DBG("%s: assign to right of plane %s for caps %x",
+		    (*r_hwpipe)->name, plane->name, caps);
+		new_state->hwpipe_to_plane[(*r_hwpipe)->idx] = plane;
+	}
+
 	return 0;
 }
 
--- a/drivers/gpu/drm/msm/mdp/mdp5/mdp5_pipe.h
+++ b/drivers/gpu/drm/msm/mdp/mdp5/mdp5_pipe.h
@@ -44,9 +44,10 @@ struct mdp5_hw_pipe_state {
 	struct drm_plane *hwpipe_to_plane[SSPP_MAX];
 };
 
-int
-mdp5_pipe_assign(struct drm_atomic_state *s, struct drm_plane *plane,
-		 uint32_t caps, uint32_t blkcfg, struct mdp5_hw_pipe **hwpipe);
+int mdp5_pipe_assign(struct drm_atomic_state *s, struct drm_plane *plane,
+		     uint32_t caps, uint32_t blkcfg,
+		     struct mdp5_hw_pipe **hwpipe,
+		     struct mdp5_hw_pipe **r_hwpipe);
 void mdp5_pipe_release(struct drm_atomic_state *s, struct mdp5_hw_pipe *hwpipe);
 
 struct mdp5_hw_pipe *mdp5_pipe_init(enum mdp5_pipe pipe,
--- a/drivers/gpu/drm/msm/mdp/mdp5/mdp5_plane.c
+++ b/drivers/gpu/drm/msm/mdp/mdp5/mdp5_plane.c
@@ -393,31 +393,30 @@ static int mdp5_plane_atomic_check_with_
 			struct mdp5_hw_pipe *old_hwpipe = mdp5_state->hwpipe;
 			struct mdp5_hw_pipe *old_right_hwpipe =
 							  mdp5_state->r_hwpipe;
+			struct mdp5_hw_pipe *new_hwpipe = NULL;
+			struct mdp5_hw_pipe *new_right_hwpipe = NULL;
 
 			ret = mdp5_pipe_assign(state->state, plane, caps,
-					       blkcfg, &mdp5_state->hwpipe);
+					       blkcfg, &new_hwpipe,
+					       need_right_hwpipe ?
+					       &new_right_hwpipe : NULL);
 			if (ret) {
-				DBG("%s: failed to assign hwpipe!", plane->name);
+				DBG("%s: failed to assign hwpipe(s)!",
+				    plane->name);
 				return ret;
 			}
 
-			if (need_right_hwpipe) {
-				ret = mdp5_pipe_assign(state->state, plane,
-						       caps, blkcfg,
-						       &mdp5_state->r_hwpipe);
-				if (ret) {
-					DBG("%s: failed to assign right hwpipe",
-					    plane->name);
-					return ret;
-				}
-			} else {
+			mdp5_state->hwpipe = new_hwpipe;
+			if (need_right_hwpipe)
+				mdp5_state->r_hwpipe = new_right_hwpipe;
+			else
 				/*
 				 * set it to NULL so that the driver knows we
 				 * don't have a right hwpipe when committing a
 				 * new state
 				 */
 				mdp5_state->r_hwpipe = NULL;
-			}
+
 
 			mdp5_pipe_release(state->state, old_hwpipe);
 			mdp5_pipe_release(state->state, old_right_hwpipe);
