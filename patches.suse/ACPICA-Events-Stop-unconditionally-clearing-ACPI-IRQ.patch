From: Erik Schmauss <erik.schmauss@intel.com>
Date: Wed, 14 Mar 2018 16:12:57 -0700
Subject: ACPICA: Events: Stop unconditionally clearing ACPI IRQs during
 suspend/resume
Patch-mainline: v4.17-rc1
Git-commit: 18996f2db9186cbabe3a7e7085bfb80408b32755
References: bsc#1117419

Unconditionally clearing ACPI IRQs during suspend/resume can lead to
unexpected IRQ losts. This patch fixes this issue by removing such IRQ
clearing code.

If this patch triggers regression, the regression should be in the GPE
handlers that cannot correctly determine some spurious triggered events as
no-ops. Please report any regression related to this commit to the ACPI
component on kernel bugzilla. Lv Zheng.

Link: https://bugzilla.kernel.org/show_bug.cgi?id=196249
Signed-off-by: Lv Zheng <lv.zheng@intel.com>
Reported-and-tested-by: Eric Bakula-Davis <ericbakuladavis@gmail.com>
Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Acked-by: Lee, Chun-Yi <jlee@suse.com>
---
 drivers/acpi/acpica/evgpe.c     |    9 +--------
 drivers/acpi/acpica/hwgpe.c     |    1 -
 drivers/acpi/acpica/hwsleep.c   |   11 ++---------
 drivers/acpi/acpica/hwxfsleep.c |    2 +-
 4 files changed, 4 insertions(+), 19 deletions(-)

--- a/drivers/acpi/acpica/evgpe.c
+++ b/drivers/acpi/acpica/evgpe.c
@@ -105,7 +105,7 @@ acpi_ev_update_gpe_enable_mask(struct ac
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Clear a GPE of stale events and enable it.
+ * DESCRIPTION: Enable a GPE.
  *
  ******************************************************************************/
 
@@ -115,13 +115,6 @@ acpi_status acpi_ev_enable_gpe(struct ac
 
 	ACPI_FUNCTION_TRACE(ev_enable_gpe);
 
-	/* Clear the GPE (of stale events) */
-
-	status = acpi_hw_clear_gpe(gpe_event_info);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
 	/* Enable the requested GPE */
 
 	status = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_ENABLE);
--- a/drivers/acpi/acpica/hwgpe.c
+++ b/drivers/acpi/acpica/hwgpe.c
@@ -497,7 +497,6 @@ acpi_status acpi_hw_disable_all_gpes(voi
 	ACPI_FUNCTION_TRACE(hw_disable_all_gpes);
 
 	status = acpi_ev_walk_gpe_list(acpi_hw_disable_gpe_block, NULL);
-	status = acpi_ev_walk_gpe_list(acpi_hw_clear_gpe_block, NULL);
 	return_ACPI_STATUS(status);
 }
 
--- a/drivers/acpi/acpica/hwsleep.c
+++ b/drivers/acpi/acpica/hwsleep.c
@@ -85,15 +85,8 @@ acpi_status acpi_hw_legacy_sleep(u8 slee
 		return_ACPI_STATUS(status);
 	}
 
-	/* Clear all fixed and general purpose status bits */
-
-	status = acpi_hw_clear_acpi_status();
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
 	/*
-	 * 1) Disable/Clear all GPEs
+	 * 1) Disable all GPEs
 	 * 2) Enable all wakeup GPEs
 	 */
 	status = acpi_hw_disable_all_gpes();
@@ -299,7 +292,7 @@ acpi_status acpi_hw_legacy_wake(u8 sleep
 	 * might get fired there
 	 *
 	 * Restore the GPEs:
-	 * 1) Disable/Clear all GPEs
+	 * 1) Disable all GPEs
 	 * 2) Enable all runtime GPEs
 	 */
 	status = acpi_hw_disable_all_gpes();
--- a/drivers/acpi/acpica/hwxfsleep.c
+++ b/drivers/acpi/acpica/hwxfsleep.c
@@ -209,7 +209,7 @@ acpi_status acpi_enter_sleep_state_s4bio
 	}
 
 	/*
-	 * 1) Disable/Clear all GPEs
+	 * 1) Disable all GPEs
 	 * 2) Enable all wakeup GPEs
 	 */
 	status = acpi_hw_disable_all_gpes();
