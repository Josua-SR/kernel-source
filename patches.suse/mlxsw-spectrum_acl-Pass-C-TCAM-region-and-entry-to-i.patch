From: Ido Schimmel <idosch@mellanox.com>
Date: Wed, 25 Jul 2018 09:24:04 +0300
Subject: mlxsw: spectrum_acl: Pass C-TCAM region and entry to insert function
Patch-mainline: v4.19-rc1
Git-commit: a20ff8eb3f15c8adcae60fc467697b442f6267eb
References: bsc#1112374

When A-TCAM will be used together with C-TCAM, the C-TCAM code will need
to call into the eRP core in order to get an eRP for an inserted entry.

The eRP core takes an A-TCAM region as one of its arguments, so pass the
C-TCAM region to the insertion function which will later allow us to
derive the A-TCAM region, given it contains the C-TCAM one.

Signed-off-by: Ido Schimmel <idosch@mellanox.com>
Reviewed-by: Jiri Pirko <jiri@mellanox.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_ctcam.c |   21 +++++++--------
 1 file changed, 11 insertions(+), 10 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_ctcam.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_ctcam.c
@@ -69,11 +69,12 @@ mlxsw_sp_acl_ctcam_region_move(struct ml
 
 static int
 mlxsw_sp_acl_ctcam_region_entry_insert(struct mlxsw_sp *mlxsw_sp,
-				       struct mlxsw_sp_acl_tcam_region *region,
-				       unsigned int offset,
+				       struct mlxsw_sp_acl_ctcam_region *cregion,
+				       struct mlxsw_sp_acl_ctcam_entry *centry,
 				       struct mlxsw_sp_acl_rule_info *rulei,
 				       bool fillup_priority)
 {
+	struct mlxsw_sp_acl_tcam_region *region = cregion->region;
 	struct mlxsw_afk *afk = mlxsw_sp_acl_afk(mlxsw_sp->acl);
 	char ptce2_pl[MLXSW_REG_PTCE2_LEN];
 	unsigned int blocks_count;
@@ -89,7 +90,8 @@ mlxsw_sp_acl_ctcam_region_entry_insert(s
 		return err;
 
 	mlxsw_reg_ptce2_pack(ptce2_pl, true, MLXSW_REG_PTCE2_OP_WRITE_WRITE,
-			     region->tcam_region_info, offset, priority);
+			     region->tcam_region_info,
+			     centry->parman_item.index, priority);
 	key = mlxsw_reg_ptce2_flex_key_blocks_data(ptce2_pl);
 	mask = mlxsw_reg_ptce2_mask_data(ptce2_pl);
 	blocks_count = mlxsw_afk_key_info_blocks_count_get(region->key_info);
@@ -105,13 +107,14 @@ mlxsw_sp_acl_ctcam_region_entry_insert(s
 
 static void
 mlxsw_sp_acl_ctcam_region_entry_remove(struct mlxsw_sp *mlxsw_sp,
-				       struct mlxsw_sp_acl_tcam_region *region,
-				       unsigned int offset)
+				       struct mlxsw_sp_acl_ctcam_region *cregion,
+				       struct mlxsw_sp_acl_ctcam_entry *centry)
 {
 	char ptce2_pl[MLXSW_REG_PTCE2_LEN];
 
 	mlxsw_reg_ptce2_pack(ptce2_pl, false, MLXSW_REG_PTCE2_OP_WRITE_WRITE,
-			     region->tcam_region_info, offset, 0);
+			     cregion->region->tcam_region_info,
+			     centry->parman_item.index, 0);
 	mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ptce2), ptce2_pl);
 }
 
@@ -193,8 +196,7 @@ int mlxsw_sp_acl_ctcam_entry_add(struct
 	if (err)
 		return err;
 
-	err = mlxsw_sp_acl_ctcam_region_entry_insert(mlxsw_sp, cregion->region,
-						     centry->parman_item.index,
+	err = mlxsw_sp_acl_ctcam_region_entry_insert(mlxsw_sp, cregion, centry,
 						     rulei, fillup_priority);
 	if (err)
 		goto err_rule_insert;
@@ -211,8 +213,7 @@ void mlxsw_sp_acl_ctcam_entry_del(struct
 				  struct mlxsw_sp_acl_ctcam_chunk *cchunk,
 				  struct mlxsw_sp_acl_ctcam_entry *centry)
 {
-	mlxsw_sp_acl_ctcam_region_entry_remove(mlxsw_sp, cregion->region,
-					       centry->parman_item.index);
+	mlxsw_sp_acl_ctcam_region_entry_remove(mlxsw_sp, cregion, centry);
 	parman_item_remove(cregion->parman, &cchunk->parman_prio,
 			   &centry->parman_item);
 }
