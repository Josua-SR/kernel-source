From: Hans Wippel <ndev@hwipl.net>
Date: Tue, 25 Feb 2020 22:41:22 +0100
Subject: net/smc: improve peer ID in CLC decline for SMC-R
Git-commit: a082ec897ffed754aae39a9665af161f1a6fa44b
Patch-mainline: v5.7-rc1
References: jsc#SLE-13763

According to RFC 7609, all CLC messages contain a peer ID that consists
of a unique instance ID and the MAC address of one of the host's RoCE
devices. But if a SMC-R connection cannot be established, e.g., because
no matching pnet table entry is found, the current implementation uses a
zero value in the CLC decline message although the host's peer ID is set
to a proper value.

If no RoCE and no ISM device is usable for a connection, there is no LGR
and the LGR check in smc_clc_send_decline() prevents that the peer ID is
copied into the CLC decline message for both SMC-D and SMC-R. So, this
patch modifies the check to also accept the case of no LGR. Also, only a
valid peer ID is copied into the decline message.

Signed-off-by: Hans Wippel <ndev@hwipl.net>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 net/smc/smc_clc.c |    3 ++-
 net/smc/smc_ib.c  |    2 +-
 net/smc/smc_ib.h  |    1 +
 3 files changed, 4 insertions(+), 2 deletions(-)

--- a/net/smc/smc_clc.c
+++ b/net/smc/smc_clc.c
@@ -372,7 +372,8 @@ int smc_clc_send_decline(struct smc_sock
 	dclc.hdr.length = htons(sizeof(struct smc_clc_msg_decline));
 	dclc.hdr.version = SMC_CLC_V1;
 	dclc.hdr.flag = (peer_diag_info == SMC_CLC_DECL_SYNCERR) ? 1 : 0;
-	if (smc->conn.lgr && !smc->conn.lgr->is_smcd)
+	if ((!smc->conn.lgr || !smc->conn.lgr->is_smcd) &&
+	    smc_ib_is_valid_local_systemid())
 		memcpy(dclc.id_for_peer, local_systemid,
 		       sizeof(local_systemid));
 	dclc.peer_diagnosis = htonl(peer_diag_info);
--- a/net/smc/smc_ib.c
+++ b/net/smc/smc_ib.c
@@ -166,7 +166,7 @@ static inline void smc_ib_define_local_s
 	       sizeof(smcibdev->mac[ibport - 1]));
 }
 
-static bool smc_ib_is_valid_local_systemid(void)
+bool smc_ib_is_valid_local_systemid(void)
 {
 	return !is_zero_ether_addr(&local_systemid[2]);
 }
--- a/net/smc/smc_ib.h
+++ b/net/smc/smc_ib.h
@@ -84,4 +84,5 @@ void smc_ib_sync_sg_for_device(struct sm
 			       enum dma_data_direction data_direction);
 int smc_ib_determine_gid(struct smc_ib_device *smcibdev, u8 ibport,
 			 unsigned short vlan_id, u8 gid[], u8 *sgid_index);
+bool smc_ib_is_valid_local_systemid(void);
 #endif
