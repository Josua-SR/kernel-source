From: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date: Thu, 19 Oct 2017 13:41:30 -0400
Subject: drm/amd/display: Apply VQ adjustments in MPO case
Git-commit: de4a2967737114d426411a79781d9d81d0ff38d2
Patch-mainline: v4.16-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/amd/display/dc/core/dc.c                  |    4 
 drivers/gpu/drm/amd/display/dc/dc.h                       |    7 +
 drivers/gpu/drm/amd/display/dc/dc_types.h                 |    5 
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c          |   31 ++++-
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h          |   47 ++++++--
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c       |   44 ++++++--
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c |   75 +++++++++++++-
 drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h               |   10 +
 drivers/gpu/drm/amd/display/dc/inc/hw/hw_shared.h         |   14 ++
 drivers/gpu/drm/amd/display/dc/inc/hw/ipp.h               |    6 -
 drivers/gpu/drm/amd/display/dc/inc/hw/transform.h         |    6 -
 11 files changed, 211 insertions(+), 38 deletions(-)

--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1137,6 +1137,7 @@ static enum surface_update_type get_plan
 	temp_plane_info.plane_size = u->surface->plane_size;
 	temp_plane_info.rotation = u->surface->rotation;
 	temp_plane_info.stereo_format = u->surface->stereo_format;
+	temp_plane_info.input_csc_enabled = u->surface->input_csc_color_matrix.enable_adjustment;
 
 	if (surface_index == 0)
 		temp_plane_info.visible = u->plane_info->visible;
@@ -1217,7 +1218,8 @@ static enum surface_update_type det_surf
 		overall_type = type;
 
 	if (u->in_transfer_func ||
-		u->hdr_static_metadata) {
+		u->hdr_static_metadata ||
+		u->input_csc_color_matrix) {
 		if (overall_type < UPDATE_TYPE_MED)
 			overall_type = UPDATE_TYPE_MED;
 	}
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
@@ -431,6 +431,9 @@ struct dc_plane_state {
 
 	struct dc_gamma *gamma_correction;
 	struct dc_transfer_func *in_transfer_func;
+	struct dc_bias_and_scale *bias_and_scale;
+	struct csc_transform input_csc_color_matrix;
+	struct fixed31_32 coeff_reduction_factor;
 
 	// sourceContentAttribute cache
 	bool is_source_input_valid;
@@ -468,6 +471,7 @@ struct dc_plane_info {
 	bool horizontal_mirror;
 	bool visible;
 	bool per_pixel_alpha;
+	bool input_csc_enabled;
 };
 
 struct dc_scaling_info {
@@ -491,6 +495,9 @@ struct dc_surface_update {
 	struct dc_gamma *gamma;
 	struct dc_transfer_func *in_transfer_func;
 	struct dc_hdr_static_metadata *hdr_static_metadata;
+
+	struct csc_transform *input_csc_color_matrix;
+	struct fixed31_32 *coeff_reduction_factor;
 };
 
 /*
--- a/drivers/gpu/drm/amd/display/dc/dc_types.h
+++ b/drivers/gpu/drm/amd/display/dc/dc_types.h
@@ -638,11 +638,6 @@ struct colorspace_transform {
 	bool enable_remap;
 };
 
-struct csc_transform {
-	uint16_t matrix[12];
-	bool enable_adjustment;
-};
-
 enum i2c_mot_mode {
 	I2C_MOT_UNDEF,
 	I2C_MOT_TRUE,
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -263,8 +263,10 @@ static void dpp1_set_degamma_format_floa
 
 void dpp1_cnv_setup (
 		struct dpp *dpp_base,
-		enum surface_pixel_format input_format,
-		enum expansion_mode mode)
+		enum surface_pixel_format format,
+		enum expansion_mode mode,
+		struct csc_transform input_csc_color_matrix,
+		enum dc_color_space input_color_space)
 {
 	uint32_t pixel_format;
 	uint32_t alpha_en;
@@ -274,8 +276,10 @@ void dpp1_cnv_setup (
 	bool is_float;
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	bool force_disable_cursor = false;
+	struct out_csc_color_matrix tbl_entry;
+	int i = 0;
 
-	dpp1_setup_format_flags(input_format, &fmt);
+	dpp1_setup_format_flags(format, &fmt);
 	alpha_en = 1;
 	pixel_format = 0;
 	color_space = COLOR_SPACE_SRGB;
@@ -305,7 +309,7 @@ void dpp1_cnv_setup (
 
 	dpp1_set_degamma_format_float(dpp_base, is_float);
 
-	switch (input_format) {
+	switch (format) {
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
 		pixel_format = 1;
 		break;
@@ -361,7 +365,23 @@ void dpp1_cnv_setup (
 			CNVC_SURFACE_PIXEL_FORMAT, pixel_format);
 	REG_UPDATE(FORMAT_CONTROL, FORMAT_CONTROL__ALPHA_EN, alpha_en);
 
-	dpp1_program_input_csc(dpp_base, color_space, select);
+	// if input adjustments exist, program icsc with those values
+
+	if (input_csc_color_matrix.enable_adjustment
+				== true) {
+		for (i = 0; i < 12; i++)
+			tbl_entry.regval[i] = input_csc_color_matrix.matrix[i];
+
+		tbl_entry.color_space = input_color_space;
+
+		if (color_space >= COLOR_SPACE_YCBCR601)
+			select = INPUT_CSC_SELECT_ICSC;
+		else
+			select = INPUT_CSC_SELECT_BYPASS;
+
+		dpp1_program_input_csc(dpp_base, color_space, select, &tbl_entry);
+	} else
+		dpp1_program_input_csc(dpp_base, color_space, select, NULL);
 
 	if (force_disable_cursor) {
 		REG_UPDATE(CURSOR_CONTROL,
@@ -434,6 +454,7 @@ static const struct dpp_funcs dcn10_dpp_
 		.opp_program_regamma_luta_settings = dpp1_cm_program_regamma_luta_settings,
 		.opp_program_regamma_pwl = dpp1_cm_set_regamma_pwl,
 		.opp_set_regamma_mode = dpp1_cm_set_regamma_mode,
+		.ipp_program_bias_and_scale = dpp1_program_bias_and_scale,
 		.ipp_set_degamma = dpp1_set_degamma,
 		.ipp_program_input_lut		= dpp1_program_input_lut,
 		.ipp_program_degamma_pwl	= dpp1_set_degamma_pwl,
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h
@@ -73,9 +73,6 @@
 	SRI(RECOUT_START, DSCL, id), \
 	SRI(RECOUT_SIZE, DSCL, id), \
 	SRI(OBUF_CONTROL, DSCL, id), \
-	SRI(CM_ICSC_CONTROL, CM, id), \
-	SRI(CM_ICSC_C11_C12, CM, id), \
-	SRI(CM_ICSC_C33_C34, CM, id), \
 	SRI(CM_DGAM_RAMB_START_CNTL_B, CM, id), \
 	SRI(CM_DGAM_RAMB_START_CNTL_G, CM, id), \
 	SRI(CM_DGAM_RAMB_START_CNTL_R, CM, id), \
@@ -127,6 +124,12 @@
 	SRI(CM_OCSC_CONTROL, CM, id), \
 	SRI(CM_OCSC_C11_C12, CM, id), \
 	SRI(CM_OCSC_C33_C34, CM, id), \
+	SRI(CM_ICSC_CONTROL, CM, id), \
+	SRI(CM_ICSC_C11_C12, CM, id), \
+	SRI(CM_ICSC_C33_C34, CM, id), \
+	SRI(CM_BNS_VALUES_R, CM, id), \
+	SRI(CM_BNS_VALUES_G, CM, id), \
+	SRI(CM_BNS_VALUES_B, CM, id), \
 	SRI(CM_MEM_PWR_CTRL, CM, id), \
 	SRI(CM_RGAM_LUT_DATA, CM, id), \
 	SRI(CM_RGAM_LUT_WRITE_EN_MASK, CM, id),\
@@ -236,11 +239,6 @@
 	TF_SF(DSCL0_SCL_MODE, SCL_CHROMA_COEF_MODE, mask_sh),\
 	TF_SF(DSCL0_SCL_MODE, SCL_COEF_RAM_SELECT_CURRENT, mask_sh), \
 	TF_SF(DSCL0_OBUF_CONTROL, OBUF_BYPASS, mask_sh), \
-	TF_SF(CM0_CM_ICSC_CONTROL, CM_ICSC_MODE, mask_sh), \
-	TF_SF(CM0_CM_ICSC_C11_C12, CM_ICSC_C11, mask_sh), \
-	TF_SF(CM0_CM_ICSC_C11_C12, CM_ICSC_C12, mask_sh), \
-	TF_SF(CM0_CM_ICSC_C33_C34, CM_ICSC_C33, mask_sh), \
-	TF_SF(CM0_CM_ICSC_C33_C34, CM_ICSC_C34, mask_sh), \
 	TF_SF(CM0_CM_DGAM_RAMB_START_CNTL_B, CM_DGAM_RAMB_EXP_REGION_START_B, mask_sh), \
 	TF_SF(CM0_CM_DGAM_RAMB_START_CNTL_B, CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B, mask_sh), \
 	TF_SF(CM0_CM_DGAM_RAMB_START_CNTL_G, CM_DGAM_RAMB_EXP_REGION_START_G, mask_sh), \
@@ -329,6 +327,17 @@
 	TF_SF(CM0_CM_OCSC_C11_C12, CM_OCSC_C12, mask_sh), \
 	TF_SF(CM0_CM_OCSC_C33_C34, CM_OCSC_C33, mask_sh), \
 	TF_SF(CM0_CM_OCSC_C33_C34, CM_OCSC_C34, mask_sh), \
+	TF_SF(CM0_CM_ICSC_CONTROL, CM_ICSC_MODE, mask_sh), \
+	TF_SF(CM0_CM_ICSC_C11_C12, CM_ICSC_C11, mask_sh), \
+	TF_SF(CM0_CM_ICSC_C11_C12, CM_ICSC_C12, mask_sh), \
+	TF_SF(CM0_CM_ICSC_C33_C34, CM_ICSC_C33, mask_sh), \
+	TF_SF(CM0_CM_ICSC_C33_C34, CM_ICSC_C34, mask_sh), \
+	TF_SF(CM0_CM_BNS_VALUES_R, CM_BNS_BIAS_R, mask_sh), \
+	TF_SF(CM0_CM_BNS_VALUES_G, CM_BNS_BIAS_G, mask_sh), \
+	TF_SF(CM0_CM_BNS_VALUES_B, CM_BNS_BIAS_B, mask_sh), \
+	TF_SF(CM0_CM_BNS_VALUES_R, CM_BNS_SCALE_R, mask_sh), \
+	TF_SF(CM0_CM_BNS_VALUES_G, CM_BNS_SCALE_G, mask_sh), \
+	TF_SF(CM0_CM_BNS_VALUES_B, CM_BNS_SCALE_B, mask_sh), \
 	TF_SF(CM0_CM_MEM_PWR_CTRL, RGAM_MEM_PWR_FORCE, mask_sh), \
 	TF_SF(CM0_CM_RGAM_LUT_DATA, CM_RGAM_LUT_DATA, mask_sh), \
 	TF_SF(CM0_CM_RGAM_LUT_WRITE_EN_MASK, CM_RGAM_LUT_WRITE_EN_MASK, mask_sh), \
@@ -913,6 +922,12 @@
 	type CM_ICSC_C12; \
 	type CM_ICSC_C33; \
 	type CM_ICSC_C34; \
+	type CM_BNS_BIAS_R; \
+	type CM_BNS_BIAS_G; \
+	type CM_BNS_BIAS_B; \
+	type CM_BNS_SCALE_R; \
+	type CM_BNS_SCALE_G; \
+	type CM_BNS_SCALE_B; \
 	type CM_DGAM_RAMB_EXP_REGION_START_B; \
 	type CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B; \
 	type CM_DGAM_RAMB_EXP_REGION_START_G; \
@@ -1206,6 +1221,9 @@ struct dcn_dpp_registers {
 	uint32_t CM_ICSC_CONTROL;
 	uint32_t CM_ICSC_C11_C12;
 	uint32_t CM_ICSC_C33_C34;
+	uint32_t CM_BNS_VALUES_R;
+	uint32_t CM_BNS_VALUES_G;
+	uint32_t CM_BNS_VALUES_B;
 	uint32_t CM_DGAM_RAMB_START_CNTL_B;
 	uint32_t CM_DGAM_RAMB_START_CNTL_G;
 	uint32_t CM_DGAM_RAMB_START_CNTL_R;
@@ -1310,7 +1328,12 @@ void dpp1_power_on_degamma_lut(
 void dpp1_program_input_csc(
 		struct dpp *dpp_base,
 		enum dc_color_space color_space,
-		enum dcn10_input_csc_select select);
+		enum dcn10_input_csc_select select,
+		const struct out_csc_color_matrix *tbl_entry);
+
+void dpp1_program_bias_and_scale(
+		struct dpp *dpp_base,
+		struct dc_bias_and_scale *params);
 
 void dpp1_program_input_lut(
 		struct dpp *dpp_base,
@@ -1372,8 +1395,10 @@ void dpp1_dscl_set_scaler_manual_scale(
 
 void dpp1_cnv_setup (
 		struct dpp *dpp_base,
-		enum surface_pixel_format input_format,
-		enum expansion_mode mode);
+		enum surface_pixel_format format,
+		enum expansion_mode mode,
+		struct csc_transform input_csc_color_matrix,
+		enum dc_color_space input_color_space);
 
 void dpp1_full_bypass(struct dpp *dpp_base);
 
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -471,7 +471,8 @@ void dpp1_cm_program_regamma_lutb_settin
 void dpp1_program_input_csc(
 		struct dpp *dpp_base,
 		enum dc_color_space color_space,
-		enum dcn10_input_csc_select select)
+		enum dcn10_input_csc_select select,
+		const struct out_csc_color_matrix *tbl_entry)
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	int i;
@@ -485,15 +486,19 @@ void dpp1_program_input_csc(
 		return;
 	}
 
-	for (i = 0; i < arr_size; i++)
-		if (dcn10_input_csc_matrix[i].color_space == color_space) {
-			regval = dcn10_input_csc_matrix[i].regval;
-			break;
+	if (tbl_entry == NULL) {
+		for (i = 0; i < arr_size; i++)
+			if (dcn10_input_csc_matrix[i].color_space == color_space) {
+				regval = dcn10_input_csc_matrix[i].regval;
+				break;
+			}
+
+		if (regval == NULL) {
+			BREAK_TO_DEBUGGER();
+			return;
 		}
-
-	if (regval == NULL) {
-		BREAK_TO_DEBUGGER();
-		return;
+	} else {
+		regval = tbl_entry->regval;
 	}
 
 	if (select == INPUT_CSC_SELECT_COMA)
@@ -528,6 +533,27 @@ void dpp1_program_input_csc(
 	}
 }
 
+//keep here for now, decide multi dce support later
+void dpp1_program_bias_and_scale(
+	struct dpp *dpp_base,
+	struct dc_bias_and_scale *params)
+{
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
+
+	REG_SET_2(CM_BNS_VALUES_R, 0,
+		CM_BNS_SCALE_R, params->scale_red,
+		CM_BNS_BIAS_R, params->bias_red);
+
+	REG_SET_2(CM_BNS_VALUES_G, 0,
+		CM_BNS_SCALE_G, params->scale_green,
+		CM_BNS_BIAS_G, params->bias_green);
+
+	REG_SET_2(CM_BNS_VALUES_B, 0,
+		CM_BNS_SCALE_B, params->scale_blue,
+		CM_BNS_BIAS_B, params->bias_blue);
+
+}
+
 /*program de gamma RAM B*/
 void dpp1_program_degamma_lutb_settings(
 		struct dpp *dpp_base,
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1572,6 +1572,7 @@ static void program_csc_matrix(struct pi
 		pipe_ctx->plane_res.dpp->funcs->opp_set_csc_default(pipe_ctx->plane_res.dpp, colorspace);
 	}
 }
+
 static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
 	if (pipe_ctx->plane_state->visible)
@@ -1659,6 +1660,69 @@ static void dcn10_get_surface_visual_con
 	}
 }
 
+static uint16_t fixed_point_to_int_frac(
+	struct fixed31_32 arg,
+	uint8_t integer_bits,
+	uint8_t fractional_bits)
+{
+	int32_t numerator;
+	int32_t divisor = 1 << fractional_bits;
+
+	uint16_t result;
+
+	uint16_t d = (uint16_t)dal_fixed31_32_floor(
+		dal_fixed31_32_abs(
+			arg));
+
+	if (d <= (uint16_t)(1 << integer_bits) - (1 / (uint16_t)divisor))
+		numerator = (uint16_t)dal_fixed31_32_floor(
+			dal_fixed31_32_mul_int(
+				arg,
+				divisor));
+	else {
+		numerator = dal_fixed31_32_floor(
+			dal_fixed31_32_sub(
+				dal_fixed31_32_from_int(
+					1LL << integer_bits),
+				dal_fixed31_32_recip(
+					dal_fixed31_32_from_int(
+						divisor))));
+	}
+
+	if (numerator >= 0)
+		result = (uint16_t)numerator;
+	else
+		result = (uint16_t)(
+		(1 << (integer_bits + fractional_bits + 1)) + numerator);
+
+	if ((result != 0) && dal_fixed31_32_lt(
+		arg, dal_fixed31_32_zero))
+		result |= 1 << (integer_bits + fractional_bits);
+
+	return result;
+}
+
+void build_prescale_params(struct  dc_bias_and_scale *bias_and_scale,
+		const struct dc_plane_state *plane_state)
+{
+	if (plane_state->format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN
+			&& plane_state->format != SURFACE_PIXEL_FORMAT_INVALID
+			&& plane_state->input_csc_color_matrix.enable_adjustment
+			&& plane_state->coeff_reduction_factor.value != 0) {
+		bias_and_scale->scale_blue = fixed_point_to_int_frac(
+			dal_fixed31_32_mul(plane_state->coeff_reduction_factor,
+					dal_fixed31_32_from_fraction(256, 255)),
+				2,
+				13);
+		bias_and_scale->scale_red = bias_and_scale->scale_blue;
+		bias_and_scale->scale_green = bias_and_scale->scale_blue;
+	} else {
+		bias_and_scale->scale_blue = 0x2000;
+		bias_and_scale->scale_red = 0x2000;
+		bias_and_scale->scale_green = 0x2000;
+	}
+}
+
 static void mmhub_read_vm_system_aperture_settings(struct dcn10_hubp *hubp1,
 		struct vm_system_aperture_param *apt,
 		struct dce_hwseq *hws)
@@ -1759,6 +1823,7 @@ static void update_dchubp_dpp(
 	struct mpcc_cfg mpcc_cfg = {0};
 	struct pipe_ctx *top_pipe;
 	bool per_pixel_alpha = plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;
+	struct dc_bias_and_scale bns_params = {0};
 
 	/* TODO: proper fix once fpga works */
 	/* depends on DML calculation, DPP clock value may change dynamically */
@@ -1795,9 +1860,16 @@ static void update_dchubp_dpp(
 				hws
 				);
 
+	// program the input csc
 	dpp->funcs->ipp_setup(dpp,
 			plane_state->format,
-			EXPANSION_MODE_ZERO);
+			EXPANSION_MODE_ZERO,
+			plane_state->input_csc_color_matrix,
+			COLOR_SPACE_YCBCR601_LIMITED);
+
+	//set scale and bias registers
+	build_prescale_params(&bns_params, plane_state);
+	dpp->funcs->ipp_program_bias_and_scale(dpp, &bns_params);
 
 	mpcc_cfg.dpp_id = hubp->inst;
 	mpcc_cfg.opp_id = pipe_ctx->stream_res.opp->inst;
@@ -1837,6 +1909,7 @@ static void update_dchubp_dpp(
 			pipe_ctx->stream->output_color_space,
 			pipe_ctx->stream->csc_color_matrix.matrix);
 
+
 	hubp->funcs->hubp_program_surface_config(
 		hubp,
 		plane_state->format,
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h
@@ -98,6 +98,10 @@ struct dpp_funcs {
 			struct dpp *dpp_base,
 			enum opp_regamma mode);
 
+	void (*ipp_program_bias_and_scale)(
+			struct dpp *dpp,
+			struct dc_bias_and_scale *params);
+
 	void (*ipp_set_degamma)(
 			struct dpp *dpp_base,
 			enum ipp_degamma_mode mode);
@@ -111,8 +115,10 @@ struct dpp_funcs {
 
 	void (*ipp_setup)(
 			struct dpp *dpp_base,
-			enum surface_pixel_format input_format,
-			enum expansion_mode mode);
+			enum surface_pixel_format format,
+			enum expansion_mode mode,
+			struct csc_transform input_csc_color_matrix,
+			enum dc_color_space input_color_space);
 
 	void (*ipp_full_bypass)(struct dpp *dpp_base);
 
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/hw_shared.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/hw_shared.h
@@ -138,4 +138,18 @@ enum opp_regamma {
 	OPP_REGAMMA_USER
 };
 
+struct csc_transform {
+	uint16_t matrix[12];
+	bool enable_adjustment;
+};
+
+struct dc_bias_and_scale {
+	uint16_t scale_red;
+	uint16_t bias_red;
+	uint16_t scale_green;
+	uint16_t bias_green;
+	uint16_t scale_blue;
+	uint16_t bias_blue;
+};
+
 #endif /* __DAL_HW_SHARED_H__ */
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/ipp.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/ipp.h
@@ -85,8 +85,10 @@ struct ipp_funcs {
 	/* setup ipp to expand/convert input to pixel processor internal format */
 	void (*ipp_setup)(
 		struct input_pixel_processor *ipp,
-		enum surface_pixel_format input_format,
-		enum expansion_mode mode);
+		enum surface_pixel_format format,
+		enum expansion_mode mode,
+		struct csc_transform input_csc_color_matrix,
+		enum dc_color_space input_color_space);
 
 	/* DCE function to setup IPP.  TODO: see if we can consolidate to setup */
 	void (*ipp_program_prescale)(
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/transform.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/transform.h
@@ -250,8 +250,10 @@ struct transform_funcs {
 
 	void (*ipp_setup)(
 			struct transform *xfm_base,
-			enum surface_pixel_format input_format,
-			enum expansion_mode mode);
+			enum surface_pixel_format format,
+			enum expansion_mode mode,
+			struct csc_transform input_csc_color_matrix,
+			enum dc_color_space input_color_space);
 
 	void (*ipp_full_bypass)(struct transform *xfm_base);
 
