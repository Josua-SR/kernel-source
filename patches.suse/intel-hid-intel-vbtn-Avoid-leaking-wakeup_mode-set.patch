From: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
Date: Thu, 8 Aug 2019 11:39:17 +0200
Subject: intel-hid: intel-vbtn: Avoid leaking wakeup_mode set
Patch-mainline: v5.4-rc1
Git-commit: 31eb845718398f9bc9f6fbe1aca675f4e6284392
References: jsc#SLE-16407

Both intel-hid and intel-vbtn set a wakeup_mode flag causing them
to behave in a special way during system suspend and while suspended
in their "prepare" PM callbacks and clear it in their "resume" PM
callbacks.  That may cause the wakeup_mode flag to remain set after
a system suspend failure (if some other driver's "suspend" callback
returns an error before the "suspend" callback of either intel-hid
or intel-vbtn is invoked).

After commit 10a08fd65ec1 ("ACPI: PM: Set up EC GPE for system wakeup
from drivers that need it") that also affects the "wakeup mask" bit
of the EC GPE, which may not be cleared after a failing system
suspend.

Fix this issue by adding "complete" PM callbacks to intel-hid and
intel-vbtn to clear the wakeup_mode flag and the "wakeup mask" bit
of the EC GPE if they have not been cleared earlier.

Fixes: 10a08fd65ec1 ("ACPI: PM: Set up EC GPE for system wakeup from drivers that need it")
Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Acked-by: Lee, Chun-Yi <jlee@suse.com>
---
 drivers/platform/x86/intel-hid.c  |   17 ++++++++++++-----
 drivers/platform/x86/intel-vbtn.c |   12 +++++++++---
 2 files changed, 21 insertions(+), 8 deletions(-)

--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -262,6 +262,16 @@ static int intel_hid_pm_prepare(struct d
 	return 0;
 }
 
+static void intel_hid_pm_complete(struct device *device)
+{
+	struct intel_hid_priv *priv = dev_get_drvdata(device);
+
+	if (priv->wakeup_mode) {
+		acpi_ec_set_gpe_wake_mask(ACPI_GPE_DISABLE);
+		priv->wakeup_mode = false;
+	}
+}
+
 static int intel_hid_pl_suspend_handler(struct device *device)
 {
 	if (pm_suspend_via_firmware()) {
@@ -273,12 +283,8 @@ static int intel_hid_pl_suspend_handler(
 
 static int intel_hid_pl_resume_handler(struct device *device)
 {
-	if (device_may_wakeup(device)) {
-		struct intel_hid_priv *priv = dev_get_drvdata(device);
+	intel_hid_pm_complete(device);
 
-		acpi_ec_set_gpe_wake_mask(ACPI_GPE_DISABLE);
-		priv->wakeup_mode = false;
-	}
 	if (pm_resume_via_firmware()) {
 		intel_hid_set_enable(device, true);
 		intel_button_array_enable(device, true);
@@ -288,6 +294,7 @@ static int intel_hid_pl_resume_handler(s
 
 static const struct dev_pm_ops intel_hid_pl_pm_ops = {
 	.prepare = intel_hid_pm_prepare,
+	.complete = intel_hid_pm_complete,
 	.freeze  = intel_hid_pl_suspend_handler,
 	.thaw  = intel_hid_pl_resume_handler,
 	.restore  = intel_hid_pl_resume_handler,
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -210,19 +210,25 @@ static int intel_vbtn_pm_prepare(struct
 	return 0;
 }
 
-static int intel_vbtn_pm_resume(struct device *dev)
+static void intel_vbtn_pm_complete(struct device *dev)
 {
-	if (device_may_wakeup(dev)) {
-		struct intel_vbtn_priv *priv = dev_get_drvdata(dev);
+	struct intel_vbtn_priv *priv = dev_get_drvdata(dev);
 
+	if (priv->wakeup_mode) {
 		acpi_ec_set_gpe_wake_mask(ACPI_GPE_DISABLE);
 		priv->wakeup_mode = false;
 	}
+}
+
+static int intel_vbtn_pm_resume(struct device *dev)
+{
+	intel_vbtn_pm_complete(dev);
 	return 0;
 }
 
 static const struct dev_pm_ops intel_vbtn_pm_ops = {
 	.prepare = intel_vbtn_pm_prepare,
+	.complete = intel_vbtn_pm_complete,
 	.resume = intel_vbtn_pm_resume,
 	.restore = intel_vbtn_pm_resume,
 	.thaw = intel_vbtn_pm_resume,
