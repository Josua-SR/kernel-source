From: Ioana Radulescu <ruxandra.radulescu@nxp.com>
Date: Fri, 8 Dec 2017 06:47:57 -0600
Subject: staging: fsl-dpaa2/eth: Compute needed headroom per frame

Git-commit: 18c21467b2162107891f15ce1da4350b4e7016a3
Patch-mainline: v4.16-rc1
References: fate#326530,fate#326531,fate#326535,fate#326538,fate#326539

For non-linear skbs we build scatter-gather frames and allocate
a new buffer for the S/G table in which we reserve the required
headroom, so the actual skb headroom size doesn't matter.

Rather than use a one-size-fits-all approach, decide when to
enforce headroom requirements on a frame by frame basis.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@nxp.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Mian Yousaf Kaukab <yousaf.kaukab@suse.com>
---
 drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c |  9 ++++++---
 drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.h | 11 ++++++++---
 2 files changed, 14 insertions(+), 6 deletions(-)

diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
index 2c12859d3ff0..8edb7c10f978 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
@@ -437,7 +437,8 @@ static int build_single_fd(struct dpaa2_eth_priv *priv,
 	struct sk_buff **skbh;
 	dma_addr_t addr;
 
-	buffer_start = PTR_ALIGN(skb->data - dpaa2_eth_needed_headroom(priv),
+	buffer_start = PTR_ALIGN(skb->data -
+				 dpaa2_eth_needed_headroom(priv, skb),
 				 DPAA2_ETH_TX_BUF_ALIGN);
 
 	/* Store a backpointer to the skb at the beginning of the buffer
@@ -532,15 +533,17 @@ static netdev_tx_t dpaa2_eth_tx(struct sk_buff *skb, struct net_device *net_dev)
 	struct dpaa2_eth_drv_stats *percpu_extras;
 	struct dpaa2_eth_fq *fq;
 	u16 queue_mapping;
+	unsigned int needed_headroom;
 	int err, i;
 
 	percpu_stats = this_cpu_ptr(priv->percpu_stats);
 	percpu_extras = this_cpu_ptr(priv->percpu_extras);
 
-	if (skb_headroom(skb) < dpaa2_eth_needed_headroom(priv)) {
+	needed_headroom = dpaa2_eth_needed_headroom(priv, skb);
+	if (skb_headroom(skb) < needed_headroom) {
 		struct sk_buff *ns;
 
-		ns = skb_realloc_headroom(skb, dpaa2_eth_needed_headroom(priv));
+		ns = skb_realloc_headroom(skb, needed_headroom);
 		if (unlikely(!ns)) {
 			percpu_stats->tx_dropped++;
 			goto err_alloc_headroom;
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.h b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.h
index 546a8624ac2f..4ea41d85c231 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.h
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.h
@@ -364,9 +364,13 @@ static inline unsigned int dpaa2_eth_buf_raw_size(struct dpaa2_eth_priv *priv)
 }
 
 static inline
-unsigned int dpaa2_eth_needed_headroom(struct dpaa2_eth_priv *priv)
+unsigned int dpaa2_eth_needed_headroom(struct dpaa2_eth_priv *priv,
+				       struct sk_buff *skb)
 {
-	return priv->tx_data_offset + DPAA2_ETH_TX_BUF_ALIGN;
+	if (skb_is_nonlinear(skb))
+		return 0;
+
+	return DPAA2_ETH_SWA_SIZE + DPAA2_ETH_TX_BUF_ALIGN;
 }
 
 /* Extra headroom space requested to hardware, in order to make sure there's
@@ -374,7 +378,8 @@ unsigned int dpaa2_eth_needed_headroom(struct dpaa2_eth_priv *priv)
  */
 static inline unsigned int dpaa2_eth_rx_head_room(struct dpaa2_eth_priv *priv)
 {
-	return dpaa2_eth_needed_headroom(priv) - DPAA2_ETH_RX_HWA_SIZE;
+	return priv->tx_data_offset + DPAA2_ETH_TX_BUF_ALIGN -
+	       DPAA2_ETH_RX_HWA_SIZE;
 }
 
 static int dpaa2_eth_queue_count(struct dpaa2_eth_priv *priv)
-- 
2.11.0

