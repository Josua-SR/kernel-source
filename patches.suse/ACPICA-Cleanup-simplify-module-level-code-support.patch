From: Bob Moore <robert.moore@intel.com>
Date: Wed, 14 Mar 2018 16:13:09 -0700
Subject: ACPICA: Cleanup/simplify module-level code support
Patch-mainline: v4.17-rc1
Git-commit: a406dea82af80a2cb069f7e34e24677fe9dd580e
References: bsc#1117419

This prepares the code for eventual removal of the original
style of deferred execution of the MLC.

Signed-off-by: Bob Moore <robert.moore@intel.com>
Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Acked-by: Lee, Chun-Yi <jlee@suse.com>
---
 drivers/acpi/acpica/evrgnini.c |    3 ++
 drivers/acpi/acpica/nseval.c   |   14 +++++++++++
 drivers/acpi/acpica/nsload.c   |   24 +++++++-------------
 drivers/acpi/acpica/nsparse.c  |   24 ++++++++++++++++++--
 drivers/acpi/acpica/psloop.c   |   24 +++++++++++++++++---
 drivers/acpi/acpica/tbdata.c   |   18 ++++++++++-----
 drivers/acpi/acpica/tbxfload.c |   11 +++++----
 drivers/acpi/acpica/utxfinit.c |   48 +++++++++++++++--------------------------
 include/acpi/actypes.h         |   20 ++++++++---------
 9 files changed, 116 insertions(+), 70 deletions(-)

--- a/drivers/acpi/acpica/evrgnini.c
+++ b/drivers/acpi/acpica/evrgnini.c
@@ -526,6 +526,9 @@ acpi_status acpi_ev_initialize_region(un
 				 * Node's object was replaced by this Method object and we
 				 * saved the handler in the method object.
 				 *
+				 * Note: Only used for the legacy MLC support. Will
+				 * be removed in the future.
+				 *
 				 * See acpi_ns_exec_module_code
 				 */
 				if (!acpi_gbl_execute_tables_as_methods &&
--- a/drivers/acpi/acpica/nseval.c
+++ b/drivers/acpi/acpica/nseval.c
@@ -310,6 +310,17 @@ cleanup:
  * DESCRIPTION: Execute all elements of the global module-level code list.
  *              Each element is executed as a single control method.
  *
+ * NOTE: With this option enabled, each block of detected executable AML
+ * code that is outside of any control method is wrapped with a temporary
+ * control method object and placed on a global list. The methods on this
+ * list are executed below.
+ *
+ * This function executes the module-level code for all tables only after
+ * all of the tables have been loaded. It is a legacy option and is
+ * not compatible with other ACPI implementations. See acpi_ns_load_table.
+ *
+ * This function will be removed when the legacy option is removed.
+ *
  ******************************************************************************/
 
 void acpi_ns_exec_module_code_list(void)
@@ -325,6 +336,9 @@ void acpi_ns_exec_module_code_list(void)
 
 	next = acpi_gbl_module_code_list;
 	if (!next) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INIT_NAMES,
+				  "Legacy MLC block list is empty\n"));
+
 		return_VOID;
 	}
 
--- a/drivers/acpi/acpica/nsload.c
+++ b/drivers/acpi/acpica/nsload.c
@@ -111,23 +111,17 @@ unlock:
 			  "**** Completed Table Object Initialization\n"));
 
 	/*
-	 * Execute any module-level code that was detected during the table load
-	 * phase. Although illegal since ACPI 2.0, there are many machines that
-	 * contain this type of code. Each block of detected executable AML code
-	 * outside of any control method is wrapped with a temporary control
-	 * method object and placed on a global list. The methods on this list
-	 * are executed below.
+	 * This case handles the legacy option that groups all module-level
+	 * code blocks together and defers execution until all of the tables
+	 * are loaded. Execute all of these blocks at this time.
+	 * Execute any module-level code that was detected during the table
+	 * load phase.
 	 *
-	 * This case executes the module-level code for each table immediately
-	 * after the table has been loaded. This provides compatibility with
-	 * other ACPI implementations. Optionally, the execution can be deferred
-	 * until later, see acpi_initialize_objects.
+	 * Note: this option is deprecated and will be eliminated in the
+	 * future. Use of this option can cause problems with AML code that
+	 * depends upon in-order immediate execution of module-level code.
 	 */
-	if (!acpi_gbl_execute_tables_as_methods
-	    && !acpi_gbl_group_module_level_code) {
-		acpi_ns_exec_module_code_list();
-	}
-
+	acpi_ns_exec_module_code_list();
 	return_ACPI_STATUS(status);
 }
 
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -27,8 +27,17 @@ ACPI_MODULE_NAME("nsparse")
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Load ACPI/AML table by executing the entire table as a
- *              term_list.
+ * DESCRIPTION: Load ACPI/AML table by executing the entire table as a single
+ *              large control method.
+ *
+ * NOTE: The point of this is to execute any module-level code in-place
+ * as the table is parsed. Some AML code depends on this behavior.
+ *
+ * It is a run-time option at this time, but will eventually become
+ * the default.
+ *
+ * Note: This causes the table to only have a single-pass parse.
+ * However, this is compatible with other ACPI implementations.
  *
  ******************************************************************************/
 acpi_status
@@ -233,6 +242,17 @@ acpi_ns_parse_table(u32 table_index, str
 	ACPI_FUNCTION_TRACE(ns_parse_table);
 
 	if (acpi_gbl_execute_tables_as_methods) {
+		/*
+		 * This case executes the AML table as one large control method.
+		 * The point of this is to execute any module-level code in-place
+		 * as the table is parsed. Some AML code depends on this behavior.
+		 *
+		 * It is a run-time option at this time, but will eventually become
+		 * the default.
+		 *
+		 * Note: This causes the table to only have a single-pass parse.
+		 * However, this is compatible with other ACPI implementations.
+		 */
 		ACPI_DEBUG_PRINT_RAW((ACPI_DB_PARSE,
 				      "%s: **** Start table execution pass\n",
 				      ACPI_GET_FUNCTION_NAME));
--- a/drivers/acpi/acpica/psloop.c
+++ b/drivers/acpi/acpica/psloop.c
@@ -136,10 +136,18 @@ acpi_ps_get_arguments(struct acpi_walk_s
 				  walk_state->pass_number));
 
 		/*
-		 * Handle executable code at "module-level". This refers to
-		 * executable opcodes that appear outside of any control method.
+		 * This case handles the legacy option that groups all module-level
+		 * code blocks together and defers execution until all of the tables
+		 * are loaded. Execute all of these blocks at this time.
+		 * Execute any module-level code that was detected during the table
+		 * load phase.
+		 *
+		 * Note: this option is deprecated and will be eliminated in the
+		 * future. Use of this option can cause problems with AML code that
+		 * depends upon in-order immediate execution of module-level code.
 		 */
-		if ((walk_state->pass_number <= ACPI_IMODE_LOAD_PASS2) &&
+		if (acpi_gbl_group_module_level_code &&
+		    (walk_state->pass_number <= ACPI_IMODE_LOAD_PASS2) &&
 		    ((walk_state->parse_flags & ACPI_PARSE_DISASSEMBLE) == 0)) {
 			/*
 			 * We want to skip If/Else/While constructs during Pass1 because we
@@ -306,6 +314,16 @@ acpi_ps_get_arguments(struct acpi_walk_s
  *              object to the global list. Note, the mutex field of the method
  *              object is used to link multiple module-level code objects.
  *
+ * NOTE: In this legacy option, each block of detected executable AML
+ * code that is outside of any control method is wrapped with a temporary
+ * control method object and placed on a global list below.
+ *
+ * This function executes the module-level code for all tables only after
+ * all of the tables have been loaded. It is a legacy option and is
+ * not compatible with other ACPI implementations. See acpi_ns_load_table.
+ *
+ * This function will be removed when the legacy option is removed.
+ *
  ******************************************************************************/
 
 static void
--- a/drivers/acpi/acpica/tbdata.c
+++ b/drivers/acpi/acpica/tbdata.c
@@ -932,12 +932,18 @@ acpi_tb_load_table(u32 table_index, stru
 
 	status = acpi_ns_load_table(table_index, parent_node);
 
-	/* Execute any module-level code that was found in the table */
-
-	if (!acpi_gbl_execute_tables_as_methods
-	    && acpi_gbl_group_module_level_code) {
-		acpi_ns_exec_module_code_list();
-	}
+	/*
+	 * This case handles the legacy option that groups all module-level
+	 * code blocks together and defers execution until all of the tables
+	 * are loaded. Execute all of these blocks at this time.
+	 * Execute any module-level code that was detected during the table
+	 * load phase.
+	 *
+	 * Note: this option is deprecated and will be eliminated in the
+	 * future. Use of this option can cause problems with AML code that
+	 * depends upon in-order immediate execution of module-level code.
+	 */
+	acpi_ns_exec_module_code_list();
 
 	/*
 	 * Update GPEs for any new _Lxx/_Exx methods. Ignore errors. The host is
--- a/drivers/acpi/acpica/tbxfload.c
+++ b/drivers/acpi/acpica/tbxfload.c
@@ -72,10 +72,13 @@ acpi_status ACPI_INIT_FUNCTION acpi_load
 	if (acpi_gbl_execute_tables_as_methods
 	    || !acpi_gbl_group_module_level_code) {
 		/*
-		 * Initialize the objects that remain uninitialized. This
-		 * runs the executable AML that may be part of the
-		 * declaration of these objects:
-		 * operation_regions, buffer_fields, Buffers, and Packages.
+		 * If the module-level code support is enabled, initialize the objects
+		 * in the namespace that remain uninitialized. This runs the executable
+		 * AML that may be part of the declaration of these name objects:
+		 *     operation_regions, buffer_fields, Buffers, and Packages.
+		 *
+		 * Note: The module-level code is optional at this time, but will
+		 * become the default in the future.
 		 */
 		status = acpi_ns_initialize_objects();
 		if (ACPI_FAILURE(status)) {
--- a/drivers/acpi/acpica/utxfinit.c
+++ b/drivers/acpi/acpica/utxfinit.c
@@ -211,41 +211,29 @@ acpi_status ACPI_INIT_FUNCTION acpi_init
 
 	ACPI_FUNCTION_TRACE(acpi_initialize_objects);
 
-#ifdef ACPI_EXEC_APP
 	/*
-	 * This call implements the "initialization file" option for acpi_exec.
-	 * This is the precise point that we want to perform the overrides.
+	 * This case handles the legacy option that groups all module-level
+	 * code blocks together and defers execution until all of the tables
+	 * are loaded. Execute all of these blocks at this time.
+	 * Execute any module-level code that was detected during the table
+	 * load phase.
+	 *
+	 * Note: this option is deprecated and will be eliminated in the
+	 * future. Use of this option can cause problems with AML code that
+	 * depends upon in-order immediate execution of module-level code.
 	 */
-	ae_do_object_overrides();
-#endif
+	acpi_ns_exec_module_code_list();
 
 	/*
-	 * Execute any module-level code that was detected during the table load
-	 * phase. Although illegal since ACPI 2.0, there are many machines that
-	 * contain this type of code. Each block of detected executable AML code
-	 * outside of any control method is wrapped with a temporary control
-	 * method object and placed on a global list. The methods on this list
-	 * are executed below.
-	 *
-	 * This case executes the module-level code for all tables only after
-	 * all of the tables have been loaded. It is a legacy option and is
-	 * not compatible with other ACPI implementations. See acpi_ns_load_table.
+	 * Initialize the objects that remain uninitialized. This
+	 * runs the executable AML that may be part of the
+	 * declaration of these objects:
+	 * operation_regions, buffer_fields, Buffers, and Packages.
 	 */
-	if (!acpi_gbl_execute_tables_as_methods
-	    && acpi_gbl_group_module_level_code) {
-		acpi_ns_exec_module_code_list();
-
-		/*
-		 * Initialize the objects that remain uninitialized. This
-		 * runs the executable AML that may be part of the
-		 * declaration of these objects:
-		 * operation_regions, buffer_fields, Buffers, and Packages.
-		 */
-		if (!(flags & ACPI_NO_OBJECT_INIT)) {
-			status = acpi_ns_initialize_objects();
-			if (ACPI_FAILURE(status)) {
-				return_ACPI_STATUS(status);
-			}
+	if (!(flags & ACPI_NO_OBJECT_INIT)) {
+		status = acpi_ns_initialize_objects();
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
 		}
 	}
 
--- a/include/acpi/actypes.h
+++ b/include/acpi/actypes.h
@@ -534,17 +534,17 @@ typedef u64 acpi_integer;
  ******************************************************************************/
 
 /*
- * Initialization sequence
+ * Initialization sequence options
  */
-#define ACPI_FULL_INITIALIZATION        0x00
-#define ACPI_NO_ADDRESS_SPACE_INIT      0x01
-#define ACPI_NO_HARDWARE_INIT           0x02
-#define ACPI_NO_EVENT_INIT              0x04
-#define ACPI_NO_HANDLER_INIT            0x08
-#define ACPI_NO_ACPI_ENABLE             0x10
-#define ACPI_NO_DEVICE_INIT             0x20
-#define ACPI_NO_OBJECT_INIT             0x40
-#define ACPI_NO_FACS_INIT               0x80
+#define ACPI_FULL_INITIALIZATION        0x0000
+#define ACPI_NO_FACS_INIT               0x0001
+#define ACPI_NO_ACPI_ENABLE             0x0002
+#define ACPI_NO_HARDWARE_INIT           0x0004
+#define ACPI_NO_EVENT_INIT              0x0008
+#define ACPI_NO_HANDLER_INIT            0x0010
+#define ACPI_NO_OBJECT_INIT             0x0020
+#define ACPI_NO_DEVICE_INIT             0x0040
+#define ACPI_NO_ADDRESS_SPACE_INIT      0x0080
 
 /*
  * Initialization state
