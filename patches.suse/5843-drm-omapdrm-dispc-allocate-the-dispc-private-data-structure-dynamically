From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Tue, 13 Feb 2018 14:00:44 +0200
Subject: drm: omapdrm: dispc: Allocate the dispc private data structure
 dynamically
Git-commit: 1f6b6b6267ebe6f36f3640bccb93d54e9699c131
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

The dispc private data structure is currently stored as a global
variable. While no platform with multiple DISPC currently exists
nor is planned, this doesn't comply with the kernel device model and
should thus be fixed.

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/omapdrm/dss/dispc.c | 1948 +++++++++++++++++++-----------------
 1 file changed, 1046 insertions(+), 902 deletions(-)

--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -47,6 +47,8 @@
 #include "dss.h"
 #include "dispc.h"
 
+struct dispc_device;
+
 /* DISPC */
 #define DISPC_SZ_REGS			SZ_4K
 
@@ -56,11 +58,12 @@ enum omap_burst_size {
 	BURST_SIZE_X8 = 2,
 };
 
-#define REG_GET(idx, start, end) \
-	FLD_GET(dispc_read_reg(idx), start, end)
+#define REG_GET(dispc, idx, start, end) \
+	FLD_GET(dispc_read_reg(dispc, idx), start, end)
 
-#define REG_FLD_MOD(idx, val, start, end)				\
-	dispc_write_reg(idx, FLD_MOD(dispc_read_reg(idx), val, start, end))
+#define REG_FLD_MOD(dispc, idx, val, start, end)			\
+	dispc_write_reg(dispc, idx, \
+			FLD_MOD(dispc_read_reg(dispc, idx), val, start, end))
 
 /* DISPC has feature id */
 enum dispc_feature_id {
@@ -105,7 +108,8 @@ struct dispc_features {
 	unsigned int max_downscale;
 	unsigned int max_line_width;
 	unsigned int min_pcd;
-	int (*calc_scaling) (unsigned long pclk, unsigned long lclk,
+	int (*calc_scaling)(struct dispc_device *dispc,
+		unsigned long pclk, unsigned long lclk,
 		const struct videomode *vm,
 		u16 width, u16 height, u16 out_width, u16 out_height,
 		u32 fourcc, bool *five_taps,
@@ -196,8 +200,6 @@ struct dispc_device {
 	spinlock_t control_lock;
 };
 
-static struct dispc_device dispc;
-
 enum omap_color_component {
 	/* used for all color formats for OMAP3 and earlier
 	 * and for RGB and Y color component on OMAP4
@@ -355,45 +357,52 @@ struct color_conv_coef {
 	int full_range;
 };
 
-static unsigned long dispc_fclk_rate(void);
-static unsigned long dispc_core_clk_rate(void);
-static unsigned long dispc_mgr_lclk_rate(enum omap_channel channel);
-static unsigned long dispc_mgr_pclk_rate(enum omap_channel channel);
-
-static unsigned long dispc_plane_pclk_rate(enum omap_plane_id plane);
-static unsigned long dispc_plane_lclk_rate(enum omap_plane_id plane);
+static unsigned long dispc_fclk_rate(struct dispc_device *dispc);
+static unsigned long dispc_core_clk_rate(struct dispc_device *dispc);
+static unsigned long dispc_mgr_lclk_rate(struct dispc_device *dispc,
+					 enum omap_channel channel);
+static unsigned long dispc_mgr_pclk_rate(struct dispc_device *dispc,
+					 enum omap_channel channel);
+
+static unsigned long dispc_plane_pclk_rate(struct dispc_device *dispc,
+					   enum omap_plane_id plane);
+static unsigned long dispc_plane_lclk_rate(struct dispc_device *dispc,
+					   enum omap_plane_id plane);
 
 static void dispc_clear_irqstatus(struct dispc_device *dispc, u32 mask);
 
-static inline void dispc_write_reg(const u16 idx, u32 val)
+static inline void dispc_write_reg(struct dispc_device *dispc, u16 idx, u32 val)
 {
-	__raw_writel(val, dispc.base + idx);
+	__raw_writel(val, dispc->base + idx);
 }
 
-static inline u32 dispc_read_reg(const u16 idx)
+static inline u32 dispc_read_reg(struct dispc_device *dispc, u16 idx)
 {
-	return __raw_readl(dispc.base + idx);
+	return __raw_readl(dispc->base + idx);
 }
 
-static u32 mgr_fld_read(enum omap_channel channel, enum mgr_reg_fields regfld)
+static u32 mgr_fld_read(struct dispc_device *dispc, enum omap_channel channel,
+			enum mgr_reg_fields regfld)
 {
 	const struct dispc_reg_field rfld = mgr_desc[channel].reg_desc[regfld];
-	return REG_GET(rfld.reg, rfld.high, rfld.low);
+
+	return REG_GET(dispc, rfld.reg, rfld.high, rfld.low);
 }
 
-static void mgr_fld_write(enum omap_channel channel,
-					enum mgr_reg_fields regfld, int val) {
+static void mgr_fld_write(struct dispc_device *dispc, enum omap_channel channel,
+			  enum mgr_reg_fields regfld, int val)
+{
 	const struct dispc_reg_field rfld = mgr_desc[channel].reg_desc[regfld];
 	const bool need_lock = rfld.reg == DISPC_CONTROL || rfld.reg == DISPC_CONFIG;
 	unsigned long flags;
 
 	if (need_lock)
-		spin_lock_irqsave(&dispc.control_lock, flags);
+		spin_lock_irqsave(&dispc->control_lock, flags);
 
-	REG_FLD_MOD(rfld.reg, val, rfld.high, rfld.low);
+	REG_FLD_MOD(dispc, rfld.reg, val, rfld.high, rfld.low);
 
 	if (need_lock)
-		spin_unlock_irqrestore(&dispc.control_lock, flags);
+		spin_unlock_irqrestore(&dispc->control_lock, flags);
 }
 
 static int dispc_get_num_ovls(struct dispc_device *dispc)
@@ -406,255 +415,257 @@ static int dispc_get_num_mgrs(struct dis
 	return dispc->feat->num_mgrs;
 }
 
-static void dispc_get_reg_field(enum dispc_feat_reg_field id,
+static void dispc_get_reg_field(struct dispc_device *dispc,
+				enum dispc_feat_reg_field id,
 				u8 *start, u8 *end)
 {
-	if (id >= dispc.feat->num_reg_fields)
+	if (id >= dispc->feat->num_reg_fields)
 		BUG();
 
-	*start = dispc.feat->reg_fields[id].start;
-	*end = dispc.feat->reg_fields[id].end;
+	*start = dispc->feat->reg_fields[id].start;
+	*end = dispc->feat->reg_fields[id].end;
 }
 
-static bool dispc_has_feature(enum dispc_feature_id id)
+static bool dispc_has_feature(struct dispc_device *dispc,
+			      enum dispc_feature_id id)
 {
 	unsigned int i;
 
-	for (i = 0; i < dispc.feat->num_features; i++) {
-		if (dispc.feat->features[i] == id)
+	for (i = 0; i < dispc->feat->num_features; i++) {
+		if (dispc->feat->features[i] == id)
 			return true;
 	}
 
 	return false;
 }
 
-#define SR(reg) \
-	dispc.ctx[DISPC_##reg / sizeof(u32)] = dispc_read_reg(DISPC_##reg)
-#define RR(reg) \
-	dispc_write_reg(DISPC_##reg, dispc.ctx[DISPC_##reg / sizeof(u32)])
+#define SR(dispc, reg) \
+	dispc->ctx[DISPC_##reg / sizeof(u32)] = dispc_read_reg(dispc, DISPC_##reg)
+#define RR(dispc, reg) \
+	dispc_write_reg(dispc, DISPC_##reg, dispc->ctx[DISPC_##reg / sizeof(u32)])
 
-static void dispc_save_context(void)
+static void dispc_save_context(struct dispc_device *dispc)
 {
 	int i, j;
 
 	DSSDBG("dispc_save_context\n");
 
-	SR(IRQENABLE);
-	SR(CONTROL);
-	SR(CONFIG);
-	SR(LINE_NUMBER);
-	if (dispc_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||
-			dispc_has_feature(FEAT_ALPHA_FREE_ZORDER))
-		SR(GLOBAL_ALPHA);
-	if (dispc_has_feature(FEAT_MGR_LCD2)) {
-		SR(CONTROL2);
-		SR(CONFIG2);
-	}
-	if (dispc_has_feature(FEAT_MGR_LCD3)) {
-		SR(CONTROL3);
-		SR(CONFIG3);
-	}
-
-	for (i = 0; i < dispc_get_num_mgrs(&dispc); i++) {
-		SR(DEFAULT_COLOR(i));
-		SR(TRANS_COLOR(i));
-		SR(SIZE_MGR(i));
+	SR(dispc, IRQENABLE);
+	SR(dispc, CONTROL);
+	SR(dispc, CONFIG);
+	SR(dispc, LINE_NUMBER);
+	if (dispc_has_feature(dispc, FEAT_ALPHA_FIXED_ZORDER) ||
+			dispc_has_feature(dispc, FEAT_ALPHA_FREE_ZORDER))
+		SR(dispc, GLOBAL_ALPHA);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD2)) {
+		SR(dispc, CONTROL2);
+		SR(dispc, CONFIG2);
+	}
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD3)) {
+		SR(dispc, CONTROL3);
+		SR(dispc, CONFIG3);
+	}
+
+	for (i = 0; i < dispc_get_num_mgrs(dispc); i++) {
+		SR(dispc, DEFAULT_COLOR(i));
+		SR(dispc, TRANS_COLOR(i));
+		SR(dispc, SIZE_MGR(i));
 		if (i == OMAP_DSS_CHANNEL_DIGIT)
 			continue;
-		SR(TIMING_H(i));
-		SR(TIMING_V(i));
-		SR(POL_FREQ(i));
-		SR(DIVISORo(i));
-
-		SR(DATA_CYCLE1(i));
-		SR(DATA_CYCLE2(i));
-		SR(DATA_CYCLE3(i));
-
-		if (dispc_has_feature(FEAT_CPR)) {
-			SR(CPR_COEF_R(i));
-			SR(CPR_COEF_G(i));
-			SR(CPR_COEF_B(i));
+		SR(dispc, TIMING_H(i));
+		SR(dispc, TIMING_V(i));
+		SR(dispc, POL_FREQ(i));
+		SR(dispc, DIVISORo(i));
+
+		SR(dispc, DATA_CYCLE1(i));
+		SR(dispc, DATA_CYCLE2(i));
+		SR(dispc, DATA_CYCLE3(i));
+
+		if (dispc_has_feature(dispc, FEAT_CPR)) {
+			SR(dispc, CPR_COEF_R(i));
+			SR(dispc, CPR_COEF_G(i));
+			SR(dispc, CPR_COEF_B(i));
 		}
 	}
 
-	for (i = 0; i < dispc_get_num_ovls(&dispc); i++) {
-		SR(OVL_BA0(i));
-		SR(OVL_BA1(i));
-		SR(OVL_POSITION(i));
-		SR(OVL_SIZE(i));
-		SR(OVL_ATTRIBUTES(i));
-		SR(OVL_FIFO_THRESHOLD(i));
-		SR(OVL_ROW_INC(i));
-		SR(OVL_PIXEL_INC(i));
-		if (dispc_has_feature(FEAT_PRELOAD))
-			SR(OVL_PRELOAD(i));
+	for (i = 0; i < dispc_get_num_ovls(dispc); i++) {
+		SR(dispc, OVL_BA0(i));
+		SR(dispc, OVL_BA1(i));
+		SR(dispc, OVL_POSITION(i));
+		SR(dispc, OVL_SIZE(i));
+		SR(dispc, OVL_ATTRIBUTES(i));
+		SR(dispc, OVL_FIFO_THRESHOLD(i));
+		SR(dispc, OVL_ROW_INC(i));
+		SR(dispc, OVL_PIXEL_INC(i));
+		if (dispc_has_feature(dispc, FEAT_PRELOAD))
+			SR(dispc, OVL_PRELOAD(i));
 		if (i == OMAP_DSS_GFX) {
-			SR(OVL_WINDOW_SKIP(i));
-			SR(OVL_TABLE_BA(i));
+			SR(dispc, OVL_WINDOW_SKIP(i));
+			SR(dispc, OVL_TABLE_BA(i));
 			continue;
 		}
-		SR(OVL_FIR(i));
-		SR(OVL_PICTURE_SIZE(i));
-		SR(OVL_ACCU0(i));
-		SR(OVL_ACCU1(i));
+		SR(dispc, OVL_FIR(i));
+		SR(dispc, OVL_PICTURE_SIZE(i));
+		SR(dispc, OVL_ACCU0(i));
+		SR(dispc, OVL_ACCU1(i));
 
 		for (j = 0; j < 8; j++)
-			SR(OVL_FIR_COEF_H(i, j));
+			SR(dispc, OVL_FIR_COEF_H(i, j));
 
 		for (j = 0; j < 8; j++)
-			SR(OVL_FIR_COEF_HV(i, j));
+			SR(dispc, OVL_FIR_COEF_HV(i, j));
 
 		for (j = 0; j < 5; j++)
-			SR(OVL_CONV_COEF(i, j));
+			SR(dispc, OVL_CONV_COEF(i, j));
 
-		if (dispc_has_feature(FEAT_FIR_COEF_V)) {
+		if (dispc_has_feature(dispc, FEAT_FIR_COEF_V)) {
 			for (j = 0; j < 8; j++)
-				SR(OVL_FIR_COEF_V(i, j));
+				SR(dispc, OVL_FIR_COEF_V(i, j));
 		}
 
-		if (dispc_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
-			SR(OVL_BA0_UV(i));
-			SR(OVL_BA1_UV(i));
-			SR(OVL_FIR2(i));
-			SR(OVL_ACCU2_0(i));
-			SR(OVL_ACCU2_1(i));
+		if (dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE)) {
+			SR(dispc, OVL_BA0_UV(i));
+			SR(dispc, OVL_BA1_UV(i));
+			SR(dispc, OVL_FIR2(i));
+			SR(dispc, OVL_ACCU2_0(i));
+			SR(dispc, OVL_ACCU2_1(i));
 
 			for (j = 0; j < 8; j++)
-				SR(OVL_FIR_COEF_H2(i, j));
+				SR(dispc, OVL_FIR_COEF_H2(i, j));
 
 			for (j = 0; j < 8; j++)
-				SR(OVL_FIR_COEF_HV2(i, j));
+				SR(dispc, OVL_FIR_COEF_HV2(i, j));
 
 			for (j = 0; j < 8; j++)
-				SR(OVL_FIR_COEF_V2(i, j));
+				SR(dispc, OVL_FIR_COEF_V2(i, j));
 		}
-		if (dispc_has_feature(FEAT_ATTR2))
-			SR(OVL_ATTRIBUTES2(i));
+		if (dispc_has_feature(dispc, FEAT_ATTR2))
+			SR(dispc, OVL_ATTRIBUTES2(i));
 	}
 
-	if (dispc_has_feature(FEAT_CORE_CLK_DIV))
-		SR(DIVISOR);
+	if (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))
+		SR(dispc, DIVISOR);
 
-	dispc.ctx_valid = true;
+	dispc->ctx_valid = true;
 
 	DSSDBG("context saved\n");
 }
 
-static void dispc_restore_context(void)
+static void dispc_restore_context(struct dispc_device *dispc)
 {
 	int i, j;
 
 	DSSDBG("dispc_restore_context\n");
 
-	if (!dispc.ctx_valid)
+	if (!dispc->ctx_valid)
 		return;
 
-	/*RR(IRQENABLE);*/
-	/*RR(CONTROL);*/
-	RR(CONFIG);
-	RR(LINE_NUMBER);
-	if (dispc_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||
-			dispc_has_feature(FEAT_ALPHA_FREE_ZORDER))
-		RR(GLOBAL_ALPHA);
-	if (dispc_has_feature(FEAT_MGR_LCD2))
-		RR(CONFIG2);
-	if (dispc_has_feature(FEAT_MGR_LCD3))
-		RR(CONFIG3);
-
-	for (i = 0; i < dispc_get_num_mgrs(&dispc); i++) {
-		RR(DEFAULT_COLOR(i));
-		RR(TRANS_COLOR(i));
-		RR(SIZE_MGR(i));
+	/*RR(dispc, IRQENABLE);*/
+	/*RR(dispc, CONTROL);*/
+	RR(dispc, CONFIG);
+	RR(dispc, LINE_NUMBER);
+	if (dispc_has_feature(dispc, FEAT_ALPHA_FIXED_ZORDER) ||
+			dispc_has_feature(dispc, FEAT_ALPHA_FREE_ZORDER))
+		RR(dispc, GLOBAL_ALPHA);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD2))
+		RR(dispc, CONFIG2);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD3))
+		RR(dispc, CONFIG3);
+
+	for (i = 0; i < dispc_get_num_mgrs(dispc); i++) {
+		RR(dispc, DEFAULT_COLOR(i));
+		RR(dispc, TRANS_COLOR(i));
+		RR(dispc, SIZE_MGR(i));
 		if (i == OMAP_DSS_CHANNEL_DIGIT)
 			continue;
-		RR(TIMING_H(i));
-		RR(TIMING_V(i));
-		RR(POL_FREQ(i));
-		RR(DIVISORo(i));
-
-		RR(DATA_CYCLE1(i));
-		RR(DATA_CYCLE2(i));
-		RR(DATA_CYCLE3(i));
-
-		if (dispc_has_feature(FEAT_CPR)) {
-			RR(CPR_COEF_R(i));
-			RR(CPR_COEF_G(i));
-			RR(CPR_COEF_B(i));
+		RR(dispc, TIMING_H(i));
+		RR(dispc, TIMING_V(i));
+		RR(dispc, POL_FREQ(i));
+		RR(dispc, DIVISORo(i));
+
+		RR(dispc, DATA_CYCLE1(i));
+		RR(dispc, DATA_CYCLE2(i));
+		RR(dispc, DATA_CYCLE3(i));
+
+		if (dispc_has_feature(dispc, FEAT_CPR)) {
+			RR(dispc, CPR_COEF_R(i));
+			RR(dispc, CPR_COEF_G(i));
+			RR(dispc, CPR_COEF_B(i));
 		}
 	}
 
-	for (i = 0; i < dispc_get_num_ovls(&dispc); i++) {
-		RR(OVL_BA0(i));
-		RR(OVL_BA1(i));
-		RR(OVL_POSITION(i));
-		RR(OVL_SIZE(i));
-		RR(OVL_ATTRIBUTES(i));
-		RR(OVL_FIFO_THRESHOLD(i));
-		RR(OVL_ROW_INC(i));
-		RR(OVL_PIXEL_INC(i));
-		if (dispc_has_feature(FEAT_PRELOAD))
-			RR(OVL_PRELOAD(i));
+	for (i = 0; i < dispc_get_num_ovls(dispc); i++) {
+		RR(dispc, OVL_BA0(i));
+		RR(dispc, OVL_BA1(i));
+		RR(dispc, OVL_POSITION(i));
+		RR(dispc, OVL_SIZE(i));
+		RR(dispc, OVL_ATTRIBUTES(i));
+		RR(dispc, OVL_FIFO_THRESHOLD(i));
+		RR(dispc, OVL_ROW_INC(i));
+		RR(dispc, OVL_PIXEL_INC(i));
+		if (dispc_has_feature(dispc, FEAT_PRELOAD))
+			RR(dispc, OVL_PRELOAD(i));
 		if (i == OMAP_DSS_GFX) {
-			RR(OVL_WINDOW_SKIP(i));
-			RR(OVL_TABLE_BA(i));
+			RR(dispc, OVL_WINDOW_SKIP(i));
+			RR(dispc, OVL_TABLE_BA(i));
 			continue;
 		}
-		RR(OVL_FIR(i));
-		RR(OVL_PICTURE_SIZE(i));
-		RR(OVL_ACCU0(i));
-		RR(OVL_ACCU1(i));
+		RR(dispc, OVL_FIR(i));
+		RR(dispc, OVL_PICTURE_SIZE(i));
+		RR(dispc, OVL_ACCU0(i));
+		RR(dispc, OVL_ACCU1(i));
 
 		for (j = 0; j < 8; j++)
-			RR(OVL_FIR_COEF_H(i, j));
+			RR(dispc, OVL_FIR_COEF_H(i, j));
 
 		for (j = 0; j < 8; j++)
-			RR(OVL_FIR_COEF_HV(i, j));
+			RR(dispc, OVL_FIR_COEF_HV(i, j));
 
 		for (j = 0; j < 5; j++)
-			RR(OVL_CONV_COEF(i, j));
+			RR(dispc, OVL_CONV_COEF(i, j));
 
-		if (dispc_has_feature(FEAT_FIR_COEF_V)) {
+		if (dispc_has_feature(dispc, FEAT_FIR_COEF_V)) {
 			for (j = 0; j < 8; j++)
-				RR(OVL_FIR_COEF_V(i, j));
+				RR(dispc, OVL_FIR_COEF_V(i, j));
 		}
 
-		if (dispc_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
-			RR(OVL_BA0_UV(i));
-			RR(OVL_BA1_UV(i));
-			RR(OVL_FIR2(i));
-			RR(OVL_ACCU2_0(i));
-			RR(OVL_ACCU2_1(i));
+		if (dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE)) {
+			RR(dispc, OVL_BA0_UV(i));
+			RR(dispc, OVL_BA1_UV(i));
+			RR(dispc, OVL_FIR2(i));
+			RR(dispc, OVL_ACCU2_0(i));
+			RR(dispc, OVL_ACCU2_1(i));
 
 			for (j = 0; j < 8; j++)
-				RR(OVL_FIR_COEF_H2(i, j));
+				RR(dispc, OVL_FIR_COEF_H2(i, j));
 
 			for (j = 0; j < 8; j++)
-				RR(OVL_FIR_COEF_HV2(i, j));
+				RR(dispc, OVL_FIR_COEF_HV2(i, j));
 
 			for (j = 0; j < 8; j++)
-				RR(OVL_FIR_COEF_V2(i, j));
+				RR(dispc, OVL_FIR_COEF_V2(i, j));
 		}
-		if (dispc_has_feature(FEAT_ATTR2))
-			RR(OVL_ATTRIBUTES2(i));
+		if (dispc_has_feature(dispc, FEAT_ATTR2))
+			RR(dispc, OVL_ATTRIBUTES2(i));
 	}
 
-	if (dispc_has_feature(FEAT_CORE_CLK_DIV))
-		RR(DIVISOR);
+	if (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))
+		RR(dispc, DIVISOR);
 
 	/* enable last, because LCD & DIGIT enable are here */
-	RR(CONTROL);
-	if (dispc_has_feature(FEAT_MGR_LCD2))
-		RR(CONTROL2);
-	if (dispc_has_feature(FEAT_MGR_LCD3))
-		RR(CONTROL3);
+	RR(dispc, CONTROL);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD2))
+		RR(dispc, CONTROL2);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD3))
+		RR(dispc, CONTROL3);
 	/* clear spurious SYNC_LOST_DIGIT interrupts */
-	dispc_clear_irqstatus(&dispc, DISPC_IRQ_SYNC_LOST_DIGIT);
+	dispc_clear_irqstatus(dispc, DISPC_IRQ_SYNC_LOST_DIGIT);
 
 	/*
 	 * enable last so IRQs won't trigger before
 	 * the context is fully restored
 	 */
-	RR(IRQENABLE);
+	RR(dispc, IRQENABLE);
 
 	DSSDBG("context restored\n");
 }
@@ -712,21 +723,21 @@ u32 dispc_wb_get_framedone_irq(struct di
 static void dispc_mgr_enable(struct dispc_device *dispc,
 			     enum omap_channel channel, bool enable)
 {
-	mgr_fld_write(channel, DISPC_MGR_FLD_ENABLE, enable);
+	mgr_fld_write(dispc, channel, DISPC_MGR_FLD_ENABLE, enable);
 	/* flush posted write */
-	mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);
+	mgr_fld_read(dispc, channel, DISPC_MGR_FLD_ENABLE);
 }
 
 static bool dispc_mgr_is_enabled(struct dispc_device *dispc,
 				 enum omap_channel channel)
 {
-	return !!mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);
+	return !!mgr_fld_read(dispc, channel, DISPC_MGR_FLD_ENABLE);
 }
 
 static bool dispc_mgr_go_busy(struct dispc_device *dispc,
 			      enum omap_channel channel)
 {
-	return mgr_fld_read(channel, DISPC_MGR_FLD_GO) == 1;
+	return mgr_fld_read(dispc, channel, DISPC_MGR_FLD_GO) == 1;
 }
 
 static void dispc_mgr_go(struct dispc_device *dispc, enum omap_channel channel)
@@ -736,12 +747,12 @@ static void dispc_mgr_go(struct dispc_de
 
 	DSSDBG("GO %s\n", mgr_desc[channel].name);
 
-	mgr_fld_write(channel, DISPC_MGR_FLD_GO, 1);
+	mgr_fld_write(dispc, channel, DISPC_MGR_FLD_GO, 1);
 }
 
 bool dispc_wb_go_busy(struct dispc_device *dispc)
 {
-	return REG_GET(DISPC_CONTROL2, 6, 6) == 1;
+	return REG_GET(dispc, DISPC_CONTROL2, 6, 6) == 1;
 }
 
 void dispc_wb_go(struct dispc_device *dispc)
@@ -749,65 +760,72 @@ void dispc_wb_go(struct dispc_device *di
 	enum omap_plane_id plane = OMAP_DSS_WB;
 	bool enable, go;
 
-	enable = REG_GET(DISPC_OVL_ATTRIBUTES(plane), 0, 0) == 1;
+	enable = REG_GET(dispc, DISPC_OVL_ATTRIBUTES(plane), 0, 0) == 1;
 
 	if (!enable)
 		return;
 
-	go = REG_GET(DISPC_CONTROL2, 6, 6) == 1;
+	go = REG_GET(dispc, DISPC_CONTROL2, 6, 6) == 1;
 	if (go) {
 		DSSERR("GO bit not down for WB\n");
 		return;
 	}
 
-	REG_FLD_MOD(DISPC_CONTROL2, 1, 6, 6);
+	REG_FLD_MOD(dispc, DISPC_CONTROL2, 1, 6, 6);
 }
 
-static void dispc_ovl_write_firh_reg(enum omap_plane_id plane, int reg,
+static void dispc_ovl_write_firh_reg(struct dispc_device *dispc,
+				     enum omap_plane_id plane, int reg,
 				     u32 value)
 {
-	dispc_write_reg(DISPC_OVL_FIR_COEF_H(plane, reg), value);
+	dispc_write_reg(dispc, DISPC_OVL_FIR_COEF_H(plane, reg), value);
 }
 
-static void dispc_ovl_write_firhv_reg(enum omap_plane_id plane, int reg,
+static void dispc_ovl_write_firhv_reg(struct dispc_device *dispc,
+				      enum omap_plane_id plane, int reg,
 				      u32 value)
 {
-	dispc_write_reg(DISPC_OVL_FIR_COEF_HV(plane, reg), value);
+	dispc_write_reg(dispc, DISPC_OVL_FIR_COEF_HV(plane, reg), value);
 }
 
-static void dispc_ovl_write_firv_reg(enum omap_plane_id plane, int reg,
+static void dispc_ovl_write_firv_reg(struct dispc_device *dispc,
+				     enum omap_plane_id plane, int reg,
 				     u32 value)
 {
-	dispc_write_reg(DISPC_OVL_FIR_COEF_V(plane, reg), value);
+	dispc_write_reg(dispc, DISPC_OVL_FIR_COEF_V(plane, reg), value);
 }
 
-static void dispc_ovl_write_firh2_reg(enum omap_plane_id plane, int reg,
+static void dispc_ovl_write_firh2_reg(struct dispc_device *dispc,
+				      enum omap_plane_id plane, int reg,
 				      u32 value)
 {
 	BUG_ON(plane == OMAP_DSS_GFX);
 
-	dispc_write_reg(DISPC_OVL_FIR_COEF_H2(plane, reg), value);
+	dispc_write_reg(dispc, DISPC_OVL_FIR_COEF_H2(plane, reg), value);
 }
 
-static void dispc_ovl_write_firhv2_reg(enum omap_plane_id plane, int reg,
-		u32 value)
+static void dispc_ovl_write_firhv2_reg(struct dispc_device *dispc,
+				       enum omap_plane_id plane, int reg,
+				       u32 value)
 {
 	BUG_ON(plane == OMAP_DSS_GFX);
 
-	dispc_write_reg(DISPC_OVL_FIR_COEF_HV2(plane, reg), value);
+	dispc_write_reg(dispc, DISPC_OVL_FIR_COEF_HV2(plane, reg), value);
 }
 
-static void dispc_ovl_write_firv2_reg(enum omap_plane_id plane, int reg,
+static void dispc_ovl_write_firv2_reg(struct dispc_device *dispc,
+				      enum omap_plane_id plane, int reg,
 				      u32 value)
 {
 	BUG_ON(plane == OMAP_DSS_GFX);
 
-	dispc_write_reg(DISPC_OVL_FIR_COEF_V2(plane, reg), value);
+	dispc_write_reg(dispc, DISPC_OVL_FIR_COEF_V2(plane, reg), value);
 }
 
-static void dispc_ovl_set_scale_coef(enum omap_plane_id plane, int fir_hinc,
-				int fir_vinc, int five_taps,
-				enum omap_color_component color_comp)
+static void dispc_ovl_set_scale_coef(struct dispc_device *dispc,
+				     enum omap_plane_id plane, int fir_hinc,
+				     int fir_vinc, int five_taps,
+				     enum omap_color_component color_comp)
 {
 	const struct dispc_coef *h_coef, *v_coef;
 	int i;
@@ -828,11 +846,11 @@ static void dispc_ovl_set_scale_coef(enu
 			| FLD_VAL(v_coef[i].hc3_vc2, 31, 24);
 
 		if (color_comp == DISPC_COLOR_COMPONENT_RGB_Y) {
-			dispc_ovl_write_firh_reg(plane, i, h);
-			dispc_ovl_write_firhv_reg(plane, i, hv);
+			dispc_ovl_write_firh_reg(dispc, plane, i, h);
+			dispc_ovl_write_firhv_reg(dispc, plane, i, hv);
 		} else {
-			dispc_ovl_write_firh2_reg(plane, i, h);
-			dispc_ovl_write_firhv2_reg(plane, i, hv);
+			dispc_ovl_write_firh2_reg(dispc, plane, i, h);
+			dispc_ovl_write_firhv2_reg(dispc, plane, i, hv);
 		}
 
 	}
@@ -843,34 +861,35 @@ static void dispc_ovl_set_scale_coef(enu
 			v = FLD_VAL(v_coef[i].hc0_vc00, 7, 0)
 				| FLD_VAL(v_coef[i].hc4_vc22, 15, 8);
 			if (color_comp == DISPC_COLOR_COMPONENT_RGB_Y)
-				dispc_ovl_write_firv_reg(plane, i, v);
+				dispc_ovl_write_firv_reg(dispc, plane, i, v);
 			else
-				dispc_ovl_write_firv2_reg(plane, i, v);
+				dispc_ovl_write_firv2_reg(dispc, plane, i, v);
 		}
 	}
 }
 
 
-static void dispc_ovl_write_color_conv_coef(enum omap_plane_id plane,
-		const struct color_conv_coef *ct)
+static void dispc_ovl_write_color_conv_coef(struct dispc_device *dispc,
+					    enum omap_plane_id plane,
+					    const struct color_conv_coef *ct)
 {
 #define CVAL(x, y) (FLD_VAL(x, 26, 16) | FLD_VAL(y, 10, 0))
 
-	dispc_write_reg(DISPC_OVL_CONV_COEF(plane, 0), CVAL(ct->rcr, ct->ry));
-	dispc_write_reg(DISPC_OVL_CONV_COEF(plane, 1), CVAL(ct->gy,  ct->rcb));
-	dispc_write_reg(DISPC_OVL_CONV_COEF(plane, 2), CVAL(ct->gcb, ct->gcr));
-	dispc_write_reg(DISPC_OVL_CONV_COEF(plane, 3), CVAL(ct->bcr, ct->by));
-	dispc_write_reg(DISPC_OVL_CONV_COEF(plane, 4), CVAL(0, ct->bcb));
+	dispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 0), CVAL(ct->rcr, ct->ry));
+	dispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 1), CVAL(ct->gy,  ct->rcb));
+	dispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 2), CVAL(ct->gcb, ct->gcr));
+	dispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 3), CVAL(ct->bcr, ct->by));
+	dispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 4), CVAL(0, ct->bcb));
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), ct->full_range, 11, 11);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), ct->full_range, 11, 11);
 
 #undef CVAL
 }
 
-static void dispc_setup_color_conv_coef(void)
+static void dispc_setup_color_conv_coef(struct dispc_device *dispc)
 {
 	int i;
-	int num_ovl = dispc_get_num_ovls(&dispc);
+	int num_ovl = dispc_get_num_ovls(dispc);
 	const struct color_conv_coef ctbl_bt601_5_ovl = {
 		/* YUV -> RGB */
 		298, 409, 0, 298, -208, -100, 298, 0, 517, 0,
@@ -881,34 +900,40 @@ static void dispc_setup_color_conv_coef(
 	};
 
 	for (i = 1; i < num_ovl; i++)
-		dispc_ovl_write_color_conv_coef(i, &ctbl_bt601_5_ovl);
+		dispc_ovl_write_color_conv_coef(dispc, i, &ctbl_bt601_5_ovl);
 
-	if (dispc.feat->has_writeback)
-		dispc_ovl_write_color_conv_coef(OMAP_DSS_WB, &ctbl_bt601_5_wb);
+	if (dispc->feat->has_writeback)
+		dispc_ovl_write_color_conv_coef(dispc, OMAP_DSS_WB,
+						&ctbl_bt601_5_wb);
 }
 
-static void dispc_ovl_set_ba0(enum omap_plane_id plane, u32 paddr)
+static void dispc_ovl_set_ba0(struct dispc_device *dispc,
+			      enum omap_plane_id plane, u32 paddr)
 {
-	dispc_write_reg(DISPC_OVL_BA0(plane), paddr);
+	dispc_write_reg(dispc, DISPC_OVL_BA0(plane), paddr);
 }
 
-static void dispc_ovl_set_ba1(enum omap_plane_id plane, u32 paddr)
+static void dispc_ovl_set_ba1(struct dispc_device *dispc,
+			      enum omap_plane_id plane, u32 paddr)
 {
-	dispc_write_reg(DISPC_OVL_BA1(plane), paddr);
+	dispc_write_reg(dispc, DISPC_OVL_BA1(plane), paddr);
 }
 
-static void dispc_ovl_set_ba0_uv(enum omap_plane_id plane, u32 paddr)
+static void dispc_ovl_set_ba0_uv(struct dispc_device *dispc,
+				 enum omap_plane_id plane, u32 paddr)
 {
-	dispc_write_reg(DISPC_OVL_BA0_UV(plane), paddr);
+	dispc_write_reg(dispc, DISPC_OVL_BA0_UV(plane), paddr);
 }
 
-static void dispc_ovl_set_ba1_uv(enum omap_plane_id plane, u32 paddr)
+static void dispc_ovl_set_ba1_uv(struct dispc_device *dispc,
+				 enum omap_plane_id plane, u32 paddr)
 {
-	dispc_write_reg(DISPC_OVL_BA1_UV(plane), paddr);
+	dispc_write_reg(dispc, DISPC_OVL_BA1_UV(plane), paddr);
 }
 
-static void dispc_ovl_set_pos(enum omap_plane_id plane,
-		enum omap_overlay_caps caps, int x, int y)
+static void dispc_ovl_set_pos(struct dispc_device *dispc,
+			      enum omap_plane_id plane,
+			      enum omap_overlay_caps caps, int x, int y)
 {
 	u32 val;
 
@@ -917,22 +942,24 @@ static void dispc_ovl_set_pos(enum omap_
 
 	val = FLD_VAL(y, 26, 16) | FLD_VAL(x, 10, 0);
 
-	dispc_write_reg(DISPC_OVL_POSITION(plane), val);
+	dispc_write_reg(dispc, DISPC_OVL_POSITION(plane), val);
 }
 
-static void dispc_ovl_set_input_size(enum omap_plane_id plane, int width,
-		int height)
+static void dispc_ovl_set_input_size(struct dispc_device *dispc,
+				     enum omap_plane_id plane, int width,
+				     int height)
 {
 	u32 val = FLD_VAL(height - 1, 26, 16) | FLD_VAL(width - 1, 10, 0);
 
 	if (plane == OMAP_DSS_GFX || plane == OMAP_DSS_WB)
-		dispc_write_reg(DISPC_OVL_SIZE(plane), val);
+		dispc_write_reg(dispc, DISPC_OVL_SIZE(plane), val);
 	else
-		dispc_write_reg(DISPC_OVL_PICTURE_SIZE(plane), val);
+		dispc_write_reg(dispc, DISPC_OVL_PICTURE_SIZE(plane), val);
 }
 
-static void dispc_ovl_set_output_size(enum omap_plane_id plane, int width,
-		int height)
+static void dispc_ovl_set_output_size(struct dispc_device *dispc,
+				      enum omap_plane_id plane, int width,
+				      int height)
 {
 	u32 val;
 
@@ -941,42 +968,47 @@ static void dispc_ovl_set_output_size(en
 	val = FLD_VAL(height - 1, 26, 16) | FLD_VAL(width - 1, 10, 0);
 
 	if (plane == OMAP_DSS_WB)
-		dispc_write_reg(DISPC_OVL_PICTURE_SIZE(plane), val);
+		dispc_write_reg(dispc, DISPC_OVL_PICTURE_SIZE(plane), val);
 	else
-		dispc_write_reg(DISPC_OVL_SIZE(plane), val);
+		dispc_write_reg(dispc, DISPC_OVL_SIZE(plane), val);
 }
 
-static void dispc_ovl_set_zorder(enum omap_plane_id plane,
-		enum omap_overlay_caps caps, u8 zorder)
+static void dispc_ovl_set_zorder(struct dispc_device *dispc,
+				 enum omap_plane_id plane,
+				 enum omap_overlay_caps caps, u8 zorder)
 {
 	if ((caps & OMAP_DSS_OVL_CAP_ZORDER) == 0)
 		return;
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), zorder, 27, 26);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), zorder, 27, 26);
 }
 
-static void dispc_ovl_enable_zorder_planes(void)
+static void dispc_ovl_enable_zorder_planes(struct dispc_device *dispc)
 {
 	int i;
 
-	if (!dispc_has_feature(FEAT_ALPHA_FREE_ZORDER))
+	if (!dispc_has_feature(dispc, FEAT_ALPHA_FREE_ZORDER))
 		return;
 
-	for (i = 0; i < dispc_get_num_ovls(&dispc); i++)
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(i), 1, 25, 25);
+	for (i = 0; i < dispc_get_num_ovls(dispc); i++)
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(i), 1, 25, 25);
 }
 
-static void dispc_ovl_set_pre_mult_alpha(enum omap_plane_id plane,
-		enum omap_overlay_caps caps, bool enable)
+static void dispc_ovl_set_pre_mult_alpha(struct dispc_device *dispc,
+					 enum omap_plane_id plane,
+					 enum omap_overlay_caps caps,
+					 bool enable)
 {
 	if ((caps & OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA) == 0)
 		return;
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 28, 28);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 28, 28);
 }
 
-static void dispc_ovl_setup_global_alpha(enum omap_plane_id plane,
-		enum omap_overlay_caps caps, u8 global_alpha)
+static void dispc_ovl_setup_global_alpha(struct dispc_device *dispc,
+					 enum omap_plane_id plane,
+					 enum omap_overlay_caps caps,
+					 u8 global_alpha)
 {
 	static const unsigned int shifts[] = { 0, 8, 16, 24, };
 	int shift;
@@ -985,20 +1017,23 @@ static void dispc_ovl_setup_global_alpha
 		return;
 
 	shift = shifts[plane];
-	REG_FLD_MOD(DISPC_GLOBAL_ALPHA, global_alpha, shift + 7, shift);
+	REG_FLD_MOD(dispc, DISPC_GLOBAL_ALPHA, global_alpha, shift + 7, shift);
 }
 
-static void dispc_ovl_set_pix_inc(enum omap_plane_id plane, s32 inc)
+static void dispc_ovl_set_pix_inc(struct dispc_device *dispc,
+				  enum omap_plane_id plane, s32 inc)
 {
-	dispc_write_reg(DISPC_OVL_PIXEL_INC(plane), inc);
+	dispc_write_reg(dispc, DISPC_OVL_PIXEL_INC(plane), inc);
 }
 
-static void dispc_ovl_set_row_inc(enum omap_plane_id plane, s32 inc)
+static void dispc_ovl_set_row_inc(struct dispc_device *dispc,
+				  enum omap_plane_id plane, s32 inc)
 {
-	dispc_write_reg(DISPC_OVL_ROW_INC(plane), inc);
+	dispc_write_reg(dispc, DISPC_OVL_ROW_INC(plane), inc);
 }
 
-static void dispc_ovl_set_color_mode(enum omap_plane_id plane, u32 fourcc)
+static void dispc_ovl_set_color_mode(struct dispc_device *dispc,
+				     enum omap_plane_id plane, u32 fourcc)
 {
 	u32 m = 0;
 	if (plane != OMAP_DSS_GFX) {
@@ -1067,7 +1102,7 @@ static void dispc_ovl_set_color_mode(enu
 		}
 	}
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), m, 4, 1);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), m, 4, 1);
 }
 
 static bool format_is_yuv(u32 fourcc)
@@ -1082,19 +1117,21 @@ static bool format_is_yuv(u32 fourcc)
 	}
 }
 
-static void dispc_ovl_configure_burst_type(enum omap_plane_id plane,
-		enum omap_dss_rotation_type rotation_type)
+static void dispc_ovl_configure_burst_type(struct dispc_device *dispc,
+					   enum omap_plane_id plane,
+					   enum omap_dss_rotation_type rotation)
 {
-	if (dispc_has_feature(FEAT_BURST_2D) == 0)
+	if (dispc_has_feature(dispc, FEAT_BURST_2D) == 0)
 		return;
 
-	if (rotation_type == OMAP_DSS_ROT_TILER)
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), 1, 29, 29);
+	if (rotation == OMAP_DSS_ROT_TILER)
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), 1, 29, 29);
 	else
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), 0, 29, 29);
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), 0, 29, 29);
 }
 
-static void dispc_ovl_set_channel_out(enum omap_plane_id plane,
+static void dispc_ovl_set_channel_out(struct dispc_device *dispc,
+				      enum omap_plane_id plane,
 				      enum omap_channel channel)
 {
 	int shift;
@@ -1115,8 +1152,8 @@ static void dispc_ovl_set_channel_out(en
 		return;
 	}
 
-	val = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
-	if (dispc_has_feature(FEAT_MGR_LCD2)) {
+	val = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD2)) {
 		switch (channel) {
 		case OMAP_DSS_CHANNEL_LCD:
 			chan = 0;
@@ -1131,7 +1168,7 @@ static void dispc_ovl_set_channel_out(en
 			chan2 = 1;
 			break;
 		case OMAP_DSS_CHANNEL_LCD3:
-			if (dispc_has_feature(FEAT_MGR_LCD3)) {
+			if (dispc_has_feature(dispc, FEAT_MGR_LCD3)) {
 				chan = 0;
 				chan2 = 2;
 			} else {
@@ -1153,10 +1190,11 @@ static void dispc_ovl_set_channel_out(en
 	} else {
 		val = FLD_MOD(val, channel, shift, shift);
 	}
-	dispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), val);
+	dispc_write_reg(dispc, DISPC_OVL_ATTRIBUTES(plane), val);
 }
 
-static enum omap_channel dispc_ovl_get_channel_out(enum omap_plane_id plane)
+static enum omap_channel dispc_ovl_get_channel_out(struct dispc_device *dispc,
+						   enum omap_plane_id plane)
 {
 	int shift;
 	u32 val;
@@ -1175,12 +1213,12 @@ static enum omap_channel dispc_ovl_get_c
 		return 0;
 	}
 
-	val = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
+	val = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));
 
 	if (FLD_GET(val, shift, shift) == 1)
 		return OMAP_DSS_CHANNEL_DIGIT;
 
-	if (!dispc_has_feature(FEAT_MGR_LCD2))
+	if (!dispc_has_feature(dispc, FEAT_MGR_LCD2))
 		return OMAP_DSS_CHANNEL_LCD;
 
 	switch (FLD_GET(val, 31, 30)) {
@@ -1201,43 +1239,47 @@ void dispc_wb_set_channel_in(struct disp
 {
 	enum omap_plane_id plane = OMAP_DSS_WB;
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), channel, 18, 16);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), channel, 18, 16);
 }
 
-static void dispc_ovl_set_burst_size(enum omap_plane_id plane,
-		enum omap_burst_size burst_size)
+static void dispc_ovl_set_burst_size(struct dispc_device *dispc,
+				     enum omap_plane_id plane,
+				     enum omap_burst_size burst_size)
 {
 	static const unsigned int shifts[] = { 6, 14, 14, 14, 14, };
 	int shift;
 
 	shift = shifts[plane];
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), burst_size, shift + 1, shift);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), burst_size,
+		    shift + 1, shift);
 }
 
-static void dispc_configure_burst_sizes(void)
+static void dispc_configure_burst_sizes(struct dispc_device *dispc)
 {
 	int i;
 	const int burst_size = BURST_SIZE_X8;
 
 	/* Configure burst size always to maximum size */
-	for (i = 0; i < dispc_get_num_ovls(&dispc); ++i)
-		dispc_ovl_set_burst_size(i, burst_size);
-	if (dispc.feat->has_writeback)
-		dispc_ovl_set_burst_size(OMAP_DSS_WB, burst_size);
+	for (i = 0; i < dispc_get_num_ovls(dispc); ++i)
+		dispc_ovl_set_burst_size(dispc, i, burst_size);
+	if (dispc->feat->has_writeback)
+		dispc_ovl_set_burst_size(dispc, OMAP_DSS_WB, burst_size);
 }
 
-static u32 dispc_ovl_get_burst_size(enum omap_plane_id plane)
+static u32 dispc_ovl_get_burst_size(struct dispc_device *dispc,
+				    enum omap_plane_id plane)
 {
 	/* burst multiplier is always x8 (see dispc_configure_burst_sizes()) */
-	return dispc.feat->burst_size_unit * 8;
+	return dispc->feat->burst_size_unit * 8;
 }
 
-static bool dispc_ovl_color_mode_supported(enum omap_plane_id plane, u32 fourcc)
+static bool dispc_ovl_color_mode_supported(struct dispc_device *dispc,
+					   enum omap_plane_id plane, u32 fourcc)
 {
 	const u32 *modes;
 	unsigned int i;
 
-	modes = dispc.feat->supported_color_modes[plane];
+	modes = dispc->feat->supported_color_modes[plane];
 
 	for (i = 0; modes[i]; ++i) {
 		if (modes[i] == fourcc)
@@ -1253,16 +1295,18 @@ static const u32 *dispc_ovl_get_color_mo
 	return dispc->feat->supported_color_modes[plane];
 }
 
-static void dispc_mgr_enable_cpr(enum omap_channel channel, bool enable)
+static void dispc_mgr_enable_cpr(struct dispc_device *dispc,
+				 enum omap_channel channel, bool enable)
 {
 	if (channel == OMAP_DSS_CHANNEL_DIGIT)
 		return;
 
-	mgr_fld_write(channel, DISPC_MGR_FLD_CPR, enable);
+	mgr_fld_write(dispc, channel, DISPC_MGR_FLD_CPR, enable);
 }
 
-static void dispc_mgr_set_cpr_coef(enum omap_channel channel,
-		const struct omap_dss_cpr_coefs *coefs)
+static void dispc_mgr_set_cpr_coef(struct dispc_device *dispc,
+				   enum omap_channel channel,
+				   const struct omap_dss_cpr_coefs *coefs)
 {
 	u32 coef_r, coef_g, coef_b;
 
@@ -1276,25 +1320,27 @@ static void dispc_mgr_set_cpr_coef(enum
 	coef_b = FLD_VAL(coefs->br, 31, 22) | FLD_VAL(coefs->bg, 20, 11) |
 		FLD_VAL(coefs->bb, 9, 0);
 
-	dispc_write_reg(DISPC_CPR_COEF_R(channel), coef_r);
-	dispc_write_reg(DISPC_CPR_COEF_G(channel), coef_g);
-	dispc_write_reg(DISPC_CPR_COEF_B(channel), coef_b);
+	dispc_write_reg(dispc, DISPC_CPR_COEF_R(channel), coef_r);
+	dispc_write_reg(dispc, DISPC_CPR_COEF_G(channel), coef_g);
+	dispc_write_reg(dispc, DISPC_CPR_COEF_B(channel), coef_b);
 }
 
-static void dispc_ovl_set_vid_color_conv(enum omap_plane_id plane,
-					 bool enable)
+static void dispc_ovl_set_vid_color_conv(struct dispc_device *dispc,
+					 enum omap_plane_id plane, bool enable)
 {
 	u32 val;
 
 	BUG_ON(plane == OMAP_DSS_GFX);
 
-	val = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
+	val = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));
 	val = FLD_MOD(val, enable, 9, 9);
-	dispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), val);
+	dispc_write_reg(dispc, DISPC_OVL_ATTRIBUTES(plane), val);
 }
 
-static void dispc_ovl_enable_replication(enum omap_plane_id plane,
-		enum omap_overlay_caps caps, bool enable)
+static void dispc_ovl_enable_replication(struct dispc_device *dispc,
+					 enum omap_plane_id plane,
+					 enum omap_overlay_caps caps,
+					 bool enable)
 {
 	static const unsigned int shifts[] = { 5, 10, 10, 10 };
 	int shift;
@@ -1303,21 +1349,21 @@ static void dispc_ovl_enable_replication
 		return;
 
 	shift = shifts[plane];
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable, shift, shift);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), enable, shift, shift);
 }
 
-static void dispc_mgr_set_size(enum omap_channel channel, u16 width,
-		u16 height)
+static void dispc_mgr_set_size(struct dispc_device *dispc,
+			       enum omap_channel channel, u16 width, u16 height)
 {
 	u32 val;
 
-	val = FLD_VAL(height - 1, dispc.feat->mgr_height_start, 16) |
-		FLD_VAL(width - 1, dispc.feat->mgr_width_start, 0);
+	val = FLD_VAL(height - 1, dispc->feat->mgr_height_start, 16) |
+		FLD_VAL(width - 1, dispc->feat->mgr_width_start, 0);
 
-	dispc_write_reg(DISPC_SIZE_MGR(channel), val);
+	dispc_write_reg(dispc, DISPC_SIZE_MGR(channel), val);
 }
 
-static void dispc_init_fifos(void)
+static void dispc_init_fifos(struct dispc_device *dispc)
 {
 	u32 size;
 	int fifo;
@@ -1325,20 +1371,21 @@ static void dispc_init_fifos(void)
 	u32 unit;
 	int i;
 
-	unit = dispc.feat->buffer_size_unit;
+	unit = dispc->feat->buffer_size_unit;
 
-	dispc_get_reg_field(FEAT_REG_FIFOSIZE, &start, &end);
+	dispc_get_reg_field(dispc, FEAT_REG_FIFOSIZE, &start, &end);
 
-	for (fifo = 0; fifo < dispc.feat->num_fifos; ++fifo) {
-		size = REG_GET(DISPC_OVL_FIFO_SIZE_STATUS(fifo), start, end);
+	for (fifo = 0; fifo < dispc->feat->num_fifos; ++fifo) {
+		size = REG_GET(dispc, DISPC_OVL_FIFO_SIZE_STATUS(fifo),
+			       start, end);
 		size *= unit;
-		dispc.fifo_size[fifo] = size;
+		dispc->fifo_size[fifo] = size;
 
 		/*
 		 * By default fifos are mapped directly to overlays, fifo 0 to
 		 * ovl 0, fifo 1 to ovl 1, etc.
 		 */
-		dispc.fifo_assignment[fifo] = fifo;
+		dispc->fifo_assignment[fifo] = fifo;
 	}
 
 	/*
@@ -1348,57 +1395,58 @@ static void dispc_init_fifos(void)
 	 * giving GFX plane a larger fifo. WB but should work fine with a
 	 * smaller fifo.
 	 */
-	if (dispc.feat->gfx_fifo_workaround) {
+	if (dispc->feat->gfx_fifo_workaround) {
 		u32 v;
 
-		v = dispc_read_reg(DISPC_GLOBAL_BUFFER);
+		v = dispc_read_reg(dispc, DISPC_GLOBAL_BUFFER);
 
 		v = FLD_MOD(v, 4, 2, 0); /* GFX BUF top to WB */
 		v = FLD_MOD(v, 4, 5, 3); /* GFX BUF bottom to WB */
 		v = FLD_MOD(v, 0, 26, 24); /* WB BUF top to GFX */
 		v = FLD_MOD(v, 0, 29, 27); /* WB BUF bottom to GFX */
 
-		dispc_write_reg(DISPC_GLOBAL_BUFFER, v);
+		dispc_write_reg(dispc, DISPC_GLOBAL_BUFFER, v);
 
-		dispc.fifo_assignment[OMAP_DSS_GFX] = OMAP_DSS_WB;
-		dispc.fifo_assignment[OMAP_DSS_WB] = OMAP_DSS_GFX;
+		dispc->fifo_assignment[OMAP_DSS_GFX] = OMAP_DSS_WB;
+		dispc->fifo_assignment[OMAP_DSS_WB] = OMAP_DSS_GFX;
 	}
 
 	/*
 	 * Setup default fifo thresholds.
 	 */
-	for (i = 0; i < dispc_get_num_ovls(&dispc); ++i) {
+	for (i = 0; i < dispc_get_num_ovls(dispc); ++i) {
 		u32 low, high;
 		const bool use_fifomerge = false;
 		const bool manual_update = false;
 
-		dispc_ovl_compute_fifo_thresholds(&dispc, i, &low, &high,
-			use_fifomerge, manual_update);
+		dispc_ovl_compute_fifo_thresholds(dispc, i, &low, &high,
+						  use_fifomerge, manual_update);
 
-		dispc_ovl_set_fifo_threshold(&dispc, i, low, high);
+		dispc_ovl_set_fifo_threshold(dispc, i, low, high);
 	}
 
-	if (dispc.feat->has_writeback) {
+	if (dispc->feat->has_writeback) {
 		u32 low, high;
 		const bool use_fifomerge = false;
 		const bool manual_update = false;
 
-		dispc_ovl_compute_fifo_thresholds(&dispc, OMAP_DSS_WB,
-						  &low, &high,
-						  use_fifomerge, manual_update);
+		dispc_ovl_compute_fifo_thresholds(dispc, OMAP_DSS_WB,
+						  &low, &high, use_fifomerge,
+						  manual_update);
 
-		dispc_ovl_set_fifo_threshold(&dispc, OMAP_DSS_WB, low, high);
+		dispc_ovl_set_fifo_threshold(dispc, OMAP_DSS_WB, low, high);
 	}
 }
 
-static u32 dispc_ovl_get_fifo_size(enum omap_plane_id plane)
+static u32 dispc_ovl_get_fifo_size(struct dispc_device *dispc,
+				   enum omap_plane_id plane)
 {
 	int fifo;
 	u32 size = 0;
 
-	for (fifo = 0; fifo < dispc.feat->num_fifos; ++fifo) {
-		if (dispc.fifo_assignment[fifo] == plane)
-			size += dispc.fifo_size[fifo];
+	for (fifo = 0; fifo < dispc->feat->num_fifos; ++fifo) {
+		if (dispc->fifo_assignment[fifo] == plane)
+			size += dispc->fifo_size[fifo];
 	}
 
 	return size;
@@ -1419,18 +1467,20 @@ void dispc_ovl_set_fifo_threshold(struct
 	low /= unit;
 	high /= unit;
 
-	dispc_get_reg_field(FEAT_REG_FIFOHIGHTHRESHOLD, &hi_start, &hi_end);
-	dispc_get_reg_field(FEAT_REG_FIFOLOWTHRESHOLD, &lo_start, &lo_end);
+	dispc_get_reg_field(dispc, FEAT_REG_FIFOHIGHTHRESHOLD,
+			    &hi_start, &hi_end);
+	dispc_get_reg_field(dispc, FEAT_REG_FIFOLOWTHRESHOLD,
+			    &lo_start, &lo_end);
 
 	DSSDBG("fifo(%d) threshold (bytes), old %u/%u, new %u/%u\n",
 			plane,
-			REG_GET(DISPC_OVL_FIFO_THRESHOLD(plane),
+			REG_GET(dispc, DISPC_OVL_FIFO_THRESHOLD(plane),
 				lo_start, lo_end) * unit,
-			REG_GET(DISPC_OVL_FIFO_THRESHOLD(plane),
+			REG_GET(dispc, DISPC_OVL_FIFO_THRESHOLD(plane),
 				hi_start, hi_end) * unit,
 			low * unit, high * unit);
 
-	dispc_write_reg(DISPC_OVL_FIFO_THRESHOLD(plane),
+	dispc_write_reg(dispc, DISPC_OVL_FIFO_THRESHOLD(plane),
 			FLD_VAL(high, hi_start, hi_end) |
 			FLD_VAL(low, lo_start, lo_end));
 
@@ -1439,20 +1489,21 @@ void dispc_ovl_set_fifo_threshold(struct
 	 * large for the preload field, set the threshold to the maximum value
 	 * that can be held by the preload register
 	 */
-	if (dispc_has_feature(FEAT_PRELOAD) && dispc->feat->set_max_preload &&
-			plane != OMAP_DSS_WB)
-		dispc_write_reg(DISPC_OVL_PRELOAD(plane), min(high, 0xfffu));
+	if (dispc_has_feature(dispc, FEAT_PRELOAD) &&
+	    dispc->feat->set_max_preload && plane != OMAP_DSS_WB)
+		dispc_write_reg(dispc, DISPC_OVL_PRELOAD(plane),
+				min(high, 0xfffu));
 }
 
 void dispc_enable_fifomerge(struct dispc_device *dispc, bool enable)
 {
-	if (!dispc_has_feature(FEAT_FIFO_MERGE)) {
+	if (!dispc_has_feature(dispc, FEAT_FIFO_MERGE)) {
 		WARN_ON(enable);
 		return;
 	}
 
 	DSSDBG("FIFO merge %s\n", enable ? "enabled" : "disabled");
-	REG_FLD_MOD(DISPC_CONFIG, enable ? 1 : 0, 14, 14);
+	REG_FLD_MOD(dispc, DISPC_CONFIG, enable ? 1 : 0, 14, 14);
 }
 
 void dispc_ovl_compute_fifo_thresholds(struct dispc_device *dispc,
@@ -1468,13 +1519,13 @@ void dispc_ovl_compute_fifo_thresholds(s
 	unsigned int ovl_fifo_size, total_fifo_size, burst_size;
 	int i;
 
-	burst_size = dispc_ovl_get_burst_size(plane);
-	ovl_fifo_size = dispc_ovl_get_fifo_size(plane);
+	burst_size = dispc_ovl_get_burst_size(dispc, plane);
+	ovl_fifo_size = dispc_ovl_get_fifo_size(dispc, plane);
 
 	if (use_fifomerge) {
 		total_fifo_size = 0;
 		for (i = 0; i < dispc_get_num_ovls(dispc); ++i)
-			total_fifo_size += dispc_ovl_get_fifo_size(i);
+			total_fifo_size += dispc_ovl_get_fifo_size(dispc, i);
 	} else {
 		total_fifo_size = ovl_fifo_size;
 	}
@@ -1485,7 +1536,7 @@ void dispc_ovl_compute_fifo_thresholds(s
 	 * combined fifo size
 	 */
 
-	if (manual_update && dispc_has_feature(FEAT_OMAP3_DSI_FIFO_BUG)) {
+	if (manual_update && dispc_has_feature(dispc, FEAT_OMAP3_DSI_FIFO_BUG)) {
 		*fifo_low = ovl_fifo_size - burst_size * 2;
 		*fifo_high = total_fifo_size - burst_size;
 	} else if (plane == OMAP_DSS_WB) {
@@ -1502,7 +1553,8 @@ void dispc_ovl_compute_fifo_thresholds(s
 	}
 }
 
-static void dispc_ovl_set_mflag(enum omap_plane_id plane, bool enable)
+static void dispc_ovl_set_mflag(struct dispc_device *dispc,
+				enum omap_plane_id plane, bool enable)
 {
 	int bit;
 
@@ -1511,17 +1563,18 @@ static void dispc_ovl_set_mflag(enum oma
 	else
 		bit = 23;
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable, bit, bit);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), enable, bit, bit);
 }
 
-static void dispc_ovl_set_mflag_threshold(enum omap_plane_id plane,
-	int low, int high)
+static void dispc_ovl_set_mflag_threshold(struct dispc_device *dispc,
+					  enum omap_plane_id plane,
+					  int low, int high)
 {
-	dispc_write_reg(DISPC_OVL_MFLAG_THRESHOLD(plane),
+	dispc_write_reg(dispc, DISPC_OVL_MFLAG_THRESHOLD(plane),
 		FLD_VAL(high, 31, 16) |	FLD_VAL(low, 15, 0));
 }
 
-static void dispc_init_mflag(void)
+static void dispc_init_mflag(struct dispc_device *dispc)
 {
 	int i;
 
@@ -1535,16 +1588,16 @@ static void dispc_init_mflag(void)
 	 *
 	 * As a work-around, set force MFLAG to always on.
 	 */
-	dispc_write_reg(DISPC_GLOBAL_MFLAG_ATTRIBUTE,
+	dispc_write_reg(dispc, DISPC_GLOBAL_MFLAG_ATTRIBUTE,
 		(1 << 0) |	/* MFLAG_CTRL = force always on */
 		(0 << 2));	/* MFLAG_START = disable */
 
-	for (i = 0; i < dispc_get_num_ovls(&dispc); ++i) {
-		u32 size = dispc_ovl_get_fifo_size(i);
-		u32 unit = dispc.feat->buffer_size_unit;
+	for (i = 0; i < dispc_get_num_ovls(dispc); ++i) {
+		u32 size = dispc_ovl_get_fifo_size(dispc, i);
+		u32 unit = dispc->feat->buffer_size_unit;
 		u32 low, high;
 
-		dispc_ovl_set_mflag(i, true);
+		dispc_ovl_set_mflag(dispc, i, true);
 
 		/*
 		 * Simulation team suggests below thesholds:
@@ -1555,15 +1608,15 @@ static void dispc_init_mflag(void)
 		low = size * 4 / 8 / unit;
 		high = size * 5 / 8 / unit;
 
-		dispc_ovl_set_mflag_threshold(i, low, high);
+		dispc_ovl_set_mflag_threshold(dispc, i, low, high);
 	}
 
-	if (dispc.feat->has_writeback) {
-		u32 size = dispc_ovl_get_fifo_size(OMAP_DSS_WB);
-		u32 unit = dispc.feat->buffer_size_unit;
+	if (dispc->feat->has_writeback) {
+		u32 size = dispc_ovl_get_fifo_size(dispc, OMAP_DSS_WB);
+		u32 unit = dispc->feat->buffer_size_unit;
 		u32 low, high;
 
-		dispc_ovl_set_mflag(OMAP_DSS_WB, true);
+		dispc_ovl_set_mflag(dispc, OMAP_DSS_WB, true);
 
 		/*
 		 * Simulation team suggests below thesholds:
@@ -1574,98 +1627,112 @@ static void dispc_init_mflag(void)
 		low = size * 4 / 8 / unit;
 		high = size * 5 / 8 / unit;
 
-		dispc_ovl_set_mflag_threshold(OMAP_DSS_WB, low, high);
+		dispc_ovl_set_mflag_threshold(dispc, OMAP_DSS_WB, low, high);
 	}
 }
 
-static void dispc_ovl_set_fir(enum omap_plane_id plane,
-				int hinc, int vinc,
-				enum omap_color_component color_comp)
+static void dispc_ovl_set_fir(struct dispc_device *dispc,
+			      enum omap_plane_id plane,
+			      int hinc, int vinc,
+			      enum omap_color_component color_comp)
 {
 	u32 val;
 
 	if (color_comp == DISPC_COLOR_COMPONENT_RGB_Y) {
 		u8 hinc_start, hinc_end, vinc_start, vinc_end;
 
-		dispc_get_reg_field(FEAT_REG_FIRHINC, &hinc_start, &hinc_end);
-		dispc_get_reg_field(FEAT_REG_FIRVINC, &vinc_start, &vinc_end);
+		dispc_get_reg_field(dispc, FEAT_REG_FIRHINC,
+				    &hinc_start, &hinc_end);
+		dispc_get_reg_field(dispc, FEAT_REG_FIRVINC,
+				    &vinc_start, &vinc_end);
 		val = FLD_VAL(vinc, vinc_start, vinc_end) |
 				FLD_VAL(hinc, hinc_start, hinc_end);
 
-		dispc_write_reg(DISPC_OVL_FIR(plane), val);
+		dispc_write_reg(dispc, DISPC_OVL_FIR(plane), val);
 	} else {
 		val = FLD_VAL(vinc, 28, 16) | FLD_VAL(hinc, 12, 0);
-		dispc_write_reg(DISPC_OVL_FIR2(plane), val);
+		dispc_write_reg(dispc, DISPC_OVL_FIR2(plane), val);
 	}
 }
 
-static void dispc_ovl_set_vid_accu0(enum omap_plane_id plane, int haccu,
+static void dispc_ovl_set_vid_accu0(struct dispc_device *dispc,
+				    enum omap_plane_id plane, int haccu,
 				    int vaccu)
 {
 	u32 val;
 	u8 hor_start, hor_end, vert_start, vert_end;
 
-	dispc_get_reg_field(FEAT_REG_HORIZONTALACCU, &hor_start, &hor_end);
-	dispc_get_reg_field(FEAT_REG_VERTICALACCU, &vert_start, &vert_end);
+	dispc_get_reg_field(dispc, FEAT_REG_HORIZONTALACCU,
+			    &hor_start, &hor_end);
+	dispc_get_reg_field(dispc, FEAT_REG_VERTICALACCU,
+			    &vert_start, &vert_end);
 
 	val = FLD_VAL(vaccu, vert_start, vert_end) |
 			FLD_VAL(haccu, hor_start, hor_end);
 
-	dispc_write_reg(DISPC_OVL_ACCU0(plane), val);
+	dispc_write_reg(dispc, DISPC_OVL_ACCU0(plane), val);
 }
 
-static void dispc_ovl_set_vid_accu1(enum omap_plane_id plane, int haccu,
+static void dispc_ovl_set_vid_accu1(struct dispc_device *dispc,
+				    enum omap_plane_id plane, int haccu,
 				    int vaccu)
 {
 	u32 val;
 	u8 hor_start, hor_end, vert_start, vert_end;
 
-	dispc_get_reg_field(FEAT_REG_HORIZONTALACCU, &hor_start, &hor_end);
-	dispc_get_reg_field(FEAT_REG_VERTICALACCU, &vert_start, &vert_end);
+	dispc_get_reg_field(dispc, FEAT_REG_HORIZONTALACCU,
+			    &hor_start, &hor_end);
+	dispc_get_reg_field(dispc, FEAT_REG_VERTICALACCU,
+			    &vert_start, &vert_end);
 
 	val = FLD_VAL(vaccu, vert_start, vert_end) |
 			FLD_VAL(haccu, hor_start, hor_end);
 
-	dispc_write_reg(DISPC_OVL_ACCU1(plane), val);
+	dispc_write_reg(dispc, DISPC_OVL_ACCU1(plane), val);
 }
 
-static void dispc_ovl_set_vid_accu2_0(enum omap_plane_id plane, int haccu,
-		int vaccu)
+static void dispc_ovl_set_vid_accu2_0(struct dispc_device *dispc,
+				      enum omap_plane_id plane, int haccu,
+				      int vaccu)
 {
 	u32 val;
 
 	val = FLD_VAL(vaccu, 26, 16) | FLD_VAL(haccu, 10, 0);
-	dispc_write_reg(DISPC_OVL_ACCU2_0(plane), val);
+	dispc_write_reg(dispc, DISPC_OVL_ACCU2_0(plane), val);
 }
 
-static void dispc_ovl_set_vid_accu2_1(enum omap_plane_id plane, int haccu,
-		int vaccu)
+static void dispc_ovl_set_vid_accu2_1(struct dispc_device *dispc,
+				      enum omap_plane_id plane, int haccu,
+				      int vaccu)
 {
 	u32 val;
 
 	val = FLD_VAL(vaccu, 26, 16) | FLD_VAL(haccu, 10, 0);
-	dispc_write_reg(DISPC_OVL_ACCU2_1(plane), val);
+	dispc_write_reg(dispc, DISPC_OVL_ACCU2_1(plane), val);
 }
 
-static void dispc_ovl_set_scale_param(enum omap_plane_id plane,
-		u16 orig_width, u16 orig_height,
-		u16 out_width, u16 out_height,
-		bool five_taps, u8 rotation,
-		enum omap_color_component color_comp)
+static void dispc_ovl_set_scale_param(struct dispc_device *dispc,
+				      enum omap_plane_id plane,
+				      u16 orig_width, u16 orig_height,
+				      u16 out_width, u16 out_height,
+				      bool five_taps, u8 rotation,
+				      enum omap_color_component color_comp)
 {
 	int fir_hinc, fir_vinc;
 
 	fir_hinc = 1024 * orig_width / out_width;
 	fir_vinc = 1024 * orig_height / out_height;
 
-	dispc_ovl_set_scale_coef(plane, fir_hinc, fir_vinc, five_taps,
-				color_comp);
-	dispc_ovl_set_fir(plane, fir_hinc, fir_vinc, color_comp);
+	dispc_ovl_set_scale_coef(dispc, plane, fir_hinc, fir_vinc, five_taps,
+				 color_comp);
+	dispc_ovl_set_fir(dispc, plane, fir_hinc, fir_vinc, color_comp);
 }
 
-static void dispc_ovl_set_accu_uv(enum omap_plane_id plane,
-		u16 orig_width,	u16 orig_height, u16 out_width, u16 out_height,
-		bool ilace, u32 fourcc, u8 rotation)
+static void dispc_ovl_set_accu_uv(struct dispc_device *dispc,
+				  enum omap_plane_id plane,
+				  u16 orig_width, u16 orig_height,
+				  u16 out_width, u16 out_height,
+				  bool ilace, u32 fourcc, u8 rotation)
 {
 	int h_accu2_0, h_accu2_1;
 	int v_accu2_0, v_accu2_1;
@@ -1746,25 +1813,26 @@ static void dispc_ovl_set_accu_uv(enum o
 	v_accu2_0 = (accu_val->v0_m * chroma_vinc / accu_val->v0_n) % 1024;
 	v_accu2_1 = (accu_val->v1_m * chroma_vinc / accu_val->v1_n) % 1024;
 
-	dispc_ovl_set_vid_accu2_0(plane, h_accu2_0, v_accu2_0);
-	dispc_ovl_set_vid_accu2_1(plane, h_accu2_1, v_accu2_1);
+	dispc_ovl_set_vid_accu2_0(dispc, plane, h_accu2_0, v_accu2_0);
+	dispc_ovl_set_vid_accu2_1(dispc, plane, h_accu2_1, v_accu2_1);
 }
 
-static void dispc_ovl_set_scaling_common(enum omap_plane_id plane,
-		u16 orig_width, u16 orig_height,
-		u16 out_width, u16 out_height,
-		bool ilace, bool five_taps,
-		bool fieldmode, u32 fourcc,
-		u8 rotation)
+static void dispc_ovl_set_scaling_common(struct dispc_device *dispc,
+					 enum omap_plane_id plane,
+					 u16 orig_width, u16 orig_height,
+					 u16 out_width, u16 out_height,
+					 bool ilace, bool five_taps,
+					 bool fieldmode, u32 fourcc,
+					 u8 rotation)
 {
 	int accu0 = 0;
 	int accu1 = 0;
 	u32 l;
 
-	dispc_ovl_set_scale_param(plane, orig_width, orig_height,
-				out_width, out_height, five_taps,
-				rotation, DISPC_COLOR_COMPONENT_RGB_Y);
-	l = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
+	dispc_ovl_set_scale_param(dispc, plane, orig_width, orig_height,
+				  out_width, out_height, five_taps,
+				  rotation, DISPC_COLOR_COMPONENT_RGB_Y);
+	l = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));
 
 	/* RESIZEENABLE and VERTICALTAPS */
 	l &= ~((0x3 << 5) | (0x1 << 21));
@@ -1773,19 +1841,19 @@ static void dispc_ovl_set_scaling_common
 	l |= five_taps ? (1 << 21) : 0;
 
 	/* VRESIZECONF and HRESIZECONF */
-	if (dispc_has_feature(FEAT_RESIZECONF)) {
+	if (dispc_has_feature(dispc, FEAT_RESIZECONF)) {
 		l &= ~(0x3 << 7);
 		l |= (orig_width <= out_width) ? 0 : (1 << 7);
 		l |= (orig_height <= out_height) ? 0 : (1 << 8);
 	}
 
 	/* LINEBUFFERSPLIT */
-	if (dispc_has_feature(FEAT_LINEBUFFERSPLIT)) {
+	if (dispc_has_feature(dispc, FEAT_LINEBUFFERSPLIT)) {
 		l &= ~(0x1 << 22);
 		l |= five_taps ? (1 << 22) : 0;
 	}
 
-	dispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), l);
+	dispc_write_reg(dispc, DISPC_OVL_ATTRIBUTES(plane), l);
 
 	/*
 	 * field 0 = even field = bottom field
@@ -1800,33 +1868,35 @@ static void dispc_ovl_set_scaling_common
 		}
 	}
 
-	dispc_ovl_set_vid_accu0(plane, 0, accu0);
-	dispc_ovl_set_vid_accu1(plane, 0, accu1);
+	dispc_ovl_set_vid_accu0(dispc, plane, 0, accu0);
+	dispc_ovl_set_vid_accu1(dispc, plane, 0, accu1);
 }
 
-static void dispc_ovl_set_scaling_uv(enum omap_plane_id plane,
-		u16 orig_width, u16 orig_height,
-		u16 out_width, u16 out_height,
-		bool ilace, bool five_taps,
-		bool fieldmode, u32 fourcc,
-		u8 rotation)
+static void dispc_ovl_set_scaling_uv(struct dispc_device *dispc,
+				     enum omap_plane_id plane,
+				     u16 orig_width, u16 orig_height,
+				     u16 out_width, u16 out_height,
+				     bool ilace, bool five_taps,
+				     bool fieldmode, u32 fourcc,
+				     u8 rotation)
 {
 	int scale_x = out_width != orig_width;
 	int scale_y = out_height != orig_height;
 	bool chroma_upscale = plane != OMAP_DSS_WB;
 
-	if (!dispc_has_feature(FEAT_HANDLE_UV_SEPARATE))
+	if (!dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE))
 		return;
 
 	if (!format_is_yuv(fourcc)) {
 		/* reset chroma resampling for RGB formats  */
 		if (plane != OMAP_DSS_WB)
-			REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), 0, 8, 8);
+			REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane),
+				    0, 8, 8);
 		return;
 	}
 
-	dispc_ovl_set_accu_uv(plane, orig_width, orig_height, out_width,
-			out_height, ilace, fourcc, rotation);
+	dispc_ovl_set_accu_uv(dispc, plane, orig_width, orig_height, out_width,
+			      out_height, ilace, fourcc, rotation);
 
 	switch (fourcc) {
 	case DRM_FORMAT_NV12:
@@ -1868,46 +1938,43 @@ static void dispc_ovl_set_scaling_uv(enu
 	if (out_height != orig_height)
 		scale_y = true;
 
-	dispc_ovl_set_scale_param(plane, orig_width, orig_height,
-			out_width, out_height, five_taps,
-				rotation, DISPC_COLOR_COMPONENT_UV);
+	dispc_ovl_set_scale_param(dispc, plane, orig_width, orig_height,
+				  out_width, out_height, five_taps,
+				  rotation, DISPC_COLOR_COMPONENT_UV);
 
 	if (plane != OMAP_DSS_WB)
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane),
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane),
 			(scale_x || scale_y) ? 1 : 0, 8, 8);
 
 	/* set H scaling */
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), scale_x ? 1 : 0, 5, 5);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), scale_x ? 1 : 0, 5, 5);
 	/* set V scaling */
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), scale_y ? 1 : 0, 6, 6);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), scale_y ? 1 : 0, 6, 6);
 }
 
-static void dispc_ovl_set_scaling(enum omap_plane_id plane,
-		u16 orig_width, u16 orig_height,
-		u16 out_width, u16 out_height,
-		bool ilace, bool five_taps,
-		bool fieldmode, u32 fourcc,
-		u8 rotation)
+static void dispc_ovl_set_scaling(struct dispc_device *dispc,
+				  enum omap_plane_id plane,
+				  u16 orig_width, u16 orig_height,
+				  u16 out_width, u16 out_height,
+				  bool ilace, bool five_taps,
+				  bool fieldmode, u32 fourcc,
+				  u8 rotation)
 {
 	BUG_ON(plane == OMAP_DSS_GFX);
 
-	dispc_ovl_set_scaling_common(plane,
-			orig_width, orig_height,
-			out_width, out_height,
-			ilace, five_taps,
-			fieldmode, fourcc,
-			rotation);
-
-	dispc_ovl_set_scaling_uv(plane,
-		orig_width, orig_height,
-		out_width, out_height,
-		ilace, five_taps,
-		fieldmode, fourcc,
-		rotation);
+	dispc_ovl_set_scaling_common(dispc, plane, orig_width, orig_height,
+				     out_width, out_height, ilace, five_taps,
+				     fieldmode, fourcc, rotation);
+
+	dispc_ovl_set_scaling_uv(dispc, plane, orig_width, orig_height,
+				 out_width, out_height, ilace, five_taps,
+				 fieldmode, fourcc, rotation);
 }
 
-static void dispc_ovl_set_rotation_attrs(enum omap_plane_id plane, u8 rotation,
-		enum omap_dss_rotation_type rotation_type, u32 fourcc)
+static void dispc_ovl_set_rotation_attrs(struct dispc_device *dispc,
+					 enum omap_plane_id plane, u8 rotation,
+					 enum omap_dss_rotation_type rotation_type,
+					 u32 fourcc)
 {
 	bool row_repeat = false;
 	int vidrot = 0;
@@ -1961,19 +2028,20 @@ static void dispc_ovl_set_rotation_attrs
 	if (fourcc == DRM_FORMAT_NV12 && rotation_type != OMAP_DSS_ROT_TILER)
 		vidrot = 1;
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), vidrot, 13, 12);
-	if (dispc_has_feature(FEAT_ROWREPEATENABLE))
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane),
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), vidrot, 13, 12);
+	if (dispc_has_feature(dispc, FEAT_ROWREPEATENABLE))
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane),
 			row_repeat ? 1 : 0, 18, 18);
 
-	if (dispc_ovl_color_mode_supported(plane, DRM_FORMAT_NV12)) {
+	if (dispc_ovl_color_mode_supported(dispc, plane, DRM_FORMAT_NV12)) {
 		bool doublestride =
 			fourcc == DRM_FORMAT_NV12 &&
 			rotation_type == OMAP_DSS_ROT_TILER &&
 			!drm_rotation_90_or_270(rotation);
 
 		/* DOUBLESTRIDE */
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), doublestride, 22, 22);
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane),
+			    doublestride, 22, 22);
 	}
 }
 
@@ -2210,27 +2278,31 @@ static unsigned long calc_core_clk_44xx(
 		return pclk;
 }
 
-static int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,
-		const struct videomode *vm,
-		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 fourcc, bool *five_taps,
-		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
-		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
+static int dispc_ovl_calc_scaling_24xx(struct dispc_device *dispc,
+				       unsigned long pclk, unsigned long lclk,
+				       const struct videomode *vm,
+				       u16 width, u16 height,
+				       u16 out_width, u16 out_height,
+				       u32 fourcc, bool *five_taps,
+				       int *x_predecim, int *y_predecim,
+				       int *decim_x, int *decim_y,
+				       u16 pos_x, unsigned long *core_clk,
+				       bool mem_to_mem)
 {
 	int error;
 	u16 in_width, in_height;
 	int min_factor = min(*decim_x, *decim_y);
-	const int maxsinglelinewidth = dispc.feat->max_line_width;
+	const int maxsinglelinewidth = dispc->feat->max_line_width;
 
 	*five_taps = false;
 
 	do {
 		in_height = height / *decim_y;
 		in_width = width / *decim_x;
-		*core_clk = dispc.feat->calc_core_clk(pclk, in_width,
+		*core_clk = dispc->feat->calc_core_clk(pclk, in_width,
 				in_height, out_width, out_height, mem_to_mem);
 		error = (in_width > maxsinglelinewidth || !*core_clk ||
-			*core_clk > dispc_core_clk_rate());
+			*core_clk > dispc_core_clk_rate(dispc));
 		if (error) {
 			if (*decim_x == *decim_y) {
 				*decim_x = min_factor;
@@ -2255,16 +2327,20 @@ static int dispc_ovl_calc_scaling_24xx(u
 	return 0;
 }
 
-static int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,
-		const struct videomode *vm,
-		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 fourcc, bool *five_taps,
-		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
-		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
+static int dispc_ovl_calc_scaling_34xx(struct dispc_device *dispc,
+				       unsigned long pclk, unsigned long lclk,
+				       const struct videomode *vm,
+				       u16 width, u16 height,
+				       u16 out_width, u16 out_height,
+				       u32 fourcc, bool *five_taps,
+				       int *x_predecim, int *y_predecim,
+				       int *decim_x, int *decim_y,
+				       u16 pos_x, unsigned long *core_clk,
+				       bool mem_to_mem)
 {
 	int error;
 	u16 in_width, in_height;
-	const int maxsinglelinewidth = dispc.feat->max_line_width;
+	const int maxsinglelinewidth = dispc->feat->max_line_width;
 
 	do {
 		in_height = height / *decim_y;
@@ -2281,7 +2357,7 @@ again:
 						in_width, in_height, out_width,
 						out_height, fourcc);
 		else
-			*core_clk = dispc.feat->calc_core_clk(pclk, in_width,
+			*core_clk = dispc->feat->calc_core_clk(pclk, in_width,
 					in_height, out_width, out_height,
 					mem_to_mem);
 
@@ -2295,7 +2371,7 @@ again:
 
 		error = (error || in_width > maxsinglelinewidth * 2 ||
 			(in_width > maxsinglelinewidth && *five_taps) ||
-			!*core_clk || *core_clk > dispc_core_clk_rate());
+			!*core_clk || *core_clk > dispc_core_clk_rate(dispc));
 
 		if (!error) {
 			/* verify that we're inside the limits of scaler */
@@ -2339,24 +2415,28 @@ again:
 	return 0;
 }
 
-static int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,
-		const struct videomode *vm,
-		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 fourcc, bool *five_taps,
-		int *x_predecim, int *y_predecim, int *decim_x, int *decim_y,
-		u16 pos_x, unsigned long *core_clk, bool mem_to_mem)
+static int dispc_ovl_calc_scaling_44xx(struct dispc_device *dispc,
+				       unsigned long pclk, unsigned long lclk,
+				       const struct videomode *vm,
+				       u16 width, u16 height,
+				       u16 out_width, u16 out_height,
+				       u32 fourcc, bool *five_taps,
+				       int *x_predecim, int *y_predecim,
+				       int *decim_x, int *decim_y,
+				       u16 pos_x, unsigned long *core_clk,
+				       bool mem_to_mem)
 {
 	u16 in_width, in_width_max;
 	int decim_x_min = *decim_x;
 	u16 in_height = height / *decim_y;
-	const int maxsinglelinewidth = dispc.feat->max_line_width;
-	const int maxdownscale = dispc.feat->max_downscale;
+	const int maxsinglelinewidth = dispc->feat->max_line_width;
+	const int maxdownscale = dispc->feat->max_downscale;
 
 	if (mem_to_mem) {
 		in_width_max = out_width * maxdownscale;
 	} else {
-		in_width_max = dispc_core_clk_rate() /
-					DIV_ROUND_UP(pclk, out_width);
+		in_width_max = dispc_core_clk_rate(dispc)
+			     / DIV_ROUND_UP(pclk, out_width);
 	}
 
 	*decim_x = DIV_ROUND_UP(width, in_width_max);
@@ -2394,7 +2474,7 @@ static int dispc_ovl_calc_scaling_44xx(u
 		return -EINVAL;
 	}
 
-	*core_clk = dispc.feat->calc_core_clk(pclk, in_width, in_height,
+	*core_clk = dispc->feat->calc_core_clk(pclk, in_width, in_height,
 				out_width, out_height, mem_to_mem);
 	return 0;
 }
@@ -2402,15 +2482,18 @@ static int dispc_ovl_calc_scaling_44xx(u
 #define DIV_FRAC(dividend, divisor) \
 	((dividend) * 100 / (divisor) - ((dividend) / (divisor) * 100))
 
-static int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,
-		enum omap_overlay_caps caps,
-		const struct videomode *vm,
-		u16 width, u16 height, u16 out_width, u16 out_height,
-		u32 fourcc, bool *five_taps,
-		int *x_predecim, int *y_predecim, u16 pos_x,
-		enum omap_dss_rotation_type rotation_type, bool mem_to_mem)
+static int dispc_ovl_calc_scaling(struct dispc_device *dispc,
+				  unsigned long pclk, unsigned long lclk,
+				  enum omap_overlay_caps caps,
+				  const struct videomode *vm,
+				  u16 width, u16 height,
+				  u16 out_width, u16 out_height,
+				  u32 fourcc, bool *five_taps,
+				  int *x_predecim, int *y_predecim, u16 pos_x,
+				  enum omap_dss_rotation_type rotation_type,
+				  bool mem_to_mem)
 {
-	const int maxdownscale = dispc.feat->max_downscale;
+	const int maxdownscale = dispc->feat->max_downscale;
 	const int max_decim_limit = 16;
 	unsigned long core_clk = 0;
 	int decim_x, decim_y, ret;
@@ -2431,7 +2514,7 @@ static int dispc_ovl_calc_scaling(unsign
 	} else {
 		*x_predecim = max_decim_limit;
 		*y_predecim = (rotation_type == OMAP_DSS_ROT_TILER &&
-				dispc_has_feature(FEAT_BURST_2D)) ?
+				dispc_has_feature(dispc, FEAT_BURST_2D)) ?
 				2 : max_decim_limit;
 	}
 
@@ -2444,10 +2527,11 @@ static int dispc_ovl_calc_scaling(unsign
 	if (decim_y > *y_predecim || out_height > height * 8)
 		return -EINVAL;
 
-	ret = dispc.feat->calc_scaling(pclk, lclk, vm, width, height,
-		out_width, out_height, fourcc, five_taps,
-		x_predecim, y_predecim, &decim_x, &decim_y, pos_x, &core_clk,
-		mem_to_mem);
+	ret = dispc->feat->calc_scaling(dispc, pclk, lclk, vm, width, height,
+					out_width, out_height, fourcc,
+					five_taps, x_predecim, y_predecim,
+					&decim_x, &decim_y, pos_x, &core_clk,
+					mem_to_mem);
 	if (ret)
 		return ret;
 
@@ -2463,13 +2547,13 @@ static int dispc_ovl_calc_scaling(unsign
 		out_height / (height / decim_y), DIV_FRAC(out_height, height / decim_y),
 
 		*five_taps ? 5 : 3,
-		core_clk, dispc_core_clk_rate());
+		core_clk, dispc_core_clk_rate(dispc));
 
-	if (!core_clk || core_clk > dispc_core_clk_rate()) {
+	if (!core_clk || core_clk > dispc_core_clk_rate(dispc)) {
 		DSSERR("failed to set up scaling, "
 			"required core clk rate = %lu Hz, "
 			"current core clk rate = %lu Hz\n",
-			core_clk, dispc_core_clk_rate());
+			core_clk, dispc_core_clk_rate(dispc));
 		return -EINVAL;
 	}
 
@@ -2478,14 +2562,18 @@ static int dispc_ovl_calc_scaling(unsign
 	return 0;
 }
 
-static int dispc_ovl_setup_common(enum omap_plane_id plane,
-		enum omap_overlay_caps caps, u32 paddr, u32 p_uv_addr,
-		u16 screen_width, int pos_x, int pos_y, u16 width, u16 height,
-		u16 out_width, u16 out_height, u32 fourcc,
-		u8 rotation, u8 zorder, u8 pre_mult_alpha,
-		u8 global_alpha, enum omap_dss_rotation_type rotation_type,
-		bool replication, const struct videomode *vm,
-		bool mem_to_mem)
+static int dispc_ovl_setup_common(struct dispc_device *dispc,
+				  enum omap_plane_id plane,
+				  enum omap_overlay_caps caps,
+				  u32 paddr, u32 p_uv_addr,
+				  u16 screen_width, int pos_x, int pos_y,
+				  u16 width, u16 height,
+				  u16 out_width, u16 out_height,
+				  u32 fourcc, u8 rotation, u8 zorder,
+				  u8 pre_mult_alpha, u8 global_alpha,
+				  enum omap_dss_rotation_type rotation_type,
+				  bool replication, const struct videomode *vm,
+				  bool mem_to_mem)
 {
 	bool five_taps = true;
 	bool fieldmode = false;
@@ -2499,8 +2587,8 @@ static int dispc_ovl_setup_common(enum o
 	u16 in_width = width;
 	int x_predecim = 1, y_predecim = 1;
 	bool ilace = !!(vm->flags & DISPLAY_FLAGS_INTERLACED);
-	unsigned long pclk = dispc_plane_pclk_rate(plane);
-	unsigned long lclk = dispc_plane_lclk_rate(plane);
+	unsigned long pclk = dispc_plane_pclk_rate(dispc, plane);
+	unsigned long lclk = dispc_plane_lclk_rate(dispc, plane);
 
 	if (paddr == 0 && rotation_type != OMAP_DSS_ROT_TILER)
 		return -EINVAL;
@@ -2527,13 +2615,13 @@ static int dispc_ovl_setup_common(enum o
 			out_height);
 	}
 
-	if (!dispc_ovl_color_mode_supported(plane, fourcc))
+	if (!dispc_ovl_color_mode_supported(dispc, plane, fourcc))
 		return -EINVAL;
 
-	r = dispc_ovl_calc_scaling(pclk, lclk, caps, vm, in_width,
-			in_height, out_width, out_height, fourcc,
-			&five_taps, &x_predecim, &y_predecim, pos_x,
-			rotation_type, mem_to_mem);
+	r = dispc_ovl_calc_scaling(dispc, pclk, lclk, caps, vm, in_width,
+				   in_height, out_width, out_height, fourcc,
+				   &five_taps, &x_predecim, &y_predecim, pos_x,
+				   rotation_type, mem_to_mem);
 	if (r)
 		return r;
 
@@ -2595,49 +2683,50 @@ static int dispc_ovl_setup_common(enum o
 	DSSDBG("offset0 %u, offset1 %u, row_inc %d, pix_inc %d\n",
 			offset0, offset1, row_inc, pix_inc);
 
-	dispc_ovl_set_color_mode(plane, fourcc);
+	dispc_ovl_set_color_mode(dispc, plane, fourcc);
 
-	dispc_ovl_configure_burst_type(plane, rotation_type);
+	dispc_ovl_configure_burst_type(dispc, plane, rotation_type);
 
-	if (dispc.feat->reverse_ilace_field_order)
+	if (dispc->feat->reverse_ilace_field_order)
 		swap(offset0, offset1);
 
-	dispc_ovl_set_ba0(plane, paddr + offset0);
-	dispc_ovl_set_ba1(plane, paddr + offset1);
+	dispc_ovl_set_ba0(dispc, plane, paddr + offset0);
+	dispc_ovl_set_ba1(dispc, plane, paddr + offset1);
 
 	if (fourcc == DRM_FORMAT_NV12) {
-		dispc_ovl_set_ba0_uv(plane, p_uv_addr + offset0);
-		dispc_ovl_set_ba1_uv(plane, p_uv_addr + offset1);
+		dispc_ovl_set_ba0_uv(dispc, plane, p_uv_addr + offset0);
+		dispc_ovl_set_ba1_uv(dispc, plane, p_uv_addr + offset1);
 	}
 
-	if (dispc.feat->last_pixel_inc_missing)
+	if (dispc->feat->last_pixel_inc_missing)
 		row_inc += pix_inc - 1;
 
-	dispc_ovl_set_row_inc(plane, row_inc);
-	dispc_ovl_set_pix_inc(plane, pix_inc);
+	dispc_ovl_set_row_inc(dispc, plane, row_inc);
+	dispc_ovl_set_pix_inc(dispc, plane, pix_inc);
 
 	DSSDBG("%d,%d %dx%d -> %dx%d\n", pos_x, pos_y, in_width,
 			in_height, out_width, out_height);
 
-	dispc_ovl_set_pos(plane, caps, pos_x, pos_y);
+	dispc_ovl_set_pos(dispc, plane, caps, pos_x, pos_y);
 
-	dispc_ovl_set_input_size(plane, in_width, in_height);
+	dispc_ovl_set_input_size(dispc, plane, in_width, in_height);
 
 	if (caps & OMAP_DSS_OVL_CAP_SCALE) {
-		dispc_ovl_set_scaling(plane, in_width, in_height, out_width,
-				   out_height, ilace, five_taps, fieldmode,
-				   fourcc, rotation);
-		dispc_ovl_set_output_size(plane, out_width, out_height);
-		dispc_ovl_set_vid_color_conv(plane, cconv);
+		dispc_ovl_set_scaling(dispc, plane, in_width, in_height,
+				      out_width, out_height, ilace, five_taps,
+				      fieldmode, fourcc, rotation);
+		dispc_ovl_set_output_size(dispc, plane, out_width, out_height);
+		dispc_ovl_set_vid_color_conv(dispc, plane, cconv);
 	}
 
-	dispc_ovl_set_rotation_attrs(plane, rotation, rotation_type, fourcc);
+	dispc_ovl_set_rotation_attrs(dispc, plane, rotation, rotation_type,
+				     fourcc);
 
-	dispc_ovl_set_zorder(plane, caps, zorder);
-	dispc_ovl_set_pre_mult_alpha(plane, caps, pre_mult_alpha);
-	dispc_ovl_setup_global_alpha(plane, caps, global_alpha);
+	dispc_ovl_set_zorder(dispc, plane, caps, zorder);
+	dispc_ovl_set_pre_mult_alpha(dispc, plane, caps, pre_mult_alpha);
+	dispc_ovl_setup_global_alpha(dispc, plane, caps, global_alpha);
 
-	dispc_ovl_enable_replication(plane, caps, replication);
+	dispc_ovl_enable_replication(dispc, plane, caps, replication);
 
 	return 0;
 }
@@ -2658,9 +2747,9 @@ static int dispc_ovl_setup(struct dispc_
 		oi->pos_y, oi->width, oi->height, oi->out_width, oi->out_height,
 		oi->fourcc, oi->rotation, channel, replication);
 
-	dispc_ovl_set_channel_out(plane, channel);
+	dispc_ovl_set_channel_out(dispc, plane, channel);
 
-	r = dispc_ovl_setup_common(plane, caps, oi->paddr, oi->p_uv_addr,
+	r = dispc_ovl_setup_common(dispc, plane, caps, oi->paddr, oi->p_uv_addr,
 		oi->screen_width, oi->pos_x, oi->pos_y, oi->width, oi->height,
 		oi->out_width, oi->out_height, oi->fourcc, oi->rotation,
 		oi->zorder, oi->pre_mult_alpha, oi->global_alpha,
@@ -2689,7 +2778,7 @@ int dispc_wb_setup(struct dispc_device *
 		"rot %d\n", wi->paddr, wi->p_uv_addr, in_width,
 		in_height, wi->width, wi->height, wi->fourcc, wi->rotation);
 
-	r = dispc_ovl_setup_common(plane, caps, wi->paddr, wi->p_uv_addr,
+	r = dispc_ovl_setup_common(dispc, plane, caps, wi->paddr, wi->p_uv_addr,
 		wi->buf_width, pos_x, pos_y, in_width, in_height, wi->width,
 		wi->height, wi->fourcc, wi->rotation, zorder,
 		wi->pre_mult_alpha, global_alpha, wi->rotation_type,
@@ -2712,18 +2801,18 @@ int dispc_wb_setup(struct dispc_device *
 	}
 
 	/* setup extra DISPC_WB_ATTRIBUTES */
-	l = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));
+	l = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));
 	l = FLD_MOD(l, truncation, 10, 10);	/* TRUNCATIONENABLE */
 	l = FLD_MOD(l, mem_to_mem, 19, 19);	/* WRITEBACKMODE */
 	if (mem_to_mem)
 		l = FLD_MOD(l, 1, 26, 24);	/* CAPTUREMODE */
 	else
 		l = FLD_MOD(l, 0, 26, 24);	/* CAPTUREMODE */
-	dispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), l);
+	dispc_write_reg(dispc, DISPC_OVL_ATTRIBUTES(plane), l);
 
 	if (mem_to_mem) {
 		/* WBDELAYCOUNT */
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), 0, 7, 0);
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane), 0, 7, 0);
 	} else {
 		int wbdelay;
 
@@ -2731,7 +2820,7 @@ int dispc_wb_setup(struct dispc_device *
 			      vm->vsync_len + vm->vback_porch, (u32)255);
 
 		/* WBDELAYCOUNT */
-		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), wbdelay, 7, 0);
+		REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane), wbdelay, 7, 0);
 	}
 
 	return r;
@@ -2742,7 +2831,7 @@ static int dispc_ovl_enable(struct dispc
 {
 	DSSDBG("dispc_enable_plane %d, %d\n", plane, enable);
 
-	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 0, 0);
+	REG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 0, 0);
 
 	return 0;
 }
@@ -2754,94 +2843,106 @@ dispc_mgr_get_supported_outputs(struct d
 	return dss_get_supported_outputs(dispc->dss, channel);
 }
 
-static void dispc_lcd_enable_signal_polarity(bool act_high)
+static void dispc_lcd_enable_signal_polarity(struct dispc_device *dispc,
+					     bool act_high)
 {
-	if (!dispc_has_feature(FEAT_LCDENABLEPOL))
+	if (!dispc_has_feature(dispc, FEAT_LCDENABLEPOL))
 		return;
 
-	REG_FLD_MOD(DISPC_CONTROL, act_high ? 1 : 0, 29, 29);
+	REG_FLD_MOD(dispc, DISPC_CONTROL, act_high ? 1 : 0, 29, 29);
 }
 
 void dispc_lcd_enable_signal(struct dispc_device *dispc, bool enable)
 {
-	if (!dispc_has_feature(FEAT_LCDENABLESIGNAL))
+	if (!dispc_has_feature(dispc, FEAT_LCDENABLESIGNAL))
 		return;
 
-	REG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 28, 28);
+	REG_FLD_MOD(dispc, DISPC_CONTROL, enable ? 1 : 0, 28, 28);
 }
 
 void dispc_pck_free_enable(struct dispc_device *dispc, bool enable)
 {
-	if (!dispc_has_feature(FEAT_PCKFREEENABLE))
+	if (!dispc_has_feature(dispc, FEAT_PCKFREEENABLE))
 		return;
 
-	REG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 27, 27);
+	REG_FLD_MOD(dispc, DISPC_CONTROL, enable ? 1 : 0, 27, 27);
 }
 
-static void dispc_mgr_enable_fifohandcheck(enum omap_channel channel, bool enable)
+static void dispc_mgr_enable_fifohandcheck(struct dispc_device *dispc,
+					   enum omap_channel channel,
+					   bool enable)
 {
-	mgr_fld_write(channel, DISPC_MGR_FLD_FIFOHANDCHECK, enable);
+	mgr_fld_write(dispc, channel, DISPC_MGR_FLD_FIFOHANDCHECK, enable);
 }
 
 
-static void dispc_mgr_set_lcd_type_tft(enum omap_channel channel)
+static void dispc_mgr_set_lcd_type_tft(struct dispc_device *dispc,
+				       enum omap_channel channel)
 {
-	mgr_fld_write(channel, DISPC_MGR_FLD_STNTFT, 1);
+	mgr_fld_write(dispc, channel, DISPC_MGR_FLD_STNTFT, 1);
 }
 
-static void dispc_set_loadmode(enum omap_dss_load_mode mode)
+static void dispc_set_loadmode(struct dispc_device *dispc,
+			       enum omap_dss_load_mode mode)
 {
-	REG_FLD_MOD(DISPC_CONFIG, mode, 2, 1);
+	REG_FLD_MOD(dispc, DISPC_CONFIG, mode, 2, 1);
 }
 
 
-static void dispc_mgr_set_default_color(enum omap_channel channel, u32 color)
+static void dispc_mgr_set_default_color(struct dispc_device *dispc,
+					enum omap_channel channel, u32 color)
 {
-	dispc_write_reg(DISPC_DEFAULT_COLOR(channel), color);
+	dispc_write_reg(dispc, DISPC_DEFAULT_COLOR(channel), color);
 }
 
-static void dispc_mgr_set_trans_key(enum omap_channel ch,
-		enum omap_dss_trans_key_type type,
-		u32 trans_key)
+static void dispc_mgr_set_trans_key(struct dispc_device *dispc,
+				    enum omap_channel ch,
+				    enum omap_dss_trans_key_type type,
+				    u32 trans_key)
 {
-	mgr_fld_write(ch, DISPC_MGR_FLD_TCKSELECTION, type);
+	mgr_fld_write(dispc, ch, DISPC_MGR_FLD_TCKSELECTION, type);
 
-	dispc_write_reg(DISPC_TRANS_COLOR(ch), trans_key);
+	dispc_write_reg(dispc, DISPC_TRANS_COLOR(ch), trans_key);
 }
 
-static void dispc_mgr_enable_trans_key(enum omap_channel ch, bool enable)
+static void dispc_mgr_enable_trans_key(struct dispc_device *dispc,
+				       enum omap_channel ch, bool enable)
 {
-	mgr_fld_write(ch, DISPC_MGR_FLD_TCKENABLE, enable);
+	mgr_fld_write(dispc, ch, DISPC_MGR_FLD_TCKENABLE, enable);
 }
 
-static void dispc_mgr_enable_alpha_fixed_zorder(enum omap_channel ch,
-		bool enable)
+static void dispc_mgr_enable_alpha_fixed_zorder(struct dispc_device *dispc,
+						enum omap_channel ch,
+						bool enable)
 {
-	if (!dispc_has_feature(FEAT_ALPHA_FIXED_ZORDER))
+	if (!dispc_has_feature(dispc, FEAT_ALPHA_FIXED_ZORDER))
 		return;
 
 	if (ch == OMAP_DSS_CHANNEL_LCD)
-		REG_FLD_MOD(DISPC_CONFIG, enable, 18, 18);
+		REG_FLD_MOD(dispc, DISPC_CONFIG, enable, 18, 18);
 	else if (ch == OMAP_DSS_CHANNEL_DIGIT)
-		REG_FLD_MOD(DISPC_CONFIG, enable, 19, 19);
+		REG_FLD_MOD(dispc, DISPC_CONFIG, enable, 19, 19);
 }
 
 static void dispc_mgr_setup(struct dispc_device *dispc,
 			    enum omap_channel channel,
 			    const struct omap_overlay_manager_info *info)
 {
-	dispc_mgr_set_default_color(channel, info->default_color);
-	dispc_mgr_set_trans_key(channel, info->trans_key_type, info->trans_key);
-	dispc_mgr_enable_trans_key(channel, info->trans_enabled);
-	dispc_mgr_enable_alpha_fixed_zorder(channel,
+	dispc_mgr_set_default_color(dispc, channel, info->default_color);
+	dispc_mgr_set_trans_key(dispc, channel, info->trans_key_type,
+				info->trans_key);
+	dispc_mgr_enable_trans_key(dispc, channel, info->trans_enabled);
+	dispc_mgr_enable_alpha_fixed_zorder(dispc, channel,
 			info->partial_alpha_enabled);
-	if (dispc_has_feature(FEAT_CPR)) {
-		dispc_mgr_enable_cpr(channel, info->cpr_enable);
-		dispc_mgr_set_cpr_coef(channel, &info->cpr_coefs);
+	if (dispc_has_feature(dispc, FEAT_CPR)) {
+		dispc_mgr_enable_cpr(dispc, channel, info->cpr_enable);
+		dispc_mgr_set_cpr_coef(dispc, channel, &info->cpr_coefs);
 	}
 }
 
-static void dispc_mgr_set_tft_data_lines(enum omap_channel channel, u8 data_lines)
+static void dispc_mgr_set_tft_data_lines(struct dispc_device *dispc,
+					 enum omap_channel channel,
+					 u8 data_lines)
 {
 	int code;
 
@@ -2863,10 +2964,11 @@ static void dispc_mgr_set_tft_data_lines
 		return;
 	}
 
-	mgr_fld_write(channel, DISPC_MGR_FLD_TFTDATALINES, code);
+	mgr_fld_write(dispc, channel, DISPC_MGR_FLD_TFTDATALINES, code);
 }
 
-static void dispc_mgr_set_io_pad_mode(enum dss_io_pad_mode mode)
+static void dispc_mgr_set_io_pad_mode(struct dispc_device *dispc,
+				      enum dss_io_pad_mode mode)
 {
 	u32 l;
 	int gpout0, gpout1;
@@ -2889,70 +2991,74 @@ static void dispc_mgr_set_io_pad_mode(en
 		return;
 	}
 
-	l = dispc_read_reg(DISPC_CONTROL);
+	l = dispc_read_reg(dispc, DISPC_CONTROL);
 	l = FLD_MOD(l, gpout0, 15, 15);
 	l = FLD_MOD(l, gpout1, 16, 16);
-	dispc_write_reg(DISPC_CONTROL, l);
+	dispc_write_reg(dispc, DISPC_CONTROL, l);
 }
 
-static void dispc_mgr_enable_stallmode(enum omap_channel channel, bool enable)
+static void dispc_mgr_enable_stallmode(struct dispc_device *dispc,
+				       enum omap_channel channel, bool enable)
 {
-	mgr_fld_write(channel, DISPC_MGR_FLD_STALLMODE, enable);
+	mgr_fld_write(dispc, channel, DISPC_MGR_FLD_STALLMODE, enable);
 }
 
 static void dispc_mgr_set_lcd_config(struct dispc_device *dispc,
 				     enum omap_channel channel,
 				     const struct dss_lcd_mgr_config *config)
 {
-	dispc_mgr_set_io_pad_mode(config->io_pad_mode);
+	dispc_mgr_set_io_pad_mode(dispc, config->io_pad_mode);
 
-	dispc_mgr_enable_stallmode(channel, config->stallmode);
-	dispc_mgr_enable_fifohandcheck(channel, config->fifohandcheck);
+	dispc_mgr_enable_stallmode(dispc, channel, config->stallmode);
+	dispc_mgr_enable_fifohandcheck(dispc, channel, config->fifohandcheck);
 
 	dispc_mgr_set_clock_div(dispc, channel, &config->clock_info);
 
-	dispc_mgr_set_tft_data_lines(channel, config->video_port_width);
+	dispc_mgr_set_tft_data_lines(dispc, channel, config->video_port_width);
 
-	dispc_lcd_enable_signal_polarity(config->lcden_sig_polarity);
+	dispc_lcd_enable_signal_polarity(dispc, config->lcden_sig_polarity);
 
-	dispc_mgr_set_lcd_type_tft(channel);
+	dispc_mgr_set_lcd_type_tft(dispc, channel);
 }
 
-static bool _dispc_mgr_size_ok(u16 width, u16 height)
+static bool _dispc_mgr_size_ok(struct dispc_device *dispc,
+			       u16 width, u16 height)
 {
-	return width <= dispc.feat->mgr_width_max &&
-		height <= dispc.feat->mgr_height_max;
+	return width <= dispc->feat->mgr_width_max &&
+		height <= dispc->feat->mgr_height_max;
 }
 
-static bool _dispc_lcd_timings_ok(int hsync_len, int hfp, int hbp,
-		int vsw, int vfp, int vbp)
+static bool _dispc_lcd_timings_ok(struct dispc_device *dispc,
+				  int hsync_len, int hfp, int hbp,
+				  int vsw, int vfp, int vbp)
 {
-	if (hsync_len < 1 || hsync_len > dispc.feat->sw_max ||
-			hfp < 1 || hfp > dispc.feat->hp_max ||
-			hbp < 1 || hbp > dispc.feat->hp_max ||
-			vsw < 1 || vsw > dispc.feat->sw_max ||
-			vfp < 0 || vfp > dispc.feat->vp_max ||
-			vbp < 0 || vbp > dispc.feat->vp_max)
+	if (hsync_len < 1 || hsync_len > dispc->feat->sw_max ||
+	    hfp < 1 || hfp > dispc->feat->hp_max ||
+	    hbp < 1 || hbp > dispc->feat->hp_max ||
+	    vsw < 1 || vsw > dispc->feat->sw_max ||
+	    vfp < 0 || vfp > dispc->feat->vp_max ||
+	    vbp < 0 || vbp > dispc->feat->vp_max)
 		return false;
 	return true;
 }
 
-static bool _dispc_mgr_pclk_ok(enum omap_channel channel,
-		unsigned long pclk)
+static bool _dispc_mgr_pclk_ok(struct dispc_device *dispc,
+			       enum omap_channel channel,
+			       unsigned long pclk)
 {
 	if (dss_mgr_is_lcd(channel))
-		return pclk <= dispc.feat->max_lcd_pclk;
+		return pclk <= dispc->feat->max_lcd_pclk;
 	else
-		return pclk <= dispc.feat->max_tv_pclk;
+		return pclk <= dispc->feat->max_tv_pclk;
 }
 
 bool dispc_mgr_timings_ok(struct dispc_device *dispc, enum omap_channel channel,
 			  const struct videomode *vm)
 {
-	if (!_dispc_mgr_size_ok(vm->hactive, vm->vactive))
+	if (!_dispc_mgr_size_ok(dispc, vm->hactive, vm->vactive))
 		return false;
 
-	if (!_dispc_mgr_pclk_ok(channel, vm->pixelclock))
+	if (!_dispc_mgr_pclk_ok(dispc, channel, vm->pixelclock))
 		return false;
 
 	if (dss_mgr_is_lcd(channel)) {
@@ -2960,7 +3066,7 @@ bool dispc_mgr_timings_ok(struct dispc_d
 		if (vm->flags & DISPLAY_FLAGS_INTERLACED)
 			return false;
 
-		if (!_dispc_lcd_timings_ok(vm->hsync_len,
+		if (!_dispc_lcd_timings_ok(dispc, vm->hsync_len,
 				vm->hfront_porch, vm->hback_porch,
 				vm->vsync_len, vm->vfront_porch,
 				vm->vback_porch))
@@ -2970,21 +3076,22 @@ bool dispc_mgr_timings_ok(struct dispc_d
 	return true;
 }
 
-static void _dispc_mgr_set_lcd_timings(enum omap_channel channel,
+static void _dispc_mgr_set_lcd_timings(struct dispc_device *dispc,
+				       enum omap_channel channel,
 				       const struct videomode *vm)
 {
 	u32 timing_h, timing_v, l;
 	bool onoff, rf, ipc, vs, hs, de;
 
-	timing_h = FLD_VAL(vm->hsync_len - 1, dispc.feat->sw_start, 0) |
-		   FLD_VAL(vm->hfront_porch - 1, dispc.feat->fp_start, 8) |
-		   FLD_VAL(vm->hback_porch - 1, dispc.feat->bp_start, 20);
-	timing_v = FLD_VAL(vm->vsync_len - 1, dispc.feat->sw_start, 0) |
-		   FLD_VAL(vm->vfront_porch, dispc.feat->fp_start, 8) |
-		   FLD_VAL(vm->vback_porch, dispc.feat->bp_start, 20);
+	timing_h = FLD_VAL(vm->hsync_len - 1, dispc->feat->sw_start, 0) |
+		   FLD_VAL(vm->hfront_porch - 1, dispc->feat->fp_start, 8) |
+		   FLD_VAL(vm->hback_porch - 1, dispc->feat->bp_start, 20);
+	timing_v = FLD_VAL(vm->vsync_len - 1, dispc->feat->sw_start, 0) |
+		   FLD_VAL(vm->vfront_porch, dispc->feat->fp_start, 8) |
+		   FLD_VAL(vm->vback_porch, dispc->feat->bp_start, 20);
 
-	dispc_write_reg(DISPC_TIMING_H(channel), timing_h);
-	dispc_write_reg(DISPC_TIMING_V(channel), timing_v);
+	dispc_write_reg(dispc, DISPC_TIMING_H(channel), timing_h);
+	dispc_write_reg(dispc, DISPC_TIMING_V(channel), timing_v);
 
 	if (vm->flags & DISPLAY_FLAGS_VSYNC_HIGH)
 		vs = false;
@@ -3022,12 +3129,12 @@ static void _dispc_mgr_set_lcd_timings(e
 		FLD_VAL(vs, 12, 12);
 
 	/* always set ALIGN bit when available */
-	if (dispc.feat->supports_sync_align)
+	if (dispc->feat->supports_sync_align)
 		l |= (1 << 18);
 
-	dispc_write_reg(DISPC_POL_FREQ(channel), l);
+	dispc_write_reg(dispc, DISPC_POL_FREQ(channel), l);
 
-	if (dispc.syscon_pol) {
+	if (dispc->syscon_pol) {
 		const int shifts[] = {
 			[OMAP_DSS_CHANNEL_LCD] = 0,
 			[OMAP_DSS_CHANNEL_LCD2] = 1,
@@ -3042,8 +3149,8 @@ static void _dispc_mgr_set_lcd_timings(e
 		mask <<= 16 + shifts[channel];
 		val <<= 16 + shifts[channel];
 
-		regmap_update_bits(dispc.syscon_pol, dispc.syscon_pol_offset,
-			mask, val);
+		regmap_update_bits(dispc->syscon_pol, dispc->syscon_pol_offset,
+				   mask, val);
 	}
 }
 
@@ -3074,7 +3181,7 @@ static void dispc_mgr_set_timings(struct
 	}
 
 	if (dss_mgr_is_lcd(channel)) {
-		_dispc_mgr_set_lcd_timings(channel, &t);
+		_dispc_mgr_set_lcd_timings(dispc, channel, &t);
 
 		xtot = t.hactive + t.hfront_porch + t.hsync_len + t.hback_porch;
 		ytot = t.vactive + t.vfront_porch + t.vsync_len + t.vback_porch;
@@ -3099,51 +3206,53 @@ static void dispc_mgr_set_timings(struct
 			t.vactive /= 2;
 
 		if (dispc->feat->supports_double_pixel)
-			REG_FLD_MOD(DISPC_CONTROL,
+			REG_FLD_MOD(dispc, DISPC_CONTROL,
 				    !!(t.flags & DISPLAY_FLAGS_DOUBLECLK),
 				    19, 17);
 	}
 
-	dispc_mgr_set_size(channel, t.hactive, t.vactive);
+	dispc_mgr_set_size(dispc, channel, t.hactive, t.vactive);
 }
 
-static void dispc_mgr_set_lcd_divisor(enum omap_channel channel, u16 lck_div,
-		u16 pck_div)
+static void dispc_mgr_set_lcd_divisor(struct dispc_device *dispc,
+				      enum omap_channel channel, u16 lck_div,
+				      u16 pck_div)
 {
 	BUG_ON(lck_div < 1);
 	BUG_ON(pck_div < 1);
 
-	dispc_write_reg(DISPC_DIVISORo(channel),
+	dispc_write_reg(dispc, DISPC_DIVISORo(channel),
 			FLD_VAL(lck_div, 23, 16) | FLD_VAL(pck_div, 7, 0));
 
-	if (!dispc_has_feature(FEAT_CORE_CLK_DIV) &&
+	if (!dispc_has_feature(dispc, FEAT_CORE_CLK_DIV) &&
 			channel == OMAP_DSS_CHANNEL_LCD)
-		dispc.core_clk_rate = dispc_fclk_rate() / lck_div;
+		dispc->core_clk_rate = dispc_fclk_rate(dispc) / lck_div;
 }
 
-static void dispc_mgr_get_lcd_divisor(enum omap_channel channel, int *lck_div,
-		int *pck_div)
+static void dispc_mgr_get_lcd_divisor(struct dispc_device *dispc,
+				      enum omap_channel channel, int *lck_div,
+				      int *pck_div)
 {
 	u32 l;
-	l = dispc_read_reg(DISPC_DIVISORo(channel));
+	l = dispc_read_reg(dispc, DISPC_DIVISORo(channel));
 	*lck_div = FLD_GET(l, 23, 16);
 	*pck_div = FLD_GET(l, 7, 0);
 }
 
-static unsigned long dispc_fclk_rate(void)
+static unsigned long dispc_fclk_rate(struct dispc_device *dispc)
 {
 	unsigned long r;
 	enum dss_clk_source src;
 
-	src = dss_get_dispc_clk_source(dispc.dss);
+	src = dss_get_dispc_clk_source(dispc->dss);
 
 	if (src == DSS_CLK_SRC_FCK) {
-		r = dss_get_dispc_clk_rate(dispc.dss);
+		r = dss_get_dispc_clk_rate(dispc->dss);
 	} else {
 		struct dss_pll *pll;
 		unsigned int clkout_idx;
 
-		pll = dss_pll_find_by_src(dispc.dss, src);
+		pll = dss_pll_find_by_src(dispc->dss, src);
 		clkout_idx = dss_pll_get_clkout_idx_for_src(src);
 
 		r = pll->cinfo.clkout[clkout_idx];
@@ -3152,7 +3261,8 @@ static unsigned long dispc_fclk_rate(voi
 	return r;
 }
 
-static unsigned long dispc_mgr_lclk_rate(enum omap_channel channel)
+static unsigned long dispc_mgr_lclk_rate(struct dispc_device *dispc,
+					 enum omap_channel channel)
 {
 	int lcd;
 	unsigned long r;
@@ -3160,28 +3270,29 @@ static unsigned long dispc_mgr_lclk_rate
 
 	/* for TV, LCLK rate is the FCLK rate */
 	if (!dss_mgr_is_lcd(channel))
-		return dispc_fclk_rate();
+		return dispc_fclk_rate(dispc);
 
-	src = dss_get_lcd_clk_source(dispc.dss, channel);
+	src = dss_get_lcd_clk_source(dispc->dss, channel);
 
 	if (src == DSS_CLK_SRC_FCK) {
-		r = dss_get_dispc_clk_rate(dispc.dss);
+		r = dss_get_dispc_clk_rate(dispc->dss);
 	} else {
 		struct dss_pll *pll;
 		unsigned int clkout_idx;
 
-		pll = dss_pll_find_by_src(dispc.dss, src);
+		pll = dss_pll_find_by_src(dispc->dss, src);
 		clkout_idx = dss_pll_get_clkout_idx_for_src(src);
 
 		r = pll->cinfo.clkout[clkout_idx];
 	}
 
-	lcd = REG_GET(DISPC_DIVISORo(channel), 23, 16);
+	lcd = REG_GET(dispc, DISPC_DIVISORo(channel), 23, 16);
 
 	return r / lcd;
 }
 
-static unsigned long dispc_mgr_pclk_rate(enum omap_channel channel)
+static unsigned long dispc_mgr_pclk_rate(struct dispc_device *dispc,
+					 enum omap_channel channel)
 {
 	unsigned long r;
 
@@ -3189,15 +3300,15 @@ static unsigned long dispc_mgr_pclk_rate
 		int pcd;
 		u32 l;
 
-		l = dispc_read_reg(DISPC_DIVISORo(channel));
+		l = dispc_read_reg(dispc, DISPC_DIVISORo(channel));
 
 		pcd = FLD_GET(l, 7, 0);
 
-		r = dispc_mgr_lclk_rate(channel);
+		r = dispc_mgr_lclk_rate(dispc, channel);
 
 		return r / pcd;
 	} else {
-		return dispc.tv_pclk_rate;
+		return dispc->tv_pclk_rate;
 	}
 }
 
@@ -3206,53 +3317,57 @@ void dispc_set_tv_pclk(struct dispc_devi
 	dispc->tv_pclk_rate = pclk;
 }
 
-static unsigned long dispc_core_clk_rate(void)
+static unsigned long dispc_core_clk_rate(struct dispc_device *dispc)
 {
-	return dispc.core_clk_rate;
+	return dispc->core_clk_rate;
 }
 
-static unsigned long dispc_plane_pclk_rate(enum omap_plane_id plane)
+static unsigned long dispc_plane_pclk_rate(struct dispc_device *dispc,
+					   enum omap_plane_id plane)
 {
 	enum omap_channel channel;
 
 	if (plane == OMAP_DSS_WB)
 		return 0;
 
-	channel = dispc_ovl_get_channel_out(plane);
+	channel = dispc_ovl_get_channel_out(dispc, plane);
 
-	return dispc_mgr_pclk_rate(channel);
+	return dispc_mgr_pclk_rate(dispc, channel);
 }
 
-static unsigned long dispc_plane_lclk_rate(enum omap_plane_id plane)
+static unsigned long dispc_plane_lclk_rate(struct dispc_device *dispc,
+					   enum omap_plane_id plane)
 {
 	enum omap_channel channel;
 
 	if (plane == OMAP_DSS_WB)
 		return 0;
 
-	channel	= dispc_ovl_get_channel_out(plane);
+	channel	= dispc_ovl_get_channel_out(dispc, plane);
 
-	return dispc_mgr_lclk_rate(channel);
+	return dispc_mgr_lclk_rate(dispc, channel);
 }
 
-static void dispc_dump_clocks_channel(struct seq_file *s, enum omap_channel channel)
+static void dispc_dump_clocks_channel(struct dispc_device *dispc,
+				      struct seq_file *s,
+				      enum omap_channel channel)
 {
 	int lcd, pcd;
 	enum dss_clk_source lcd_clk_src;
 
 	seq_printf(s, "- %s -\n", mgr_desc[channel].name);
 
-	lcd_clk_src = dss_get_lcd_clk_source(dispc.dss, channel);
+	lcd_clk_src = dss_get_lcd_clk_source(dispc->dss, channel);
 
 	seq_printf(s, "%s clk source = %s\n", mgr_desc[channel].name,
 		dss_get_clk_source_name(lcd_clk_src));
 
-	dispc_mgr_get_lcd_divisor(channel, &lcd, &pcd);
+	dispc_mgr_get_lcd_divisor(dispc, channel, &lcd, &pcd);
 
 	seq_printf(s, "lck\t\t%-16lulck div\t%u\n",
-		dispc_mgr_lclk_rate(channel), lcd);
+		dispc_mgr_lclk_rate(dispc, channel), lcd);
 	seq_printf(s, "pck\t\t%-16lupck div\t%u\n",
-		dispc_mgr_pclk_rate(channel), pcd);
+		dispc_mgr_pclk_rate(dispc, channel), pcd);
 }
 
 void dispc_dump_clocks(struct dispc_device *dispc, struct seq_file *s)
@@ -3270,29 +3385,30 @@ void dispc_dump_clocks(struct dispc_devi
 	seq_printf(s, "dispc fclk source = %s\n",
 			dss_get_clk_source_name(dispc_clk_src));
 
-	seq_printf(s, "fck\t\t%-16lu\n", dispc_fclk_rate());
+	seq_printf(s, "fck\t\t%-16lu\n", dispc_fclk_rate(dispc));
 
-	if (dispc_has_feature(FEAT_CORE_CLK_DIV)) {
+	if (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV)) {
 		seq_printf(s, "- DISPC-CORE-CLK -\n");
-		l = dispc_read_reg(DISPC_DIVISOR);
+		l = dispc_read_reg(dispc, DISPC_DIVISOR);
 		lcd = FLD_GET(l, 23, 16);
 
 		seq_printf(s, "lck\t\t%-16lulck div\t%u\n",
-				(dispc_fclk_rate()/lcd), lcd);
+				(dispc_fclk_rate(dispc)/lcd), lcd);
 	}
 
-	dispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD);
+	dispc_dump_clocks_channel(dispc, s, OMAP_DSS_CHANNEL_LCD);
 
-	if (dispc_has_feature(FEAT_MGR_LCD2))
-		dispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD2);
-	if (dispc_has_feature(FEAT_MGR_LCD3))
-		dispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD3);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD2))
+		dispc_dump_clocks_channel(dispc, s, OMAP_DSS_CHANNEL_LCD2);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD3))
+		dispc_dump_clocks_channel(dispc, s, OMAP_DSS_CHANNEL_LCD3);
 
 	dispc_runtime_put(dispc);
 }
 
 static int dispc_dump_regs(struct seq_file *s, void *p)
 {
+	struct dispc_device *dispc = s->private;
 	int i, j;
 	const char *mgr_names[] = {
 		[OMAP_DSS_CHANNEL_LCD]		= "LCD",
@@ -3309,178 +3425,179 @@ static int dispc_dump_regs(struct seq_fi
 	};
 	const char **p_names;
 
-#define DUMPREG(r) seq_printf(s, "%-50s %08x\n", #r, dispc_read_reg(r))
+#define DUMPREG(dispc, r) \
+	seq_printf(s, "%-50s %08x\n", #r, dispc_read_reg(dispc, r))
 
-	if (dispc_runtime_get(&dispc))
+	if (dispc_runtime_get(dispc))
 		return 0;
 
 	/* DISPC common registers */
-	DUMPREG(DISPC_REVISION);
-	DUMPREG(DISPC_SYSCONFIG);
-	DUMPREG(DISPC_SYSSTATUS);
-	DUMPREG(DISPC_IRQSTATUS);
-	DUMPREG(DISPC_IRQENABLE);
-	DUMPREG(DISPC_CONTROL);
-	DUMPREG(DISPC_CONFIG);
-	DUMPREG(DISPC_CAPABLE);
-	DUMPREG(DISPC_LINE_STATUS);
-	DUMPREG(DISPC_LINE_NUMBER);
-	if (dispc_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||
-			dispc_has_feature(FEAT_ALPHA_FREE_ZORDER))
-		DUMPREG(DISPC_GLOBAL_ALPHA);
-	if (dispc_has_feature(FEAT_MGR_LCD2)) {
-		DUMPREG(DISPC_CONTROL2);
-		DUMPREG(DISPC_CONFIG2);
-	}
-	if (dispc_has_feature(FEAT_MGR_LCD3)) {
-		DUMPREG(DISPC_CONTROL3);
-		DUMPREG(DISPC_CONFIG3);
+	DUMPREG(dispc, DISPC_REVISION);
+	DUMPREG(dispc, DISPC_SYSCONFIG);
+	DUMPREG(dispc, DISPC_SYSSTATUS);
+	DUMPREG(dispc, DISPC_IRQSTATUS);
+	DUMPREG(dispc, DISPC_IRQENABLE);
+	DUMPREG(dispc, DISPC_CONTROL);
+	DUMPREG(dispc, DISPC_CONFIG);
+	DUMPREG(dispc, DISPC_CAPABLE);
+	DUMPREG(dispc, DISPC_LINE_STATUS);
+	DUMPREG(dispc, DISPC_LINE_NUMBER);
+	if (dispc_has_feature(dispc, FEAT_ALPHA_FIXED_ZORDER) ||
+			dispc_has_feature(dispc, FEAT_ALPHA_FREE_ZORDER))
+		DUMPREG(dispc, DISPC_GLOBAL_ALPHA);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD2)) {
+		DUMPREG(dispc, DISPC_CONTROL2);
+		DUMPREG(dispc, DISPC_CONFIG2);
+	}
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD3)) {
+		DUMPREG(dispc, DISPC_CONTROL3);
+		DUMPREG(dispc, DISPC_CONFIG3);
 	}
-	if (dispc_has_feature(FEAT_MFLAG))
-		DUMPREG(DISPC_GLOBAL_MFLAG_ATTRIBUTE);
+	if (dispc_has_feature(dispc, FEAT_MFLAG))
+		DUMPREG(dispc, DISPC_GLOBAL_MFLAG_ATTRIBUTE);
 
 #undef DUMPREG
 
 #define DISPC_REG(i, name) name(i)
-#define DUMPREG(i, r) seq_printf(s, "%s(%s)%*s %08x\n", #r, p_names[i], \
+#define DUMPREG(dispc, i, r) seq_printf(s, "%s(%s)%*s %08x\n", #r, p_names[i], \
 	(int)(48 - strlen(#r) - strlen(p_names[i])), " ", \
-	dispc_read_reg(DISPC_REG(i, r)))
+	dispc_read_reg(dispc, DISPC_REG(i, r)))
 
 	p_names = mgr_names;
 
 	/* DISPC channel specific registers */
-	for (i = 0; i < dispc_get_num_mgrs(&dispc); i++) {
-		DUMPREG(i, DISPC_DEFAULT_COLOR);
-		DUMPREG(i, DISPC_TRANS_COLOR);
-		DUMPREG(i, DISPC_SIZE_MGR);
+	for (i = 0; i < dispc_get_num_mgrs(dispc); i++) {
+		DUMPREG(dispc, i, DISPC_DEFAULT_COLOR);
+		DUMPREG(dispc, i, DISPC_TRANS_COLOR);
+		DUMPREG(dispc, i, DISPC_SIZE_MGR);
 
 		if (i == OMAP_DSS_CHANNEL_DIGIT)
 			continue;
 
-		DUMPREG(i, DISPC_TIMING_H);
-		DUMPREG(i, DISPC_TIMING_V);
-		DUMPREG(i, DISPC_POL_FREQ);
-		DUMPREG(i, DISPC_DIVISORo);
-
-		DUMPREG(i, DISPC_DATA_CYCLE1);
-		DUMPREG(i, DISPC_DATA_CYCLE2);
-		DUMPREG(i, DISPC_DATA_CYCLE3);
-
-		if (dispc_has_feature(FEAT_CPR)) {
-			DUMPREG(i, DISPC_CPR_COEF_R);
-			DUMPREG(i, DISPC_CPR_COEF_G);
-			DUMPREG(i, DISPC_CPR_COEF_B);
+		DUMPREG(dispc, i, DISPC_TIMING_H);
+		DUMPREG(dispc, i, DISPC_TIMING_V);
+		DUMPREG(dispc, i, DISPC_POL_FREQ);
+		DUMPREG(dispc, i, DISPC_DIVISORo);
+
+		DUMPREG(dispc, i, DISPC_DATA_CYCLE1);
+		DUMPREG(dispc, i, DISPC_DATA_CYCLE2);
+		DUMPREG(dispc, i, DISPC_DATA_CYCLE3);
+
+		if (dispc_has_feature(dispc, FEAT_CPR)) {
+			DUMPREG(dispc, i, DISPC_CPR_COEF_R);
+			DUMPREG(dispc, i, DISPC_CPR_COEF_G);
+			DUMPREG(dispc, i, DISPC_CPR_COEF_B);
 		}
 	}
 
 	p_names = ovl_names;
 
-	for (i = 0; i < dispc_get_num_ovls(&dispc); i++) {
-		DUMPREG(i, DISPC_OVL_BA0);
-		DUMPREG(i, DISPC_OVL_BA1);
-		DUMPREG(i, DISPC_OVL_POSITION);
-		DUMPREG(i, DISPC_OVL_SIZE);
-		DUMPREG(i, DISPC_OVL_ATTRIBUTES);
-		DUMPREG(i, DISPC_OVL_FIFO_THRESHOLD);
-		DUMPREG(i, DISPC_OVL_FIFO_SIZE_STATUS);
-		DUMPREG(i, DISPC_OVL_ROW_INC);
-		DUMPREG(i, DISPC_OVL_PIXEL_INC);
-
-		if (dispc_has_feature(FEAT_PRELOAD))
-			DUMPREG(i, DISPC_OVL_PRELOAD);
-		if (dispc_has_feature(FEAT_MFLAG))
-			DUMPREG(i, DISPC_OVL_MFLAG_THRESHOLD);
+	for (i = 0; i < dispc_get_num_ovls(dispc); i++) {
+		DUMPREG(dispc, i, DISPC_OVL_BA0);
+		DUMPREG(dispc, i, DISPC_OVL_BA1);
+		DUMPREG(dispc, i, DISPC_OVL_POSITION);
+		DUMPREG(dispc, i, DISPC_OVL_SIZE);
+		DUMPREG(dispc, i, DISPC_OVL_ATTRIBUTES);
+		DUMPREG(dispc, i, DISPC_OVL_FIFO_THRESHOLD);
+		DUMPREG(dispc, i, DISPC_OVL_FIFO_SIZE_STATUS);
+		DUMPREG(dispc, i, DISPC_OVL_ROW_INC);
+		DUMPREG(dispc, i, DISPC_OVL_PIXEL_INC);
+
+		if (dispc_has_feature(dispc, FEAT_PRELOAD))
+			DUMPREG(dispc, i, DISPC_OVL_PRELOAD);
+		if (dispc_has_feature(dispc, FEAT_MFLAG))
+			DUMPREG(dispc, i, DISPC_OVL_MFLAG_THRESHOLD);
 
 		if (i == OMAP_DSS_GFX) {
-			DUMPREG(i, DISPC_OVL_WINDOW_SKIP);
-			DUMPREG(i, DISPC_OVL_TABLE_BA);
+			DUMPREG(dispc, i, DISPC_OVL_WINDOW_SKIP);
+			DUMPREG(dispc, i, DISPC_OVL_TABLE_BA);
 			continue;
 		}
 
-		DUMPREG(i, DISPC_OVL_FIR);
-		DUMPREG(i, DISPC_OVL_PICTURE_SIZE);
-		DUMPREG(i, DISPC_OVL_ACCU0);
-		DUMPREG(i, DISPC_OVL_ACCU1);
-		if (dispc_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
-			DUMPREG(i, DISPC_OVL_BA0_UV);
-			DUMPREG(i, DISPC_OVL_BA1_UV);
-			DUMPREG(i, DISPC_OVL_FIR2);
-			DUMPREG(i, DISPC_OVL_ACCU2_0);
-			DUMPREG(i, DISPC_OVL_ACCU2_1);
+		DUMPREG(dispc, i, DISPC_OVL_FIR);
+		DUMPREG(dispc, i, DISPC_OVL_PICTURE_SIZE);
+		DUMPREG(dispc, i, DISPC_OVL_ACCU0);
+		DUMPREG(dispc, i, DISPC_OVL_ACCU1);
+		if (dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE)) {
+			DUMPREG(dispc, i, DISPC_OVL_BA0_UV);
+			DUMPREG(dispc, i, DISPC_OVL_BA1_UV);
+			DUMPREG(dispc, i, DISPC_OVL_FIR2);
+			DUMPREG(dispc, i, DISPC_OVL_ACCU2_0);
+			DUMPREG(dispc, i, DISPC_OVL_ACCU2_1);
 		}
-		if (dispc_has_feature(FEAT_ATTR2))
-			DUMPREG(i, DISPC_OVL_ATTRIBUTES2);
+		if (dispc_has_feature(dispc, FEAT_ATTR2))
+			DUMPREG(dispc, i, DISPC_OVL_ATTRIBUTES2);
 	}
 
-	if (dispc.feat->has_writeback) {
+	if (dispc->feat->has_writeback) {
 		i = OMAP_DSS_WB;
-		DUMPREG(i, DISPC_OVL_BA0);
-		DUMPREG(i, DISPC_OVL_BA1);
-		DUMPREG(i, DISPC_OVL_SIZE);
-		DUMPREG(i, DISPC_OVL_ATTRIBUTES);
-		DUMPREG(i, DISPC_OVL_FIFO_THRESHOLD);
-		DUMPREG(i, DISPC_OVL_FIFO_SIZE_STATUS);
-		DUMPREG(i, DISPC_OVL_ROW_INC);
-		DUMPREG(i, DISPC_OVL_PIXEL_INC);
-
-		if (dispc_has_feature(FEAT_MFLAG))
-			DUMPREG(i, DISPC_OVL_MFLAG_THRESHOLD);
-
-		DUMPREG(i, DISPC_OVL_FIR);
-		DUMPREG(i, DISPC_OVL_PICTURE_SIZE);
-		DUMPREG(i, DISPC_OVL_ACCU0);
-		DUMPREG(i, DISPC_OVL_ACCU1);
-		if (dispc_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
-			DUMPREG(i, DISPC_OVL_BA0_UV);
-			DUMPREG(i, DISPC_OVL_BA1_UV);
-			DUMPREG(i, DISPC_OVL_FIR2);
-			DUMPREG(i, DISPC_OVL_ACCU2_0);
-			DUMPREG(i, DISPC_OVL_ACCU2_1);
+		DUMPREG(dispc, i, DISPC_OVL_BA0);
+		DUMPREG(dispc, i, DISPC_OVL_BA1);
+		DUMPREG(dispc, i, DISPC_OVL_SIZE);
+		DUMPREG(dispc, i, DISPC_OVL_ATTRIBUTES);
+		DUMPREG(dispc, i, DISPC_OVL_FIFO_THRESHOLD);
+		DUMPREG(dispc, i, DISPC_OVL_FIFO_SIZE_STATUS);
+		DUMPREG(dispc, i, DISPC_OVL_ROW_INC);
+		DUMPREG(dispc, i, DISPC_OVL_PIXEL_INC);
+
+		if (dispc_has_feature(dispc, FEAT_MFLAG))
+			DUMPREG(dispc, i, DISPC_OVL_MFLAG_THRESHOLD);
+
+		DUMPREG(dispc, i, DISPC_OVL_FIR);
+		DUMPREG(dispc, i, DISPC_OVL_PICTURE_SIZE);
+		DUMPREG(dispc, i, DISPC_OVL_ACCU0);
+		DUMPREG(dispc, i, DISPC_OVL_ACCU1);
+		if (dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE)) {
+			DUMPREG(dispc, i, DISPC_OVL_BA0_UV);
+			DUMPREG(dispc, i, DISPC_OVL_BA1_UV);
+			DUMPREG(dispc, i, DISPC_OVL_FIR2);
+			DUMPREG(dispc, i, DISPC_OVL_ACCU2_0);
+			DUMPREG(dispc, i, DISPC_OVL_ACCU2_1);
 		}
-		if (dispc_has_feature(FEAT_ATTR2))
-			DUMPREG(i, DISPC_OVL_ATTRIBUTES2);
+		if (dispc_has_feature(dispc, FEAT_ATTR2))
+			DUMPREG(dispc, i, DISPC_OVL_ATTRIBUTES2);
 	}
 
 #undef DISPC_REG
 #undef DUMPREG
 
 #define DISPC_REG(plane, name, i) name(plane, i)
-#define DUMPREG(plane, name, i) \
+#define DUMPREG(dispc, plane, name, i) \
 	seq_printf(s, "%s_%d(%s)%*s %08x\n", #name, i, p_names[plane], \
 	(int)(46 - strlen(#name) - strlen(p_names[plane])), " ", \
-	dispc_read_reg(DISPC_REG(plane, name, i)))
+	dispc_read_reg(dispc, DISPC_REG(plane, name, i)))
 
 	/* Video pipeline coefficient registers */
 
 	/* start from OMAP_DSS_VIDEO1 */
-	for (i = 1; i < dispc_get_num_ovls(&dispc); i++) {
+	for (i = 1; i < dispc_get_num_ovls(dispc); i++) {
 		for (j = 0; j < 8; j++)
-			DUMPREG(i, DISPC_OVL_FIR_COEF_H, j);
+			DUMPREG(dispc, i, DISPC_OVL_FIR_COEF_H, j);
 
 		for (j = 0; j < 8; j++)
-			DUMPREG(i, DISPC_OVL_FIR_COEF_HV, j);
+			DUMPREG(dispc, i, DISPC_OVL_FIR_COEF_HV, j);
 
 		for (j = 0; j < 5; j++)
-			DUMPREG(i, DISPC_OVL_CONV_COEF, j);
+			DUMPREG(dispc, i, DISPC_OVL_CONV_COEF, j);
 
-		if (dispc_has_feature(FEAT_FIR_COEF_V)) {
+		if (dispc_has_feature(dispc, FEAT_FIR_COEF_V)) {
 			for (j = 0; j < 8; j++)
-				DUMPREG(i, DISPC_OVL_FIR_COEF_V, j);
+				DUMPREG(dispc, i, DISPC_OVL_FIR_COEF_V, j);
 		}
 
-		if (dispc_has_feature(FEAT_HANDLE_UV_SEPARATE)) {
+		if (dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE)) {
 			for (j = 0; j < 8; j++)
-				DUMPREG(i, DISPC_OVL_FIR_COEF_H2, j);
+				DUMPREG(dispc, i, DISPC_OVL_FIR_COEF_H2, j);
 
 			for (j = 0; j < 8; j++)
-				DUMPREG(i, DISPC_OVL_FIR_COEF_HV2, j);
+				DUMPREG(dispc, i, DISPC_OVL_FIR_COEF_HV2, j);
 
 			for (j = 0; j < 8; j++)
-				DUMPREG(i, DISPC_OVL_FIR_COEF_V2, j);
+				DUMPREG(dispc, i, DISPC_OVL_FIR_COEF_V2, j);
 		}
 	}
 
-	dispc_runtime_put(&dispc);
+	dispc_runtime_put(dispc);
 
 #undef DISPC_REG
 #undef DUMPREG
@@ -3548,8 +3665,8 @@ bool dispc_div_calc(struct dispc_device
 			 * also. Thus we need to use the calculated lck. For
 			 * OMAP4+ the DISPC fclk is a separate clock.
 			 */
-			if (dispc_has_feature(FEAT_CORE_CLK_DIV))
-				fck = dispc_core_clk_rate();
+			if (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))
+				fck = dispc_core_clk_rate(dispc);
 			else
 				fck = lck;
 
@@ -3571,7 +3688,8 @@ void dispc_mgr_set_clock_div(struct disp
 	DSSDBG("lck = %lu (%u)\n", cinfo->lck, cinfo->lck_div);
 	DSSDBG("pck = %lu (%u)\n", cinfo->pck, cinfo->pck_div);
 
-	dispc_mgr_set_lcd_divisor(channel, cinfo->lck_div, cinfo->pck_div);
+	dispc_mgr_set_lcd_divisor(dispc, channel, cinfo->lck_div,
+				  cinfo->pck_div);
 }
 
 int dispc_mgr_get_clock_div(struct dispc_device *dispc,
@@ -3580,10 +3698,10 @@ int dispc_mgr_get_clock_div(struct dispc
 {
 	unsigned long fck;
 
-	fck = dispc_fclk_rate();
+	fck = dispc_fclk_rate(dispc);
 
-	cinfo->lck_div = REG_GET(DISPC_DIVISORo(channel), 23, 16);
-	cinfo->pck_div = REG_GET(DISPC_DIVISORo(channel), 7, 0);
+	cinfo->lck_div = REG_GET(dispc, DISPC_DIVISORo(channel), 23, 16);
+	cinfo->pck_div = REG_GET(dispc, DISPC_DIVISORo(channel), 7, 0);
 
 	cinfo->lck = fck / cinfo->lck_div;
 	cinfo->pck = cinfo->lck / cinfo->pck_div;
@@ -3593,35 +3711,36 @@ int dispc_mgr_get_clock_div(struct dispc
 
 static u32 dispc_read_irqstatus(struct dispc_device *dispc)
 {
-	return dispc_read_reg(DISPC_IRQSTATUS);
+	return dispc_read_reg(dispc, DISPC_IRQSTATUS);
 }
 
 static void dispc_clear_irqstatus(struct dispc_device *dispc, u32 mask)
 {
-	dispc_write_reg(DISPC_IRQSTATUS, mask);
+	dispc_write_reg(dispc, DISPC_IRQSTATUS, mask);
 }
 
 static void dispc_write_irqenable(struct dispc_device *dispc, u32 mask)
 {
-	u32 old_mask = dispc_read_reg(DISPC_IRQENABLE);
+	u32 old_mask = dispc_read_reg(dispc, DISPC_IRQENABLE);
 
 	/* clear the irqstatus for newly enabled irqs */
 	dispc_clear_irqstatus(dispc, (mask ^ old_mask) & mask);
 
-	dispc_write_reg(DISPC_IRQENABLE, mask);
+	dispc_write_reg(dispc, DISPC_IRQENABLE, mask);
 
 	/* flush posted write */
-	dispc_read_reg(DISPC_IRQENABLE);
+	dispc_read_reg(dispc, DISPC_IRQENABLE);
 }
 
 void dispc_enable_sidle(struct dispc_device *dispc)
 {
-	REG_FLD_MOD(DISPC_SYSCONFIG, 2, 4, 3);	/* SIDLEMODE: smart idle */
+	/* SIDLEMODE: smart idle */
+	REG_FLD_MOD(dispc, DISPC_SYSCONFIG, 2, 4, 3);
 }
 
 void dispc_disable_sidle(struct dispc_device *dispc)
 {
-	REG_FLD_MOD(DISPC_SYSCONFIG, 1, 4, 3);	/* SIDLEMODE: no idle */
+	REG_FLD_MOD(dispc, DISPC_SYSCONFIG, 1, 4, 3);	/* SIDLEMODE: no idle */
 }
 
 static u32 dispc_mgr_gamma_size(struct dispc_device *dispc,
@@ -3635,10 +3754,11 @@ static u32 dispc_mgr_gamma_size(struct d
 	return gdesc->len;
 }
 
-static void dispc_mgr_write_gamma_table(enum omap_channel channel)
+static void dispc_mgr_write_gamma_table(struct dispc_device *dispc,
+					enum omap_channel channel)
 {
 	const struct dispc_gamma_desc *gdesc = &mgr_desc[channel].gamma;
-	u32 *table = dispc.gamma_table[channel];
+	u32 *table = dispc->gamma_table[channel];
 	unsigned int i;
 
 	DSSDBG("%s: channel %d\n", __func__, channel);
@@ -3651,26 +3771,26 @@ static void dispc_mgr_write_gamma_table(
 		else if (i == 0)
 			v |= 1 << 31;
 
-		dispc_write_reg(gdesc->reg, v);
+		dispc_write_reg(dispc, gdesc->reg, v);
 	}
 }
 
-static void dispc_restore_gamma_tables(void)
+static void dispc_restore_gamma_tables(struct dispc_device *dispc)
 {
 	DSSDBG("%s()\n", __func__);
 
-	if (!dispc.feat->has_gamma_table)
+	if (!dispc->feat->has_gamma_table)
 		return;
 
-	dispc_mgr_write_gamma_table(OMAP_DSS_CHANNEL_LCD);
+	dispc_mgr_write_gamma_table(dispc, OMAP_DSS_CHANNEL_LCD);
 
-	dispc_mgr_write_gamma_table(OMAP_DSS_CHANNEL_DIGIT);
+	dispc_mgr_write_gamma_table(dispc, OMAP_DSS_CHANNEL_DIGIT);
 
-	if (dispc_has_feature(FEAT_MGR_LCD2))
-		dispc_mgr_write_gamma_table(OMAP_DSS_CHANNEL_LCD2);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD2))
+		dispc_mgr_write_gamma_table(dispc, OMAP_DSS_CHANNEL_LCD2);
 
-	if (dispc_has_feature(FEAT_MGR_LCD3))
-		dispc_mgr_write_gamma_table(OMAP_DSS_CHANNEL_LCD3);
+	if (dispc_has_feature(dispc, FEAT_MGR_LCD3))
+		dispc_mgr_write_gamma_table(dispc, OMAP_DSS_CHANNEL_LCD3);
 }
 
 static const struct drm_color_lut dispc_mgr_gamma_default_lut[] = {
@@ -3723,81 +3843,82 @@ static void dispc_mgr_set_gamma(struct d
 	}
 
 	if (dispc->is_enabled)
-		dispc_mgr_write_gamma_table(channel);
+		dispc_mgr_write_gamma_table(dispc, channel);
 }
 
-static int dispc_init_gamma_tables(void)
+static int dispc_init_gamma_tables(struct dispc_device *dispc)
 {
 	int channel;
 
-	if (!dispc.feat->has_gamma_table)
+	if (!dispc->feat->has_gamma_table)
 		return 0;
 
-	for (channel = 0; channel < ARRAY_SIZE(dispc.gamma_table); channel++) {
+	for (channel = 0; channel < ARRAY_SIZE(dispc->gamma_table); channel++) {
 		const struct dispc_gamma_desc *gdesc = &mgr_desc[channel].gamma;
 		u32 *gt;
 
 		if (channel == OMAP_DSS_CHANNEL_LCD2 &&
-		    !dispc_has_feature(FEAT_MGR_LCD2))
+		    !dispc_has_feature(dispc, FEAT_MGR_LCD2))
 			continue;
 
 		if (channel == OMAP_DSS_CHANNEL_LCD3 &&
-		    !dispc_has_feature(FEAT_MGR_LCD3))
+		    !dispc_has_feature(dispc, FEAT_MGR_LCD3))
 			continue;
 
-		gt = devm_kmalloc_array(&dispc.pdev->dev, gdesc->len,
-					   sizeof(u32), GFP_KERNEL);
+		gt = devm_kmalloc_array(&dispc->pdev->dev, gdesc->len,
+					sizeof(u32), GFP_KERNEL);
 		if (!gt)
 			return -ENOMEM;
 
-		dispc.gamma_table[channel] = gt;
+		dispc->gamma_table[channel] = gt;
 
-		dispc_mgr_set_gamma(&dispc, channel, NULL, 0);
+		dispc_mgr_set_gamma(dispc, channel, NULL, 0);
 	}
 	return 0;
 }
 
-static void _omap_dispc_initial_config(void)
+static void _omap_dispc_initial_config(struct dispc_device *dispc)
 {
 	u32 l;
 
 	/* Exclusively enable DISPC_CORE_CLK and set divider to 1 */
-	if (dispc_has_feature(FEAT_CORE_CLK_DIV)) {
-		l = dispc_read_reg(DISPC_DIVISOR);
+	if (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV)) {
+		l = dispc_read_reg(dispc, DISPC_DIVISOR);
 		/* Use DISPC_DIVISOR.LCD, instead of DISPC_DIVISOR1.LCD */
 		l = FLD_MOD(l, 1, 0, 0);
 		l = FLD_MOD(l, 1, 23, 16);
-		dispc_write_reg(DISPC_DIVISOR, l);
+		dispc_write_reg(dispc, DISPC_DIVISOR, l);
 
-		dispc.core_clk_rate = dispc_fclk_rate();
+		dispc->core_clk_rate = dispc_fclk_rate(dispc);
 	}
 
 	/* Use gamma table mode, instead of palette mode */
-	if (dispc.feat->has_gamma_table)
-		REG_FLD_MOD(DISPC_CONFIG, 1, 3, 3);
+	if (dispc->feat->has_gamma_table)
+		REG_FLD_MOD(dispc, DISPC_CONFIG, 1, 3, 3);
 
 	/* For older DSS versions (FEAT_FUNCGATED) this enables
 	 * func-clock auto-gating. For newer versions
-	 * (dispc.feat->has_gamma_table) this enables tv-out gamma tables.
+	 * (dispc->feat->has_gamma_table) this enables tv-out gamma tables.
 	 */
-	if (dispc_has_feature(FEAT_FUNCGATED) || dispc.feat->has_gamma_table)
-		REG_FLD_MOD(DISPC_CONFIG, 1, 9, 9);
+	if (dispc_has_feature(dispc, FEAT_FUNCGATED) ||
+	    dispc->feat->has_gamma_table)
+		REG_FLD_MOD(dispc, DISPC_CONFIG, 1, 9, 9);
 
-	dispc_setup_color_conv_coef();
+	dispc_setup_color_conv_coef(dispc);
 
-	dispc_set_loadmode(OMAP_DSS_LOAD_FRAME_ONLY);
+	dispc_set_loadmode(dispc, OMAP_DSS_LOAD_FRAME_ONLY);
 
-	dispc_init_fifos();
+	dispc_init_fifos(dispc);
 
-	dispc_configure_burst_sizes();
+	dispc_configure_burst_sizes(dispc);
 
-	dispc_ovl_enable_zorder_planes();
+	dispc_ovl_enable_zorder_planes(dispc);
 
-	if (dispc.feat->mstandby_workaround)
-		REG_FLD_MOD(DISPC_MSTANDBY_CTRL, 1, 0, 0);
+	if (dispc->feat->mstandby_workaround)
+		REG_FLD_MOD(dispc, DISPC_MSTANDBY_CTRL, 1, 0, 0);
 
-	if (dispc_has_feature(FEAT_MFLAG))
-		dispc_init_mflag();
+	if (dispc_has_feature(dispc, FEAT_MFLAG))
+		dispc_init_mflag(dispc);
 }
 
 static const enum dispc_feature_id omap2_dispc_features_list[] = {
@@ -4316,10 +4437,12 @@ static const struct dispc_features omap5
 
 static irqreturn_t dispc_irq_handler(int irq, void *arg)
 {
-	if (!dispc.is_enabled)
+	struct dispc_device *dispc = arg;
+
+	if (!dispc->is_enabled)
 		return IRQ_NONE;
 
-	return dispc.user_handler(irq, dispc.user_data);
+	return dispc->user_handler(irq, dispc->user_data);
 }
 
 static int dispc_request_irq(struct dispc_device *dispc, irq_handler_t handler,
@@ -4436,18 +4559,19 @@ static struct i734_buf {
 	void *vaddr;
 } i734_buf;
 
-static int dispc_errata_i734_wa_init(void)
+static int dispc_errata_i734_wa_init(struct dispc_device *dispc)
 {
-	if (!dispc.feat->has_gamma_i734_bug)
+	if (!dispc->feat->has_gamma_i734_bug)
 		return 0;
 
 	i734_buf.size = i734.ovli.width * i734.ovli.height *
 		color_mode_to_bpp(i734.ovli.fourcc) / 8;
 
-	i734_buf.vaddr = dma_alloc_writecombine(&dispc.pdev->dev, i734_buf.size,
-						&i734_buf.paddr, GFP_KERNEL);
+	i734_buf.vaddr = dma_alloc_writecombine(&dispc->pdev->dev,
+						i734_buf.size, &i734_buf.paddr,
+						GFP_KERNEL);
 	if (!i734_buf.vaddr) {
-		dev_err(&dispc.pdev->dev, "%s: dma_alloc_writecombine failed",
+		dev_err(&dispc->pdev->dev, "%s: dma_alloc_writecombine failed",
 			__func__);
 		return -ENOMEM;
 	}
@@ -4455,73 +4579,73 @@ static int dispc_errata_i734_wa_init(voi
 	return 0;
 }
 
-static void dispc_errata_i734_wa_fini(void)
+static void dispc_errata_i734_wa_fini(struct dispc_device *dispc)
 {
-	if (!dispc.feat->has_gamma_i734_bug)
+	if (!dispc->feat->has_gamma_i734_bug)
 		return;
 
-	dma_free_writecombine(&dispc.pdev->dev, i734_buf.size, i734_buf.vaddr,
+	dma_free_writecombine(&dispc->pdev->dev, i734_buf.size, i734_buf.vaddr,
 			      i734_buf.paddr);
 }
 
-static void dispc_errata_i734_wa(void)
+static void dispc_errata_i734_wa(struct dispc_device *dispc)
 {
-	u32 framedone_irq = dispc_mgr_get_framedone_irq(&dispc,
+	u32 framedone_irq = dispc_mgr_get_framedone_irq(dispc,
 							OMAP_DSS_CHANNEL_LCD);
 	struct omap_overlay_info ovli;
 	struct dss_lcd_mgr_config lcd_conf;
 	u32 gatestate;
 	unsigned int count;
 
-	if (!dispc.feat->has_gamma_i734_bug)
+	if (!dispc->feat->has_gamma_i734_bug)
 		return;
 
-	gatestate = REG_GET(DISPC_CONFIG, 8, 4);
+	gatestate = REG_GET(dispc, DISPC_CONFIG, 8, 4);
 
 	ovli = i734.ovli;
 	ovli.paddr = i734_buf.paddr;
 	lcd_conf = i734.lcd_conf;
 
 	/* Gate all LCD1 outputs */
-	REG_FLD_MOD(DISPC_CONFIG, 0x1f, 8, 4);
+	REG_FLD_MOD(dispc, DISPC_CONFIG, 0x1f, 8, 4);
 
 	/* Setup and enable GFX plane */
-	dispc_ovl_setup(&dispc, OMAP_DSS_GFX, &ovli, &i734.vm, false,
+	dispc_ovl_setup(dispc, OMAP_DSS_GFX, &ovli, &i734.vm, false,
 			OMAP_DSS_CHANNEL_LCD);
-	dispc_ovl_enable(&dispc, OMAP_DSS_GFX, true);
+	dispc_ovl_enable(dispc, OMAP_DSS_GFX, true);
 
 	/* Set up and enable display manager for LCD1 */
-	dispc_mgr_setup(&dispc, OMAP_DSS_CHANNEL_LCD, &i734.mgri);
-	dispc_calc_clock_rates(&dispc, dss_get_dispc_clk_rate(dispc.dss),
+	dispc_mgr_setup(dispc, OMAP_DSS_CHANNEL_LCD, &i734.mgri);
+	dispc_calc_clock_rates(dispc, dss_get_dispc_clk_rate(dispc->dss),
 			       &lcd_conf.clock_info);
-	dispc_mgr_set_lcd_config(&dispc, OMAP_DSS_CHANNEL_LCD, &lcd_conf);
-	dispc_mgr_set_timings(&dispc, OMAP_DSS_CHANNEL_LCD, &i734.vm);
+	dispc_mgr_set_lcd_config(dispc, OMAP_DSS_CHANNEL_LCD, &lcd_conf);
+	dispc_mgr_set_timings(dispc, OMAP_DSS_CHANNEL_LCD, &i734.vm);
 
-	dispc_clear_irqstatus(&dispc, framedone_irq);
+	dispc_clear_irqstatus(dispc, framedone_irq);
 
 	/* Enable and shut the channel to produce just one frame */
-	dispc_mgr_enable(&dispc, OMAP_DSS_CHANNEL_LCD, true);
-	dispc_mgr_enable(&dispc, OMAP_DSS_CHANNEL_LCD, false);
+	dispc_mgr_enable(dispc, OMAP_DSS_CHANNEL_LCD, true);
+	dispc_mgr_enable(dispc, OMAP_DSS_CHANNEL_LCD, false);
 
 	/* Busy wait for framedone. We can't fiddle with irq handlers
 	 * in PM resume. Typically the loop runs less than 5 times and
 	 * waits less than a micro second.
 	 */
 	count = 0;
-	while (!(dispc_read_irqstatus(&dispc) & framedone_irq)) {
+	while (!(dispc_read_irqstatus(dispc) & framedone_irq)) {
 		if (count++ > 10000) {
-			dev_err(&dispc.pdev->dev, "%s: framedone timeout\n",
+			dev_err(&dispc->pdev->dev, "%s: framedone timeout\n",
 				__func__);
 			break;
 		}
 	}
-	dispc_ovl_enable(&dispc, OMAP_DSS_GFX, false);
+	dispc_ovl_enable(dispc, OMAP_DSS_GFX, false);
 
 	/* Clear all irq bits before continuing */
-	dispc_clear_irqstatus(&dispc, 0xffffffff);
+	dispc_clear_irqstatus(dispc, 0xffffffff);
 
 	/* Restore the original state to LCD1 output gates */
-	REG_FLD_MOD(DISPC_CONFIG, gatestate, 8, 4);
+	REG_FLD_MOD(dispc, DISPC_CONFIG, gatestate, 8, 4);
 }
 
 static const struct dispc_ops dispc_ops = {
@@ -4583,15 +4707,21 @@ static int dispc_bind(struct device *dev
 	struct platform_device *pdev = to_platform_device(dev);
 	const struct soc_device_attribute *soc;
 	struct dss_device *dss = dss_get_device(master);
+	struct dispc_device *dispc;
 	u32 rev;
 	int r = 0;
 	struct resource *dispc_mem;
 	struct device_node *np = pdev->dev.of_node;
 
-	dispc.pdev = pdev;
-	dispc.dss = dss;
+	dispc = kzalloc(sizeof(*dispc), GFP_KERNEL);
+	if (!dispc)
+		return -ENOMEM;
+
+	dispc->pdev = pdev;
+	platform_set_drvdata(pdev, dispc);
+	dispc->dss = dss;
 
-	spin_lock_init(&dispc.control_lock);
+	spin_lock_init(&dispc->control_lock);
 
 	/*
 	 * The OMAP3-based models can't be told apart using the compatible
@@ -4599,82 +4729,92 @@ static int dispc_bind(struct device *dev
 	 */
 	soc = soc_device_match(dispc_soc_devices);
 	if (soc)
-		dispc.feat = soc->data;
+		dispc->feat = soc->data;
 	else
-		dispc.feat = of_match_device(dispc_of_match, &pdev->dev)->data;
+		dispc->feat = of_match_device(dispc_of_match, &pdev->dev)->data;
 
-	r = dispc_errata_i734_wa_init();
+	r = dispc_errata_i734_wa_init(dispc);
 	if (r)
-		return r;
+		goto err_free;
 
-	dispc_mem = platform_get_resource(dispc.pdev, IORESOURCE_MEM, 0);
-	dispc.base = devm_ioremap_resource(&pdev->dev, dispc_mem);
-	if (IS_ERR(dispc.base))
-		return PTR_ERR(dispc.base);
+	dispc_mem = platform_get_resource(dispc->pdev, IORESOURCE_MEM, 0);
+	dispc->base = devm_ioremap_resource(&pdev->dev, dispc_mem);
+	if (IS_ERR(dispc->base)) {
+		r = PTR_ERR(dispc->base);
+		goto err_free;
+	}
 
-	dispc.irq = platform_get_irq(dispc.pdev, 0);
-	if (dispc.irq < 0) {
+	dispc->irq = platform_get_irq(dispc->pdev, 0);
+	if (dispc->irq < 0) {
 		DSSERR("platform_get_irq failed\n");
-		return -ENODEV;
+		r = -ENODEV;
+		goto err_free;
 	}
 
 	if (np && of_property_read_bool(np, "syscon-pol")) {
-		dispc.syscon_pol = syscon_regmap_lookup_by_phandle(np, "syscon-pol");
-		if (IS_ERR(dispc.syscon_pol)) {
+		dispc->syscon_pol = syscon_regmap_lookup_by_phandle(np, "syscon-pol");
+		if (IS_ERR(dispc->syscon_pol)) {
 			dev_err(&pdev->dev, "failed to get syscon-pol regmap\n");
-			return PTR_ERR(dispc.syscon_pol);
+			r = PTR_ERR(dispc->syscon_pol);
+			goto err_free;
 		}
 
 		if (of_property_read_u32_index(np, "syscon-pol", 1,
-				&dispc.syscon_pol_offset)) {
+				&dispc->syscon_pol_offset)) {
 			dev_err(&pdev->dev, "failed to get syscon-pol offset\n");
-			return -EINVAL;
+			r = -EINVAL;
+			goto err_free;
 		}
 	}
 
-	r = dispc_init_gamma_tables();
+	r = dispc_init_gamma_tables(dispc);
 	if (r)
-		return r;
+		goto err_free;
 
 	pm_runtime_enable(&pdev->dev);
 
-	r = dispc_runtime_get(&dispc);
+	r = dispc_runtime_get(dispc);
 	if (r)
 		goto err_runtime_get;
 
-	_omap_dispc_initial_config();
+	_omap_dispc_initial_config(dispc);
 
-	rev = dispc_read_reg(DISPC_REVISION);
+	rev = dispc_read_reg(dispc, DISPC_REVISION);
 	dev_dbg(&pdev->dev, "OMAP DISPC rev %d.%d\n",
 	       FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));
 
-	dispc_runtime_put(&dispc);
+	dispc_runtime_put(dispc);
 
-	dss->dispc = &dispc;
+	dss->dispc = dispc;
 	dss->dispc_ops = &dispc_ops;
 
-	dispc.debugfs = dss_debugfs_create_file(dss, "dispc", dispc_dump_regs,
-						&dispc);
+	dispc->debugfs = dss_debugfs_create_file(dss, "dispc", dispc_dump_regs,
+						 dispc);
 
 	return 0;
 
 err_runtime_get:
 	pm_runtime_disable(&pdev->dev);
+err_free:
+	kfree(dispc);
 	return r;
 }
 
 static void dispc_unbind(struct device *dev, struct device *master, void *data)
 {
-	struct dss_device *dss = dispc.dss;
+	struct dispc_device *dispc = dev_get_drvdata(dev);
+	struct dss_device *dss = dispc->dss;
 
-	dss_debugfs_remove_file(dispc.debugfs);
+	dss_debugfs_remove_file(dispc->debugfs);
 
 	dss->dispc = NULL;
 	dss->dispc_ops = NULL;
 
 	pm_runtime_disable(dev);
 
-	dispc_errata_i734_wa_fini();
+	dispc_errata_i734_wa_fini(dispc);
+
+	kfree(dispc);
 }
 
 static const struct component_ops dispc_component_ops = {
@@ -4695,36 +4835,40 @@ static int dispc_remove(struct platform_
 
 static int dispc_runtime_suspend(struct device *dev)
 {
-	dispc.is_enabled = false;
+	struct dispc_device *dispc = dev_get_drvdata(dev);
+
+	dispc->is_enabled = false;
 	/* ensure the dispc_irq_handler sees the is_enabled value */
 	smp_wmb();
 	/* wait for current handler to finish before turning the DISPC off */
-	synchronize_irq(dispc.irq);
+	synchronize_irq(dispc->irq);
 
-	dispc_save_context();
+	dispc_save_context(dispc);
 
 	return 0;
 }
 
 static int dispc_runtime_resume(struct device *dev)
 {
+	struct dispc_device *dispc = dev_get_drvdata(dev);
+
 	/*
 	 * The reset value for load mode is 0 (OMAP_DSS_LOAD_CLUT_AND_FRAME)
 	 * but we always initialize it to 2 (OMAP_DSS_LOAD_FRAME_ONLY) in
 	 * _omap_dispc_initial_config(). We can thus use it to detect if
 	 * we have lost register context.
 	 */
-	if (REG_GET(DISPC_CONFIG, 2, 1) != OMAP_DSS_LOAD_FRAME_ONLY) {
-		_omap_dispc_initial_config();
+	if (REG_GET(dispc, DISPC_CONFIG, 2, 1) != OMAP_DSS_LOAD_FRAME_ONLY) {
+		_omap_dispc_initial_config(dispc);
 
-		dispc_errata_i734_wa();
+		dispc_errata_i734_wa(dispc);
 
-		dispc_restore_context();
+		dispc_restore_context(dispc);
 
-		dispc_restore_gamma_tables();
+		dispc_restore_gamma_tables(dispc);
 	}
 
-	dispc.is_enabled = true;
+	dispc->is_enabled = true;
 	/* ensure the dispc_irq_handler sees the is_enabled value */
 	smp_wmb();
 
