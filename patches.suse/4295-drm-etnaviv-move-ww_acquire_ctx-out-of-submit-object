From: Lucas Stach <l.stach@pengutronix.de>
Date: Fri, 24 Nov 2017 14:34:46 +0100
Subject: drm/etnaviv: move ww_acquire_ctx out of submit object
Git-commit: 08301d73f27d59e2ac45411ed7bb2235d68190db
Patch-mainline: v4.16-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

The acquire_ctx is special in that it needs to be released from the same
thread as has been used to initialize it. This collides with the intention to
extend the submit lifetime beyond the gem_submit function with potentially
other threads doing the final cleanup.

Move the ww_acquire_ctx to the function local stack as suggested in the
documentation.

Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
Reviewed-by: Philipp Zabel <p.zabel@pengutronix.de>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/etnaviv/etnaviv_gem.h        |    1 -
 drivers/gpu/drm/etnaviv/etnaviv_gem_submit.c |   22 +++++++++++++---------
 2 files changed, 13 insertions(+), 10 deletions(-)

--- a/drivers/gpu/drm/etnaviv/etnaviv_gem.h
+++ b/drivers/gpu/drm/etnaviv/etnaviv_gem.h
@@ -102,7 +102,6 @@ struct etnaviv_gem_submit_bo {
  */
 struct etnaviv_gem_submit {
 	struct etnaviv_gpu *gpu;
-	struct ww_acquire_ctx ticket;
 	struct dma_fence *out_fence, *in_fence;
 	u32 flags;
 	unsigned int nr_bos;
--- a/drivers/gpu/drm/etnaviv/etnaviv_gem_submit.c
+++ b/drivers/gpu/drm/etnaviv/etnaviv_gem_submit.c
@@ -44,8 +44,6 @@ static struct etnaviv_gem_submit *submit
 
 	submit->gpu = gpu;
 
-	ww_acquire_init(&submit->ticket, &reservation_ww_class);
-
 	return submit;
 }
 
@@ -107,7 +105,8 @@ static void submit_unlock_object(struct
 	}
 }
 
-static int submit_lock_objects(struct etnaviv_gem_submit *submit)
+static int submit_lock_objects(struct etnaviv_gem_submit *submit,
+		struct ww_acquire_ctx *ticket)
 {
 	int contended, slow_locked = -1, i, ret = 0;
 
@@ -122,7 +121,7 @@ retry:
 
 		if (!(submit->bos[i].flags & BO_LOCKED)) {
 			ret = ww_mutex_lock_interruptible(&etnaviv_obj->resv->lock,
-					&submit->ticket);
+							  ticket);
 			if (ret == -EALREADY)
 				DRM_ERROR("BO at index %u already on submit list\n",
 					  i);
@@ -132,7 +131,7 @@ retry:
 		}
 	}
 
-	ww_acquire_done(&submit->ticket);
+	ww_acquire_done(ticket);
 
 	return 0;
 
@@ -150,7 +149,7 @@ fail:
 
 		/* we lost out in a seqno race, lock and retry.. */
 		ret = ww_mutex_lock_slow_interruptible(&etnaviv_obj->resv->lock,
-				&submit->ticket);
+						       ticket);
 		if (!ret) {
 			submit->bos[contended].flags |= BO_LOCKED;
 			slow_locked = contended;
@@ -361,7 +360,6 @@ static void submit_cleanup(struct etnavi
 		drm_gem_object_put_unlocked(&etnaviv_obj->base);
 	}
 
-	ww_acquire_fini(&submit->ticket);
 	if (submit->in_fence)
 		dma_fence_put(submit->in_fence);
 	if (submit->out_fence)
@@ -381,6 +379,7 @@ int etnaviv_ioctl_gem_submit(struct drm_
 	struct etnaviv_cmdbuf *cmdbuf;
 	struct etnaviv_gpu *gpu;
 	struct sync_file *sync_file = NULL;
+	struct ww_acquire_ctx ticket;
 	int out_fence_fd = -1;
 	void *stream;
 	int ret;
@@ -466,10 +465,12 @@ int etnaviv_ioctl_gem_submit(struct drm_
 		}
 	}
 
+	ww_acquire_init(&ticket, &reservation_ww_class);
+
 	submit = submit_create(dev, gpu, args->nr_bos);
 	if (!submit) {
 		ret = -ENOMEM;
-		goto err_submit_cmds;
+		goto err_submit_ww_acquire;
 	}
 
 	submit->flags = args->flags;
@@ -478,7 +479,7 @@ int etnaviv_ioctl_gem_submit(struct drm_
 	if (ret)
 		goto err_submit_objects;
 
-	ret = submit_lock_objects(submit);
+	ret = submit_lock_objects(submit, &ticket);
 	if (ret)
 		goto err_submit_objects;
 
@@ -545,6 +546,9 @@ int etnaviv_ioctl_gem_submit(struct drm_
 err_submit_objects:
 	submit_cleanup(submit);
 
+err_submit_ww_acquire:
+	ww_acquire_fini(&ticket);
+
 err_submit_cmds:
 	if (ret && (out_fence_fd >= 0))
 		put_unused_fd(out_fence_fd);
