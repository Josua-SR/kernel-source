From: Edwin Peer <edwin.peer@broadcom.com>
Date: Mon, 4 May 2020 04:50:32 -0400
Subject: bnxt_en: refactor ethtool firmware reset types
Patch-mainline: v5.8-rc1
Git-commit: 94f17e89c956553606d5c7cf4f40ce6012529d48
References: jsc#SLE-15075

The case statement in bnxt_firmware_reset() dangerously mixes types.
This patch separates the application processor and whole chip resets
from the rest such that the selection is performed on a pure type.

Signed-off-by: Edwin Peer <edwin.peer@broadcom.com>
Signed-off-by: Michael Chan <michael.chan@broadcom.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c |   38 ++++++++++++++--------
 1 file changed, 25 insertions(+), 13 deletions(-)

--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
@@ -1769,10 +1769,10 @@ static int bnxt_hwrm_firmware_reset(stru
 	return rc;
 }
 
-static int bnxt_firmware_reset(struct net_device *dev, u16 dir_type)
+static int bnxt_firmware_reset(struct net_device *dev,
+			       enum bnxt_nvm_directory_type dir_type)
 {
 	u8 self_reset = FW_RESET_REQ_SELFRST_STATUS_SELFRSTNONE;
-	struct bnxt *bp = netdev_priv(dev);
 	u8 proc_type, flags = 0;
 
 	/* TODO: Address self-reset of APE/KONG/BONO/TANG or ungraceful reset */
@@ -1799,15 +1799,6 @@ static int bnxt_firmware_reset(struct ne
 	case BNX_DIR_TYPE_BONO_PATCH:
 		proc_type = FW_RESET_REQ_EMBEDDED_PROC_TYPE_ROCE;
 		break;
-	case BNXT_FW_RESET_CHIP:
-		proc_type = FW_RESET_REQ_EMBEDDED_PROC_TYPE_CHIP;
-		self_reset = FW_RESET_REQ_SELFRST_STATUS_SELFRSTASAP;
-		if (bp->fw_cap & BNXT_FW_CAP_HOT_RESET)
-			flags = FW_RESET_REQ_FLAGS_RESET_GRACEFUL;
-		break;
-	case BNXT_FW_RESET_AP:
-		proc_type = FW_RESET_REQ_EMBEDDED_PROC_TYPE_AP;
-		break;
 	default:
 		return -EINVAL;
 	}
@@ -1815,6 +1806,27 @@ static int bnxt_firmware_reset(struct ne
 	return bnxt_hwrm_firmware_reset(dev, proc_type, self_reset, flags);
 }
 
+static int bnxt_firmware_reset_chip(struct net_device *dev)
+{
+	struct bnxt *bp = netdev_priv(dev);
+	u8 flags = 0;
+
+	if (bp->fw_cap & BNXT_FW_CAP_HOT_RESET)
+		flags = FW_RESET_REQ_FLAGS_RESET_GRACEFUL;
+
+	return bnxt_hwrm_firmware_reset(dev,
+					FW_RESET_REQ_EMBEDDED_PROC_TYPE_CHIP,
+					FW_RESET_REQ_SELFRST_STATUS_SELFRSTASAP,
+					flags);
+}
+
+static int bnxt_firmware_reset_ap(struct net_device *dev)
+{
+	return bnxt_hwrm_firmware_reset(dev, FW_RESET_REQ_EMBEDDED_PROC_TYPE_AP,
+					FW_RESET_REQ_SELFRST_STATUS_SELFRSTNONE,
+					0);
+}
+
 static int bnxt_flash_firmware(struct net_device *dev,
 			       u16 dir_type,
 			       const u8 *fw_data,
@@ -3008,7 +3020,7 @@ static int bnxt_reset(struct net_device
 		if (bp->hwrm_spec_code < 0x10803)
 			return -EOPNOTSUPP;
 
-		rc = bnxt_firmware_reset(dev, BNXT_FW_RESET_CHIP);
+		rc = bnxt_firmware_reset_chip(dev);
 		if (!rc) {
 			netdev_info(dev, "Reset request successful.\n");
 			if (!(bp->fw_cap & BNXT_FW_CAP_HOT_RESET))
@@ -3020,7 +3032,7 @@ static int bnxt_reset(struct net_device
 		if (bp->hwrm_spec_code < 0x10803)
 			return -EOPNOTSUPP;
 
-		rc = bnxt_firmware_reset(dev, BNXT_FW_RESET_AP);
+		rc = bnxt_firmware_reset_ap(dev);
 		if (!rc) {
 			netdev_info(dev, "Reset Application Processor request successful.\n");
 			*flags = 0;
