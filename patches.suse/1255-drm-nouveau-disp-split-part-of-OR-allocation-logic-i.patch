From f20e4963e77818f8af850871a4677d368c3f385d Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Wed, 3 Jun 2020 11:40:47 +1000
Subject: drm/nouveau/disp: split part of OR allocation logic into a function
Git-commit: f24b6ae19fa257ea9b10a9389d0b7046b3efd97c
Patch-mainline: v5.8-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

No logical changes here, this is just moving the code to make the
changes in the next commit more obvious.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 .../gpu/drm/nouveau/nvkm/engine/disp/outp.c   | 63 +++++++++++--------
 1 file changed, 37 insertions(+), 26 deletions(-)

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index 1b1c6ff0e1bc..b56224558a05 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -111,37 +111,18 @@ nvkm_outp_acquire_ior(struct nvkm_outp *outp, u8 user, struct nvkm_ior *ior)
 	return 0;
 }
 
-int
-nvkm_outp_acquire(struct nvkm_outp *outp, u8 user, bool hda)
+static inline int
+nvkm_outp_acquire_hda(struct nvkm_outp *outp, enum nvkm_ior_type type,
+		      u8 user, bool hda)
 {
-	struct nvkm_ior *ior = outp->ior;
-	enum nvkm_ior_proto proto;
-	enum nvkm_ior_type type;
-
-	OUTP_TRACE(outp, "acquire %02x |= %02x %p", outp->acquired, user, ior);
-	if (ior) {
-		outp->acquired |= user;
-		return 0;
-	}
-
-	/* Lookup a compatible, and unused, OR to assign to the device. */
-	proto = nvkm_outp_xlat(outp, &type);
-	if (proto == UNKNOWN)
-		return -ENOSYS;
-
-	/* Deal with panels requiring identity-mapped SOR assignment. */
-	if (outp->identity) {
-		ior = nvkm_ior_find(outp->disp, SOR, ffs(outp->info.or) - 1);
-		if (WARN_ON(!ior))
-			return -ENOSPC;
-		return nvkm_outp_acquire_ior(outp, user, ior);
-	}
+	struct nvkm_ior *ior;
 
 	/* First preference is to reuse the OR that is currently armed
 	 * on HW, if any, in order to prevent unnecessary switching.
 	 */
 	list_for_each_entry(ior, &outp->disp->ior, head) {
-		if (!ior->identity && !ior->asy.outp && ior->arm.outp == outp)
+		if (!ior->identity &&
+		    !ior->asy.outp && ior->arm.outp == outp)
 			return nvkm_outp_acquire_ior(outp, user, ior);
 	}
 
@@ -157,7 +138,8 @@ nvkm_outp_acquire(struct nvkm_outp *outp, u8 user, bool hda)
 	 * but will be released during the next modeset.
 	 */
 	list_for_each_entry(ior, &outp->disp->ior, head) {
-		if (!ior->identity && !ior->asy.outp && ior->type == type &&
+		if (!ior->identity &&
+		    !ior->asy.outp && ior->type == type &&
 		    (ior->func->route.set || ior->id == __ffs(outp->info.or)))
 			return nvkm_outp_acquire_ior(outp, user, ior);
 	}
@@ -165,6 +147,35 @@ nvkm_outp_acquire(struct nvkm_outp *outp, u8 user, bool hda)
 	return -ENOSPC;
 }
 
+int
+nvkm_outp_acquire(struct nvkm_outp *outp, u8 user, bool hda)
+{
+	struct nvkm_ior *ior = outp->ior;
+	enum nvkm_ior_proto proto;
+	enum nvkm_ior_type type;
+
+	OUTP_TRACE(outp, "acquire %02x |= %02x %p", outp->acquired, user, ior);
+	if (ior) {
+		outp->acquired |= user;
+		return 0;
+	}
+
+	/* Lookup a compatible, and unused, OR to assign to the device. */
+	proto = nvkm_outp_xlat(outp, &type);
+	if (proto == UNKNOWN)
+		return -ENOSYS;
+
+	/* Deal with panels requiring identity-mapped SOR assignment. */
+	if (outp->identity) {
+		ior = nvkm_ior_find(outp->disp, SOR, ffs(outp->info.or) - 1);
+		if (WARN_ON(!ior))
+			return -ENOSPC;
+		return nvkm_outp_acquire_ior(outp, user, ior);
+	}
+
+	return nvkm_outp_acquire_hda(outp, type, user, true);
+}
+
 void
 nvkm_outp_fini(struct nvkm_outp *outp)
 {
-- 
2.28.0

