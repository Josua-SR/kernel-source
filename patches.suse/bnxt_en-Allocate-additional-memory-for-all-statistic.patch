From: Michael Chan <michael.chan@broadcom.com>
Date: Mon, 27 Jul 2020 05:40:40 -0400
Subject: bnxt_en: Allocate additional memory for all statistics blocks.
Patch-mainline: v5.9-rc1
Git-commit: a37120b22e540b4eb068addf9be3f63b64dca690
References: jsc#SLE-15075

Some of these DMAed hardware counters are not full 64-bit counters and
so we need to accumulate them as they overflow.  Allocate copies of these
DMA statistics memory blocks with the same size for accumulation.  The
hardware counter widths are also counter specific so we allocate
memory for masks that correspond to each counter.

Reviewed-by: Vasundhara Volam <vasundhara-v.volam@broadcom.com>
Signed-off-by: Michael Chan <michael.chan@broadcom.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/broadcom/bnxt/bnxt.c |   29 ++++++++++++++++++++++++-----
 drivers/net/ethernet/broadcom/bnxt/bnxt.h |    2 ++
 2 files changed, 26 insertions(+), 5 deletions(-)

--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -3717,6 +3717,10 @@ static int bnxt_alloc_hwrm_short_cmd_req
 
 static void bnxt_free_stats_mem(struct bnxt *bp, struct bnxt_stats_mem *stats)
 {
+	kfree(stats->hw_masks);
+	stats->hw_masks = NULL;
+	kfree(stats->sw_stats);
+	stats->sw_stats = NULL;
 	if (stats->hw_stats) {
 		dma_free_coherent(&bp->pdev->dev, stats->len, stats->hw_stats,
 				  stats->hw_stats_map);
@@ -3724,7 +3728,8 @@ static void bnxt_free_stats_mem(struct b
 	}
 }
 
-static int bnxt_alloc_stats_mem(struct bnxt *bp, struct bnxt_stats_mem *stats)
+static int bnxt_alloc_stats_mem(struct bnxt *bp, struct bnxt_stats_mem *stats,
+				bool alloc_masks)
 {
 	stats->hw_stats = dma_alloc_coherent(&bp->pdev->dev, stats->len,
 					     &stats->hw_stats_map, GFP_KERNEL);
@@ -3732,7 +3737,21 @@ static int bnxt_alloc_stats_mem(struct b
 		return -ENOMEM;
 
 	memset(stats->hw_stats, 0, stats->len);
+
+	stats->sw_stats = kzalloc(stats->len, GFP_KERNEL);
+	if (!stats->sw_stats)
+		goto stats_mem_err;
+
+	if (alloc_masks) {
+		stats->hw_masks = kzalloc(stats->len, GFP_KERNEL);
+		if (!stats->hw_masks)
+			goto stats_mem_err;
+	}
 	return 0;
+
+stats_mem_err:
+	bnxt_free_stats_mem(bp, stats);
+	return -ENOMEM;
 }
 
 static void bnxt_free_port_stats(struct bnxt *bp)
@@ -3772,7 +3791,7 @@ static int bnxt_alloc_stats(struct bnxt
 		struct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;
 
 		cpr->stats.len = size;
-		rc = bnxt_alloc_stats_mem(bp, &cpr->stats);
+		rc = bnxt_alloc_stats_mem(bp, &cpr->stats, !i);
 		if (rc)
 			return rc;
 
@@ -3786,7 +3805,7 @@ static int bnxt_alloc_stats(struct bnxt
 		goto alloc_ext_stats;
 
 	bp->port_stats.len = BNXT_PORT_STATS_SIZE;
-	rc = bnxt_alloc_stats_mem(bp, &bp->port_stats);
+	rc = bnxt_alloc_stats_mem(bp, &bp->port_stats, true);
 	if (rc)
 		return rc;
 
@@ -3802,7 +3821,7 @@ alloc_ext_stats:
 		goto alloc_tx_ext_stats;
 
 	bp->rx_port_stats_ext.len = sizeof(struct rx_port_stats_ext);
-	rc = bnxt_alloc_stats_mem(bp, &bp->rx_port_stats_ext);
+	rc = bnxt_alloc_stats_mem(bp, &bp->rx_port_stats_ext, true);
 	/* Extended stats are optional */
 	if (rc)
 		return 0;
@@ -3814,7 +3833,7 @@ alloc_tx_ext_stats:
 	if (bp->hwrm_spec_code >= 0x10902 ||
 	    (bp->fw_cap & BNXT_FW_CAP_EXT_STATS_SUPPORTED)) {
 		bp->tx_port_stats_ext.len = sizeof(struct tx_port_stats_ext);
-		rc = bnxt_alloc_stats_mem(bp, &bp->tx_port_stats_ext);
+		rc = bnxt_alloc_stats_mem(bp, &bp->tx_port_stats_ext, true);
 		/* Extended stats are optional */
 		if (rc)
 			return 0;
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@ -918,6 +918,8 @@ struct bnxt_sw_stats {
 };
 
 struct bnxt_stats_mem {
+	u64		*sw_stats;
+	u64		*hw_masks;
 	void		*hw_stats;
 	dma_addr_t	hw_stats_map;
 	int		len;
