From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Fri, 21 Apr 2017 00:33:50 +0300
Subject: drm: omapdrm: Remove remap argument to omap_gem_get_paddr()
Git-commit: aa0408bcb1b8c2c5941b6e0e7ce0ad2b733bb971
Patch-mainline: v4.13-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

The function is always called with the remap argument set to true.
Hardcode that behaviour and remove it.

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/omapdrm/omap_drv.h        |    3 +--
 drivers/gpu/drm/omapdrm/omap_fb.c         |    2 +-
 drivers/gpu/drm/omapdrm/omap_fbdev.c      |    2 +-
 drivers/gpu/drm/omapdrm/omap_gem.c        |   10 ++++------
 drivers/gpu/drm/omapdrm/omap_gem_dmabuf.c |    2 +-
 5 files changed, 8 insertions(+), 11 deletions(-)

--- a/drivers/gpu/drm/omapdrm/omap_drv.h
+++ b/drivers/gpu/drm/omapdrm/omap_drv.h
@@ -188,8 +188,7 @@ int omap_gem_roll(struct drm_gem_object
 void omap_gem_cpu_sync(struct drm_gem_object *obj, int pgoff);
 void omap_gem_dma_sync(struct drm_gem_object *obj,
 		enum dma_data_direction dir);
-int omap_gem_get_paddr(struct drm_gem_object *obj,
-		dma_addr_t *paddr, bool remap);
+int omap_gem_get_paddr(struct drm_gem_object *obj, dma_addr_t *paddr);
 void omap_gem_put_paddr(struct drm_gem_object *obj);
 int omap_gem_get_pages(struct drm_gem_object *obj, struct page ***pages,
 		bool remap);
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -258,7 +258,7 @@ int omap_framebuffer_pin(struct drm_fram
 
 	for (i = 0; i < n; i++) {
 		struct plane *plane = &omap_fb->planes[i];
-		ret = omap_gem_get_paddr(plane->bo, &plane->paddr, true);
+		ret = omap_gem_get_paddr(plane->bo, &plane->paddr);
 		if (ret)
 			goto fail;
 		omap_gem_dma_sync(plane->bo, DMA_TO_DEVICE);
--- a/drivers/gpu/drm/omapdrm/omap_fbdev.c
+++ b/drivers/gpu/drm/omapdrm/omap_fbdev.c
@@ -162,7 +162,7 @@ static int omap_fbdev_create(struct drm_
 	 * to it).  Then we just need to be sure that we are able to re-
 	 * pin it in case of an opps.
 	 */
-	ret = omap_gem_get_paddr(fbdev->bo, &paddr, true);
+	ret = omap_gem_get_paddr(fbdev->bo, &paddr);
 	if (ret) {
 		dev_err(dev->dev,
 			"could not map (paddr)!  Skipping framebuffer alloc\n");
--- a/drivers/gpu/drm/omapdrm/omap_gem.c
+++ b/drivers/gpu/drm/omapdrm/omap_gem.c
@@ -784,12 +784,10 @@ void omap_gem_dma_sync(struct drm_gem_ob
 	}
 }
 
-/* Get physical address for DMA.. if 'remap' is true, and the buffer is not
- * already contiguous, remap it to pin in physically contiguous memory.. (ie.
- * map in TILER)
+/* Get physical address for DMA.. if the buffer is not already contiguous, remap
+ * it to pin in physically contiguous memory.. (ie. map in TILER)
  */
-int omap_gem_get_paddr(struct drm_gem_object *obj,
-		dma_addr_t *paddr, bool remap)
+int omap_gem_get_paddr(struct drm_gem_object *obj, dma_addr_t *paddr)
 {
 	struct omap_drm_private *priv = obj->dev->dev_private;
 	struct omap_gem_object *omap_obj = to_omap_bo(obj);
@@ -797,7 +795,7 @@ int omap_gem_get_paddr(struct drm_gem_ob
 
 	mutex_lock(&obj->dev->struct_mutex);
 
-	if (!is_contiguous(omap_obj) && remap && priv->has_dmm) {
+	if (!is_contiguous(omap_obj) && priv->has_dmm) {
 		if (omap_obj->paddr_cnt == 0) {
 			struct page **pages;
 			uint32_t npages = obj->size >> PAGE_SHIFT;
--- a/drivers/gpu/drm/omapdrm/omap_gem_dmabuf.c
+++ b/drivers/gpu/drm/omapdrm/omap_gem_dmabuf.c
@@ -41,7 +41,7 @@ static struct sg_table *omap_gem_map_dma
 	/* camera, etc, need physically contiguous.. but we need a
 	 * better way to know this..
 	 */
-	ret = omap_gem_get_paddr(obj, &paddr, true);
+	ret = omap_gem_get_paddr(obj, &paddr);
 	if (ret)
 		goto out;
 
