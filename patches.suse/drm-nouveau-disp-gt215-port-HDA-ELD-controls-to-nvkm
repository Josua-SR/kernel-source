From 409b9e54727e700ab8dd15a1e29226eda1e04cdb Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Fri, 19 May 2017 23:59:35 +1000
Subject: [PATCH] drm/nouveau/disp/gt215-: port HDA ELD controls to nvkm_ior
Git-commit: 409b9e54727e700ab8dd15a1e29226eda1e04cdb
Patch-mainline: v4.13-rc1
References: bsc#1095094

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/nouveau/nvkm/engine/disp/gf119.c    |    4 -
 drivers/gpu/drm/nouveau/nvkm/engine/disp/gk104.c    |    4 -
 drivers/gpu/drm/nouveau/nvkm/engine/disp/gk110.c    |    4 -
 drivers/gpu/drm/nouveau/nvkm/engine/disp/gm107.c    |    4 -
 drivers/gpu/drm/nouveau/nvkm/engine/disp/gm200.c    |    1 
 drivers/gpu/drm/nouveau/nvkm/engine/disp/gp100.c    |    1 
 drivers/gpu/drm/nouveau/nvkm/engine/disp/gp102.c    |    1 
 drivers/gpu/drm/nouveau/nvkm/engine/disp/gt215.c    |    4 -
 drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c |   77 ++++++--------------
 drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagt215.c |   76 ++++++-------------
 drivers/gpu/drm/nouveau/nvkm/engine/disp/ior.h      |   15 +++
 drivers/gpu/drm/nouveau/nvkm/engine/disp/mcp89.c    |    4 -
 drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.h     |    8 --
 drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c |   36 ++++++++-
 drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgf119.c |   21 +++++
 drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgk104.c |    5 +
 drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgm107.c |    5 +
 drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgm200.c |    5 +
 drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgt215.c |   21 +++++
 drivers/gpu/drm/nouveau/nvkm/engine/disp/sormcp89.c |    5 +
 20 files changed, 163 insertions(+), 138 deletions(-)

--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/gf119.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/gf119.c
@@ -507,9 +507,7 @@ gf119_disp = {
 	.outp.internal.lvds = nv50_sor_output_new,
 	.outp.internal.dp = gf119_sor_dp_new,
 	.dac = { .nr = 3, .new = gf119_dac_new },
-	.sor.nr = 4,
-	.sor.new = gf119_sor_new,
-	.sor.hda_eld = gf119_hda_eld,
+	.sor = { .nr = 4, .new = gf119_sor_new },
 };
 
 int
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/gk104.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/gk104.c
@@ -39,9 +39,7 @@ gk104_disp = {
 	.outp.internal.lvds = nv50_sor_output_new,
 	.outp.internal.dp = gf119_sor_dp_new,
 	.dac = { .nr = 3, .new = gf119_dac_new },
-	.sor.nr = 4,
-	.sor.new = gk104_sor_new,
-	.sor.hda_eld = gf119_hda_eld,
+	.sor = { .nr = 4, .new = gk104_sor_new },
 };
 
 int
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/gk110.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/gk110.c
@@ -39,9 +39,7 @@ gk110_disp = {
 	.outp.internal.lvds = nv50_sor_output_new,
 	.outp.internal.dp = gf119_sor_dp_new,
 	.dac = { .nr = 3, .new = gf119_dac_new },
-	.sor.nr = 4,
-	.sor.new = gk104_sor_new,
-	.sor.hda_eld = gf119_hda_eld,
+	.sor = { .nr = 4, .new = gk104_sor_new },
 };
 
 int
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/gm107.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/gm107.c
@@ -39,9 +39,7 @@ gm107_disp = {
 	.outp.internal.lvds = nv50_sor_output_new,
 	.outp.internal.dp = gm107_sor_dp_new,
 	.dac = { .nr = 3, .new = gf119_dac_new },
-	.sor.nr = 4,
-	.sor.new = gm107_sor_new,
-	.sor.hda_eld = gf119_hda_eld,
+	.sor = { .nr = 4, .new = gm107_sor_new },
 };
 
 int
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/gm200.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/gm200.c
@@ -41,7 +41,6 @@ gm200_disp = {
 	.dac = { .nr = 3, .new = gf119_dac_new },
 	.sor.nr = 4,
 	.sor.new = gm200_sor_new,
-	.sor.hda_eld = gf119_hda_eld,
 	.sor.magic = gm200_sor_magic,
 };
 
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/gp100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/gp100.c
@@ -39,7 +39,6 @@ gp100_disp = {
 	.outp.internal.dp = gm200_sor_dp_new,
 	.sor.nr = 4,
 	.sor.new = gm200_sor_new,
-	.sor.hda_eld = gf119_hda_eld,
 	.sor.magic = gm200_sor_magic,
 };
 
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/gp102.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/gp102.c
@@ -65,7 +65,6 @@ gp102_disp = {
 	.outp.internal.dp = gm200_sor_dp_new,
 	.sor.nr = 4,
 	.sor.new = gm200_sor_new,
-	.sor.hda_eld = gf119_hda_eld,
 	.sor.magic = gm200_sor_magic,
 };
 
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/gt215.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/gt215.c
@@ -40,9 +40,7 @@ gt215_disp = {
 	.outp.external.tmds = nv50_pior_output_new,
 	.outp.external.dp = nv50_pior_dp_new,
 	.dac = { .nr = 3, .new = nv50_dac_new },
-	.sor.nr = 4,
-	.sor.new = gt215_sor_new,
-	.sor.hda_eld = gt215_hda_eld,
+	.sor = { .nr = 4, .new = gt215_sor_new },
 	.pior = { .nr = 3, .new = nv50_pior_new },
 };
 
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
@@ -21,63 +21,34 @@
  *
  * Authors: Ben Skeggs
  */
-#include "nv50.h"
-#include "outp.h"
+#include "ior.h"
 
-#include <core/client.h>
-#include <subdev/bios.h>
-#include <subdev/bios/dcb.h>
-#include <subdev/timer.h>
-
-#include <nvif/cl5070.h>
-#include <nvif/unpack.h>
-
-int
-gf119_hda_eld(NV50_DISP_MTHD_V1)
+void
+gf119_hda_eld(struct nvkm_ior *ior, u8 *data, u8 size)
 {
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	union {
-		struct nv50_disp_sor_hda_eld_v0 v0;
-	} *args = data;
-	const u32 soff = outp->or * 0x030;
-	const u32 hoff = head * 0x800;
-	int ret = -ENOSYS, i;
-
-	nvif_ioctl(object, "disp sor hda eld size %d\n", size);
-	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
-		nvif_ioctl(object, "disp sor hda eld vers %d\n",
-			   args->v0.version);
-		if (size > 0x60)
-			return -E2BIG;
-	} else
-		return ret;
+	struct nvkm_device *device = ior->disp->engine.subdev.device;
+	const u32 soff = 0x030 * ior->id;
+	int i;
+
+	for (i = 0; i < size; i++)
+		nvkm_wr32(device, 0x10ec00 + soff, (i << 8) | data[i]);
+	for (; i < 0x60; i++)
+		nvkm_wr32(device, 0x10ec00 + soff, (i << 8));
+	nvkm_mask(device, 0x10ec10 + soff, 0x80000002, 0x80000002);
+}
 
-	if (size && args->v0.data[0]) {
-		if (outp->info.type == DCB_OUTPUT_DP) {
-			nvkm_mask(device, 0x616618 + hoff, 0x8000000c, 0x80000001);
-			nvkm_msec(device, 2000,
-				u32 tmp = nvkm_rd32(device, 0x616618 + hoff);
-				if (!(tmp & 0x80000000))
-					break;
-			);
-		}
+void
+gf119_hda_hpd(struct nvkm_ior *ior, int head, bool present)
+{
+	struct nvkm_device *device = ior->disp->engine.subdev.device;
+	const u32 hoff = 0x800 * head;
+	u32 data = 0x80000000;
+	u32 mask = 0x80000001;
+	if (present) {
 		nvkm_mask(device, 0x616548 + hoff, 0x00000070, 0x00000000);
-		for (i = 0; i < size; i++)
-			nvkm_wr32(device, 0x10ec00 + soff, (i << 8) | args->v0.data[i]);
-		for (; i < 0x60; i++)
-			nvkm_wr32(device, 0x10ec00 + soff, (i << 8));
-		nvkm_mask(device, 0x10ec10 + soff, 0x80000003, 0x80000003);
+		data |= 0x00000001;
 	} else {
-		if (outp->info.type == DCB_OUTPUT_DP) {
-			nvkm_mask(device, 0x616618 + hoff, 0x80000001, 0x80000000);
-			nvkm_msec(device, 2000,
-				u32 tmp = nvkm_rd32(device, 0x616618 + hoff);
-				if (!(tmp & 0x80000000))
-					break;
-			);
-		}
-		nvkm_mask(device, 0x10ec10 + soff, 0x80000003, 0x80000000 | !!size);
+		mask |= 0x00000002;
 	}
-
-	return 0;
+	nvkm_mask(device, 0x10ec10 + ior->id * 0x030, mask, data);
 }
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagt215.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagt215.c
@@ -21,59 +21,31 @@
  *
  * Authors: Ben Skeggs
  */
-#include "nv50.h"
-#include "outp.h"
+#include "ior.h"
 
-#include <core/client.h>
-#include <subdev/timer.h>
-
-#include <nvif/cl5070.h>
-#include <nvif/unpack.h>
-
-int
-gt215_hda_eld(NV50_DISP_MTHD_V1)
+void
+gt215_hda_eld(struct nvkm_ior *ior, u8 *data, u8 size)
 {
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	union {
-		struct nv50_disp_sor_hda_eld_v0 v0;
-	} *args = data;
-	const u32 soff = outp->or * 0x800;
-	int ret = -ENOSYS, i;
-
-	nvif_ioctl(object, "disp sor hda eld size %d\n", size);
-	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
-		nvif_ioctl(object, "disp sor hda eld vers %d\n",
-			   args->v0.version);
-		if (size > 0x60)
-			return -E2BIG;
-	} else
-		return ret;
-
-	if (size && args->v0.data[0]) {
-		if (outp->info.type == DCB_OUTPUT_DP) {
-			nvkm_mask(device, 0x61c1e0 + soff, 0x8000000d, 0x80000001);
-			nvkm_msec(device, 2000,
-				u32 tmp = nvkm_rd32(device, 0x61c1e0 + soff);
-				if (!(tmp & 0x80000000))
-					break;
-			);
-		}
-		for (i = 0; i < size; i++)
-			nvkm_wr32(device, 0x61c440 + soff, (i << 8) | args->v0.data[i]);
-		for (; i < 0x60; i++)
-			nvkm_wr32(device, 0x61c440 + soff, (i << 8));
-		nvkm_mask(device, 0x61c448 + soff, 0x80000003, 0x80000003);
-	} else {
-		if (outp->info.type == DCB_OUTPUT_DP) {
-			nvkm_mask(device, 0x61c1e0 + soff, 0x80000001, 0x80000000);
-			nvkm_msec(device, 2000,
-				u32 tmp = nvkm_rd32(device, 0x61c1e0 + soff);
-				if (!(tmp & 0x80000000))
-					break;
-			);
-		}
-		nvkm_mask(device, 0x61c448 + soff, 0x80000003, 0x80000000 | !!size);
-	}
+	struct nvkm_device *device = ior->disp->engine.subdev.device;
+	const u32 soff = ior->id * 0x800;
+	int i;
+
+	for (i = 0; i < size; i++)
+		nvkm_wr32(device, 0x61c440 + soff, (i << 8) | data[i]);
+	for (; i < 0x60; i++)
+		nvkm_wr32(device, 0x61c440 + soff, (i << 8));
+	nvkm_mask(device, 0x61c448 + soff, 0x80000002, 0x80000002);
+}
 
-	return 0;
+void
+gt215_hda_hpd(struct nvkm_ior *ior, int head, bool present)
+{
+	struct nvkm_device *device = ior->disp->engine.subdev.device;
+	u32 data = 0x80000000;
+	u32 mask = 0x80000001;
+	if (present)
+		data |= 0x00000001;
+	else
+		mask |= 0x00000002;
+	nvkm_mask(device, 0x61c448 + ior->id * 0x800, mask, data);
 }
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/ior.h
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/ior.h
@@ -58,7 +58,13 @@ struct nvkm_ior_func {
 		void (*pattern)(struct nvkm_ior *, int pattern);
 		void (*drive)(struct nvkm_ior *, int ln, int pc,
 			      int dc, int pe, int tx_pu);
+		void (*audio)(struct nvkm_ior *, int head, bool enable);
 	} dp;
+
+	struct {
+		void (*hpd)(struct nvkm_ior *, int head, bool present);
+		void (*eld)(struct nvkm_ior *, u8 *data, u8 size);
+	} hda;
 };
 
 int nvkm_ior_new_(const struct nvkm_ior_func *func, struct nvkm_disp *,
@@ -90,10 +96,13 @@ void g94_sor_dp_power(struct nvkm_ior *,
 void g94_sor_dp_pattern(struct nvkm_ior *, int);
 void g94_sor_dp_drive(struct nvkm_ior *, int, int, int, int, int);
 
+void gt215_sor_dp_audio(struct nvkm_ior *, int, bool);
+
 void gf119_sor_state(struct nvkm_ior *, struct nvkm_ior_state *);
 int gf119_sor_dp_links(struct nvkm_ior *, struct nvkm_i2c_aux *);
 void gf119_sor_dp_pattern(struct nvkm_ior *, int);
 void gf119_sor_dp_drive(struct nvkm_ior *, int, int, int, int, int);
+void gf119_sor_dp_audio(struct nvkm_ior *, int, bool);
 
 void gm107_sor_dp_pattern(struct nvkm_ior *, int);
 
@@ -102,6 +111,12 @@ void gt215_hdmi_ctrl(struct nvkm_ior *,
 void gf119_hdmi_ctrl(struct nvkm_ior *, int, bool, u8, u8, u8 *, u8 , u8 *, u8);
 void gk104_hdmi_ctrl(struct nvkm_ior *, int, bool, u8, u8, u8 *, u8 , u8 *, u8);
 
+void gt215_hda_hpd(struct nvkm_ior *, int, bool);
+void gt215_hda_eld(struct nvkm_ior *, u8 *, u8);
+
+void gf119_hda_hpd(struct nvkm_ior *, int, bool);
+void gf119_hda_eld(struct nvkm_ior *, u8 *, u8);
+
 #define IOR_MSG(i,l,f,a...) do {                                               \
 	struct nvkm_ior *_ior = (i);                                           \
 	nvkm_##l(&_ior->disp->engine.subdev, "%s: "f, _ior->name, ##a);        \
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/mcp89.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/mcp89.c
@@ -38,9 +38,7 @@ mcp89_disp = {
 	.outp.external.tmds = nv50_pior_output_new,
 	.outp.external.dp = nv50_pior_dp_new,
 	.dac = { .nr = 3, .new = nv50_dac_new },
-	.sor.nr = 4,
-	.sor.new = mcp89_sor_new,
-	.sor.hda_eld = gt215_hda_eld,
+	.sor = { .nr = 4, .new = mcp89_sor_new },
 	.pior = { .nr = 3, .new = nv50_pior_new },
 };
 
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.h
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.h
@@ -4,10 +4,6 @@
 #include "priv.h"
 #include "dp.h"
 
-#define NV50_DISP_MTHD_ struct nvkm_object *object,                            \
-	struct nv50_disp *disp, void *data, u32 size
-#define NV50_DISP_MTHD_V1 NV50_DISP_MTHD_, int head, struct nvkm_output *outp
-
 struct nv50_disp {
 	const struct nv50_disp_func *func;
 	struct nvkm_disp base;
@@ -31,9 +27,6 @@ struct nv50_disp {
 
 void nv50_disp_super_1(struct nv50_disp *);
 
-int gt215_hda_eld(NV50_DISP_MTHD_V1);
-int gf119_hda_eld(NV50_DISP_MTHD_V1);
-
 int nv50_disp_new_(const struct nv50_disp_func *, struct nvkm_device *,
 		   int index, int heads, struct nvkm_disp **);
 int gf119_disp_new_(const struct nv50_disp_func *, struct nvkm_device *,
@@ -78,7 +71,6 @@ struct nv50_disp_func {
 	struct {
 		int nr;
 		int (*new)(struct nvkm_disp *, int id);
-		int (*hda_eld)(NV50_DISP_MTHD_V1);
 		void (*magic)(struct nvkm_output *);
 	} sor;
 
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -43,7 +43,6 @@ nv50_disp_root_mthd_(struct nvkm_object
 	} *args = data;
 	struct nv50_disp_root *root = nv50_disp_root(object);
 	struct nv50_disp *disp = root->disp;
-	const struct nv50_disp_func *func = disp->func;
 	struct nvkm_outp *temp, *outp = NULL;
 	struct nvkm_head *head;
 	u16 type, mask = 0;
@@ -112,10 +111,39 @@ nv50_disp_root_mthd_(struct nvkm_object
 			return ret;
 	}
 		break;
-	case NV50_DISP_MTHD_V1_SOR_HDA_ELD:
-		if (!func->sor.hda_eld)
+	case NV50_DISP_MTHD_V1_SOR_HDA_ELD: {
+		union {
+			struct nv50_disp_sor_hda_eld_v0 v0;
+		} *args = data;
+		struct nvkm_ior *ior = outp->ior;
+		int ret = -ENOSYS;
+
+		nvif_ioctl(object, "disp sor hda eld size %d\n", size);
+		if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
+			nvif_ioctl(object, "disp sor hda eld vers %d\n",
+				   args->v0.version);
+			if (size > 0x60)
+				return -E2BIG;
+		} else
+			return ret;
+
+		if (!ior->func->hda.hpd)
 			return -ENODEV;
-		return func->sor.hda_eld(object, disp, data, size, hidx, outp);
+
+		if (size && args->v0.data[0]) {
+			if (outp->info.type == DCB_OUTPUT_DP)
+				ior->func->dp.audio(ior, hidx, true);
+			ior->func->hda.hpd(ior, hidx, true);
+			ior->func->hda.eld(ior, data, size);
+		} else {
+			if (outp->info.type == DCB_OUTPUT_DP)
+				ior->func->dp.audio(ior, hidx, false);
+			ior->func->hda.hpd(ior, hidx, false);
+		}
+
+		return 0;
+	}
+		break;
 	case NV50_DISP_MTHD_V1_SOR_HDMI_PWR: {
 		union {
 			struct nv50_disp_sor_hdmi_pwr_v0 v0;
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgf119.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgf119.c
@@ -24,6 +24,22 @@
 #include "ior.h"
 #include "nv50.h"
 
+#include <subdev/timer.h>
+
+void
+gf119_sor_dp_audio(struct nvkm_ior *sor, int head, bool enable)
+{
+	struct nvkm_device *device = sor->disp->engine.subdev.device;
+	const u32 hoff = 0x800 * head;
+	const u32 data = 0x80000000 | (0x00000001 * enable);
+	const u32 mask = 0x8000000d;
+	nvkm_mask(device, 0x616618 + hoff, mask, data);
+	nvkm_msec(device, 2000,
+		if (!(nvkm_rd32(device, 0x616618 + hoff) & 0x80000000))
+			break;
+	);
+}
+
 void
 gf119_sor_dp_vcpi(struct nvkm_output_dp *outp, int head, u8 slot,
 		  u8 slot_nr, u16 pbn, u16 aligned)
@@ -131,6 +147,11 @@ gf119_sor = {
 		.links = gf119_sor_dp_links,
 		.power = g94_sor_dp_power,
 		.pattern = gf119_sor_dp_pattern,
+		.audio = gf119_sor_dp_audio,
+	},
+	.hda = {
+		.hpd = gf119_hda_hpd,
+		.eld = gf119_hda_eld,
 	},
 };
 
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgk104.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgk104.c
@@ -34,6 +34,11 @@ gk104_sor = {
 		.power = g94_sor_dp_power,
 		.pattern = gf119_sor_dp_pattern,
 		.drive = gf119_sor_dp_drive,
+		.audio = gf119_sor_dp_audio,
+	},
+	.hda = {
+		.hpd = gf119_hda_hpd,
+		.eld = gf119_hda_eld,
 	},
 };
 
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgm107.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgm107.c
@@ -61,6 +61,11 @@ gm107_sor = {
 		.power = g94_sor_dp_power,
 		.pattern = gm107_sor_dp_pattern,
 		.drive = gf119_sor_dp_drive,
+		.audio = gf119_sor_dp_audio,
+	},
+	.hda = {
+		.hpd = gf119_hda_hpd,
+		.eld = gf119_hda_eld,
 	},
 };
 
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgm200.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgm200.c
@@ -83,6 +83,11 @@ gm200_sor = {
 		.power = g94_sor_dp_power,
 		.pattern = gm107_sor_dp_pattern,
 		.drive = gm200_sor_dp_drive,
+		.audio = gf119_sor_dp_audio,
+	},
+	.hda = {
+		.hpd = gf119_hda_hpd,
+		.eld = gf119_hda_eld,
 	},
 };
 
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgt215.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/sorgt215.c
@@ -21,6 +21,22 @@
  */
 #include "ior.h"
 
+#include <subdev/timer.h>
+
+void
+gt215_sor_dp_audio(struct nvkm_ior *sor, int head, bool enable)
+{
+	struct nvkm_device *device = sor->disp->engine.subdev.device;
+	const u32 soff = nv50_ior_base(sor);
+	const u32 data = 0x80000000 | (0x00000001 * enable);
+	const u32 mask = 0x8000000d;
+	nvkm_mask(device, 0x61c1e0 + soff, mask, data);
+	nvkm_msec(device, 2000,
+		if (!(nvkm_rd32(device, 0x61c1e0 + soff) & 0x80000000))
+			break;
+	);
+}
+
 static const struct nvkm_ior_func
 gt215_sor = {
 	.state = g94_sor_state,
@@ -34,6 +50,11 @@ gt215_sor = {
 		.power = g94_sor_dp_power,
 		.pattern = g94_sor_dp_pattern,
 		.drive = g94_sor_dp_drive,
+		.audio = gt215_sor_dp_audio,
+	},
+	.hda = {
+		.hpd = gt215_hda_hpd,
+		.eld = gt215_hda_eld,
 	},
 };
 
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/sormcp89.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/sormcp89.c
@@ -34,6 +34,11 @@ mcp89_sor = {
 		.power = g94_sor_dp_power,
 		.pattern = g94_sor_dp_pattern,
 		.drive = g94_sor_dp_drive,
+		.audio = gt215_sor_dp_audio,
+	},
+	.hda = {
+		.hpd = gt215_hda_hpd,
+		.eld = gt215_hda_eld,
 	},
 };
 
