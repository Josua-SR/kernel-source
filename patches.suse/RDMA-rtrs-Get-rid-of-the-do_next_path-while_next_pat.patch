From: Danil Kipnis <danil.kipnis@cloud.ionos.com>
Date: Fri, 22 May 2020 07:39:24 +0200
Subject: RDMA/rtrs: Get rid of the do_next_path while_next_path macros
Patch-mainline: v5.8-rc1
Git-commit: a94dae867c5663f36c950b82832e146a6c2f0e42
References: jsc#SLE-15176

The macros do_each_path/while_each_path lead to a smatch warning:

drivers/infiniband/ulp/rtrs/rtrs-clt.c:1196 rtrs_clt_failover_req() warn: inconsistent indenting
drivers/infiniband/ulp/rtrs/rtrs-clt.c:2890 rtrs_clt_request() warn: inconsistent indenting

Also checkpatch complains:
ERROR: Macros with multiple statements should be enclosed in a do - while loop

The macros are used only in two places: for a normal IO path and for the
failover path triggered after errors.

Get rid of the macros and just use a for loop iterating over the list of
paths in both places. It is easier to read and also less lines of code.

Fixes: 6a98d71daea1 ("RDMA/rtrs: client: main functionality")
Link: https://lore.kernel.org/r/20200522053924.528980-1-danil.kipnis@cloud.ionos.com
Reported-by: kbuild test robot <lkp@intel.com>
Signed-off-by: Danil Kipnis <danil.kipnis@cloud.ionos.com>
Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/infiniband/ulp/rtrs/rtrs-clt.c |   29 +++++++++++++----------------
 1 file changed, 13 insertions(+), 16 deletions(-)

--- a/drivers/infiniband/ulp/rtrs/rtrs-clt.c
+++ b/drivers/infiniband/ulp/rtrs/rtrs-clt.c
@@ -726,18 +726,6 @@ struct path_it {
 	struct rtrs_clt_sess *(*next_path)(struct path_it *it);
 };
 
-#define do_each_path(path, clt, it) {					\
-	path_it_init(it, clt);						\
-	rcu_read_lock();						\
-	for ((it)->i = 0; ((path) = ((it)->next_path)(it)) &&		\
-			  (it)->i < (it)->clt->paths_num;		\
-	     (it)->i++)
-
-#define while_each_path(it)						\
-	path_it_deinit(it);						\
-	rcu_read_unlock();						\
-	}
-
 /**
  * list_next_or_null_rr_rcu - get next list element in round-robin fashion.
  * @head:	the head for the list.
@@ -1175,7 +1163,10 @@ static int rtrs_clt_failover_req(struct
 	int err = -ECONNABORTED;
 	struct path_it it;
 
-	do_each_path(alive_sess, clt, &it) {
+	rcu_read_lock();
+	for (path_it_init(&it, clt);
+	     (alive_sess = it.next_path(&it)) && it.i < it.clt->paths_num;
+	     it.i++) {
 		if (unlikely(READ_ONCE(alive_sess->state) !=
 			     RTRS_CLT_CONNECTED))
 			continue;
@@ -1191,7 +1182,9 @@ static int rtrs_clt_failover_req(struct
 		/* Success path */
 		rtrs_clt_inc_failover_cnt(alive_sess->stats);
 		break;
-	} while_each_path(&it);
+	}
+	path_it_deinit(&it);
+	rcu_read_unlock();
 
 	return err;
 }
@@ -2862,7 +2855,9 @@ int rtrs_clt_request(int dir, struct rtr
 		dma_dir = DMA_TO_DEVICE;
 	}
 
-	do_each_path(sess, clt, &it) {
+	rcu_read_lock();
+	for (path_it_init(&it, clt);
+	     (sess = it.next_path(&it)) && it.i < it.clt->paths_num; it.i++) {
 		if (unlikely(READ_ONCE(sess->state) != RTRS_CLT_CONNECTED))
 			continue;
 
@@ -2887,7 +2882,9 @@ int rtrs_clt_request(int dir, struct rtr
 		}
 		/* Success path */
 		break;
-	} while_each_path(&it);
+	}
+	path_it_deinit(&it);
+	rcu_read_unlock();
 
 	return err;
 }
