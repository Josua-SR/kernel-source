From: Ben Skeggs <bskeggs@redhat.com>
Date: Wed, 1 Nov 2017 03:56:19 +1000
Subject: drm/nouveau/imem/nv50: split object map out from api functions
Git-commit: f584bde6095af4d91e917be54c487258856ace89
Patch-mainline: v4.15-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

acquire()/boot() will need different logic in addition to performing
the actual mapping.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/nouveau/nvkm/subdev/instmem/nv50.c |   57 +++++++++++----------
 1 file changed, 32 insertions(+), 25 deletions(-)

--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/nv50.c
@@ -90,6 +90,34 @@ nv50_instobj_slow = {
 };
 
 static void
+nv50_instobj_kmap(struct nv50_instobj *iobj, struct nvkm_vmm *vmm)
+{
+	struct nvkm_memory *memory = &iobj->memory;
+	struct nvkm_subdev *subdev = &iobj->imem->base.subdev;
+	struct nvkm_device *device = subdev->device;
+	u64 size = nvkm_memory_size(memory);
+	void __iomem *map;
+	int ret;
+
+	iobj->map = ERR_PTR(-ENOMEM);
+
+	ret = nvkm_vm_get(vmm, size, 12, NV_MEM_ACCESS_RW, &iobj->bar);
+	if (ret == 0) {
+		map = ioremap(device->func->resource_addr(device, 3) +
+			      (u32)iobj->bar.offset, size);
+		if (map) {
+			nvkm_memory_map(memory, &iobj->bar, 0);
+			iobj->map = map;
+		} else {
+			nvkm_warn(subdev, "PRAMIN ioremap failed\n");
+			nvkm_vm_put(&iobj->bar);
+		}
+	} else {
+		nvkm_warn(subdev, "PRAMIN exhausted\n");
+	}
+}
+
+static void
 nv50_instobj_map(struct nvkm_memory *memory, struct nvkm_vma *vma, u64 offset)
 {
 	struct nv50_instobj *iobj = nv50_instobj(memory);
@@ -112,7 +140,7 @@ nv50_instobj_acquire(struct nvkm_memory
 	unsigned long flags;
 
 	if (!iobj->map && (vm = nvkm_bar_bar2_vmm(imem->base.subdev.device)))
-		nvkm_memory_boot(memory, vm);
+		nv50_instobj_kmap(iobj, vm);
 	if (!IS_ERR_OR_NULL(iobj->map))
 		return iobj->map;
 
@@ -122,31 +150,10 @@ nv50_instobj_acquire(struct nvkm_memory
 }
 
 static void
-nv50_instobj_boot(struct nvkm_memory *memory, struct nvkm_vm *vm)
+nv50_instobj_boot(struct nvkm_memory *memory, struct nvkm_vmm *vmm)
 {
 	struct nv50_instobj *iobj = nv50_instobj(memory);
-	struct nvkm_subdev *subdev = &iobj->imem->base.subdev;
-	struct nvkm_device *device = subdev->device;
-	u64 size = nvkm_memory_size(memory);
-	void __iomem *map;
-	int ret;
-
-	iobj->map = ERR_PTR(-ENOMEM);
-
-	ret = nvkm_vm_get(vm, size, 12, NV_MEM_ACCESS_RW, &iobj->bar);
-	if (ret == 0) {
-		map = ioremap(device->func->resource_addr(device, 3) +
-			      (u32)iobj->bar.offset, size);
-		if (map) {
-			nvkm_memory_map(memory, &iobj->bar, 0);
-			iobj->map = map;
-		} else {
-			nvkm_warn(subdev, "PRAMIN ioremap failed\n");
-			nvkm_vm_put(&iobj->bar);
-		}
-	} else {
-		nvkm_warn(subdev, "PRAMIN exhausted\n");
-	}
+	nv50_instobj_kmap(iobj, vmm);
 }
 
 static u64
@@ -173,8 +180,8 @@ nv50_instobj_dtor(struct nvkm_memory *me
 	struct nv50_instobj *iobj = nv50_instobj(memory);
 	struct nvkm_ram *ram = iobj->imem->base.subdev.device->fb->ram;
 	if (!IS_ERR_OR_NULL(iobj->map)) {
-		nvkm_vm_put(&iobj->bar);
 		iounmap(iobj->map);
+		nvkm_vm_put(&iobj->bar);
 	}
 	ram->func->put(ram, &iobj->mem);
 	return iobj;
