From: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
Date: Wed, 31 Jul 2019 11:05:52 +0200
Subject: ACPI: EC: PM: Consolidate some code depending on PM_SLEEP
Patch-mainline: v5.4-rc1
Git-commit: d7589404932be148fabe696b56b7c391bad6bdb1
References: jsc#SLE-16407

Move some routines, including acpi_ec_dispatch_gpe(), that are only
used if CONFIG_PM_SLEEP is set to the #ifdef block containing the EC
suspend and resume callbacks, to make the "full EC PM picture" easier
to follow.

While at it, move the header of acpi_ec_dispatch_gpe() in the
header file to a CONFIG_PM_SLEEP #ifdef block.

Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
Acked-by: Lee, Chun-Yi <jlee@suse.com>
---
 drivers/acpi/ec.c       |   54 +++++++++++++++++++++++-------------------------
 drivers/acpi/internal.h |    2 -
 2 files changed, 27 insertions(+), 29 deletions(-)

--- a/drivers/acpi/ec.c
+++ b/drivers/acpi/ec.c
@@ -1049,33 +1049,6 @@ void acpi_ec_unblock_transactions(void)
 		acpi_ec_start(first_ec, true);
 }
 
-#ifdef CONFIG_PM_SLEEP
-void acpi_ec_mark_gpe_for_wake(void)
-{
-	if (first_ec && !ec_no_wakeup)
-		acpi_mark_gpe_for_wake(NULL, first_ec->gpe);
-}
-EXPORT_SYMBOL_GPL(acpi_ec_mark_gpe_for_wake);
-
-void acpi_ec_set_gpe_wake_mask(u8 action)
-{
-	if (pm_suspend_no_platform() && first_ec && !ec_no_wakeup)
-		acpi_set_gpe_wake_mask(NULL, first_ec->gpe, action);
-}
-EXPORT_SYMBOL_GPL(acpi_ec_set_gpe_wake_mask);
-#endif
-
-bool acpi_ec_dispatch_gpe(void)
-{
-	u32 ret;
-
-	if (!first_ec)
-		return false;
-
-	ret = acpi_dispatch_gpe(NULL, first_ec->gpe);
-	return ret == ACPI_INTERRUPT_HANDLED;
-}
-
 /* --------------------------------------------------------------------------
                                 Event Management
    -------------------------------------------------------------------------- */
@@ -1984,7 +1957,32 @@ static int acpi_ec_resume(struct device
 	acpi_ec_enable_event(ec);
 	return 0;
 }
-#endif
+
+void acpi_ec_mark_gpe_for_wake(void)
+{
+	if (first_ec && !ec_no_wakeup)
+		acpi_mark_gpe_for_wake(NULL, first_ec->gpe);
+}
+EXPORT_SYMBOL_GPL(acpi_ec_mark_gpe_for_wake);
+
+void acpi_ec_set_gpe_wake_mask(u8 action)
+{
+	if (pm_suspend_no_platform() && first_ec && !ec_no_wakeup)
+		acpi_set_gpe_wake_mask(NULL, first_ec->gpe, action);
+}
+EXPORT_SYMBOL_GPL(acpi_ec_set_gpe_wake_mask);
+
+bool acpi_ec_dispatch_gpe(void)
+{
+	u32 ret;
+
+	if (!first_ec)
+		return false;
+
+	ret = acpi_dispatch_gpe(NULL, first_ec->gpe);
+	return ret == ACPI_INTERRUPT_HANDLED;
+}
+#endif /* CONFIG_PM_SLEEP */
 
 static const struct dev_pm_ops acpi_ec_pm = {
 	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(acpi_ec_suspend_noirq, acpi_ec_resume_noirq)
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@ -194,7 +194,6 @@ void acpi_ec_ecdt_probe(void);
 void acpi_ec_dsdt_probe(void);
 void acpi_ec_block_transactions(void);
 void acpi_ec_unblock_transactions(void);
-bool acpi_ec_dispatch_gpe(void);
 int acpi_ec_add_query_handler(struct acpi_ec *ec, u8 query_bit,
 			      acpi_handle handle, acpi_ec_query_func func,
 			      void *data);
@@ -202,6 +201,7 @@ void acpi_ec_remove_query_handler(struct
 
 #ifdef CONFIG_PM_SLEEP
 void acpi_ec_flush_work(void);
+bool acpi_ec_dispatch_gpe(void);
 #endif
 
 
