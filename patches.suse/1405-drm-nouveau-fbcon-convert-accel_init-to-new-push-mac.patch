From 8dcefb4f4980b5d0631ec275bcda75b2acaf72b6 Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Mon, 22 Jun 2020 11:08:51 +1000
Subject: drm/nouveau/fbcon: convert accel_init() to new push macros
Git-commit: d9a91300ae21bb886b05014cfb1a3ad0dfff04b8
Patch-mainline: v5.9-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Reviewed-by: Lyude Paul <lyude@redhat.com>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 .../drm/nouveau/include/nvhw/class/cl006c.h   |  46 +++++++
 .../drm/nouveau/include/nvhw/class/cl206e.h   |  35 ++++++
 .../drm/nouveau/include/nvhw/class/cl906f.h   |  74 +++++++++++
 .../gpu/drm/nouveau/include/nvif/push006c.h   |  73 +++++++++++
 .../gpu/drm/nouveau/include/nvif/push206e.h   |  13 ++
 .../gpu/drm/nouveau/include/nvif/push906f.h   |  48 ++++++++
 drivers/gpu/drm/nouveau/nouveau_dma.h         |   1 -
 drivers/gpu/drm/nouveau/nv04_fbcon.c          | 109 +++++++----------
 drivers/gpu/drm/nouveau/nv50_fbcon.c          | 115 ++++++++----------
 drivers/gpu/drm/nouveau/nvc0_fbcon.c          | 113 ++++++++---------
 10 files changed, 438 insertions(+), 189 deletions(-)
 create mode 100644 drivers/gpu/drm/nouveau/include/nvhw/class/cl006c.h
 create mode 100644 drivers/gpu/drm/nouveau/include/nvhw/class/cl206e.h
 create mode 100644 drivers/gpu/drm/nouveau/include/nvhw/class/cl906f.h
 create mode 100644 drivers/gpu/drm/nouveau/include/nvif/push006c.h
 create mode 100644 drivers/gpu/drm/nouveau/include/nvif/push206e.h
 create mode 100644 drivers/gpu/drm/nouveau/include/nvif/push906f.h

diff --git a/drivers/gpu/drm/nouveau/include/nvhw/class/cl006c.h b/drivers/gpu/drm/nouveau/include/nvhw/class/cl006c.h
new file mode 100644
index 000000000000..9ab2a22659e4
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/include/nvhw/class/cl006c.h
@@ -0,0 +1,46 @@
+/*******************************************************************************
+    Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in
+    all copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+
+*******************************************************************************/
+#ifndef _cl006c_h_
+#define _cl006c_h_
+
+/* fields and values */
+#define NV06C_PUT                                                  (0x00000040)
+#define NV06C_PUT_PTR                                              31:2
+#define NV06C_GET                                                  (0x00000044)
+#define NV06C_GET_PTR                                              31:2
+
+/* dma method descriptor format */
+#define NV06C_METHOD_ADDRESS                                       12:2
+#define NV06C_METHOD_SUBCHANNEL                                    15:13
+#define NV06C_METHOD_COUNT                                         28:18
+#define NV06C_OPCODE                                               31:29
+#define NV06C_OPCODE_METHOD                                        (0x00000000)
+#define NV06C_OPCODE_NONINC_METHOD                                 (0x00000002)
+
+/* dma data format */
+#define NV06C_DATA                                                 31:0
+
+/* dma jump format */
+#define NV06C_OPCODE_JUMP                                          (0x00000001)
+#define NV06C_JUMP_OFFSET                                          28:2
+#endif /* _cl006c_h_ */
diff --git a/drivers/gpu/drm/nouveau/include/nvhw/class/cl206e.h b/drivers/gpu/drm/nouveau/include/nvhw/class/cl206e.h
new file mode 100644
index 000000000000..27313c7c43cd
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/include/nvhw/class/cl206e.h
@@ -0,0 +1,35 @@
+/*******************************************************************************
+    Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in
+    all copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+
+*******************************************************************************/
+#ifndef _cl206e_h_
+#define _cl206e_h_
+
+/* dma opcode2 format */
+#define NV206E_DMA_OPCODE2                                         1:0
+#define NV206E_DMA_OPCODE2_NONE                                    (0x00000000)
+/* dma jump_long format */
+#define NV206E_DMA_OPCODE2_JUMP_LONG                               (0x00000001)
+#define NV206E_DMA_JUMP_LONG_OFFSET                                31:2
+/* dma call format */
+#define NV206E_DMA_OPCODE2_CALL                                    (0x00000002)
+#define NV206E_DMA_CALL_OFFSET                                     31:2
+#endif /* _cl206e_h_ */
diff --git a/drivers/gpu/drm/nouveau/include/nvhw/class/cl906f.h b/drivers/gpu/drm/nouveau/include/nvhw/class/cl906f.h
new file mode 100644
index 000000000000..673d668885bb
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/include/nvhw/class/cl906f.h
@@ -0,0 +1,74 @@
+/*******************************************************************************
+    Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in
+    all copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+
+*******************************************************************************/
+#ifndef _cl906f_h_
+#define _cl906f_h_
+
+/* fields and values */
+#define NV906F_SEMAPHOREA                                          (0x00000010)
+#define NV906F_SEMAPHOREA_OFFSET_UPPER                                     7:0
+#define NV906F_SEMAPHOREB                                          (0x00000014)
+#define NV906F_SEMAPHOREB_OFFSET_LOWER                                    31:2
+#define NV906F_SEMAPHOREC                                          (0x00000018)
+#define NV906F_SEMAPHOREC_PAYLOAD                                         31:0
+#define NV906F_SEMAPHORED                                          (0x0000001C)
+#define NV906F_SEMAPHORED_OPERATION                                        3:0
+#define NV906F_SEMAPHORED_OPERATION_ACQUIRE                         0x00000001
+#define NV906F_SEMAPHORED_OPERATION_RELEASE                         0x00000002
+#define NV906F_SEMAPHORED_OPERATION_ACQ_GEQ                         0x00000004
+#define NV906F_SEMAPHORED_OPERATION_ACQ_AND                         0x00000008
+#define NV906F_SEMAPHORED_ACQUIRE_SWITCH                                 12:12
+#define NV906F_SEMAPHORED_ACQUIRE_SWITCH_DISABLED                   0x00000000
+#define NV906F_SEMAPHORED_ACQUIRE_SWITCH_ENABLED                    0x00000001
+#define NV906F_SEMAPHORED_RELEASE_WFI                                    20:20
+#define NV906F_SEMAPHORED_RELEASE_WFI_EN                            0x00000000
+#define NV906F_SEMAPHORED_RELEASE_WFI_DIS                           0x00000001
+#define NV906F_SEMAPHORED_RELEASE_SIZE                                   24:24
+#define NV906F_SEMAPHORED_RELEASE_SIZE_16BYTE                       0x00000000
+#define NV906F_SEMAPHORED_RELEASE_SIZE_4BYTE                        0x00000001
+#define NV906F_NON_STALL_INTERRUPT                                 (0x00000020)
+#define NV906F_NON_STALL_INTERRUPT_HANDLE                                 31:0
+#define NV906F_SET_REFERENCE                                       (0x00000050)
+#define NV906F_SET_REFERENCE_COUNT                                        31:0
+
+/* dma method formats */
+#define NV906F_DMA_METHOD_ADDRESS                                  11:0
+#define NV906F_DMA_SUBDEVICE_MASK                                  15:4
+#define NV906F_DMA_METHOD_SUBCHANNEL                               15:13
+#define NV906F_DMA_TERT_OP                                         17:16
+#define NV906F_DMA_TERT_OP_GRP0_INC_METHOD                         (0x00000000)
+#define NV906F_DMA_TERT_OP_GRP0_SET_SUB_DEV_MASK                   (0x00000001)
+#define NV906F_DMA_TERT_OP_GRP0_STORE_SUB_DEV_MASK                 (0x00000002)
+#define NV906F_DMA_TERT_OP_GRP0_USE_SUB_DEV_MASK                   (0x00000003)
+#define NV906F_DMA_TERT_OP_GRP2_NON_INC_METHOD                     (0x00000000)
+#define NV906F_DMA_METHOD_COUNT                                    28:16
+#define NV906F_DMA_IMMD_DATA                                       28:16
+#define NV906F_DMA_SEC_OP                                          31:29
+#define NV906F_DMA_SEC_OP_GRP0_USE_TERT                            (0x00000000)
+#define NV906F_DMA_SEC_OP_INC_METHOD                               (0x00000001)
+#define NV906F_DMA_SEC_OP_GRP2_USE_TERT                            (0x00000002)
+#define NV906F_DMA_SEC_OP_NON_INC_METHOD                           (0x00000003)
+#define NV906F_DMA_SEC_OP_IMMD_DATA_METHOD                         (0x00000004)
+#define NV906F_DMA_SEC_OP_ONE_INC                                  (0x00000005)
+#define NV906F_DMA_SEC_OP_RESERVED6                                (0x00000006)
+#define NV906F_DMA_SEC_OP_END_PB_SEGMENT                           (0x00000007)
+#endif /* _cl906f_h_ */
diff --git a/drivers/gpu/drm/nouveau/include/nvif/push006c.h b/drivers/gpu/drm/nouveau/include/nvif/push006c.h
new file mode 100644
index 000000000000..a31c147e72c7
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/include/nvif/push006c.h
@@ -0,0 +1,73 @@
+#ifndef __NVIF_PUSH006C_H__
+#define __NVIF_PUSH006C_H__
+#include <nvif/push.h>
+
+#include <nvhw/class/cl006c.h>
+
+#ifndef PUSH006C_SUBC
+// Host methods
+#define PUSH006C_SUBC_NV06E	0
+#define PUSH006C_SUBC_NV176E	0
+#define PUSH006C_SUBC_NV826F	0
+
+// ContextSurfaces2d
+#define PUSH006C_SUBC_NV042	0
+#define PUSH006C_SUBC_NV062	0
+
+// ContextClipRectangle
+#define PUSH006C_SUBC_NV019	0
+
+// ContextRop
+#define PUSH006C_SUBC_NV043	0
+
+// ContextPattern
+#define PUSH006C_SUBC_NV044	0
+
+// Misc dodginess...
+#define PUSH006C_SUBC_NV_SW	1
+
+// ImageBlit
+#define PUSH006C_SUBC_NV05F	2
+#define PUSH006C_SUBC_NV09F	2
+
+// GdiRectangleText
+#define PUSH006C_SUBC_NV04A	3
+
+// Twod
+#define PUSH006C_SUBC_NV502D	3
+
+// MemoryToMemoryFormat
+#define PUSH006C_SUBC_NV039	4
+#define PUSH006C_SUBC_NV5039	4
+
+// DmaCopy
+#define PUSH006C_SUBC_NV85B5	4
+
+// Cipher
+#define PUSH006C_SUBC_NV74C1	4
+#endif
+
+#define PUSH_HDR(p,o,n,s,m,c) do {                                        \
+        PUSH_ASSERT(!((s) & ~DRF_MASK(NV06C_METHOD_SUBCHANNEL)), "subc"); \
+        PUSH_ASSERT(!((m) & ~DRF_SMASK(NV06C_METHOD_ADDRESS)), "mthd");   \
+        PUSH_ASSERT(!((c) & ~DRF_MASK(NV06C_METHOD_COUNT)), "count");     \
+        PUSH_DATA__((p), NVVAL_X(NV06C_METHOD_ADDRESS, (m) >> 2) |        \
+			 NVVAL_X(NV06C_METHOD_SUBCHANNEL, (s)) |          \
+			 NVVAL_X(NV06C_METHOD_COUNT, (c)) |               \
+			 NVVAL_X(NV06C_OPCODE, NV06C_OPCODE_##o),         \
+		    " "n" subc %d mthd 0x%04x size %d - %s",              \
+		    (u32)(s), (u32)(m), (u32)(c), __func__);              \
+} while(0)
+
+#define PUSH_MTHD_HDR(p,c,m,n) PUSH_HDR(p, METHOD, "incr", PUSH006C_SUBC_##c, m, n)
+#define PUSH_MTHD_INC 4:4
+#define PUSH_NINC_HDR(p,c,m,n) PUSH_HDR(p, NONINC_METHOD, "ninc", PUSH006C_SUBC_##c, m, n)
+#define PUSH_NINC_INC 0:0
+
+#define PUSH_JUMP(p,o) do {                                         \
+        PUSH_ASSERT(!((o) & ~0x1fffffffcULL), "offset");            \
+	PUSH_DATA__((p), NVVAL_X(NV06C_OPCODE, NV06C_OPCODE_JUMP) | \
+			 NVVAL_X(NV06C_JUMP_OFFSET, (o) >> 2),      \
+		    " jump 0x%08x - %s", (u32)(o), __func__);       \
+} while(0)
+#endif
diff --git a/drivers/gpu/drm/nouveau/include/nvif/push206e.h b/drivers/gpu/drm/nouveau/include/nvif/push206e.h
new file mode 100644
index 000000000000..1dfb8a35423e
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/include/nvif/push206e.h
@@ -0,0 +1,13 @@
+#ifndef __NVIF_PUSH206E_H__
+#define __NVIF_PUSH206E_H__
+#include <nvif/push006c.h>
+
+#include <nvhw/class/cl206e.h>
+
+#define PUSH_CALL(p,o) do {                                         \
+        PUSH_ASSERT(!((o) & ~0xffffffffcULL), "offset");            \
+	PUSH_DATA__((p), NVDEF(NV206E, DMA, OPCODE2, CALL) |        \
+			 NVVAL(NV206E, DMA, CALL_OFFSET, (o) >> 2), \
+		    " call 0x%08x - %s", (u32)(o), __func__);       \
+} while(0)
+#endif
diff --git a/drivers/gpu/drm/nouveau/include/nvif/push906f.h b/drivers/gpu/drm/nouveau/include/nvif/push906f.h
new file mode 100644
index 000000000000..cc2866bc8b0a
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/include/nvif/push906f.h
@@ -0,0 +1,48 @@
+#ifndef __NVIF_PUSH906F_H__
+#define __NVIF_PUSH906F_H__
+#include <nvif/push.h>
+
+#include <nvhw/class/cl906f.h>
+
+#ifndef PUSH906F_SUBC
+// Host methods
+#define PUSH906F_SUBC_NV906F	0
+
+// Twod
+#define PUSH906F_SUBC_NV902D	3
+
+// MemoryToMemoryFormat
+#define PUSH906F_SUBC_NV9039	4
+
+// DmaCopy
+#define PUSH906F_SUBC_NV90B5	4
+#define PUSH906F_SUBC_NVA0B5	4
+#endif
+
+#define PUSH_HDR(p,o,n,f,s,m,c) do {                                                \
+        PUSH_ASSERT(!((s) & ~DRF_MASK(NV906F_DMA_METHOD_SUBCHANNEL)), "subc");      \
+        PUSH_ASSERT(!((m) & ~(DRF_MASK(NV906F_DMA_METHOD_ADDRESS) << 2)), "mthd");   \
+        PUSH_ASSERT(!((c) & ~DRF_MASK(NV906F_DMA_METHOD_COUNT)), "count/immd");     \
+        PUSH_DATA__((p), NVVAL(NV906F, DMA, METHOD_ADDRESS, (m) >> 2) |             \
+			 NVVAL(NV906F, DMA, METHOD_SUBCHANNEL, (s)) |               \
+			 NVVAL(NV906F, DMA, METHOD_COUNT, (c)) |                    \
+			 NVDEF(NV906F, DMA, SEC_OP, o),                             \
+		    " "n" subc %d mthd 0x%04x "f" - %s",                            \
+		    (u32)(s), (u32)(m), (u32)(c), __func__);                        \
+} while(0)
+
+#define PUSH_MTHD_INC 4:4
+#define PUSH_MTHD_HDR(p,c,m,n) \
+	PUSH_HDR(p, INC_METHOD, "incr", "size %d", PUSH906F_SUBC_##c, m, n)
+
+#define PUSH_NINC_INC 0:0
+#define PUSH_NINC_HDR(p,c,m,n) \
+	PUSH_HDR(p, NON_INC_METHOD, "ninc", "size %d", PUSH906F_SUBC_##c, m, n)
+
+#define PUSH_IMMD_HDR(p,c,m,n) \
+	PUSH_HDR(p, IMMD_DATA_METHOD, "immd", "data 0x%04x", PUSH906F_SUBC_##c, m, n)
+
+#define PUSH_1INC_INC 4:0
+#define PUSH_1INC_HDR(p,c,m,n) \
+	PUSH_HDR(p, ONE_INC, "oinc", "size %d", PUSH906F_SUBC_##c, m, n)
+#endif
diff --git a/drivers/gpu/drm/nouveau/nouveau_dma.h b/drivers/gpu/drm/nouveau/nouveau_dma.h
index fc5e3f41282d..d00cf7bd220c 100644
--- a/drivers/gpu/drm/nouveau/nouveau_dma.h
+++ b/drivers/gpu/drm/nouveau/nouveau_dma.h
@@ -47,7 +47,6 @@ void nv50_dma_push(struct nouveau_channel *, u64 addr, int length);
 
 /* Hardcoded object assignments to subchannels (subchannel id). */
 enum {
-	NvSubCtxSurf2D  = 0,
 	NvSubSw		= 1,
 	NvSubImageBlit  = 2,
 	NvSubGdiRect    = 3,
diff --git a/drivers/gpu/drm/nouveau/nv04_fbcon.c b/drivers/gpu/drm/nouveau/nv04_fbcon.c
index 936e11f526b6..a254e5f7fad1 100644
--- a/drivers/gpu/drm/nouveau/nv04_fbcon.c
+++ b/drivers/gpu/drm/nouveau/nv04_fbcon.c
@@ -21,11 +21,13 @@
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  */
-
+#define NVIF_DEBUG_PRINT_DISABLE
 #include "nouveau_drv.h"
 #include "nouveau_dma.h"
 #include "nouveau_fbcon.h"
 
+#include <nvif/push006c.h>
+
 int
 nv04_fbcon_copyarea(struct fb_info *info, const struct fb_copyarea *region)
 {
@@ -137,6 +139,7 @@ nv04_fbcon_accel_init(struct fb_info *info)
 	struct nouveau_drm *drm = nouveau_drm(dev);
 	struct nouveau_channel *chan = drm->channel;
 	struct nvif_device *device = &drm->client.device;
+	struct nvif_push *push = chan->chan.push;
 	int surface_fmt, pattern_fmt, rect_fmt;
 	int ret;
 
@@ -200,78 +203,58 @@ nv04_fbcon_accel_init(struct fb_info *info)
 	if (ret)
 		return ret;
 
-	if (RING_SPACE(chan, 49 + (device->info.chipset >= 0x11 ? 4 : 0))) {
+	if (PUSH_WAIT(push, 49 + (device->info.chipset >= 0x11 ? 4 : 0))) {
 		nouveau_fbcon_gpu_lockup(info);
 		return 0;
 	}
 
-	BEGIN_NV04(chan, NvSubCtxSurf2D, 0x0000, 1);
-	OUT_RING(chan, nfbdev->surf2d.handle);
-	BEGIN_NV04(chan, NvSubCtxSurf2D, 0x0184, 2);
-	OUT_RING(chan, chan->vram.handle);
-	OUT_RING(chan, chan->vram.handle);
-	BEGIN_NV04(chan, NvSubCtxSurf2D, 0x0300, 4);
-	OUT_RING(chan, surface_fmt);
-	OUT_RING(chan, info->fix.line_length | (info->fix.line_length << 16));
-	OUT_RING(chan, info->fix.smem_start - dev->mode_config.fb_base);
-	OUT_RING(chan, info->fix.smem_start - dev->mode_config.fb_base);
-
-	BEGIN_NV04(chan, NvSubCtxSurf2D, 0x0000, 1);
-	OUT_RING(chan, nfbdev->rop.handle);
-	BEGIN_NV04(chan, NvSubCtxSurf2D, 0x0300, 1);
-	OUT_RING(chan, 0x55);
-
-	BEGIN_NV04(chan, NvSubCtxSurf2D, 0x0000, 1);
-	OUT_RING(chan, nfbdev->patt.handle);
-	BEGIN_NV04(chan, NvSubCtxSurf2D, 0x0300, 8);
-	OUT_RING(chan, pattern_fmt);
+	PUSH_NVSQ(push, NV042, 0x0000, nfbdev->surf2d.handle);
+	PUSH_NVSQ(push, NV042, 0x0184, chan->vram.handle,
+			       0x0188, chan->vram.handle);
+	PUSH_NVSQ(push, NV042, 0x0300, surface_fmt,
+			       0x0304, info->fix.line_length | (info->fix.line_length << 16),
+			       0x0308, info->fix.smem_start - dev->mode_config.fb_base,
+			       0x030c, info->fix.smem_start - dev->mode_config.fb_base);
+
+	PUSH_NVSQ(push, NV043, 0x0000, nfbdev->rop.handle);
+	PUSH_NVSQ(push, NV043, 0x0300, 0x55);
+
+	PUSH_NVSQ(push, NV044, 0x0000, nfbdev->patt.handle);
+	PUSH_NVSQ(push, NV044, 0x0300, pattern_fmt,
 #ifdef __BIG_ENDIAN
-	OUT_RING(chan, 2);
+			       0x0304, 2,
 #else
-	OUT_RING(chan, 1);
+			       0x0304, 1,
 #endif
-	OUT_RING(chan, 0);
-	OUT_RING(chan, 1);
-	OUT_RING(chan, ~0);
-	OUT_RING(chan, ~0);
-	OUT_RING(chan, ~0);
-	OUT_RING(chan, ~0);
-
-	BEGIN_NV04(chan, NvSubCtxSurf2D, 0x0000, 1);
-	OUT_RING(chan, nfbdev->clip.handle);
-	BEGIN_NV04(chan, NvSubCtxSurf2D, 0x0300, 2);
-	OUT_RING(chan, 0);
-	OUT_RING(chan, (info->var.yres_virtual << 16) | info->var.xres_virtual);
-
-	BEGIN_NV04(chan, NvSubImageBlit, 0x0000, 1);
-	OUT_RING(chan, nfbdev->blit.handle);
-	BEGIN_NV04(chan, NvSubImageBlit, 0x019c, 1);
-	OUT_RING(chan, nfbdev->surf2d.handle);
-	BEGIN_NV04(chan, NvSubImageBlit, 0x02fc, 1);
-	OUT_RING(chan, 3);
-	if (device->info.chipset >= 0x11 /*XXX: oclass == 0x009f*/) {
-		BEGIN_NV04(chan, NvSubImageBlit, 0x0120, 3);
-		OUT_RING(chan, 0);
-		OUT_RING(chan, 1);
-		OUT_RING(chan, 2);
+			       0x0308, 0,
+			       0x030c, 1,
+			       0x0310, ~0,
+			       0x0314, ~0,
+			       0x0318, ~0,
+			       0x031c, ~0);
+
+	PUSH_NVSQ(push, NV019, 0x0000, nfbdev->clip.handle);
+	PUSH_NVSQ(push, NV019, 0x0300, 0,
+			       0x0304, (info->var.yres_virtual << 16) | info->var.xres_virtual);
+
+	PUSH_NVSQ(push, NV05F, 0x0000, nfbdev->blit.handle);
+	PUSH_NVSQ(push, NV05F, 0x019c, nfbdev->surf2d.handle);
+	PUSH_NVSQ(push, NV05F, 0x02fc, 3);
+	if (nfbdev->blit.oclass == 0x009f) {
+		PUSH_NVSQ(push, NV09F, 0x0120, 0,
+				       0x0124, 1,
+				       0x0128, 2);
 	}
 
-	BEGIN_NV04(chan, NvSubGdiRect, 0x0000, 1);
-	OUT_RING(chan, nfbdev->gdi.handle);
-	BEGIN_NV04(chan, NvSubGdiRect, 0x0198, 1);
-	OUT_RING(chan, nfbdev->surf2d.handle);
-	BEGIN_NV04(chan, NvSubGdiRect, 0x0188, 2);
-	OUT_RING(chan, nfbdev->patt.handle);
-	OUT_RING(chan, nfbdev->rop.handle);
-	BEGIN_NV04(chan, NvSubGdiRect, 0x0304, 1);
-	OUT_RING(chan, 1);
-	BEGIN_NV04(chan, NvSubGdiRect, 0x0300, 1);
-	OUT_RING(chan, rect_fmt);
-	BEGIN_NV04(chan, NvSubGdiRect, 0x02fc, 1);
-	OUT_RING(chan, 3);
-
-	FIRE_RING(chan);
+	PUSH_NVSQ(push, NV04A, 0x0000, nfbdev->gdi.handle);
+	PUSH_NVSQ(push, NV04A, 0x0198, nfbdev->surf2d.handle);
+	PUSH_NVSQ(push, NV04A, 0x0188, nfbdev->patt.handle,
+			       0x018c, nfbdev->rop.handle);
+	PUSH_NVSQ(push, NV04A, 0x0304, 1);
+	PUSH_NVSQ(push, NV04A, 0x0300, rect_fmt);
+	PUSH_NVSQ(push, NV04A, 0x02fc, 3);
 
+	PUSH_KICK(push);
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/nouveau/nv50_fbcon.c b/drivers/gpu/drm/nouveau/nv50_fbcon.c
index 31d8dca54f9f..36348f72ecb3 100644
--- a/drivers/gpu/drm/nouveau/nv50_fbcon.c
+++ b/drivers/gpu/drm/nouveau/nv50_fbcon.c
@@ -21,12 +21,14 @@
  *
  * Authors: Ben Skeggs
  */
-
+#define NVIF_DEBUG_PRINT_DISABLE
 #include "nouveau_drv.h"
 #include "nouveau_dma.h"
 #include "nouveau_fbcon.h"
 #include "nouveau_vmm.h"
 
+#include <nvif/push206e.h>
+
 int
 nv50_fbcon_fillrect(struct fb_info *info, const struct fb_fillrect *rect)
 {
@@ -152,6 +154,7 @@ nv50_fbcon_accel_init(struct fb_info *info)
 	struct drm_device *dev = nfbdev->helper.dev;
 	struct nouveau_drm *drm = nouveau_drm(dev);
 	struct nouveau_channel *chan = drm->channel;
+	struct nvif_push *push = chan->chan.push;
 	int ret, format;
 
 	switch (info->var.bits_per_pixel) {
@@ -186,72 +189,60 @@ nv50_fbcon_accel_init(struct fb_info *info)
 	if (ret)
 		return ret;
 
-	ret = RING_SPACE(chan, 58);
+	ret = PUSH_WAIT(push, 56);
 	if (ret) {
 		nouveau_fbcon_gpu_lockup(info);
 		return ret;
 	}
 
-	BEGIN_NV04(chan, NvSub2D, 0x0000, 1);
-	OUT_RING(chan, nfbdev->twod.handle);
-	BEGIN_NV04(chan, NvSub2D, 0x0184, 3);
-	OUT_RING(chan, chan->vram.handle);
-	OUT_RING(chan, chan->vram.handle);
-	OUT_RING(chan, chan->vram.handle);
-	BEGIN_NV04(chan, NvSub2D, 0x0290, 1);
-	OUT_RING(chan, 0);
-	BEGIN_NV04(chan, NvSub2D, 0x0888, 1);
-	OUT_RING(chan, 1);
-	BEGIN_NV04(chan, NvSub2D, 0x02ac, 1);
-	OUT_RING(chan, 3);
-	BEGIN_NV04(chan, NvSub2D, 0x02a0, 1);
-	OUT_RING(chan, 0x55);
-	BEGIN_NV04(chan, NvSub2D, 0x08c0, 4);
-	OUT_RING(chan, 0);
-	OUT_RING(chan, 1);
-	OUT_RING(chan, 0);
-	OUT_RING(chan, 1);
-	BEGIN_NV04(chan, NvSub2D, 0x0580, 2);
-	OUT_RING(chan, 4);
-	OUT_RING(chan, format);
-	BEGIN_NV04(chan, NvSub2D, 0x02e8, 2);
-	OUT_RING(chan, 2);
-	OUT_RING(chan, 1);
-	BEGIN_NV04(chan, NvSub2D, 0x0804, 1);
-	OUT_RING(chan, format);
-	BEGIN_NV04(chan, NvSub2D, 0x0800, 1);
-	OUT_RING(chan, 1);
-	BEGIN_NV04(chan, NvSub2D, 0x0808, 3);
-	OUT_RING(chan, 0);
-	OUT_RING(chan, 0);
-	OUT_RING(chan, 1);
-	BEGIN_NV04(chan, NvSub2D, 0x081c, 1);
-	OUT_RING(chan, 1);
-	BEGIN_NV04(chan, NvSub2D, 0x0840, 4);
-	OUT_RING(chan, 0);
-	OUT_RING(chan, 1);
-	OUT_RING(chan, 0);
-	OUT_RING(chan, 1);
-	BEGIN_NV04(chan, NvSub2D, 0x0200, 2);
-	OUT_RING(chan, format);
-	OUT_RING(chan, 1);
-	BEGIN_NV04(chan, NvSub2D, 0x0214, 5);
-	OUT_RING(chan, info->fix.line_length);
-	OUT_RING(chan, info->var.xres_virtual);
-	OUT_RING(chan, info->var.yres_virtual);
-	OUT_RING(chan, upper_32_bits(nfbdev->vma->addr));
-	OUT_RING(chan, lower_32_bits(nfbdev->vma->addr));
-	BEGIN_NV04(chan, NvSub2D, 0x0230, 2);
-	OUT_RING(chan, format);
-	OUT_RING(chan, 1);
-	BEGIN_NV04(chan, NvSub2D, 0x0244, 5);
-	OUT_RING(chan, info->fix.line_length);
-	OUT_RING(chan, info->var.xres_virtual);
-	OUT_RING(chan, info->var.yres_virtual);
-	OUT_RING(chan, upper_32_bits(nfbdev->vma->addr));
-	OUT_RING(chan, lower_32_bits(nfbdev->vma->addr));
-	FIRE_RING(chan);
-
+	PUSH_NVSQ(push, NV502D, 0x0000, nfbdev->twod.handle);
+	PUSH_NVSQ(push, NV502D, 0x0184, chan->vram.handle,
+				0x0188, chan->vram.handle,
+				0x018c, chan->vram.handle);
+
+	PUSH_NVSQ(push, NV502D, 0x0200, format,
+				0x0204, 1);
+	PUSH_NVSQ(push, NV502D, 0x0214, info->fix.line_length,
+				0x0218, info->var.xres_virtual,
+				0x021c, info->var.yres_virtual,
+				0x0220, upper_32_bits(nfbdev->vma->addr),
+				0x0224, lower_32_bits(nfbdev->vma->addr));
+
+	PUSH_NVSQ(push, NV502D, 0x0230, format,
+				0x0234, 1);
+	PUSH_NVSQ(push, NV502D, 0x0244, info->fix.line_length,
+				0x0248, info->var.xres_virtual,
+				0x024c, info->var.yres_virtual,
+				0x0250, upper_32_bits(nfbdev->vma->addr),
+				0x0254, lower_32_bits(nfbdev->vma->addr));
+
+	PUSH_NVSQ(push, NV502D, 0x0290, 0);
+	PUSH_NVSQ(push, NV502D, 0x02a0, 0x55);
+	PUSH_NVSQ(push, NV502D, 0x02ac, 3);
+	PUSH_NVSQ(push, NV502D, 0x02e8, 2,
+				0x02ec, 1);
+
+	PUSH_NVSQ(push, NV502D, 0X0580, 4,
+				0x0584, format);
+
+	PUSH_NVSQ(push, NV502D, 0x0800, 1,
+				0x0804, format,
+				0x0808, 0,
+				0x080c, 0,
+				0x0810, 1);
+	PUSH_NVSQ(push, NV502D, 0x081c, 1);
+	PUSH_NVSQ(push, NV502D, 0x0840, 0,
+				0x0844, 1,
+				0x0848, 0,
+				0x084c, 1);
+
+	PUSH_NVSQ(push, NV502D, 0x0888, 1);
+	PUSH_NVSQ(push, NV502D, 0x08c0, 0,
+				0x08c4, 1,
+				0x08c8, 0,
+				0x08cc, 1);
+
+	PUSH_KICK(push);
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/nouveau/nvc0_fbcon.c b/drivers/gpu/drm/nouveau/nvc0_fbcon.c
index d6ce6323bf41..2d213c365a43 100644
--- a/drivers/gpu/drm/nouveau/nvc0_fbcon.c
+++ b/drivers/gpu/drm/nouveau/nvc0_fbcon.c
@@ -21,12 +21,14 @@
  *
  * Authors: Ben Skeggs
  */
-
+#define NVIF_DEBUG_PRINT_DISABLE
 #include "nouveau_drv.h"
 #include "nouveau_dma.h"
 #include "nouveau_fbcon.h"
 #include "nouveau_vmm.h"
 
+#include <nvif/push906f.h>
+
 int
 nvc0_fbcon_fillrect(struct fb_info *info, const struct fb_fillrect *rect)
 {
@@ -152,6 +154,7 @@ nvc0_fbcon_accel_init(struct fb_info *info)
 	struct drm_device *dev = nfbdev->helper.dev;
 	struct nouveau_drm *drm = nouveau_drm(dev);
 	struct nouveau_channel *chan = drm->channel;
+	struct nvif_push *push = chan->chan.push;
 	int ret, format;
 
 	ret = nvif_object_ctor(&chan->user, "fbconTwoD", 0x902d, 0x902d,
@@ -186,74 +189,58 @@ nvc0_fbcon_accel_init(struct fb_info *info)
 		return -EINVAL;
 	}
 
-	ret = RING_SPACE(chan, 58);
+	ret = PUSH_WAIT(push, 52);
 	if (ret) {
 		WARN_ON(1);
 		nouveau_fbcon_gpu_lockup(info);
 		return ret;
 	}
 
-	BEGIN_NVC0(chan, NvSub2D, 0x0000, 1);
-	OUT_RING  (chan, nfbdev->twod.handle);
-	BEGIN_NVC0(chan, NvSub2D, 0x0290, 1);
-	OUT_RING  (chan, 0);
-	BEGIN_NVC0(chan, NvSub2D, 0x0888, 1);
-	OUT_RING  (chan, 1);
-	BEGIN_NVC0(chan, NvSub2D, 0x02ac, 1);
-	OUT_RING  (chan, 3);
-	BEGIN_NVC0(chan, NvSub2D, 0x02a0, 1);
-	OUT_RING  (chan, 0x55);
-	BEGIN_NVC0(chan, NvSub2D, 0x08c0, 4);
-	OUT_RING  (chan, 0);
-	OUT_RING  (chan, 1);
-	OUT_RING  (chan, 0);
-	OUT_RING  (chan, 1);
-	BEGIN_NVC0(chan, NvSub2D, 0x0580, 2);
-	OUT_RING  (chan, 4);
-	OUT_RING  (chan, format);
-	BEGIN_NVC0(chan, NvSub2D, 0x02e8, 2);
-	OUT_RING  (chan, 2);
-	OUT_RING  (chan, 1);
-
-	BEGIN_NVC0(chan, NvSub2D, 0x0804, 1);
-	OUT_RING  (chan, format);
-	BEGIN_NVC0(chan, NvSub2D, 0x0800, 1);
-	OUT_RING  (chan, 1);
-	BEGIN_NVC0(chan, NvSub2D, 0x0808, 3);
-	OUT_RING  (chan, 0);
-	OUT_RING  (chan, 0);
-	OUT_RING  (chan, 1);
-	BEGIN_NVC0(chan, NvSub2D, 0x081c, 1);
-	OUT_RING  (chan, 1);
-	BEGIN_NVC0(chan, NvSub2D, 0x0840, 4);
-	OUT_RING  (chan, 0);
-	OUT_RING  (chan, 1);
-	OUT_RING  (chan, 0);
-	OUT_RING  (chan, 1);
-	BEGIN_NVC0(chan, NvSub2D, 0x0200, 10);
-	OUT_RING  (chan, format);
-	OUT_RING  (chan, 1);
-	OUT_RING  (chan, 0);
-	OUT_RING  (chan, 1);
-	OUT_RING  (chan, 0);
-	OUT_RING  (chan, info->fix.line_length);
-	OUT_RING  (chan, info->var.xres_virtual);
-	OUT_RING  (chan, info->var.yres_virtual);
-	OUT_RING  (chan, upper_32_bits(nfbdev->vma->addr));
-	OUT_RING  (chan, lower_32_bits(nfbdev->vma->addr));
-	BEGIN_NVC0(chan, NvSub2D, 0x0230, 10);
-	OUT_RING  (chan, format);
-	OUT_RING  (chan, 1);
-	OUT_RING  (chan, 0);
-	OUT_RING  (chan, 1);
-	OUT_RING  (chan, 0);
-	OUT_RING  (chan, info->fix.line_length);
-	OUT_RING  (chan, info->var.xres_virtual);
-	OUT_RING  (chan, info->var.yres_virtual);
-	OUT_RING  (chan, upper_32_bits(nfbdev->vma->addr));
-	OUT_RING  (chan, lower_32_bits(nfbdev->vma->addr));
-	FIRE_RING (chan);
-
+	PUSH_NVSQ(push, NV902D, 0x0000, nfbdev->twod.handle);
+
+	PUSH_NVSQ(push, NV902D, 0x0200, format,
+				0x0204, 1);
+	PUSH_NVSQ(push, NV902D, 0x0214, info->fix.line_length,
+				0x0218, info->var.xres_virtual,
+				0x021c, info->var.yres_virtual,
+				0x0220, upper_32_bits(nfbdev->vma->addr),
+				0x0224, lower_32_bits(nfbdev->vma->addr));
+
+	PUSH_NVSQ(push, NV902D, 0x0230, format,
+				0x0234, 1);
+	PUSH_NVSQ(push, NV902D, 0x0244, info->fix.line_length,
+				0x0248, info->var.xres_virtual,
+				0x024c, info->var.yres_virtual,
+				0x0250, upper_32_bits(nfbdev->vma->addr),
+				0x0254, lower_32_bits(nfbdev->vma->addr));
+
+	PUSH_NVIM(push, NV902D, 0x0290, 0);
+	PUSH_NVIM(push, NV902D, 0x02a0, 0x55);
+	PUSH_NVIM(push, NV902D, 0x02ac, 3);
+	PUSH_NVSQ(push, NV902D, 0x02e8, 2,
+				0x02ec, 1);
+
+	PUSH_NVSQ(push, NV902D, 0X0580, 4,
+				0x0584, format);
+
+	PUSH_NVSQ(push, NV902D, 0x0800, 1,
+				0x0804, format,
+				0x0808, 0,
+				0x080c, 0,
+				0x0810, 1);
+	PUSH_NVIM(push, NV902D, 0x081c, 1);
+	PUSH_NVSQ(push, NV902D, 0x0840, 0,
+				0x0844, 1,
+				0x0848, 0,
+				0x084c, 1);
+
+	PUSH_NVIM(push, NV902D, 0x0888, 1);
+	PUSH_NVSQ(push, NV902D, 0x08c0, 0,
+				0x08c4, 1,
+				0x08c8, 0,
+				0x08cc, 1);
+
+	PUSH_KICK(push);
 	return 0;
 }
 
-- 
2.29.2

