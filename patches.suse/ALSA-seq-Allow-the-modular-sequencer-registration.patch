From 111b0cdb97d44cfe5dec1338a78ba8aff65c32e2 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Fri, 9 Jun 2017 15:11:58 +0200
Subject: [PATCH] ALSA: seq: Allow the modular sequencer registration
Git-commit: 111b0cdb97d44cfe5dec1338a78ba8aff65c32e2
Patch-mainline: v4.13-rc1
References: bsc#1121278

Many drivers bind the sequencer stuff in off-load by another driver
module, so that it's loaded only on demand.  In the current code, this
mechanism doesn't work when the driver is built-in while the sequencer
is module.  We check with IS_REACHABLE() and enable only when the
sequencer is in the same level of build.

However, this is basically a overshoot.  The binder code
(snd-seq-device) is an individual module from the sequencer core
(snd-seq), and we just have to make the former a built-in while
keeping the latter a module for allowing the scenario like the above.

This patch achieves that by rewriting Kconfig slightly.  Now, a driver
that provides the manual sequencer device binding should select
CONFIG_SND_SEQ_DEVICE in a way as
	select SND_SEQ_DEVICE if SND_SEQUENCER != n

Note that the "!=n" is needed here to avoid the influence of the
sequencer core is module while the driver is built-in.

Also, since rawmidi.o may be linked with snd_seq_device.o when
built-in, we have to shuffle the code to make the linker happy.
(the kernel linker isn't smart enough yet to handle such a case.)
That is, snd_seq_device.c is moved to sound/core from sound/core/seq,
as well as Makefile.

Last but not least, the patch replaces the code using IS_REACHABLE()
with IS_ENABLED(), since now the condition meets always when enabled.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 sound/core/Kconfig                | 4 ++++
 sound/core/Makefile               | 2 ++
 sound/core/rawmidi.c              | 4 ++--
 sound/core/seq/Kconfig            | 2 +-
 sound/core/seq/Makefile           | 3 +--
 sound/core/{seq => }/seq_device.c | 0
 sound/core/Kconfig              |    4 
 sound/core/Makefile             |    2 
 sound/core/rawmidi.c            |    4 
 sound/core/seq/Kconfig          |    2 
 sound/core/seq/Makefile         |    3 
 sound/core/seq/seq_device.c     |  315 ----------------------------------------
 sound/core/seq_device.c         |  315 ++++++++++++++++++++++++++++++++++++++++
 sound/drivers/Kconfig           |    2 
 sound/drivers/opl3/opl3_lib.c   |    2 
 sound/drivers/opl4/opl4_lib.c   |    4 
 sound/drivers/opl4/opl4_local.h |    2 
 sound/isa/Kconfig               |    1 
 sound/isa/sb/emu8000.c          |    2 
 sound/isa/sb/sb16.c             |    2 
 sound/pci/Kconfig               |    1 
 sound/pci/emu10k1/emu10k1.c     |    2 
 16 files changed, 336 insertions(+), 327 deletions(-)
 rename sound/core/{seq => }/seq_device.c (100%)

--- a/sound/core/Kconfig
+++ b/sound/core/Kconfig
@@ -18,8 +18,12 @@ config SND_DMAENGINE_PCM
 config SND_HWDEP
 	tristate
 
+config SND_SEQ_DEVICE
+	tristate
+
 config SND_RAWMIDI
 	tristate
+	select SND_SEQ_DEVICE if SND_SEQUENCER != n
 
 config SND_COMPRESS_OFFLOAD
 	tristate
--- a/sound/core/Makefile
+++ b/sound/core/Makefile
@@ -31,6 +31,7 @@ snd-timer-objs    := timer.o
 snd-hrtimer-objs  := hrtimer.o
 snd-rtctimer-objs := rtctimer.o
 snd-hwdep-objs    := hwdep.o
+snd-seq-device-objs := seq_device.o
 
 snd-compress-objs := compress_offload.o
 
@@ -40,6 +41,7 @@ obj-$(CONFIG_SND_TIMER)		+= snd-timer.o
 obj-$(CONFIG_SND_HRTIMER)	+= snd-hrtimer.o
 obj-$(CONFIG_SND_PCM)		+= snd-pcm.o
 obj-$(CONFIG_SND_DMAENGINE_PCM)	+= snd-pcm-dmaengine.o
+obj-$(CONFIG_SND_SEQ_DEVICE)	+= snd-seq-device.o
 obj-$(CONFIG_SND_RAWMIDI)	+= snd-rawmidi.o
 
 obj-$(CONFIG_SND_OSSEMUL)	+= oss/
--- a/sound/core/rawmidi.c
+++ b/sound/core/rawmidi.c
@@ -1610,7 +1610,7 @@ static int snd_rawmidi_dev_free(struct s
 	return snd_rawmidi_free(rmidi);
 }
 
-#if IS_REACHABLE(CONFIG_SND_SEQUENCER)
+#if IS_ENABLED(CONFIG_SND_SEQUENCER)
 static void snd_rawmidi_dev_seq_free(struct snd_seq_device *device)
 {
 	struct snd_rawmidi *rmidi = device->private_data;
@@ -1691,7 +1691,7 @@ static int snd_rawmidi_dev_register(stru
 		}
 	}
 	rmidi->proc_entry = entry;
-#if IS_REACHABLE(CONFIG_SND_SEQUENCER)
+#if IS_ENABLED(CONFIG_SND_SEQUENCER)
 	if (!rmidi->ops || !rmidi->ops->dev_register) { /* own registration mechanism */
 		if (snd_seq_device_new(rmidi->card, rmidi->device, SNDRV_SEQ_DEV_ID_MIDISYNTH, 0, &rmidi->seq_dev) >= 0) {
 			rmidi->seq_dev->private_data = rmidi;
--- a/sound/core/seq/Kconfig
+++ b/sound/core/seq/Kconfig
@@ -1,6 +1,7 @@
 config SND_SEQUENCER
 	tristate "Sequencer support"
 	select SND_TIMER
+	select SND_SEQ_DEVICE
 	help
 	  Say Y or M to enable MIDI sequencer and router support.  This
 	  feature allows routing and enqueueing of MIDI events.  Events
@@ -59,4 +60,3 @@ config SND_SEQ_VIRMIDI
 	tristate
 
 endif # SND_SEQUENCER
-
--- a/sound/core/seq/Makefile
+++ b/sound/core/seq/Makefile
@@ -3,7 +3,6 @@
 # Copyright (c) 1999 by Jaroslav Kysela <perex@perex.cz>
 #
 
-snd-seq-device-objs := seq_device.o
 snd-seq-objs := seq.o seq_lock.o seq_clientmgr.o seq_memory.o seq_queue.o \
                 seq_fifo.o seq_prioq.o seq_timer.o \
                 seq_system.o seq_ports.o
@@ -14,7 +13,7 @@ snd-seq-midi-event-objs := seq_midi_even
 snd-seq-dummy-objs := seq_dummy.o
 snd-seq-virmidi-objs := seq_virmidi.o
 
-obj-$(CONFIG_SND_SEQUENCER) += snd-seq.o snd-seq-device.o
+obj-$(CONFIG_SND_SEQUENCER) += snd-seq.o
 obj-$(CONFIG_SND_SEQUENCER_OSS) += oss/
 
 obj-$(CONFIG_SND_SEQ_DUMMY) += snd-seq-dummy.o
--- a/sound/drivers/Kconfig
+++ b/sound/drivers/Kconfig
@@ -6,11 +6,13 @@ config SND_OPL3_LIB
 	tristate
 	select SND_TIMER
 	select SND_HWDEP
+	select SND_SEQ_DEVICE if SND_SEQUENCER != n
 
 config SND_OPL4_LIB
 	tristate
 	select SND_TIMER
 	select SND_HWDEP
+	select SND_SEQ_DEVICE if SND_SEQUENCER != n
 
 # select SEQ stuff to min(SND_SEQUENCER,SND_XXX)
 config SND_OPL3_LIB_SEQ
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -528,7 +528,7 @@ int snd_opl3_hwdep_new(struct snd_opl3 *
 
 	opl3->hwdep = hw;
 	opl3->seq_dev_num = seq_device;
-#if IS_REACHABLE(CONFIG_SND_SEQUENCER)
+#if IS_ENABLED(CONFIG_SND_SEQUENCER)
 	if (snd_seq_device_new(card, seq_device, SNDRV_SEQ_DEV_ID_OPL3,
 			       sizeof(struct snd_opl3 *), &opl3->seq_dev) >= 0) {
 		strcpy(opl3->seq_dev->name, hw->name);
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -153,7 +153,7 @@ static int snd_opl4_detect(struct snd_op
 	return 0;
 }
 
-#if IS_REACHABLE(CONFIG_SND_SEQUENCER)
+#if IS_ENABLED(CONFIG_SND_SEQUENCER)
 static void snd_opl4_seq_dev_free(struct snd_seq_device *seq_dev)
 {
 	struct snd_opl4 *opl4 = seq_dev->private_data;
@@ -249,7 +249,7 @@ int snd_opl4_create(struct snd_card *car
 	snd_opl4_create_mixer(opl4);
 	snd_opl4_create_proc(opl4);
 
-#if IS_REACHABLE(CONFIG_SND_SEQUENCER)
+#if IS_ENABLED(CONFIG_SND_SEQUENCER)
 	opl4->seq_client = -1;
 	if (opl4->hardware < OPL3_HW_OPL4_ML)
 		snd_opl4_create_seq_dev(opl4, seq_device);
--- a/sound/drivers/opl4/opl4_local.h
+++ b/sound/drivers/opl4/opl4_local.h
@@ -184,7 +184,7 @@ struct snd_opl4 {
 #endif
 	struct mutex access_mutex;
 
-#if IS_REACHABLE(CONFIG_SND_SEQUENCER)
+#if IS_ENABLED(CONFIG_SND_SEQUENCER)
 	int used;
 
 	int seq_dev_num;
--- a/sound/isa/Kconfig
+++ b/sound/isa/Kconfig
@@ -377,6 +377,7 @@ config SND_SBAWE
 	select SND_OPL3_LIB
 	select SND_MPU401_UART
 	select SND_SB16_DSP
+	select SND_SEQ_DEVICE if SND_SEQUENCER != n
 	help
 	  Say Y here to include support for Sound Blaster AWE soundcards
 	  (including the Plug and Play version).
--- a/sound/isa/sb/emu8000.c
+++ b/sound/isa/sb/emu8000.c
@@ -1138,7 +1138,7 @@ snd_emu8000_new(struct snd_card *card, i
 		snd_emu8000_free(hw);
 		return err;
 	}
-#if IS_REACHABLE(CONFIG_SND_SEQUENCER)
+#if IS_ENABLED(CONFIG_SND_SEQUENCER)
 	if (snd_seq_device_new(card, index, SNDRV_SEQ_DEV_ID_EMU8000,
 			       sizeof(struct snd_emu8000*), &awe) >= 0) {
 		strcpy(awe->name, "EMU-8000");
--- a/sound/isa/sb/sb16.c
+++ b/sound/isa/sb/sb16.c
@@ -62,7 +62,7 @@ MODULE_SUPPORTED_DEVICE("{{Creative Labs
 #define SNDRV_DEBUG_IRQ
 #endif
 
-#if defined(SNDRV_SBAWE) && IS_REACHABLE(CONFIG_SND_SEQUENCER)
+#if defined(SNDRV_SBAWE) && IS_ENABLED(CONFIG_SND_SEQUENCER)
 #define SNDRV_SBAWE_EMU8000
 #endif
 
--- a/sound/pci/Kconfig
+++ b/sound/pci/Kconfig
@@ -465,6 +465,7 @@ config SND_EMU10K1
 	select SND_RAWMIDI
 	select SND_AC97_CODEC
 	select SND_TIMER
+	select SND_SEQ_DEVICE if SND_SEQUENCER != n
 	depends on ZONE_DMA
 	help
 	  Say Y to include support for Sound Blaster PCI 512, Live!,
--- a/sound/pci/emu10k1/emu10k1.c
+++ b/sound/pci/emu10k1/emu10k1.c
@@ -37,7 +37,7 @@ MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{Creative Labs,SB Live!/PCI512/E-mu APS},"
 	       "{Creative Labs,SB Audigy}}");
 
-#if IS_REACHABLE(CONFIG_SND_SEQUENCER)
+#if IS_ENABLED(CONFIG_SND_SEQUENCER)
 #define ENABLE_SYNTH
 #include <sound/emu10k1_synth.h>
 #endif
--- a/sound/core/seq/seq_device.c
+++ /dev/null
@@ -1,315 +0,0 @@
-/*
- *  ALSA sequencer device management
- *  Copyright (c) 1999 by Takashi Iwai <tiwai@suse.de>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- *
- *----------------------------------------------------------------
- *
- * This device handler separates the card driver module from sequencer
- * stuff (sequencer core, synth drivers, etc), so that user can avoid
- * to spend unnecessary resources e.g. if he needs only listening to
- * MP3s.
- *
- * The card (or lowlevel) driver creates a sequencer device entry
- * via snd_seq_device_new().  This is an entry pointer to communicate
- * with the sequencer device "driver", which is involved with the
- * actual part to communicate with the sequencer core.
- * Each sequencer device entry has an id string and the corresponding
- * driver with the same id is loaded when required.  For example,
- * lowlevel codes to access emu8000 chip on sbawe card are included in
- * emu8000-synth module.  To activate this module, the hardware
- * resources like i/o port are passed via snd_seq_device argument.
- *
- */
-
-#include <linux/device.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <sound/core.h>
-#include <sound/info.h>
-#include <sound/seq_device.h>
-#include <sound/seq_kernel.h>
-#include <sound/initval.h>
-#include <linux/kmod.h>
-#include <linux/slab.h>
-#include <linux/mutex.h>
-
-MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>");
-MODULE_DESCRIPTION("ALSA sequencer device management");
-MODULE_LICENSE("GPL");
-
-/*
- * bus definition
- */
-static int snd_seq_bus_match(struct device *dev, struct device_driver *drv)
-{
-	struct snd_seq_device *sdev = to_seq_dev(dev);
-	struct snd_seq_driver *sdrv = to_seq_drv(drv);
-
-	return strcmp(sdrv->id, sdev->id) == 0 &&
-		sdrv->argsize == sdev->argsize;
-}
-
-static struct bus_type snd_seq_bus_type = {
-	.name = "snd_seq",
-	.match = snd_seq_bus_match,
-};
-
-/*
- * proc interface -- just for compatibility
- */
-#ifdef CONFIG_SND_PROC_FS
-static struct snd_info_entry *info_entry;
-
-static int print_dev_info(struct device *dev, void *data)
-{
-	struct snd_seq_device *sdev = to_seq_dev(dev);
-	struct snd_info_buffer *buffer = data;
-
-	snd_iprintf(buffer, "snd-%s,%s,%d\n", sdev->id,
-		    dev->driver ? "loaded" : "empty",
-		    dev->driver ? 1 : 0);
-	return 0;
-}
-
-static void snd_seq_device_info(struct snd_info_entry *entry,
-				struct snd_info_buffer *buffer)
-{
-	bus_for_each_dev(&snd_seq_bus_type, NULL, buffer, print_dev_info);
-}
-#endif
-
-/*
- * load all registered drivers (called from seq_clientmgr.c)
- */
-
-#ifdef CONFIG_MODULES
-/* flag to block auto-loading */
-static atomic_t snd_seq_in_init = ATOMIC_INIT(1); /* blocked as default */
-
-static int request_seq_drv(struct device *dev, void *data)
-{
-	struct snd_seq_device *sdev = to_seq_dev(dev);
-
-	if (!dev->driver)
-		request_module("snd-%s", sdev->id);
-	return 0;
-}
-
-static void autoload_drivers(struct work_struct *work)
-{
-	/* avoid reentrance */
-	if (atomic_inc_return(&snd_seq_in_init) == 1)
-		bus_for_each_dev(&snd_seq_bus_type, NULL, NULL,
-				 request_seq_drv);
-	atomic_dec(&snd_seq_in_init);
-}
-
-static DECLARE_WORK(autoload_work, autoload_drivers);
-
-static void queue_autoload_drivers(void)
-{
-	schedule_work(&autoload_work);
-}
-
-void snd_seq_autoload_init(void)
-{
-	atomic_dec(&snd_seq_in_init);
-#ifdef CONFIG_SND_SEQUENCER_MODULE
-	/* initial autoload only when snd-seq is a module */
-	queue_autoload_drivers();
-#endif
-}
-EXPORT_SYMBOL(snd_seq_autoload_init);
-
-void snd_seq_autoload_exit(void)
-{
-	atomic_inc(&snd_seq_in_init);
-}
-EXPORT_SYMBOL(snd_seq_autoload_exit);
-
-void snd_seq_device_load_drivers(void)
-{
-	queue_autoload_drivers();
-	flush_work(&autoload_work);
-}
-EXPORT_SYMBOL(snd_seq_device_load_drivers);
-#else
-#define queue_autoload_drivers() /* NOP */
-#endif
-
-/*
- * device management
- */
-static int snd_seq_device_dev_free(struct snd_device *device)
-{
-	struct snd_seq_device *dev = device->device_data;
-
-	put_device(&dev->dev);
-	return 0;
-}
-
-static int snd_seq_device_dev_register(struct snd_device *device)
-{
-	struct snd_seq_device *dev = device->device_data;
-	int err;
-
-	err = device_add(&dev->dev);
-	if (err < 0)
-		return err;
-	if (!dev->dev.driver)
-		queue_autoload_drivers();
-	return 0;
-}
-
-static int snd_seq_device_dev_disconnect(struct snd_device *device)
-{
-	struct snd_seq_device *dev = device->device_data;
-
-	device_del(&dev->dev);
-	return 0;
-}
-
-static void snd_seq_dev_release(struct device *dev)
-{
-	struct snd_seq_device *sdev = to_seq_dev(dev);
-
-	if (sdev->private_free)
-		sdev->private_free(sdev);
-	kfree(sdev);
-}
-
-/*
- * register a sequencer device
- * card = card info
- * device = device number (if any)
- * id = id of driver
- * result = return pointer (NULL allowed if unnecessary)
- */
-int snd_seq_device_new(struct snd_card *card, int device, const char *id,
-		       int argsize, struct snd_seq_device **result)
-{
-	struct snd_seq_device *dev;
-	int err;
-	static struct snd_device_ops dops = {
-		.dev_free = snd_seq_device_dev_free,
-		.dev_register = snd_seq_device_dev_register,
-		.dev_disconnect = snd_seq_device_dev_disconnect,
-	};
-
-	if (result)
-		*result = NULL;
-
-	if (snd_BUG_ON(!id))
-		return -EINVAL;
-
-	dev = kzalloc(sizeof(*dev) + argsize, GFP_KERNEL);
-	if (!dev)
-		return -ENOMEM;
-
-	/* set up device info */
-	dev->card = card;
-	dev->device = device;
-	dev->id = id;
-	dev->argsize = argsize;
-
-	device_initialize(&dev->dev);
-	dev->dev.parent = &card->card_dev;
-	dev->dev.bus = &snd_seq_bus_type;
-	dev->dev.release = snd_seq_dev_release;
-	dev_set_name(&dev->dev, "%s-%d-%d", dev->id, card->number, device);
-
-	/* add this device to the list */
-	err = snd_device_new(card, SNDRV_DEV_SEQUENCER, dev, &dops);
-	if (err < 0) {
-		put_device(&dev->dev);
-		return err;
-	}
-	
-	if (result)
-		*result = dev;
-
-	return 0;
-}
-EXPORT_SYMBOL(snd_seq_device_new);
-
-/*
- * driver registration
- */
-int __snd_seq_driver_register(struct snd_seq_driver *drv, struct module *mod)
-{
-	if (WARN_ON(!drv->driver.name || !drv->id))
-		return -EINVAL;
-	drv->driver.bus = &snd_seq_bus_type;
-	drv->driver.owner = mod;
-	return driver_register(&drv->driver);
-}
-EXPORT_SYMBOL_GPL(__snd_seq_driver_register);
-
-void snd_seq_driver_unregister(struct snd_seq_driver *drv)
-{
-	driver_unregister(&drv->driver);
-}
-EXPORT_SYMBOL_GPL(snd_seq_driver_unregister);
-
-/*
- * module part
- */
-
-static int __init seq_dev_proc_init(void)
-{
-#ifdef CONFIG_SND_PROC_FS
-	info_entry = snd_info_create_module_entry(THIS_MODULE, "drivers",
-						  snd_seq_root);
-	if (info_entry == NULL)
-		return -ENOMEM;
-	info_entry->content = SNDRV_INFO_CONTENT_TEXT;
-	info_entry->c.text.read = snd_seq_device_info;
-	if (snd_info_register(info_entry) < 0) {
-		snd_info_free_entry(info_entry);
-		return -ENOMEM;
-	}
-#endif
-	return 0;
-}
-
-static int __init alsa_seq_device_init(void)
-{
-	int err;
-
-	err = bus_register(&snd_seq_bus_type);
-	if (err < 0)
-		return err;
-	err = seq_dev_proc_init();
-	if (err < 0)
-		bus_unregister(&snd_seq_bus_type);
-	return err;
-}
-
-static void __exit alsa_seq_device_exit(void)
-{
-#ifdef CONFIG_MODULES
-	cancel_work_sync(&autoload_work);
-#endif
-#ifdef CONFIG_SND_PROC_FS
-	snd_info_free_entry(info_entry);
-#endif
-	bus_unregister(&snd_seq_bus_type);
-}
-
-subsys_initcall(alsa_seq_device_init)
-module_exit(alsa_seq_device_exit)
--- /dev/null
+++ b/sound/core/seq_device.c
@@ -0,0 +1,315 @@
+/*
+ *  ALSA sequencer device management
+ *  Copyright (c) 1999 by Takashi Iwai <tiwai@suse.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *
+ *----------------------------------------------------------------
+ *
+ * This device handler separates the card driver module from sequencer
+ * stuff (sequencer core, synth drivers, etc), so that user can avoid
+ * to spend unnecessary resources e.g. if he needs only listening to
+ * MP3s.
+ *
+ * The card (or lowlevel) driver creates a sequencer device entry
+ * via snd_seq_device_new().  This is an entry pointer to communicate
+ * with the sequencer device "driver", which is involved with the
+ * actual part to communicate with the sequencer core.
+ * Each sequencer device entry has an id string and the corresponding
+ * driver with the same id is loaded when required.  For example,
+ * lowlevel codes to access emu8000 chip on sbawe card are included in
+ * emu8000-synth module.  To activate this module, the hardware
+ * resources like i/o port are passed via snd_seq_device argument.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/seq_device.h>
+#include <sound/seq_kernel.h>
+#include <sound/initval.h>
+#include <linux/kmod.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+
+MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>");
+MODULE_DESCRIPTION("ALSA sequencer device management");
+MODULE_LICENSE("GPL");
+
+/*
+ * bus definition
+ */
+static int snd_seq_bus_match(struct device *dev, struct device_driver *drv)
+{
+	struct snd_seq_device *sdev = to_seq_dev(dev);
+	struct snd_seq_driver *sdrv = to_seq_drv(drv);
+
+	return strcmp(sdrv->id, sdev->id) == 0 &&
+		sdrv->argsize == sdev->argsize;
+}
+
+static struct bus_type snd_seq_bus_type = {
+	.name = "snd_seq",
+	.match = snd_seq_bus_match,
+};
+
+/*
+ * proc interface -- just for compatibility
+ */
+#ifdef CONFIG_SND_PROC_FS
+static struct snd_info_entry *info_entry;
+
+static int print_dev_info(struct device *dev, void *data)
+{
+	struct snd_seq_device *sdev = to_seq_dev(dev);
+	struct snd_info_buffer *buffer = data;
+
+	snd_iprintf(buffer, "snd-%s,%s,%d\n", sdev->id,
+		    dev->driver ? "loaded" : "empty",
+		    dev->driver ? 1 : 0);
+	return 0;
+}
+
+static void snd_seq_device_info(struct snd_info_entry *entry,
+				struct snd_info_buffer *buffer)
+{
+	bus_for_each_dev(&snd_seq_bus_type, NULL, buffer, print_dev_info);
+}
+#endif
+
+/*
+ * load all registered drivers (called from seq_clientmgr.c)
+ */
+
+#ifdef CONFIG_MODULES
+/* flag to block auto-loading */
+static atomic_t snd_seq_in_init = ATOMIC_INIT(1); /* blocked as default */
+
+static int request_seq_drv(struct device *dev, void *data)
+{
+	struct snd_seq_device *sdev = to_seq_dev(dev);
+
+	if (!dev->driver)
+		request_module("snd-%s", sdev->id);
+	return 0;
+}
+
+static void autoload_drivers(struct work_struct *work)
+{
+	/* avoid reentrance */
+	if (atomic_inc_return(&snd_seq_in_init) == 1)
+		bus_for_each_dev(&snd_seq_bus_type, NULL, NULL,
+				 request_seq_drv);
+	atomic_dec(&snd_seq_in_init);
+}
+
+static DECLARE_WORK(autoload_work, autoload_drivers);
+
+static void queue_autoload_drivers(void)
+{
+	schedule_work(&autoload_work);
+}
+
+void snd_seq_autoload_init(void)
+{
+	atomic_dec(&snd_seq_in_init);
+#ifdef CONFIG_SND_SEQUENCER_MODULE
+	/* initial autoload only when snd-seq is a module */
+	queue_autoload_drivers();
+#endif
+}
+EXPORT_SYMBOL(snd_seq_autoload_init);
+
+void snd_seq_autoload_exit(void)
+{
+	atomic_inc(&snd_seq_in_init);
+}
+EXPORT_SYMBOL(snd_seq_autoload_exit);
+
+void snd_seq_device_load_drivers(void)
+{
+	queue_autoload_drivers();
+	flush_work(&autoload_work);
+}
+EXPORT_SYMBOL(snd_seq_device_load_drivers);
+#else
+#define queue_autoload_drivers() /* NOP */
+#endif
+
+/*
+ * device management
+ */
+static int snd_seq_device_dev_free(struct snd_device *device)
+{
+	struct snd_seq_device *dev = device->device_data;
+
+	put_device(&dev->dev);
+	return 0;
+}
+
+static int snd_seq_device_dev_register(struct snd_device *device)
+{
+	struct snd_seq_device *dev = device->device_data;
+	int err;
+
+	err = device_add(&dev->dev);
+	if (err < 0)
+		return err;
+	if (!dev->dev.driver)
+		queue_autoload_drivers();
+	return 0;
+}
+
+static int snd_seq_device_dev_disconnect(struct snd_device *device)
+{
+	struct snd_seq_device *dev = device->device_data;
+
+	device_del(&dev->dev);
+	return 0;
+}
+
+static void snd_seq_dev_release(struct device *dev)
+{
+	struct snd_seq_device *sdev = to_seq_dev(dev);
+
+	if (sdev->private_free)
+		sdev->private_free(sdev);
+	kfree(sdev);
+}
+
+/*
+ * register a sequencer device
+ * card = card info
+ * device = device number (if any)
+ * id = id of driver
+ * result = return pointer (NULL allowed if unnecessary)
+ */
+int snd_seq_device_new(struct snd_card *card, int device, const char *id,
+		       int argsize, struct snd_seq_device **result)
+{
+	struct snd_seq_device *dev;
+	int err;
+	static struct snd_device_ops dops = {
+		.dev_free = snd_seq_device_dev_free,
+		.dev_register = snd_seq_device_dev_register,
+		.dev_disconnect = snd_seq_device_dev_disconnect,
+	};
+
+	if (result)
+		*result = NULL;
+
+	if (snd_BUG_ON(!id))
+		return -EINVAL;
+
+	dev = kzalloc(sizeof(*dev) + argsize, GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	/* set up device info */
+	dev->card = card;
+	dev->device = device;
+	dev->id = id;
+	dev->argsize = argsize;
+
+	device_initialize(&dev->dev);
+	dev->dev.parent = &card->card_dev;
+	dev->dev.bus = &snd_seq_bus_type;
+	dev->dev.release = snd_seq_dev_release;
+	dev_set_name(&dev->dev, "%s-%d-%d", dev->id, card->number, device);
+
+	/* add this device to the list */
+	err = snd_device_new(card, SNDRV_DEV_SEQUENCER, dev, &dops);
+	if (err < 0) {
+		put_device(&dev->dev);
+		return err;
+	}
+	
+	if (result)
+		*result = dev;
+
+	return 0;
+}
+EXPORT_SYMBOL(snd_seq_device_new);
+
+/*
+ * driver registration
+ */
+int __snd_seq_driver_register(struct snd_seq_driver *drv, struct module *mod)
+{
+	if (WARN_ON(!drv->driver.name || !drv->id))
+		return -EINVAL;
+	drv->driver.bus = &snd_seq_bus_type;
+	drv->driver.owner = mod;
+	return driver_register(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(__snd_seq_driver_register);
+
+void snd_seq_driver_unregister(struct snd_seq_driver *drv)
+{
+	driver_unregister(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(snd_seq_driver_unregister);
+
+/*
+ * module part
+ */
+
+static int __init seq_dev_proc_init(void)
+{
+#ifdef CONFIG_SND_PROC_FS
+	info_entry = snd_info_create_module_entry(THIS_MODULE, "drivers",
+						  snd_seq_root);
+	if (info_entry == NULL)
+		return -ENOMEM;
+	info_entry->content = SNDRV_INFO_CONTENT_TEXT;
+	info_entry->c.text.read = snd_seq_device_info;
+	if (snd_info_register(info_entry) < 0) {
+		snd_info_free_entry(info_entry);
+		return -ENOMEM;
+	}
+#endif
+	return 0;
+}
+
+static int __init alsa_seq_device_init(void)
+{
+	int err;
+
+	err = bus_register(&snd_seq_bus_type);
+	if (err < 0)
+		return err;
+	err = seq_dev_proc_init();
+	if (err < 0)
+		bus_unregister(&snd_seq_bus_type);
+	return err;
+}
+
+static void __exit alsa_seq_device_exit(void)
+{
+#ifdef CONFIG_MODULES
+	cancel_work_sync(&autoload_work);
+#endif
+#ifdef CONFIG_SND_PROC_FS
+	snd_info_free_entry(info_entry);
+#endif
+	bus_unregister(&snd_seq_bus_type);
+}
+
+subsys_initcall(alsa_seq_device_init)
+module_exit(alsa_seq_device_exit)
