From 868b8d33f91e431b1961a35baa6b5022639067f3 Mon Sep 17 00:00:00 2001
From: Mario Limonciello <mario.limonciello@dell.com>
Date: Thu, 9 Nov 2017 11:49:10 -0600
Subject: [PATCH] platform/x86: dell-*wmi*: Relay failed initial probe to dependent drivers
Mime-version: 1.0
Content-type: text/plain; charset=UTF-8
Content-transfer-encoding: 8bit
Git-commit: 868b8d33f91e431b1961a35baa6b5022639067f3
Patch-mainline: v4.15-rc1
References: FATE#325842

dell-wmi and dell-smbios-wmi are dependent upon dell-wmi-descriptor
finishing probe successfully to probe themselves.

Currently if dell-wmi-descriptor fails probing in a non-recoverable way
(such as invalid header) dell-wmi and dell-smbios-wmi will continue to
try to redo probing due to deferred probing.

To solve this have the dependent drivers query the dell-wmi-descriptor
driver whether the descriptor has been determined valid. The possible
results are:
-enodev: Descriptor GUID missing from WMI bus
-eprobe_defer: Descriptor not yet probed, dependent driver should wait and use deferred probing
< 0: Descriptor probed, invalid.  Dependent driver should return an
 error.
0: Successful descriptor probe, dependent driver can continue

Successful descriptor probe still doesn't mean that the descriptor driver
is necessarily bound at the time of initialization of dependent driver.
Userspace can unbind the driver, so all methods used from driver
should still be verified to return success values otherwise deferred
probing be used.

Signed-off-by: Mario Limonciello <mario.limonciello@dell.com>
Reviewed-by: Pali Roh√°r <pali.rohar@gmail.com>
Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/platform/x86/dell-smbios-wmi.c     |    5 +++--
 drivers/platform/x86/dell-wmi-descriptor.c |   16 ++++++++++++++++
 drivers/platform/x86/dell-wmi-descriptor.h |    8 +++++++-
 drivers/platform/x86/dell-wmi.c            |    6 ++++--
 4 files changed, 30 insertions(+), 5 deletions(-)

--- a/drivers/platform/x86/dell-smbios-wmi.c
+++ b/drivers/platform/x86/dell-smbios-wmi.c
@@ -151,8 +151,9 @@ static int dell_smbios_wmi_probe(struct
 	int count;
 	int ret;
 
-	if (!wmi_has_guid(DELL_WMI_DESCRIPTOR_GUID))
-		return -ENODEV;
+	ret = dell_wmi_get_descriptor_valid();
+	if (ret)
+		return ret;
 
 	priv = devm_kzalloc(&wdev->dev, sizeof(struct wmi_smbios_priv),
 			    GFP_KERNEL);
--- a/drivers/platform/x86/dell-wmi-descriptor.c
+++ b/drivers/platform/x86/dell-wmi-descriptor.c
@@ -21,14 +21,26 @@
 #include <linux/wmi.h>
 #include "dell-wmi-descriptor.h"
 
+#define DELL_WMI_DESCRIPTOR_GUID "8D9DDCBC-A997-11DA-B012-B622A1EF5492"
+
 struct descriptor_priv {
 	struct list_head list;
 	u32 interface_version;
 	u32 size;
 };
+static int descriptor_valid = -EPROBE_DEFER;
 static LIST_HEAD(wmi_list);
 static DEFINE_MUTEX(list_mutex);
 
+int dell_wmi_get_descriptor_valid(void)
+{
+	if (!wmi_has_guid(DELL_WMI_DESCRIPTOR_GUID))
+		return -ENODEV;
+
+	return descriptor_valid;
+}
+EXPORT_SYMBOL_GPL(dell_wmi_get_descriptor_valid);
+
 bool dell_wmi_get_interface_version(u32 *version)
 {
 	struct descriptor_priv *priv;
@@ -91,6 +103,7 @@ static int dell_wmi_descriptor_probe(str
 	if (obj->type != ACPI_TYPE_BUFFER) {
 		dev_err(&wdev->dev, "Dell descriptor has wrong type\n");
 		ret = -EINVAL;
+		descriptor_valid = ret;
 		goto out;
 	}
 
@@ -102,6 +115,7 @@ static int dell_wmi_descriptor_probe(str
 			"Dell descriptor buffer has unexpected length (%d)\n",
 			obj->buffer.length);
 		ret = -EINVAL;
+		descriptor_valid = ret;
 		goto out;
 	}
 
@@ -111,8 +125,10 @@ static int dell_wmi_descriptor_probe(str
 		dev_err(&wdev->dev, "Dell descriptor buffer has invalid signature (%8ph)\n",
 			buffer);
 		ret = -EINVAL;
+		descriptor_valid = ret;
 		goto out;
 	}
+	descriptor_valid = 0;
 
 	if (buffer[2] != 0 && buffer[2] != 1)
 		dev_warn(&wdev->dev, "Dell descriptor buffer has unknown version (%lu)\n",
--- a/drivers/platform/x86/dell-wmi-descriptor.h
+++ b/drivers/platform/x86/dell-wmi-descriptor.h
@@ -13,7 +13,13 @@
 
 #include <linux/wmi.h>
 
-#define DELL_WMI_DESCRIPTOR_GUID "8D9DDCBC-A997-11DA-B012-B622A1EF5492"
+/* possible return values:
+ *  -ENODEV: Descriptor GUID missing from WMI bus
+ *  -EPROBE_DEFER: probing for dell-wmi-descriptor not yet run
+ *  0: valid descriptor, successfully probed
+ *  < 0: invalid descriptor, don't probe dependent devices
+ */
+int dell_wmi_get_descriptor_valid(void);
 
 bool dell_wmi_get_interface_version(u32 *version);
 bool dell_wmi_get_size(u32 *size);
--- a/drivers/platform/x86/dell-wmi.c
+++ b/drivers/platform/x86/dell-wmi.c
@@ -655,9 +655,11 @@ static int dell_wmi_events_set_enabled(b
 static int dell_wmi_probe(struct wmi_device *wdev)
 {
 	struct dell_wmi_priv *priv;
+	int ret;
 
-	if (!wmi_has_guid(DELL_WMI_DESCRIPTOR_GUID))
-		return -ENODEV;
+	ret = dell_wmi_get_descriptor_valid();
+	if (ret)
+		return ret;
 
 	priv = devm_kzalloc(
 		&wdev->dev, sizeof(struct dell_wmi_priv), GFP_KERNEL);
