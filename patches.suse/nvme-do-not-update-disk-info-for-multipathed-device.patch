From ac55ebb15df8fab1b30b8bfda2c0f463a162db08 Mon Sep 17 00:00:00 2001
From: Hannes Reinecke <hare@suse.de>
Date: Tue, 15 Sep 2020 11:49:00 +0200
Subject: nvme: do not update disk info for multipathed device
References: bsc#1171558
Patch-mainline: Never, handled differently upstream (> ~v5.8, < SLE15-SP3)

For a multipathed disk it's actually wrong to update the device
parameter when a path comes back; there is a good chance that the
multipath device will have other paths, and updating the device
characteristics has the potential of corrupting/invalidating the
other paths.
A real fix would be to compare the parameters, and reject this path
if they differ. In the absence of such a check just don't update
the disk characteristics for the multipath device.

Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/nvme/host/core.c |    9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -1769,7 +1769,8 @@ static void nvme_update_disk_info(struct
 	blk_mq_unfreeze_queue(disk->queue);
 }
 
-static void __nvme_revalidate_disk(struct gendisk *disk, struct nvme_id_ns *id)
+static void __nvme_revalidate_disk(struct gendisk *disk, struct nvme_id_ns *id,
+				   bool first_scan)
 {
 	struct nvme_ns *ns = disk->private_data;
 	u32 iob;
@@ -1800,7 +1801,7 @@ static void __nvme_revalidate_disk(struc
 		blk_queue_chunk_sectors(ns->queue, rounddown_pow_of_two(iob));
 	nvme_update_disk_info(disk, ns, id);
 #ifdef CONFIG_NVME_MULTIPATH
-	if (ns->head->disk) {
+	if (ns->head->disk && first_scan) {
 		nvme_update_disk_info(ns->head->disk, ns, id);
 		blk_queue_stack_limits(ns->head->disk->queue, ns->queue);
 		revalidate_disk(ns->head->disk);
@@ -1841,7 +1842,7 @@ static int nvme_revalidate_disk(struct g
 		goto free_id;
 	}
 
-	__nvme_revalidate_disk(disk, id);
+	__nvme_revalidate_disk(disk, id, false);
 free_id:
 	kfree(id);
 out:
@@ -3494,7 +3495,7 @@ static void nvme_alloc_ns(struct nvme_ct
 	memcpy(disk->disk_name, disk_name, DISK_NAME_LEN);
 	ns->disk = disk;
 
-	__nvme_revalidate_disk(disk, id);
+	__nvme_revalidate_disk(disk, id, true);
 
 	if ((ctrl->quirks & NVME_QUIRK_LIGHTNVM) && id->vs[0] == 0x1) {
 		ret = nvme_nvm_register(ns, disk_name, node);
