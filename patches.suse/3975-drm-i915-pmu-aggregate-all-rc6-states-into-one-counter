From: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date: Fri, 24 Nov 2017 17:13:31 +0000
Subject: drm/i915/pmu: Aggregate all RC6 states into one counter
Git-commit: 3452fa3095e91acbcb1f6290e0d70fa7d3695a3a
Patch-mainline: v4.16-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Chris has discovered that RC6, RC6p and RC6pp counters are mutually
exclusive, and even that on some SNB SKUs you get RC6p increasing, and on
the others RC6.

Furthermore RC6p and RC6pp were only present starting from GEN6 until,
GEN7, not including Haswell.

All this combined makes it questionable whether we need to reserve new ABI
for these counters. One idea was to just combine them all under the RC6
counter to simplify things for userspace. So that is what this patch does.

Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Link: https://patchwork.freedesktop.org/patch/msgid/20171124171331.17981-1-tvrtko.ursulin@linux.intel.com

Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/i915/i915_pmu.c |   23 ++++++-----------------
 include/uapi/drm/i915_drm.h     |    6 +-----
 2 files changed, 7 insertions(+), 22 deletions(-)

--- a/drivers/gpu/drm/i915/i915_pmu.c
+++ b/drivers/gpu/drm/i915/i915_pmu.c
@@ -359,11 +359,6 @@ static int i915_pmu_event_init(struct pe
 			if (!HAS_RC6(i915))
 				ret = -ENODEV;
 			break;
-		case I915_PMU_RC6p_RESIDENCY:
-		case I915_PMU_RC6pp_RESIDENCY:
-			if (!HAS_RC6p(i915))
-				ret = -ENODEV;
-			break;
 		default:
 			ret = -ENOENT;
 			break;
@@ -421,16 +416,12 @@ static u64 __i915_pmu_event_read(struct
 						     IS_VALLEYVIEW(i915) ?
 						     VLV_GT_RENDER_RC6 :
 						     GEN6_GT_GFX_RC6);
-			intel_runtime_pm_put(i915);
-			break;
-		case I915_PMU_RC6p_RESIDENCY:
-			intel_runtime_pm_get(i915);
-			val = intel_rc6_residency_ns(i915, GEN6_GT_GFX_RC6p);
-			intel_runtime_pm_put(i915);
-			break;
-		case I915_PMU_RC6pp_RESIDENCY:
-			intel_runtime_pm_get(i915);
-			val = intel_rc6_residency_ns(i915, GEN6_GT_GFX_RC6pp);
+			if (HAS_RC6p(i915)) {
+				val += intel_rc6_residency_ns(i915,
+							      GEN6_GT_GFX_RC6p);
+				val += intel_rc6_residency_ns(i915,
+							      GEN6_GT_GFX_RC6pp);
+			}
 			intel_runtime_pm_put(i915);
 			break;
 		}
@@ -708,8 +699,6 @@ static struct attribute *i915_pmu_events
 	I915_EVENT_ATTR(interrupts, I915_PMU_INTERRUPTS),
 
 	I915_EVENT(rc6-residency,   I915_PMU_RC6_RESIDENCY,   "ns"),
-	I915_EVENT(rc6p-residency,  I915_PMU_RC6p_RESIDENCY,  "ns"),
-	I915_EVENT(rc6pp-residency, I915_PMU_RC6pp_RESIDENCY, "ns"),
 
 	NULL,
 };
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -137,14 +137,10 @@ enum drm_i915_pmu_engine_sample {
 
 #define I915_PMU_ACTUAL_FREQUENCY	__I915_PMU_OTHER(0)
 #define I915_PMU_REQUESTED_FREQUENCY	__I915_PMU_OTHER(1)
-
 #define I915_PMU_INTERRUPTS		__I915_PMU_OTHER(2)
-
 #define I915_PMU_RC6_RESIDENCY		__I915_PMU_OTHER(3)
-#define I915_PMU_RC6p_RESIDENCY		__I915_PMU_OTHER(4)
-#define I915_PMU_RC6pp_RESIDENCY	__I915_PMU_OTHER(5)
 
-#define I915_PMU_LAST I915_PMU_RC6pp_RESIDENCY
+#define I915_PMU_LAST I915_PMU_RC6_RESIDENCY
 
 /* Each region is a minimum of 16k, and there are at most 255 of them.
  */
