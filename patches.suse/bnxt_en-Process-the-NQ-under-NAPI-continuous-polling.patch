From: Michael Chan <michael.chan@broadcom.com>
Date: Sun, 8 Mar 2020 18:45:49 -0400
Subject: bnxt_en: Process the NQ under NAPI continuous polling.
Patch-mainline: v5.7-rc1
Git-commit: 389a877a3b20c1bc058143dfc4d95fd754fb0240
References: jsc#SLE-15075

When we are in continuous NAPI polling mode, the current code in
bnxt_poll_p5() will only process the completion rings and will not
process the NQ until interrupt is re-enabled.  Tis logic works and
will not cause RX or TX starvation, but async events in the NQ may
be delayed for the duration of continuous NAPI polling.  These
async events may be firmware or VF events.

Continue to handle the NQ after we are done polling the completion
rings.  This actually simplies the code in bnxt_poll_p5().

Acknowledge the NQ so these async events will not overflow.

Signed-off-by: Michael Chan <michael.chan@broadcom.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/broadcom/bnxt/bnxt.c |   13 ++++---------
 1 file changed, 4 insertions(+), 9 deletions(-)

--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -2428,14 +2428,6 @@ static int bnxt_poll_p5(struct napi_stru
 	if (cpr->has_more_work) {
 		cpr->has_more_work = 0;
 		work_done = __bnxt_poll_cqs(bp, bnapi, budget);
-		if (cpr->has_more_work) {
-			__bnxt_poll_cqs_done(bp, bnapi, DBR_TYPE_CQ);
-			return work_done;
-		}
-		__bnxt_poll_cqs_done(bp, bnapi, DBR_TYPE_CQ_ARMALL);
-		if (napi_complete_done(napi, work_done))
-			BNXT_DB_NQ_ARM_P5(&cpr->cp_db, cpr->cp_raw_cons);
-		return work_done;
 	}
 	while (1) {
 		cons = RING_CMP(raw_cons);
@@ -2472,7 +2464,10 @@ static int bnxt_poll_p5(struct napi_stru
 		raw_cons = NEXT_RAW_CMP(raw_cons);
 	}
 	__bnxt_poll_cqs_done(bp, bnapi, DBR_TYPE_CQ);
-	cpr->cp_raw_cons = raw_cons;
+	if (raw_cons != cpr->cp_raw_cons) {
+		cpr->cp_raw_cons = raw_cons;
+		BNXT_DB_NQ_P5(&cpr->cp_db, raw_cons);
+	}
 	return work_done;
 }
 
