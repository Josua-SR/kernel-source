From cf0b3aeb6185f68ebd324302be01bee3f13ab9bc Mon Sep 17 00:00:00 2001
From: Evan Quan <evan.quan@amd.com>
Date: Tue, 7 Jul 2020 14:49:45 +0800
Subject: drm/amd/powerplay: move more APIs to smu_cmn.c
Git-commit: a7bae0619903196417a9daf2409412217ddaf463
Patch-mainline: v5.9-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

Considering they are shared by all ASICs.

Signed-off-by: Evan Quan <evan.quan@amd.com>
Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/gpu/drm/amd/powerplay/amdgpu_smu.c         |   65 --------------------
 drivers/gpu/drm/amd/powerplay/arcturus_ppt.c       |   14 ++--
 drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h     |    2 
 drivers/gpu/drm/amd/powerplay/navi10_ppt.c         |    2 
 drivers/gpu/drm/amd/powerplay/renoir_ppt.c         |    2 
 drivers/gpu/drm/amd/powerplay/sienna_cichlid_ppt.c |    2 
 drivers/gpu/drm/amd/powerplay/smu_cmn.c            |   66 +++++++++++++++++++++
 drivers/gpu/drm/amd/powerplay/smu_cmn.h            |    7 ++
 drivers/gpu/drm/amd/powerplay/smu_v11_0.c          |   10 +--
 drivers/gpu/drm/amd/powerplay/smu_v12_0.c          |    4 -
 10 files changed, 90 insertions(+), 84 deletions(-)

--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -91,43 +91,6 @@ int smu_sys_set_pp_feature_mask(struct s
 	return ret;
 }
 
-int smu_get_smc_version(struct smu_context *smu, uint32_t *if_version, uint32_t *smu_version)
-{
-	int ret = 0;
-
-	if (!if_version && !smu_version)
-		return -EINVAL;
-
-	if (smu->smc_fw_if_version && smu->smc_fw_version)
-	{
-		if (if_version)
-			*if_version = smu->smc_fw_if_version;
-
-		if (smu_version)
-			*smu_version = smu->smc_fw_version;
-
-		return 0;
-	}
-
-	if (if_version) {
-		ret = smu_send_smc_msg(smu, SMU_MSG_GetDriverIfVersion, if_version);
-		if (ret)
-			return ret;
-
-		smu->smc_fw_if_version = *if_version;
-	}
-
-	if (smu_version) {
-		ret = smu_send_smc_msg(smu, SMU_MSG_GetSmuVersion, smu_version);
-		if (ret)
-			return ret;
-
-		smu->smc_fw_version = *smu_version;
-	}
-
-	return ret;
-}
-
 int smu_get_status_gfxoff(struct amdgpu_device *adev, uint32_t *value)
 {
 	int ret = 0;
@@ -184,34 +147,6 @@ int smu_get_dpm_freq_range(struct smu_co
 	return ret;
 }
 
-bool smu_clk_dpm_is_enabled(struct smu_context *smu, enum smu_clk_type clk_type)
-{
-	enum smu_feature_mask feature_id = 0;
-
-	switch (clk_type) {
-	case SMU_MCLK:
-	case SMU_UCLK:
-		feature_id = SMU_FEATURE_DPM_UCLK_BIT;
-		break;
-	case SMU_GFXCLK:
-	case SMU_SCLK:
-		feature_id = SMU_FEATURE_DPM_GFXCLK_BIT;
-		break;
-	case SMU_SOCCLK:
-		feature_id = SMU_FEATURE_DPM_SOCCLK_BIT;
-		break;
-	default:
-		return true;
-	}
-
-	if(!smu_feature_is_enabled(smu, feature_id)) {
-		pr_warn("smu %d clk dpm feature %d is not enabled\n", clk_type, feature_id);
-		return false;
-	}
-
-	return true;
-}
-
 /**
  * smu_dpm_set_power_gate - power gate/ungate the specific IP block
  *
--- a/drivers/gpu/drm/amd/powerplay/arcturus_ppt.c
+++ b/drivers/gpu/drm/amd/powerplay/arcturus_ppt.c
@@ -874,7 +874,7 @@ static int arcturus_force_clk_levels(str
 	uint32_t smu_version;
 	int ret = 0;
 
-	ret = smu_get_smc_version(smu, NULL, &smu_version);
+	ret = smu_cmn_get_smc_version(smu, NULL, &smu_version);
 	if (ret) {
 		dev_err(smu->adev->dev, "Failed to get smu version!\n");
 		return ret;
@@ -1191,7 +1191,7 @@ static int arcturus_get_power_profile_mo
 	if (!buf)
 		return -EINVAL;
 
-	result = smu_get_smc_version(smu, NULL, &smu_version);
+	result = smu_cmn_get_smc_version(smu, NULL, &smu_version);
 	if (result)
 		return result;
 
@@ -1278,7 +1278,7 @@ static int arcturus_set_power_profile_mo
 		return -EINVAL;
 	}
 
-	ret = smu_get_smc_version(smu, NULL, &smu_version);
+	ret = smu_cmn_get_smc_version(smu, NULL, &smu_version);
 	if (ret)
 		return ret;
 
@@ -1362,7 +1362,7 @@ static int arcturus_set_performance_leve
 	uint32_t smu_version;
 	int ret;
 
-	ret = smu_get_smc_version(smu, NULL, &smu_version);
+	ret = smu_cmn_get_smc_version(smu, NULL, &smu_version);
 	if (ret) {
 		dev_err(smu->adev->dev, "Failed to get smu version!\n");
 		return ret;
@@ -2106,7 +2106,7 @@ static void arcturus_get_unique_id(struc
 	uint32_t top32 = 0, bottom32 = 0, smu_version;
 	uint64_t id;
 
-	if (smu_get_smc_version(smu, NULL, &smu_version)) {
+	if (smu_cmn_get_smc_version(smu, NULL, &smu_version)) {
 		dev_warn(adev->dev, "Failed to get smu version, cannot get unique_id or serial_number\n");
 		return;
 	}
@@ -2147,7 +2147,7 @@ static int arcturus_set_df_cstate(struct
 	uint32_t smu_version;
 	int ret;
 
-	ret = smu_get_smc_version(smu, NULL, &smu_version);
+	ret = smu_cmn_get_smc_version(smu, NULL, &smu_version);
 	if (ret) {
 		dev_err(smu->adev->dev, "Failed to get smu version!\n");
 		return ret;
@@ -2167,7 +2167,7 @@ static int arcturus_allow_xgmi_power_dow
 	uint32_t smu_version;
 	int ret;
 
-	ret = smu_get_smc_version(smu, NULL, &smu_version);
+	ret = smu_cmn_get_smc_version(smu, NULL, &smu_version);
 	if (ret) {
 		dev_err(smu->adev->dev, "Failed to get smu version!\n");
 		return ret;
--- a/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h
@@ -760,7 +760,6 @@ extern int smu_handle_task(struct smu_co
 int smu_switch_power_profile(struct smu_context *smu,
 			     enum PP_SMC_POWER_PROFILE type,
 			     bool en);
-int smu_get_smc_version(struct smu_context *smu, uint32_t *if_version, uint32_t *smu_version);
 int smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 			   uint32_t *min, uint32_t *max);
 int smu_set_soft_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
@@ -769,7 +768,6 @@ enum amd_dpm_forced_level smu_get_perfor
 int smu_force_performance_level(struct smu_context *smu, enum amd_dpm_forced_level level);
 int smu_set_display_count(struct smu_context *smu, uint32_t count);
 int smu_set_ac_dc(struct smu_context *smu);
-bool smu_clk_dpm_is_enabled(struct smu_context *smu, enum smu_clk_type clk_type);
 const char *smu_get_message_name(struct smu_context *smu, enum smu_message_type type);
 size_t smu_sys_get_pp_feature_mask(struct smu_context *smu, char *buf);
 int smu_sys_set_pp_feature_mask(struct smu_context *smu, uint64_t new_mask);
--- a/drivers/gpu/drm/amd/powerplay/navi10_ppt.c
+++ b/drivers/gpu/drm/amd/powerplay/navi10_ppt.c
@@ -2216,7 +2216,7 @@ static int navi10_disable_umc_cdr_12gbps
 	if (!navi10_need_umc_cdr_12gbps_workaround(smu->adev))
 		return 0;
 
-	ret = smu_get_smc_version(smu, NULL, &smu_version);
+	ret = smu_cmn_get_smc_version(smu, NULL, &smu_version);
 	if (ret)
 		return ret;
 
--- a/drivers/gpu/drm/amd/powerplay/renoir_ppt.c
+++ b/drivers/gpu/drm/amd/powerplay/renoir_ppt.c
@@ -255,7 +255,7 @@ static int renoir_get_dpm_ultimate_freq(
 	uint32_t mclk_mask, soc_mask;
 	uint32_t clock_limit;
 
-	if (!smu_clk_dpm_is_enabled(smu, clk_type)) {
+	if (!smu_cmn_clk_dpm_is_enabled(smu, clk_type)) {
 		switch (clk_type) {
 		case SMU_MCLK:
 		case SMU_UCLK:
--- a/drivers/gpu/drm/amd/powerplay/sienna_cichlid_ppt.c
+++ b/drivers/gpu/drm/amd/powerplay/sienna_cichlid_ppt.c
@@ -1732,7 +1732,7 @@ static bool sienna_cichlid_is_mode1_rese
 	 * SRIOV env will not support SMU mode1 reset
 	 * PM FW support mode1 reset from 58.26
 	 */
-	smu_get_smc_version(smu, NULL, &smu_version);
+	smu_cmn_get_smc_version(smu, NULL, &smu_version);
 	if (amdgpu_sriov_vf(adev) || (smu_version < 0x003a1a00))
 		return false;
 
--- a/drivers/gpu/drm/amd/powerplay/smu_cmn.c
+++ b/drivers/gpu/drm/amd/powerplay/smu_cmn.c
@@ -164,6 +164,33 @@ int smu_cmn_feature_is_enabled(struct sm
 	return ret;
 }
 
+bool smu_cmn_clk_dpm_is_enabled(struct smu_context *smu,
+				enum smu_clk_type clk_type)
+{
+	enum smu_feature_mask feature_id = 0;
+
+	switch (clk_type) {
+	case SMU_MCLK:
+	case SMU_UCLK:
+		feature_id = SMU_FEATURE_DPM_UCLK_BIT;
+		break;
+	case SMU_GFXCLK:
+	case SMU_SCLK:
+		feature_id = SMU_FEATURE_DPM_GFXCLK_BIT;
+		break;
+	case SMU_SOCCLK:
+		feature_id = SMU_FEATURE_DPM_SOCCLK_BIT;
+		break;
+	default:
+		return true;
+	}
+
+	if (!smu_cmn_feature_is_enabled(smu, feature_id))
+		return false;
+
+	return true;
+}
+
 int smu_cmn_get_enabled_mask(struct smu_context *smu,
 			     uint32_t *feature_mask,
 			     uint32_t num)
@@ -374,3 +401,42 @@ int smu_cmn_disable_all_features_with_ex
 						   features_to_disable,
 						   0);
 }
+
+int smu_cmn_get_smc_version(struct smu_context *smu,
+			    uint32_t *if_version,
+			    uint32_t *smu_version)
+{
+	int ret = 0;
+
+	if (!if_version && !smu_version)
+		return -EINVAL;
+
+	if (smu->smc_fw_if_version && smu->smc_fw_version)
+	{
+		if (if_version)
+			*if_version = smu->smc_fw_if_version;
+
+		if (smu_version)
+			*smu_version = smu->smc_fw_version;
+
+		return 0;
+	}
+
+	if (if_version) {
+		ret = smu_send_smc_msg(smu, SMU_MSG_GetDriverIfVersion, if_version);
+		if (ret)
+			return ret;
+
+		smu->smc_fw_if_version = *if_version;
+	}
+
+	if (smu_version) {
+		ret = smu_send_smc_msg(smu, SMU_MSG_GetSmuVersion, smu_version);
+		if (ret)
+			return ret;
+
+		smu->smc_fw_version = *smu_version;
+	}
+
+	return ret;
+}
--- a/drivers/gpu/drm/amd/powerplay/smu_cmn.h
+++ b/drivers/gpu/drm/amd/powerplay/smu_cmn.h
@@ -35,6 +35,9 @@ int smu_cmn_feature_is_supported(struct
 int smu_cmn_feature_is_enabled(struct smu_context *smu,
 			       enum smu_feature_mask mask);
 
+bool smu_cmn_clk_dpm_is_enabled(struct smu_context *smu,
+				enum smu_clk_type clk_type);
+
 int smu_cmn_get_enabled_mask(struct smu_context *smu,
 			     uint32_t *feature_mask,
 			     uint32_t num);
@@ -52,4 +55,8 @@ int smu_cmn_set_pp_feature_mask(struct s
 int smu_cmn_disable_all_features_with_exception(struct smu_context *smu,
 						enum smu_feature_mask mask);
 
+int smu_cmn_get_smc_version(struct smu_context *smu,
+			    uint32_t *if_version,
+			    uint32_t *smu_version);
+
 #endif
--- a/drivers/gpu/drm/amd/powerplay/smu_v11_0.c
+++ b/drivers/gpu/drm/amd/powerplay/smu_v11_0.c
@@ -289,7 +289,7 @@ int smu_v11_0_check_fw_version(struct sm
 	uint8_t smu_minor, smu_debug;
 	int ret = 0;
 
-	ret = smu_get_smc_version(smu, &if_version, &smu_version);
+	ret = smu_cmn_get_smc_version(smu, &if_version, &smu_version);
 	if (ret)
 		return ret;
 
@@ -1679,7 +1679,7 @@ int smu_v11_0_get_dpm_ultimate_freq(stru
 	uint32_t param = 0;
 	uint32_t clock_limit;
 
-	if (!smu_clk_dpm_is_enabled(smu, clk_type)) {
+	if (!smu_cmn_clk_dpm_is_enabled(smu, clk_type)) {
 		switch (clk_type) {
 		case SMU_MCLK:
 		case SMU_UCLK:
@@ -1740,7 +1740,7 @@ int smu_v11_0_set_soft_freq_limited_rang
 	int ret = 0, clk_id = 0;
 	uint32_t param;
 
-	if (!smu_clk_dpm_is_enabled(smu, clk_type))
+	if (!smu_cmn_clk_dpm_is_enabled(smu, clk_type))
 		return 0;
 
 	clk_id = smu_cmn_to_asic_specific_index(smu,
@@ -1786,7 +1786,7 @@ int smu_v11_0_set_hard_freq_limited_rang
 	if (min <= 0 && max <= 0)
 		return -EINVAL;
 
-	if (!smu_clk_dpm_is_enabled(smu, clk_type))
+	if (!smu_cmn_clk_dpm_is_enabled(smu, clk_type))
 		return 0;
 
 	clk_id = smu_cmn_to_asic_specific_index(smu,
@@ -1943,7 +1943,7 @@ int smu_v11_0_get_dpm_freq_by_index(stru
 	if (!value)
 		return -EINVAL;
 
-	if (!smu_clk_dpm_is_enabled(smu, clk_type))
+	if (!smu_cmn_clk_dpm_is_enabled(smu, clk_type))
 		return 0;
 
 	clk_id = smu_cmn_to_asic_specific_index(smu,
--- a/drivers/gpu/drm/amd/powerplay/smu_v12_0.c
+++ b/drivers/gpu/drm/amd/powerplay/smu_v12_0.c
@@ -157,7 +157,7 @@ int smu_v12_0_check_fw_version(struct sm
 	uint8_t smu_minor, smu_debug;
 	int ret = 0;
 
-	ret = smu_get_smc_version(smu, &if_version, &smu_version);
+	ret = smu_cmn_get_smc_version(smu, &if_version, &smu_version);
 	if (ret)
 		return ret;
 
@@ -305,7 +305,7 @@ int smu_v12_0_set_soft_freq_limited_rang
 {
 	int ret = 0;
 
-	if (!smu_clk_dpm_is_enabled(smu, clk_type))
+	if (!smu_cmn_clk_dpm_is_enabled(smu, clk_type))
 		return 0;
 
 	switch (clk_type) {
