From: Deepak Rawat <drawat@vmware.com>
Date: Tue, 16 Jan 2018 08:25:55 +0100
Subject: drm/vmwgfx: Move surface copy cmd to atomic function
Git-commit: 4e2f9fa7ffb5324adfc62fa3da6e1e36827fd5ad
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

When display surface is different than the framebuffer surface, atomic
path do not copy the surface data. This commit moved the code to copy
surface from legacy to atomic path.

Signed-off-by: Deepak Rawat <drawat@vmware.com>
Reviewed-by: Sinclair Yeh <syeh@vmware.com>
Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c |   47 ++++++++++++++++-------------------
 1 file changed, 22 insertions(+), 25 deletions(-)

--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -492,8 +492,6 @@ static int vmw_stdu_crtc_page_flip(struc
 {
 	struct vmw_private *dev_priv = vmw_priv(crtc->dev);
 	struct vmw_screen_target_display_unit *stdu = vmw_crtc_to_stdu(crtc);
-	struct vmw_framebuffer *vfb = vmw_framebuffer_to_vfb(new_fb);
-	struct drm_vmw_rect vclips;
 	int ret;
 
 	dev_priv          = vmw_priv(crtc->dev);
@@ -519,26 +517,6 @@ static int vmw_stdu_crtc_page_flip(struc
 	if (stdu->base.is_implicit)
 		vmw_kms_update_implicit_fb(dev_priv, crtc);
 
-	/*
-	 * Now that we've bound a new surface to the screen target,
-	 * update the contents.
-	 */
-	vclips.x = crtc->x;
-	vclips.y = crtc->y;
-	vclips.w = crtc->mode.hdisplay;
-	vclips.h = crtc->mode.vdisplay;
-
-	if (vfb->dmabuf)
-		ret = vmw_kms_stdu_dma(dev_priv, NULL, vfb, NULL, NULL, &vclips,
-				       1, 1, true, false, crtc);
-	else
-		ret = vmw_kms_stdu_surface_dirty(dev_priv, vfb, NULL, &vclips,
-						 NULL, 0, 0, 1, 1, NULL, crtc);
-	if (ret) {
-		DRM_ERROR("Page flip update error %d.\n", ret);
-		return ret;
-	}
-
 	if (event) {
 		struct vmw_fence_obj *fence = NULL;
 		struct drm_file *file_priv = event->base.file_priv;
@@ -1334,6 +1312,7 @@ vmw_stdu_primary_plane_atomic_update(str
 	struct vmw_screen_target_display_unit *stdu;
 	struct vmw_plane_state *vps = vmw_plane_state_to_vps(plane->state);
 	struct drm_crtc *crtc = plane->state->crtc ?: old_state->crtc;
+	struct vmw_framebuffer *vfb = NULL;
 	int ret;
 
 	stdu     = vmw_crtc_to_stdu(crtc);
@@ -1347,9 +1326,10 @@ vmw_stdu_primary_plane_atomic_update(str
 	if (!stdu->defined)
 		return;
 
-	if (plane->state->fb)
+	if (plane->state->fb) {
+		vfb = vmw_framebuffer_to_vfb(plane->state->fb);
 		ret = vmw_stdu_bind_st(dev_priv, stdu, &stdu->display_srf->res);
-	else
+	} else
 		ret = vmw_stdu_bind_st(dev_priv, stdu, NULL);
 
 	/*
@@ -1361,7 +1341,24 @@ vmw_stdu_primary_plane_atomic_update(str
 	else
 		crtc->primary->fb = plane->state->fb;
 
-	ret = vmw_stdu_update_st(dev_priv, stdu);
+	if (vfb) {
+		struct drm_vmw_rect vclips;
+
+		vclips.x = crtc->x;
+		vclips.y = crtc->y;
+		vclips.w = crtc->mode.hdisplay;
+		vclips.h = crtc->mode.vdisplay;
+
+		if (vfb->dmabuf)
+			ret = vmw_kms_stdu_dma(dev_priv, NULL, vfb, NULL, NULL,
+					       &vclips, 1, 1, true, false,
+					       crtc);
+		else
+			ret = vmw_kms_stdu_surface_dirty(dev_priv, vfb, NULL,
+							 &vclips, NULL, 0, 0,
+							 1, 1, NULL, crtc);
+	} else
+		ret = vmw_stdu_update_st(dev_priv, stdu);
 
 	if (ret)
 		DRM_ERROR("Failed to update STDU.\n");
