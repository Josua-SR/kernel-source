From: Huazhong Tan <tanhuazhong@huawei.com>
Date: Sat, 11 Jan 2020 16:33:53 +0800
Subject: net: hns3: refactor the notification scheme of PF reset
Patch-mainline: v5.6-rc1
Git-commit: c7554dcd6dbff3d1b295062649df4bce410bf50e
References: bsc#1154353

hclge_reset_prepare_down() is only used to inform VF that PF is
going to do function reset, then using hclge_func_reset_sync_vf()
in hclge_reset_prepare_wait() to query whether VF is ready before
asserting PF function reset. To make the code more readable,
this patch uses a new function hclge_function_reset_notify_vf()
to do this job.

Signed-off-by: Huazhong Tan <tanhuazhong@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c |   42 +++++++---------
 1 file changed, 19 insertions(+), 23 deletions(-)

--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
@@ -3562,23 +3562,6 @@ static void hclge_clear_reset_cause(stru
 	hclge_enable_vector(&hdev->misc_vector, true);
 }
 
-static int hclge_reset_prepare_down(struct hclge_dev *hdev)
-{
-	int ret = 0;
-
-	switch (hdev->reset_type) {
-	case HNAE3_FUNC_RESET:
-		/* fall through */
-	case HNAE3_FLR_RESET:
-		ret = hclge_set_all_vf_rst(hdev, true);
-		break;
-	default:
-		break;
-	}
-
-	return ret;
-}
-
 static void hclge_reset_handshake(struct hclge_dev *hdev, bool enable)
 {
 	u32 reg_val;
@@ -3592,6 +3575,19 @@ static void hclge_reset_handshake(struct
 	hclge_write_dev(&hdev->hw, HCLGE_NIC_CSQ_DEPTH_REG, reg_val);
 }
 
+static int hclge_func_reset_notify_vf(struct hclge_dev *hdev)
+{
+	int ret;
+
+	ret = hclge_set_all_vf_rst(hdev, true);
+	if (ret)
+		return ret;
+
+	hclge_func_reset_sync_vf(hdev);
+
+	return 0;
+}
+
 static int hclge_reset_prepare_wait(struct hclge_dev *hdev)
 {
 	u32 reg_val;
@@ -3599,7 +3595,9 @@ static int hclge_reset_prepare_wait(stru
 
 	switch (hdev->reset_type) {
 	case HNAE3_FUNC_RESET:
-		hclge_func_reset_sync_vf(hdev);
+		ret = hclge_func_reset_notify_vf(hdev);
+		if (ret)
+			return ret;
 
 		ret = hclge_func_reset_cmd(hdev, 0);
 		if (ret) {
@@ -3617,7 +3615,9 @@ static int hclge_reset_prepare_wait(stru
 		hdev->rst_stats.pf_rst_cnt++;
 		break;
 	case HNAE3_FLR_RESET:
-		hclge_func_reset_sync_vf(hdev);
+		ret = hclge_func_reset_notify_vf(hdev);
+		if (ret)
+			return ret;
 		break;
 	case HNAE3_IMP_RESET:
 		hclge_handle_imp_error(hdev);
@@ -3761,10 +3761,6 @@ static int hclge_reset_prepare(struct hc
 	if (ret)
 		return ret;
 
-	ret = hclge_reset_prepare_down(hdev);
-	if (ret)
-		return ret;
-
 	rtnl_lock();
 	ret = hclge_notify_client(hdev, HNAE3_DOWN_CLIENT);
 	rtnl_unlock();
