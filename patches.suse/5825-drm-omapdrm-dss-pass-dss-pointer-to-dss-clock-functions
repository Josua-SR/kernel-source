From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Tue, 13 Feb 2018 14:00:26 +0200
Subject: drm: omapdrm: dss: Pass DSS pointer to dss clock functions
Git-commit: 60f9c59fc1e2ced4a02e91088c367395edacc7fe
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

This removes the need to access the global DSS private data in those
functions (both for the current accesses and the future ones that will
be introduced when allocating the DSS device dynamically).

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/omapdrm/dss/dispc.c |    8 +++----
 drivers/gpu/drm/omapdrm/dss/dpi.c   |   14 +++++++------
 drivers/gpu/drm/omapdrm/dss/dss.c   |   37 +++++++++++++++++-------------------
 drivers/gpu/drm/omapdrm/dss/dss.h   |   10 ++++-----
 drivers/gpu/drm/omapdrm/dss/sdi.c   |    5 ++--
 5 files changed, 38 insertions(+), 36 deletions(-)

--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -3116,7 +3116,7 @@ static unsigned long dispc_fclk_rate(voi
 	src = dss_get_dispc_clk_source(dispc.dss);
 
 	if (src == DSS_CLK_SRC_FCK) {
-		r = dss_get_dispc_clk_rate();
+		r = dss_get_dispc_clk_rate(dispc.dss);
 	} else {
 		struct dss_pll *pll;
 		unsigned int clkout_idx;
@@ -3143,7 +3143,7 @@ static unsigned long dispc_mgr_lclk_rate
 	src = dss_get_lcd_clk_source(dispc.dss, channel);
 
 	if (src == DSS_CLK_SRC_FCK) {
-		r = dss_get_dispc_clk_rate();
+		r = dss_get_dispc_clk_rate(dispc.dss);
 	} else {
 		struct dss_pll *pll;
 		unsigned int clkout_idx;
@@ -3499,7 +3499,7 @@ bool dispc_div_calc(unsigned long dispc_
 	pckd_hw_min = dispc.feat->min_pcd;
 	pckd_hw_max = 255;
 
-	lck_max = dss_get_max_fck_rate();
+	lck_max = dss_get_max_fck_rate(dispc.dss);
 
 	pck_min = pck_min ? pck_min : 1;
 	pck_max = pck_max ? pck_max : ULONG_MAX;
@@ -4460,7 +4460,7 @@ static void dispc_errata_i734_wa(void)
 
 	/* Set up and enable display manager for LCD1 */
 	dispc_mgr_setup(OMAP_DSS_CHANNEL_LCD, &i734.mgri);
-	dispc_calc_clock_rates(dss_get_dispc_clk_rate(),
+	dispc_calc_clock_rates(dss_get_dispc_clk_rate(dispc.dss),
 			       &lcd_conf.clock_info);
 	dispc_mgr_set_lcd_config(OMAP_DSS_CHANNEL_LCD, &lcd_conf);
 	dispc_mgr_set_timings(OMAP_DSS_CHANNEL_LCD, &i734.vm);
--- a/drivers/gpu/drm/omapdrm/dss/dpi.c
+++ b/drivers/gpu/drm/omapdrm/dss/dpi.c
@@ -207,7 +207,7 @@ static bool dpi_calc_pll_cb(int n, int m
 	ctx->pll_cinfo.clkdco = clkdco;
 
 	return dss_pll_hsdiv_calc_a(ctx->pll, clkdco,
-		ctx->pck_min, dss_get_max_fck_rate(),
+		ctx->pck_min, dss_get_max_fck_rate(ctx->pll->dss),
 		dpi_calc_hsdiv_cb, ctx);
 }
 
@@ -256,7 +256,8 @@ static bool dpi_pll_clk_calc(struct dpi_
 	}
 }
 
-static bool dpi_dss_clk_calc(unsigned long pck, struct dpi_clk_calc_ctx *ctx)
+static bool dpi_dss_clk_calc(struct dpi_data *dpi, unsigned long pck,
+			     struct dpi_clk_calc_ctx *ctx)
 {
 	int i;
 
@@ -277,7 +278,8 @@ static bool dpi_dss_clk_calc(unsigned lo
 			ctx->pck_min = 0;
 		ctx->pck_max = pck + 1000 * i * i * i;
 
-		ok = dss_div_calc(pck, ctx->pck_min, dpi_calc_dss_cb, ctx);
+		ok = dss_div_calc(dpi->dss, pck, ctx->pck_min,
+				  dpi_calc_dss_cb, ctx);
 		if (ok)
 			return ok;
 	}
@@ -321,11 +323,11 @@ static int dpi_set_dispc_clk(struct dpi_
 	int r;
 	bool ok;
 
-	ok = dpi_dss_clk_calc(pck_req, &ctx);
+	ok = dpi_dss_clk_calc(dpi, pck_req, &ctx);
 	if (!ok)
 		return -EINVAL;
 
-	r = dss_set_fck_rate(ctx.fck);
+	r = dss_set_fck_rate(dpi->dss, ctx.fck);
 	if (r)
 		return r;
 
@@ -530,7 +532,7 @@ static int dpi_check_timings(struct omap
 
 		fck = ctx.pll_cinfo.clkout[ctx.clkout_idx];
 	} else {
-		ok = dpi_dss_clk_calc(vm->pixelclock, &ctx);
+		ok = dpi_dss_clk_calc(dpi, vm->pixelclock, &ctx);
 		if (!ok)
 			return -EINVAL;
 
--- a/drivers/gpu/drm/omapdrm/dss/dss.c
+++ b/drivers/gpu/drm/omapdrm/dss/dss.c
@@ -594,8 +594,8 @@ enum dss_clk_source dss_get_lcd_clk_sour
 	}
 }
 
-bool dss_div_calc(unsigned long pck, unsigned long fck_min,
-		dss_div_calc_func func, void *data)
+bool dss_div_calc(struct dss_device *dss, unsigned long pck,
+		  unsigned long fck_min, dss_div_calc_func func, void *data)
 {
 	int fckd, fckd_start, fckd_stop;
 	unsigned long fck;
@@ -604,24 +604,24 @@ bool dss_div_calc(unsigned long pck, uns
 	unsigned long prate;
 	unsigned int m;
 
-	fck_hw_max = dss.feat->fck_freq_max;
+	fck_hw_max = dss->feat->fck_freq_max;
 
-	if (dss.parent_clk == NULL) {
+	if (dss->parent_clk == NULL) {
 		unsigned int pckd;
 
 		pckd = fck_hw_max / pck;
 
 		fck = pck * pckd;
 
-		fck = clk_round_rate(dss.dss_clk, fck);
+		fck = clk_round_rate(dss->dss_clk, fck);
 
 		return func(fck, data);
 	}
 
-	fckd_hw_max = dss.feat->fck_div_max;
+	fckd_hw_max = dss->feat->fck_div_max;
 
-	m = dss.feat->dss_fck_multiplier;
-	prate = clk_get_rate(dss.parent_clk);
+	m = dss->feat->dss_fck_multiplier;
+	prate = clk_get_rate(dss->parent_clk);
 
 	fck_min = fck_min ? fck_min : 1;
 
@@ -638,33 +638,32 @@ bool dss_div_calc(unsigned long pck, uns
 	return false;
 }
 
-int dss_set_fck_rate(unsigned long rate)
+int dss_set_fck_rate(struct dss_device *dss, unsigned long rate)
 {
 	int r;
 
 	DSSDBG("set fck to %lu\n", rate);
 
-	r = clk_set_rate(dss.dss_clk, rate);
+	r = clk_set_rate(dss->dss_clk, rate);
 	if (r)
 		return r;
 
-	dss.dss_clk_rate = clk_get_rate(dss.dss_clk);
+	dss->dss_clk_rate = clk_get_rate(dss->dss_clk);
 
-	WARN_ONCE(dss.dss_clk_rate != rate,
-			"clk rate mismatch: %lu != %lu", dss.dss_clk_rate,
-			rate);
+	WARN_ONCE(dss->dss_clk_rate != rate, "clk rate mismatch: %lu != %lu",
+		  dss->dss_clk_rate, rate);
 
 	return 0;
 }
 
-unsigned long dss_get_dispc_clk_rate(void)
+unsigned long dss_get_dispc_clk_rate(struct dss_device *dss)
 {
-	return dss.dss_clk_rate;
+	return dss->dss_clk_rate;
 }
 
-unsigned long dss_get_max_fck_rate(void)
+unsigned long dss_get_max_fck_rate(struct dss_device *dss)
 {
-	return dss.feat->fck_freq_max;
+	return dss->feat->fck_freq_max;
 }
 
 enum omap_dss_output_id dss_get_supported_outputs(enum omap_channel channel)
@@ -691,7 +690,7 @@ static int dss_setup_default_clock(void)
 		fck = DIV_ROUND_UP(prate, fck_div) * dss.feat->dss_fck_multiplier;
 	}
 
-	r = dss_set_fck_rate(fck);
+	r = dss_set_fck_rate(&dss, fck);
 	if (r)
 		return r;
 
--- a/drivers/gpu/drm/omapdrm/dss/dss.h
+++ b/drivers/gpu/drm/omapdrm/dss/dss.h
@@ -297,8 +297,8 @@ struct dss_device *dss_get_device(struct
 int dss_runtime_get(struct dss_device *dss);
 void dss_runtime_put(struct dss_device *dss);
 
-unsigned long dss_get_dispc_clk_rate(void);
-unsigned long dss_get_max_fck_rate(void);
+unsigned long dss_get_dispc_clk_rate(struct dss_device *dss);
+unsigned long dss_get_max_fck_rate(struct dss_device *dss);
 enum omap_dss_output_id dss_get_supported_outputs(enum omap_channel channel);
 int dss_dpi_select_source(struct dss_device *dss, int port,
 			  enum omap_channel channel);
@@ -332,11 +332,11 @@ enum dss_clk_source dss_get_lcd_clk_sour
 void dss_set_venc_output(enum omap_dss_venc_type type);
 void dss_set_dac_pwrdn_bgz(bool enable);
 
-int dss_set_fck_rate(unsigned long rate);
+int dss_set_fck_rate(struct dss_device *dss, unsigned long rate);
 
 typedef bool (*dss_div_calc_func)(unsigned long fck, void *data);
-bool dss_div_calc(unsigned long pck, unsigned long fck_min,
-		dss_div_calc_func func, void *data);
+bool dss_div_calc(struct dss_device *dss, unsigned long pck,
+		  unsigned long fck_min, dss_div_calc_func func, void *data);
 
 /* SDI */
 #ifdef CONFIG_OMAP2_DSS_SDI
--- a/drivers/gpu/drm/omapdrm/dss/sdi.c
+++ b/drivers/gpu/drm/omapdrm/dss/sdi.c
@@ -99,7 +99,8 @@ static int sdi_calc_clock_div(unsigned l
 			ctx.pck_min = 0;
 		ctx.pck_max = pclk + 1000 * i * i * i;
 
-		ok = dss_div_calc(pclk, ctx.pck_min, dpi_calc_dss_cb, &ctx);
+		ok = dss_div_calc(sdi.dss, pclk, ctx.pck_min,
+				  dpi_calc_dss_cb, &ctx);
 		if (ok) {
 			*fck = ctx.fck;
 			*dispc_cinfo = ctx.dispc_cinfo;
@@ -169,7 +170,7 @@ static int sdi_display_enable(struct oma
 
 	dss_mgr_set_timings(channel, vm);
 
-	r = dss_set_fck_rate(fck);
+	r = dss_set_fck_rate(sdi.dss, fck);
 	if (r)
 		goto err_set_dss_clock_div;
 
