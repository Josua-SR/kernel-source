From 21ae30d1ad4328873b5367b64d306177590c692e Mon Sep 17 00:00:00 2001
From: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date: Wed, 10 Jun 2020 11:49:16 -0400
Subject: drm/amd/display: Add logger for SMU msg
Git-commit: 1664641ea946f463b12e259e6345d0a86de560e4
Patch-mainline: v5.9-rc1
References: jsc#SLE-12680, jsc#SLE-12880, jsc#SLE-12882, jsc#SLE-12883, jsc#SLE-13496, jsc#SLE-15322

[WHY]
We want to be able to see SMU messages sent and their responses

Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
Reviewed-by: Joshua Aberback <Joshua.Aberback@amd.com>
Acked-by: Eryk Brol <eryk.brol@amd.com>
Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 .../dc/clk_mgr/dcn30/dcn30_clk_mgr_smu_msg.c  | 65 ++++++++++++++++++-
 .../drm/amd/display/include/logger_types.h    |  2 +
 2 files changed, 64 insertions(+), 3 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn30/dcn30_clk_mgr_smu_msg.c b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn30/dcn30_clk_mgr_smu_msg.c
index 986c53a3b6a8..7ee3ec5a8af8 100644
--- a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn30/dcn30_clk_mgr_smu_msg.c
+++ b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn30/dcn30_clk_mgr_smu_msg.c
@@ -37,6 +37,13 @@
 #define REG(reg_name) \
 	mm ## reg_name
 
+#include "logger_types.h"
+#undef DC_LOGGER
+#define DC_LOGGER \
+	CTX->logger
+#define smu_print(str, ...) {DC_LOG_SMU(str, ##__VA_ARGS__); }
+
+
 /*
  * Function to be used instead of REG_WAIT macro because the wait ends when
  * the register is NOT EQUAL to zero, and because the translation in msg_if.h
@@ -94,6 +101,8 @@ bool dcn30_smu_test_message(struct clk_mgr_internal *clk_mgr, uint32_t input)
 {
 	uint32_t response = 0;
 
+	smu_print("SMU Test message: %d\n", input);
+
 	if (dcn30_smu_send_msg_with_param(clk_mgr,
 			DALSMC_MSG_TestMessage, input, &response))
 		if (response == input + 1)
@@ -104,9 +113,15 @@ bool dcn30_smu_test_message(struct clk_mgr_internal *clk_mgr, uint32_t input)
 
 bool dcn30_smu_get_smu_version(struct clk_mgr_internal *clk_mgr, unsigned int *version)
 {
+	smu_print("SMU Get SMU version\n");
+
 	if (dcn30_smu_send_msg_with_param(clk_mgr,
-			DALSMC_MSG_GetSmuVersion, 0, version))
+			DALSMC_MSG_GetSmuVersion, 0, version)) {
+
+		smu_print("SMU version: %d\n", *version);
+
 		return true;
+	}
 
 	return false;
 }
@@ -116,10 +131,16 @@ bool dcn30_smu_check_driver_if_version(struct clk_mgr_internal *clk_mgr)
 {
 	uint32_t response = 0;
 
+	smu_print("SMU Check driver if version\n");
+
 	if (dcn30_smu_send_msg_with_param(clk_mgr,
-			DALSMC_MSG_GetDriverIfVersion, 0, &response))
+			DALSMC_MSG_GetDriverIfVersion, 0, &response)) {
+
+		smu_print("SMU driver if version: %d\n", response);
+
 		if (response == SMU11_DRIVER_IF_VERSION)
 			return true;
+	}
 
 	return false;
 }
@@ -129,34 +150,48 @@ bool dcn30_smu_check_msg_header_version(struct clk_mgr_internal *clk_mgr)
 {
 	uint32_t response = 0;
 
+	smu_print("SMU Check msg header version\n");
+
 	if (dcn30_smu_send_msg_with_param(clk_mgr,
-			DALSMC_MSG_GetMsgHeaderVersion, 0, &response))
+			DALSMC_MSG_GetMsgHeaderVersion, 0, &response)) {
+
+		smu_print("SMU msg header version: %d\n", response);
+
 		if (response == DALSMC_VERSION)
 			return true;
+	}
 
 	return false;
 }
 
 void dcn30_smu_set_dram_addr_high(struct clk_mgr_internal *clk_mgr, uint32_t addr_high)
 {
+	smu_print("SMU Set DRAM addr high: %d\n", addr_high);
+
 	dcn30_smu_send_msg_with_param(clk_mgr,
 			DALSMC_MSG_SetDalDramAddrHigh, addr_high, NULL);
 }
 
 void dcn30_smu_set_dram_addr_low(struct clk_mgr_internal *clk_mgr, uint32_t addr_low)
 {
+	smu_print("SMU Set DRAM addr low: %d\n", addr_low);
+
 	dcn30_smu_send_msg_with_param(clk_mgr,
 			DALSMC_MSG_SetDalDramAddrLow, addr_low, NULL);
 }
 
 void dcn30_smu_transfer_wm_table_smu_2_dram(struct clk_mgr_internal *clk_mgr)
 {
+	smu_print("SMU Transfer WM table SMU 2 DRAM\n");
+
 	dcn30_smu_send_msg_with_param(clk_mgr,
 			DALSMC_MSG_TransferTableSmu2Dram, TABLE_WATERMARKS, NULL);
 }
 
 void dcn30_smu_transfer_wm_table_dram_2_smu(struct clk_mgr_internal *clk_mgr)
 {
+	smu_print("SMU Transfer WM table DRAM 2 SMU\n");
+
 	dcn30_smu_send_msg_with_param(clk_mgr,
 			DALSMC_MSG_TransferTableDram2Smu, TABLE_WATERMARKS, NULL);
 }
@@ -169,9 +204,13 @@ unsigned int dcn30_smu_set_hard_min_by_freq(struct clk_mgr_internal *clk_mgr, PP
 	/* bits 23:16 for clock type, lower 16 bits for frequency in MHz */
 	uint32_t param = (clk << 16) | freq_mhz;
 
+	smu_print("SMU Set hard min by freq: clk = %d, freq_mhz = %d MHz\n", clk, freq_mhz);
+
 	dcn30_smu_send_msg_with_param(clk_mgr,
 			DALSMC_MSG_SetHardMinByFreq, param, &response);
 
+	smu_print("SMU Frequency set = %d MHz\n", response);
+
 	return response;
 }
 
@@ -183,9 +222,13 @@ unsigned int dcn30_smu_set_hard_max_by_freq(struct clk_mgr_internal *clk_mgr, PP
 	/* bits 23:16 for clock type, lower 16 bits for frequency in MHz */
 	uint32_t param = (clk << 16) | freq_mhz;
 
+	smu_print("SMU Set hard max by freq: clk = %d, freq_mhz = %d MHz\n", clk, freq_mhz);
+
 	dcn30_smu_send_msg_with_param(clk_mgr,
 			DALSMC_MSG_SetHardMaxByFreq, param, &response);
 
+	smu_print("SMU Frequency set = %d MHz\n", response);
+
 	return response;
 }
 
@@ -210,9 +253,13 @@ unsigned int dcn30_smu_get_dpm_freq_by_index(struct clk_mgr_internal *clk_mgr, P
 	/* bits 23:16 for clock type, lower 8 bits for DPM level */
 	uint32_t param = (clk << 16) | dpm_level;
 
+	smu_print("SMU Get dpm freq by index: clk = %d, dpm_level = %d\n", clk, dpm_level);
+
 	dcn30_smu_send_msg_with_param(clk_mgr,
 			DALSMC_MSG_GetDpmFreqByIndex, param, &response);
 
+	smu_print("SMU dpm freq: %d MHz\n", response);
+
 	return response;
 }
 
@@ -224,32 +271,44 @@ unsigned int dcn30_smu_get_dc_mode_max_dpm_freq(struct clk_mgr_internal *clk_mgr
 	/* bits 23:16 for clock type */
 	uint32_t param = clk << 16;
 
+	smu_print("SMU Get DC mode max DPM freq: clk = %d\n", clk);
+
 	dcn30_smu_send_msg_with_param(clk_mgr,
 			DALSMC_MSG_GetDcModeMaxDpmFreq, param, &response);
 
+	smu_print("SMU DC mode max DMP freq: %d MHz\n", response);
+
 	return response;
 }
 
 void dcn30_smu_set_min_deep_sleep_dcef_clk(struct clk_mgr_internal *clk_mgr, uint32_t freq_mhz)
 {
+	smu_print("SMU Set min deep sleep dcef clk: freq_mhz = %d MHz\n", freq_mhz);
+
 	dcn30_smu_send_msg_with_param(clk_mgr,
 			DALSMC_MSG_SetMinDeepSleepDcefclk, freq_mhz, NULL);
 }
 
 void dcn30_smu_set_num_of_displays(struct clk_mgr_internal *clk_mgr, uint32_t num_displays)
 {
+	smu_print("SMU Set num of displays: num_displays = %d\n", num_displays);
+
 	dcn30_smu_send_msg_with_param(clk_mgr,
 			DALSMC_MSG_NumOfDisplays, num_displays, NULL);
 }
 
 void dcn30_smu_set_external_client_df_cstate_allow(struct clk_mgr_internal *clk_mgr, bool enable)
 {
+	smu_print("SMU Set external client df cstate allow: enable = %d\n", enable);
+
 	dcn30_smu_send_msg_with_param(clk_mgr,
 			DALSMC_MSG_SetExternalClientDfCstateAllow, enable ? 1 : 0, NULL);
 }
 
 void dcn30_smu_set_pme_workaround(struct clk_mgr_internal *clk_mgr)
 {
+	smu_print("SMU Set PME workaround\n");
+
 	dcn30_smu_send_msg_with_param(clk_mgr,
 	DALSMC_MSG_BacoAudioD3PME, 0, NULL);
 }
diff --git a/drivers/gpu/drm/amd/display/include/logger_types.h b/drivers/gpu/drm/amd/display/include/logger_types.h
index 5dea27fc5198..21bbee17c527 100644
--- a/drivers/gpu/drm/amd/display/include/logger_types.h
+++ b/drivers/gpu/drm/amd/display/include/logger_types.h
@@ -67,6 +67,7 @@
 #define DC_LOG_ALL_GAMMA(...) pr_debug("[GAMMA]:"__VA_ARGS__)
 #define DC_LOG_ALL_TF_CHANNELS(...) pr_debug("[GAMMA]:"__VA_ARGS__)
 #define DC_LOG_DSC(...) DRM_DEBUG_KMS(__VA_ARGS__)
+#define DC_LOG_SMU(...) pr_debug("[SMU_MSG]:"__VA_ARGS__)
 #define DC_LOG_DWB(...) DRM_DEBUG_KMS(__VA_ARGS__)
 
 struct dal_logger;
@@ -113,6 +114,7 @@ enum dc_log_type {
 	LOG_DISPLAYSTATS,
 	LOG_HDMI_RETIMER_REDRIVER,
 	LOG_DSC,
+	LOG_SMU_MSG,
 	LOG_DWB,
 	LOG_GAMMA_DEBUG,
 	LOG_MAX_HW_POINTS,
-- 
2.29.2

