From: Chuck Lever <chuck.lever@oracle.com>
Date: Thu, 14 Dec 2017 20:58:04 -0500
Subject: xprtrdma: Introduce rpcrdma_mw_unmap_and_put
Patch-mainline: v4.16-rc1
Git-commit: ec12e479e30653bf973ca1185bbb09158e9af0b7
References: bsc#1103992 FATE#326009

Clean up: Code review suggested that a common bit of code can be
placed into a helper function, and this gives us fewer places to
stick an "I DMA unmapped something" trace point.

Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 net/sunrpc/xprtrdma/fmr_ops.c   |   19 ++++++++-----------
 net/sunrpc/xprtrdma/frwr_ops.c  |   10 ++--------
 net/sunrpc/xprtrdma/verbs.c     |   26 ++++++++++++++++++++++----
 net/sunrpc/xprtrdma/xprt_rdma.h |    1 +
 4 files changed, 33 insertions(+), 23 deletions(-)

--- a/net/sunrpc/xprtrdma/fmr_ops.c
+++ b/net/sunrpc/xprtrdma/fmr_ops.c
@@ -134,14 +134,12 @@ fmr_op_recover_mr(struct rpcrdma_mr *mr)
 
 	/* ORDER: invalidate first */
 	rc = __fmr_unmap(mr);
-
-	/* ORDER: then DMA unmap */
-	ib_dma_unmap_sg(r_xprt->rx_ia.ri_device,
-			mr->mr_sg, mr->mr_nents, mr->mr_dir);
 	if (rc)
 		goto out_release;
 
-	rpcrdma_mr_put(mr);
+	/* ORDER: then DMA unmap */
+	rpcrdma_mr_unmap_and_put(mr);
+
 	r_xprt->rx_stats.mrs_recovered++;
 	return;
 
@@ -149,6 +147,9 @@ out_release:
 	pr_err("rpcrdma: FMR reset failed (%d), %p released\n", rc, mr);
 	r_xprt->rx_stats.mrs_orphaned++;
 
+	ib_dma_unmap_sg(r_xprt->rx_ia.ri_device,
+			mr->mr_sg, mr->mr_nents, mr->mr_dir);
+
 	spin_lock(&r_xprt->rx_buf.rb_mrlock);
 	list_del(&mr->mr_all);
 	spin_unlock(&r_xprt->rx_buf.rb_mrlock);
@@ -244,9 +245,7 @@ out_maperr:
 	pr_err("rpcrdma: ib_map_phys_fmr %u@0x%llx+%i (%d) status %i\n",
 	       len, (unsigned long long)dma_pages[0],
 	       pageoff, mr->mr_nents, rc);
-	ib_dma_unmap_sg(r_xprt->rx_ia.ri_device,
-			mr->mr_sg, mr->mr_nents, mr->mr_dir);
-	rpcrdma_mr_put(mr);
+	rpcrdma_mr_unmap_and_put(mr);
 	return ERR_PTR(-EIO);
 }
 
@@ -288,9 +287,7 @@ fmr_op_unmap_sync(struct rpcrdma_xprt *r
 		dprintk("RPC:       %s: DMA unmapping fmr %p\n",
 			__func__, &mr->fmr);
 		list_del(&mr->fmr.fm_mr->list);
-		ib_dma_unmap_sg(r_xprt->rx_ia.ri_device,
-				mr->mr_sg, mr->mr_nents, mr->mr_dir);
-		rpcrdma_mr_put(mr);
+		rpcrdma_mr_unmap_and_put(mr);
 	}
 
 	return;
--- a/net/sunrpc/xprtrdma/frwr_ops.c
+++ b/net/sunrpc/xprtrdma/frwr_ops.c
@@ -458,13 +458,9 @@ frwr_op_reminv(struct rpcrdma_rep *rep,
 
 	list_for_each_entry(mr, mrs, mr_list)
 		if (mr->mr_handle == rep->rr_inv_rkey) {
-			struct rpcrdma_xprt *r_xprt = mr->mr_xprt;
-
 			list_del(&mr->mr_list);
 			mr->frwr.fr_state = FRWR_IS_INVALID;
-			ib_dma_unmap_sg(r_xprt->rx_ia.ri_device,
-					mr->mr_sg, mr->mr_nents, mr->mr_dir);
-			rpcrdma_mr_put(mr);
+			rpcrdma_mr_unmap_and_put(mr);
 			break;	/* only one invalidated MR per RPC */
 		}
 }
@@ -544,9 +540,7 @@ unmap:
 		mr = rpcrdma_mr_pop(mrs);
 		dprintk("RPC:       %s: DMA unmapping frwr %p\n",
 			__func__, &mr->frwr);
-		ib_dma_unmap_sg(ia->ri_device,
-				mr->mr_sg, mr->mr_nents, mr->mr_dir);
-		rpcrdma_mr_put(mr);
+		rpcrdma_mr_unmap_and_put(mr);
 	}
 	return;
 
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@ -1321,6 +1321,14 @@ out_nomrs:
 	return NULL;
 }
 
+static void
+__rpcrdma_mr_put(struct rpcrdma_buffer *buf, struct rpcrdma_mr *mr)
+{
+	spin_lock(&buf->rb_mrlock);
+	rpcrdma_mr_push(mr, &buf->rb_mrs);
+	spin_unlock(&buf->rb_mrlock);
+}
+
 /**
  * rpcrdma_mr_put - Release an rpcrdma_mr object
  * @mr: object to release
@@ -1329,12 +1337,22 @@ out_nomrs:
 void
 rpcrdma_mr_put(struct rpcrdma_mr *mr)
 {
+	__rpcrdma_mr_put(&mr->mr_xprt->rx_buf, mr);
+}
+
+/**
+ * rpcrdma_mr_unmap_and_put - DMA unmap an MR and release it
+ * @mr: object to release
+ *
+ */
+void
+rpcrdma_mr_unmap_and_put(struct rpcrdma_mr *mr)
+{
 	struct rpcrdma_xprt *r_xprt = mr->mr_xprt;
-	struct rpcrdma_buffer *buf = &r_xprt->rx_buf;
 
-	spin_lock(&buf->rb_mrlock);
-	rpcrdma_mr_push(mr, &buf->rb_mrs);
-	spin_unlock(&buf->rb_mrlock);
+	ib_dma_unmap_sg(r_xprt->rx_ia.ri_device,
+			mr->mr_sg, mr->mr_nents, mr->mr_dir);
+	__rpcrdma_mr_put(&r_xprt->rx_buf, mr);
 }
 
 static struct rpcrdma_rep *
--- a/net/sunrpc/xprtrdma/xprt_rdma.h
+++ b/net/sunrpc/xprtrdma/xprt_rdma.h
@@ -576,6 +576,7 @@ void rpcrdma_sendctx_put_locked(struct r
 
 struct rpcrdma_mr *rpcrdma_mr_get(struct rpcrdma_xprt *r_xprt);
 void rpcrdma_mr_put(struct rpcrdma_mr *mr);
+void rpcrdma_mr_unmap_and_put(struct rpcrdma_mr *mr);
 void rpcrdma_mr_defer_recovery(struct rpcrdma_mr *mr);
 
 struct rpcrdma_req *rpcrdma_buffer_get(struct rpcrdma_buffer *);
