From: Mike Marciniszyn <mike.marciniszyn@intel.com>
Date: Tue, 15 May 2018 18:31:09 -0700
Subject: IB/hfi1: Cleanup of exp_rcv
Patch-mainline: v4.18-rc1
Git-commit: c8314811f9b2068eb53728d7a06b1ea195579e79
References: bsc#1114685 FATE#325854

The knowledge of the internal workings of the expect receive
is too distributed.

Fix by:
- right size several rcd fields associated with
  expect receive
- making an init entrance to init all the lists
- consolidate all the allocations into an array anchored
  in the rcd

Reviewed-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
Reviewed-by: Kaike Wan <kaike.wan@intel.com>
Signed-off-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
Signed-off-by: Doug Ledford <dledford@redhat.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/infiniband/hw/hfi1/exp_rcv.c |   39 +++++++++++++++++++++--------------
 drivers/infiniband/hw/hfi1/exp_rcv.h |   24 ++++++++++++++++++++-
 drivers/infiniband/hw/hfi1/hfi.h     |   14 +++++++-----
 drivers/infiniband/hw/hfi1/init.c    |    4 ---
 4 files changed, 56 insertions(+), 25 deletions(-)

--- a/drivers/infiniband/hw/hfi1/exp_rcv.c
+++ b/drivers/infiniband/hw/hfi1/exp_rcv.c
@@ -52,13 +52,24 @@
  * exp_tid_group_init - initialize exp_tid_set
  * @set - the set
  */
-void hfi1_exp_tid_group_init(struct exp_tid_set *set)
+static void hfi1_exp_tid_set_init(struct exp_tid_set *set)
 {
 	INIT_LIST_HEAD(&set->list);
 	set->count = 0;
 }
 
 /**
+ * hfi1_exp_tid_group_init - initialize rcd expected receive
+ * @rcd - the rcd
+ */
+void hfi1_exp_tid_group_init(struct hfi1_ctxtdata *rcd)
+{
+	hfi1_exp_tid_set_init(&rcd->tid_group_list);
+	hfi1_exp_tid_set_init(&rcd->tid_used_list);
+	hfi1_exp_tid_set_init(&rcd->tid_full_list);
+}
+
+/**
  * alloc_ctxt_rcv_groups - initialize expected receive groups
  * @rcd - the context to add the groupings to
  */
@@ -68,13 +79,17 @@ int hfi1_alloc_ctxt_rcv_groups(struct hf
 	u32 tidbase;
 	struct tid_group *grp;
 	int i;
+	u32 ngroups;
 
+	ngroups = rcd->expected_count / dd->rcv_entries.group_size;
+	rcd->groups =
+		kcalloc_node(ngroups, sizeof(*rcd->groups),
+			     GFP_KERNEL, rcd->numa_id);
+	if (!rcd->groups)
+		return -ENOMEM;
 	tidbase = rcd->expected_base;
-	for (i = 0; i < rcd->expected_count /
-		     dd->rcv_entries.group_size; i++) {
-		grp = kzalloc(sizeof(*grp), GFP_KERNEL);
-		if (!grp)
-			goto bail;
+	for (i = 0; i < ngroups; i++) {
+		grp = &rcd->groups[i];
 		grp->size = dd->rcv_entries.group_size;
 		grp->base = tidbase;
 		tid_group_add_tail(grp, &rcd->tid_group_list);
@@ -82,9 +97,6 @@ int hfi1_alloc_ctxt_rcv_groups(struct hf
 	}
 
 	return 0;
-bail:
-	hfi1_free_ctxt_rcv_groups(rcd);
-	return -ENOMEM;
 }
 
 /**
@@ -100,15 +112,12 @@ bail:
  */
 void hfi1_free_ctxt_rcv_groups(struct hfi1_ctxtdata *rcd)
 {
-	struct tid_group *grp, *gptr;
-
 	WARN_ON(!EXP_TID_SET_EMPTY(rcd->tid_full_list));
 	WARN_ON(!EXP_TID_SET_EMPTY(rcd->tid_used_list));
 
-	list_for_each_entry_safe(grp, gptr, &rcd->tid_group_list.list, list) {
-		tid_group_remove(grp, &rcd->tid_group_list);
-		kfree(grp);
-	}
+	kfree(rcd->groups);
+	rcd->groups = NULL;
+	hfi1_exp_tid_group_init(rcd);
 
 	hfi1_clear_tids(rcd);
 }
--- a/drivers/infiniband/hw/hfi1/exp_rcv.h
+++ b/drivers/infiniband/hw/hfi1/exp_rcv.h
@@ -183,8 +183,30 @@ static inline u32 rcventry2tidinfo(u32 r
 		EXP_TID_SET(CTRL, 1 << (rcventry - pair));
 }
 
+/**
+ * hfi1_tid_group_to_idx - convert an index to a group
+ * @rcd - the receive context
+ * @grp - the group pointer
+ */
+static inline u16
+hfi1_tid_group_to_idx(struct hfi1_ctxtdata *rcd, struct tid_group *grp)
+{
+	return grp - &rcd->groups[0];
+}
+
+/**
+ * hfi1_idx_to_tid_group - convert a group to an index
+ * @rcd - the receive context
+ * @idx - the index
+ */
+static inline struct tid_group *
+hfi1_idx_to_tid_group(struct hfi1_ctxtdata *rcd, u16 idx)
+{
+	return &rcd->groups[idx];
+}
+
 int hfi1_alloc_ctxt_rcv_groups(struct hfi1_ctxtdata *rcd);
 void hfi1_free_ctxt_rcv_groups(struct hfi1_ctxtdata *rcd);
-void hfi1_exp_tid_group_init(struct exp_tid_set *set);
+void hfi1_exp_tid_group_init(struct hfi1_ctxtdata *rcd);
 
 #endif /* _HFI1_EXP_RCV_H */
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@ -231,13 +231,15 @@ struct hfi1_ctxtdata {
 	/* job key */
 	u16 jkey;
 	/* number of RcvArray groups for this context. */
-	u32 rcv_array_groups;
+	u16 rcv_array_groups;
 	/* index of first eager TID entry. */
-	u32 eager_base;
+	u16 eager_base;
 	/* number of expected TID entries */
-	u32 expected_count;
+	u16 expected_count;
 	/* index of first expected TID entry. */
-	u32 expected_base;
+	u16 expected_base;
+	/* array of tid_groups */
+	struct tid_group  *groups;
 
 	struct exp_tid_set tid_group_list;
 	struct exp_tid_set tid_used_list;
@@ -282,7 +284,7 @@ struct hfi1_ctxtdata {
 	/* interrupt handling */
 	u64 imask;	/* clear interrupt mask */
 	int ireg;	/* clear interrupt register */
-	unsigned numa_id; /* numa node of this context */
+	int numa_id; /* numa node of this context */
 	/* verbs rx_stats per rcd */
 	struct hfi1_opcode_stats_perctx *opstats;
 
@@ -909,9 +911,9 @@ typedef void (*hfi1_make_req)(struct rvt
 #define RHF_RCV_REPROCESS 2	/* stop. retain this packet */
 
 struct rcv_array_data {
-	u8 group_size;
 	u16 ngroups;
 	u16 nctxt_extra;
+	u8 group_size;
 };
 
 struct per_vl_data {
--- a/drivers/infiniband/hw/hfi1/init.c
+++ b/drivers/infiniband/hw/hfi1/init.c
@@ -361,9 +361,7 @@ int hfi1_create_ctxtdata(struct hfi1_ppo
 		}
 
 		INIT_LIST_HEAD(&rcd->qp_wait_list);
-		hfi1_exp_tid_group_init(&rcd->tid_group_list);
-		hfi1_exp_tid_group_init(&rcd->tid_used_list);
-		hfi1_exp_tid_group_init(&rcd->tid_full_list);
+		hfi1_exp_tid_group_init(rcd);
 		rcd->ppd = ppd;
 		rcd->dd = dd;
 		__set_bit(0, rcd->in_use_ctxts);
