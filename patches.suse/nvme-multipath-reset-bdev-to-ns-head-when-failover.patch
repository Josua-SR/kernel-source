From: Daniel Wagner <dwagner@suse.de>
Date: Mon, 3 May 2021 19:03:03 +0200
Subject: nvme-multipath: reset bdev to ns head when failover
Patch-mainline: v5.13-rc1
Git-commit: ce86dad222e9074d3ec174ec81cb463a770331b5
References: bsc#178378 bsc#1182999

When a request finally completes in end_io() after it has failed over,
the bdev pointer can be stale and thus the system can crash. Set the
bdev back to ns head, so the request is map to an active path when
resubmitted.

Signed-off-by: Daniel Wagner <dwagner@suse.de>
Reviewed-by: Hannes Reinecke <hare@suse.de>
Signed-off-by: Christoph Hellwig <hch@lst.de>
[dwagner: use bdget_disk() to retrieve bdev]
Signed-off-by: Daniel Wagner <dwagner@suse.de>
---
 drivers/nvme/host/multipath.c |    7 +++++++
 1 file changed, 7 insertions(+)

--- a/drivers/nvme/host/multipath.c
+++ b/drivers/nvme/host/multipath.c
@@ -69,7 +69,9 @@ bool nvme_failover_req(struct request *r
 {
 	struct nvme_ns *ns = req->q->queuedata;
 	u16 status = nvme_req(req)->status;
+	struct block_device *bdev;
 	unsigned long flags;
+	struct bio *bio;
 
 	switch (status & 0x7ff) {
 	case NVME_SC_ANA_TRANSITION:
@@ -103,10 +105,15 @@ bool nvme_failover_req(struct request *r
 		return false;
 	}
 
+	bdev = bdget_disk(ns->head->disk, 0);
+	WARN_ON(!bdev);
 	spin_lock_irqsave(&ns->head->requeue_lock, flags);
+	for (bio = req->bio; bio; bio = bio->bi_next)
+		bio_set_dev(bio, bdev);
 	blk_steal_bios(&ns->head->requeue_list, req);
 	spin_unlock_irqrestore(&ns->head->requeue_lock, flags);
 	blk_mq_end_request(req, 0);
+	bdput(bdev);
 
 	kblockd_schedule_work(&ns->head->requeue_work);
 	return true;
