From: Roger He <Hongbo.He@amd.com>
Date: Tue, 21 Nov 2017 16:47:16 +0800
Subject: drm/ttm: roundup the shrink request to prevent skip huge pool
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 2bf257d662509553ae226239e7dc1c3d00636ca6
Patch-mainline: v4.15-rc3
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

e.g. shrink reqeust is less than 512, the logic will skip huge pool

Reviewed-by: Chunming Zhou <david1.zhou@amd.com>
Reviewed-by: Christian KÃ¶nig <christian.koenig@amd.com>
Signed-off-by: Roger He <Hongbo.He@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/ttm/ttm_page_alloc.c |   12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

--- a/drivers/gpu/drm/ttm/ttm_page_alloc.c
+++ b/drivers/gpu/drm/ttm/ttm_page_alloc.c
@@ -442,17 +442,19 @@ ttm_pool_shrink_scan(struct shrinker *sh
 	/* select start pool in round robin fashion */
 	for (i = 0; i < NUM_POOLS; ++i) {
 		unsigned nr_free = shrink_pages;
+		unsigned page_nr;
+
 		if (shrink_pages == 0)
 			break;
 
 		pool = &_manager->pools[(i + pool_offset)%NUM_POOLS];
+		page_nr = (1 << pool->order);
 		/* OK to use static buffer since global mutex is held. */
-		nr_free_pool = (nr_free >> pool->order);
-		if (nr_free_pool == 0)
-			continue;
-
+		nr_free_pool = roundup(nr_free, page_nr) >> pool->order;
 		shrink_pages = ttm_page_pool_free(pool, nr_free_pool, true);
-		freed += ((nr_free_pool - shrink_pages) << pool->order);
+		freed += (nr_free_pool - shrink_pages) << pool->order;
+		if (freed >= sc->nr_to_scan)
+			break;
 	}
 	mutex_unlock(&lock);
 	return freed;
