From: Arjun Vynipadath <arjun@chelsio.com>
Date: Thu, 28 Feb 2019 15:33:16 +0530
Subject: cxgb4vf: Enter debugging mode if FW is inaccessible
Patch-mainline: v5.1-rc1
Git-commit: 4a8acef78e170854ce6865e216eff82bda92437d
References: bsc#1136347 jsc#SLE-4683

If we are not able to reach firmware, enter debugging mode that will
help us to get adapter logs.

Signed-off-by: Arjun Vynipadath <arjun@chelsio.com>
Signed-off-by: Vishal Kulkarni <vishal@chelsio.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/chelsio/cxgb4vf/adapter.h      |    1 
 drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c |   45 ++++++++++++++------
 2 files changed, 33 insertions(+), 13 deletions(-)

--- a/drivers/net/ethernet/chelsio/cxgb4vf/adapter.h
+++ b/drivers/net/ethernet/chelsio/cxgb4vf/adapter.h
@@ -411,6 +411,7 @@ enum { /* adapter flags */
 	USING_MSIX         = (1UL << 2),
 	QUEUES_BOUND       = (1UL << 3),
 	ROOT_NO_RELAXED_ORDERING = (1UL << 4),
+	FW_OK              = (1UL << 5),
 };
 
 /*
--- a/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
@@ -845,6 +845,13 @@ static int cxgb4vf_open(struct net_devic
 	struct adapter *adapter = pi->adapter;
 
 	/*
+	 * If we don't have a connection to the firmware there's nothing we
+	 * can do.
+	 */
+	if (!(adapter->flags & FW_OK))
+		return -ENXIO;
+
+	/*
 	 * If this is the first interface that we're opening on the "adapter",
 	 * bring the "adapter" up now.
 	 */
@@ -2720,6 +2727,7 @@ static int adap_init0(struct adapter *ad
 	 */
 	size_nports_qsets(adapter);
 
+	adapter->flags |= FW_OK;
 	return 0;
 }
 
@@ -3084,7 +3092,9 @@ static int cxgb4vf_pci_probe(struct pci_
 
 	err = adap_init0(adapter);
 	if (err)
-		goto err_unmap_bar;
+		dev_err(&pdev->dev,
+			"Adapter initialization failed, error %d. Continuing in debug mode\n",
+			err);
 
 	/* Initialize hash mac addr list */
 	INIT_LIST_HEAD(&adapter->mac_hlist);
@@ -3109,13 +3119,6 @@ static int cxgb4vf_pci_probe(struct pci_
 			break;
 		port_id = ffs(pmask) - 1;
 		pmask &= ~(1 << port_id);
-		viid = t4vf_alloc_vi(adapter, port_id);
-		if (viid < 0) {
-			dev_err(&pdev->dev, "cannot allocate VI for port %d:"
-				" err=%d\n", port_id, viid);
-			err = viid;
-			goto err_free_dev;
-		}
 
 		/*
 		 * Allocate our network device and stitch things together.
@@ -3123,7 +3126,6 @@ static int cxgb4vf_pci_probe(struct pci_
 		netdev = alloc_etherdev_mq(sizeof(struct port_info),
 					   MAX_PORT_QSETS);
 		if (netdev == NULL) {
-			t4vf_free_vi(adapter, viid);
 			err = -ENOMEM;
 			goto err_free_dev;
 		}
@@ -3133,7 +3135,6 @@ static int cxgb4vf_pci_probe(struct pci_
 		pi->adapter = adapter;
 		pi->pidx = pidx;
 		pi->port_id = port_id;
-		pi->viid = viid;
 
 		/*
 		 * Initialize the starting state of our "port" and register
@@ -3160,6 +3161,23 @@ static int cxgb4vf_pci_probe(struct pci_
 		netdev->dev_port = pi->port_id;
 
 		/*
+		 * If we haven't been able to contact the firmware, there's
+		 * nothing else we can do for this "port" ...
+		 */
+		if (!(adapter->flags & FW_OK))
+			continue;
+
+		viid = t4vf_alloc_vi(adapter, port_id);
+		if (viid < 0) {
+			dev_err(&pdev->dev,
+				"cannot allocate VI for port %d: err=%d\n",
+				port_id, viid);
+			err = viid;
+			goto err_free_dev;
+		}
+		pi->viid = viid;
+
+		/*
 		 * Initialize the hardware/software state for the port.
 		 */
 		err = t4vf_port_init(adapter, pidx);
@@ -3302,13 +3320,13 @@ err_free_dev:
 		if (netdev == NULL)
 			continue;
 		pi = netdev_priv(netdev);
-		t4vf_free_vi(adapter, pi->viid);
+		if (pi->viid)
+			t4vf_free_vi(adapter, pi->viid);
 		if (test_bit(pidx, &adapter->registered_device_map))
 			unregister_netdev(netdev);
 		free_netdev(netdev);
 	}
 
-err_unmap_bar:
 	if (!is_t4(adapter->params.chip))
 		iounmap(adapter->bar2);
 
@@ -3381,7 +3399,8 @@ static void cxgb4vf_pci_remove(struct pc
 				continue;
 
 			pi = netdev_priv(netdev);
-			t4vf_free_vi(adapter, pi->viid);
+			if (pi->viid)
+				t4vf_free_vi(adapter, pi->viid);
 			free_netdev(netdev);
 		}
 		iounmap(adapter->regs);
