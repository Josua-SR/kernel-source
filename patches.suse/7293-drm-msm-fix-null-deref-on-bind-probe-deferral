From: Sean Paul <seanpaul@chromium.org>
Date: Thu, 31 May 2018 14:48:58 -0400
Subject: drm/msm: Fix NULL deref on bind/probe deferral
Git-commit: 74d3a3a70775de356b96b5461c3a204a51496fb3
Patch-mainline: v4.18-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

This patch avoids dereferencing msm_host->dev when it is NULL.

If we find ourselves tearing down dsi before calling
(mdp4|mdp5|dpu)_kms_init(), we'll end up in a state where the dev
pointer is NULL and trying to extract priv from it will fail.

This was introduced in a seemingly innocuous commit to ensure the
arguments to msm_gem_put_iova() are correct (even though that
function has been a stub for ~5 years). Correctness FTW! \o/

Fixes: b01884a286b0 drm/msm: use correct aspace pointer in msm_gem_put_iova()
Cc: Daniel Mack <daniel@zonque.org>
Cc: Rob Clark <robdclark@gmail.com>
Signed-off-by: Sean Paul <seanpaul@chromium.org>
Signed-off-by: Rob Clark <robdclark@gmail.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/msm/dsi/dsi_host.c |   12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

--- a/drivers/gpu/drm/msm/dsi/dsi_host.c
+++ b/drivers/gpu/drm/msm/dsi/dsi_host.c
@@ -1066,8 +1066,18 @@ static int dsi_tx_buf_alloc(struct msm_d
 static void dsi_tx_buf_free(struct msm_dsi_host *msm_host)
 {
 	struct drm_device *dev = msm_host->dev;
-	struct msm_drm_private *priv = dev->dev_private;
+	struct msm_drm_private *priv;
 
+	/*
+	 * This is possible if we're tearing down before we've had a chance to
+	 * fully initialize. A very real possibility if our probe is deferred,
+	 * in which case we'll hit msm_dsi_host_destroy() without having run
+	 * through the dsi_tx_buf_alloc().
+	 */
+	if (!dev)
+		return;
+
+	priv = dev->dev_private;
 	if (msm_host->tx_gem_obj) {
 		msm_gem_put_iova(msm_host->tx_gem_obj, priv->kms->aspace);
 		drm_gem_object_put_unlocked(msm_host->tx_gem_obj);
