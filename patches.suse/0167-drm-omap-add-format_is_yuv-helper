From: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date: Thu, 4 May 2017 09:13:32 +0300
Subject: drm/omap: add format_is_yuv() helper
Git-commit: 5edec14c73553941ea80f3527f3be02c071caac6
Patch-mainline: v4.13-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

In a few places the dispc driver needs to know whether the pixel format
is an YUV format. Add a helper to figure that out.

Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/omapdrm/dss/dispc.c |   56 ++++++++++++++----------------------
 1 file changed, 23 insertions(+), 33 deletions(-)

--- a/drivers/gpu/drm/omapdrm/dss/dispc.c
+++ b/drivers/gpu/drm/omapdrm/dss/dispc.c
@@ -978,6 +978,18 @@ static void dispc_ovl_set_color_mode(enu
 	REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), m, 4, 1);
 }
 
+static bool format_is_yuv(enum omap_color_mode color_mode)
+{
+	switch (color_mode) {
+	case OMAP_DSS_COLOR_YUV2:
+	case OMAP_DSS_COLOR_UYVY:
+	case OMAP_DSS_COLOR_NV12:
+		return true;
+	default:
+		return false;
+	}
+}
+
 static void dispc_ovl_configure_burst_type(enum omap_plane_id plane,
 		enum omap_dss_rotation_type rotation_type)
 {
@@ -1703,9 +1715,8 @@ static void dispc_ovl_set_scaling_uv(enu
 
 	if (!dss_has_feature(FEAT_HANDLE_UV_SEPARATE))
 		return;
-	if ((color_mode != OMAP_DSS_COLOR_YUV2 &&
-			color_mode != OMAP_DSS_COLOR_UYVY &&
-			color_mode != OMAP_DSS_COLOR_NV12)) {
+
+	if (!format_is_yuv(color_mode)) {
 		/* reset chroma resampling for RGB formats  */
 		if (plane != OMAP_DSS_WB)
 			REG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), 0, 8, 8);
@@ -2384,19 +2395,9 @@ static int dispc_ovl_setup_common(enum o
 	if (paddr == 0 && rotation_type != OMAP_DSS_ROT_TILER)
 		return -EINVAL;
 
-	switch (color_mode) {
-	case OMAP_DSS_COLOR_YUV2:
-	case OMAP_DSS_COLOR_UYVY:
-	case OMAP_DSS_COLOR_NV12:
-		if (in_width & 1) {
-			DSSERR("input width %d is not even for YUV format\n",
-				in_width);
-			return -EINVAL;
-		}
-		break;
-
-	default:
-		break;
+	if (format_is_yuv(color_mode) && (in_width & 1)) {
+		DSSERR("input width %d is not even for YUV format\n", in_width);
+		return -EINVAL;
 	}
 
 	out_width = out_width == 0 ? width : out_width;
@@ -2433,26 +2434,15 @@ static int dispc_ovl_setup_common(enum o
 		DSSDBG("predecimation %d x %x, new input size %d x %d\n",
 			x_predecim, y_predecim, in_width, in_height);
 
-	switch (color_mode) {
-	case OMAP_DSS_COLOR_YUV2:
-	case OMAP_DSS_COLOR_UYVY:
-	case OMAP_DSS_COLOR_NV12:
-		if (in_width & 1) {
-			DSSDBG("predecimated input width is not even for YUV format\n");
-			DSSDBG("adjusting input width %d -> %d\n",
-				in_width, in_width & ~1);
-
-			in_width &= ~1;
-		}
-		break;
+	if (format_is_yuv(color_mode) && (in_width & 1)) {
+		DSSDBG("predecimated input width is not even for YUV format\n");
+		DSSDBG("adjusting input width %d -> %d\n",
+			in_width, in_width & ~1);
 
-	default:
-		break;
+		in_width &= ~1;
 	}
 
-	if (color_mode == OMAP_DSS_COLOR_YUV2 ||
-			color_mode == OMAP_DSS_COLOR_UYVY ||
-			color_mode == OMAP_DSS_COLOR_NV12)
+	if (format_is_yuv(color_mode))
 		cconv = 1;
 
 	if (ilace && !fieldmode) {
