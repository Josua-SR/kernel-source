From: Saeed Mahameed <saeedm@mellanox.com>
Date: Tue, 8 May 2018 16:17:06 -0700
Subject: net/mlx5e: Vxlan, add sync lock for add/del vxlan port
Patch-mainline: v4.19-rc1
Git-commit: aec4eab9af9606e8a6a1ceab3ec5a15030751876
References: bsc#1103990 FATE#326006

Vxlan API can and will be called from different mlx5 modules, we should
not count on mlx5e private state lock only, hence we introduce a vxlan
private mutex to sync between add/del vxlan port operations.

Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/net/ethernet/mellanox/mlx5/core/vxlan.c |   18 +++++++++++++++---
 1 file changed, 15 insertions(+), 3 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/vxlan.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/vxlan.c
@@ -39,9 +39,10 @@
 struct mlx5_vxlan {
 	struct mlx5_core_dev		*mdev;
 	spinlock_t			lock; /* protect vxlan table */
-	int				num_ports;
 	/* max_num_ports is usuallly 4, 16 buckets is more than enough */
 	DECLARE_HASHTABLE(htable, 4);
+	int				num_ports;
+	struct mutex                    sync_lock; /* sync add/del port HW operations */
 };
 
 struct mlx5_vxlan_port {
@@ -115,17 +116,18 @@ int mlx5_vxlan_add_port(struct mlx5_vxla
 		return 0;
 	}
 
+	mutex_lock(&vxlan->sync_lock);
 	if (vxlan->num_ports >= mlx5_vxlan_max_udp_ports(vxlan->mdev)) {
 		mlx5_core_info(vxlan->mdev,
 			       "UDP port (%d) not offloaded, max number of UDP ports (%d) are already offloaded\n",
 			       port, mlx5_vxlan_max_udp_ports(vxlan->mdev));
 		ret = -ENOSPC;
-		return ret;
+		goto unlock;
 	}
 
 	ret = mlx5_vxlan_core_add_port_cmd(vxlan->mdev, port);
 	if (ret)
-		return ret;
+		goto unlock;
 
 	vxlanp = kzalloc(sizeof(*vxlanp), GFP_KERNEL);
 	if (!vxlanp) {
@@ -141,10 +143,14 @@ int mlx5_vxlan_add_port(struct mlx5_vxla
 	spin_unlock_bh(&vxlan->lock);
 
 	vxlan->num_ports++;
+	mutex_unlock(&vxlan->sync_lock);
 	return 0;
 
 err_delete_port:
 	mlx5_vxlan_core_del_port_cmd(vxlan->mdev, port);
+
+unlock:
+	mutex_unlock(&vxlan->sync_lock);
 	return ret;
 }
 
@@ -154,6 +160,8 @@ int mlx5_vxlan_del_port(struct mlx5_vxla
 	bool remove = false;
 	int ret = 0;
 
+	mutex_lock(&vxlan->sync_lock);
+
 	spin_lock_bh(&vxlan->lock);
 	vxlanp = mlx5_vxlan_lookup_port_locked(vxlan, port);
 	if (!vxlanp) {
@@ -174,6 +182,9 @@ out_unlock:
 		kfree(vxlanp);
 		vxlan->num_ports--;
 	}
+
+	mutex_unlock(&vxlan->sync_lock);
+
 	return ret;
 }
 
@@ -189,6 +200,7 @@ struct mlx5_vxlan *mlx5_vxlan_create(str
 		return ERR_PTR(-ENOMEM);
 
 	vxlan->mdev = mdev;
+	mutex_init(&vxlan->sync_lock);
 	spin_lock_init(&vxlan->lock);
 	hash_init(vxlan->htable);
 
