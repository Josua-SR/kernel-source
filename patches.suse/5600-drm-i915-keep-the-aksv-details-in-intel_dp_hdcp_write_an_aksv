From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Thu, 22 Feb 2018 23:27:32 +0200
Subject: drm/i915: Keep the AKSV details in intel_dp_hdcp_write_an_aksv()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 8159c796b6d7919bd77c84b8b9a4aa2e76f45491
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Let's try to keep the details on the AKSV stuff concentrated
in one place. So move the control bit and +5 data size handling
there.

v2: Increase txbuf[] to include the payload which intel_dp_aux_xfer()
    will still load into the registers even though the hardware
    will ignore it

Cc: Sean Paul <seanpaul@chromium.org>
Cc: Ramalingam C <ramalingam.c@intel.com>
Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20180222212732.4665-1-ville.syrjala@linux.intel.com
Reviewed-by: Ramalingam C <ramalingam.c@intel.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/i915/intel_dp.c |   42 ++++++++++++----------------------------
 1 file changed, 13 insertions(+), 29 deletions(-)

--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@ -1065,29 +1065,11 @@ static uint32_t skl_get_aux_send_ctl(str
 	       DP_AUX_CH_CTL_SYNC_PULSE_SKL(32);
 }
 
-static uint32_t intel_dp_get_aux_send_ctl(struct intel_dp *intel_dp,
-					  bool has_aux_irq,
-					  int send_bytes,
-					  uint32_t aux_clock_divider,
-					  bool aksv_write)
-{
-	uint32_t val = 0;
-
-	if (aksv_write) {
-		send_bytes += 5;
-		val |= DP_AUX_CH_CTL_AUX_AKSV_SELECT;
-	}
-
-	return val | intel_dp->get_aux_send_ctl(intel_dp,
-						has_aux_irq,
-						send_bytes,
-						aux_clock_divider);
-}
-
 static int
 intel_dp_aux_xfer(struct intel_dp *intel_dp,
 		  const uint8_t *send, int send_bytes,
-		  uint8_t *recv, int recv_size, bool aksv_write)
+		  uint8_t *recv, int recv_size,
+		  u32 aux_send_ctl_flags)
 {
 	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
 	struct drm_i915_private *dev_priv =
@@ -1151,11 +1133,12 @@ intel_dp_aux_xfer(struct intel_dp *intel
 	}
 
 	while ((aux_clock_divider = intel_dp->get_aux_clock_divider(intel_dp, clock++))) {
-		u32 send_ctl = intel_dp_get_aux_send_ctl(intel_dp,
-							 has_aux_irq,
-							 send_bytes,
-							 aux_clock_divider,
-							 aksv_write);
+		u32 send_ctl = intel_dp->get_aux_send_ctl(intel_dp,
+							  has_aux_irq,
+							  send_bytes,
+							  aux_clock_divider);
+
+		send_ctl |= aux_send_ctl_flags;
 
 		/* Must try at least 3 times according to DP spec */
 		for (try = 0; try < 5; try++) {
@@ -1285,7 +1268,7 @@ intel_dp_aux_transfer(struct drm_dp_aux
 			memcpy(txbuf + HEADER_SIZE, msg->buffer, msg->size);
 
 		ret = intel_dp_aux_xfer(intel_dp, txbuf, txsize,
-					rxbuf, rxsize, false);
+					rxbuf, rxsize, 0);
 		if (ret > 0) {
 			msg->reply = rxbuf[0] >> 4;
 
@@ -1308,7 +1291,7 @@ intel_dp_aux_transfer(struct drm_dp_aux
 			return -E2BIG;
 
 		ret = intel_dp_aux_xfer(intel_dp, txbuf, txsize,
-					rxbuf, rxsize, false);
+					rxbuf, rxsize, 0);
 		if (ret > 0) {
 			msg->reply = rxbuf[0] >> 4;
 			/*
@@ -5021,7 +5004,7 @@ int intel_dp_hdcp_write_an_aksv(struct i
 				u8 *an)
 {
 	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_dig_port->base.base);
-	uint8_t txbuf[4], rxbuf[2], reply = 0;
+	uint8_t txbuf[4+5] = {}, rxbuf[2], reply = 0;
 	ssize_t dpcd_ret;
 	int ret;
 
@@ -5046,7 +5029,8 @@ int intel_dp_hdcp_write_an_aksv(struct i
 	txbuf[3] = DRM_HDCP_KSV_LEN - 1;
 
 	ret = intel_dp_aux_xfer(intel_dp, txbuf, sizeof(txbuf),
-				rxbuf, sizeof(rxbuf), true);
+				rxbuf, sizeof(rxbuf),
+				DP_AUX_CH_CTL_AUX_AKSV_SELECT);
 	if (ret < 0) {
 		DRM_ERROR("Write Aksv over DP/AUX failed (%d)\n", ret);
 		return ret;
