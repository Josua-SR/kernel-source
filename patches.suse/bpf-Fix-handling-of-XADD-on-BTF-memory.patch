From: Jann Horn <jannh@google.com>
Date: Fri, 17 Apr 2020 02:00:07 +0200
Subject: bpf: Fix handling of XADD on BTF memory
Patch-mainline: v5.7-rc3
Git-commit: 8ff3571f7e1bf3f293cc5e3dc14f2943f4fa7fcf
References: bsc#1155518

check_xadd() can cause check_ptr_to_btf_access() to be executed with
atype==BPF_READ and value_regno==-1 (meaning "just check whether the access
is okay, don't tell me what type it will result in").
Handle that case properly and skip writing type information, instead of
indexing into the registers at index -1 and writing into out-of-bounds
memory.

Note that at least at the moment, you can't actually write through a BTF
pointer, so check_xadd() will reject the program after calling
check_ptr_to_btf_access with atype==BPF_WRITE; but that's after the
verifier has already corrupted memory.

This patch assumes that BTF pointers are not available in unprivileged
programs.

Fixes: 9e15db66136a ("bpf: Implement accurate raw_tp context access via BTF")
Signed-off-by: Jann Horn <jannh@google.com>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200417000007.10734-2-jannh@google.com
Acked-by: Gary Lin <glin@suse.com>

Gary's note:
  The original patch appends the conditional check of "value_regno" to the
  access type check (atype == BPF_READ). Since we didn't backport the
  struct ops patch(*), there is no such check before "ret == SCALAR_VALUE",
  so we only need to check whether "value_regno" is negative or not.
  This patch is modified to provide the equivalent fix.

  (*) 27ae7997a6617 ("bpf: Introduce BPF_PROG_TYPE_STRUCT_OPS")
---
 kernel/bpf/verifier.c |    3 +++
 1 file changed, 3 insertions(+)

--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -2881,6 +2881,9 @@ static int check_ptr_to_btf_access(struc
 	if (ret < 0)
 		return ret;
 
+	if (value_regno < 0)
+		return 0;
+
 	if (ret == SCALAR_VALUE) {
 		mark_reg_unknown(env, regs, value_regno);
 		return 0;
