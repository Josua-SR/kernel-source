From: Ben Skeggs <bskeggs@redhat.com>
Date: Tue, 8 May 2018 20:39:47 +1000
Subject: drm/nouveau/kms/nv50-: plane updates don't always require image_set()
Git-commit: e349a05dc8faad6b27700383945a1783612cbae6
Patch-mainline: v4.18-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

When only the position of a window changes, there's no need to submit
an image update as well.

Will be required to support the overlays, and Volta windows.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/nouveau/dispnv50/base507c.c |    1 
 drivers/gpu/drm/nouveau/dispnv50/wndw.c     |   65 ++++++++++++++--------------
 2 files changed, 33 insertions(+), 33 deletions(-)

--- a/drivers/gpu/drm/nouveau/dispnv50/base507c.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/base507c.c
@@ -185,7 +185,6 @@ base507c_acquire(struct nv50_wndw *wndw,
 	asyh->base.h = asyw->state.fb->height;
 
 	asyw->lut.enable = 1;
-	asyw->set.image = true;
 	return 0;
 }
 
--- a/drivers/gpu/drm/nouveau/dispnv50/wndw.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/wndw.c
@@ -190,7 +190,8 @@ nv50_wndw_atomic_check_acquire_rgb(struc
 }
 
 static int
-nv50_wndw_atomic_check_acquire(struct nv50_wndw *wndw,
+nv50_wndw_atomic_check_acquire(struct nv50_wndw *wndw, bool modeset,
+			       struct nv50_wndw_atom *armw,
 			       struct nv50_wndw_atom *asyw,
 			       struct nv50_head_atom *asyh)
 {
@@ -200,40 +201,44 @@ nv50_wndw_atomic_check_acquire(struct nv
 
 	NV_ATOMIC(drm, "%s acquire\n", wndw->plane.name);
 
-	asyw->image.w = fb->base.width;
-	asyw->image.h = fb->base.height;
-	asyw->image.kind = fb->nvbo->kind;
-
-	ret = nv50_wndw_atomic_check_acquire_rgb(asyw);
-	if (ret)
-		return ret;
-
-	if (asyw->image.kind) {
-		asyw->image.layout = 0;
-		if (drm->client.device.info.chipset >= 0xc0)
-			asyw->image.block = fb->nvbo->mode >> 4;
-		else
-			asyw->image.block = fb->nvbo->mode;
-		asyw->image.pitch[0] = (fb->base.pitches[0] / 4) << 4;
-	} else {
-		asyw->image.layout = 1;
-		asyw->image.block  = 0;
-		asyw->image.pitch[0] = fb->base.pitches[0];
-	}
+	if (asyw->state.fb != armw->state.fb || !armw->visible || modeset) {
+		asyw->image.w = fb->base.width;
+		asyw->image.h = fb->base.height;
+		asyw->image.kind = fb->nvbo->kind;
 
-	ret = wndw->func->acquire(wndw, asyw, asyh);
-	if (ret)
-		return ret;
+		ret = nv50_wndw_atomic_check_acquire_rgb(asyw);
+		if (ret)
+			return ret;
+
+		if (asyw->image.kind) {
+			asyw->image.layout = 0;
+			if (drm->client.device.info.chipset >= 0xc0)
+				asyw->image.block = fb->nvbo->mode >> 4;
+			else
+				asyw->image.block = fb->nvbo->mode;
+			asyw->image.pitch[0] = (fb->base.pitches[0] / 4) << 4;
+		} else {
+			asyw->image.layout = 1;
+			asyw->image.block  = 0;
+			asyw->image.pitch[0] = fb->base.pitches[0];
+		}
 
-	if (asyw->set.image) {
 		if (!(asyh->state.pageflip_flags & DRM_MODE_PAGE_FLIP_ASYNC))
 			asyw->image.interval = 1;
 		else
 			asyw->image.interval = 0;
 		asyw->image.mode = asyw->image.interval ? 0 : 1;
+		asyw->set.image = wndw->func->image_set != NULL;
 	}
 
-	return 0;
+	if (wndw->immd) {
+		asyw->point.x = asyw->state.crtc_x;
+		asyw->point.y = asyw->state.crtc_y;
+		if (memcmp(&armw->point, &asyw->point, sizeof(asyw->point)))
+			asyw->set.point = true;
+	}
+
+	return wndw->func->acquire(wndw, asyw, asyh);
 }
 
 int
@@ -271,12 +276,8 @@ nv50_wndw_atomic_check(struct drm_plane
 
 	/* Calculate new window state. */
 	if (asyw->visible) {
-		asyw->point.x = asyw->state.crtc_x;
-		asyw->point.y = asyw->state.crtc_y;
-		if (memcmp(&armw->point, &asyw->point, sizeof(asyw->point)))
-			asyw->set.point = true;
-
-		ret = nv50_wndw_atomic_check_acquire(wndw, asyw, asyh);
+		ret = nv50_wndw_atomic_check_acquire(wndw, modeset,
+						     armw, asyw, asyh);
 		if (ret)
 			return ret;
 	} else
