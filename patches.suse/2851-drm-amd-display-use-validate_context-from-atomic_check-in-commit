From: Harry Wentland <harry.wentland@amd.com>
Date: Wed, 28 Jun 2017 13:23:04 -0400
Subject: drm/amd/display: Use validate_context from atomic_check in commit
Git-commit: e2c7bb1228bec5b1224b235e90ffa1def8e3900e
Patch-mainline: v4.15-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Acked-by: Harry Wentland <Harry.Wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c |   18 ++--
 drivers/gpu/drm/amd/display/dc/core/dc.c                |   71 +++++-----------
 drivers/gpu/drm/amd/display/dc/core/dc_stream.c         |    6 -
 drivers/gpu/drm/amd/display/dc/dc.h                     |    5 -
 4 files changed, 40 insertions(+), 60 deletions(-)

--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
@@ -2607,6 +2607,7 @@ void amdgpu_dm_atomic_commit_tail(
 					new_stream = dm_state->set[j].stream;
 					break;
 				}
+
 			/*
 			 * this loop saves set mode crtcs
 			 * we needed to enable vblanks once all
@@ -2665,7 +2666,6 @@ void amdgpu_dm_atomic_commit_tail(
 			dm_error("%s: Failed to update stream scaling!\n", __func__);
 	}
 
-
 	/*
 	 * Add streams after required streams from new and replaced streams
 	 * are removed from freesync module
@@ -2693,15 +2693,19 @@ void amdgpu_dm_atomic_commit_tail(
 	}
 
 	/* DC is optimized not to do anything if 'streams' didn't change. */
-	WARN_ON(!dc_commit_validation_set(dm->dc, dm_state->set,
-					  dm_state->set_count));
+	WARN_ON(!dc_commit_context(dm->dc, dm_state->context));
 
 	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
 		struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
 
-		if (acrtc->stream != NULL)
-			acrtc->otg_inst =
-				dc_stream_get_status(acrtc->stream)->primary_otg_inst;
+		if (acrtc->stream != NULL) {
+			const struct dc_stream_status *status = dc_stream_get_status(acrtc->stream);
+
+			if (!status)
+				DC_ERR("got no status for stream %p on acrtc%p\n", acrtc->stream, acrtc);
+			else
+				acrtc->otg_inst = status->primary_otg_inst;
+		}
 	}
 
 	for (i = 0; i < new_crtcs_count; i++) {
@@ -2884,6 +2888,7 @@ static uint32_t update_in_val_sets_strea
 	} else {
 		/* update. relase old stream */
 		dc_stream_release(old_stream);
+
 	}
 
 	return set_count;
@@ -3064,6 +3069,7 @@ int amdgpu_dm_atomic_check(struct drm_de
 						__func__, acrtc->base.base.id);
 				break;
 			}
+			new_stream->priv = acrtc;
 
 			new_streams[new_stream_count] = new_stream;
 			dm_state->set_count = update_in_val_sets_stream(
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -841,18 +841,17 @@ static void program_timing_sync(
 	}
 }
 
-static bool set_changed(
+static bool context_changed(
 		struct core_dc *dc,
-		const struct dc_validation_set set[],
-		uint8_t set_count)
+		struct validate_context *context)
 {
 	uint8_t i;
 
-	if (set_count != dc->current_context->stream_count)
+	if (context->stream_count != dc->current_context->stream_count)
 		return true;
 
 	for (i = 0; i < dc->current_context->stream_count; i++) {
-		if (&dc->current_context->streams[i]->public != set[i].stream)
+		if (&dc->current_context->streams[i]->public != &context->streams[i]->public)
 			return true;
 	}
 
@@ -915,55 +914,37 @@ bool dc_enable_stereo(
 }
 
 /* TODO operate on validation set (or something like it) */
-bool dc_commit_validation_set(
-	const struct dc *dc,
-	const struct dc_validation_set set[],
-	uint8_t set_count)
+bool dc_commit_context(struct dc *dc, struct validate_context *context)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct dc_bios *dcb = core_dc->ctx->dc_bios;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
-	struct validate_context *context;
 	struct pipe_ctx *pipe;
 	int i, j, k, l;
 
-	/* TODO check validation set changed */
-	if (false == set_changed(core_dc, set, set_count))
+	if (!context)
+		dm_logger_write(core_dc->ctx->logger, LOG_ERROR,
+				"%s: dc_commit_context with no context!\n",
+				__func__);
+
+	if (false == context_changed(core_dc, context))
 		return DC_OK;
 
 	dm_logger_write(core_dc->ctx->logger, LOG_DC, "%s: %d streams\n",
-				__func__, set_count);
-
-	for (i = 0; i < set_count; i++)
-		dc_stream_log(set[i].stream,
-			      core_dc->ctx->logger,
-			      LOG_DC);
+				__func__, context->stream_count);
 
-	context = dm_alloc(sizeof(struct validate_context));
-	if (context == NULL)
-		goto context_alloc_fail;
+	for (i = 0; i < context->stream_count; i++) {
+		const struct dc_stream *stream = &context->streams[i]->public;
 
-	/* TODO no need for validation. just rebuild context */
-	/* TODO check context is created deterministically */
-	result = core_dc->res_pool->funcs->validate_with_context(core_dc, set,
-								 set_count,
-								 context,
-								 core_dc->current_context);
-	if (result != DC_OK) {
-		dm_logger_write(core_dc->ctx->logger, LOG_ERROR,
-					"%s: Context validation failed! dc_status:%d\n",
-					__func__,
-					result);
-		BREAK_TO_DEBUGGER();
-		dc_resource_validate_ctx_destruct(context);
-		goto fail;
+		dc_stream_log(stream,
+				core_dc->ctx->logger,
+				LOG_DC);
 	}
 
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		core_dc->hwss.enable_accelerated_mode(core_dc);
 
-	if (result == DC_OK)
-		result = core_dc->hwss.apply_ctx_to_hw(core_dc, context);
+	result = core_dc->hwss.apply_ctx_to_hw(core_dc, context);
 
 	program_timing_sync(core_dc, context);
 
@@ -1000,17 +981,8 @@ bool dc_commit_validation_set(
 				context->streams[i]->public.timing.pix_clk_khz);
 	}
 
-	dc_resource_validate_ctx_destruct(core_dc->current_context);
-	dm_free(core_dc->current_context);
-
-	core_dc->current_context = context;
-
-	return (result == DC_OK);
+	dc_resource_validate_ctx_copy_construct(context, core_dc->current_context);
 
-fail:
-	dm_free(context);
-
-context_alloc_fail:
 	return (result == DC_OK);
 }
 
@@ -1631,7 +1603,10 @@ void dc_update_surfaces_and_stream(struc
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;
 
-			if (srf_updates[i].in_transfer_func)
+			/* TODO find out why check is false */
+			/* TODO with this still not programming some color stuff... panel is dark-ish */
+			/*if (is_new_pipe_surface ||
+					srf_updates[i].in_transfer_func)*/
 				core_dc->hwss.set_input_transfer_func(
 						pipe_ctx, pipe_ctx->surface);
 
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -164,9 +164,11 @@ const struct dc_stream_status *dc_stream
 	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct core_dc *dc = DC_TO_CORE(stream->ctx->dc);
 
-	for (i = 0; i < dc->current_context->stream_count; i++)
-		if (stream == dc->current_context->streams[i])
+	for (i = 0; i < dc->current_context->stream_count; i++) {
+		if (stream == dc->current_context->streams[i]) {
 			return &dc->current_context->stream_status[i];
+		}
+	}
 
 	return NULL;
 }
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
@@ -590,10 +590,7 @@ void dc_resource_validate_ctx_destruct(s
  *   Phy, Encoder, Timing Generator are programmed and enabled.
  *   New streams are enabled with blank stream; no memory read.
  */
-bool dc_commit_validation_set(
-		const struct dc *dc,
-		const struct dc_validation_set set[],
-		uint8_t set_count);
+bool dc_commit_context(struct dc *dc, struct validate_context *context);
 
 /*
  * Set up streams and links associated to drive sinks
