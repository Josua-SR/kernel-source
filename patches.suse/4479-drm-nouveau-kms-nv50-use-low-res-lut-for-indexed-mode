From: Ilia Mirkin <imirkin@alum.mit.edu>
Date: Sat, 30 Dec 2017 23:35:28 -0500
Subject: drm/nouveau/kms/nv50: use "low res" lut for indexed mode
Git-commit: e75182f68b7b3a073e33b89ee4c1688160755930
Patch-mainline: v4.16-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

This is what was done prior to the big refactor in kernel 3.8, and what
was done by xf86-video-nv. Experimentally, it seems like there's some
sort of issue with the high-res lut to be used there. Tested on G92.

This ends up mattering because fbcon/fbdev chooses the C8 fb format for
low-vram systems, which can occur with some IGP-based configurations
with little "stolen" vram.

Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=80675
Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/nouveau/nv50_display.c |    6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

--- a/drivers/gpu/drm/nouveau/nv50_display.c
+++ b/drivers/gpu/drm/nouveau/nv50_display.c
@@ -1805,12 +1805,14 @@ nv50_head_lut_set(struct nv50_head *head
 	if ((push = evo_wait(core, 7))) {
 		if (core->base.user.oclass < G82_DISP_CORE_CHANNEL_DMA) {
 			evo_mthd(push, 0x0840 + (head->base.index * 0x400), 2);
-			evo_data(push, 0xc0000000);
+			evo_data(push, asyh->base.depth == 8 ?
+				 0x80000000 : 0xc0000000);
 			evo_data(push, asyh->lut.offset >> 8);
 		} else
 		if (core->base.user.oclass < GF110_DISP_CORE_CHANNEL_DMA) {
 			evo_mthd(push, 0x0840 + (head->base.index * 0x400), 2);
-			evo_data(push, 0xc0000000);
+			evo_data(push, asyh->base.depth == 8 ?
+				 0x80000000 : 0xc0000000);
 			evo_data(push, asyh->lut.offset >> 8);
 			evo_mthd(push, 0x085c + (head->base.index * 0x400), 1);
 			evo_data(push, asyh->lut.handle);
