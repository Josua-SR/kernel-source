From: Stefan Raspl <raspl@linux.ibm.com>
Subject: net/smc: handle state SMC_PEERFINCLOSEWAIT correctly
Patch-mainline: v4.16-rc1
Git-commit: 5ac92a00aa743e76e86503d58f092830486af39b
References: FATE#325694, LTC#167874, bsc#1113480

Summary:     net/smc: SMC-R MVP
Description: Add latest upstream patches to push SMC-R to the MVP level

Upstream-Description:

             net/smc: handle state SMC_PEERFINCLOSEWAIT correctly

             A state transition from closing state SMC_PEERFINCLOSEWAIT to closing
             state SMC_APPFINCLOSEWAIT is not allowed. Once a closing indication
             from the peer has been received, the socket reaches state SMC_CLOSED.

             And receiving a peer_conn_abort just changes the state of the socket
             into one of the states SMC_PROCESSABORT or SMC_CLOSED;
             sending a peer_conn_abort occurs in smc_close_active() for state
             SMC_PROCESSABORT only.

             Signed-off-by: Ursula Braun <ubraun@linux.vnet.ibm.com>
             Signed-off-by: David S. Miller <davem@davemloft.net>

Signed-off-by: Stefan Raspl <raspl@linux.ibm.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 net/smc/smc_close.c |    7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

--- a/net/smc/smc_close.c
+++ b/net/smc/smc_close.c
@@ -279,7 +279,6 @@ static void smc_close_passive_abort_rece
 	case SMC_APPFINCLOSEWAIT:
 	case SMC_APPCLOSEWAIT1:
 	case SMC_APPCLOSEWAIT2:
-		smc_close_abort(&smc->conn);
 		sk->sk_state = SMC_PROCESSABORT;
 		break;
 	case SMC_PEERCLOSEWAIT1:
@@ -287,7 +286,6 @@ static void smc_close_passive_abort_rece
 		if (txflags->peer_done_writing &&
 		    !smc_close_sent_any_close(&smc->conn)) {
 			/* just shutdown, but not yet closed locally */
-			smc_close_abort(&smc->conn);
 			sk->sk_state = SMC_PROCESSABORT;
 		} else {
 			sk->sk_state = SMC_CLOSED;
@@ -353,7 +351,6 @@ static void smc_close_passive_work(struc
 		/* fall through */
 		/* to check for closing */
 	case SMC_PEERCLOSEWAIT2:
-	case SMC_PEERFINCLOSEWAIT:
 		if (!smc_cdc_rxed_any_close(conn))
 			break;
 		if (sock_flag(sk, SOCK_DEAD) &&
@@ -365,6 +362,10 @@ static void smc_close_passive_work(struc
 			sk->sk_state = SMC_APPFINCLOSEWAIT;
 		}
 		break;
+	case SMC_PEERFINCLOSEWAIT:
+		if (smc_cdc_rxed_any_close(conn))
+			sk->sk_state = SMC_CLOSED;
+		break;
 	case SMC_APPCLOSEWAIT1:
 	case SMC_APPCLOSEWAIT2:
 	case SMC_APPFINCLOSEWAIT:
