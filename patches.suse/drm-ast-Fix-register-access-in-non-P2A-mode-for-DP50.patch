From b821d19a29bfa2d7a8b47307f88f5e9fa92a96cb Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Wed, 21 Apr 2021 13:12:48 +0200
Subject: [PATCH 05/11] drm/ast: Fix register access in non-P2A mode for DP501
Patch-mainline: Never, temporary fixes until upstream resolution
References: bsc#1174416

A code snippet forward-ported from A-Speed downstream driver.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/ast/ast_dp501.c |   53 ++++++++++++++++++++++++++++------------
 drivers/gpu/drm/ast/ast_drv.h   |    1 
 drivers/gpu/drm/ast/ast_main.c  |   13 +++++++++
 3 files changed, 52 insertions(+), 15 deletions(-)

--- a/drivers/gpu/drm/ast/ast_dp501.c
+++ b/drivers/gpu/drm/ast/ast_dp501.c
@@ -176,6 +176,9 @@ bool ast_backup_fw(struct drm_device *de
 	u32 i, data;
 	u32 boot_address;
 
+	if (ast->config_mode != ast_use_p2a)
+		return false;
+
 	data = ast_mindwm(ast, 0x1e6e2100) & 0x01;
 	if (data) {
 		boot_address = get_fw_base(ast);
@@ -194,6 +197,9 @@ static bool ast_launch_m68k(struct drm_d
 	u8 *fw_addr = NULL;
 	u8 jreg;
 
+	if (ast->config_mode != ast_use_p2a)
+		return false;
+
 	data = ast_mindwm(ast, 0x1e6e2100) & 0x01;
 	if (!data) {
 
@@ -250,23 +256,36 @@ static bool ast_launch_m68k(struct drm_d
 	return true;
 }
 
+static u32 ast_peek(struct ast_private *ast, u32 address, u32 offset)
+{
+	if (ast->config_mode == ast_use_p2a)
+		return ast_mindwm(ast, address + offset);
+	else
+		return *(u32 *) (ast->reservedbuffer + offset);
+}
+
 u8 ast_get_dp501_max_clk(struct drm_device *dev)
 {
 	struct ast_private *ast = dev->dev_private;
-	u32 boot_address, offset, data;
+	u32 boot_address, data;
 	u8 linkcap[4], linkrate, linklanes, maxclk = 0xff;
 
-	boot_address = get_fw_base(ast);
+	if (ast->config_mode == ast_use_p2a) {
+		boot_address = get_fw_base(ast);
+	} else {
+		boot_address = 0;
+		if (!ast->reservedbuffer)
+			return 65;	/* 1024x768 as default */
+		ast_peek(ast, boot_address, 0x0000); /* dummy read */
+	}
 
 	/* validate FW version */
-	offset = 0xf000;
-	data = ast_mindwm(ast, boot_address + offset);
+	data = ast_peek(ast, boot_address, 0xf000);
 	if ((data & 0xf0) != 0x10) /* version: 1x */
 		return maxclk;
 
 	/* Read Link Capability */
-	offset  = 0xf014;
-	*(u32 *)linkcap = ast_mindwm(ast, boot_address + offset);
+	*(u32 *)linkcap = ast_peek(ast, boot_address, 0xf014);
 	if (linkcap[2] == 0) {
 		linkrate = linkcap[0];
 		linklanes = linkcap[1];
@@ -281,26 +300,30 @@ u8 ast_get_dp501_max_clk(struct drm_devi
 bool ast_dp501_read_edid(struct drm_device *dev, u8 *ediddata)
 {
 	struct ast_private *ast = dev->dev_private;
-	u32 i, boot_address, offset, data;
-
-	boot_address = get_fw_base(ast);
+	u32 i, boot_address, data;
 
+	if (ast->config_mode == ast_use_p2a) {
+		boot_address = get_fw_base(ast);
+	} else {
+		boot_address = 0;
+		if (!ast->reservedbuffer)
+			return false;
+		ast_peek(ast, boot_address, 0x0000); /* dummy read */
+	}
+	
 	/* validate FW version */
-	offset = 0xf000;
-	data = ast_mindwm(ast, boot_address + offset);
+	data = ast_peek(ast, boot_address, 0xf000);
 	if ((data & 0xf0) != 0x10)
 		return false;
 
 	/* validate PnP Monitor */
-	offset = 0xf010;
-	data = ast_mindwm(ast, boot_address + offset);
+	data = ast_peek(ast, boot_address, 0xf010);
 	if (!(data & 0x01))
 		return false;
 
 	/* Read EDID */
-	offset = 0xf020;
 	for (i = 0; i < 128; i += 4) {
-		data = ast_mindwm(ast, boot_address + offset + i);
+		data = ast_peek(ast, boot_address, 0xf020 + i);
 		*(u32 *)(ediddata + i) = data;
 	}
 
--- a/drivers/gpu/drm/ast/ast_drv.h
+++ b/drivers/gpu/drm/ast/ast_drv.h
@@ -88,6 +88,7 @@ struct ast_private {
 
 	void __iomem *regs;
 	void __iomem *ioregs;
+	void __iomem *reservedbuffer;
 
 	enum ast_chip chip;
 	bool vga2_clone;
--- a/drivers/gpu/drm/ast/ast_main.c
+++ b/drivers/gpu/drm/ast/ast_main.c
@@ -541,6 +541,17 @@ int ast_driver_load(struct drm_device *d
 	if (ret)
 		goto out_free;
 
+	/* map reserved buffer */
+	if (ast->vram_size < pci_resource_len(dev->pdev, 0)) {
+		ast->reservedbuffer =
+			ioremap_nocache(pci_resource_start(ast->dev->pdev, 0) +
+					ast->vram_size,
+					pci_resource_len(dev->pdev, 0) -
+					ast->vram_size);
+		if (!ast->reservedbuffer)
+			DRM_INFO("failed to map reserved buffer\n");
+	}
+
 	drm_mode_config_init(dev);
 
 	dev->mode_config.funcs = (void *)&ast_mode_funcs;
@@ -592,6 +603,8 @@ void ast_driver_unload(struct drm_device
 	drm_mode_config_cleanup(dev);
 
 	ast_mm_fini(ast);
+	if (ast->reservedbuffer)
+		iounmap(ast->reservedbuffer);
 	if (ast->ioregs != ast->regs + AST_IO_MM_OFFSET)
 		pci_iounmap(dev->pdev, ast->ioregs);
 	pci_iounmap(dev->pdev, ast->regs);
