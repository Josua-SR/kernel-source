From b821d19a29bfa2d7a8b47307f88f5e9fa92a96cb Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Wed, 21 Apr 2021 13:12:48 +0200
Subject: [PATCH 05/11] drm/ast: Fix register access in non-P2A mode for DP501
Patch-mainline: Never, temporary fixes until upstream resolution
References: bsc#1174416

A code snippet forward-ported from A-Speed downstream driver.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/ast/ast_dp501.c | 51 ++++++++++++++++++++++++---------
 drivers/gpu/drm/ast/ast_drv.h   |  1 +
 drivers/gpu/drm/ast/ast_main.c  | 17 +++++++++++
 3 files changed, 55 insertions(+), 14 deletions(-)

diff --git a/drivers/gpu/drm/ast/ast_dp501.c b/drivers/gpu/drm/ast/ast_dp501.c
index 8427bc8a9bd1..e7a1023c6504 100644
--- a/drivers/gpu/drm/ast/ast_dp501.c
+++ b/drivers/gpu/drm/ast/ast_dp501.c
@@ -179,6 +179,9 @@ bool ast_backup_fw(struct drm_device *dev, u8 *addr, u32 size)
 	u32 i, data;
 	u32 boot_address;
 
+	if (ast->config_mode != ast_use_p2a)
+		return false;
+
 	data = ast_mindwm(ast, 0x1e6e2100) & 0x01;
 	if (data) {
 		boot_address = get_fw_base(ast);
@@ -197,6 +200,9 @@ static bool ast_launch_m68k(struct drm_device *dev)
 	u8 *fw_addr = NULL;
 	u8 jreg;
 
+	if (ast->config_mode != ast_use_p2a)
+		return false;
+
 	data = ast_mindwm(ast, 0x1e6e2100) & 0x01;
 	if (!data) {
 
@@ -253,23 +259,36 @@ static bool ast_launch_m68k(struct drm_device *dev)
 	return true;
 }
 
+static u32 ast_peek(struct ast_private *ast, u32 address, u32 offset)
+{
+	if (ast->config_mode == ast_use_p2a)
+		return ast_mindwm(ast, address + offset);
+	else
+		return *(u32 *) (ast->reservedbuffer + offset);
+}
+
 u8 ast_get_dp501_max_clk(struct drm_device *dev)
 {
 	struct ast_private *ast = to_ast_private(dev);
-	u32 boot_address, offset, data;
+	u32 boot_address, data;
 	u8 linkcap[4], linkrate, linklanes, maxclk = 0xff;
 
-	boot_address = get_fw_base(ast);
+	if (ast->config_mode == ast_use_p2a) {
+		boot_address = get_fw_base(ast);
+	} else {
+		boot_address = 0;
+		if (!ast->reservedbuffer)
+			return 65;	/* 1024x768 as default */
+		ast_peek(ast, boot_address, 0x0000); /* dummy read */
+	}
 
 	/* validate FW version */
-	offset = 0xf000;
-	data = ast_mindwm(ast, boot_address + offset);
+	data = ast_peek(ast, boot_address, 0xf000);
 	if ((data & 0xf0) != 0x10) /* version: 1x */
 		return maxclk;
 
 	/* Read Link Capability */
-	offset  = 0xf014;
-	*(u32 *)linkcap = ast_mindwm(ast, boot_address + offset);
+	*(u32 *)linkcap = ast_peek(ast, boot_address, 0xf014);
 	if (linkcap[2] == 0) {
 		linkrate = linkcap[0];
 		linklanes = linkcap[1];
@@ -284,26 +303,30 @@ u8 ast_get_dp501_max_clk(struct drm_device *dev)
 bool ast_dp501_read_edid(struct drm_device *dev, u8 *ediddata)
 {
 	struct ast_private *ast = to_ast_private(dev);
-	u32 i, boot_address, offset, data;
+	u32 i, boot_address, data;
 
-	boot_address = get_fw_base(ast);
+	if (ast->config_mode == ast_use_p2a) {
+		boot_address = get_fw_base(ast);
+	} else {
+		boot_address = 0;
+		if (!ast->reservedbuffer)
+			return false;
+		ast_peek(ast, boot_address, 0x0000); /* dummy read */
+	}
 
 	/* validate FW version */
-	offset = 0xf000;
-	data = ast_mindwm(ast, boot_address + offset);
+	data = ast_peek(ast, boot_address, 0xf000);
 	if ((data & 0xf0) != 0x10)
 		return false;
 
 	/* validate PnP Monitor */
-	offset = 0xf010;
-	data = ast_mindwm(ast, boot_address + offset);
+	data = ast_peek(ast, boot_address, 0xf010);
 	if (!(data & 0x01))
 		return false;
 
 	/* Read EDID */
-	offset = 0xf020;
 	for (i = 0; i < 128; i += 4) {
-		data = ast_mindwm(ast, boot_address + offset + i);
+		data = ast_peek(ast, boot_address, 0xf020 + i);
 		*(u32 *)(ediddata + i) = data;
 	}
 
diff --git a/drivers/gpu/drm/ast/ast_drv.h b/drivers/gpu/drm/ast/ast_drv.h
index e3a264ac7ee2..a3cfa943d90c 100644
--- a/drivers/gpu/drm/ast/ast_drv.h
+++ b/drivers/gpu/drm/ast/ast_drv.h
@@ -104,6 +104,7 @@ struct ast_private {
 
 	void __iomem *regs;
 	void __iomem *ioregs;
+	void __iomem *reservedbuffer;
 
 	enum ast_chip chip;
 	bool vga2_clone;
diff --git a/drivers/gpu/drm/ast/ast_main.c b/drivers/gpu/drm/ast/ast_main.c
index 93df685e5773..e16ea888d012 100644
--- a/drivers/gpu/drm/ast/ast_main.c
+++ b/drivers/gpu/drm/ast/ast_main.c
@@ -384,6 +384,7 @@ static int ast_get_dram_info(struct drm_device *dev)
 int ast_driver_load(struct drm_device *dev, unsigned long flags)
 {
 	struct ast_private *ast;
+	unsigned int vram_size;
 	bool need_post;
 	int ret = 0;
 
@@ -434,6 +435,20 @@ int ast_driver_load(struct drm_device *dev, unsigned long flags)
 	if (ret)
 		goto out_free;
 
+	/* map reserved buffer */
+	vram_size = ast->dev->vram_mm->vram_size;
+	if (vram_size < pci_resource_len(dev->pdev, 0)) {
+		ast->reservedbuffer =
+			ioremap_nocache(pci_resource_start(ast->dev->pdev, 0) +
+					vram_size,
+					pci_resource_len(dev->pdev, 0) - vram_size);
+		if (!ast->reservedbuffer) {
+			DRM_INFO("failed to map reserved buffer\n");
+			ret = -EIO;
+			goto out_free;
+		}
+	}
+
 	ret = ast_mode_config_init(ast);
 	if (ret)
 		goto out_free;
@@ -452,6 +467,8 @@ void ast_driver_unload(struct drm_device *dev)
 	/* enable standard VGA decode */
 	ast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa1, 0x04);
 
+	if (ast->reservedbuffer)
+		iounmap(ast->reservedbuffer);
 	ast_release_firmware(dev);
 	kfree(ast->dp501_fw_addr);
 
-- 
2.26.2

