From 02b1a74c9cc13e1a254ac71b17568e676e2697b3 Mon Sep 17 00:00:00 2001
From: Daniel Wagner <dwagner@suse.de>
Date: Thu, 7 Nov 2019 13:31:30 +0100
Subject: [PATCH] Revert "printk/panic: Avoid deadlock in printk() after
 stopping CPUs"
Patch-mainline: Never, -RT specific
References: SLE Realtime Extension

Revert fdaa896e840a ("printk/panic: Avoid deadlock in printk() after
stopping CPUs by NMI (bsc#1148712).") because it conflicts with the
printk() rewrite from John Ogness.

Signed-off-by: Daniel Wagner <dwagner@suse.de>
---
 arch/x86/kernel/crash.c |    1 -
 include/linux/printk.h  |    6 ------
 kernel/printk/printk.c  |   16 ----------------
 3 files changed, 23 deletions(-)

--- a/arch/x86/kernel/crash.c
+++ b/arch/x86/kernel/crash.c
@@ -99,7 +99,6 @@ static void kdump_nmi_callback(int cpu,
 void kdump_nmi_shootdown_cpus(void)
 {
 	nmi_shootdown_cpus(kdump_nmi_callback);
-	printk_bust_locks();
 
 	disable_local_APIC();
 }
--- a/include/linux/printk.h
+++ b/include/linux/printk.h
@@ -194,8 +194,6 @@ devkmsg_sysctl_set_loglvl(struct ctl_tab
 
 extern void wake_up_klogd(void);
 
-void printk_bust_locks(void);
-
 char *log_buf_addr_get(void);
 u32 log_buf_len_get(void);
 void log_buf_vmcoreinfo_setup(void);
@@ -237,10 +235,6 @@ static inline void wake_up_klogd(void)
 {
 }
 
-static void printk_bust_locks(void)
-{
-}
-
 static inline char *log_buf_addr_get(void)
 {
 	return NULL;
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1626,22 +1626,6 @@ static struct task_struct *console_owner
 static bool console_waiter;
 
 /**
- * printk_bust_locks - forcibly reset all printk-related locks
- *
- * This function can be used after CPUs were stopped using NMI.
- * It is especially useful in kdump_nmi_shootdown_cpus() that
- * uses NMI but it does not modify the online CPU mask.
- */
-void printk_bust_locks(void)
-{
-	debug_locks_off();
-	raw_spin_lock_init(&logbuf_lock);
-	raw_spin_lock_init(&console_owner_lock);
-	console_owner = NULL;
-	console_waiter = false;
-}
-
-/**
  * console_lock_spinning_enable - mark beginning of code where another
  *	thread might safely busy wait
  *
