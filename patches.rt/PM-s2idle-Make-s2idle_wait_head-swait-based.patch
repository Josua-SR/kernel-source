From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date: Fri, 25 May 2018 10:05:13 +0200
Subject: PM / s2idle: Make s2idle_wait_head swait based
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/rt/linux-rt-devel.git
Git-commit: 39f8eb7b817c5ac2aa0c675975b02a9b3a744675
Patch-mainline: Queued in subsystem maintainer repository
References: SLE Realtime Extension

[ Upstream commit 93f141324d4860a1294e6899923c01ec5411d70b ]

s2idle_wait_head is used during s2idle with interrupts disabled even on
RT. There is no "custom" wake up function so swait could be used instead
which is also lower weight compared to the wait_queue.
Make s2idle_wait_head a swait_queue_head.

Mike: adjust for missing 690cbb90a709..23d5855f477 rename series, in
particular the suspend_freeze_wait_head -> s2idle_wait_head rename.

Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
Signed-off-by: Mike Galbraith <mgalbraith@suse.de>
---
 kernel/power/suspend.c |    7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -25,6 +25,7 @@
 #include <linux/export.h>
 #include <linux/suspend.h>
 #include <linux/syscore_ops.h>
+#include <linux/swait.h>
 #include <linux/ftrace.h>
 #include <trace/events/power.h>
 #include <linux/compiler.h>
@@ -53,7 +54,7 @@ EXPORT_SYMBOL_GPL(pm_suspend_global_flag
 
 static const struct platform_suspend_ops *suspend_ops;
 static const struct platform_freeze_ops *freeze_ops;
-static DECLARE_WAIT_QUEUE_HEAD(suspend_freeze_wait_head);
+static DECLARE_SWAIT_QUEUE_HEAD(suspend_freeze_wait_head);
 
 enum freeze_state __read_mostly suspend_freeze_state;
 static DEFINE_SPINLOCK(suspend_freeze_lock);
@@ -87,7 +88,7 @@ static void freeze_enter(void)
 	/* Push all the CPUs into the idle loop. */
 	wake_up_all_idle_cpus();
 	/* Make the current CPU wait so it can enter the idle loop too. */
-	wait_event(suspend_freeze_wait_head,
+	swait_event(suspend_freeze_wait_head,
 		   suspend_freeze_state == FREEZE_STATE_WAKE);
 
 	cpuidle_pause();
@@ -132,7 +133,7 @@ void freeze_wake(void)
 	spin_lock_irqsave(&suspend_freeze_lock, flags);
 	if (suspend_freeze_state > FREEZE_STATE_NONE) {
 		suspend_freeze_state = FREEZE_STATE_WAKE;
-		wake_up(&suspend_freeze_wait_head);
+		swake_up(&suspend_freeze_wait_head);
 	}
 	spin_unlock_irqrestore(&suspend_freeze_lock, flags);
 }
