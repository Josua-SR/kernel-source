From: Thomas Gleixner <tglx@linutronix.de>
Date: Sat, 1 Apr 2017 12:51:00 +0200
Subject: rtmutex: Provide rt_mutex_lock_state()
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/rt/linux-rt-devel.git
Git-commit: 3f31a31b2461453f98d4e984c55aa4b57104a4b4
Patch-mainline: Queued in subsystem maintainer repository
References: SLE15 Realtime Extension

Allow rtmutex to be locked with arbitrary states. Preparatory patch for the
rt rwsem rework.

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Signed-off-by: Mike Galbraith <mgalbraith@suse.de>
---
 include/linux/rtmutex.h  |    1 +
 kernel/locking/rtmutex.c |   41 +++++++++++++++++++++++------------------
 2 files changed, 24 insertions(+), 18 deletions(-)

--- a/include/linux/rtmutex.h
+++ b/include/linux/rtmutex.h
@@ -106,6 +106,7 @@ extern void __rt_mutex_init(struct rt_mu
 extern void rt_mutex_destroy(struct rt_mutex *lock);
 
 extern void rt_mutex_lock(struct rt_mutex *lock);
+extern int rt_mutex_lock_state(struct rt_mutex *lock, int state);
 extern int rt_mutex_lock_interruptible(struct rt_mutex *lock);
 extern int rt_mutex_lock_killable(struct rt_mutex *lock);
 extern int rt_mutex_timed_lock(struct rt_mutex *lock,
--- a/kernel/locking/rtmutex.c
+++ b/kernel/locking/rtmutex.c
@@ -1488,16 +1488,33 @@ rt_mutex_fastunlock(struct rt_mutex *loc
 }
 
 /**
- * rt_mutex_lock - lock a rt_mutex
+ * rt_mutex_lock_state - lock a rt_mutex with a given state
  *
- * @lock: the rt_mutex to be locked
+ * @lock:	The rt_mutex to be locked
+ * @state:	The state to set when blocking on the rt_mutex
  */
-void __sched rt_mutex_lock(struct rt_mutex *lock)
+int __sched rt_mutex_lock_state(struct rt_mutex *lock, int state)
 {
+	int ret;
+
 	might_sleep();
 
 	mutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);
-	rt_mutex_fastlock(lock, TASK_UNINTERRUPTIBLE, rt_mutex_slowlock);
+	ret = rt_mutex_fastlock(lock, state, rt_mutex_slowlock);
+	if (ret)
+		mutex_release(&lock->dep_map, 1, _RET_IP_);
+
+	return ret;
+}
+
+/**
+ * rt_mutex_lock - lock a rt_mutex
+ *
+ * @lock: the rt_mutex to be locked
+ */
+void __sched rt_mutex_lock(struct rt_mutex *lock)
+{
+	rt_mutex_lock_state(lock, TASK_UNINTERRUPTIBLE);
 }
 EXPORT_SYMBOL_GPL(rt_mutex_lock);
 
@@ -1512,16 +1529,7 @@ EXPORT_SYMBOL_GPL(rt_mutex_lock);
  */
 int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)
 {
-	int ret;
-
-	might_sleep();
-
-	mutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);
-	ret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);
-	if (ret)
-		mutex_release(&lock->dep_map, 1, _RET_IP_);
-
-	return ret;
+	return rt_mutex_lock_state(lock, TASK_INTERRUPTIBLE);
 }
 EXPORT_SYMBOL_GPL(rt_mutex_lock_interruptible);
 
@@ -1542,7 +1550,6 @@ int __sched __rt_mutex_futex_trylock(str
  * rt_mutex_lock_killable - lock a rt_mutex killable
  *
  * @lock:              the rt_mutex to be locked
- * @detect_deadlock:   deadlock detection on/off
  *
  * Returns:
  *  0          on success
@@ -1551,9 +1558,7 @@ int __sched __rt_mutex_futex_trylock(str
  */
 int __sched rt_mutex_lock_killable(struct rt_mutex *lock)
 {
-	might_sleep();
-
-	return rt_mutex_fastlock(lock, TASK_KILLABLE, rt_mutex_slowlock);
+	return rt_mutex_lock_state(lock, TASK_KILLABLE);
 }
 EXPORT_SYMBOL_GPL(rt_mutex_lock_killable);
 
