From: Jens Axboe <axboe@kernel.dk>
Date: Wed, 8 Apr 2020 09:20:54 -0600
Subject: [PATCH] io_uring: ensure openat sets O_LARGEFILE if needed
References: bnc#1012628
Patch-mainline: 5.6.5
Git-commit: 08a1d26eb894a9dcf79f674558a284ad1ffef517

commit 08a1d26eb894a9dcf79f674558a284ad1ffef517 upstream.

OPENAT2 correctly sets O_LARGEFILE if it has to, but that escaped the
OPENAT opcode. Dmitry reports that his test case that compares openat()
and IORING_OP_OPENAT sees failures on large files:

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 fs/io_uring.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/fs/io_uring.c b/fs/io_uring.c
index bdcffd78fbb9..1a72933ac371 100644
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@ -2571,6 +2571,8 @@ static int io_openat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)
 	req->open.how.mode = READ_ONCE(sqe->len);
 	fname = u64_to_user_ptr(READ_ONCE(sqe->addr));
 	req->open.how.flags = READ_ONCE(sqe->open_flags);
+	if (force_o_largefile())
+		req->open.how.flags |= O_LARGEFILE;
 
 	req->open.filename = getname(fname);
 	if (IS_ERR(req->open.filename)) {
-- 
2.26.1

