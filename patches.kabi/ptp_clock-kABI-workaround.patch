From: Takashi Iwai <tiwai@suse.de>
Subject: kABI workaround for ptp_clock struct change
Patch-mainline: Never, kABI workaround
References: CVE-2020-10690 bsc#1170056

The patch
  patches.suse/ptp-fix-the-race-between-the-release-of-ptp_clock-an.patch
changed the dev field of struct ptp_clock from the pointer to the
embedded device object, and it breaks kABI.
For restoring kABI compatibility, revert to the struct device pointer
again and allocate the object dynamically.

Also, struct posix_clock was modified to restore kref field.
It means that struct posix_clock won't be compatible while the size is
still kept.  Since the access to the object is limited to
posix_clock_register() and its caller is only ptp core, we'll break the
kABI for that intentionally.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/ptp/ptp_clock.c     |   27 +++++++++++++++++----------
 drivers/ptp/ptp_private.h   |    2 +-
 include/linux/posix-clock.h |   12 +++++++++++-
 3 files changed, 29 insertions(+), 12 deletions(-)

--- a/drivers/ptp/ptp_clock.c
+++ b/drivers/ptp/ptp_clock.c
@@ -176,13 +176,14 @@ static struct posix_clock_operations ptp
 
 static void ptp_clock_release(struct device *dev)
 {
-	struct ptp_clock *ptp = container_of(dev, struct ptp_clock, dev);
+	struct ptp_clock *ptp = dev_get_drvdata(dev);
 
 	ptp_cleanup_pin_groups(ptp);
 	mutex_destroy(&ptp->tsevq_mux);
 	mutex_destroy(&ptp->pincfg_mux);
 	ida_simple_remove(&ptp_clocks_map, ptp->index);
 	kfree(ptp);
+	kfree(dev);
 }
 
 /* public interface */
@@ -236,18 +237,23 @@ struct ptp_clock *ptp_clock_register(str
 		}
 	}
 
+	ptp->dev = kzalloc(sizeof(*ptp->dev), GFP_KERNEL);
+	if (!ptp->dev) {
+		err = -ENOMEM;
+		goto no_clock;
+	}
 	/* Initialize a new device of our class in our clock structure. */
-	device_initialize(&ptp->dev);
-	ptp->dev.devt = ptp->devid;
-	ptp->dev.class = ptp_class;
-	ptp->dev.parent = parent;
-	ptp->dev.groups = ptp->pin_attr_groups;
-	ptp->dev.release = ptp_clock_release;
-	dev_set_drvdata(&ptp->dev, ptp);
-	dev_set_name(&ptp->dev, "ptp%d", ptp->index);
+	device_initialize(ptp->dev);
+	ptp->dev->devt = ptp->devid;
+	ptp->dev->class = ptp_class;
+	ptp->dev->parent = parent;
+	ptp->dev->groups = ptp->pin_attr_groups;
+	ptp->dev->release = ptp_clock_release;
+	dev_set_drvdata(ptp->dev, ptp);
+	dev_set_name(ptp->dev, "ptp%d", ptp->index);
 
 	/* Create a posix clock and link it to the device. */
-	err = posix_clock_register(&ptp->clock, &ptp->dev);
+	err = posix_clock_register(&ptp->clock, ptp->dev);
 	if (err) {
 		pr_err("failed to create posix clock\n");
 		goto no_clock;
@@ -256,6 +262,7 @@ struct ptp_clock *ptp_clock_register(str
 	return ptp;
 
 no_clock:
+	kfree(ptp->dev);
 	if (ptp->pps_source)
 		pps_unregister_source(ptp->pps_source);
 no_pps:
--- a/drivers/ptp/ptp_private.h
+++ b/drivers/ptp/ptp_private.h
@@ -40,7 +40,7 @@ struct timestamp_event_queue {
 
 struct ptp_clock {
 	struct posix_clock clock;
-	struct device dev;
+	struct device *dev; /* XXX: changed back to a pointer for kABI */
 	struct ptp_clock_info *info;
 	dev_t devid;
 	int index; /* index into clocks.map */
--- a/include/linux/posix-clock.h
+++ b/include/linux/posix-clock.h
@@ -120,9 +120,19 @@ struct posix_clock_operations {
 struct posix_clock {
 	struct posix_clock_operations ops;
 	struct cdev cdev;
-	struct device *dev;
+#ifdef __GENKSYMS__
+	struct kref kref;
+#else
+	union {
+		struct kref kref;
+		struct device *dev;
+	};
+#endif
 	struct rw_semaphore rwsem;
 	bool zombie;
+#ifdef __GENKSYMS__
+	void (*release)(struct posix_clock *clk); /* placeholder */
+#endif
 };
 
 /**
